{"sha": "d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZDQyMDZlNTYwNGI4NmZjNGE5YjI4YThiNTFkOTkxMjFjYzNhNWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-22T12:49:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-22T12:49:06Z"}, "message": "Auto merge of #26683 - eefriedman:const-eval-hint, r=pnkfelix\n\nThe \"hint\" mechanism is essentially used as a workaround to compute\r\ntypes for expressions which have not yet been type-checked. This\r\ncommit clarifies that usage, and limits the effects to the places\r\nwhere it is currently necessary.\r\n\r\nFixes #26210.", "tree": {"sha": "2b46c7caa8b19a1e5c6393c8648f11644260f246", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b46c7caa8b19a1e5c6393c8648f11644260f246"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "html_url": "https://github.com/rust-lang/rust/commit/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25281b121ff809f35a6abd7d2d115995436c3319", "url": "https://api.github.com/repos/rust-lang/rust/commits/25281b121ff809f35a6abd7d2d115995436c3319", "html_url": "https://github.com/rust-lang/rust/commit/25281b121ff809f35a6abd7d2d115995436c3319"}, {"sha": "6bdfb0534737b371e3b3e4abdec2f5dffd629916", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bdfb0534737b371e3b3e4abdec2f5dffd629916", "html_url": "https://github.com/rust-lang/rust/commit/6bdfb0534737b371e3b3e4abdec2f5dffd629916"}], "stats": {"total": 312, "additions": 194, "deletions": 118}, "files": [{"sha": "4e21efcf9eb6b12dbc9d825ea95e85d4242577ac", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "patch": "@@ -335,6 +335,24 @@ This error indicates that an attempt was made to divide by zero (or take the\n remainder of a zero divisor) in a static or constant expression.\n \"##,\n \n+E0030: r##\"\n+When matching against a range, the compiler verifies that the range is\n+non-empty.  Range patterns include both end-points, so this is equivalent to\n+requiring the start of the range to be less than or equal to the end of the\n+range.\n+\n+For example:\n+\n+```\n+match 5u32 {\n+    // This range is ok, albeit pointless.\n+    1 ... 1 => ...\n+    // This range is empty, and the compiler can tell.\n+    1000 ... 5 => ...\n+}\n+```\n+\"##,\n+\n E0079: r##\"\n Enum variants which contain no data can be given a custom integer\n representation. This error indicates that the value provided is not an"}, {"sha": "baaf6b6a0401d545355bf109e1435418983485d4", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "patch": "@@ -26,6 +26,7 @@\n \n use middle::cast::{CastKind};\n use middle::const_eval;\n+use middle::const_eval::EvalHint::ExprTypeChecked;\n use middle::def;\n use middle::expr_use_visitor as euv;\n use middle::infer;\n@@ -39,6 +40,7 @@ use syntax::codemap::Span;\n use syntax::visit::{self, Visitor};\n \n use std::collections::hash_map::Entry;\n+use std::cmp::Ordering;\n \n // Const qualification, from partial to completely promotable.\n bitflags! {\n@@ -365,6 +367,19 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n             ast::PatRange(ref start, ref end) => {\n                 self.global_expr(Mode::Const, &**start);\n                 self.global_expr(Mode::Const, &**end);\n+\n+                match const_eval::compare_lit_exprs(self.tcx, start, end) {\n+                    Some(Ordering::Less) |\n+                    Some(Ordering::Equal) => {}\n+                    Some(Ordering::Greater) => {\n+                        span_err!(self.tcx.sess, start.span, E0030,\n+                            \"lower range bound must be less than or equal to upper\");\n+                    }\n+                    None => {\n+                        self.tcx.sess.span_bug(\n+                            start.span, \"literals of different types in range pat\");\n+                    }\n+                }\n             }\n             _ => visit::walk_pat(self, p)\n         }\n@@ -457,7 +472,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 match node_ty.sty {\n                     ty::TyUint(_) | ty::TyInt(_) if div_or_rem => {\n                         if !self.qualif.intersects(ConstQualif::NOT_CONST) {\n-                            match const_eval::eval_const_expr_partial(self.tcx, ex, None) {\n+                            match const_eval::eval_const_expr_partial(\n+                                    self.tcx, ex, ExprTypeChecked) {\n                                 Ok(_) => {}\n                                 Err(msg) => {\n                                     span_err!(self.tcx.sess, msg.span, E0020,"}, {"sha": "d8c2341df2d9f487c54bfd5d775f747cae47290e", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "patch": "@@ -15,6 +15,7 @@ use self::WitnessPreference::*;\n use middle::const_eval::{compare_const_vals, ConstVal};\n use middle::const_eval::{eval_const_expr, eval_const_expr_partial};\n use middle::const_eval::{const_expr_to_pat, lookup_const_by_id};\n+use middle::const_eval::EvalHint::ExprTypeChecked;\n use middle::def::*;\n use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};\n use middle::expr_use_visitor::{JustWrite, LoanCause, MutateMode};\n@@ -263,7 +264,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n     ast_util::walk_pat(pat, |p| {\n         if let ast::PatLit(ref expr) = p.node {\n-            match eval_const_expr_partial(cx.tcx, &**expr, None) {\n+            match eval_const_expr_partial(cx.tcx, &**expr, ExprTypeChecked) {\n                 Ok(ConstVal::Float(f)) if f.is_nan() => {\n                     span_warn!(cx.tcx.sess, p.span, E0003,\n                                \"unmatchable NaN in pattern, \\"}, {"sha": "9e2bcbaec8a6ccd83d51c08fedb15c5cbbea99b2", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 115, "deletions": 56, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "patch": "@@ -11,8 +11,8 @@\n #![allow(non_camel_case_types)]\n \n use self::ConstVal::*;\n-\n use self::ErrKind::*;\n+use self::EvalHint::*;\n \n use ast_map;\n use ast_map::blocks::FnLikeNode;\n@@ -345,7 +345,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n }\n \n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> ConstVal {\n-    match eval_const_expr_partial(tcx, e, None) {\n+    match eval_const_expr_partial(tcx, e, ExprTypeChecked) {\n         Ok(r) => r,\n         Err(s) => tcx.sess.span_fatal(s.span, &s.description())\n     }\n@@ -434,6 +434,28 @@ impl ConstEvalErr {\n pub type EvalResult = Result<ConstVal, ConstEvalErr>;\n pub type CastResult = Result<ConstVal, ErrKind>;\n \n+// FIXME: Long-term, this enum should go away: trying to evaluate\n+// an expression which hasn't been type-checked is a recipe for\n+// disaster.  That said, it's not clear how to fix ast_ty_to_ty\n+// to avoid the ordering issue.\n+\n+/// Hint to determine how to evaluate constant expressions which\n+/// might not be type-checked.\n+#[derive(Copy, Clone, Debug)]\n+pub enum EvalHint<'tcx> {\n+    /// We have a type-checked expression.\n+    ExprTypeChecked,\n+    /// We have an expression which hasn't been type-checked, but we have\n+    /// an idea of what the type will be because of the context. For example,\n+    /// the length of an array is always `usize`. (This is referred to as\n+    /// a hint because it isn't guaranteed to be consistent with what\n+    /// type-checking would compute.)\n+    UncheckedExprHint(Ty<'tcx>),\n+    /// We have an expression which has not yet been type-checked, and\n+    /// and we have no clue what the type will be.\n+    UncheckedExprNoHint,\n+}\n+\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum IntTy { I8, I16, I32, I64 }\n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -704,26 +726,34 @@ pub_fn_checked_op!{ const_uint_checked_shr_via_int(a: u64, b: i64,.. UintTy) {\n            uint_shift_body overflowing_shr Uint ShiftRightWithOverflow\n }}\n \n-// After type checking, `eval_const_expr_partial` should always suffice. The\n-// reason for providing `eval_const_expr_with_substs` is to allow\n-// trait-associated consts to be evaluated *during* type checking, when the\n-// substs for each expression have not been written into `tcx` yet.\n+/// Evaluate a constant expression in a context where the expression isn't\n+/// guaranteed to be evaluatable. `ty_hint` is usually ExprTypeChecked,\n+/// but a few places need to evaluate constants during type-checking, like\n+/// computing the length of an array. (See also the FIXME above EvalHint.)\n pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      e: &Expr,\n-                                     ty_hint: Option<Ty<'tcx>>) -> EvalResult {\n-    eval_const_expr_with_substs(tcx, e, ty_hint, |id| {\n-        tcx.node_id_item_substs(id).substs\n-    })\n-}\n-\n-pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n-                                            e: &Expr,\n-                                            ty_hint: Option<Ty<'tcx>>,\n-                                            get_substs: S) -> EvalResult\n-        where S: Fn(ast::NodeId) -> subst::Substs<'tcx> {\n+                                     ty_hint: EvalHint<'tcx>) -> EvalResult {\n     fn fromb(b: bool) -> ConstVal { Int(b as i64) }\n \n-    let ety = ty_hint.or_else(|| tcx.expr_ty_opt(e));\n+    // Try to compute the type of the expression based on the EvalHint.\n+    // (See also the definition of EvalHint, and the FIXME above EvalHint.)\n+    let ety = match ty_hint {\n+        ExprTypeChecked => {\n+            // After type-checking, expr_ty is guaranteed to succeed.\n+            Some(tcx.expr_ty(e))\n+        }\n+        UncheckedExprHint(ty) => {\n+            // Use the type hint; it's not guaranteed to be right, but it's\n+            // usually good enough.\n+            Some(ty)\n+        }\n+        UncheckedExprNoHint => {\n+            // This expression might not be type-checked, and we have no hint.\n+            // Try to query the context for a type anyway; we might get lucky\n+            // (for example, if the expression was imported from another crate).\n+            tcx.expr_ty_opt(e)\n+        }\n+    };\n \n     // If type of expression itself is int or uint, normalize in these\n     // bindings so that isize/usize is mapped to a type with an\n@@ -739,7 +769,7 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n \n     let result = match e.node {\n       ast::ExprUnary(ast::UnNeg, ref inner) => {\n-        match try!(eval_const_expr_partial(tcx, &**inner, ety)) {\n+        match try!(eval_const_expr_partial(tcx, &**inner, ty_hint)) {\n           Float(f) => Float(-f),\n           Int(n) =>  try!(const_int_checked_neg(n, e, expr_int_type)),\n           Uint(i) => {\n@@ -749,7 +779,7 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n         }\n       }\n       ast::ExprUnary(ast::UnNot, ref inner) => {\n-        match try!(eval_const_expr_partial(tcx, &**inner, ety)) {\n+        match try!(eval_const_expr_partial(tcx, &**inner, ty_hint)) {\n           Int(i) => Int(!i),\n           Uint(i) => const_uint_not(i, expr_uint_type),\n           Bool(b) => Bool(!b),\n@@ -758,10 +788,16 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n       }\n       ast::ExprBinary(op, ref a, ref b) => {\n         let b_ty = match op.node {\n-            ast::BiShl | ast::BiShr => Some(tcx.types.usize),\n-            _ => ety\n+            ast::BiShl | ast::BiShr => {\n+                if let ExprTypeChecked = ty_hint {\n+                    ExprTypeChecked\n+                } else {\n+                    UncheckedExprHint(tcx.types.usize)\n+                }\n+            }\n+            _ => ty_hint\n         };\n-        match (try!(eval_const_expr_partial(tcx, &**a, ety)),\n+        match (try!(eval_const_expr_partial(tcx, &**a, ty_hint)),\n                try!(eval_const_expr_partial(tcx, &**b, b_ty))) {\n           (Float(a), Float(b)) => {\n             match op.node {\n@@ -851,22 +887,25 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n         }\n       }\n       ast::ExprCast(ref base, ref target_ty) => {\n-        // This tends to get called w/o the type actually having been\n-        // populated in the ctxt, which was causing things to blow up\n-        // (#5900). Fall back to doing a limited lookup to get past it.\n         let ety = ety.or_else(|| ast_ty_to_prim_ty(tcx, &**target_ty))\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_fatal(target_ty.span,\n                                         \"target type not found for const cast\")\n                 });\n \n-        // Prefer known type to noop, but always have a type hint.\n-        //\n-        // FIXME (#23833): the type-hint can cause problems,\n-        // e.g. `(i8::MAX + 1_i8) as u32` feeds in `u32` as result\n-        // type to the sum, and thus no overflow is signaled.\n-        let base_hint = tcx.expr_ty_opt(&**base).unwrap_or(ety);\n-        let val = try!(eval_const_expr_partial(tcx, &**base, Some(base_hint)));\n+        let base_hint = if let ExprTypeChecked = ty_hint {\n+            ExprTypeChecked\n+        } else {\n+            // FIXME (#23833): the type-hint can cause problems,\n+            // e.g. `(i8::MAX + 1_i8) as u32` feeds in `u32` as result\n+            // type to the sum, and thus no overflow is signaled.\n+            match tcx.expr_ty_opt(&base) {\n+                Some(t) => UncheckedExprHint(t),\n+                None => ty_hint\n+            }\n+        };\n+\n+        let val = try!(eval_const_expr_partial(tcx, &**base, base_hint));\n         match cast_const(tcx, val, ety) {\n             Ok(val) => val,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n@@ -896,12 +935,16 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n                           def::FromTrait(trait_id) => match tcx.map.find(def_id.node) {\n                               Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n                                   ast::ConstTraitItem(ref ty, _) => {\n-                                      let substs = get_substs(e.id);\n-                                      (resolve_trait_associated_const(tcx,\n-                                                                      ti,\n-                                                                      trait_id,\n-                                                                      substs),\n-                                       Some(&**ty))\n+                                      if let ExprTypeChecked = ty_hint {\n+                                          let substs = tcx.node_id_item_substs(e.id).substs;\n+                                          (resolve_trait_associated_const(tcx,\n+                                                                          ti,\n+                                                                          trait_id,\n+                                                                          substs),\n+                                           Some(&**ty))\n+                                       } else {\n+                                           (None, None)\n+                                       }\n                                   }\n                                   _ => (None, None)\n                               },\n@@ -930,27 +973,42 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n               Some(actual_e) => actual_e,\n               None => signal!(e, NonConstPath)\n           };\n-          let ety = ety.or_else(|| const_ty.and_then(|ty| ast_ty_to_prim_ty(tcx, ty)));\n-          try!(eval_const_expr_partial(tcx, const_expr, ety))\n+          let item_hint = if let UncheckedExprNoHint = ty_hint {\n+              match const_ty {\n+                  Some(ty) => match ast_ty_to_prim_ty(tcx, ty) {\n+                      Some(ty) => UncheckedExprHint(ty),\n+                      None => UncheckedExprNoHint\n+                  },\n+                  None => UncheckedExprNoHint\n+              }\n+          } else {\n+              ty_hint\n+          };\n+          try!(eval_const_expr_partial(tcx, const_expr, item_hint))\n       }\n       ast::ExprLit(ref lit) => {\n           lit_to_const(&**lit, ety)\n       }\n-      ast::ExprParen(ref e) => try!(eval_const_expr_partial(tcx, &**e, ety)),\n+      ast::ExprParen(ref e) => try!(eval_const_expr_partial(tcx, &**e, ty_hint)),\n       ast::ExprBlock(ref block) => {\n         match block.expr {\n-            Some(ref expr) => try!(eval_const_expr_partial(tcx, &**expr, ety)),\n+            Some(ref expr) => try!(eval_const_expr_partial(tcx, &**expr, ty_hint)),\n             None => Int(0)\n         }\n       }\n       ast::ExprTup(_) => Tuple(e.id),\n       ast::ExprStruct(..) => Struct(e.id),\n       ast::ExprTupField(ref base, index) => {\n-        if let Ok(c) = eval_const_expr_partial(tcx, base, None) {\n+        let base_hint = if let ExprTypeChecked = ty_hint {\n+            ExprTypeChecked\n+        } else {\n+            UncheckedExprNoHint\n+        };\n+        if let Ok(c) = eval_const_expr_partial(tcx, base, base_hint) {\n             if let Tuple(tup_id) = c {\n                 if let ast::ExprTup(ref fields) = tcx.map.expect_expr(tup_id).node {\n                     if index.node < fields.len() {\n-                        return eval_const_expr_partial(tcx, &fields[index.node], None)\n+                        return eval_const_expr_partial(tcx, &fields[index.node], base_hint)\n                     } else {\n                         signal!(e, TupleIndexOutOfBounds);\n                     }\n@@ -966,13 +1024,18 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n       }\n       ast::ExprField(ref base, field_name) => {\n         // Get the base expression if it is a struct and it is constant\n-        if let Ok(c) = eval_const_expr_partial(tcx, base, None) {\n+        let base_hint = if let ExprTypeChecked = ty_hint {\n+            ExprTypeChecked\n+        } else {\n+            UncheckedExprNoHint\n+        };\n+        if let Ok(c) = eval_const_expr_partial(tcx, base, base_hint) {\n             if let Struct(struct_id) = c {\n                 if let ast::ExprStruct(_, ref fields, _) = tcx.map.expect_expr(struct_id).node {\n                     // Check that the given field exists and evaluate it\n                     if let Some(f) = fields.iter().find(|f| f.ident.node.as_str()\n                                                          == field_name.node.as_str()) {\n-                        return eval_const_expr_partial(tcx, &*f.expr, None)\n+                        return eval_const_expr_partial(tcx, &*f.expr, base_hint)\n                     } else {\n                         signal!(e, MissingStructField);\n                     }\n@@ -1148,21 +1211,17 @@ pub fn compare_const_vals(a: &ConstVal, b: &ConstVal) -> Option<Ordering> {\n     })\n }\n \n-pub fn compare_lit_exprs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n-                                  a: &Expr,\n-                                  b: &Expr,\n-                                  ty_hint: Option<Ty<'tcx>>,\n-                                  get_substs: S) -> Option<Ordering>\n-        where S: Fn(ast::NodeId) -> subst::Substs<'tcx> {\n-    let a = match eval_const_expr_with_substs(tcx, a, ty_hint,\n-                                              |id| {get_substs(id)}) {\n+pub fn compare_lit_exprs<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                               a: &Expr,\n+                               b: &Expr) -> Option<Ordering> {\n+    let a = match eval_const_expr_partial(tcx, a, ExprTypeChecked) {\n         Ok(a) => a,\n         Err(e) => {\n             tcx.sess.span_err(a.span, &e.description());\n             return None;\n         }\n     };\n-    let b = match eval_const_expr_with_substs(tcx, b, ty_hint, get_substs) {\n+    let b = match eval_const_expr_partial(tcx, b, ExprTypeChecked) {\n         Ok(b) => b,\n         Err(e) => {\n             tcx.sess.span_err(b.span, &e.description());"}, {"sha": "17a76f6eed9c5af59e415b23d4791d3d81e7a973", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "patch": "@@ -45,6 +45,7 @@ use middle;\n use middle::cast;\n use middle::check_const;\n use middle::const_eval::{self, ConstVal};\n+use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def::{self, DefMap, ExportMap};\n use middle::dependency_format;\n use middle::fast_reject;\n@@ -5758,20 +5759,8 @@ impl<'tcx> ctxt<'tcx> {\n                 Some(ref e) => {\n                     debug!(\"disr expr, checking {}\", pprust::expr_to_string(&**e));\n \n-                    // check_expr (from check_const pass) doesn't guarantee\n-                    // that the expression is in a form that eval_const_expr can\n-                    // handle, so we may still get an internal compiler error\n-                    //\n-                    // pnkfelix: The above comment was transcribed from\n-                    // the version of this code taken from rustc_typeck.\n-                    // Presumably the implication is that we need to deal\n-                    // with such ICE's as they arise.\n-                    //\n-                    // Since this can be called from `ty::enum_variants`\n-                    // anyway, best thing is to make `eval_const_expr`\n-                    // more robust (on case-by-case basis).\n-\n-                    match const_eval::eval_const_expr_partial(self, &**e, Some(repr_type_ty)) {\n+                    let hint = UncheckedExprHint(repr_type_ty);\n+                    match const_eval::eval_const_expr_partial(self, &**e, hint) {\n                         Ok(ConstVal::Int(val)) => current_disr_val = val as Disr,\n                         Ok(ConstVal::Uint(val)) => current_disr_val = val as Disr,\n                         Ok(_) => {\n@@ -6086,7 +6075,8 @@ impl<'tcx> ctxt<'tcx> {\n \n     // Returns the repeat count for a repeating vector expression.\n     pub fn eval_repeat_count(&self, count_expr: &ast::Expr) -> usize {\n-        match const_eval::eval_const_expr_partial(self, count_expr, Some(self.types.usize)) {\n+        let hint = UncheckedExprHint(self.types.usize);\n+        match const_eval::eval_const_expr_partial(self, count_expr, hint) {\n             Ok(val) => {\n                 let found = match val {\n                     ConstVal::Uint(count) => return count as usize,"}, {"sha": "ae95466e6e675e4fd60682262ed02f8317c0ba5e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "patch": "@@ -39,6 +39,7 @@ use middle::ty::{self, Ty};\n use middle::traits;\n use middle::{def, pat_util, stability};\n use middle::const_eval::{eval_const_expr_partial, ConstVal};\n+use middle::const_eval::EvalHint::ExprTypeChecked;\n use middle::cfg;\n use rustc::ast_map;\n use util::nodemap::{FnvHashMap, NodeSet};\n@@ -178,7 +179,7 @@ impl LintPass for TypeLimits {\n                             if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n                             else { false }\n                         } else {\n-                            match eval_const_expr_partial(cx.tcx, &**r, Some(cx.tcx.types.usize)) {\n+                            match eval_const_expr_partial(cx.tcx, &**r, ExprTypeChecked) {\n                                 Ok(ConstVal::Int(shift)) => { shift as u64 >= bits },\n                                 Ok(ConstVal::Uint(shift)) => { shift >= bits },\n                                 _ => { false }"}, {"sha": "925da81d77e6bdf4d6ac00c4f7d36f7c85f8018c", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "patch": "@@ -235,8 +235,7 @@ struct ConstantExpr<'a>(&'a ast::Expr);\n \n impl<'a> ConstantExpr<'a> {\n     fn eq(self, other: ConstantExpr<'a>, tcx: &ty::ctxt) -> bool {\n-        match const_eval::compare_lit_exprs(tcx, self.0, other.0, None,\n-                                            |id| {tcx.node_id_item_substs(id).substs}) {\n+        match const_eval::compare_lit_exprs(tcx, self.0, other.0) {\n             Some(result) => result == Ordering::Equal,\n             None => panic!(\"compare_list_exprs: type mismatch\"),\n         }"}, {"sha": "302ef68bddc7d9943fa756d24bcbbd3e76404d71", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "patch": "@@ -23,6 +23,8 @@ use middle::const_eval::{const_int_checked_div, const_uint_checked_div};\n use middle::const_eval::{const_int_checked_rem, const_uint_checked_rem};\n use middle::const_eval::{const_int_checked_shl, const_uint_checked_shl};\n use middle::const_eval::{const_int_checked_shr, const_uint_checked_shr};\n+use middle::const_eval::EvalHint::ExprTypeChecked;\n+use middle::const_eval::eval_const_expr_partial;\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n use trans::common::*;\n@@ -591,7 +593,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         ast::ExprIndex(ref base, ref index) => {\n             let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n-            let iv = match const_eval::eval_const_expr_partial(cx.tcx(), &**index, None) {\n+            let iv = match eval_const_expr_partial(cx.tcx(), &index, ExprTypeChecked) {\n                 Ok(ConstVal::Int(i)) => i as u64,\n                 Ok(ConstVal::Uint(u)) => u,\n                 _ => cx.sess().span_bug(index.span,"}, {"sha": "8f0eef8ba0b3832bb3ffa17f1ae08f78ff530a8f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "patch": "@@ -50,6 +50,7 @@\n \n use middle::astconv_util::{prim_ty_to_ty, check_path_args, NO_TPS, NO_REGIONS};\n use middle::const_eval::{self, ConstVal};\n+use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def;\n use middle::implicator::object_region_bounds;\n use middle::resolve_lifetime as rl;\n@@ -1623,7 +1624,8 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             ty\n         }\n         ast::TyFixedLengthVec(ref ty, ref e) => {\n-            match const_eval::eval_const_expr_partial(tcx, &**e, Some(tcx.types.usize)) {\n+            let hint = UncheckedExprHint(tcx.types.usize);\n+            match const_eval::eval_const_expr_partial(tcx, &e, hint) {\n                 Ok(r) => {\n                     match r {\n                         ConstVal::Int(i) =>"}, {"sha": "c4b31d578dbfdd77c0be639e51b9dd8a0ad0456b", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::const_eval;\n use middle::def;\n use middle::infer;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n@@ -23,7 +22,7 @@ use check::{instantiate_path, resolve_ty_and_def_ufcs, structurally_resolved_typ\n use require_same_types;\n use util::nodemap::FnvHashMap;\n \n-use std::cmp::{self, Ordering};\n+use std::cmp;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::ast;\n use syntax::ast_util;\n@@ -130,18 +129,6 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             fcx.write_ty(pat.id, common_type);\n \n-            // Finally we evaluate the constants and check that the range is non-empty.\n-            let get_substs = |id| fcx.item_substs()[&id].substs.clone();\n-            match const_eval::compare_lit_exprs(tcx, begin, end, Some(&common_type), get_substs) {\n-                Some(Ordering::Less) |\n-                Some(Ordering::Equal) => {}\n-                Some(Ordering::Greater) => {\n-                    span_err!(tcx.sess, begin.span, E0030,\n-                        \"lower range bound must be less than or equal to upper\");\n-                }\n-                None => tcx.sess.span_bug(begin.span, \"literals of different types in range pat\")\n-            }\n-\n             // subtyping doesn't matter here, as the value is some kind of scalar\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }"}, {"sha": "f22da25c01003651b06e10e6490c18b48052ca9d", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "patch": "@@ -169,24 +169,6 @@ match string {\n ```\n \"##,\n \n-E0030: r##\"\n-When matching against a range, the compiler verifies that the range is\n-non-empty.  Range patterns include both end-points, so this is equivalent to\n-requiring the start of the range to be less than or equal to the end of the\n-range.\n-\n-For example:\n-\n-```\n-match 5u32 {\n-    // This range is ok, albeit pointless.\n-    1 ... 1 => ...\n-    // This range is empty, and the compiler can tell.\n-    1000 ... 5 => ...\n-}\n-```\n-\"##,\n-\n E0033: r##\"\n This error indicates that a pointer to a trait type cannot be implicitly\n dereferenced by a pattern. Every trait defines a type, but because the"}, {"sha": "160551b81cb2edfdbaa819424ad7bd07805df760", "filename": "src/test/compile-fail/lint-exceeding-bitshifts.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs?ref=d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(negate_unsigned)]\n #![deny(exceeding_bitshifts)]\n #![allow(unused_variables)]\n #![allow(dead_code)]\n-#![feature(num_bits_bytes, negate_unsigned)]\n+#![feature(num_bits_bytes)]\n \n fn main() {\n       let n = 1u8 << 7;\n@@ -60,4 +59,7 @@ fn main() {\n \n       let n = 1_isize << std::isize::BITS; //~ ERROR: bitshift exceeds the type's number of bits\n       let n = 1_usize << std::usize::BITS; //~ ERROR: bitshift exceeds the type's number of bits\n+\n+\n+      let n = 1i8<<(1isize+-1);\n }"}, {"sha": "e30f783ce363773a6ee0aed79c60f5a63fd54010", "filename": "src/test/compile-fail/match-range-fail-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail-2.rs?ref=d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    match 5 {\n+        6 ... 1 => { }\n+        _ => { }\n+    };\n+    //~^^^ ERROR lower range bound must be less than or equal to upper\n+\n+    match 5u64 {\n+        0xFFFF_FFFF_FFFF_FFFF ... 1 => { }\n+        _ => { }\n+    };\n+    //~^^^ ERROR lower range bound must be less than or equal to upper\n+}"}, {"sha": "05b870b8f41ccef1fa017f000e299055f293521f", "filename": "src/test/compile-fail/match-range-fail.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail.rs?ref=d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "patch": "@@ -9,12 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    match 5 {\n-        6 ... 1 => { }\n-        _ => { }\n-    };\n-    //~^^^ ERROR lower range bound must be less than or equal to upper\n-\n     match \"wow\" {\n         \"bar\" ... \"foo\" => { }\n     };"}]}