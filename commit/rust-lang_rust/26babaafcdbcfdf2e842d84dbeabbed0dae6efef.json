{"sha": "26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YmFiYWFmY2RiY2ZkZjJlODQyZDg0ZGJlYWJiZWQwZGFlNmVmZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-20T19:04:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-20T19:04:47Z"}, "message": "auto merge of #6559 : jbclements/rust/hygiene-fns-and-cleanup, r=jbclements\n\nThis includes new, tested, hygiene support functions. It also removes the interner_key! macro and replaces it with a function, which should be inline-able. It also contains some parser patch-ups and some docfixes.\r\n\r\nOn my machine, this patch passes all tests.", "tree": {"sha": "51ba2c1f043882643de9ca2957d9efab24335a91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51ba2c1f043882643de9ca2957d9efab24335a91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "html_url": "https://github.com/rust-lang/rust/commit/26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3b458b5c5a555067e9d013066fac9c8de50c3f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3b458b5c5a555067e9d013066fac9c8de50c3f8", "html_url": "https://github.com/rust-lang/rust/commit/f3b458b5c5a555067e9d013066fac9c8de50c3f8"}, {"sha": "b71a1ecea2de87cff3089f9f261be71cd314aac9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b71a1ecea2de87cff3089f9f261be71cd314aac9", "html_url": "https://github.com/rust-lang/rust/commit/b71a1ecea2de87cff3089f9f261be71cd314aac9"}], "stats": {"total": 630, "additions": 359, "deletions": 271}, "files": [{"sha": "a115f41ae864b4b71fb79e0967cc286789eeab62", "filename": "doc/rust.md", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "patch": "@@ -2250,6 +2250,14 @@ do_expr : \"do\" expr [ '|' ident_list '|' ] ? '{' block '}' ;\n A _do expression_ provides a more-familiar block-syntax for a [lambda expression](#lambda-expressions),\n including a special translation of [return expressions](#return-expressions) inside the supplied block.\n \n+Any occurrence of a [return expression](#return-expressions)\n+inside this `block` expression is rewritten\n+as a reference to an (anonymous) flag set in the caller's environment,\n+which is checked on return from the `expr` and, if set,\n+causes a corresponding return from the caller.\n+In this way, the meaning of `return` statements in language built-in control blocks is preserved,\n+if they are rewritten using lambda functions and `do` expressions as abstractions.\n+\n The optional `ident_list` and `block` provided in a `do` expression are parsed as though they constitute a lambda expression;\n if the `ident_list` is missing, an empty `ident_list` is implied.\n \n@@ -2296,19 +2304,15 @@ A _for expression_ is similar to a [`do` expression](#do-expressions),\n in that it provides a special block-form of lambda expression,\n suited to passing the `block` function to a higher-order function implementing a loop.\n \n-Like a `do` expression, a `return` expression inside a `for` expresison is rewritten,\n-to access a local flag that causes an early return in the caller.\n-\n-Additionally, any occurrence of a [return expression](#return-expressions)\n-inside the `block` of a `for` expression is rewritten\n-as a reference to an (anonymous) flag set in the caller's environment,\n-which is checked on return from the `expr` and, if set,\n-causes a corresponding return from the caller.\n-In this way, the meaning of `return` statements in language built-in control blocks is preserved,\n-if they are rewritten using lambda functions and `do` expressions as abstractions.\n+In contrast to a `do` expression, a `for` expression is designed to work\n+with methods such as `each` and `times`, that require the body block to\n+return a boolean. The `for` expression accommodates this by implicitly\n+returning `true` at the end of each block, unless a `break` expression\n+is evaluated.\n \n-Like `return` expressions, any [`break`](#break-expressions) and [`loop`](#loop-expressions) expressions\n-are rewritten inside `for` expressions, with a combination of local flag variables,\n+In addition, [`break`](#break-expressions) and [`loop`](#loop-expressions) expressions\n+are rewritten inside `for` expressions in the same way that `return` expressions are,\n+with a combination of local flag variables,\n and early boolean-valued returns from the `block` function,\n such that the meaning of `break` and `loop` is preserved in a primitive loop\n when rewritten as a `for` loop controlled by a higher order function."}, {"sha": "e3da6e6844e52dd67d5fa865ac030a6ce6043362", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "patch": "@@ -17,24 +17,18 @@ use doc;\n use core::local_data::local_data_get;\n use syntax::ast;\n use syntax;\n-\n-/* can't import macros yet, so this is copied from token.rs. See its comment\n- * there. */\n-macro_rules! interner_key (\n-    () => (cast::transmute::<(uint, uint),\n-           &fn(v: @@syntax::parse::token::ident_interner)>((-3 as uint, 0u)))\n-)\n+use syntax::parse::token::{ident_interner};\n+use syntax::parse::token;\n \n // Hack; rather than thread an interner through everywhere, rely on\n // thread-local data\n pub fn to_str(id: ast::ident) -> ~str {\n-    let intr = unsafe{ local_data_get(interner_key!()) };\n-\n-    return copy *(*intr.get()).get(id);\n+    let intr = token::get_ident_interner();\n+    return copy *(*intr).get(id);\n }\n \n-pub fn interner() -> @syntax::parse::token::ident_interner {\n-    return *(unsafe{ local_data_get(interner_key!()) }).get();\n+pub fn interner() -> @ident_interner {\n+    return token::get_ident_interner();\n }\n \n pub fn from_srv("}, {"sha": "a8ff8dab54c19ce3aa90a5089b59c6deef27760b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "patch": "@@ -13,12 +13,14 @@\n use codemap::{span, spanned};\n use abi::AbiSet;\n use opt_vec::OptVec;\n+use parse::token::get_ident_interner;\n \n use core::cast;\n-use core::option::{None, Option, Some};\n+use core::option::{Option};\n use core::to_bytes;\n use core::to_bytes::IterBytes;\n use core::to_str::ToStr;\n+use core::hashmap::HashMap;\n use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n \n@@ -38,14 +40,20 @@ pub struct ident { repr: Name, ctxt: SyntaxContext }\n // that's causing unreleased memory to cause core dumps\n // and also perhaps to save some work in destructor checks.\n // the special uint '0' will be used to indicate an empty\n-// syntax context\n+// syntax context.\n \n // this uint is a reference to a table stored in thread-local\n // storage.\n pub type SyntaxContext = uint;\n \n-pub type SCTable = ~[SyntaxContext_];\n+pub struct SCTable {\n+    table : ~[SyntaxContext_],\n+    mark_memo : HashMap<(SyntaxContext,Mrk),SyntaxContext>,\n+    rename_memo : HashMap<(SyntaxContext,ident,Name),SyntaxContext>\n+}\n+// NB: these must be placed in any SCTable...\n pub static empty_ctxt : uint = 0;\n+pub static illegal_ctxt : uint = 1;\n \n #[deriving(Eq, Encodable, Decodable)]\n pub enum SyntaxContext_ {\n@@ -59,7 +67,8 @@ pub enum SyntaxContext_ {\n     // \"to\" slot must have the same name and context\n     // in the \"from\" slot. In essence, they're all\n     // pointers to a single \"rename\" event node.\n-    Rename (ident,Name,SyntaxContext)\n+    Rename (ident,Name,SyntaxContext),\n+    IllegalCtxt()\n }\n \n // a name represents an identifier\n@@ -70,27 +79,14 @@ pub type Mrk = uint;\n \n impl<S:Encoder> Encodable<S> for ident {\n     fn encode(&self, s: &mut S) {\n-        unsafe {\n-            let intr =\n-                match local_data::local_data_get(interner_key!()) {\n-                    None => fail!(\"encode: TLS interner not set up\"),\n-                    Some(intr) => intr\n-                };\n-\n-            s.emit_str(*(*intr).get(*self));\n-        }\n+        let intr = get_ident_interner();\n+        s.emit_str(*(*intr).get(*self));\n     }\n }\n \n impl<D:Decoder> Decodable<D> for ident {\n     fn decode(d: &mut D) -> ident {\n-        let intr = match unsafe {\n-            local_data::local_data_get(interner_key!())\n-        } {\n-            None => fail!(\"decode: TLS interner not set up\"),\n-            Some(intr) => intr\n-        };\n-\n+        let intr = get_ident_interner();\n         (*intr).intern(d.read_str())\n     }\n }"}, {"sha": "eaacb054ca1aea8e70cdca0529ed8b8b8e2059d4", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 93, "deletions": 41, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "patch": "@@ -15,6 +15,7 @@ use codemap::{span, spanned};\n use parse::token;\n use visit;\n use opt_vec;\n+use core::hashmap::HashMap;\n \n use core::to_bytes;\n \n@@ -577,22 +578,61 @@ pub enum Privacy {\n // HYGIENE FUNCTIONS\n \n /// Construct an identifier with the given repr and an empty context:\n-pub fn mk_ident(repr: uint) -> ident { ident {repr: repr, ctxt: 0}}\n+pub fn new_ident(repr: uint) -> ident { ident {repr: repr, ctxt: 0}}\n \n /// Extend a syntax context with a given mark\n-pub fn mk_mark (m:Mrk,ctxt:SyntaxContext,table:&mut SCTable)\n+pub fn new_mark (m:Mrk, tail:SyntaxContext,table:&mut SCTable)\n     -> SyntaxContext {\n-    idx_push(table,Mark(m,ctxt))\n+    let key = (tail,m);\n+    // FIXME #5074 : can't use more natural style because we're missing\n+    // flow-sensitivity. Results in two lookups on a hash table hit.\n+    // also applies to new_rename, below.\n+    // let try_lookup = table.mark_memo.find(&key);\n+    match table.mark_memo.contains_key(&key) {\n+        false => {\n+            let new_idx = idx_push(&mut table.table,Mark(m,tail));\n+            table.mark_memo.insert(key,new_idx);\n+            new_idx\n+        }\n+        true => {\n+            match table.mark_memo.find(&key) {\n+                None => fail!(~\"internal error: key disappeared 2013042901\"),\n+                Some(idxptr) => {*idxptr}\n+            }\n+        }\n+    }\n }\n \n /// Extend a syntax context with a given rename\n-pub fn mk_rename (id:ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n+pub fn new_rename (id:ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n     -> SyntaxContext {\n-    idx_push(table,Rename(id,to,tail))\n+    let key = (tail,id,to);\n+    // FIXME #5074\n+    //let try_lookup = table.rename_memo.find(&key);\n+    match table.rename_memo.contains_key(&key) {\n+        false => {\n+            let new_idx = idx_push(&mut table.table,Rename(id,to,tail));\n+            table.rename_memo.insert(key,new_idx);\n+            new_idx\n+        }\n+        true => {\n+            match table.rename_memo.find(&key) {\n+                None => fail!(~\"internal error: key disappeared 2013042902\"),\n+                Some(idxptr) => {*idxptr}\n+            }\n+        }\n+    }\n }\n \n /// Make a fresh syntax context table with EmptyCtxt in slot zero\n-pub fn mk_sctable() -> SCTable { ~[EmptyCtxt] }\n+/// and IllegalCtxt in slot one.\n+pub fn new_sctable() -> SCTable {\n+    SCTable {\n+        table: ~[EmptyCtxt,IllegalCtxt],\n+        mark_memo: HashMap::new(),\n+        rename_memo: HashMap::new()\n+    }\n+}\n \n /// Add a value to the end of a vec, return its index\n fn idx_push<T>(vec: &mut ~[T], val: T) -> uint {\n@@ -601,8 +641,8 @@ fn idx_push<T>(vec: &mut ~[T], val: T) -> uint {\n }\n \n /// Resolve a syntax object to a name, per MTWT.\n-pub fn resolve (id : ident, table : &SCTable) -> Name {\n-    match table[id.ctxt] {\n+pub fn resolve (id : ident, table : &mut SCTable) -> Name {\n+    match table.table[id.ctxt] {\n         EmptyCtxt => id.repr,\n         // ignore marks here:\n         Mark(_,subctxt) => resolve (ident{repr:id.repr, ctxt: subctxt},table),\n@@ -619,6 +659,7 @@ pub fn resolve (id : ident, table : &SCTable) -> Name {\n                 resolvedthis\n             }\n         }\n+        IllegalCtxt() => fail!(~\"expected resolvable context, got IllegalCtxt\")\n     }\n }\n \n@@ -629,7 +670,7 @@ pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> ~[Mrk] {\n     let mut result = ~[];\n     let mut loopvar = ctxt;\n     loop {\n-        match table[loopvar] {\n+        match table.table[loopvar] {\n             EmptyCtxt => {return result;},\n             Mark(mark,tl) => {\n                 xorPush(&mut result,mark);\n@@ -644,6 +685,7 @@ pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> ~[Mrk] {\n                     loopvar = tl;\n                 }\n             }\n+            IllegalCtxt => fail!(~\"expected resolvable context, got IllegalCtxt\")\n         }\n     }\n }\n@@ -713,15 +755,15 @@ mod test {\n         -> SyntaxContext {\n         tscs.foldr(tail, |tsc : &TestSC,tail : SyntaxContext|\n                   {match *tsc {\n-                      M(mrk) => mk_mark(mrk,tail,table),\n-                      R(ident,name) => mk_rename(ident,name,tail,table)}})\n+                      M(mrk) => new_mark(mrk,tail,table),\n+                      R(ident,name) => new_rename(ident,name,tail,table)}})\n     }\n \n     // gather a SyntaxContext back into a vector of TestSCs\n     fn refold_test_sc(mut sc: SyntaxContext, table : &SCTable) -> ~[TestSC] {\n         let mut result = ~[];\n         loop {\n-            match table[sc] {\n+            match table.table[sc] {\n                 EmptyCtxt => {return result;},\n                 Mark(mrk,tail) => {\n                     result.push(M(mrk));\n@@ -733,40 +775,41 @@ mod test {\n                     sc = tail;\n                     loop;\n                 }\n+                IllegalCtxt => fail!(\"expected resolvable context, got IllegalCtxt\")\n             }\n         }\n     }\n \n     #[test] fn test_unfold_refold(){\n-        let mut t = mk_sctable();\n+        let mut t = new_sctable();\n \n         let test_sc = ~[M(3),R(id(101,0),14),M(9)];\n-        assert_eq!(unfold_test_sc(copy test_sc,empty_ctxt,&mut t),3);\n-        assert_eq!(t[1],Mark(9,0));\n-        assert_eq!(t[2],Rename(id(101,0),14,1));\n-        assert_eq!(t[3],Mark(3,2));\n-        assert_eq!(refold_test_sc(3,&t),test_sc);\n+        assert_eq!(unfold_test_sc(copy test_sc,empty_ctxt,&mut t),4);\n+        assert_eq!(t.table[2],Mark(9,0));\n+        assert_eq!(t.table[3],Rename(id(101,0),14,2));\n+        assert_eq!(t.table[4],Mark(3,3));\n+        assert_eq!(refold_test_sc(4,&t),test_sc);\n     }\n \n     // extend a syntax context with a sequence of marks given\n     // in a vector. v[0] will be the outermost mark.\n     fn unfold_marks(mrks:~[Mrk],tail:SyntaxContext,table: &mut SCTable) -> SyntaxContext {\n         mrks.foldr(tail, |mrk:&Mrk,tail:SyntaxContext|\n-                   {mk_mark(*mrk,tail,table)})\n+                   {new_mark(*mrk,tail,table)})\n     }\n \n     #[test] fn unfold_marks_test() {\n-        let mut t = ~[EmptyCtxt];\n+        let mut t = new_sctable();\n \n-        assert_eq!(unfold_marks(~[3,7],empty_ctxt,&mut t),2);\n-        assert_eq!(t[1],Mark(7,0));\n-        assert_eq!(t[2],Mark(3,1));\n+        assert_eq!(unfold_marks(~[3,7],empty_ctxt,&mut t),3);\n+        assert_eq!(t.table[2],Mark(7,0));\n+        assert_eq!(t.table[3],Mark(3,2));\n     }\n \n     #[test] fn test_marksof () {\n         let stopname = 242;\n         let name1 = 243;\n-        let mut t = mk_sctable();\n+        let mut t = new_sctable();\n         assert_eq!(marksof (empty_ctxt,stopname,&t),~[]);\n         // FIXME #5074: ANF'd to dodge nested calls\n         { let ans = unfold_marks(~[4,98],empty_ctxt,&mut t);\n@@ -780,13 +823,13 @@ mod test {\n         // rename where stop doesn't match:\n         { let chain = ~[M(9),\n                         R(id(name1,\n-                             mk_mark (4, empty_ctxt,&mut t)),\n+                             new_mark (4, empty_ctxt,&mut t)),\n                           100101102),\n                         M(14)];\n          let ans = unfold_test_sc(chain,empty_ctxt,&mut t);\n          assert_eq! (marksof (ans, stopname, &t), ~[9,14]);}\n         // rename where stop does match\n-        { let name1sc = mk_mark(4, empty_ctxt, &mut t);\n+        { let name1sc = new_mark(4, empty_ctxt, &mut t);\n          let chain = ~[M(9),\n                        R(id(name1, name1sc),\n                          stopname),\n@@ -798,51 +841,60 @@ mod test {\n \n     #[test] fn resolve_tests () {\n         let a = 40;\n-        let mut t = mk_sctable();\n+        let mut t = new_sctable();\n         // - ctxt is MT\n-        assert_eq!(resolve(id(a,empty_ctxt),&t),a);\n+        assert_eq!(resolve(id(a,empty_ctxt),&mut t),a);\n         // - simple ignored marks\n         { let sc = unfold_marks(~[1,2,3],empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&t),a);}\n+         assert_eq!(resolve(id(a,sc),&mut t),a);}\n         // - orthogonal rename where names don't match\n         { let sc = unfold_test_sc(~[R(id(50,empty_ctxt),51),M(12)],empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&t),a);}\n+         assert_eq!(resolve(id(a,sc),&mut t),a);}\n         // - rename where names do match, but marks don't\n-        { let sc1 = mk_mark(1,empty_ctxt,&mut t);\n+        { let sc1 = new_mark(1,empty_ctxt,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50),\n                                    M(1),\n                                    M(2)],\n                                  empty_ctxt,&mut t);\n-        assert_eq!(resolve(id(a,sc),&t), a);}\n+        assert_eq!(resolve(id(a,sc),&mut t), a);}\n         // - rename where names and marks match\n         { let sc1 = unfold_test_sc(~[M(1),M(2)],empty_ctxt,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50),M(1),M(2)],empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&t), 50); }\n+         assert_eq!(resolve(id(a,sc),&mut t), 50); }\n         // - rename where names and marks match by literal sharing\n         { let sc1 = unfold_test_sc(~[M(1),M(2)],empty_ctxt,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50)],sc1,&mut t);\n-         assert_eq!(resolve(id(a,sc),&t), 50); }\n+         assert_eq!(resolve(id(a,sc),&mut t), 50); }\n         // - two renames of the same var.. can only happen if you use\n         // local-expand to prevent the inner binding from being renamed\n         // during the rename-pass caused by the first:\n         io::println(\"about to run bad test\");\n         { let sc = unfold_test_sc(~[R(id(a,empty_ctxt),50),\n                                     R(id(a,empty_ctxt),51)],\n                                   empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&t), 51); }\n+         assert_eq!(resolve(id(a,sc),&mut t), 51); }\n         // the simplest double-rename:\n-        { let a_to_a50 = mk_rename(id(a,empty_ctxt),50,empty_ctxt,&mut t);\n-         let a50_to_a51 = mk_rename(id(a,a_to_a50),51,a_to_a50,&mut t);\n-         assert_eq!(resolve(id(a,a50_to_a51),&t),51);\n+        { let a_to_a50 = new_rename(id(a,empty_ctxt),50,empty_ctxt,&mut t);\n+         let a50_to_a51 = new_rename(id(a,a_to_a50),51,a_to_a50,&mut t);\n+         assert_eq!(resolve(id(a,a50_to_a51),&mut t),51);\n          // mark on the outside doesn't stop rename:\n-         let sc = mk_mark(9,a50_to_a51,&mut t);\n-         assert_eq!(resolve(id(a,sc),&t),51);\n+         let sc = new_mark(9,a50_to_a51,&mut t);\n+         assert_eq!(resolve(id(a,sc),&mut t),51);\n          // but mark on the inside does:\n          let a50_to_a51_b = unfold_test_sc(~[R(id(a,a_to_a50),51),\n                                               M(9)],\n                                            a_to_a50,\n                                            &mut t);\n-         assert_eq!(resolve(id(a,a50_to_a51_b),&t),50);}\n+         assert_eq!(resolve(id(a,a50_to_a51_b),&mut t),50);}\n+    }\n+\n+    #[test] fn hashing_tests () {\n+        let mut t = new_sctable();\n+        assert_eq!(new_mark(12,empty_ctxt,&mut t),2);\n+        assert_eq!(new_mark(13,empty_ctxt,&mut t),3);\n+        // using the same one again should result in the same index:\n+        assert_eq!(new_mark(12,empty_ctxt,&mut t),2);\n+        // I'm assuming that the rename table will behave the same....\n     }\n \n }"}, {"sha": "db95cb65b76602d0767102df8a454a379d040211", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 58, "deletions": 35, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "patch": "@@ -11,7 +11,9 @@\n use ast::{blk_, attribute_, attr_outer, meta_word};\n use ast::{crate, expr_, expr_mac, mac_invoc_tt};\n use ast::{item_mac, stmt_, stmt_mac, stmt_expr, stmt_semi};\n+use ast::{SCTable, illegal_ctxt};\n use ast;\n+use ast_util::{new_rename, new_mark, resolve};\n use attr;\n use codemap;\n use codemap::{span, CallInfo, ExpandedFrom, NameAndSpan, spanned};\n@@ -635,62 +637,65 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     @f.fold_crate(&*c)\n }\n \n-// given a function from paths to paths, produce\n+// given a function from idents to idents, produce\n // an ast_fold that applies that function:\n-fn fun_to_path_folder(f: @fn(&ast::Path)->ast::Path) -> @ast_fold{\n+pub fn fun_to_ident_folder(f: @fn(ast::ident)->ast::ident) -> @ast_fold{\n     let afp = default_ast_fold();\n     let f_pre = @AstFoldFns{\n-        fold_path : |p, _| f(p),\n+        fold_ident : |id, _| f(id),\n         .. *afp\n     };\n     make_fold(f_pre)\n }\n-/* going to have to figure out whether the table is passed in or\n-extracted from TLS...\n+\n // update the ctxts in a path to get a rename node\n-fn ctxt_update_rename(from: ast::Name,\n-                       fromctx: ast::SyntaxContext, to: ast::Name) ->\n-    @fn(&ast::Path,@ast_fold)->ast::Path {\n-    return |p:&ast::Path,_|\n-    ast::Path {span: p.span,\n-               global: p.global,\n-               idents: p.idents.map(|id|\n-                                    ast::ident{\n-                                        repr: id.repr,\n-                                        // this needs to be cached....\n-                                        ctxt: Some(@ast::Rename(from,fromctx,\n-                                                           to,id.ctxt))\n-                                    }),\n-               rp: p.rp,\n-               types: p.types};\n+pub fn new_ident_renamer(from: ast::ident,\n+                      to: ast::Name,\n+                      table: @mut SCTable) ->\n+    @fn(ast::ident)->ast::ident {\n+    |id : ast::ident|\n+    ast::ident{\n+        repr: id.repr,\n+        ctxt: new_rename(from,to,id.ctxt,table)\n+    }\n }\n \n+\n // update the ctxts in a path to get a mark node\n-fn ctxt_update_mark(mark: uint) ->\n-    @fn(&ast::Path,@ast_fold)->ast::Path {\n-    return |p:&ast::Path,_|\n-    ast::Path {span: p.span,\n-               global: p.global,\n-               idents: p.idents.map(|id|\n-                                    ast::ident{\n-                                        repr: id.repr,\n-                                        // this needs to be cached....\n-                                        ctxt: Some(@ast::Mark(mark,id.ctxt))\n-                                    }),\n-               rp: p.rp,\n-               types: p.types};\n+pub fn new_ident_marker(mark: uint,\n+                        table: @mut SCTable) ->\n+    @fn(ast::ident)->ast::ident {\n+    |id : ast::ident|\n+    ast::ident{\n+        repr: id.repr,\n+        ctxt: new_mark(mark,id.ctxt,table)\n+    }\n }\n-*/\n+\n+// perform resolution (in the MTWT sense) on all of the\n+// idents in the tree. This is the final step in expansion.\n+pub fn new_ident_resolver(table: @mut SCTable) ->\n+    @fn(ast::ident)->ast::ident {\n+    |id : ast::ident|\n+    ast::ident {\n+        repr : resolve(id,table),\n+        ctxt : illegal_ctxt\n+    }\n+}\n+\n \n #[cfg(test)]\n mod test {\n     use super::*;\n     use ast;\n-    use ast::{attribute_, attr_outer, meta_word};\n+    use ast::{attribute_, attr_outer, meta_word, empty_ctxt};\n+    use ast_util::{new_sctable};\n     use codemap;\n     use codemap::spanned;\n     use parse;\n+    use core::io;\n     use core::option::{None, Some};\n+    use util::parser_testing::{string_to_item_and_sess};\n \n     // make sure that fail! is present\n     #[test] fn fail_exists_test () {\n@@ -792,4 +797,22 @@ mod test {\n         }\n     }\n \n+    #[test]\n+    fn renaming () {\n+        let (maybe_item_ast,sess) = string_to_item_and_sess(@~\"fn a() -> int { let b = 13; b} \");\n+        let item_ast = match maybe_item_ast {\n+            Some(x) => x,\n+            None => fail!(\"test case fail\")\n+        };\n+        let table = @mut new_sctable();\n+        let a_name = 100; // enforced by testing_interner\n+        let a2_name = sess.interner.gensym(\"a2\").repr;\n+        let renamer = new_ident_renamer(ast::ident{repr:a_name,ctxt:empty_ctxt},\n+                                        a2_name,table);\n+        let renamed_ast = fun_to_ident_folder(renamer).fold_item(item_ast).get();\n+        let resolver = new_ident_resolver(table);\n+        let resolved_ast = fun_to_ident_folder(resolver).fold_item(renamed_ast).get();\n+        io::print(fmt!(\"ast: %?\\n\",resolved_ast))\n+    }\n+\n }"}, {"sha": "5340293bb0249034440c6b95887259c5653bb82a", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "patch": "@@ -786,7 +786,7 @@ mod test {\n     fn setup(teststr: ~str) -> Env {\n         let cm = CodeMap::new();\n         let fm = cm.new_filemap(~\"zebra.rs\", @teststr);\n-        let ident_interner = token::mk_ident_interner(); // interner::mk();\n+        let ident_interner = token::get_ident_interner();\n         let span_handler =\n             diagnostic::mk_span_handler(diagnostic::mk_handler(None),@cm);\n         Env {"}, {"sha": "8eb7ca2923c256f1495784e1fb16ca3656c7e9c8", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 44, "deletions": 95, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "patch": "@@ -19,7 +19,7 @@ use diagnostic::{span_handler, mk_span_handler, mk_handler, Emitter};\n use parse::attr::parser_attr;\n use parse::lexer::reader;\n use parse::parser::Parser;\n-use parse::token::{ident_interner, mk_ident_interner};\n+use parse::token::{ident_interner, get_ident_interner};\n \n use core::io;\n use core::option::{None, Option, Some};\n@@ -59,7 +59,7 @@ pub fn new_parse_sess(demitter: Option<Emitter>) -> @mut ParseSess {\n         cm: cm,\n         next_id: 1,\n         span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n-        interner: mk_ident_interner(),\n+        interner: get_ident_interner(),\n     }\n }\n \n@@ -70,7 +70,7 @@ pub fn new_parse_sess_special_handler(sh: @span_handler,\n         cm: cm,\n         next_id: 1,\n         span_diagnostic: sh,\n-        interner: mk_ident_interner(),\n+        interner: get_ident_interner(),\n     }\n }\n \n@@ -346,76 +346,24 @@ mod test {\n     use std::serialize::Encodable;\n     use std;\n     use core::io;\n-    use core::option::Option;\n     use core::option::Some;\n     use core::option::None;\n-    use core::int;\n-    use core::num::NumCast;\n-    use codemap::{CodeMap, span, BytePos, spanned};\n+    use codemap::{span, BytePos, spanned};\n     use opt_vec;\n     use ast;\n     use abi;\n-    use ast_util::mk_ident;\n     use parse::parser::Parser;\n-    use parse::token::{ident_interner, mk_fresh_ident_interner};\n-    use diagnostic::{mk_span_handler, mk_handler};\n-\n-    // add known names to interner for testing\n-    fn mk_testing_interner() -> @ident_interner {\n-        let i = mk_fresh_ident_interner();\n-        // baby hack; in order to put the identifiers\n-        // 'a' and 'b' at known locations, we're going\n-        // to fill up the interner to length 100. If\n-        // the # of preloaded items on the interner\n-        // ever gets larger than 100, we'll have to\n-        // adjust this number (say, to 200) and\n-        // change the numbers in the identifier\n-        // test cases below.\n-\n-        assert!(i.len() < 100);\n-        for int::range(0,100-((i.len()).to_int())) |_dc| {\n-            i.gensym(\"dontcare\");\n-        }\n-        i.intern(\"a\");\n-        i.intern(\"b\");\n-        i.intern(\"c\");\n-        i.intern(\"d\");\n-        i.intern(\"return\");\n-        assert_eq!(i.get(ast::ident{repr:101,ctxt:0}), @~\"b\");\n-        i\n-    }\n-\n-    // make a parse_sess that's closed over a\n-    // testing interner (where a -> 100, b -> 101)\n-    fn mk_testing_parse_sess() -> @mut ParseSess {\n-        let interner = mk_testing_interner();\n-        let cm = @CodeMap::new();\n-        @mut ParseSess {\n-            cm: cm,\n-            next_id: 1,\n-            span_diagnostic: mk_span_handler(mk_handler(None), cm),\n-            interner: interner,\n-        }\n-    }\n-\n-    // map a string to tts, using a made-up filename: return both the token_trees\n-    // and the ParseSess\n-    fn string_to_tts_t (source_str : @~str) -> (~[ast::token_tree],@mut ParseSess) {\n-        let ps = mk_testing_parse_sess();\n-        (filemap_to_tts(ps,string_to_filemap(ps,source_str,~\"bogofile\")),ps)\n-    }\n+    use parse::token::intern;\n+    use util::parser_testing::{string_to_tts_and_sess,string_to_parser};\n+    use util::parser_testing::{string_to_expr, string_to_item};\n+    use util::parser_testing::{string_to_stmt};\n \n     // map a string to tts, return the tt without its parsesess\n     fn string_to_tts_only(source_str : @~str) -> ~[ast::token_tree] {\n-        let (tts,_ps) = string_to_tts_t(source_str);\n+        let (tts,_ps) = string_to_tts_and_sess(source_str);\n         tts\n     }\n \n-    // map string to parser (via tts)\n-    fn string_to_parser(source_str: @~str) -> Parser {\n-        let ps = mk_testing_parse_sess();\n-        new_parser_from_source_str(ps,~[],~\"bogofile\",source_str)\n-    }\n \n     #[cfg(test)] fn to_json_str<E : Encodable<std::json::Encoder>>(val: @E) -> ~str {\n         do io::with_str_writer |writer| {\n@@ -424,30 +372,14 @@ mod test {\n         }\n     }\n \n-    fn string_to_crate (source_str : @~str) -> @ast::crate {\n-        string_to_parser(source_str).parse_crate_mod()\n-    }\n-\n-    fn string_to_expr (source_str : @~str) -> @ast::expr {\n-        string_to_parser(source_str).parse_expr()\n-    }\n-\n-    fn string_to_item (source_str : @~str) -> Option<@ast::item> {\n-        string_to_parser(source_str).parse_item(~[])\n-    }\n-\n-    fn string_to_stmt (source_str : @~str) -> @ast::stmt {\n-        string_to_parser(source_str).parse_stmt(~[])\n-    }\n-\n     // produce a codemap::span\n     fn sp (a: uint, b: uint) -> span {\n         span{lo:BytePos(a),hi:BytePos(b),expn_info:None}\n     }\n \n     // convert a vector of uints to a vector of ast::idents\n-    fn ints_to_idents(ids: ~[uint]) -> ~[ast::ident] {\n-        ids.map(|u| mk_ident(*u))\n+    fn ints_to_idents(ids: ~[~str]) -> ~[ast::ident] {\n+        ids.map(|u| intern(*u))\n     }\n \n     #[test] fn path_exprs_1 () {\n@@ -456,7 +388,7 @@ mod test {\n                               callee_id:2,\n                               node:ast::expr_path(@ast::Path {span:sp(0,1),\n                                                               global:false,\n-                                                              idents:~[mk_ident(100)],\n+                                                              idents:~[intern(\"a\")],\n                                                               rp:None,\n                                                               types:~[]}),\n                               span:sp(0,1)})\n@@ -466,11 +398,12 @@ mod test {\n         assert_eq!(string_to_expr(@~\"::a::b\"),\n                    @ast::expr{id:1,\n                                callee_id:2,\n-                               node:ast::expr_path(@ast::Path {span:sp(0,6),\n-                                                               global:true,\n-                                                               idents:ints_to_idents(~[100,101]),\n-                                                               rp:None,\n-                                                               types:~[]}),\n+                               node:ast::expr_path(\n+                                   @ast::Path {span:sp(0,6),\n+                                               global:true,\n+                                               idents:ints_to_idents(~[~\"a\",~\"b\"]),\n+                                               rp:None,\n+                                               types:~[]}),\n                               span:sp(0,6)})\n     }\n \n@@ -482,7 +415,7 @@ mod test {\n     }*/\n \n     #[test] fn string_to_tts_1 () {\n-        let (tts,_ps) = string_to_tts_t(@~\"fn a (b : int) { b; }\");\n+        let (tts,_ps) = string_to_tts_and_sess(@~\"fn a (b : int) { b; }\");\n         assert_eq!(to_json_str(@tts),\n                    ~\"[\\\n                 [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"fn\\\",false]],\\\n@@ -519,7 +452,7 @@ mod test {\n                                                   node:ast::expr_path(\n                                                       @ast::Path{span:sp(7,8),\n                                                                  global:false,\n-                                                                 idents:~[mk_ident(103)],\n+                                                                 idents:~[intern(\"d\")],\n                                                                  rp:None,\n                                                                  types:~[]\n                                                                 }),\n@@ -537,7 +470,7 @@ mod test {\n                                @ast::Path{\n                                    span:sp(0,1),\n                                    global:false,\n-                                   idents:~[mk_ident(101)],\n+                                   idents:~[intern(\"b\")],\n                                    rp:None,\n                                    types: ~[]}),\n                            span: sp(0,1)},\n@@ -558,7 +491,7 @@ mod test {\n                                                   @ast::Path{\n                                                       span:sp(0,1),\n                                                       global:false,\n-                                                      idents:~[mk_ident(101)],\n+                                                      idents:~[intern(\"b\")],\n                                                       rp: None,\n                                                       types: ~[]},\n                                                   None // no idea\n@@ -577,7 +510,7 @@ mod test {\n                                         span:sp(4,4), // this is bizarre...\n                                         // check this in the original parser?\n                                         global:false,\n-                                        idents:~[mk_ident(105)],\n+                                        idents:~[intern(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n                                                        2),\n@@ -587,7 +520,7 @@ mod test {\n                                                            @ast::Path{\n                                                                span:sp(0,1),\n                                                                global:false,\n-                                                               idents:~[mk_ident(101)],\n+                                                               idents:~[intern(\"b\")],\n                                                                rp: None,\n                                                                types: ~[]},\n                                                            None // no idea\n@@ -603,7 +536,7 @@ mod test {\n         // assignment order of the node_ids.\n         assert_eq!(string_to_item(@~\"fn a (b : int) { b; }\"),\n                   Some(\n-                      @ast::item{ident:mk_ident(100),\n+                      @ast::item{ident:intern(\"a\"),\n                             attrs:~[],\n                             id: 10, // fixme\n                             node: ast::item_fn(ast::fn_decl{\n@@ -613,7 +546,7 @@ mod test {\n                                                 node: ast::ty_path(@ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n-                                        idents:~[mk_ident(106)],\n+                                        idents:~[intern(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n                                                        2),\n@@ -624,7 +557,7 @@ mod test {\n                                                        @ast::Path{\n                                                            span:sp(6,7),\n                                                            global:false,\n-                                                           idents:~[mk_ident(101)],\n+                                                           idents:~[intern(\"b\")],\n                                                            rp: None,\n                                                            types: ~[]},\n                                                        None // no idea\n@@ -655,7 +588,7 @@ mod test {\n                                                         @ast::Path{\n                                                             span:sp(17,18),\n                                                             global:false,\n-                                                            idents:~[mk_ident(101)],\n+                                                            idents:~[intern(\"b\")],\n                                                             rp:None,\n                                                             types: ~[]}),\n                                                     span: sp(17,18)},\n@@ -675,4 +608,20 @@ mod test {\n         string_to_expr(@~\"3 + 4\");\n         string_to_expr(@~\"a::z.froob(b,@(987+3))\");\n     }\n+\n+    #[test] fn attrs_fix_bug () {\n+        string_to_item(@~\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n+                   -> Result<@Writer, ~str> {\n+    #[cfg(windows)]\n+    fn wb() -> c_int {\n+      (O_WRONLY | libc::consts::os::extra::O_BINARY) as c_int\n+    }\n+\n+    #[cfg(unix)]\n+    fn wb() -> c_int { O_WRONLY as c_int }\n+\n+    let mut fflags: c_int = wb();\n+}\");\n+    }\n+\n }"}, {"sha": "fddeea9302414fa5b1a00822b855c5781b051fcf", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "patch": "@@ -2496,6 +2496,7 @@ pub impl Parser {\n         @ast::pat { id: self.get_id(), node: pat, span: mk_sp(lo, hi) }\n     }\n \n+    // parse ident or ident @ pat\n     // used by the copy foo and ref foo patterns to give a good\n     // error message when parsing mistakes like ref foo(a,b)\n     fn parse_pat_ident(&self,\n@@ -2587,20 +2588,22 @@ pub impl Parser {\n         })\n     }\n \n-    // parse a statement. may include decl\n-    fn parse_stmt(&self, first_item_attrs: ~[attribute]) -> @stmt {\n+    // parse a statement. may include decl.\n+    // precondition: any attributes are parsed already\n+    fn parse_stmt(&self, item_attrs: ~[attribute]) -> @stmt {\n         maybe_whole!(self, nt_stmt);\n \n         fn check_expected_item(p: &Parser, current_attrs: &[attribute]) {\n             // If we have attributes then we should have an item\n             if !current_attrs.is_empty() {\n-                p.fatal(~\"expected item after attrs\");\n+                p.span_err(*p.last_span,\n+                           ~\"expected item after attributes\");\n             }\n         }\n \n         let lo = self.span.lo;\n         if self.is_keyword(\"let\") {\n-            check_expected_item(self, first_item_attrs);\n+            check_expected_item(self, item_attrs);\n             self.expect_keyword(\"let\");\n             let decl = self.parse_let();\n             return @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n@@ -2613,7 +2616,7 @@ pub impl Parser {\n             // to the macro clause of parse_item_or_view_item. This\n             // could use some cleanup, it appears to me.\n \n-            check_expected_item(self, first_item_attrs);\n+            check_expected_item(self, item_attrs);\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n@@ -2649,9 +2652,6 @@ pub impl Parser {\n             }\n \n         } else {\n-            let item_attrs = vec::append(first_item_attrs,\n-                                         self.parse_outer_attributes());\n-\n             match self.parse_item_or_view_item(/*bad*/ copy item_attrs,\n                                                            false) {\n                 iovi_item(i) => {\n@@ -2726,6 +2726,7 @@ pub impl Parser {\n         let mut stmts = ~[];\n         let mut expr = None;\n \n+        // wouldn't it be more uniform to parse view items only, here?\n         let ParsedItemsAndViewItems {\n             attrs_remaining: attrs_remaining,\n             view_items: view_items,\n@@ -2740,23 +2741,29 @@ pub impl Parser {\n                                 stmt_decl(decl, self.get_id())));\n         }\n \n-        let mut initial_attrs = attrs_remaining;\n-\n-        if *self.token == token::RBRACE && !vec::is_empty(initial_attrs) {\n-            self.fatal(~\"expected item\");\n-        }\n+        let mut attributes_box = attrs_remaining;\n \n-        while *self.token != token::RBRACE {\n+        while (*self.token != token::RBRACE) {\n+            // parsing items even when they're not allowed lets us give\n+            // better error messages and recover more gracefully.\n+            attributes_box.push_all(self.parse_outer_attributes());\n             match *self.token {\n                 token::SEMI => {\n+                    if !vec::is_empty(attributes_box) {\n+                        self.span_err(*self.last_span,~\"expected item after attributes\");\n+                        attributes_box = ~[];\n+                    }\n                     self.bump(); // empty\n                 }\n+                token::RBRACE => {\n+                    // fall through and out.\n+                }\n                 _ => {\n-                    let stmt = self.parse_stmt(initial_attrs);\n-                    initial_attrs = ~[];\n+                    let stmt = self.parse_stmt(attributes_box);\n+                    attributes_box = ~[];\n                     match stmt.node {\n                         stmt_expr(e, stmt_id) => {\n-                            // Expression without semicolon\n+                            // expression without semicolon\n                             match *self.token {\n                                 token::SEMI => {\n                                     self.bump();\n@@ -2772,7 +2779,7 @@ pub impl Parser {\n                                         self.fatal(\n                                             fmt!(\n                                                 \"expected `;` or `}` after \\\n-                                                expression but found `%s`\",\n+                                                 expression but found `%s`\",\n                                                 self.token_to_str(&t)\n                                             )\n                                         );\n@@ -2781,9 +2788,8 @@ pub impl Parser {\n                                 }\n                             }\n                         }\n-\n                         stmt_mac(ref m, _) => {\n-                            // Statement macro; might be an expr\n+                            // statement macro; might be an expr\n                             match *self.token {\n                                 token::SEMI => {\n                                     self.bump();\n@@ -2802,8 +2808,7 @@ pub impl Parser {\n                                 _ => { stmts.push(stmt); }\n                             }\n                         }\n-\n-                        _ => { // All other kinds of statements:\n+                        _ => { // all other kinds of statements:\n                             stmts.push(stmt);\n \n                             if classify::stmt_ends_with_semi(stmt) {\n@@ -2814,6 +2819,11 @@ pub impl Parser {\n                 }\n             }\n         }\n+\n+        if !vec::is_empty(attributes_box) {\n+            self.span_err(*self.last_span,~\"expected item after attributes\");\n+        }\n+\n         let hi = self.span.hi;\n         self.bump();\n         let bloc = ast::blk_ {\n@@ -3518,7 +3528,7 @@ pub impl Parser {\n \n         if first && attrs_remaining_len > 0u {\n             // We parsed attributes for the first item but didn't find it\n-            self.fatal(~\"expected item\");\n+            self.span_err(*self.last_span,~\"expected item after attributes\");\n         }\n \n         ast::_mod { view_items: view_items, items: items }\n@@ -3723,11 +3733,15 @@ pub impl Parser {\n                                first_item_attrs: ~[attribute])\n                                -> foreign_mod {\n         let ParsedItemsAndViewItems {\n-            attrs_remaining: _,\n+            attrs_remaining: attrs_remaining,\n             view_items: view_items,\n             items: _,\n             foreign_items: foreign_items\n         } = self.parse_foreign_items(first_item_attrs, true);\n+        if (! attrs_remaining.is_empty()) {\n+            self.span_err(*self.last_span,\n+                          ~\"expected item after attributes\");\n+        }\n         assert!(*self.token == token::RBRACE);\n         ast::foreign_mod {\n             sort: sort,"}, {"sha": "b4bad5abbf9364a934362761ad489e0390b1c7ad", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "patch": "@@ -411,8 +411,7 @@ pub impl ident_interner {\n }\n \n // return a fresh interner, preloaded with special identifiers.\n-// EFFECT: stores this interner in TLS\n-pub fn mk_fresh_ident_interner() -> @ident_interner {\n+fn mk_fresh_ident_interner() -> @ident_interner {\n     // the indices here must correspond to the numbers in\n     // special_idents.\n     let init_vec = ~[\n@@ -453,23 +452,27 @@ pub fn mk_fresh_ident_interner() -> @ident_interner {\n         \"Self\",               // 34\n     ];\n \n-    let rv = @ident_interner {\n+    @ident_interner {\n         interner: interner::StrInterner::prefill(init_vec)\n-    };\n-    unsafe {\n-        local_data::local_data_set(interner_key!(), @rv);\n     }\n-    rv\n }\n \n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n-pub fn mk_ident_interner() -> @ident_interner {\n+pub fn get_ident_interner() -> @ident_interner {\n     unsafe {\n-        match local_data::local_data_get(interner_key!()) {\n+        let key =\n+            (cast::transmute::<(uint, uint),\n+             &fn(v: @@::parse::token::ident_interner)>(\n+                 (-3 as uint, 0u)));\n+        match local_data::local_data_get(key) {\n             Some(interner) => *interner,\n             None => {\n-                mk_fresh_ident_interner()\n+                let interner = mk_fresh_ident_interner();\n+                unsafe {\n+                    local_data::local_data_set(key, @interner);\n+                }\n+                interner\n             }\n         }\n     }\n@@ -481,6 +484,12 @@ pub fn mk_fake_ident_interner() -> @ident_interner {\n     @ident_interner { interner: interner::StrInterner::new() }\n }\n \n+// maps a string to its interned representation\n+pub fn intern(str : &str) -> ast::ident {\n+    let interner = get_ident_interner();\n+    interner.intern(str)\n+}\n+\n /**\n  * All the valid words that have meaning in the Rust language.\n  *"}, {"sha": "0650df576031b6a964565ee36f5f4ec6be9ae3f8", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "patch": "@@ -25,11 +25,10 @@\n \n extern mod std;\n \n-// allow the interner_key macro\n-// to escape this module:\n-#[macro_escape]\n pub mod util {\n     pub mod interner;\n+    #[cfg(test)]\n+    pub mod parser_testing;\n }\n \n pub mod syntax {"}, {"sha": "5d49c8cd75d86d5fd54d0613a49c8d70c8913dfe", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "patch": "@@ -12,9 +12,6 @@\n // allows bidirectional lookup; i.e. given a value, one can easily find the\n // type, and vice versa.\n \n-// allow the interner_key macro to escape this module:\n-#[macro_escape];\n-\n use core::cmp::Equiv;\n use core::hashmap::HashMap;\n use syntax::parse::token::StringRef;\n@@ -78,6 +75,8 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     }\n }\n \n+// A StrInterner differs from Interner<String> in that it accepts\n+// borrowed pointers rather than @ ones, resulting in less allocation.\n pub struct StrInterner {\n     priv map: @mut HashMap<@~str, uint>,\n     priv vect: @mut ~[@~str],\n@@ -133,17 +132,6 @@ pub impl StrInterner {\n     }\n }\n \n-/* Key for thread-local data for sneaking interner information to the\n-* encoder/decoder. It sounds like a hack because it is one.\n-* Bonus ultra-hack: functions as keys don't work across crates,\n-* so we have to use a unique number. See taskgroup_key! in task.rs\n-* for another case of this. */\n-macro_rules! interner_key (\n-    () => (cast::transmute::<(uint, uint),\n-           &fn(v: @@::parse::token::ident_interner)>(\n-        (-3 as uint, 0u)))\n-)\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "1c2210c96b6c24b65fc8b92d200cb446166e9f21", "filename": "src/libsyntax/util/parser_testing.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::option::{Option,None};\n+use ast;\n+use parse::parser::Parser;\n+use parse::{new_parse_sess};\n+\n+use syntax::parse::{ParseSess,string_to_filemap,filemap_to_tts};\n+use syntax::parse::{new_parser_from_source_str};\n+\n+// map a string to tts, using a made-up filename: return both the token_trees\n+// and the ParseSess\n+pub fn string_to_tts_and_sess (source_str : @~str) -> (~[ast::token_tree],@mut ParseSess) {\n+    let ps = new_parse_sess(None);\n+    (filemap_to_tts(ps,string_to_filemap(ps,source_str,~\"bogofile\")),ps)\n+}\n+\n+pub fn string_to_parser_and_sess(source_str: @~str) -> (Parser,@mut ParseSess) {\n+    let ps = new_parse_sess(None);\n+    (new_parser_from_source_str(ps,~[],~\"bogofile\",source_str),ps)\n+}\n+\n+// map string to parser (via tts)\n+pub fn string_to_parser(source_str: @~str) -> Parser {\n+    let (p,_) = string_to_parser_and_sess(source_str);\n+    p\n+}\n+\n+pub fn string_to_crate (source_str : @~str) -> @ast::crate {\n+    string_to_parser(source_str).parse_crate_mod()\n+}\n+\n+// parse a string, return an expr\n+pub fn string_to_expr (source_str : @~str) -> @ast::expr {\n+    string_to_parser(source_str).parse_expr()\n+}\n+\n+// parse a string, return an item\n+pub fn string_to_item (source_str : @~str) -> Option<@ast::item> {\n+    string_to_parser(source_str).parse_item(~[])\n+}\n+\n+// parse a string, return an item and the ParseSess\n+pub fn string_to_item_and_sess (source_str : @~str) -> (Option<@ast::item>,@mut ParseSess) {\n+    let (p,ps) = string_to_parser_and_sess(source_str);\n+    (p.parse_item(~[]),ps)\n+}\n+\n+pub fn string_to_stmt (source_str : @~str) -> @ast::stmt {\n+    string_to_parser(source_str).parse_stmt(~[])\n+}\n+"}, {"sha": "cf0f4a6240e2b9f6ec15efbcf07649a4f942dda8", "filename": "src/test/compile-fail/attr-before-ext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs?ref=26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    #[attr]\n-    debug!(\"hi\"); //~ ERROR expected item after attrs\n+    #[attr] //~ ERROR expected item after attributes\n+    debug!(\"hi\");\n }"}, {"sha": "acc9aa8a9a13eee54b5715dd87b915601171bfb0", "filename": "src/test/compile-fail/attr-before-let.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Ftest%2Fcompile-fail%2Fattr-before-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26babaafcdbcfdf2e842d84dbeabbed0dae6efef/src%2Ftest%2Fcompile-fail%2Fattr-before-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-let.rs?ref=26babaafcdbcfdf2e842d84dbeabbed0dae6efef", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    #[attr]\n-    let _i = 0; //~ ERROR expected item\n+    #[attr] //~ ERROR expected item\n+    let _i = 0;\n }"}]}