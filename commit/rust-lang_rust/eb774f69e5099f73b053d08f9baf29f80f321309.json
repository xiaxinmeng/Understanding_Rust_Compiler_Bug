{"sha": "eb774f69e5099f73b053d08f9baf29f80f321309", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNzc0ZjY5ZTUwOTlmNzNiMDUzZDA4ZjliYWYyOWY4MGYzMjEzMDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-09T00:39:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-09T00:42:24Z"}, "message": "Update deriving to pass around the `cx` linearly", "tree": {"sha": "bed4353a32fe23409ebb7c6f2d4b7e90fa8c48cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bed4353a32fe23409ebb7c6f2d4b7e90fa8c48cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb774f69e5099f73b053d08f9baf29f80f321309", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb774f69e5099f73b053d08f9baf29f80f321309", "html_url": "https://github.com/rust-lang/rust/commit/eb774f69e5099f73b053d08f9baf29f80f321309", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb774f69e5099f73b053d08f9baf29f80f321309/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9b9067560b1664abc8408f89b98a2469dd856ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9b9067560b1664abc8408f89b98a2469dd856ed", "html_url": "https://github.com/rust-lang/rust/commit/e9b9067560b1664abc8408f89b98a2469dd856ed"}], "stats": {"total": 289, "additions": 157, "deletions": 132}, "files": [{"sha": "76cf5997aee75851e586ac63c8b7ed4c1819c069", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -20,8 +20,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              in_items: ~[@Item])\n                           -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"clone\", \"Clone\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -39,7 +38,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n pub fn expand_deriving_deep_clone(cx: &mut ExtCtxt,\n@@ -48,8 +47,7 @@ pub fn expand_deriving_deep_clone(cx: &mut ExtCtxt,\n                                   in_items: ~[@Item])\n     -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"clone\", \"DeepClone\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -69,7 +67,7 @@ pub fn expand_deriving_deep_clone(cx: &mut ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn cs_clone("}, {"sha": "4672f1a8db689131de597d841b04f13c03ff9e70", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -45,8 +45,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n     );\n \n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"cmp\", \"Eq\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -55,5 +54,5 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n             md!(\"ne\", cs_ne)\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }"}, {"sha": "1a8ace69307a7313b17c6fecd2dfe2580cfab3de", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -35,8 +35,7 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n     );\n \n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"cmp\", \"Ord\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -47,7 +46,7 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n             md!(\"ge\", false, true)\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n /// Strict inequality."}, {"sha": "7b7c1afa4d5cb990928adb196e025c1d03ca701d", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -24,8 +24,7 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n     }\n \n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"cmp\", \"TotalEq\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -42,5 +41,5 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n             }\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }"}, {"sha": "157b6dc7521b7a737dcd82bf56ac9ed9ae49dc00", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -21,8 +21,7 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                                 mitem: @MetaItem,\n                                 in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"cmp\", \"TotalOrd\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -40,7 +39,7 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n "}, {"sha": "fdf1ef17d538bf084884a8091526811bb39502a3", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -26,8 +26,7 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  mitem: @MetaItem,\n                                  in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new_(~[\"serialize\", \"Decodable\"], None,\n                          ~[~Literal(Path::new_local(\"__D\"))], true),\n         additional_bounds: ~[],\n@@ -50,7 +49,7 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,"}, {"sha": "7b87152b7115a1c122786310fe005c23cd0a2b5a", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -18,10 +18,9 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@Item])\n-    -> ~[@Item] {\n+                               -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"default\", \"Default\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -38,7 +37,7 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n             },\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "43edf6006b414bfd83e6f07f6a34db6a9ee5ed4f", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -87,8 +87,7 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  mitem: @MetaItem,\n                                  in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new_(~[\"serialize\", \"Encodable\"], None,\n                          ~[~Literal(Path::new_local(\"__E\"))], true),\n         additional_bounds: ~[],\n@@ -111,7 +110,7 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,"}, {"sha": "47be3067284a50f39c074bf2df5a5c691cc65bcd", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 122, "deletions": 82, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -193,13 +193,12 @@ pub use self::ty::*;\n mod ty;\n \n pub struct TraitDef<'a> {\n-    /// The extension context\n-    cx: &'a mut ExtCtxt<'a>,\n     /// The span for the current #[deriving(Foo)] header.\n     span: Span,\n \n     /// Path of the trait, including any type parameters\n     path: Path<'a>,\n+\n     /// Additional bounds required of any type parameters of the type,\n     /// other than the current trait\n     additional_bounds: ~[Ty<'a>],\n@@ -321,19 +320,22 @@ pub type EnumNonMatchFunc<'a> =\n \n impl<'a> TraitDef<'a> {\n     pub fn expand(&self,\n+                  cx: &mut ExtCtxt,\n                   _mitem: @ast::MetaItem,\n                   in_items: ~[@ast::Item]) -> ~[@ast::Item] {\n         let mut result = ~[];\n         for item in in_items.iter() {\n             result.push(*item);\n             match item.node {\n                 ast::ItemStruct(struct_def, ref generics) => {\n-                    result.push(self.expand_struct_def(struct_def,\n+                    result.push(self.expand_struct_def(cx,\n+                                                       struct_def,\n                                                        item.ident,\n                                                        generics));\n                 }\n                 ast::ItemEnum(ref enum_def, ref generics) => {\n-                    result.push(self.expand_enum_def(enum_def,\n+                    result.push(self.expand_enum_def(cx,\n+                                                     enum_def,\n                                                      item.ident,\n                                                      generics));\n                 }\n@@ -354,9 +356,9 @@ impl<'a> TraitDef<'a> {\n      *\n      */\n     fn create_derived_impl(&self,\n+                           cx: &mut ExtCtxt,\n                            type_ident: Ident, generics: &Generics,\n                            methods: ~[@ast::Method]) -> @ast::Item {\n-        let cx = &*self.cx;\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n         let mut trait_generics = self.generics.to_generics(cx, self.span,\n@@ -372,7 +374,8 @@ impl<'a> TraitDef<'a> {\n             let mut bounds = opt_vec::from(\n                 // extra restrictions on the generics parameters to the type being derived upon\n                 self.additional_bounds.map(|p| {\n-                    cx.typarambound(p.to_path(cx, self.span, type_ident, generics))\n+                    cx.typarambound(p.to_path(cx, self.span,\n+                                                  type_ident, generics))\n                 }));\n             // require the current trait\n             bounds.push(cx.typarambound(trait_path.clone()));\n@@ -393,15 +396,15 @@ impl<'a> TraitDef<'a> {\n         // Create the type of `self`.\n         let self_type = cx.ty_path(\n             cx.path_all(self.span, false, ~[ type_ident ], self_lifetimes,\n-                             opt_vec::take_vec(self_ty_params)), None);\n+                        opt_vec::take_vec(self_ty_params)), None);\n \n         let doc_attr = cx.attribute(\n             self.span,\n             cx.meta_name_value(self.span,\n                                InternedString::new(\"doc\"),\n                                ast::LitStr(token::intern_and_get_ident(\n-                                       \"Automatically derived.\"),\n-                                       ast::CookedStr)));\n+                                               \"Automatically derived.\"),\n+                                           ast::CookedStr)));\n         cx.item(\n             self.span,\n             ::parse::token::special_idents::clownshoes_extensions,\n@@ -411,68 +414,77 @@ impl<'a> TraitDef<'a> {\n     }\n \n     fn expand_struct_def(&self,\n+                         cx: &mut ExtCtxt,\n                          struct_def: &StructDef,\n                          type_ident: Ident,\n                          generics: &Generics) -> @ast::Item {\n         let methods = self.methods.map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n-                method_def.split_self_nonself_args(self, type_ident, generics);\n+                method_def.split_self_nonself_args(\n+                    cx, self, type_ident, generics);\n \n             let body = if method_def.is_static() {\n                 method_def.expand_static_struct_method_body(\n+                    cx,\n                     self,\n                     struct_def,\n                     type_ident,\n                     self_args, nonself_args)\n             } else {\n-                method_def.expand_struct_method_body(self,\n+                method_def.expand_struct_method_body(cx,\n+                                                     self,\n                                                      struct_def,\n                                                      type_ident,\n                                                      self_args, nonself_args)\n             };\n \n-            method_def.create_method(self,\n+            method_def.create_method(cx, self,\n                                      type_ident, generics,\n                                      explicit_self, tys,\n                                      body)\n         });\n \n-        self.create_derived_impl(type_ident, generics, methods)\n+        self.create_derived_impl(cx, type_ident, generics, methods)\n     }\n \n     fn expand_enum_def(&self,\n+                       cx: &mut ExtCtxt,\n                        enum_def: &EnumDef,\n                        type_ident: Ident,\n                        generics: &Generics) -> @ast::Item {\n         let methods = self.methods.map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n-                method_def.split_self_nonself_args(self, type_ident, generics);\n+                method_def.split_self_nonself_args(cx, self,\n+                                                   type_ident, generics);\n \n             let body = if method_def.is_static() {\n                 method_def.expand_static_enum_method_body(\n+                    cx,\n                     self,\n                     enum_def,\n                     type_ident,\n                     self_args, nonself_args)\n             } else {\n-                method_def.expand_enum_method_body(self,\n+                method_def.expand_enum_method_body(cx,\n+                                                   self,\n                                                    enum_def,\n                                                    type_ident,\n                                                    self_args, nonself_args)\n             };\n \n-            method_def.create_method(self,\n+            method_def.create_method(cx, self,\n                                      type_ident, generics,\n                                      explicit_self, tys,\n                                      body)\n         });\n \n-        self.create_derived_impl(type_ident, generics, methods)\n+        self.create_derived_impl(cx, type_ident, generics, methods)\n     }\n }\n \n impl<'a> MethodDef<'a> {\n     fn call_substructure_method(&self,\n+                                cx: &mut ExtCtxt,\n                                 trait_: &TraitDef,\n                                 type_ident: Ident,\n                                 self_args: &[@Expr],\n@@ -481,26 +493,33 @@ impl<'a> MethodDef<'a> {\n         -> @Expr {\n         let substructure = Substructure {\n             type_ident: type_ident,\n-            method_ident: trait_.cx.ident_of(self.name),\n+            method_ident: cx.ident_of(self.name),\n             self_args: self_args,\n             nonself_args: nonself_args,\n             fields: fields\n         };\n-        (self.combine_substructure)(trait_.cx, trait_.span,\n+        (self.combine_substructure)(cx, trait_.span,\n                                     &substructure)\n     }\n \n-    fn get_ret_ty(&self, trait_: &TraitDef,\n-                  generics: &Generics, type_ident: Ident) -> P<ast::Ty> {\n-        self.ret_ty.to_ty(trait_.cx, trait_.span, type_ident, generics)\n+    fn get_ret_ty(&self,\n+                  cx: &mut ExtCtxt,\n+                  trait_: &TraitDef,\n+                  generics: &Generics,\n+                  type_ident: Ident)\n+                  -> P<ast::Ty> {\n+        self.ret_ty.to_ty(cx, trait_.span, type_ident, generics)\n     }\n \n     fn is_static(&self) -> bool {\n         self.explicit_self.is_none()\n     }\n \n-    fn split_self_nonself_args(&self, trait_: &TraitDef,\n-                               type_ident: Ident, generics: &Generics)\n+    fn split_self_nonself_args(&self,\n+                               cx: &mut ExtCtxt,\n+                               trait_: &TraitDef,\n+                               type_ident: Ident,\n+                               generics: &Generics)\n         -> (ast::ExplicitSelf, ~[@Expr], ~[@Expr], ~[(Ident, P<ast::Ty>)]) {\n \n         let mut self_args = ~[];\n@@ -511,7 +530,7 @@ impl<'a> MethodDef<'a> {\n         let ast_explicit_self = match self.explicit_self {\n             Some(ref self_ptr) => {\n                 let (self_expr, explicit_self) =\n-                    ty::get_explicit_self(trait_.cx, trait_.span, self_ptr);\n+                    ty::get_explicit_self(cx, trait_.span, self_ptr);\n \n                 self_args.push(self_expr);\n                 nonstatic = true;\n@@ -522,11 +541,11 @@ impl<'a> MethodDef<'a> {\n         };\n \n         for (i, ty) in self.args.iter().enumerate() {\n-            let ast_ty = ty.to_ty(trait_.cx, trait_.span, type_ident, generics);\n-            let ident = trait_.cx.ident_of(format!(\"__arg_{}\", i));\n+            let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n+            let ident = cx.ident_of(format!(\"__arg_{}\", i));\n             arg_tys.push((ident, ast_ty));\n \n-            let arg_expr = trait_.cx.expr_ident(trait_.span, ident);\n+            let arg_expr = cx.expr_ident(trait_.span, ident);\n \n             match *ty {\n                 // for static methods, just treat any Self\n@@ -535,7 +554,7 @@ impl<'a> MethodDef<'a> {\n                     self_args.push(arg_expr);\n                 }\n                 Ptr(~Self, _) if nonstatic => {\n-                    self_args.push(trait_.cx.expr_deref(trait_.span, arg_expr))\n+                    self_args.push(cx.expr_deref(trait_.span, arg_expr))\n                 }\n                 _ => {\n                     nonself_args.push(arg_expr);\n@@ -546,35 +565,37 @@ impl<'a> MethodDef<'a> {\n         (ast_explicit_self, self_args, nonself_args, arg_tys)\n     }\n \n-    fn create_method(&self, trait_: &TraitDef,\n+    fn create_method(&self,\n+                     cx: &mut ExtCtxt,\n+                     trait_: &TraitDef,\n                      type_ident: Ident,\n                      generics: &Generics,\n                      explicit_self: ast::ExplicitSelf,\n                      arg_types: ~[(Ident, P<ast::Ty>)],\n                      body: @Expr) -> @ast::Method {\n         // create the generics that aren't for Self\n-        let fn_generics = self.generics.to_generics(trait_.cx, trait_.span, type_ident, generics);\n+        let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n         let self_arg = match explicit_self.node {\n             ast::SelfStatic => None,\n             _ => Some(ast::Arg::new_self(trait_.span, ast::MutImmutable))\n         };\n         let args = arg_types.move_iter().map(|(name, ty)| {\n-            trait_.cx.arg(trait_.span, name, ty)\n+            cx.arg(trait_.span, name, ty)\n         });\n         let args = self_arg.move_iter().chain(args).collect();\n \n-        let ret_type = self.get_ret_ty(trait_, generics, type_ident);\n+        let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n \n-        let method_ident = trait_.cx.ident_of(self.name);\n-        let fn_decl = trait_.cx.fn_decl(args, ret_type);\n-        let body_block = trait_.cx.block_expr(body);\n+        let method_ident = cx.ident_of(self.name);\n+        let fn_decl = cx.fn_decl(args, ret_type);\n+        let body_block = cx.block_expr(body);\n \n         let attrs = if self.inline {\n             ~[\n-                trait_.cx\n+                cx\n                       .attribute(trait_.span,\n-                                 trait_.cx\n+                                 cx\n                                        .meta_word(trait_.span,\n                                                   InternedString::new(\n                                                       \"inline\")))\n@@ -620,6 +641,7 @@ impl<'a> MethodDef<'a> {\n    ~~~\n     */\n     fn expand_struct_method_body(&self,\n+                                 cx: &mut ExtCtxt,\n                                  trait_: &TraitDef,\n                                  struct_def: &StructDef,\n                                  type_ident: Ident,\n@@ -631,7 +653,7 @@ impl<'a> MethodDef<'a> {\n                                  // [fields of next Self arg], [etc]]\n         let mut patterns = ~[];\n         for i in range(0u, self_args.len()) {\n-            let (pat, ident_expr) = trait_.create_struct_pattern(type_ident, struct_def,\n+            let (pat, ident_expr) = trait_.create_struct_pattern(cx, type_ident, struct_def,\n                                                                  format!(\"__self_{}\", i),\n                                                                  ast::MutImmutable);\n             patterns.push(pat);\n@@ -655,13 +677,14 @@ impl<'a> MethodDef<'a> {\n                     }\n                 }).collect()\n             }\n-            [] => { trait_.cx.span_bug(trait_.span,\n-                                       \"no self arguments to non-static method \\\n-                                       in generic `deriving`\") }\n+            [] => { cx.span_bug(trait_.span,\n+                                \"no self arguments to non-static method \\\n+                                in generic `deriving`\") }\n         };\n \n         // body of the inner most destructuring match\n         let mut body = self.call_substructure_method(\n+            cx,\n             trait_,\n             type_ident,\n             self_args,\n@@ -672,22 +695,24 @@ impl<'a> MethodDef<'a> {\n         // structs. This is actually right-to-left, but it shoudn't\n         // matter.\n         for (&arg_expr, &pat) in self_args.iter().zip(patterns.iter()) {\n-            body = trait_.cx.expr_match(trait_.span, arg_expr,\n-                                        ~[ trait_.cx.arm(trait_.span, ~[pat], body) ])\n+            body = cx.expr_match(trait_.span, arg_expr,\n+                                     ~[ cx.arm(trait_.span, ~[pat], body) ])\n         }\n         body\n     }\n \n     fn expand_static_struct_method_body(&self,\n+                                        cx: &mut ExtCtxt,\n                                         trait_: &TraitDef,\n                                         struct_def: &StructDef,\n                                         type_ident: Ident,\n                                         self_args: &[@Expr],\n                                         nonself_args: &[@Expr])\n         -> @Expr {\n-        let summary = trait_.summarise_struct(struct_def);\n+        let summary = trait_.summarise_struct(cx, struct_def);\n \n-        self.call_substructure_method(trait_,\n+        self.call_substructure_method(cx,\n+                                      trait_,\n                                       type_ident,\n                                       self_args, nonself_args,\n                                       &StaticStruct(struct_def, summary))\n@@ -720,14 +745,15 @@ impl<'a> MethodDef<'a> {\n    ~~~\n     */\n     fn expand_enum_method_body(&self,\n+                               cx: &mut ExtCtxt,\n                                trait_: &TraitDef,\n                                enum_def: &EnumDef,\n                                type_ident: Ident,\n                                self_args: &[@Expr],\n                                nonself_args: &[@Expr])\n-        -> @Expr {\n+                               -> @Expr {\n         let mut matches = ~[];\n-        self.build_enum_match(trait_, enum_def, type_ident,\n+        self.build_enum_match(cx, trait_, enum_def, type_ident,\n                               self_args, nonself_args,\n                               None, &mut matches, 0)\n     }\n@@ -755,6 +781,7 @@ impl<'a> MethodDef<'a> {\n     the first call).\n     */\n     fn build_enum_match(&self,\n+                        cx: &mut ExtCtxt,\n                         trait_: &TraitDef,\n                         enum_def: &EnumDef,\n                         type_ident: Ident,\n@@ -764,13 +791,13 @@ impl<'a> MethodDef<'a> {\n                         matches_so_far: &mut ~[(uint, P<ast::Variant>,\n                                               ~[(Span, Option<Ident>, @Expr)])],\n                         match_count: uint) -> @Expr {\n-        let cx = &trait_.cx;\n         if match_count == self_args.len() {\n             // we've matched against all arguments, so make the final\n             // expression at the bottom of the match tree\n             if matches_so_far.len() == 0 {\n                 cx.span_bug(trait_.span,\n-                            \"no self match on an enum in generic `deriving`\");\n+                                \"no self match on an enum in \\\n+                                generic `deriving`\");\n             }\n             // we currently have a vec of vecs, where each\n             // subvec is the fields of one of the arguments,\n@@ -820,7 +847,7 @@ impl<'a> MethodDef<'a> {\n                     substructure = EnumNonMatching(*matches_so_far);\n                 }\n             }\n-            self.call_substructure_method(trait_, type_ident,\n+            self.call_substructure_method(cx, trait_, type_ident,\n                                           self_args, nonself_args,\n                                           &substructure)\n \n@@ -846,12 +873,14 @@ impl<'a> MethodDef<'a> {\n \n                 // matching-variant match\n                 let variant = enum_def.variants[index];\n-                let (pattern, idents) = trait_.create_enum_variant_pattern(variant,\n+                let (pattern, idents) = trait_.create_enum_variant_pattern(cx,\n+                                                                           variant,\n                                                                            current_match_str,\n                                                                            ast::MutImmutable);\n \n                 matches_so_far.push((index, variant, idents));\n-                let arm_expr = self.build_enum_match(trait_,\n+                let arm_expr = self.build_enum_match(cx,\n+                                                     trait_,\n                                                      enum_def,\n                                                      type_ident,\n                                                      self_args, nonself_args,\n@@ -863,18 +892,20 @@ impl<'a> MethodDef<'a> {\n \n                 if enum_def.variants.len() > 1 {\n                     let e = &EnumNonMatching(&[]);\n-                    let wild_expr = self.call_substructure_method(trait_, type_ident,\n+                    let wild_expr = self.call_substructure_method(cx, trait_, type_ident,\n                                                                   self_args, nonself_args,\n                                                                   e);\n-                    let wild_arm = cx.arm(trait_.span,\n-                                          ~[ cx.pat_wild(trait_.span) ],\n-                                          wild_expr);\n+                    let wild_arm = cx.arm(\n+                        trait_.span,\n+                        ~[ cx.pat_wild(trait_.span) ],\n+                        wild_expr);\n                     arms.push(wild_arm);\n                 }\n             } else {\n                 // create an arm matching on each variant\n                 for (index, &variant) in enum_def.variants.iter().enumerate() {\n-                    let (pattern, idents) = trait_.create_enum_variant_pattern(variant,\n+                    let (pattern, idents) = trait_.create_enum_variant_pattern(cx,\n+                                                                               variant,\n                                                                                current_match_str,\n                                                                                ast::MutImmutable);\n \n@@ -885,7 +916,8 @@ impl<'a> MethodDef<'a> {\n                             Some(i) if index == i => Some(i),\n                             _ => None\n                         };\n-                    let arm_expr = self.build_enum_match(trait_,\n+                    let arm_expr = self.build_enum_match(cx,\n+                                                         trait_,\n                                                          enum_def,\n                                                          type_ident,\n                                                          self_args, nonself_args,\n@@ -905,6 +937,7 @@ impl<'a> MethodDef<'a> {\n     }\n \n     fn expand_static_enum_method_body(&self,\n+                                      cx: &mut ExtCtxt,\n                                       trait_: &TraitDef,\n                                       enum_def: &EnumDef,\n                                       type_ident: Ident,\n@@ -915,15 +948,15 @@ impl<'a> MethodDef<'a> {\n             let ident = v.node.name;\n             let summary = match v.node.kind {\n                 ast::TupleVariantKind(ref args) => {\n-                    Unnamed(args.map(|va| trait_.set_expn_info(va.ty.span)))\n+                    Unnamed(args.map(|va| trait_.set_expn_info(cx, va.ty.span)))\n                 }\n                 ast::StructVariantKind(struct_def) => {\n-                    trait_.summarise_struct(struct_def)\n+                    trait_.summarise_struct(cx, struct_def)\n                 }\n             };\n             (ident, v.span, summary)\n         });\n-        self.call_substructure_method(trait_, type_ident,\n+        self.call_substructure_method(cx, trait_, type_ident,\n                                       self_args, nonself_args,\n                                       &StaticEnum(enum_def, summary))\n     }\n@@ -936,9 +969,11 @@ enum StructType {\n \n // general helper methods.\n impl<'a> TraitDef<'a> {\n-    fn set_expn_info(&self, mut to_set: Span) -> Span {\n+    fn set_expn_info(&self,\n+                     cx: &mut ExtCtxt,\n+                     mut to_set: Span) -> Span {\n         let trait_name = match self.path.path.last() {\n-            None => self.cx.span_bug(self.span, \"trait with empty path in generic `deriving`\"),\n+            None => cx.span_bug(self.span, \"trait with empty path in generic `deriving`\"),\n             Some(name) => *name\n         };\n         to_set.expn_info = Some(@codemap::ExpnInfo {\n@@ -952,21 +987,23 @@ impl<'a> TraitDef<'a> {\n         to_set\n     }\n \n-    fn summarise_struct(&self, struct_def: &StructDef) -> StaticFields {\n+    fn summarise_struct(&self,\n+                        cx: &mut ExtCtxt,\n+                        struct_def: &StructDef) -> StaticFields {\n         let mut named_idents = ~[];\n         let mut just_spans = ~[];\n         for field in struct_def.fields.iter(){\n-            let sp = self.set_expn_info(field.span);\n+            let sp = self.set_expn_info(cx, field.span);\n             match field.node.kind {\n                 ast::NamedField(ident, _) => named_idents.push((ident, sp)),\n                 ast::UnnamedField => just_spans.push(sp),\n             }\n         }\n \n         match (just_spans.is_empty(), named_idents.is_empty()) {\n-            (false, false) => self.cx.span_bug(self.span,\n-                                               \"a struct with named and unnamed \\\n-                                               fields in generic `deriving`\"),\n+            (false, false) => cx.span_bug(self.span,\n+                                          \"a struct with named and unnamed \\\n+                                          fields in generic `deriving`\"),\n             // named fields\n             (_, false) => Named(named_idents),\n             // tuple structs (includes empty structs)\n@@ -975,23 +1012,23 @@ impl<'a> TraitDef<'a> {\n     }\n \n     fn create_subpatterns(&self,\n+                          cx: &mut ExtCtxt,\n                           field_paths: ~[ast::Path],\n                           mutbl: ast::Mutability)\n                           -> ~[@ast::Pat] {\n         field_paths.map(|path| {\n-            self.cx.pat(path.span,\n+            cx.pat(path.span,\n                         ast::PatIdent(ast::BindByRef(mutbl), (*path).clone(), None))\n             })\n     }\n \n     fn create_struct_pattern(&self,\n+                             cx: &mut ExtCtxt,\n                              struct_ident: Ident,\n                              struct_def: &StructDef,\n                              prefix: &str,\n                              mutbl: ast::Mutability)\n-        -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n-        let cx = &self.cx;\n-\n+                             -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n         if struct_def.fields.is_empty() {\n             return (\n                 cx.pat_ident_binding_mode(\n@@ -1006,7 +1043,7 @@ impl<'a> TraitDef<'a> {\n         let mut struct_type = Unknown;\n \n         for (i, struct_field) in struct_def.fields.iter().enumerate() {\n-            let sp = self.set_expn_info(struct_field.span);\n+            let sp = self.set_expn_info(cx, struct_field.span);\n             let opt_id = match struct_field.node.kind {\n                 ast::NamedField(ident, _) if (struct_type == Unknown ||\n                                               struct_type == Record) => {\n@@ -1024,11 +1061,13 @@ impl<'a> TraitDef<'a> {\n             };\n             let path = cx.path_ident(sp, cx.ident_of(format!(\"{}_{}\", prefix, i)));\n             paths.push(path.clone());\n-            let val = cx.expr(sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(path))));\n+            let val = cx.expr(\n+                sp, ast::ExprParen(\n+                    cx.expr_deref(sp, cx.expr_path(path))));\n             ident_expr.push((sp, opt_id, val));\n         }\n \n-        let subpats = self.create_subpatterns(paths, mutbl);\n+        let subpats = self.create_subpatterns(cx, paths, mutbl);\n \n         // struct_type is definitely not Unknown, since struct_def.fields\n         // must be nonempty to reach here\n@@ -1046,17 +1085,17 @@ impl<'a> TraitDef<'a> {\n     }\n \n     fn create_enum_variant_pattern(&self,\n+                                   cx: &mut ExtCtxt,\n                                    variant: &ast::Variant,\n                                    prefix: &str,\n                                    mutbl: ast::Mutability)\n         -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n-        let cx = &*self.cx;\n         let variant_ident = variant.node.name;\n         match variant.node.kind {\n             ast::TupleVariantKind(ref variant_args) => {\n                 if variant_args.is_empty() {\n                     return (cx.pat_ident_binding_mode(variant.span, variant_ident,\n-                                                      ast::BindByValue(ast::MutImmutable)),\n+                                                          ast::BindByValue(ast::MutImmutable)),\n                             ~[]);\n                 }\n \n@@ -1065,21 +1104,22 @@ impl<'a> TraitDef<'a> {\n                 let mut paths = ~[];\n                 let mut ident_expr = ~[];\n                 for (i, va) in variant_args.iter().enumerate() {\n-                    let sp = self.set_expn_info(va.ty.span);\n+                    let sp = self.set_expn_info(cx, va.ty.span);\n                     let path = cx.path_ident(sp, cx.ident_of(format!(\"{}_{}\", prefix, i)));\n \n                     paths.push(path.clone());\n-                    let val = cx.expr(sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(path))));\n+                    let val = cx.expr(\n+                        sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(path))));\n                     ident_expr.push((sp, None, val));\n                 }\n \n-                let subpats = self.create_subpatterns(paths, mutbl);\n+                let subpats = self.create_subpatterns(cx, paths, mutbl);\n \n                 (cx.pat_enum(variant.span, matching_path, subpats),\n                  ident_expr)\n             }\n             ast::StructVariantKind(struct_def) => {\n-                self.create_struct_pattern(variant_ident, struct_def,\n+                self.create_struct_pattern(cx, variant_ident, struct_def,\n                                            prefix, mutbl)\n             }\n         }"}, {"sha": "19e81b81df6a650434d04bb28d05ef63791050e4", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -20,8 +20,7 @@ pub fn expand_deriving_iter_bytes(cx: &mut ExtCtxt,\n                                   mitem: @MetaItem,\n                                   in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"to_bytes\", \"IterBytes\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -42,7 +41,7 @@ pub fn expand_deriving_iter_bytes(cx: &mut ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn iter_bytes_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "1b356667b6b313da7e7cc7137e9223e486773fe6", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -21,8 +21,7 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                       mitem: @MetaItem,\n                                       in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"num\", \"FromPrimitive\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -62,7 +61,7 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "a40317286c96083615f102fcbdeff9455bd81ca6", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -20,10 +20,9 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@Item])\n-    -> ~[@Item] {\n+                            -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"rand\", \"Rand\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -47,7 +46,7 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n             }\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "e2d507f30351054190ddd95baa8de70a65d42737", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -24,14 +24,13 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@Item])\n-    -> ~[@Item] {\n+                            -> ~[@Item] {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(~Literal(Path::new(~[\"std\", \"fmt\", \"Formatter\"])),\n                    Borrowed(None, ast::MutMutable));\n \n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"fmt\", \"Show\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -48,7 +47,7 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n             }\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n // we construct a format string and then defer to std::fmt, since that"}, {"sha": "186f12544935d519886d0cb2830072cebf5f3881", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -21,10 +21,9 @@ pub fn expand_deriving_to_str(cx: &mut ExtCtxt,\n                               span: Span,\n                               mitem: @MetaItem,\n                               in_items: ~[@Item])\n-    -> ~[@Item] {\n+                              -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"to_str\", \"ToStr\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -41,7 +40,7 @@ pub fn expand_deriving_to_str(cx: &mut ExtCtxt,\n             }\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n // It used to be the case that this deriving implementation invoked"}, {"sha": "ca5c1543d88dc66f5e30772e8199e7beccbdd1c0", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb774f69e5099f73b053d08f9baf29f80f321309/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=eb774f69e5099f73b053d08f9baf29f80f321309", "patch": "@@ -18,10 +18,9 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@Item])\n-    -> ~[@Item] {\n+                            -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"num\", \"Zero\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -54,7 +53,7 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n             }\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {"}]}