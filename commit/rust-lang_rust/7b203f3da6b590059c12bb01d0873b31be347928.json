{"sha": "7b203f3da6b590059c12bb01d0873b31be347928", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMjAzZjNkYTZiNTkwMDU5YzEyYmIwMWQwODczYjMxYmUzNDc5Mjg=", "commit": {"author": {"name": "Henri Lunnikivi", "email": "henri.lunnikivi@gmail.com", "date": "2019-10-31T16:02:02Z"}, "committer": {"name": "Henri Lunnikivi", "email": "henri.lunnikivi@tuni.fi", "date": "2020-10-31T13:49:58Z"}, "message": "Implement field_reassign_with_default\n\n- Implement `field_reassign_with_default` as a `LateLintPass`\n- Avoid triggering `default_trait_access` on a span already linted by\n`field_reassigned_with_default`\n- Merge `default_trait_access` and `field_reassign_with_default` into\n`Default`\n- Co-authored-by: Eduardo Broto <ebroto@tutanota.com>\n- Fixes #568", "tree": {"sha": "37937148abe9f7883f6803172f23d12fc1802c5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37937148abe9f7883f6803172f23d12fc1802c5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b203f3da6b590059c12bb01d0873b31be347928", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b203f3da6b590059c12bb01d0873b31be347928", "html_url": "https://github.com/rust-lang/rust/commit/7b203f3da6b590059c12bb01d0873b31be347928", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b203f3da6b590059c12bb01d0873b31be347928/comments", "author": null, "committer": null, "parents": [{"sha": "e298c830af37e48a7778b3e6a487a2107230e8a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e298c830af37e48a7778b3e6a487a2107230e8a6", "html_url": "https://github.com/rust-lang/rust/commit/e298c830af37e48a7778b3e6a487a2107230e8a6"}], "stats": {"total": 572, "additions": 505, "deletions": 67}, "files": [{"sha": "36b54416a195505ae1daa42f41547f1bb998882b", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b203f3da6b590059c12bb01d0873b31be347928/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b203f3da6b590059c12bb01d0873b31be347928/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=7b203f3da6b590059c12bb01d0873b31be347928", "patch": "@@ -1714,6 +1714,7 @@ Released 2018-09-13\n [`extend_from_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#extend_from_slice\n [`extra_unused_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#extra_unused_lifetimes\n [`fallible_impl_from`]: https://rust-lang.github.io/rust-clippy/master/index.html#fallible_impl_from\n+[`field_reassign_with_default`]: https://rust-lang.github.io/rust-clippy/master/index.html#field_reassign_with_default\n [`filetype_is_file`]: https://rust-lang.github.io/rust-clippy/master/index.html#filetype_is_file\n [`filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#filter_map\n [`filter_map_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#filter_map_next"}, {"sha": "612c5355338a140f1ed371a01779fee6a4fbf20a", "filename": "clippy_lints/src/default.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/7b203f3da6b590059c12bb01d0873b31be347928/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b203f3da6b590059c12bb01d0873b31be347928/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=7b203f3da6b590059c12bb01d0873b31be347928", "patch": "@@ -0,0 +1,304 @@\n+use crate::utils::{any_parent_is_automatically_derived, contains_name, match_def_path, paths, qpath_res, snippet};\n+use crate::utils::{span_lint_and_note, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir::def::Res;\n+use rustc_hir::{Block, Expr, ExprKind, PatKind, QPath, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, Adt, Ty};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for literal calls to `Default::default()`.\n+    ///\n+    /// **Why is this bad?** It's more clear to the reader to use the name of the type whose default is\n+    /// being gotten than the generic `Default`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// let s: String = Default::default();\n+    ///\n+    /// // Good\n+    /// let s = String::default();\n+    /// ```\n+    pub DEFAULT_TRAIT_ACCESS,\n+    pedantic,\n+    \"checks for literal calls to `Default::default()`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for immediate reassignment of fields initialized\n+    /// with Default::default().\n+    ///\n+    /// **Why is this bad?**It's more idiomatic to use the [functional update syntax](https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax).\n+    ///\n+    /// **Known problems:** Assignments to patterns that are of tuple type are not linted.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```\n+    /// # #[derive(Default)]\n+    /// # struct A { i: i32 }\n+    /// let mut a: A = Default::default();\n+    /// a.i = 42;\n+    /// ```\n+    /// Use instead:\n+    /// ```\n+    /// # #[derive(Default)]\n+    /// # struct A { i: i32 }\n+    /// let a = A {\n+    ///     i: 42,\n+    ///     .. Default::default()\n+    /// };\n+    /// ```\n+    pub FIELD_REASSIGN_WITH_DEFAULT,\n+    style,\n+    \"binding initialized with Default should have its fields set in the initializer\"\n+}\n+\n+#[derive(Default)]\n+pub struct Default {\n+    // Spans linted by `field_reassign_with_default`.\n+    reassigned_linted: FxHashSet<Span>,\n+}\n+\n+impl_lint_pass!(Default => [DEFAULT_TRAIT_ACCESS, FIELD_REASSIGN_WITH_DEFAULT]);\n+\n+impl LateLintPass<'_> for Default {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            // Avoid cases already linted by `field_reassign_with_default`\n+            if !self.reassigned_linted.contains(&expr.span);\n+            if let ExprKind::Call(ref path, ..) = expr.kind;\n+            if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n+            if let ExprKind::Path(ref qpath) = path.kind;\n+            if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n+            if match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n+            // Detect and ignore <Foo as Default>::default() because these calls do explicitly name the type.\n+            if let QPath::Resolved(None, _path) = qpath;\n+            then {\n+                let expr_ty = cx.typeck_results().expr_ty(expr);\n+                if let ty::Adt(def, ..) = expr_ty.kind() {\n+                    // TODO: Work out a way to put \"whatever the imported way of referencing\n+                    // this type in this file\" rather than a fully-qualified type.\n+                    let replacement = format!(\"{}::default()\", cx.tcx.def_path_str(def.did));\n+                    span_lint_and_sugg(\n+                        cx,\n+                        DEFAULT_TRAIT_ACCESS,\n+                        expr.span,\n+                        &format!(\"calling `{}` is more clear than this expression\", replacement),\n+                        \"try\",\n+                        replacement,\n+                        Applicability::Unspecified, // First resolve the TODO above\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_block<'tcx>(&mut self, cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n+        // find all binding statements like `let mut _ = T::default()` where `T::default()` is the\n+        // `default` method of the `Default` trait, and store statement index in current block being\n+        // checked and the name of the bound variable\n+        let binding_statements_using_default = enumerate_bindings_using_default(cx, block);\n+\n+        // start from the `let mut _ = _::default();` and look at all the following\n+        // statements, see if they re-assign the fields of the binding\n+        for (stmt_idx, binding_name, binding_type, span) in binding_statements_using_default {\n+            // the last statement of a block cannot trigger the lint\n+            if stmt_idx == block.stmts.len() - 1 {\n+                break;\n+            }\n+\n+            // find all \"later statement\"'s where the fields of the binding set as\n+            // Default::default() get reassigned, unless the reassignment refers to the original binding\n+            let mut first_assign = None;\n+            let mut assigned_fields = Vec::new();\n+            let mut cancel_lint = false;\n+            for consecutive_statement in &block.stmts[stmt_idx + 1..] {\n+                // interrupt if the statement is a let binding (`Local`) that shadows the original\n+                // binding\n+                if stmt_shadows_binding(consecutive_statement, binding_name) {\n+                    break;\n+                }\n+                // find out if and which field was set by this `consecutive_statement`\n+                else if let Some((field_ident, assign_rhs)) =\n+                    field_reassigned_by_stmt(consecutive_statement, binding_name)\n+                {\n+                    // interrupt and cancel lint if assign_rhs references the original binding\n+                    if contains_name(binding_name, assign_rhs) {\n+                        cancel_lint = true;\n+                        break;\n+                    }\n+\n+                    // if the field was previously assigned, replace the assignment, otherwise insert the assignment\n+                    if let Some(prev) = assigned_fields\n+                        .iter_mut()\n+                        .find(|(field_name, _)| field_name == &field_ident.name)\n+                    {\n+                        *prev = (field_ident.name, assign_rhs);\n+                    } else {\n+                        assigned_fields.push((field_ident.name, assign_rhs));\n+                    }\n+\n+                    // also set first instance of error for help message\n+                    if first_assign.is_none() {\n+                        first_assign = Some(consecutive_statement);\n+                    }\n+                }\n+                // interrupt also if no field was assigned, since we only want to look at consecutive statements\n+                else {\n+                    break;\n+                }\n+            }\n+\n+            // if there are incorrectly assigned fields, do a span_lint_and_note to suggest\n+            // construction using `Ty { fields, ..Default::default() }`\n+            if !assigned_fields.is_empty() && !cancel_lint {\n+                // take the original assignment as span\n+                let stmt = &block.stmts[stmt_idx];\n+\n+                if let StmtKind::Local(preceding_local) = &stmt.kind {\n+                    // filter out fields like `= Default::default()`, because the FRU already covers them\n+                    let assigned_fields = assigned_fields\n+                        .into_iter()\n+                        .filter(|(_, rhs)| !is_expr_default(rhs, cx))\n+                        .collect::<Vec<(Symbol, &Expr<'_>)>>();\n+\n+                    // if all fields of the struct are not assigned, add `.. Default::default()` to the suggestion.\n+                    let ext_with_default = !fields_of_type(binding_type)\n+                        .iter()\n+                        .all(|field| assigned_fields.iter().any(|(a, _)| a == &field.name));\n+\n+                    let field_list = assigned_fields\n+                        .into_iter()\n+                        .map(|(field, rhs)| {\n+                            // extract and store the assigned value for help message\n+                            let value_snippet = snippet(cx, rhs.span, \"..\");\n+                            format!(\"{}: {}\", field, value_snippet)\n+                        })\n+                        .collect::<Vec<String>>()\n+                        .join(\", \");\n+\n+                    let sugg = if ext_with_default {\n+                        if field_list.is_empty() {\n+                            format!(\"{}::default()\", binding_type)\n+                        } else {\n+                            format!(\"{} {{ {}, ..Default::default() }}\", binding_type, field_list)\n+                        }\n+                    } else {\n+                        format!(\"{} {{ {} }}\", binding_type, field_list)\n+                    };\n+\n+                    // span lint once per statement that binds default\n+                    span_lint_and_note(\n+                        cx,\n+                        FIELD_REASSIGN_WITH_DEFAULT,\n+                        first_assign.unwrap().span,\n+                        \"field assignment outside of initializer for an instance created with Default::default()\",\n+                        Some(preceding_local.span),\n+                        &format!(\n+                            \"consider initializing the variable with `{}` and removing relevant reassignments\",\n+                            sugg\n+                        ),\n+                    );\n+                    self.reassigned_linted.insert(span);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Checks if the given expression is the `default` method belonging to the `Default` trait.\n+fn is_expr_default<'tcx>(expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> bool {\n+    if_chain! {\n+        if let ExprKind::Call(ref fn_expr, _) = &expr.kind;\n+        if let ExprKind::Path(qpath) = &fn_expr.kind;\n+        if let Res::Def(_, def_id) = qpath_res(cx, qpath, fn_expr.hir_id);\n+        then {\n+            // right hand side of assignment is `Default::default`\n+            match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Returns the block indices, identifiers and types of bindings set as `Default::default()`, except\n+/// for when the pattern type is a tuple.\n+fn enumerate_bindings_using_default<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    block: &Block<'tcx>,\n+) -> Vec<(usize, Symbol, Ty<'tcx>, Span)> {\n+    block\n+        .stmts\n+        .iter()\n+        .enumerate()\n+        .filter_map(|(idx, stmt)| {\n+            if_chain! {\n+                // only take `let ...` statements\n+                if let StmtKind::Local(ref local) = stmt.kind;\n+                // only take bindings to identifiers\n+                if let PatKind::Binding(_, _, ident, _) = local.pat.kind;\n+                // that are not tuples\n+                let ty = cx.typeck_results().pat_ty(local.pat);\n+                if !matches!(ty.kind(), ty::Tuple(_));\n+                // only when assigning `... = Default::default()`\n+                if let Some(ref expr) = local.init;\n+                if is_expr_default(expr, cx);\n+                then {\n+                    Some((idx, ident.name, ty, expr.span))\n+                } else {\n+                    None\n+                }\n+            }\n+        })\n+        .collect()\n+}\n+\n+fn stmt_shadows_binding(this: &Stmt<'_>, shadowed: Symbol) -> bool {\n+    if let StmtKind::Local(local) = &this.kind {\n+        if let PatKind::Binding(_, _, ident, _) = local.pat.kind {\n+            return ident.name == shadowed;\n+        }\n+    }\n+    false\n+}\n+\n+/// Returns the reassigned field and the assigning expression (right-hand side of assign).\n+fn field_reassigned_by_stmt<'tcx>(this: &Stmt<'tcx>, binding_name: Symbol) -> Option<(Ident, &'tcx Expr<'tcx>)> {\n+    if_chain! {\n+        // only take assignments\n+        if let StmtKind::Semi(ref later_expr) = this.kind;\n+        if let ExprKind::Assign(ref assign_lhs, ref assign_rhs, _) = later_expr.kind;\n+        // only take assignments to fields where the left-hand side field is a field of\n+        // the same binding as the previous statement\n+        if let ExprKind::Field(ref binding, field_ident) = assign_lhs.kind;\n+        if let ExprKind::Path(ref qpath) = binding.kind;\n+        if let QPath::Resolved(_, path) = qpath;\n+        if let Some(second_binding_name) = path.segments.last();\n+        if second_binding_name.ident.name == binding_name;\n+        then {\n+            Some((field_ident, assign_rhs))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Returns the vec of fields for a struct and an empty vec for non-struct ADTs.\n+fn fields_of_type(ty: Ty<'_>) -> Vec<Ident> {\n+    if let Adt(adt, _) = ty.kind() {\n+        if adt.is_struct() {\n+            let variant = &adt.non_enum_variant();\n+            return variant.fields.iter().map(|f| f.ident).collect();\n+        }\n+    }\n+    vec![]\n+}"}, {"sha": "3048436d9a7b5f30d066fc7374fd2db090d9e2db", "filename": "clippy_lints/src/default_trait_access.rs", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e298c830af37e48a7778b3e6a487a2107230e8a6/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e298c830af37e48a7778b3e6a487a2107230e8a6/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=e298c830af37e48a7778b3e6a487a2107230e8a6", "patch": "@@ -1,62 +0,0 @@\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-use crate::utils::{any_parent_is_automatically_derived, match_def_path, paths, span_lint_and_sugg};\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for literal calls to `Default::default()`.\n-    ///\n-    /// **Why is this bad?** It's more clear to the reader to use the name of the type whose default is\n-    /// being gotten than the generic `Default`.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// // Bad\n-    /// let s: String = Default::default();\n-    ///\n-    /// // Good\n-    /// let s = String::default();\n-    /// ```\n-    pub DEFAULT_TRAIT_ACCESS,\n-    pedantic,\n-    \"checks for literal calls to `Default::default()`\"\n-}\n-\n-declare_lint_pass!(DefaultTraitAccess => [DEFAULT_TRAIT_ACCESS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for DefaultTraitAccess {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Call(ref path, ..) = expr.kind;\n-            if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n-            if let ExprKind::Path(ref qpath) = path.kind;\n-            if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n-            if match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n-            // Detect and ignore <Foo as Default>::default() because these calls do explicitly name the type.\n-            if let QPath::Resolved(None, _path) = qpath;\n-            then {\n-                let expr_ty = cx.typeck_results().expr_ty(expr);\n-                if let ty::Adt(def, ..) = expr_ty.kind() {\n-                    // TODO: Work out a way to put \"whatever the imported way of referencing\n-                    // this type in this file\" rather than a fully-qualified type.\n-                    let replacement = format!(\"{}::default()\", cx.tcx.def_path_str(def.did));\n-                    span_lint_and_sugg(\n-                        cx,\n-                        DEFAULT_TRAIT_ACCESS,\n-                        expr.span,\n-                        &format!(\"calling `{}` is more clear than this expression\", replacement),\n-                        \"try\",\n-                        replacement,\n-                        Applicability::Unspecified, // First resolve the TODO above\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "bb94b3f6cbeb49aeaae260866e85e30c46124f46", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7b203f3da6b590059c12bb01d0873b31be347928/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b203f3da6b590059c12bb01d0873b31be347928/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=7b203f3da6b590059c12bb01d0873b31be347928", "patch": "@@ -176,7 +176,7 @@ mod copies;\n mod copy_iterator;\n mod create_dir;\n mod dbg_macro;\n-mod default_trait_access;\n+mod default;\n mod dereference;\n mod derive;\n mod disallowed_method;\n@@ -537,7 +537,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &copy_iterator::COPY_ITERATOR,\n         &create_dir::CREATE_DIR,\n         &dbg_macro::DBG_MACRO,\n-        &default_trait_access::DEFAULT_TRAIT_ACCESS,\n+        &default::DEFAULT_TRAIT_ACCESS,\n+        &default::FIELD_REASSIGN_WITH_DEFAULT,\n         &dereference::EXPLICIT_DEREF_METHODS,\n         &derive::DERIVE_HASH_XOR_EQ,\n         &derive::DERIVE_ORD_XOR_PARTIAL_ORD,\n@@ -1049,7 +1050,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd);\n     store.register_late_pass(|| box unwrap::Unwrap);\n     store.register_late_pass(|| box duration_subsec::DurationSubsec);\n-    store.register_late_pass(|| box default_trait_access::DefaultTraitAccess);\n     store.register_late_pass(|| box indexing_slicing::IndexingSlicing);\n     store.register_late_pass(|| box non_copy_const::NonCopyConst);\n     store.register_late_pass(|| box ptr_offset_with_cast::PtrOffsetWithCast);\n@@ -1100,6 +1100,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let enum_variant_name_threshold = conf.enum_variant_name_threshold;\n     store.register_early_pass(move || box enum_variants::EnumVariantNames::new(enum_variant_name_threshold));\n     store.register_early_pass(|| box tabs_in_doc_comments::TabsInDocComments);\n+    store.register_late_pass(|| box default::Default::default());\n     store.register_late_pass(|| box unused_self::UnusedSelf);\n     store.register_late_pass(|| box mutable_debug_assertion::DebugAssertWithMutCall);\n     store.register_late_pass(|| box exit::Exit);\n@@ -1212,7 +1213,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n         LintId::of(&copies::SAME_FUNCTIONS_IN_IF_CONDITION),\n         LintId::of(&copy_iterator::COPY_ITERATOR),\n-        LintId::of(&default_trait_access::DEFAULT_TRAIT_ACCESS),\n+        LintId::of(&default::DEFAULT_TRAIT_ACCESS),\n         LintId::of(&dereference::EXPLICIT_DEREF_METHODS),\n         LintId::of(&derive::EXPL_IMPL_CLONE_ON_COPY),\n         LintId::of(&derive::UNSAFE_DERIVE_DESERIALIZE),\n@@ -1321,6 +1322,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n         LintId::of(&copies::IFS_SAME_COND),\n         LintId::of(&copies::IF_SAME_THEN_ELSE),\n+        LintId::of(&default::FIELD_REASSIGN_WITH_DEFAULT),\n         LintId::of(&derive::DERIVE_HASH_XOR_EQ),\n         LintId::of(&derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n         LintId::of(&doc::MISSING_SAFETY_DOC),\n@@ -1581,6 +1583,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n+        LintId::of(&default::FIELD_REASSIGN_WITH_DEFAULT),\n         LintId::of(&doc::MISSING_SAFETY_DOC),\n         LintId::of(&doc::NEEDLESS_DOCTEST_MAIN),\n         LintId::of(&enum_variants::ENUM_VARIANT_NAMES),"}, {"sha": "a3645a65182077c26651fee2995fb03901bc4f55", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7b203f3da6b590059c12bb01d0873b31be347928/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b203f3da6b590059c12bb01d0873b31be347928/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=7b203f3da6b590059c12bb01d0873b31be347928", "patch": "@@ -359,7 +359,7 @@ vec![\n         group: \"pedantic\",\n         desc: \"checks for literal calls to `Default::default()`\",\n         deprecation: None,\n-        module: \"default_trait_access\",\n+        module: \"default\",\n     },\n     Lint {\n         name: \"deprecated_cfg_attr\",\n@@ -627,6 +627,13 @@ vec![\n         deprecation: None,\n         module: \"fallible_impl_from\",\n     },\n+    Lint {\n+        name: \"field_reassign_with_default\",\n+        group: \"style\",\n+        desc: \"binding initialized with Default should have its fields set in the initializer\",\n+        deprecation: None,\n+        module: \"default\",\n+    },\n     Lint {\n         name: \"filetype_is_file\",\n         group: \"restriction\","}, {"sha": "79a30c22f953658269ee94b88de670e4d9f6257a", "filename": "tests/ui/field_reassign_with_default.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/7b203f3da6b590059c12bb01d0873b31be347928/tests%2Fui%2Ffield_reassign_with_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b203f3da6b590059c12bb01d0873b31be347928/tests%2Fui%2Ffield_reassign_with_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffield_reassign_with_default.rs?ref=7b203f3da6b590059c12bb01d0873b31be347928", "patch": "@@ -0,0 +1,110 @@\n+#![warn(clippy::field_reassign_with_default)]\n+\n+#[derive(Default)]\n+struct A {\n+    i: i32,\n+    j: i64,\n+}\n+\n+struct B {\n+    i: i32,\n+    j: i64,\n+}\n+\n+/// Implements .next() that returns a different number each time.\n+struct SideEffect(i32);\n+\n+impl SideEffect {\n+    fn new() -> SideEffect {\n+        SideEffect(0)\n+    }\n+    fn next(&mut self) -> i32 {\n+        self.0 += 1;\n+        self.0\n+    }\n+}\n+\n+fn main() {\n+    // wrong, produces first error in stderr\n+    let mut a: A = Default::default();\n+    a.i = 42;\n+\n+    // right\n+    let mut a: A = Default::default();\n+\n+    // right\n+    let a = A {\n+        i: 42,\n+        ..Default::default()\n+    };\n+\n+    // right\n+    let mut a: A = Default::default();\n+    if a.i == 0 {\n+        a.j = 12;\n+    }\n+\n+    // right\n+    let mut a: A = Default::default();\n+    let b = 5;\n+\n+    // right\n+    let mut b = 32;\n+    let mut a: A = Default::default();\n+    b = 2;\n+\n+    // right\n+    let b: B = B { i: 42, j: 24 };\n+\n+    // right\n+    let mut b: B = B { i: 42, j: 24 };\n+    b.i = 52;\n+\n+    // right\n+    let mut b = B { i: 15, j: 16 };\n+    let mut a: A = Default::default();\n+    b.i = 2;\n+\n+    // wrong, produces second error in stderr\n+    let mut a: A = Default::default();\n+    a.j = 43;\n+    a.i = 42;\n+\n+    // wrong, produces third error in stderr\n+    let mut a: A = Default::default();\n+    a.i = 42;\n+    a.j = 43;\n+    a.j = 44;\n+\n+    // wrong, produces fourth error in stderr\n+    let mut a = A::default();\n+    a.i = 42;\n+\n+    // wrong, but does not produce an error in stderr, because we can't produce a correct kind of\n+    // suggestion with current implementation\n+    let mut c: (i32, i32) = Default::default();\n+    c.0 = 42;\n+    c.1 = 21;\n+\n+    // wrong, produces the fifth error in stderr\n+    let mut a: A = Default::default();\n+    a.i = Default::default();\n+\n+    // wrong, produces the sixth error in stderr\n+    let mut a: A = Default::default();\n+    a.i = Default::default();\n+    a.j = 45;\n+\n+    // right, because an assignment refers to another field\n+    let mut x = A::default();\n+    x.i = 42;\n+    x.j = 21 + x.i as i64;\n+\n+    // right, we bail out if there's a reassignment to the same variable, since there is a risk of\n+    // side-effects affecting the outcome\n+    let mut x = A::default();\n+    let mut side_effect = SideEffect::new();\n+    x.i = side_effect.next();\n+    x.j = 2;\n+    x.i = side_effect.next();\n+}"}, {"sha": "c788ebae5526ce4e397038b07a0dca309067e7a1", "filename": "tests/ui/field_reassign_with_default.stderr", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7b203f3da6b590059c12bb01d0873b31be347928/tests%2Fui%2Ffield_reassign_with_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b203f3da6b590059c12bb01d0873b31be347928/tests%2Fui%2Ffield_reassign_with_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffield_reassign_with_default.stderr?ref=7b203f3da6b590059c12bb01d0873b31be347928", "patch": "@@ -0,0 +1,75 @@\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:30:5\n+   |\n+LL |     a.i = 42;\n+   |     ^^^^^^^^^\n+   |\n+   = note: `-D clippy::field-reassign-with-default` implied by `-D warnings`\n+note: consider initializing the variable with `A { i: 42, ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:29:5\n+   |\n+LL |     let mut a: A = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:70:5\n+   |\n+LL |     a.j = 43;\n+   |     ^^^^^^^^^\n+   |\n+note: consider initializing the variable with `A { j: 43, i: 42 }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:69:5\n+   |\n+LL |     let mut a: A = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:75:5\n+   |\n+LL |     a.i = 42;\n+   |     ^^^^^^^^^\n+   |\n+note: consider initializing the variable with `A { i: 42, j: 44 }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:74:5\n+   |\n+LL |     let mut a: A = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:81:5\n+   |\n+LL |     a.i = 42;\n+   |     ^^^^^^^^^\n+   |\n+note: consider initializing the variable with `A { i: 42, ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:80:5\n+   |\n+LL |     let mut a = A::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:91:5\n+   |\n+LL |     a.i = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: consider initializing the variable with `A::default()` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:90:5\n+   |\n+LL |     let mut a: A = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:95:5\n+   |\n+LL |     a.i = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: consider initializing the variable with `A { j: 45, ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:94:5\n+   |\n+LL |     let mut a: A = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}]}