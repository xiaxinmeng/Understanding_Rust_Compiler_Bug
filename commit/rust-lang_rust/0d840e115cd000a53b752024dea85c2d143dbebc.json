{"sha": "0d840e115cd000a53b752024dea85c2d143dbebc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkODQwZTExNWNkMDAwYTUzYjc1MjAyNGRlYTg1YzJkMTQzZGJlYmM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-09-15T20:26:04Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-09-15T20:31:38Z"}, "message": "avoid leaking host details in proc macro metadata decoding\n\nproc macro crates are essentially implemented as dynamic libraries using\na dlopen-based ABI. They are also Rust crates, so they have 2 worlds -\nthe \"host\" world in which they are defined, and the \"target\" world in\nwhich they are used.\n\nFor all the \"target\" world knows, the proc macro crate might not even\nbe implemented in Rust, so leaks of details from the host to the target\nmust be avoided for correctness.\n\nBecause the \"host\" DefId space is different from the \"target\" DefId\nspace, any leak involving a DefId will have a nonsensical or\nout-of-bounds DefKey, and will cause all sorts of crashes.\n\nThis PR fixes all leaks I have found in `decoder`. In particular, #54059\nwas caused by host native libraries leaking into the target, which feels\nlike it might even be a correctness issue if it doesn't cause an ICE.\n\nFixes #54059", "tree": {"sha": "55950013a66411673fc6bb02a161434955424057", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55950013a66411673fc6bb02a161434955424057"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d840e115cd000a53b752024dea85c2d143dbebc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d840e115cd000a53b752024dea85c2d143dbebc", "html_url": "https://github.com/rust-lang/rust/commit/0d840e115cd000a53b752024dea85c2d143dbebc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d840e115cd000a53b752024dea85c2d143dbebc/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cba0fdf43c22795822e1d7c751a69e6c85007221", "url": "https://api.github.com/repos/rust-lang/rust/commits/cba0fdf43c22795822e1d7c751a69e6c85007221", "html_url": "https://github.com/rust-lang/rust/commit/cba0fdf43c22795822e1d7c751a69e6c85007221"}], "stats": {"total": 154, "additions": 130, "deletions": 24}, "files": [{"sha": "4382a3c12c961e15ffc3e91b2d900529535adc7a", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d840e115cd000a53b752024dea85c2d143dbebc/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d840e115cd000a53b752024dea85c2d143dbebc/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=0d840e115cd000a53b752024dea85c2d143dbebc", "patch": "@@ -259,12 +259,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         let cnum = cdata.cnum;\n         assert!(cnum != LOCAL_CRATE);\n \n-        // If this crate is a custom derive crate, then we're not even going to\n-        // link those in so we skip those crates.\n-        if cdata.root.macro_derive_registrar.is_some() {\n-            return Arc::new(Vec::new())\n-        }\n-\n         Arc::new(cdata.exported_symbols(tcx))\n     }\n }"}, {"sha": "43b03cb863c746acc95011aa2d16a67e014943fc", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 53, "deletions": 18, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0d840e115cd000a53b752024dea85c2d143dbebc/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d840e115cd000a53b752024dea85c2d143dbebc/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=0d840e115cd000a53b752024dea85c2d143dbebc", "patch": "@@ -692,6 +692,8 @@ impl<'a, 'tcx> CrateMetadata {\n \n     /// Iterates over all the stability attributes in the given crate.\n     pub fn get_lib_features(&self) -> Vec<(ast::Name, Option<ast::Name>)> {\n+        // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n+        // features or an empty Vec. Both don't cause ICEs.\n         self.root\n             .lib_features\n             .decode(self)\n@@ -700,11 +702,16 @@ impl<'a, 'tcx> CrateMetadata {\n \n     /// Iterates over the language items in the given crate.\n     pub fn get_lang_items(&self) -> Vec<(DefId, usize)> {\n-        self.root\n-            .lang_items\n-            .decode(self)\n-            .map(|(def_index, index)| (self.local_def_id(def_index), index))\n-            .collect()\n+        if self.proc_macros.is_some() {\n+            // Proc macro crates do not export any lang-items to the target.\n+            vec![]\n+        } else {\n+            self.root\n+                .lang_items\n+                .decode(self)\n+                .map(|(def_index, index)| (self.local_def_id(def_index), index))\n+                .collect()\n+        }\n     }\n \n     /// Iterates over each child of the given item.\n@@ -978,12 +985,16 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn get_implementations_for_trait(&self,\n                                          filter: Option<DefId>,\n                                          result: &mut Vec<DefId>) {\n+        if self.proc_macros.is_some() {\n+            // proc-macro crates export no trait impls.\n+            return\n+        }\n+\n         // Do a reverse lookup beforehand to avoid touching the crate_num\n         // hash map in the loop below.\n         let filter = match filter.map(|def_id| self.reverse_translate_def_id(def_id)) {\n             Some(Some(def_id)) => Some((def_id.krate.as_u32(), def_id.index)),\n             Some(None) => return,\n-            None if self.proc_macros.is_some() => return,\n             None => None,\n         };\n \n@@ -1016,11 +1027,21 @@ impl<'a, 'tcx> CrateMetadata {\n \n \n     pub fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n-        self.root.native_libraries.decode((self, sess)).collect()\n+        if self.proc_macros.is_some() {\n+            // Proc macro crates do not have any *target* native libraries.\n+            vec![]\n+        } else {\n+            self.root.native_libraries.decode((self, sess)).collect()\n+        }\n     }\n \n     pub fn get_foreign_modules(&self, sess: &Session) -> Vec<ForeignModule> {\n-        self.root.foreign_modules.decode((self, sess)).collect()\n+        if self.proc_macros.is_some() {\n+            // Proc macro crates do not have any *target* foreign modules.\n+            vec![]\n+        } else {\n+            self.root.foreign_modules.decode((self, sess)).collect()\n+        }\n     }\n \n     pub fn get_dylib_dependency_formats(&self) -> Vec<(CrateNum, LinkagePreference)> {\n@@ -1036,10 +1057,15 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_missing_lang_items(&self) -> Vec<lang_items::LangItem> {\n-        self.root\n-            .lang_items_missing\n-            .decode(self)\n-            .collect()\n+        if self.proc_macros.is_some() {\n+            // Proc macro crates do not depend on any target weak lang-items.\n+            vec![]\n+        } else {\n+            self.root\n+                .lang_items_missing\n+                .decode(self)\n+                .collect()\n+        }\n     }\n \n     pub fn get_fn_arg_names(&self, id: DefIndex) -> Vec<ast::Name> {\n@@ -1055,10 +1081,16 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn exported_symbols(&self,\n                             tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                             -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n-        let lazy_seq: LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)> =\n-            LazySeq::with_position_and_length(self.root.exported_symbols.position,\n-                                              self.root.exported_symbols.len);\n-        lazy_seq.decode((self, tcx)).collect()\n+        if self.proc_macros.is_some() {\n+            // If this crate is a custom derive crate, then we're not even going to\n+            // link those in so we skip those crates.\n+            vec![]\n+        } else {\n+            let lazy_seq: LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)> =\n+                LazySeq::with_position_and_length(self.root.exported_symbols.position,\n+                                                  self.root.exported_symbols.len);\n+            lazy_seq.decode((self, tcx)).collect()\n+        }\n     }\n \n     pub fn get_rendered_const(&self, id: DefIndex) -> String {\n@@ -1149,9 +1181,12 @@ impl<'a, 'tcx> CrateMetadata {\n     /// file they represent, just information about length, line breaks, and\n     /// multibyte characters. This information is enough to generate valid debuginfo\n     /// for items inlined from other crates.\n+    ///\n+    /// Proc macro crates don't currently export spans, so this function does not have\n+    /// to work for them.\n     pub fn imported_source_files(&'a self,\n-                             local_source_map: &source_map::SourceMap)\n-                             -> ReadGuard<'a, Vec<cstore::ImportedSourceFile>> {\n+                                 local_source_map: &source_map::SourceMap)\n+                                 -> ReadGuard<'a, Vec<cstore::ImportedSourceFile>> {\n         {\n             let source_files = self.source_map_import_info.borrow();\n             if !source_files.is_empty() {"}, {"sha": "ec0d044d4bf8d6cb028c2f36bd1d481b0c9c3d8f", "filename": "src/test/incremental-fulldeps/auxiliary/issue_54059.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0d840e115cd000a53b752024dea85c2d143dbebc/src%2Ftest%2Fincremental-fulldeps%2Fauxiliary%2Fissue_54059.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d840e115cd000a53b752024dea85c2d143dbebc/src%2Ftest%2Fincremental-fulldeps%2Fauxiliary%2Fissue_54059.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental-fulldeps%2Fauxiliary%2Fissue_54059.rs?ref=0d840e115cd000a53b752024dea85c2d143dbebc", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+// check that having extern \"C\" functions in a proc macro doesn't crash.\n+\n+#![crate_type=\"proc-macro\"]\n+#![allow(non_snake_case)]\n+\n+extern crate proc_macro;\n+\n+macro_rules! proc_macro_tokenstream {\n+    () => {\n+        ::proc_macro::TokenStream\n+    };\n+}\n+\n+macro_rules! proc_macro_expr_impl {\n+    ($(\n+        $( #[$attr:meta] )*\n+        pub fn $func:ident($input:ident: &str) -> String $body:block\n+    )+) => {\n+        $(\n+            // Parses an input that looks like:\n+            //\n+            // ```\n+            // #[allow(unused)]\n+            // enum ProcMacroHack {\n+            //     Input = (stringify!(ARGS), 0).1,\n+            // }\n+            // ```\n+            $( #[$attr] )*\n+            #[proc_macro_derive($func)]\n+            pub fn $func(input: proc_macro_tokenstream!()) -> proc_macro_tokenstream!() {\n+                unsafe { rust_dbg_extern_identity_u64(0); }\n+                panic!()\n+            }\n+        )+\n+    };\n+}\n+\n+proc_macro_expr_impl! {\n+    pub fn base2_impl(input: &str) -> String {\n+        panic!()\n+    }\n+}\n+\n+#[link(name=\"rust_test_helpers\")]\n+extern \"C\" {\n+    pub fn rust_dbg_extern_identity_u64(v: u64) -> u64;\n+}"}, {"sha": "5f0c7db64fe7d2dc8c8fe5c3247403825d6f9fba", "filename": "src/test/incremental-fulldeps/issue-54059.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d840e115cd000a53b752024dea85c2d143dbebc/src%2Ftest%2Fincremental-fulldeps%2Fissue-54059.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d840e115cd000a53b752024dea85c2d143dbebc/src%2Ftest%2Fincremental-fulldeps%2Fissue-54059.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental-fulldeps%2Fissue-54059.rs?ref=0d840e115cd000a53b752024dea85c2d143dbebc", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue_54059.rs\n+// ignore-stage1\n+// ignore-wasm32-bare no libc for ffi testing\n+// revisions: rpass1\n+\n+extern crate issue_54059;\n+\n+fn main() {}"}]}