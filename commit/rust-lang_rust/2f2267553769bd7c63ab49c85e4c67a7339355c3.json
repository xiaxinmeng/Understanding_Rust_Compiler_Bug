{"sha": "2f2267553769bd7c63ab49c85e4c67a7339355c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMjI2NzU1Mzc2OWJkN2M2M2FiNDljODVlNGM2N2E3MzM5MzU1YzM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-12-26T11:11:42Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-12-26T11:11:42Z"}, "message": "Simplify assists resolution API\n\nAssist vs UnresolvedAssist split doesn't really pull its weight. This\nis especially bad if we want to include `Assist` as a field of\ndiagnostics, where we'd have to make the thing generic.", "tree": {"sha": "107c3baf8ac0d8b386f7b1441544011e23caf70b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/107c3baf8ac0d8b386f7b1441544011e23caf70b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f2267553769bd7c63ab49c85e4c67a7339355c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f2267553769bd7c63ab49c85e4c67a7339355c3", "html_url": "https://github.com/rust-lang/rust/commit/2f2267553769bd7c63ab49c85e4c67a7339355c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f2267553769bd7c63ab49c85e4c67a7339355c3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44893bbcc58abc630e5263d3261236ca1cc21041", "url": "https://api.github.com/repos/rust-lang/rust/commits/44893bbcc58abc630e5263d3261236ca1cc21041", "html_url": "https://github.com/rust-lang/rust/commit/44893bbcc58abc630e5263d3261236ca1cc21041"}], "stats": {"total": 189, "additions": 69, "deletions": 120}, "files": [{"sha": "4f59d39a9676aabd586ac7bf8af8dabf7e28d781", "filename": "crates/assists/src/assist_context.rs", "status": "modified", "additions": 12, "deletions": 39, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2f2267553769bd7c63ab49c85e4c67a7339355c3/crates%2Fassists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2267553769bd7c63ab49c85e4c67a7339355c3/crates%2Fassists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fassist_context.rs?ref=2f2267553769bd7c63ab49c85e4c67a7339355c3", "patch": "@@ -19,7 +19,7 @@ use text_edit::{TextEdit, TextEditBuilder};\n \n use crate::{\n     assist_config::{AssistConfig, SnippetCap},\n-    Assist, AssistId, AssistKind, GroupLabel, ResolvedAssist,\n+    Assist, AssistId, AssistKind, GroupLabel,\n };\n \n /// `AssistContext` allows to apply an assist or check if it could be applied.\n@@ -105,46 +105,23 @@ impl<'a> AssistContext<'a> {\n pub(crate) struct Assists {\n     resolve: bool,\n     file: FileId,\n-    buf: Vec<(Assist, Option<SourceChange>)>,\n+    buf: Vec<Assist>,\n     allowed: Option<Vec<AssistKind>>,\n }\n \n impl Assists {\n-    pub(crate) fn new_resolved(ctx: &AssistContext) -> Assists {\n+    pub(crate) fn new(ctx: &AssistContext, resolve: bool) -> Assists {\n         Assists {\n-            resolve: true,\n+            resolve,\n             file: ctx.frange.file_id,\n             buf: Vec::new(),\n             allowed: ctx.config.allowed.clone(),\n         }\n     }\n \n-    pub(crate) fn new_unresolved(ctx: &AssistContext) -> Assists {\n-        Assists {\n-            resolve: false,\n-            file: ctx.frange.file_id,\n-            buf: Vec::new(),\n-            allowed: ctx.config.allowed.clone(),\n-        }\n-    }\n-\n-    pub(crate) fn finish_unresolved(self) -> Vec<Assist> {\n-        assert!(!self.resolve);\n-        self.finish()\n-            .into_iter()\n-            .map(|(label, edit)| {\n-                assert!(edit.is_none());\n-                label\n-            })\n-            .collect()\n-    }\n-\n-    pub(crate) fn finish_resolved(self) -> Vec<ResolvedAssist> {\n-        assert!(self.resolve);\n-        self.finish()\n-            .into_iter()\n-            .map(|(label, edit)| ResolvedAssist { assist: label, source_change: edit.unwrap() })\n-            .collect()\n+    pub(crate) fn finish(mut self) -> Vec<Assist> {\n+        self.buf.sort_by_key(|assist| assist.target.len());\n+        self.buf\n     }\n \n     pub(crate) fn add(\n@@ -158,7 +135,7 @@ impl Assists {\n             return None;\n         }\n         let label = Label::new(label.into());\n-        let assist = Assist { id, label, group: None, target };\n+        let assist = Assist { id, label, group: None, target, source_change: None };\n         self.add_impl(assist, f)\n     }\n \n@@ -174,28 +151,24 @@ impl Assists {\n             return None;\n         }\n         let label = Label::new(label.into());\n-        let assist = Assist { id, label, group: Some(group.clone()), target };\n+        let assist = Assist { id, label, group: Some(group.clone()), target, source_change: None };\n         self.add_impl(assist, f)\n     }\n \n-    fn add_impl(&mut self, assist: Assist, f: impl FnOnce(&mut AssistBuilder)) -> Option<()> {\n+    fn add_impl(&mut self, mut assist: Assist, f: impl FnOnce(&mut AssistBuilder)) -> Option<()> {\n         let source_change = if self.resolve {\n             let mut builder = AssistBuilder::new(self.file);\n             f(&mut builder);\n             Some(builder.finish())\n         } else {\n             None\n         };\n+        assist.source_change = source_change.clone();\n \n-        self.buf.push((assist, source_change));\n+        self.buf.push(assist);\n         Some(())\n     }\n \n-    fn finish(mut self) -> Vec<(Assist, Option<SourceChange>)> {\n-        self.buf.sort_by_key(|(label, _edit)| label.target.len());\n-        self.buf\n-    }\n-\n     fn is_allowed(&self, id: &AssistId) -> bool {\n         match &self.allowed {\n             Some(allowed) => allowed.iter().any(|kind| kind.contains(id.1)),"}, {"sha": "fdec886e9d80fc13d61a6fbd5b6cbc1a32e259b3", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2f2267553769bd7c63ab49c85e4c67a7339355c3/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2267553769bd7c63ab49c85e4c67a7339355c3/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=2f2267553769bd7c63ab49c85e4c67a7339355c3", "patch": "@@ -73,45 +73,32 @@ pub struct Assist {\n     /// Target ranges are used to sort assists: the smaller the target range,\n     /// the more specific assist is, and so it should be sorted first.\n     pub target: TextRange,\n-}\n-\n-#[derive(Debug, Clone)]\n-pub struct ResolvedAssist {\n-    pub assist: Assist,\n-    pub source_change: SourceChange,\n+    /// Computing source change sometimes is much more costly then computing the\n+    /// other fields. Additionally, the actual change is not required to show\n+    /// the lightbulb UI, it only is needed when the user tries to apply an\n+    /// assist. So, we compute it lazily: the API allow requesting assists with\n+    /// or without source change. We could (and in fact, used to) distinguish\n+    /// between resolved and unresolved assists at the type level, but this is\n+    /// cumbersome, especially if you want to embed an assist into another data\n+    /// structure, such as a diagnostic.\n+    pub source_change: Option<SourceChange>,\n }\n \n impl Assist {\n     /// Return all the assists applicable at the given position.\n-    ///\n-    /// Assists are returned in the \"unresolved\" state, that is only labels are\n-    /// returned, without actual edits.\n-    pub fn unresolved(db: &RootDatabase, config: &AssistConfig, range: FileRange) -> Vec<Assist> {\n-        let sema = Semantics::new(db);\n-        let ctx = AssistContext::new(sema, config, range);\n-        let mut acc = Assists::new_unresolved(&ctx);\n-        handlers::all().iter().for_each(|handler| {\n-            handler(&mut acc, &ctx);\n-        });\n-        acc.finish_unresolved()\n-    }\n-\n-    /// Return all the assists applicable at the given position.\n-    ///\n-    /// Assists are returned in the \"resolved\" state, that is with edit fully\n-    /// computed.\n-    pub fn resolved(\n+    pub fn get(\n         db: &RootDatabase,\n         config: &AssistConfig,\n+        resolve: bool,\n         range: FileRange,\n-    ) -> Vec<ResolvedAssist> {\n+    ) -> Vec<Assist> {\n         let sema = Semantics::new(db);\n         let ctx = AssistContext::new(sema, config, range);\n-        let mut acc = Assists::new_resolved(&ctx);\n+        let mut acc = Assists::new(&ctx, resolve);\n         handlers::all().iter().for_each(|handler| {\n             handler(&mut acc, &ctx);\n         });\n-        acc.finish_resolved()\n+        acc.finish()\n     }\n }\n "}, {"sha": "21e448fb8671bf9a3209435d9fbfe0219fb5cc3c", "filename": "crates/assists/src/tests.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2f2267553769bd7c63ab49c85e4c67a7339355c3/crates%2Fassists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2267553769bd7c63ab49c85e4c67a7339355c3/crates%2Fassists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests.rs?ref=2f2267553769bd7c63ab49c85e4c67a7339355c3", "patch": "@@ -48,24 +48,25 @@ fn check_doc_test(assist_id: &str, before: &str, after: &str) {\n     let before = db.file_text(file_id).to_string();\n     let frange = FileRange { file_id, range: selection.into() };\n \n-    let assist = Assist::resolved(&db, &AssistConfig::default(), frange)\n+    let assist = Assist::get(&db, &AssistConfig::default(), true, frange)\n         .into_iter()\n-        .find(|assist| assist.assist.id.0 == assist_id)\n+        .find(|assist| assist.id.0 == assist_id)\n         .unwrap_or_else(|| {\n             panic!(\n                 \"\\n\\nAssist is not applicable: {}\\nAvailable assists: {}\",\n                 assist_id,\n-                Assist::resolved(&db, &AssistConfig::default(), frange)\n+                Assist::get(&db, &AssistConfig::default(), false, frange)\n                     .into_iter()\n-                    .map(|assist| assist.assist.id.0)\n+                    .map(|assist| assist.id.0)\n                     .collect::<Vec<_>>()\n                     .join(\", \")\n             )\n         });\n \n     let actual = {\n+        let source_change = assist.source_change.unwrap();\n         let mut actual = before;\n-        for source_file_edit in assist.source_change.source_file_edits {\n+        for source_file_edit in source_change.source_file_edits {\n             if source_file_edit.file_id == file_id {\n                 source_file_edit.edit.apply(&mut actual)\n             }\n@@ -90,18 +91,18 @@ fn check(handler: Handler, before: &str, expected: ExpectedResult, assist_label:\n     let sema = Semantics::new(&db);\n     let config = AssistConfig::default();\n     let ctx = AssistContext::new(sema, &config, frange);\n-    let mut acc = Assists::new_resolved(&ctx);\n+    let mut acc = Assists::new(&ctx, true);\n     handler(&mut acc, &ctx);\n-    let mut res = acc.finish_resolved();\n+    let mut res = acc.finish();\n \n     let assist = match assist_label {\n-        Some(label) => res.into_iter().find(|resolved| resolved.assist.label == label),\n+        Some(label) => res.into_iter().find(|resolved| resolved.label == label),\n         None => res.pop(),\n     };\n \n     match (assist, expected) {\n         (Some(assist), ExpectedResult::After(after)) => {\n-            let mut source_change = assist.source_change;\n+            let mut source_change = assist.source_change.unwrap();\n             assert!(!source_change.source_file_edits.is_empty());\n             let skip_header = source_change.source_file_edits.len() == 1\n                 && source_change.file_system_edits.len() == 0;\n@@ -138,7 +139,7 @@ fn check(handler: Handler, before: &str, expected: ExpectedResult, assist_label:\n             assert_eq_text!(after, &buf);\n         }\n         (Some(assist), ExpectedResult::Target(target)) => {\n-            let range = assist.assist.target;\n+            let range = assist.target;\n             assert_eq_text!(&text_without_caret[range], target);\n         }\n         (Some(_), ExpectedResult::NotApplicable) => panic!(\"assist should not be applicable!\"),\n@@ -155,14 +156,11 @@ fn assist_order_field_struct() {\n     let (before_cursor_pos, before) = extract_offset(before);\n     let (db, file_id) = with_single_file(&before);\n     let frange = FileRange { file_id, range: TextRange::empty(before_cursor_pos) };\n-    let assists = Assist::resolved(&db, &AssistConfig::default(), frange);\n+    let assists = Assist::get(&db, &AssistConfig::default(), false, frange);\n     let mut assists = assists.iter();\n \n-    assert_eq!(\n-        assists.next().expect(\"expected assist\").assist.label,\n-        \"Change visibility to pub(crate)\"\n-    );\n-    assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Add `#[derive]`\");\n+    assert_eq!(assists.next().expect(\"expected assist\").label, \"Change visibility to pub(crate)\");\n+    assert_eq!(assists.next().expect(\"expected assist\").label, \"Add `#[derive]`\");\n }\n \n #[test]\n@@ -178,11 +176,11 @@ fn assist_order_if_expr() {\n     let (range, before) = extract_range(before);\n     let (db, file_id) = with_single_file(&before);\n     let frange = FileRange { file_id, range };\n-    let assists = Assist::resolved(&db, &AssistConfig::default(), frange);\n+    let assists = Assist::get(&db, &AssistConfig::default(), false, frange);\n     let mut assists = assists.iter();\n \n-    assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Extract into variable\");\n-    assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Replace with match\");\n+    assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into variable\");\n+    assert_eq!(assists.next().expect(\"expected assist\").label, \"Replace with match\");\n }\n \n #[test]\n@@ -203,27 +201,27 @@ fn assist_filter_works() {\n         let mut cfg = AssistConfig::default();\n         cfg.allowed = Some(vec![AssistKind::Refactor]);\n \n-        let assists = Assist::resolved(&db, &cfg, frange);\n+        let assists = Assist::get(&db, &cfg, false, frange);\n         let mut assists = assists.iter();\n \n-        assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Extract into variable\");\n-        assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Replace with match\");\n+        assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into variable\");\n+        assert_eq!(assists.next().expect(\"expected assist\").label, \"Replace with match\");\n     }\n \n     {\n         let mut cfg = AssistConfig::default();\n         cfg.allowed = Some(vec![AssistKind::RefactorExtract]);\n-        let assists = Assist::resolved(&db, &cfg, frange);\n+        let assists = Assist::get(&db, &cfg, false, frange);\n         assert_eq!(assists.len(), 1);\n \n         let mut assists = assists.iter();\n-        assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Extract into variable\");\n+        assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into variable\");\n     }\n \n     {\n         let mut cfg = AssistConfig::default();\n         cfg.allowed = Some(vec![AssistKind::QuickFix]);\n-        let assists = Assist::resolved(&db, &cfg, frange);\n+        let assists = Assist::get(&db, &cfg, false, frange);\n         assert!(assists.is_empty(), \"All asserts but quickfixes should be filtered out\");\n     }\n }"}, {"sha": "41eb139d16b2ba51823b556a39753f3f9bc206df", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2f2267553769bd7c63ab49c85e4c67a7339355c3/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2267553769bd7c63ab49c85e4c67a7339355c3/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=2f2267553769bd7c63ab49c85e4c67a7339355c3", "patch": "@@ -79,7 +79,7 @@ pub use crate::{\n         HighlightedRange,\n     },\n };\n-pub use assists::{Assist, AssistConfig, AssistId, AssistKind, ResolvedAssist};\n+pub use assists::{Assist, AssistConfig, AssistId, AssistKind};\n pub use completion::{\n     CompletionConfig, CompletionItem, CompletionItemKind, CompletionResolveCapability,\n     CompletionScore, ImportEdit, InsertTextFormat,\n@@ -491,22 +491,16 @@ impl Analysis {\n     }\n \n     /// Computes assists (aka code actions aka intentions) for the given\n-    /// position. Computes enough info to show the lightbulb list in the editor,\n-    /// but doesn't compute actual edits, to improve performance.\n-    ///\n-    /// When the user clicks on the assist, call `resolve_assists` to get the\n-    /// edit.\n-    pub fn assists(&self, config: &AssistConfig, frange: FileRange) -> Cancelable<Vec<Assist>> {\n-        self.with_db(|db| Assist::unresolved(db, config, frange))\n-    }\n-\n-    /// Computes resolved assists with source changes for the given position.\n-    pub fn resolve_assists(\n+    /// position. If `resolve == false`, computes enough info to show the\n+    /// lightbulb list in the editor, but doesn't compute actual edits, to\n+    /// improve performance.\n+    pub fn assists(\n         &self,\n         config: &AssistConfig,\n+        resolve: bool,\n         frange: FileRange,\n-    ) -> Cancelable<Vec<ResolvedAssist>> {\n-        self.with_db(|db| assists::Assist::resolved(db, config, frange))\n+    ) -> Cancelable<Vec<Assist>> {\n+        self.with_db(|db| Assist::get(db, config, resolve, frange))\n     }\n \n     /// Computes the set of diagnostics for the given file."}, {"sha": "374fb5302b485ddf6d52009675151ce7749a433e", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f2267553769bd7c63ab49c85e4c67a7339355c3/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2267553769bd7c63ab49c85e4c67a7339355c3/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=2f2267553769bd7c63ab49c85e4c67a7339355c3", "patch": "@@ -946,12 +946,12 @@ pub(crate) fn handle_code_action(\n \n     if snap.config.client_caps.code_action_resolve {\n         for (index, assist) in\n-            snap.analysis.assists(&assists_config, frange)?.into_iter().enumerate()\n+            snap.analysis.assists(&assists_config, false, frange)?.into_iter().enumerate()\n         {\n             res.push(to_proto::unresolved_code_action(&snap, params.clone(), assist, index)?);\n         }\n     } else {\n-        for assist in snap.analysis.resolve_assists(&assists_config, frange)?.into_iter() {\n+        for assist in snap.analysis.assists(&assists_config, true, frange)?.into_iter() {\n             res.push(to_proto::resolved_code_action(&snap, assist)?);\n         }\n     }\n@@ -1014,11 +1014,11 @@ pub(crate) fn handle_code_action_resolve(\n         .only\n         .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect());\n \n-    let assists = snap.analysis.resolve_assists(&snap.config.assist, frange)?;\n+    let assists = snap.analysis.assists(&snap.config.assist, true, frange)?;\n     let (id, index) = split_once(&params.id, ':').unwrap();\n     let index = index.parse::<usize>().unwrap();\n     let assist = &assists[index];\n-    assert!(assist.assist.id.0 == id);\n+    assert!(assist.id.0 == id);\n     let edit = to_proto::resolved_code_action(&snap, assist.clone())?.edit;\n     code_action.edit = edit;\n     Ok(code_action)"}, {"sha": "1a38e79f080bbdc95a75cce97ef9abf993751426", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2f2267553769bd7c63ab49c85e4c67a7339355c3/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2267553769bd7c63ab49c85e4c67a7339355c3/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=2f2267553769bd7c63ab49c85e4c67a7339355c3", "patch": "@@ -8,8 +8,8 @@ use ide::{\n     Assist, AssistKind, CallInfo, CompletionItem, CompletionItemKind, Documentation, FileId,\n     FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier, HighlightTag,\n     HighlightedRange, Indel, InlayHint, InlayKind, InsertTextFormat, LineIndex, Markup,\n-    NavigationTarget, ReferenceAccess, ResolvedAssist, Runnable, Severity, SourceChange,\n-    SourceFileEdit, SymbolKind, TextEdit, TextRange, TextSize,\n+    NavigationTarget, ReferenceAccess, Runnable, Severity, SourceChange, SourceFileEdit,\n+    SymbolKind, TextEdit, TextRange, TextSize,\n };\n use itertools::Itertools;\n \n@@ -780,6 +780,7 @@ pub(crate) fn unresolved_code_action(\n     assist: Assist,\n     index: usize,\n ) -> Result<lsp_ext::CodeAction> {\n+    assert!(assist.source_change.is_none());\n     let res = lsp_ext::CodeAction {\n         title: assist.label.to_string(),\n         group: assist.group.filter(|_| snap.config.client_caps.code_action_group).map(|gr| gr.0),\n@@ -796,18 +797,14 @@ pub(crate) fn unresolved_code_action(\n \n pub(crate) fn resolved_code_action(\n     snap: &GlobalStateSnapshot,\n-    assist: ResolvedAssist,\n+    assist: Assist,\n ) -> Result<lsp_ext::CodeAction> {\n-    let change = assist.source_change;\n+    let change = assist.source_change.unwrap();\n     let res = lsp_ext::CodeAction {\n         edit: Some(snippet_workspace_edit(snap, change)?),\n-        title: assist.assist.label.to_string(),\n-        group: assist\n-            .assist\n-            .group\n-            .filter(|_| snap.config.client_caps.code_action_group)\n-            .map(|gr| gr.0),\n-        kind: Some(code_action_kind(assist.assist.id.1)),\n+        title: assist.label.to_string(),\n+        group: assist.group.filter(|_| snap.config.client_caps.code_action_group).map(|gr| gr.0),\n+        kind: Some(code_action_kind(assist.id.1)),\n         is_preferred: None,\n         data: None,\n     };"}]}