{"sha": "8dea3088c6f36455a6d0a2eb7eaf7a81414ce967", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkZWEzMDg4YzZmMzY0NTVhNmQwYTJlYjdlYWY3YTgxNDE0Y2U5Njc=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2020-08-21T23:28:21Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2020-08-22T00:02:48Z"}, "message": "Add a CGU partitioning trait\n\nThis will allow us to prototype different partitioning schemes without\nadding a lot of extra conditionals everywhere.", "tree": {"sha": "e44ae3ecd31af72a741eda6337447ea7aa5681fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e44ae3ecd31af72a741eda6337447ea7aa5681fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dea3088c6f36455a6d0a2eb7eaf7a81414ce967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dea3088c6f36455a6d0a2eb7eaf7a81414ce967", "html_url": "https://github.com/rust-lang/rust/commit/8dea3088c6f36455a6d0a2eb7eaf7a81414ce967", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dea3088c6f36455a6d0a2eb7eaf7a81414ce967/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9d4d39612aae0b8398340bd83d592cafad8e4ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9d4d39612aae0b8398340bd83d592cafad8e4ec", "html_url": "https://github.com/rust-lang/rust/commit/d9d4d39612aae0b8398340bd83d592cafad8e4ec"}], "stats": {"total": 621, "additions": 334, "deletions": 287}, "files": [{"sha": "8216f0569517a129b9dc206b2d4a13764ef3142b", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 334, "deletions": 287, "changes": 621, "blob_url": "https://github.com/rust-lang/rust/blob/8dea3088c6f36455a6d0a2eb7eaf7a81414ce967/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dea3088c6f36455a6d0a2eb7eaf7a81414ce967/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=8dea3088c6f36455a6d0a2eb7eaf7a81414ce967", "patch": "@@ -111,28 +111,60 @@ use rustc_span::symbol::{Symbol, SymbolStr};\n use crate::monomorphize::collector::InliningMap;\n use crate::monomorphize::collector::{self, MonoItemCollectionMode};\n \n+trait Partitioner<'tcx> {\n+    fn place_root_mono_items(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        mono_items: &mut dyn Iterator<Item = MonoItem<'tcx>>,\n+    ) -> PreInliningPartitioning<'tcx>;\n+\n+    fn merge_codegen_units(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+        target_cgu_count: usize,\n+    );\n+\n+    fn place_inlined_mono_items(\n+        &mut self,\n+        initial_partitioning: PreInliningPartitioning<'tcx>,\n+        inlining_map: &InliningMap<'tcx>,\n+    ) -> PostInliningPartitioning<'tcx>;\n+\n+    fn internalize_symbols(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        partitioning: &mut PostInliningPartitioning<'tcx>,\n+        inlining_map: &InliningMap<'tcx>,\n+    );\n+}\n+\n // Anything we can't find a proper codegen unit for goes into this.\n fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n     name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n }\n \n-pub fn partition<'tcx, I>(\n+pub struct DefaultPartitioning;\n+\n+fn get_partitioner<'tcx>() -> Box<dyn Partitioner<'tcx>> {\n+    Box::new(DefaultPartitioning)\n+}\n+\n+pub fn partition<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    mono_items: I,\n+    mono_items: &mut dyn Iterator<Item = MonoItem<'tcx>>,\n     max_cgu_count: usize,\n     inlining_map: &InliningMap<'tcx>,\n-) -> Vec<CodegenUnit<'tcx>>\n-where\n-    I: Iterator<Item = MonoItem<'tcx>>,\n-{\n+) -> Vec<CodegenUnit<'tcx>> {\n     let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n \n+    let mut partitioner = get_partitioner();\n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n     // functions and statics defined in the local crate.\n     let mut initial_partitioning = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n-        place_root_mono_items(tcx, mono_items)\n+        partitioner.place_root_mono_items(tcx, mono_items)\n     };\n \n     initial_partitioning.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(tcx));\n@@ -142,7 +174,7 @@ where\n     // Merge until we have at most `max_cgu_count` codegen units.\n     {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n-        merge_codegen_units(tcx, &mut initial_partitioning, max_cgu_count);\n+        partitioner.merge_codegen_units(tcx, &mut initial_partitioning, max_cgu_count);\n         debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n \n@@ -152,7 +184,7 @@ where\n     // local functions the definition of which is marked with `#[inline]`.\n     let mut post_inlining = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n-        place_inlined_mono_items(initial_partitioning, inlining_map)\n+        partitioner.place_inlined_mono_items(initial_partitioning, inlining_map)\n     };\n \n     post_inlining.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(tcx));\n@@ -163,7 +195,7 @@ where\n     // more freedom to optimize.\n     if tcx.sess.opts.cg.link_dead_code != Some(true) {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n-        internalize_symbols(tcx, &mut post_inlining, inlining_map);\n+        partitioner.internalize_symbols(tcx, &mut post_inlining, inlining_map);\n     }\n \n     // Finally, sort by codegen unit name, so that we get deterministic results.\n@@ -199,77 +231,6 @@ struct PostInliningPartitioning<'tcx> {\n     internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n }\n \n-fn place_root_mono_items<'tcx, I>(tcx: TyCtxt<'tcx>, mono_items: I) -> PreInliningPartitioning<'tcx>\n-where\n-    I: Iterator<Item = MonoItem<'tcx>>,\n-{\n-    let mut roots = FxHashSet::default();\n-    let mut codegen_units = FxHashMap::default();\n-    let is_incremental_build = tcx.sess.opts.incremental.is_some();\n-    let mut internalization_candidates = FxHashSet::default();\n-\n-    // Determine if monomorphizations instantiated in this crate will be made\n-    // available to downstream crates. This depends on whether we are in\n-    // share-generics mode and whether the current crate can even have\n-    // downstream crates.\n-    let export_generics = tcx.sess.opts.share_generics() && tcx.local_crate_exports_generics();\n-\n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n-    let cgu_name_cache = &mut FxHashMap::default();\n-\n-    for mono_item in mono_items {\n-        match mono_item.instantiation_mode(tcx) {\n-            InstantiationMode::GloballyShared { .. } => {}\n-            InstantiationMode::LocalCopy => continue,\n-        }\n-\n-        let characteristic_def_id = characteristic_def_id_of_mono_item(tcx, mono_item);\n-        let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n-\n-        let codegen_unit_name = match characteristic_def_id {\n-            Some(def_id) => compute_codegen_unit_name(\n-                tcx,\n-                cgu_name_builder,\n-                def_id,\n-                is_volatile,\n-                cgu_name_cache,\n-            ),\n-            None => fallback_cgu_name(cgu_name_builder),\n-        };\n-\n-        let codegen_unit = codegen_units\n-            .entry(codegen_unit_name)\n-            .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n-\n-        let mut can_be_internalized = true;\n-        let (linkage, visibility) = mono_item_linkage_and_visibility(\n-            tcx,\n-            &mono_item,\n-            &mut can_be_internalized,\n-            export_generics,\n-        );\n-        if visibility == Visibility::Hidden && can_be_internalized {\n-            internalization_candidates.insert(mono_item);\n-        }\n-\n-        codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n-        roots.insert(mono_item);\n-    }\n-\n-    // Always ensure we have at least one CGU; otherwise, if we have a\n-    // crate with just types (for example), we could wind up with no CGU.\n-    if codegen_units.is_empty() {\n-        let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n-        codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n-    }\n-\n-    PreInliningPartitioning {\n-        codegen_units: codegen_units.into_iter().map(|(_, codegen_unit)| codegen_unit).collect(),\n-        roots,\n-        internalization_candidates,\n-    }\n-}\n-\n fn mono_item_linkage_and_visibility(\n     tcx: TyCtxt<'tcx>,\n     mono_item: &MonoItem<'tcx>,\n@@ -452,248 +413,334 @@ fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibilit\n     }\n }\n \n-fn merge_codegen_units<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-    target_cgu_count: usize,\n-) {\n-    assert!(target_cgu_count >= 1);\n-    let codegen_units = &mut initial_partitioning.codegen_units;\n-\n-    // Note that at this point in time the `codegen_units` here may not be in a\n-    // deterministic order (but we know they're deterministically the same set).\n-    // We want this merging to produce a deterministic ordering of codegen units\n-    // from the input.\n-    //\n-    // Due to basically how we've implemented the merging below (merge the two\n-    // smallest into each other) we're sure to start off with a deterministic\n-    // order (sorted by name). This'll mean that if two cgus have the same size\n-    // the stable sort below will keep everything nice and deterministic.\n-    codegen_units.sort_by_cached_key(|cgu| cgu.name().as_str());\n-\n-    // This map keeps track of what got merged into what.\n-    let mut cgu_contents: FxHashMap<Symbol, Vec<SymbolStr>> =\n-        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name().as_str()])).collect();\n-\n-    // Merge the two smallest codegen units until the target size is reached.\n-    while codegen_units.len() > target_cgu_count {\n-        // Sort small cgus to the back\n-        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n-        let mut smallest = codegen_units.pop().unwrap();\n-        let second_smallest = codegen_units.last_mut().unwrap();\n-\n-        // Move the mono-items from `smallest` to `second_smallest`\n-        second_smallest.modify_size_estimate(smallest.size_estimate());\n-        for (k, v) in smallest.items_mut().drain() {\n-            second_smallest.items_mut().insert(k, v);\n-        }\n+impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n+    fn place_root_mono_items(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        mono_items: &mut dyn Iterator<Item = MonoItem<'tcx>>,\n+    ) -> PreInliningPartitioning<'tcx> {\n+        let mut roots = FxHashSet::default();\n+        let mut codegen_units = FxHashMap::default();\n+        let is_incremental_build = tcx.sess.opts.incremental.is_some();\n+        let mut internalization_candidates = FxHashSet::default();\n+\n+        // Determine if monomorphizations instantiated in this crate will be made\n+        // available to downstream crates. This depends on whether we are in\n+        // share-generics mode and whether the current crate can even have\n+        // downstream crates.\n+        let export_generics = tcx.sess.opts.share_generics() && tcx.local_crate_exports_generics();\n+\n+        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+        let cgu_name_cache = &mut FxHashMap::default();\n+\n+        for mono_item in mono_items {\n+            match mono_item.instantiation_mode(tcx) {\n+                InstantiationMode::GloballyShared { .. } => {}\n+                InstantiationMode::LocalCopy => continue,\n+            }\n \n-        // Record that `second_smallest` now contains all the stuff that was in\n-        // `smallest` before.\n-        let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n-        cgu_contents.get_mut(&second_smallest.name()).unwrap().extend(consumed_cgu_names.drain(..));\n+            let characteristic_def_id = characteristic_def_id_of_mono_item(tcx, mono_item);\n+            let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n \n-        debug!(\n-            \"CodegenUnit {} merged into CodegenUnit {}\",\n-            smallest.name(),\n-            second_smallest.name()\n-        );\n-    }\n+            let codegen_unit_name = match characteristic_def_id {\n+                Some(def_id) => compute_codegen_unit_name(\n+                    tcx,\n+                    cgu_name_builder,\n+                    def_id,\n+                    is_volatile,\n+                    cgu_name_cache,\n+                ),\n+                None => fallback_cgu_name(cgu_name_builder),\n+            };\n \n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n-\n-    if tcx.sess.opts.incremental.is_some() {\n-        // If we are doing incremental compilation, we want CGU names to\n-        // reflect the path of the source level module they correspond to.\n-        // For CGUs that contain the code of multiple modules because of the\n-        // merging done above, we use a concatenation of the names of\n-        // all contained CGUs.\n-        let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n-            .into_iter()\n-            // This `filter` makes sure we only update the name of CGUs that\n-            // were actually modified by merging.\n-            .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n-            .map(|(current_cgu_name, cgu_contents)| {\n-                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| &s[..]).collect();\n-\n-                // Sort the names, so things are deterministic and easy to\n-                // predict.\n-                cgu_contents.sort();\n-\n-                (current_cgu_name, cgu_contents.join(\"--\"))\n-            })\n-            .collect();\n+            let codegen_unit = codegen_units\n+                .entry(codegen_unit_name)\n+                .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n \n-        for cgu in codegen_units.iter_mut() {\n-            if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n-                if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n-                    cgu.set_name(Symbol::intern(&new_cgu_name));\n-                } else {\n-                    // If we don't require CGU names to be human-readable, we\n-                    // use a fixed length hash of the composite CGU name\n-                    // instead.\n-                    let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n-                    cgu.set_name(Symbol::intern(&new_cgu_name));\n-                }\n+            let mut can_be_internalized = true;\n+            let (linkage, visibility) = mono_item_linkage_and_visibility(\n+                tcx,\n+                &mono_item,\n+                &mut can_be_internalized,\n+                export_generics,\n+            );\n+            if visibility == Visibility::Hidden && can_be_internalized {\n+                internalization_candidates.insert(mono_item);\n             }\n+\n+            codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n+            roots.insert(mono_item);\n         }\n-    } else {\n-        // If we are compiling non-incrementally we just generate simple CGU\n-        // names containing an index.\n-        for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-            cgu.set_name(numbered_codegen_unit_name(cgu_name_builder, index));\n+\n+        // Always ensure we have at least one CGU; otherwise, if we have a\n+        // crate with just types (for example), we could wind up with no CGU.\n+        if codegen_units.is_empty() {\n+            let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n+            codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n         }\n-    }\n-}\n \n-fn place_inlined_mono_items<'tcx>(\n-    initial_partitioning: PreInliningPartitioning<'tcx>,\n-    inlining_map: &InliningMap<'tcx>,\n-) -> PostInliningPartitioning<'tcx> {\n-    let mut new_partitioning = Vec::new();\n-    let mut mono_item_placements = FxHashMap::default();\n+        PreInliningPartitioning {\n+            codegen_units: codegen_units\n+                .into_iter()\n+                .map(|(_, codegen_unit)| codegen_unit)\n+                .collect(),\n+            roots,\n+            internalization_candidates,\n+        }\n+    }\n \n-    let PreInliningPartitioning { codegen_units: initial_cgus, roots, internalization_candidates } =\n-        initial_partitioning;\n+    fn merge_codegen_units(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+        target_cgu_count: usize,\n+    ) {\n+        assert!(target_cgu_count >= 1);\n+        let codegen_units = &mut initial_partitioning.codegen_units;\n \n-    let single_codegen_unit = initial_cgus.len() == 1;\n+        // Note that at this point in time the `codegen_units` here may not be in a\n+        // deterministic order (but we know they're deterministically the same set).\n+        // We want this merging to produce a deterministic ordering of codegen units\n+        // from the input.\n+        //\n+        // Due to basically how we've implemented the merging below (merge the two\n+        // smallest into each other) we're sure to start off with a deterministic\n+        // order (sorted by name). This'll mean that if two cgus have the same size\n+        // the stable sort below will keep everything nice and deterministic.\n+        codegen_units.sort_by_cached_key(|cgu| cgu.name().as_str());\n+\n+        // This map keeps track of what got merged into what.\n+        let mut cgu_contents: FxHashMap<Symbol, Vec<SymbolStr>> =\n+            codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name().as_str()])).collect();\n+\n+        // Merge the two smallest codegen units until the target size is reached.\n+        while codegen_units.len() > target_cgu_count {\n+            // Sort small cgus to the back\n+            codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n+            let mut smallest = codegen_units.pop().unwrap();\n+            let second_smallest = codegen_units.last_mut().unwrap();\n+\n+            // Move the mono-items from `smallest` to `second_smallest`\n+            second_smallest.modify_size_estimate(smallest.size_estimate());\n+            for (k, v) in smallest.items_mut().drain() {\n+                second_smallest.items_mut().insert(k, v);\n+            }\n \n-    for old_codegen_unit in initial_cgus {\n-        // Collect all items that need to be available in this codegen unit.\n-        let mut reachable = FxHashSet::default();\n-        for root in old_codegen_unit.items().keys() {\n-            follow_inlining(*root, inlining_map, &mut reachable);\n+            // Record that `second_smallest` now contains all the stuff that was in\n+            // `smallest` before.\n+            let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n+            cgu_contents\n+                .get_mut(&second_smallest.name())\n+                .unwrap()\n+                .extend(consumed_cgu_names.drain(..));\n+\n+            debug!(\n+                \"CodegenUnit {} merged into CodegenUnit {}\",\n+                smallest.name(),\n+                second_smallest.name()\n+            );\n         }\n \n-        let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n-\n-        // Add all monomorphizations that are not already there.\n-        for mono_item in reachable {\n-            if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n-                // This is a root, just copy it over.\n-                new_codegen_unit.items_mut().insert(mono_item, *linkage);\n-            } else {\n-                if roots.contains(&mono_item) {\n-                    bug!(\n-                        \"GloballyShared mono-item inlined into other CGU: \\\n-                          {:?}\",\n-                        mono_item\n-                    );\n+        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+\n+        if tcx.sess.opts.incremental.is_some() {\n+            // If we are doing incremental compilation, we want CGU names to\n+            // reflect the path of the source level module they correspond to.\n+            // For CGUs that contain the code of multiple modules because of the\n+            // merging done above, we use a concatenation of the names of\n+            // all contained CGUs.\n+            let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n+                .into_iter()\n+                // This `filter` makes sure we only update the name of CGUs that\n+                // were actually modified by merging.\n+                .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n+                .map(|(current_cgu_name, cgu_contents)| {\n+                    let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| &s[..]).collect();\n+\n+                    // Sort the names, so things are deterministic and easy to\n+                    // predict.\n+                    cgu_contents.sort();\n+\n+                    (current_cgu_name, cgu_contents.join(\"--\"))\n+                })\n+                .collect();\n+\n+            for cgu in codegen_units.iter_mut() {\n+                if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n+                    if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n+                        cgu.set_name(Symbol::intern(&new_cgu_name));\n+                    } else {\n+                        // If we don't require CGU names to be human-readable, we\n+                        // use a fixed length hash of the composite CGU name\n+                        // instead.\n+                        let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n+                        cgu.set_name(Symbol::intern(&new_cgu_name));\n+                    }\n                 }\n+            }\n+        } else {\n+            // If we are compiling non-incrementally we just generate simple CGU\n+            // names containing an index.\n+            for (index, cgu) in codegen_units.iter_mut().enumerate() {\n+                cgu.set_name(numbered_codegen_unit_name(cgu_name_builder, index));\n+            }\n+        }\n+    }\n \n-                // This is a CGU-private copy.\n-                new_codegen_unit\n-                    .items_mut()\n-                    .insert(mono_item, (Linkage::Internal, Visibility::Default));\n+    fn place_inlined_mono_items(\n+        &mut self,\n+        initial_partitioning: PreInliningPartitioning<'tcx>,\n+        inlining_map: &InliningMap<'tcx>,\n+    ) -> PostInliningPartitioning<'tcx> {\n+        let mut new_partitioning = Vec::new();\n+        let mut mono_item_placements = FxHashMap::default();\n+\n+        let PreInliningPartitioning {\n+            codegen_units: initial_cgus,\n+            roots,\n+            internalization_candidates,\n+        } = initial_partitioning;\n+\n+        let single_codegen_unit = initial_cgus.len() == 1;\n+\n+        for old_codegen_unit in initial_cgus {\n+            // Collect all items that need to be available in this codegen unit.\n+            let mut reachable = FxHashSet::default();\n+            for root in old_codegen_unit.items().keys() {\n+                follow_inlining(*root, inlining_map, &mut reachable);\n             }\n \n-            if !single_codegen_unit {\n-                // If there is more than one codegen unit, we need to keep track\n-                // in which codegen units each monomorphization is placed.\n-                match mono_item_placements.entry(mono_item) {\n-                    Entry::Occupied(e) => {\n-                        let placement = e.into_mut();\n-                        debug_assert!(match *placement {\n-                            MonoItemPlacement::SingleCgu { cgu_name } => {\n-                                cgu_name != new_codegen_unit.name()\n-                            }\n-                            MonoItemPlacement::MultipleCgus => true,\n-                        });\n-                        *placement = MonoItemPlacement::MultipleCgus;\n+            let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n+\n+            // Add all monomorphizations that are not already there.\n+            for mono_item in reachable {\n+                if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n+                    // This is a root, just copy it over.\n+                    new_codegen_unit.items_mut().insert(mono_item, *linkage);\n+                } else {\n+                    if roots.contains(&mono_item) {\n+                        bug!(\n+                            \"GloballyShared mono-item inlined into other CGU: \\\n+                          {:?}\",\n+                            mono_item\n+                        );\n                     }\n-                    Entry::Vacant(e) => {\n-                        e.insert(MonoItemPlacement::SingleCgu {\n-                            cgu_name: new_codegen_unit.name(),\n-                        });\n+\n+                    // This is a CGU-private copy.\n+                    new_codegen_unit\n+                        .items_mut()\n+                        .insert(mono_item, (Linkage::Internal, Visibility::Default));\n+                }\n+\n+                if !single_codegen_unit {\n+                    // If there is more than one codegen unit, we need to keep track\n+                    // in which codegen units each monomorphization is placed.\n+                    match mono_item_placements.entry(mono_item) {\n+                        Entry::Occupied(e) => {\n+                            let placement = e.into_mut();\n+                            debug_assert!(match *placement {\n+                                MonoItemPlacement::SingleCgu { cgu_name } => {\n+                                    cgu_name != new_codegen_unit.name()\n+                                }\n+                                MonoItemPlacement::MultipleCgus => true,\n+                            });\n+                            *placement = MonoItemPlacement::MultipleCgus;\n+                        }\n+                        Entry::Vacant(e) => {\n+                            e.insert(MonoItemPlacement::SingleCgu {\n+                                cgu_name: new_codegen_unit.name(),\n+                            });\n+                        }\n                     }\n                 }\n             }\n+\n+            new_partitioning.push(new_codegen_unit);\n         }\n \n-        new_partitioning.push(new_codegen_unit);\n-    }\n+        return PostInliningPartitioning {\n+            codegen_units: new_partitioning,\n+            mono_item_placements,\n+            internalization_candidates,\n+        };\n \n-    return PostInliningPartitioning {\n-        codegen_units: new_partitioning,\n-        mono_item_placements,\n-        internalization_candidates,\n-    };\n+        fn follow_inlining<'tcx>(\n+            mono_item: MonoItem<'tcx>,\n+            inlining_map: &InliningMap<'tcx>,\n+            visited: &mut FxHashSet<MonoItem<'tcx>>,\n+        ) {\n+            if !visited.insert(mono_item) {\n+                return;\n+            }\n \n-    fn follow_inlining<'tcx>(\n-        mono_item: MonoItem<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n-        visited: &mut FxHashSet<MonoItem<'tcx>>,\n-    ) {\n-        if !visited.insert(mono_item) {\n-            return;\n+            inlining_map.with_inlining_candidates(mono_item, |target| {\n+                follow_inlining(target, inlining_map, visited);\n+            });\n         }\n-\n-        inlining_map.with_inlining_candidates(mono_item, |target| {\n-            follow_inlining(target, inlining_map, visited);\n-        });\n     }\n-}\n \n-fn internalize_symbols<'tcx>(\n-    _tcx: TyCtxt<'tcx>,\n-    partitioning: &mut PostInliningPartitioning<'tcx>,\n-    inlining_map: &InliningMap<'tcx>,\n-) {\n-    if partitioning.codegen_units.len() == 1 {\n-        // Fast path for when there is only one codegen unit. In this case we\n-        // can internalize all candidates, since there is nowhere else they\n-        // could be accessed from.\n-        for cgu in &mut partitioning.codegen_units {\n-            for candidate in &partitioning.internalization_candidates {\n-                cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n+    fn internalize_symbols(\n+        &mut self,\n+        _tcx: TyCtxt<'tcx>,\n+        partitioning: &mut PostInliningPartitioning<'tcx>,\n+        inlining_map: &InliningMap<'tcx>,\n+    ) {\n+        if partitioning.codegen_units.len() == 1 {\n+            // Fast path for when there is only one codegen unit. In this case we\n+            // can internalize all candidates, since there is nowhere else they\n+            // could be accessed from.\n+            for cgu in &mut partitioning.codegen_units {\n+                for candidate in &partitioning.internalization_candidates {\n+                    cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n+                }\n             }\n-        }\n-\n-        return;\n-    }\n \n-    // Build a map from every monomorphization to all the monomorphizations that\n-    // reference it.\n-    let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n-    inlining_map.iter_accesses(|accessor, accessees| {\n-        for accessee in accessees {\n-            accessor_map.entry(*accessee).or_default().push(accessor);\n+            return;\n         }\n-    });\n \n-    let mono_item_placements = &partitioning.mono_item_placements;\n+        // Build a map from every monomorphization to all the monomorphizations that\n+        // reference it.\n+        let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n+        inlining_map.iter_accesses(|accessor, accessees| {\n+            for accessee in accessees {\n+                accessor_map.entry(*accessee).or_default().push(accessor);\n+            }\n+        });\n \n-    // For each internalization candidates in each codegen unit, check if it is\n-    // accessed from outside its defining codegen unit.\n-    for cgu in &mut partitioning.codegen_units {\n-        let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n+        let mono_item_placements = &partitioning.mono_item_placements;\n \n-        for (accessee, linkage_and_visibility) in cgu.items_mut() {\n-            if !partitioning.internalization_candidates.contains(accessee) {\n-                // This item is no candidate for internalizing, so skip it.\n-                continue;\n-            }\n-            debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n-\n-            if let Some(accessors) = accessor_map.get(accessee) {\n-                if accessors\n-                    .iter()\n-                    .filter_map(|accessor| {\n-                        // Some accessors might not have been\n-                        // instantiated. We can safely ignore those.\n-                        mono_item_placements.get(accessor)\n-                    })\n-                    .any(|placement| *placement != home_cgu)\n-                {\n-                    // Found an accessor from another CGU, so skip to the next\n-                    // item without marking this one as internal.\n+        // For each internalization candidates in each codegen unit, check if it is\n+        // accessed from outside its defining codegen unit.\n+        for cgu in &mut partitioning.codegen_units {\n+            let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n+\n+            for (accessee, linkage_and_visibility) in cgu.items_mut() {\n+                if !partitioning.internalization_candidates.contains(accessee) {\n+                    // This item is no candidate for internalizing, so skip it.\n                     continue;\n                 }\n-            }\n+                debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n+\n+                if let Some(accessors) = accessor_map.get(accessee) {\n+                    if accessors\n+                        .iter()\n+                        .filter_map(|accessor| {\n+                            // Some accessors might not have been\n+                            // instantiated. We can safely ignore those.\n+                            mono_item_placements.get(accessor)\n+                        })\n+                        .any(|placement| *placement != home_cgu)\n+                    {\n+                        // Found an accessor from another CGU, so skip to the next\n+                        // item without marking this one as internal.\n+                        continue;\n+                    }\n+                }\n \n-            // If we got here, we did not find any accesses from other CGUs,\n-            // so it's fine to make this monomorphization internal.\n-            *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n+                // If we got here, we did not find any accesses from other CGUs,\n+                // so it's fine to make this monomorphization internal.\n+                *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n+            }\n         }\n     }\n }\n@@ -923,7 +970,7 @@ fn collect_and_partition_mono_items(\n             || {\n                 &*tcx.arena.alloc_from_iter(partition(\n                     tcx,\n-                    items.iter().cloned(),\n+                    &mut items.iter().cloned(),\n                     tcx.sess.codegen_units(),\n                     &inlining_map,\n                 ))"}]}