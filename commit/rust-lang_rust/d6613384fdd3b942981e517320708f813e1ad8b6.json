{"sha": "d6613384fdd3b942981e517320708f813e1ad8b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NjEzMzg0ZmRkM2I5NDI5ODFlNTE3MzIwNzA4ZjgxM2UxYWQ4YjY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-18T01:12:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-18T02:34:12Z"}, "message": "Introduce covariance, contravariance and invariance to the type unifier\n\nThis will be used to resolve some problems with mutable? covariance and also\nto implement function subtyping", "tree": {"sha": "c67819dca5302df0a5e5ea32a1288112114bd827", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c67819dca5302df0a5e5ea32a1288112114bd827"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6613384fdd3b942981e517320708f813e1ad8b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6613384fdd3b942981e517320708f813e1ad8b6", "html_url": "https://github.com/rust-lang/rust/commit/d6613384fdd3b942981e517320708f813e1ad8b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6613384fdd3b942981e517320708f813e1ad8b6/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b61578e1cd8c6f7c872fb843c85234486b4c060c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b61578e1cd8c6f7c872fb843c85234486b4c060c", "html_url": "https://github.com/rust-lang/rust/commit/b61578e1cd8c6f7c872fb843c85234486b4c060c"}], "stats": {"total": 69, "additions": 47, "deletions": 22}, "files": [{"sha": "a46fe3cbc9fccad6253c36ec9cb1223ab8c4ba57", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 47, "deletions": 22, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d6613384fdd3b942981e517320708f813e1ad8b6/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6613384fdd3b942981e517320708f813e1ad8b6/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=d6613384fdd3b942981e517320708f813e1ad8b6", "patch": "@@ -1807,7 +1807,8 @@ mod unify {\n     }\n \n     // Unifies two sets.\n-    fn union(cx: @ctxt, set_a: uint, set_b: uint) -> union_result {\n+    fn union(cx: @ctxt, set_a: uint, set_b: uint,\n+             variance: variance) -> union_result {\n         ufind::grow(cx.vb.sets, uint::max(set_a, set_b) + 1u);\n         let root_a = ufind::find(cx.vb.sets, set_a);\n         let root_b = ufind::find(cx.vb.sets, set_b);\n@@ -1831,7 +1832,7 @@ mod unify {\n             alt smallintmap::find(cx.vb.types, root_b) {\n               none. { replace_type(cx, t_a); ret unres_ok; }\n               some(t_b) {\n-                alt unify_step(cx, t_a, t_b) {\n+                alt unify_step(cx, t_a, t_b, variance) {\n                   ures_ok(t_c) { replace_type(cx, t_c); ret unres_ok; }\n                   ures_err(terr) { ret unres_err(terr); }\n                 }\n@@ -1842,20 +1843,20 @@ mod unify {\n     }\n \n     fn record_var_binding_for_expected(\n-        cx: @ctxt, key: int, typ: t) -> result {\n+        cx: @ctxt, key: int, typ: t, variance: variance) -> result {\n         record_var_binding(\n             cx, key, typ,\n             fn (cx: @ctxt, old_type: t, new_type: t) -> result {\n-                unify_step(cx, old_type, new_type)\n+                unify_step(cx, old_type, new_type, variance)\n             })\n     }\n \n     fn record_var_binding_for_actual(\n-        cx: @ctxt, key: int, typ: t) -> result {\n+        cx: @ctxt, key: int, typ: t, variance: variance) -> result {\n         record_var_binding(\n             cx, key, typ,\n             fn (cx: @ctxt, old_type: t, new_type: t) -> result {\n-                unify_step(cx, new_type, old_type)\n+                unify_step(cx, new_type, old_type, variance)\n             })\n     }\n \n@@ -1960,7 +1961,8 @@ mod unify {\n     }\n     fn unify_fn_common(cx: @ctxt, _expected: t, _actual: t,\n                        expected_inputs: [arg], expected_output: t,\n-                       actual_inputs: [arg], actual_output: t) ->\n+                       actual_inputs: [arg], actual_output: t,\n+                       variance: variance) ->\n        fn_common_res {\n         let expected_len = vec::len::<arg>(expected_inputs);\n         let actual_len = vec::len::<arg>(actual_inputs);\n@@ -1985,7 +1987,8 @@ mod unify {\n                     (ures_err(terr_mode_mismatch(expected_input.mode,\n                                                  actual_input.mode)));\n             } else { expected_input.mode };\n-            let result = unify_step(cx, expected_input.ty, actual_input.ty);\n+            let result = unify_step(\n+                cx, expected_input.ty, actual_input.ty, variance);\n             alt result {\n               ures_ok(rty) { result_ins += [{mode: result_mode, ty: rty}]; }\n               _ { ret fn_common_res_err(result); }\n@@ -1994,7 +1997,7 @@ mod unify {\n         }\n         // Check the output.\n \n-        let result = unify_step(cx, expected_output, actual_output);\n+        let result = unify_step(cx, expected_output, actual_output, variance);\n         alt result {\n           ures_ok(rty) { ret fn_common_res_ok(result_ins, rty); }\n           _ { ret fn_common_res_err(result); }\n@@ -2095,7 +2098,19 @@ mod unify {\n           _ { ret fix_ok(typ); }\n         }\n     }\n-    fn unify_step(cx: @ctxt, expected: t, actual: t) -> result {\n+\n+    // Specifies the allowable subtyping between expected and actual types\n+    tag variance {\n+        // Actual may be a subtype of expected\n+        covariant;\n+        // Actual may be a supertype of expected\n+        contravariant;\n+        // Actual must be the same type as expected\n+        invariant;\n+    }\n+\n+    fn unify_step(cx: @ctxt, expected: t, actual: t,\n+                  variance: variance) -> result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n \n@@ -2187,7 +2202,8 @@ mod unify {\n                 while i < expected_len {\n                     let expected_tp = expected_tps[i];\n                     let actual_tp = actual_tps[i];\n-                    let result = unify_step(cx, expected_tp, actual_tp);\n+                    let result = unify_step(\n+                        cx, expected_tp, actual_tp, variance);\n                     alt result {\n                       ures_ok(rty) { result_tps += [rty]; }\n                       _ { ret result; }\n@@ -2208,7 +2224,8 @@ mod unify {\n                   none. { ret ures_err(terr_box_mutability); }\n                   some(m) { mut = m; }\n                 }\n-                let result = unify_step(cx, expected_mt.ty, actual_mt.ty);\n+                let result = unify_step(\n+                    cx, expected_mt.ty, actual_mt.ty, variance);\n                 alt result {\n                   ures_ok(result_sub) {\n                     let mt = {ty: result_sub, mut: mut};\n@@ -2228,7 +2245,8 @@ mod unify {\n                   none. { ret ures_err(terr_box_mutability); }\n                   some(m) { mut = m; }\n                 }\n-                let result = unify_step(cx, expected_mt.ty, actual_mt.ty);\n+                let result = unify_step(\n+                    cx, expected_mt.ty, actual_mt.ty, variance);\n                 alt result {\n                   ures_ok(result_mt) {\n                     let mt = {ty: result_mt, mut: mut};\n@@ -2248,7 +2266,8 @@ mod unify {\n                   none. { ret ures_err(terr_vec_mutability); }\n                   some(m) { mut = m; }\n                 }\n-                let result = unify_step(cx, expected_mt.ty, actual_mt.ty);\n+                let result = unify_step(\n+                    cx, expected_mt.ty, actual_mt.ty, variance);\n                 alt result {\n                   ures_ok(result_sub) {\n                     let mt = {ty: result_sub, mut: mut};\n@@ -2268,7 +2287,8 @@ mod unify {\n                   none. { ret ures_err(terr_vec_mutability); }\n                   some(m) { mut = m; }\n                 }\n-                let result = unify_step(cx, expected_mt.ty, actual_mt.ty);\n+                let result = unify_step(\n+                    cx, expected_mt.ty, actual_mt.ty, variance);\n                 alt result {\n                   ures_ok(result_sub) {\n                     let mt = {ty: result_sub, mut: mut};\n@@ -2286,13 +2306,15 @@ mod unify {\n                 if ex_id.crate != act_id.crate || ex_id.node != act_id.node {\n                     ret ures_err(terr_mismatch);\n                 }\n-                let result = unify_step(cx, ex_inner, act_inner);\n+                let result = unify_step(\n+                    cx, ex_inner, act_inner, variance);\n                 alt result {\n                   ures_ok(res_inner) {\n                     let i = 0u;\n                     let res_tps = [];\n                     for ex_tp: t in ex_tps {\n-                        let result = unify_step(cx, ex_tp, act_tps[i]);\n+                        let result = unify_step(\n+                            cx, ex_tp, act_tps[i], variance);\n                         alt result {\n                           ures_ok(rty) { res_tps += [rty]; }\n                           _ { ret result; }\n@@ -2338,7 +2360,7 @@ mod unify {\n                     }\n                     let result =\n                         unify_step(cx, expected_field.mt.ty,\n-                                   actual_field.mt.ty);\n+                                   actual_field.mt.ty, variance);\n                     alt result {\n                       ures_ok(rty) {\n                         let mt = {ty: rty, mut: mut};\n@@ -2370,7 +2392,8 @@ mod unify {\n                 while i < expected_len {\n                     let expected_elem = expected_elems[i];\n                     let actual_elem = actual_elems[i];\n-                    let result = unify_step(cx, expected_elem, actual_elem);\n+                    let result = unify_step(\n+                        cx, expected_elem, actual_elem, variance);\n                     alt result {\n                       ures_ok(rty) { result_elems += [rty]; }\n                       _ { ret result; }\n@@ -2419,7 +2442,8 @@ mod unify {\n             // unify the base types...\n             alt struct(cx.tcx, actual) {\n               ty::ty_constr(actual_t, actual_constrs) {\n-                let rslt = unify_step(cx, expected_t, actual_t);\n+                let rslt = unify_step(\n+                    cx, expected_t, actual_t, variance);\n                 alt rslt {\n                   ures_ok(rty) {\n                     // FIXME: probably too restrictive --\n@@ -2435,7 +2459,8 @@ mod unify {\n                 // If the actual type is *not* a constrained type,\n                 // then we go ahead and just ignore the constraints on\n                 // the expected type. typestate handles the rest.\n-                ret unify_step(cx, expected_t, actual);\n+                ret unify_step(\n+                    cx, expected_t, actual, variance);\n               }\n             }\n           }\n@@ -2444,7 +2469,7 @@ mod unify {\n     fn unify(expected: t, actual: t, vb: @var_bindings, tcx: ty_ctxt) ->\n        result {\n         let cx = @{vb: vb, tcx: tcx};\n-        ret unify_step(cx, expected, actual);\n+        ret unify_step(cx, expected, actual, covariant);\n     }\n     fn dump_var_bindings(tcx: ty_ctxt, vb: @var_bindings) {\n         let i = 0u;"}]}