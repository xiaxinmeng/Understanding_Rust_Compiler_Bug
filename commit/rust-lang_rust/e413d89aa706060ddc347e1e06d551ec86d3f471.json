{"sha": "e413d89aa706060ddc347e1e06d551ec86d3f471", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MTNkODlhYTcwNjA2MGRkYzM0N2UxZTA2ZDU1MWVjODZkM2Y0NzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-10T03:11:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-10T03:11:27Z"}, "message": "Auto merge of #79274 - the8472:probe-eperm, r=nagisa\n\nimplement better availability probing for copy_file_range\n\nFollowup to https://github.com/rust-lang/rust/pull/75428#discussion_r469616547\n\nPreviously syscall detection was overly pessimistic. Any attempt to copy to an immutable file (EPERM) would disable copy_file_range support for the whole process.\n\nThe change tries to copy_file_range on invalid file descriptors which will never run into the immutable file case and thus we can clearly distinguish syscall availability.", "tree": {"sha": "c8ba4949a30607d1a8ae938c67ec67f6f0bb5547", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8ba4949a30607d1a8ae938c67ec67f6f0bb5547"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e413d89aa706060ddc347e1e06d551ec86d3f471", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e413d89aa706060ddc347e1e06d551ec86d3f471", "html_url": "https://github.com/rust-lang/rust/commit/e413d89aa706060ddc347e1e06d551ec86d3f471", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e413d89aa706060ddc347e1e06d551ec86d3f471/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58d2bad9f7ab0971495247b6c94978848760ca9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/58d2bad9f7ab0971495247b6c94978848760ca9d", "html_url": "https://github.com/rust-lang/rust/commit/58d2bad9f7ab0971495247b6c94978848760ca9d"}, {"sha": "7647d03c33339bd85a1665047b22ae7e800fee98", "url": "https://api.github.com/repos/rust-lang/rust/commits/7647d03c33339bd85a1665047b22ae7e800fee98", "html_url": "https://github.com/rust-lang/rust/commit/7647d03c33339bd85a1665047b22ae7e800fee98"}], "stats": {"total": 86, "additions": 50, "deletions": 36}, "files": [{"sha": "200dbf06ff8a6c236eb2378b0cf2468a83918e82", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 50, "deletions": 36, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e413d89aa706060ddc347e1e06d551ec86d3f471/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e413d89aa706060ddc347e1e06d551ec86d3f471/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=e413d89aa706060ddc347e1e06d551ec86d3f471", "patch": "@@ -59,7 +59,7 @@ use crate::os::unix::io::{AsRawFd, FromRawFd, RawFd};\n use crate::os::unix::net::UnixStream;\n use crate::process::{ChildStderr, ChildStdin, ChildStdout};\n use crate::ptr;\n-use crate::sync::atomic::{AtomicBool, Ordering};\n+use crate::sync::atomic::{AtomicBool, AtomicU8, Ordering};\n use crate::sys::cvt;\n \n #[cfg(test)]\n@@ -491,18 +491,29 @@ impl CopyResult {\n     }\n }\n \n-/// linux-specific implementation that will attempt to use copy_file_range for copy offloading\n-/// as the name says, it only works on regular files\n+/// Invalid file descriptor.\n+///\n+/// Valid file descriptors are guaranteed to be positive numbers (see `open()` manpage)\n+/// while negative values are used to indicate errors.\n+/// Thus -1 will never be overlap with a valid open file.\n+const INVALID_FD: RawFd = -1;\n+\n+/// Linux-specific implementation that will attempt to use copy_file_range for copy offloading.\n+/// As the name says, it only works on regular files.\n ///\n /// Callers must handle fallback to a generic copy loop.\n /// `Fallback` may indicate non-zero number of bytes already written\n /// if one of the files' cursor +`max_len` would exceed u64::MAX (`EOVERFLOW`).\n pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) -> CopyResult {\n     use crate::cmp;\n \n+    const NOT_PROBED: u8 = 0;\n+    const UNAVAILABLE: u8 = 1;\n+    const AVAILABLE: u8 = 2;\n+\n     // Kernel prior to 4.5 don't have copy_file_range\n     // We store the availability in a global to avoid unnecessary syscalls\n-    static HAS_COPY_FILE_RANGE: AtomicBool = AtomicBool::new(true);\n+    static HAS_COPY_FILE_RANGE: AtomicU8 = AtomicU8::new(NOT_PROBED);\n \n     syscall! {\n         fn copy_file_range(\n@@ -515,39 +526,39 @@ pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) ->\n         ) -> libc::ssize_t\n     }\n \n-    let has_copy_file_range = HAS_COPY_FILE_RANGE.load(Ordering::Relaxed);\n-    let mut written = 0u64;\n-    while written < max_len {\n-        let copy_result = if has_copy_file_range {\n-            let bytes_to_copy = cmp::min(max_len - written, usize::MAX as u64);\n-            // cap to 1GB chunks in case u64::MAX is passed as max_len and the file has a non-zero seek position\n-            // this allows us to copy large chunks without hitting EOVERFLOW,\n-            // unless someone sets a file offset close to u64::MAX - 1GB, in which case a fallback would be required\n-            let bytes_to_copy = cmp::min(bytes_to_copy as usize, 0x4000_0000usize);\n-            let copy_result = unsafe {\n-                // We actually don't have to adjust the offsets,\n-                // because copy_file_range adjusts the file offset automatically\n-                cvt(copy_file_range(\n-                    reader,\n-                    ptr::null_mut(),\n-                    writer,\n-                    ptr::null_mut(),\n-                    bytes_to_copy,\n-                    0,\n-                ))\n+    match HAS_COPY_FILE_RANGE.load(Ordering::Relaxed) {\n+        NOT_PROBED => {\n+            // EPERM can indicate seccomp filters or an immutable file.\n+            // To distinguish these cases we probe with invalid file descriptors which should result in EBADF if the syscall is supported\n+            // and some other error (ENOSYS or EPERM) if it's not available\n+            let result = unsafe {\n+                cvt(copy_file_range(INVALID_FD, ptr::null_mut(), INVALID_FD, ptr::null_mut(), 1, 0))\n             };\n-            if let Err(ref copy_err) = copy_result {\n-                match copy_err.raw_os_error() {\n-                    Some(libc::ENOSYS | libc::EPERM | libc::EOPNOTSUPP) => {\n-                        HAS_COPY_FILE_RANGE.store(false, Ordering::Relaxed);\n-                    }\n-                    _ => {}\n-                }\n+\n+            if matches!(result.map_err(|e| e.raw_os_error()), Err(Some(libc::EBADF))) {\n+                HAS_COPY_FILE_RANGE.store(AVAILABLE, Ordering::Relaxed);\n+            } else {\n+                HAS_COPY_FILE_RANGE.store(UNAVAILABLE, Ordering::Relaxed);\n+                return CopyResult::Fallback(0);\n             }\n-            copy_result\n-        } else {\n-            Err(Error::from_raw_os_error(libc::ENOSYS))\n+        }\n+        UNAVAILABLE => return CopyResult::Fallback(0),\n+        _ => {}\n+    };\n+\n+    let mut written = 0u64;\n+    while written < max_len {\n+        let bytes_to_copy = cmp::min(max_len - written, usize::MAX as u64);\n+        // cap to 1GB chunks in case u64::MAX is passed as max_len and the file has a non-zero seek position\n+        // this allows us to copy large chunks without hitting EOVERFLOW,\n+        // unless someone sets a file offset close to u64::MAX - 1GB, in which case a fallback would be required\n+        let bytes_to_copy = cmp::min(bytes_to_copy as usize, 0x4000_0000usize);\n+        let copy_result = unsafe {\n+            // We actually don't have to adjust the offsets,\n+            // because copy_file_range adjusts the file offset automatically\n+            cvt(copy_file_range(reader, ptr::null_mut(), writer, ptr::null_mut(), bytes_to_copy, 0))\n         };\n+\n         match copy_result {\n             Ok(0) if written == 0 => {\n                 // fallback to work around several kernel bugs where copy_file_range will fail to\n@@ -567,11 +578,14 @@ pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) ->\n                         libc::ENOSYS | libc::EXDEV | libc::EINVAL | libc::EPERM | libc::EOPNOTSUPP,\n                     ) => {\n                         // Try fallback io::copy if either:\n-                        // - Kernel version is < 4.5 (ENOSYS)\n+                        // - Kernel version is < 4.5 (ENOSYS\u00b9)\n                         // - Files are mounted on different fs (EXDEV)\n                         // - copy_file_range is broken in various ways on RHEL/CentOS 7 (EOPNOTSUPP)\n-                        // - copy_file_range is disallowed, for example by seccomp (EPERM)\n+                        // - copy_file_range file is immutable or syscall is blocked by seccomp\u00b9 (EPERM)\n                         // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n+                        //\n+                        // \u00b9 these cases should be detected by the initial probe but we handle them here\n+                        //   anyway in case syscall interception changes during runtime\n                         assert_eq!(written, 0);\n                         CopyResult::Fallback(0)\n                     }"}]}