{"sha": "e8cca55283ec61c5442b4a40e123d03d997c92ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4Y2NhNTUyODNlYzYxYzU0NDJiNGE0MGUxMjNkMDNkOTk3YzkyZmY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-07-20T22:15:08Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-07-22T19:02:23Z"}, "message": "Working generic impl", "tree": {"sha": "ec193de958f2b5131071c099dc724759d4f40390", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec193de958f2b5131071c099dc724759d4f40390"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8cca55283ec61c5442b4a40e123d03d997c92ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8cca55283ec61c5442b4a40e123d03d997c92ff", "html_url": "https://github.com/rust-lang/rust/commit/e8cca55283ec61c5442b4a40e123d03d997c92ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8cca55283ec61c5442b4a40e123d03d997c92ff/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73cb82384a9e97f5afd79c056ff5dba2454e6184", "url": "https://api.github.com/repos/rust-lang/rust/commits/73cb82384a9e97f5afd79c056ff5dba2454e6184", "html_url": "https://github.com/rust-lang/rust/commit/73cb82384a9e97f5afd79c056ff5dba2454e6184"}], "stats": {"total": 335, "additions": 198, "deletions": 137}, "files": [{"sha": "9203398dcb357e7c67b55ba9ec1231459b8b7c37", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 165, "deletions": 114, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/e8cca55283ec61c5442b4a40e123d03d997c92ff/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8cca55283ec61c5442b4a40e123d03d997c92ff/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=e8cca55283ec61c5442b4a40e123d03d997c92ff", "patch": "@@ -85,152 +85,203 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         name: Option<String>,\n     ) -> Vec<Item>\n     where F: Fn(DefId) -> Def {\n+        if self.cx\n+            .tcx\n+            .get_attrs(def_id)\n+            .lists(\"doc\")\n+            .has_word(\"hidden\")\n+        {\n+            debug!(\n+                \"get_auto_trait_impls(def_id={:?}, def_ctor=...): item has doc('hidden'), \\\n+                 aborting\",\n+                def_id\n+            );\n+            return Vec::new();\n+        }\n+\n         let tcx = self.cx.tcx;\n         let generics = self.cx.tcx.generics_of(def_id);\n \n         let ty = self.cx.tcx.type_of(def_id);\n         let mut traits = FxHashMap();\n-        if let ty::TyAdt(_adt, _) = ty.sty {\n-            let param_env = self.cx.tcx.param_env(def_id);\n-            match _adt.adt_kind() {\n-                AdtKind::Struct => println!(\"|||||> {}\", self.cx.tcx.item_name(def_id).to_string()),\n-                _ => {}\n-            }\n-            for &trait_def_id in self.cx.all_traits.iter() {\n-                self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n-                    self.cx.tcx.infer_ctxt().enter(|infcx| {\n-                        let trait_ref = infcx.tcx.impl_trait_ref(impl_def_id).unwrap();\n-                        let substs = infcx.fresh_substs_for_item(DUMMY_SP, def_id);\n-                        let ty2 = ty.subst(infcx.tcx, substs);\n-                        let param_env = param_env.subst(infcx.tcx, substs);\n-\n-                        let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n-                        let trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n-\n-                        // Require the type the impl is implemented on to match\n-                        // our type, and ignore the impl if there was a mismatch.\n-                        let cause = traits::ObligationCause::dummy();\n-                        let eq_result = infcx.at(&cause, param_env).eq(trait_ref.self_ty(), ty2);\n-                        if let Ok(InferOk { value: (), obligations }) = eq_result {\n-                            // FIXME(eddyb) ignoring `obligations` might cause false positives.\n-                            drop(obligations);\n-\n-                            let may_apply = infcx.predicate_may_hold(&traits::Obligation::new(\n-                                cause.clone(),\n-                                param_env,\n-                                trait_ref.to_predicate(),\n-                            ));\n-                            if may_apply {\n-                                // FIXME: add crate's id before the name to avoid removing a\n-                                // trait which doesn't exist.\n-                                if traits.get(&trait_def_id).is_none() {\n-                                    println!(\"=> {}\", infcx.tcx.item_name(trait_def_id).to_string());\n-                                    /*let generics = (infcx.tcx.generics_of(trait_def_id), &predicates).clean(cx);\n-                                    get_path_for_type(self.cx.tcx, trait_def_id, hir::def::Def::Trait)*/\n-                                    /*if let Some(i) = self.get_auto_trait_impl_for(\n-                                        def_id,\n-                                        name.clone(),\n-                                        generics.clone(),\n-                                        def_ctor,\n-                                        trait_def_id,\n-                                    ) {\n-                                        traits.insert(trait_name, i);\n-                                    }*/\n-\n-                                    let mut impls = Vec::new();\n-                                    ::clean::inline::build_impl(&self.cx, impl_def_id, &mut impls);\n-                                    /*if ::std::env::var(\"LOL\").is_ok() {\n-                                        println!(\"=> {} ::> {}\",\n-                                                 infcx.tcx.item_name(trait_def_id).to_string(),\n-                                                 impls.len());\n-                                        println!(\"{:?}\", impls);\n-                                    }*/\n-                                    for impl_ in &mut impls {\n-                                        if let ImplItem(ref mut i) = impl_.inner {\n-                                            i.synthetic = true;\n-                                            i.for_ = ty.clean(&self.cx);\n+        if self.cx.crate_name != Some(\"core\".to_string()) {\n+            if let ty::TyAdt(_adt, _) = ty.sty {\n+                let param_env = self.cx.tcx.param_env(def_id);\n+                /*let print = match _adt.adt_kind() {\n+                    AdtKind::Struct => {\n+                        //println!(\"|||||> {}\", self.cx.tcx.item_name(def_id).to_string());\n+                        true\n+                    }\n+                    _ => false,\n+                };*/\n+                for &trait_def_id in self.cx.all_traits.iter() {\n+                    if traits.get(&trait_def_id).is_some() {\n+                        continue\n+                    }\n+                    let t_name = self.cx.tcx.item_name(trait_def_id).to_string();\n+                    self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n+                        self.cx.tcx.infer_ctxt().enter(|infcx| {\n+                            let trait_ref = infcx.tcx.impl_trait_ref(impl_def_id).unwrap();\n+                            let substs = infcx.fresh_substs_for_item(DUMMY_SP, def_id);\n+                            let ty2 = ty.subst(infcx.tcx, substs);\n+                            let param_env = param_env.subst(infcx.tcx, substs);\n+\n+                            let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+                            let trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n+\n+                            // Require the type the impl is implemented on to match\n+                            // our type, and ignore the impl if there was a mismatch.\n+                            let cause = traits::ObligationCause::dummy();\n+                            let eq_result = infcx.at(&cause, param_env).eq(trait_ref.self_ty(), ty2);\n+                            if let Ok(InferOk { value: (), obligations }) = eq_result {\n+                                // FIXME(eddyb) ignoring `obligations` might cause false positives.\n+                                drop(obligations);\n+\n+                                let may_apply = infcx.predicate_may_hold(&traits::Obligation::new(\n+                                    cause.clone(),\n+                                    param_env,\n+                                    trait_ref.to_predicate(),\n+                                ));\n+                                /*if print {\n+                                    println!(\"==> {}\", infcx.tcx.item_name(trait_def_id).to_string());\n+                                }*/\n+                                if may_apply {\n+                                    if self.cx.crate_name == Some(\"std\".to_string()) && t_name == \"ToString\" {\n+                                        println!(\"may_apply: {:?}\", t_name);\n+                                    }\n+                                    // FIXME: add crate's id before the name to avoid removing a\n+                                    // trait which doesn't exist.\n+                                    if traits.get(&trait_def_id).is_none() {\n+                                        if self.cx.crate_name == Some(\"std\".to_string()) && t_name == \"ToString\" {\n+                                            println!(\"in!\");\n+                                        }\n+                                        /*if print {\n+                                            println!(\"> {}\", infcx.tcx.item_name(trait_def_id).to_string());\n+                                        }*/\n+                                        /*let generics = (infcx.tcx.generics_of(trait_def_id), &predicates).clean(cx);\n+                                        get_path_for_type(self.cx.tcx, trait_def_id, hir::def::Def::Trait)*/\n+                                        /*if let Some(i) = self.get_auto_trait_impl_for(\n+                                            def_id,\n+                                            name.clone(),\n+                                            generics.clone(),\n+                                            def_ctor,\n+                                            trait_def_id,\n+                                        ) {\n+                                            traits.insert(trait_name, i);\n+                                        }*/\n+\n+                                        let mut impls = Vec::new();\n+                                        ::clean::inline::build_impl(&self.cx, impl_def_id, &mut impls);\n+                                        /*if ::std::env::var(\"LOL\").is_ok() {\n+                                            println!(\"=> {} ::> {}\",\n+                                                     infcx.tcx.item_name(trait_def_id).to_string(),\n+                                                     impls.len());\n+                                            println!(\"{:?}\", impls);\n+                                        }*/\n+                                        for impl_ in &mut impls {\n+                                            if let ImplItem(ref mut i) = impl_.inner {\n+                                                i.synthetic = true;\n+                                                i.for_ = ty.clean(&self.cx);\n+                                                //i.visibility = None;\n+                                            }\n+                                            //impl_.visibility = None;\n+                                            if self.cx.crate_name == Some(\"std\".to_string()) && t_name == \"ToString\" {\n+                                                println!(\"**> {:?}\", impl_);\n+                                            }\n                                         }\n+                                        //traits.insert(trait_def_id, impls);\n+                                        let trait_ = hir::TraitRef {\n+                                            path: get_path_for_type(infcx.tcx, trait_def_id, hir::def::Def::Trait),\n+                                            ref_id: ast::DUMMY_NODE_ID,\n+                                        };\n+                                        let provided_trait_methods = infcx.tcx.provided_trait_methods(impl_def_id)\n+                                                                              .into_iter()\n+                                                                              .map(|meth| meth.ident.to_string())\n+                                                                              .collect();\n+                                        println!(\"|||> {}\", t_name);\n+                                        traits.insert(trait_def_id, Item {\n+                                            source: Span::empty(),\n+                                            name: None,\n+                                            attrs: Default::default(),\n+                                            visibility: None,\n+                                            def_id: self.next_def_id(impl_def_id.krate),\n+                                            stability: None,\n+                                            deprecation: None,\n+                                            inner: ImplItem(Impl {\n+                                                unsafety: hir::Unsafety::Normal,\n+                                                generics: (infcx.tcx.generics_of(trait_def_id), &Default::default()).clean(self.cx),\n+                                                provided_trait_methods,\n+                                                trait_: Some(trait_.clean(self.cx)),\n+                                                for_: ty.clean(self.cx),\n+                                                items: infcx.tcx.associated_items(impl_def_id).collect::<Vec<_>>().clean(self.cx),\n+                                                polarity: None,\n+                                                synthetic: true,\n+                                            }),\n+                                        });\n+\n+                                        /*use ::clean::{self, inline::*};\n+\n+                                        let mut ret = Vec::with_capacity(2);\n+                                        record_extern_fqn(self.cx, trait_def_id, clean::TypeKind::Trait);\n+                                        ret.extend(build_impls(self.cx, trait_def_id, false));\n+                                        let inner = clean::TraitItem(build_external_trait(self.cx, trait_def_id));\n+                                        let cx = self.cx;\n+                                        ret.push(clean::Item {\n+                                            source: infcx.tcx.def_span(trait_def_id).clean(cx),\n+                                            name: Some(infcx.tcx.item_name(trait_def_id).to_string()),\n+                                            attrs: load_attrs(cx, trait_def_id),\n+                                            inner,\n+                                            visibility: Some(clean::Public),\n+                                            stability: cx.tcx.lookup_stability(trait_def_id).clean(cx),\n+                                            deprecation: cx.tcx.lookup_deprecation(trait_def_id).clean(cx),\n+                                            def_id: trait_def_id,\n+                                        });\n+                                        traits.insert(trait_def_id, ret);*/\n                                     }\n-                                    traits.insert(trait_def_id, impls);\n-\n-                                    /*use ::clean::{self, inline::*};\n-\n-                                    let mut ret = Vec::with_capacity(2);\n-                                    record_extern_fqn(self.cx, trait_def_id, clean::TypeKind::Trait);\n-                                    ret.extend(build_impls(self.cx, trait_def_id, false));\n-                                    let inner = clean::TraitItem(build_external_trait(self.cx, trait_def_id));\n-                                    let cx = self.cx;\n-                                    ret.push(clean::Item {\n-                                        source: infcx.tcx.def_span(trait_def_id).clean(cx),\n-                                        name: Some(infcx.tcx.item_name(trait_def_id).to_string()),\n-                                        attrs: load_attrs(cx, trait_def_id),\n-                                        inner,\n-                                        visibility: Some(clean::Public),\n-                                        stability: cx.tcx.lookup_stability(trait_def_id).clean(cx),\n-                                        deprecation: cx.tcx.lookup_deprecation(trait_def_id).clean(cx),\n-                                        def_id: trait_def_id,\n-                                    });\n-                                    traits.insert(trait_def_id, ret);*/\n+                                    //println!(\"=> {}\", infcx.tcx.item_name(trait_def_id).to_string());\n                                 }\n-                                //println!(\"=> {}\", infcx.tcx.item_name(trait_def_id).to_string());\n+                                debug!(\"{:?} => {}\", trait_ref, may_apply);\n                             }\n-                            debug!(\"{:?} => {}\", trait_ref, may_apply);\n-                        }\n+                        });\n                     });\n-                });\n+                }\n             }\n         }\n         //let res = self.cx.tcx.trait_impls_of(def_id);\n         //println!(\"=> {:?} {:?}\", res.blanket_impls.len(), res.non_blanket_impls.len());\n-        if self.cx\n-            .tcx\n-            .get_attrs(def_id)\n-            .lists(\"doc\")\n-            .has_word(\"hidden\")\n-        {\n-            debug!(\n-                \"get_auto_trait_impls(def_id={:?}, def_ctor=...): item has doc('hidden'), \\\n-                 aborting\",\n-                def_id\n-            );\n-            return Vec::new();\n-        }\n \n         debug!(\n             \"get_auto_trait_impls(def_id={:?}, def_ctor=..., generics={:?}\",\n             def_id, generics\n         );\n-        let auto_traits: Vec<_> = self.cx\n-            .send_trait\n-            .and_then(|send_trait| {\n-                self.get_auto_trait_impl_for(\n-                    def_id,\n-                    name.clone(),\n-                    generics.clone(),\n-                    def_ctor,\n-                    send_trait,\n-                )\n-            })\n-            .into_iter()\n+        let auto_traits: Vec<_> =\n+            self.cx.send_trait\n+                          .and_then(|send_trait| {\n+                    self.get_auto_trait_impl_for(\n+                        def_id,\n+                        name.clone(),\n+                        generics.clone(),\n+                        def_ctor,\n+                        send_trait,\n+                    )\n+                }).into_iter()\n             .chain(self.get_auto_trait_impl_for(\n                 def_id,\n                 name.clone(),\n                 generics.clone(),\n                 def_ctor,\n                 tcx.require_lang_item(lang_items::SyncTraitLangItem),\n             ).into_iter())\n-            .chain(traits.into_iter().flat_map(|(_, v)| v.into_iter()))\n+            .chain(traits.into_iter().map(|(_, v)| v))//.flat_map(|(_, v)| v.into_iter()))\n             .collect();\n \n         debug!(\n             \"get_auto_traits: type {:?} auto_traits {:?}\",\n             def_id, auto_traits\n         );\n-        /*if ::std::env::var(\"LOL\").is_ok() {\n-            for x in &auto_traits {\n-                println!(\"\\n=> {:?}\", x);\n-            }\n-        }*/\n+        if self.cx.crate_name == Some(\"std\".to_string()) {\n+            println!(\"((((((> {} {:?}\", auto_traits.len(), auto_traits);\n+        }\n         auto_traits\n     }\n "}, {"sha": "cb9cb7a3e0f480aae06d3d376937df71cb6aa466", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8cca55283ec61c5442b4a40e123d03d997c92ff/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8cca55283ec61c5442b4a40e123d03d997c92ff/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e8cca55283ec61c5442b4a40e123d03d997c92ff", "patch": "@@ -276,6 +276,9 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n         let auto_impls = get_auto_traits_with_def_id(cx, did);\n         let mut renderinfo = cx.renderinfo.borrow_mut();\n \n+        if cx.crate_name == Some(\"std\".to_string()) {\n+            println!(\"=====> {} {:?}\\n\", auto_impls.len(), auto_impls);\n+        }\n         let new_impls: Vec<clean::Item> = auto_impls.into_iter()\n             .filter(|i| renderinfo.inlined.insert(i.def_id)).collect();\n \n@@ -337,6 +340,9 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n             build_impl(cx, def_id, &mut impls);\n \n             let auto_impls = get_auto_traits_with_def_id(cx, def_id);\n+            if cx.crate_name == Some(\"std\".to_string()) {\n+                println!(\"-----> {} {:?}\\n\", auto_impls.len(), auto_impls);\n+            }\n             let mut renderinfo = cx.renderinfo.borrow_mut();\n \n             let new_impls: Vec<clean::Item> = auto_impls.into_iter()"}, {"sha": "d893ec415e8c7b7425d1059cb3ec79139f5e3606", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8cca55283ec61c5442b4a40e123d03d997c92ff/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8cca55283ec61c5442b4a40e123d03d997c92ff/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e8cca55283ec61c5442b4a40e123d03d997c92ff", "patch": "@@ -84,7 +84,7 @@ pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a> {\n     /// Maps (type_id, trait_id) -> auto trait impl\n     pub generated_synthetics: RefCell<FxHashSet<(DefId, DefId)>>,\n     pub current_item_name: RefCell<Option<Name>>,\n-    pub all_traits: Lrc<Vec<DefId>>,\n+    pub all_traits: Vec<DefId>,\n }\n \n impl<'a, 'tcx, 'rcx> DocContext<'a, 'tcx, 'rcx> {\n@@ -386,7 +386,7 @@ pub fn run_core(search_paths: SearchPaths,\n                 all_fake_def_ids: RefCell::new(FxHashSet()),\n                 generated_synthetics: RefCell::new(FxHashSet()),\n                 current_item_name: RefCell::new(None),\n-                all_traits: tcx.all_traits(LOCAL_CRATE),\n+                all_traits: tcx.all_traits(LOCAL_CRATE).to_vec(),\n             };\n             debug!(\"crate: {:?}\", tcx.hir.krate());\n "}, {"sha": "408250a259b276a139313750b8d302c329bdf54f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e8cca55283ec61c5442b4a40e123d03d997c92ff/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8cca55283ec61c5442b4a40e123d03d997c92ff/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e8cca55283ec61c5442b4a40e123d03d997c92ff", "patch": "@@ -3584,29 +3584,32 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         Some(v) => v,\n         None => return Ok(()),\n     };\n+    //println!(\"=======> {:?}\", containing_item.name);\n     let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| {\n-        /*if ::std::env::var(\"LOL\").is_ok() {\n-            if let Some(ref t) = i.inner_impl().trait_ {\n-                println!(\"==> {:?}\", t);\n-            }\n+        /*if let Some(ref t) = i.inner_impl().trait_ {\n+            println!(\"++++++> {:?}\", t);\n+        }*/\n+        /*if i.inner_impl().trait_.is_some() {\n+            println!(\"++++++> {:?}\", i.name);\n         }*/\n         i.inner_impl().trait_.is_none()\n     });\n     if !non_trait.is_empty() {\n         let render_mode = match what {\n             AssocItemRender::All => {\n-                write!(w, \"\n-                    <h2 id='methods' class='small-section-header'>\n-                      Methods<a href='#methods' class='anchor'></a>\n-                    </h2>\n+                write!(w, \"\\\n+                    <h2 id='methods' class='small-section-header'>\\\n+                      Methods<a href='#methods' class='anchor'></a>\\\n+                    </h2>\\\n                 \")?;\n                 RenderMode::Normal\n             }\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n-                write!(w, \"\n-                    <h2 id='deref-methods' class='small-section-header'>\n-                      Methods from {}&lt;Target = {}&gt;<a href='#deref-methods' class='anchor'></a>\n-                    </h2>\n+                write!(w, \"\\\n+                    <h2 id='deref-methods' class='small-section-header'>\\\n+                      Methods from {}&lt;Target = {}&gt;\\\n+                      <a href='#deref-methods' class='anchor'></a>\\\n+                    </h2>\\\n                 \", trait_, type_)?;\n                 RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n@@ -3653,19 +3656,20 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n \n         let impls = format!(\"{}\", RendererStruct(cx, concrete, containing_item));\n         if !impls.is_empty() {\n-            write!(w, \"\n-                <h2 id='implementations' class='small-section-header'>\n-                  Trait Implementations<a href='#implementations' class='anchor'></a>\n-                </h2>\n+            write!(w, \"\\\n+                <h2 id='implementations' class='small-section-header'>\\\n+                  Trait Implementations<a href='#implementations' class='anchor'></a>\\\n+                </h2>\\\n                 <div id='implementations-list'>{}</div>\", impls)?;\n         }\n \n         if !synthetic.is_empty() {\n-            write!(w, \"\n-                <h2 id='synthetic-implementations' class='small-section-header'>\n-                  Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a>\n-                </h2>\n-                <div id='synthetic-implementations-list'>\n+            write!(w, \"\\\n+                <h2 id='synthetic-implementations' class='small-section-header'>\\\n+                  Auto Trait Implementations\\\n+                  <a href='#synthetic-implementations' class='anchor'></a>\\\n+                </h2>\\\n+                <div id='synthetic-implementations-list'>\\\n             \")?;\n             render_impls(cx, w, &synthetic, containing_item)?;\n             write!(w, \"</div>\")?;"}]}