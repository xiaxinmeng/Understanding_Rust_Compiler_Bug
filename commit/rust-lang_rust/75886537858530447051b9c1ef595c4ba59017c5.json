{"sha": "75886537858530447051b9c1ef595c4ba59017c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ODg2NTM3ODU4NTMwNDQ3MDUxYjljMWVmNTk1YzRiYTU5MDE3YzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-21T11:05:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-21T11:05:34Z"}, "message": "Auto merge of #34939 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 7 pull requests\n\n- Successful merges: #34854, #34855, #34880, #34895, #34911, #34921, #34930\n- Failed merges: #33951, #34850", "tree": {"sha": "e370ed899678d5f36a30e52434997535a625ea9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e370ed899678d5f36a30e52434997535a625ea9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75886537858530447051b9c1ef595c4ba59017c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75886537858530447051b9c1ef595c4ba59017c5", "html_url": "https://github.com/rust-lang/rust/commit/75886537858530447051b9c1ef595c4ba59017c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75886537858530447051b9c1ef595c4ba59017c5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7c822cee29b5b939340c2cb0dfefa9a49742d77", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c822cee29b5b939340c2cb0dfefa9a49742d77", "html_url": "https://github.com/rust-lang/rust/commit/e7c822cee29b5b939340c2cb0dfefa9a49742d77"}, {"sha": "22a14a83891d4c492a7133691383d825fbb4cde0", "url": "https://api.github.com/repos/rust-lang/rust/commits/22a14a83891d4c492a7133691383d825fbb4cde0", "html_url": "https://github.com/rust-lang/rust/commit/22a14a83891d4c492a7133691383d825fbb4cde0"}], "stats": {"total": 461, "additions": 435, "deletions": 26}, "files": [{"sha": "e4cb861d3b0f5299243fbd22f22a66ac91561dc3", "filename": "src/doc/book/loops.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/75886537858530447051b9c1ef595c4ba59017c5/src%2Fdoc%2Fbook%2Floops.md", "raw_url": "https://github.com/rust-lang/rust/raw/75886537858530447051b9c1ef595c4ba59017c5/src%2Fdoc%2Fbook%2Floops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Floops.md?ref=75886537858530447051b9c1ef595c4ba59017c5", "patch": "@@ -105,19 +105,19 @@ When you need to keep track of how many times you already looped, you can use th\n #### On ranges:\n \n ```rust\n-for (i, j) in (5..10).enumerate() {\n-    println!(\"i = {} and j = {}\", i, j);\n+for (index, value) in (5..10).enumerate() {\n+    println!(\"index = {} and value = {}\", index, value);\n }\n ```\n \n Outputs:\n \n ```text\n-i = 0 and j = 5\n-i = 1 and j = 6\n-i = 2 and j = 7\n-i = 3 and j = 8\n-i = 4 and j = 9\n+index = 0 and value = 5\n+index = 1 and value = 6\n+index = 2 and value = 7\n+index = 3 and value = 8\n+index = 4 and value = 9\n ```\n \n Don't forget to add the parentheses around the range."}, {"sha": "c3a7d4023754aac97d45a0539a9cf0e4a8cfe490", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 189, "deletions": 2, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=75886537858530447051b9c1ef595c4ba59017c5", "patch": "@@ -313,6 +313,10 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n+/// This enum is constructed from the [`entry`] method on [`BTreeMap`].\n+///\n+/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`entry`]: struct.BTreeMap.html#method.entry\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// A vacant Entry\n@@ -340,7 +344,9 @@ impl<'a, K: 'a + Debug + Ord, V: 'a + Debug> Debug for Entry<'a, K, V> {\n     }\n }\n \n-/// A vacant Entry.\n+/// A vacant Entry. It is part of the [`Entry`] enum.\n+///\n+/// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     key: K,\n@@ -360,7 +366,9 @@ impl<'a, K: 'a + Debug + Ord, V: 'a> Debug for VacantEntry<'a, K, V> {\n     }\n }\n \n-/// An occupied Entry.\n+/// An occupied Entry. It is part of the [`Entry`] enum.\n+///\n+/// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n@@ -1890,6 +1898,17 @@ impl<K, V> BTreeMap<K, V> {\n impl<'a, K: Ord, V> Entry<'a, K, V> {\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_insert(self, default: V) -> &'a mut V {\n         match self {\n@@ -1900,6 +1919,19 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n \n     /// Ensures a value is in the entry by inserting the result of the default function if empty,\n     /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, String> = BTreeMap::new();\n+    /// let s = \"hoho\".to_owned();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with(|| s);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_owned());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n         match self {\n@@ -1909,6 +1941,15 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n     }\n \n     /// Returns a reference to this entry's key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         match *self {\n@@ -1921,19 +1962,58 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Gets a reference to the key that would be used when inserting a value\n     /// through the VacantEntry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         &self.key\n     }\n \n     /// Take ownership of the key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_entry_recover_keys)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n+    ///     v.into_key();\n+    /// }\n+    /// ```\n     #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n     pub fn into_key(self) -> K {\n         self.key\n     }\n \n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// // count the number of occurrences of letters in the vec\n+    /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"] {\n+    ///     *count.entry(x).or_insert(0) += 1;\n+    /// }\n+    ///\n+    /// assert_eq!(count[\"a\"], 3);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         *self.length += 1;\n@@ -1979,43 +2059,150 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the key in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         self.handle.reborrow().into_kv().0\n     }\n \n     /// Take ownership of the key and value from the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_entry_recover_keys)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     // We delete the entry from the map.\n+    ///     o.remove_pair();\n+    /// }\n+    ///\n+    /// // If now try to get the value, it will panic:\n+    /// // println!(\"{}\", map[\"poneyland\"]);\n+    /// ```\n     #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n     pub fn remove_pair(self) -> (K, V) {\n         self.remove_kv()\n     }\n \n     /// Gets a reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.get(), &12);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n         self.handle.reborrow().into_kv().1\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///      *o.get_mut() += 10;\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.handle.kv_mut().1\n     }\n \n     /// Converts the entry into a mutable reference to its value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     *o.into_mut() += 10;\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.handle.into_kv_mut().1\n     }\n \n     /// Sets the value of the entry with the OccupiedEntry's key,\n     /// and returns the entry's old value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.insert(15), 12);\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 15);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: V) -> V {\n         mem::replace(self.get_mut(), value)\n     }\n \n     /// Takes the value of the entry out of the map, and returns it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.remove(), 12);\n+    /// }\n+    /// // If we try to get \"poneyland\"'s value, it'll panic:\n+    /// // println!(\"{}\", map[\"poneyland\"]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(self) -> V {\n         self.remove_kv().1"}, {"sha": "3d5c3125fae2489c460f1352aa4776a1017fdf33", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 65, "deletions": 9, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=75886537858530447051b9c1ef595c4ba59017c5", "patch": "@@ -172,6 +172,14 @@ impl<T> Default for LinkedList<T> {\n \n impl<T> LinkedList<T> {\n     /// Creates an empty `LinkedList`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let list: LinkedList<u32> = LinkedList::new();\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Self {\n@@ -226,6 +234,24 @@ impl<T> LinkedList<T> {\n     }\n \n     /// Provides a forward iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let mut list: LinkedList<u32> = LinkedList::new();\n+    ///\n+    /// list.push_back(0);\n+    /// list.push_back(1);\n+    /// list.push_back(2);\n+    ///\n+    /// let mut iter = list.iter();\n+    /// assert_eq!(iter.next(), Some(&0));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n@@ -238,6 +264,28 @@ impl<T> LinkedList<T> {\n     }\n \n     /// Provides a forward iterator with mutable references.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let mut list: LinkedList<u32> = LinkedList::new();\n+    ///\n+    /// list.push_back(0);\n+    /// list.push_back(1);\n+    /// list.push_back(2);\n+    ///\n+    /// for element in list.iter_mut() {\n+    ///     *element += 10;\n+    /// }\n+    ///\n+    /// let mut iter = list.iter();\n+    /// assert_eq!(iter.next(), Some(&10));\n+    /// assert_eq!(iter.next(), Some(&11));\n+    /// assert_eq!(iter.next(), Some(&12));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n@@ -289,7 +337,6 @@ impl<T> LinkedList<T> {\n     ///\n     /// dl.push_back(3);\n     /// assert_eq!(dl.len(), 3);\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -316,7 +363,6 @@ impl<T> LinkedList<T> {\n     /// dl.clear();\n     /// assert_eq!(dl.len(), 0);\n     /// assert_eq!(dl.front(), None);\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -326,6 +372,23 @@ impl<T> LinkedList<T> {\n \n     /// Returns `true` if the `LinkedList` contains an element equal to the\n     /// given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(linked_list_contains)]\n+    ///\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let mut list: LinkedList<u32> = LinkedList::new();\n+    ///\n+    /// list.push_back(0);\n+    /// list.push_back(1);\n+    /// list.push_back(2);\n+    ///\n+    /// assert_eq!(list.contains(&0), true);\n+    /// assert_eq!(list.contains(&10), false);\n+    /// ```\n     #[unstable(feature = \"linked_list_contains\", reason = \"recently added\",\n                issue = \"32630\")]\n     pub fn contains(&self, x: &T) -> bool\n@@ -347,7 +410,6 @@ impl<T> LinkedList<T> {\n     ///\n     /// dl.push_front(1);\n     /// assert_eq!(dl.front(), Some(&1));\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -374,7 +436,6 @@ impl<T> LinkedList<T> {\n     ///     Some(x) => *x = 5,\n     /// }\n     /// assert_eq!(dl.front(), Some(&5));\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -395,7 +456,6 @@ impl<T> LinkedList<T> {\n     ///\n     /// dl.push_back(1);\n     /// assert_eq!(dl.back(), Some(&1));\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -422,7 +482,6 @@ impl<T> LinkedList<T> {\n     ///     Some(x) => *x = 5,\n     /// }\n     /// assert_eq!(dl.back(), Some(&5));\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -446,7 +505,6 @@ impl<T> LinkedList<T> {\n     ///\n     /// dl.push_front(1);\n     /// assert_eq!(dl.front().unwrap(), &1);\n-    ///\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, elt: T) {\n@@ -471,9 +529,7 @@ impl<T> LinkedList<T> {\n     /// assert_eq!(d.pop_front(), Some(3));\n     /// assert_eq!(d.pop_front(), Some(1));\n     /// assert_eq!(d.pop_front(), None);\n-    ///\n     /// ```\n-    ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n         self.pop_front_node().map(Node::into_element)"}, {"sha": "a2d1f09b6a5aef08d425f02ebd4a3669597ad8ca", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=75886537858530447051b9c1ef595c4ba59017c5", "patch": "@@ -59,7 +59,7 @@ use core::fmt;\n use core::hash;\n use core::iter::FromIterator;\n use core::mem;\n-use core::ops::{self, Add, Index, IndexMut};\n+use core::ops::{self, Add, AddAssign, Index, IndexMut};\n use core::ptr;\n use core::str::pattern::Pattern;\n use rustc_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n@@ -1565,6 +1565,14 @@ impl<'a> Add<&'a str> for String {\n     }\n }\n \n+#[stable(feature = \"stringaddassign\", since = \"1.12.0\")]\n+impl<'a> AddAssign<&'a str> for String {\n+    #[inline]\n+    fn add_assign(&mut self, other: &str) {\n+        self.push_str(other);\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::Range<usize>> for String {\n     type Output = str;"}, {"sha": "2d77b38879b8eb8a959f4920b51abbf6bc66f57c", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=75886537858530447051b9c1ef595c4ba59017c5", "patch": "@@ -541,6 +541,14 @@ impl<T> Vec<T> {\n     /// Extracts a slice containing the entire vector.\n     ///\n     /// Equivalent to `&s[..]`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{self, Write};\n+    /// let buffer = vec![1, 2, 3, 5, 8];\n+    /// io::sink().write(buffer.as_slice()).unwrap();\n+    /// ```\n     #[inline]\n     #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n     pub fn as_slice(&self) -> &[T] {\n@@ -550,6 +558,14 @@ impl<T> Vec<T> {\n     /// Extracts a mutable slice of the entire vector.\n     ///\n     /// Equivalent to `&mut s[..]`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{self, Read};\n+    /// let mut buffer = vec![0; 3];\n+    /// io::repeat(0b101).read_exact(buffer.as_mut_slice()).unwrap();\n+    /// ```\n     #[inline]\n     #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n@@ -565,9 +581,37 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = vec![1, 2, 3, 4];\n+    /// use std::ptr;\n+    ///\n+    /// let mut vec = vec!['r', 'u', 's', 't'];\n+    ///\n+    /// unsafe {\n+    ///     ptr::drop_in_place(&mut vec[3]);\n+    ///     vec.set_len(3);\n+    /// }\n+    /// assert_eq!(vec, ['r', 'u', 's']);\n+    /// ```\n+    ///\n+    /// In this example, there is a memory leak since the memory locations\n+    /// owned by the vector were not freed prior to the `set_len` call:\n+    ///\n+    /// ```\n+    /// let mut vec = vec!['r', 'u', 's', 't'];\n+    ///\n+    /// unsafe {\n+    ///     vec.set_len(0);\n+    /// }\n+    /// ```\n+    ///\n+    /// In this example, the vector gets expanded from zero to four items\n+    /// without any memory allocations occurring, resulting in vector\n+    /// values of unallocated memory:\n+    ///\n+    /// ```\n+    /// let mut vec: Vec<char> = Vec::new();\n+    ///\n     /// unsafe {\n-    ///     v.set_len(1);\n+    ///     vec.set_len(4);\n     /// }\n     /// ```\n     #[inline]"}, {"sha": "9e4428ec57d50db1eaf6a1a95c725deeb921f28a", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=75886537858530447051b9c1ef595c4ba59017c5", "patch": "@@ -365,12 +365,28 @@ impl<T> VecDeque<T> {\n \n impl<T> VecDeque<T> {\n     /// Creates an empty `VecDeque`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let vector: VecDeque<u32> = VecDeque::new();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> VecDeque<T> {\n         VecDeque::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Creates an empty `VecDeque` with space for at least `n` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let vector: VecDeque<u32> = VecDeque::with_capacity(10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(n: usize) -> VecDeque<T> {\n         // +1 since the ringbuffer always leaves one space empty\n@@ -696,6 +712,25 @@ impl<T> VecDeque<T> {\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut vector: VecDeque<u32> = VecDeque::new();\n+    ///\n+    /// vector.push_back(0);\n+    /// vector.push_back(1);\n+    /// vector.push_back(2);\n+    ///\n+    /// assert_eq!(vector.as_slices(), (&[0u32, 1, 2] as &[u32], &[] as &[u32]));\n+    ///\n+    /// vector.push_front(10);\n+    /// vector.push_front(9);\n+    ///\n+    /// assert_eq!(vector.as_slices(), (&[9u32, 10] as &[u32], &[0u32, 1, 2] as &[u32]));\n+    /// ```\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n@@ -715,6 +750,24 @@ impl<T> VecDeque<T> {\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut vector: VecDeque<u32> = VecDeque::new();\n+    ///\n+    /// vector.push_back(0);\n+    /// vector.push_back(1);\n+    ///\n+    /// vector.push_front(10);\n+    /// vector.push_front(9);\n+    ///\n+    /// vector.as_mut_slices().0[0] = 42;\n+    /// vector.as_mut_slices().1[0] = 24;\n+    /// assert_eq!(vector.as_slices(), (&[42u32, 10] as &[u32], &[24u32, 1] as &[u32]));\n+    /// ```\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n@@ -789,7 +842,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n-\n+    ///\n     /// let mut v: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n     /// assert_eq!(vec![3].into_iter().collect::<VecDeque<_>>(), v.drain(2..).collect());\n     /// assert_eq!(vec![1, 2].into_iter().collect::<VecDeque<_>>(), v);\n@@ -875,6 +928,22 @@ impl<T> VecDeque<T> {\n \n     /// Returns `true` if the `VecDeque` contains an element equal to the\n     /// given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_deque_contains)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut vector: VecDeque<u32> = VecDeque::new();\n+    ///\n+    /// vector.push_back(0);\n+    /// vector.push_back(1);\n+    ///\n+    /// assert_eq!(vector.contains(&1), true);\n+    /// assert_eq!(vector.contains(&10), false);\n+    /// ```\n     #[unstable(feature = \"vec_deque_contains\", reason = \"recently added\",\n                issue = \"32630\")]\n     pub fn contains(&self, x: &T) -> bool\n@@ -1404,6 +1473,7 @@ impl<T> VecDeque<T> {\n     /// Returns `None` if `index` is out of bounds.\n     ///\n     /// # Examples\n+    ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///"}, {"sha": "fe508adb71380089d4e313114288410fcb6274eb", "filename": "src/libcore/option.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=75886537858530447051b9c1ef595c4ba59017c5", "patch": "@@ -142,6 +142,7 @@\n use self::Option::*;\n \n use clone::Clone;\n+use convert::From;\n use default::Default;\n use iter::ExactSizeIterator;\n use iter::{Iterator, DoubleEndedIterator, FromIterator, IntoIterator};\n@@ -754,6 +755,13 @@ impl<'a, T> IntoIterator for &'a mut Option<T> {\n     }\n }\n \n+#[stable(since = \"1.12.0\", feature = \"option_from\")]\n+impl<T> From<T> for Option<T> {\n+    fn from(val: T) -> Option<T> {\n+        Some(val)\n+    }\n+}\n+\n /////////////////////////////////////////////////////////////////////////////\n // The Option Iterators\n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "ceb17e53a5552e41540b94e3d850f72d4d08b07c", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=75886537858530447051b9c1ef595c4ba59017c5", "patch": "@@ -22,7 +22,7 @@ pub fn target() -> Target {\n         target_vendor: \"unknown\".to_string(),\n         options: TargetOptions {\n             cpu: \"mips32r2\".to_string(),\n-            features: \"+mips32r2,+soft-float\".to_string(),\n+            features: \"+mips32r2\".to_string(),\n             max_atomic_width: 32,\n             ..super::linux_base::opts()\n         },"}, {"sha": "de0457592fc8834cfa5bbc62cf38bd2c1182f2fc", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=75886537858530447051b9c1ef595c4ba59017c5", "patch": "@@ -636,8 +636,11 @@ span.since {\n     margin-right: 5px;\n }\n \n-.enum > .toggle-wrapper > .collapse-toggle, .struct > .toggle-wrapper > .collapse-toggle {\n+.toggle-wrapper > .collapse-toggle {\n     left: 0;\n+}\n+\n+.variant + .toggle-wrapper > a {\n     margin-top: 5px;\n }\n "}, {"sha": "a03249e0063568b38ec49ee378e021a8d6b72c2f", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=75886537858530447051b9c1ef595c4ba59017c5", "patch": "@@ -1351,13 +1351,37 @@ pub enum Entry<'a, K: 'a, V: 'a> {\n     ),\n }\n \n+#[stable(feature= \"debug_hash_map\", since = \"1.12.0\")]\n+impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for Entry<'a, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Vacant(ref v) => f.debug_tuple(\"Entry\")\n+                              .field(v)\n+                              .finish(),\n+            Occupied(ref o) => f.debug_tuple(\"Entry\")\n+                                .field(o)\n+                                .finish(),\n+        }\n+    }\n+}\n+\n /// A view into a single occupied location in a HashMap.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     key: Option<K>,\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n \n+#[stable(feature= \"debug_hash_map\", since = \"1.12.0\")]\n+impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for OccupiedEntry<'a, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"OccupiedEntry\")\n+         .field(\"key\", self.key())\n+         .field(\"value\", self.get())\n+         .finish()\n+    }\n+}\n+\n /// A view into a single empty location in a HashMap.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n@@ -1366,6 +1390,15 @@ pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n+#[stable(feature= \"debug_hash_map\", since = \"1.12.0\")]\n+impl<'a, K: 'a + Debug, V: 'a> Debug for VacantEntry<'a, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"VacantEntry\")\n+         .field(self.key())\n+         .finish()\n+    }\n+}\n+\n /// Possible states of a VacantEntry.\n enum VacantEntryState<K, V, M> {\n     /// The index is occupied, but the key to insert has precedence,"}, {"sha": "c28f70b8692ad7a739e1b8a83e3564bac642ba07", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75886537858530447051b9c1ef595c4ba59017c5/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=75886537858530447051b9c1ef595c4ba59017c5", "patch": "@@ -791,8 +791,8 @@ impl Iterator for ReadDir {\n impl DirEntry {\n     /// Returns the full path to the file that this entry represents.\n     ///\n-    /// The full path is created by joining the original path to `read_dir` or\n-    /// `walk_dir` with the filename of this entry.\n+    /// The full path is created by joining the original path to `read_dir`\n+    /// with the filename of this entry.\n     ///\n     /// # Examples\n     ///"}]}