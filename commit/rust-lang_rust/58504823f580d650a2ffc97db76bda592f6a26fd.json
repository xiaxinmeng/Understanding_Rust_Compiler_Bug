{"sha": "58504823f580d650a2ffc97db76bda592f6a26fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NTA0ODIzZjU4MGQ2NTBhMmZmYzk3ZGI3NmJkYTU5MmY2YTI2ZmQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-21T18:42:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-21T18:42:25Z"}, "message": "Rollup merge of #68399 - Centril:check-match-unify, r=oli-obk\n\ncheck_match: misc unifications and ICE fixes\n\nThese are some unifications made as a by-product of working on `hir::ExprKind::Let`.\n\nFixes https://github.com/rust-lang/rust/issues/68396.\nFixes https://github.com/rust-lang/rust/issues/68394.\nFixes https://github.com/rust-lang/rust/issues/68393.\n\nr? @oli-obk @matthewjasper", "tree": {"sha": "9d0121c16d746402aac8b9e34fa905f042a89668", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d0121c16d746402aac8b9e34fa905f042a89668"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58504823f580d650a2ffc97db76bda592f6a26fd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeJ0YRCRBK7hj4Ov3rIwAAdHIIAG+JK0U2nKkTFQjnSypgOZHm\nLbWVep2o7HPbWkkUtH6ebOgZESVOnzj85ovdttRlgu3BB0t4h43KTHDlvdLxKI8O\nw6wvB3lE92hj2VMQQRlX+J0OU5iMh3YUSBcjLf3g0+7dZp2jPRStFUG4TVOnm9VH\nEooBrN8zXnsUgHfN9m6q6YnJPkj0lZDcaez/yrfAkIZKPwE6LL3VMQ03Ttg/Rvxo\nuUJWEmNFIkFe+SiEetNSPK2uFYuXIHnCHw1FnMeIWZuODMfdqiFiwDI0eBChuKkk\ngnpZvNwyKk/YWJnVrtT9SBP66XP6gKSx8w6RoKJFpkv+f++LzANF/1kwc+cnj5w=\n=XPRI\n-----END PGP SIGNATURE-----\n", "payload": "tree 9d0121c16d746402aac8b9e34fa905f042a89668\nparent 3fa8cc38777362f30ec560f6164239923403ea3e\nparent 58eb03d20f08881d06334c38a3ae0da25a8924bc\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1579632145 +0100\ncommitter GitHub <noreply@github.com> 1579632145 +0100\n\nRollup merge of #68399 - Centril:check-match-unify, r=oli-obk\n\ncheck_match: misc unifications and ICE fixes\n\nThese are some unifications made as a by-product of working on `hir::ExprKind::Let`.\n\nFixes https://github.com/rust-lang/rust/issues/68396.\nFixes https://github.com/rust-lang/rust/issues/68394.\nFixes https://github.com/rust-lang/rust/issues/68393.\n\nr? @oli-obk @matthewjasper\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58504823f580d650a2ffc97db76bda592f6a26fd", "html_url": "https://github.com/rust-lang/rust/commit/58504823f580d650a2ffc97db76bda592f6a26fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58504823f580d650a2ffc97db76bda592f6a26fd/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fa8cc38777362f30ec560f6164239923403ea3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fa8cc38777362f30ec560f6164239923403ea3e", "html_url": "https://github.com/rust-lang/rust/commit/3fa8cc38777362f30ec560f6164239923403ea3e"}, {"sha": "58eb03d20f08881d06334c38a3ae0da25a8924bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/58eb03d20f08881d06334c38a3ae0da25a8924bc", "html_url": "https://github.com/rust-lang/rust/commit/58eb03d20f08881d06334c38a3ae0da25a8924bc"}], "stats": {"total": 293, "additions": 198, "deletions": 95}, "files": [{"sha": "cbb40f4e2a25e2230f921477fec031b4af84aa24", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58504823f580d650a2ffc97db76bda592f6a26fd/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/58504823f580d650a2ffc97db76bda592f6a26fd/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=58504823f580d650a2ffc97db76bda592f6a26fd", "patch": "@@ -3763,6 +3763,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_macros\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"serialize\","}, {"sha": "a22c4d18d516aac646078b180acebc953515e0df", "filename": "src/librustc_mir_build/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Flibrustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Flibrustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2FCargo.toml?ref=58504823f580d650a2ffc97db76bda592f6a26fd", "patch": "@@ -21,6 +21,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_target = { path = \"../librustc_target\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "20183fd55c871ccfd208cbef9af9ed6791421acb", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=58504823f580d650a2ffc97db76bda592f6a26fd", "patch": "@@ -582,15 +582,12 @@ crate struct MatchCheckCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n-    crate fn create_and_enter<F, R>(\n+    crate fn create_and_enter<R>(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         module: DefId,\n-        f: F,\n-    ) -> R\n-    where\n-        F: for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R,\n-    {\n+        f: impl for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R,\n+    ) -> R {\n         let pattern_arena = TypedArena::default();\n \n         f(MatchCheckCtxt { tcx, param_env, module, pattern_arena: &pattern_arena })"}, {"sha": "49b7c2d41fcbb2978cf9e938e7cd63a115ffd25d", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 66, "deletions": 87, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=58504823f580d650a2ffc97db76bda592f6a26fd", "patch": "@@ -5,16 +5,17 @@ use super::_match::{expand_pattern, is_useful, MatchCheckCtxt, Matrix, PatStack}\n use super::{PatCtxt, PatKind, PatternError};\n \n use rustc::hir::map::Map;\n-use rustc::lint;\n-use rustc::session::parse::feature_err;\n-use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_errors::{error_code, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::*;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{HirId, Pat};\n+use rustc_session::lint::builtin::BINDINGS_WITH_VARIANT_NAME;\n+use rustc_session::lint::builtin::{IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS};\n+use rustc_session::parse::feature_err;\n+use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::{MultiSpan, Span};\n use syntax::ast::Mutability;\n@@ -67,18 +68,13 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n             hir::LocalSource::AwaitDesugar => (\"`await` future binding\", None),\n         };\n         self.check_irrefutable(&loc.pat, msg, sp);\n-\n-        // Check legality of move bindings and `@` patterns.\n         self.check_patterns(false, &loc.pat);\n     }\n \n-    fn visit_body(&mut self, body: &'tcx hir::Body<'tcx>) {\n-        intravisit::walk_body(self, body);\n-\n-        for param in body.params {\n-            self.check_irrefutable(&param.pat, \"function argument\", None);\n-            self.check_patterns(false, &param.pat);\n-        }\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        intravisit::walk_param(self, param);\n+        self.check_irrefutable(&param.pat, \"function argument\", None);\n+        self.check_patterns(false, &param.pat);\n     }\n }\n \n@@ -123,6 +119,25 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         if !self.tcx.features().bindings_after_at {\n             check_legality_of_bindings_in_at_patterns(self, pat);\n         }\n+        check_for_bindings_named_same_as_variants(self, pat);\n+    }\n+\n+    fn lower_pattern<'p>(\n+        &self,\n+        cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+        pat: &'tcx hir::Pat<'tcx>,\n+        have_errors: &mut bool,\n+    ) -> (&'p super::Pat<'tcx>, Ty<'tcx>) {\n+        let mut patcx = PatCtxt::new(self.tcx, self.param_env, self.tables);\n+        patcx.include_lint_checks();\n+        let pattern = patcx.lower_pattern(pat);\n+        let pattern_ty = pattern.ty;\n+        let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n+        if !patcx.errors.is_empty() {\n+            *have_errors = true;\n+            patcx.report_inlining_errors(pat.span);\n+        }\n+        (pattern, pattern_ty)\n     }\n \n     fn check_match(\n@@ -132,11 +147,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         source: hir::MatchSource,\n     ) {\n         for arm in arms {\n-            // First, check legality of move bindings.\n+            // Check the arm for some things unrelated to exhaustiveness.\n             self.check_patterns(arm.guard.is_some(), &arm.pat);\n-\n-            // Second, perform some lints.\n-            check_for_bindings_named_same_as_variants(self, &arm.pat);\n         }\n \n         let module = self.tcx.hir().get_module_parent(scrut.hir_id);\n@@ -145,16 +157,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n             let inlined_arms: Vec<_> = arms\n                 .iter()\n-                .map(|arm| {\n-                    let mut patcx = PatCtxt::new(self.tcx, self.param_env, self.tables);\n-                    patcx.include_lint_checks();\n-                    let pattern = patcx.lower_pattern(&arm.pat);\n-                    let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n-                    if !patcx.errors.is_empty() {\n-                        patcx.report_inlining_errors(arm.pat.span);\n-                        have_errors = true;\n-                    }\n-                    (pattern, &*arm.pat, arm.guard.is_some())\n+                .map(|hir::Arm { pat, guard, .. }| {\n+                    (self.lower_pattern(cx, pat, &mut have_errors).0, pat.hir_id, guard.is_some())\n                 })\n                 .collect();\n \n@@ -178,11 +182,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let module = self.tcx.hir().get_module_parent(pat.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n-            let mut patcx = PatCtxt::new(self.tcx, self.param_env, self.tables);\n-            patcx.include_lint_checks();\n-            let pattern = patcx.lower_pattern(pat);\n-            let pattern_ty = pattern.ty;\n-            let pattern = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n+            let (pattern, pattern_ty) = self.lower_pattern(cx, pat, &mut false);\n             let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(pattern)].into_iter().collect();\n \n             let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {\n@@ -285,7 +285,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                         let ty_path = cx.tcx.def_path_str(edef.did);\n                         cx.tcx\n                             .struct_span_lint_hir(\n-                                lint::builtin::BINDINGS_WITH_VARIANT_NAME,\n+                                BINDINGS_WITH_VARIANT_NAME,\n                                 p.hir_id,\n                                 p.span,\n                                 &format!(\n@@ -310,79 +310,63 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n }\n \n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n-fn pat_is_catchall(pat: &Pat<'_>) -> bool {\n-    match pat.kind {\n-        hir::PatKind::Binding(.., None) => true,\n-        hir::PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n-        hir::PatKind::Ref(ref s, _) => pat_is_catchall(s),\n-        hir::PatKind::Tuple(ref v, _) => v.iter().all(|p| pat_is_catchall(&p)),\n+fn pat_is_catchall(pat: &super::Pat<'_>) -> bool {\n+    use super::PatKind::*;\n+    match &*pat.kind {\n+        Binding { subpattern: None, .. } => true,\n+        Binding { subpattern: Some(s), .. } | Deref { subpattern: s } => pat_is_catchall(s),\n+        Leaf { subpatterns: s } => s.iter().all(|p| pat_is_catchall(&p.pattern)),\n         _ => false,\n     }\n }\n \n+fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<Span>) {\n+    let mut err = tcx.struct_span_lint_hir(UNREACHABLE_PATTERNS, id, span, \"unreachable pattern\");\n+    if let Some(catchall) = catchall {\n+        // We had a catchall pattern, hint at that.\n+        err.span_label(span, \"unreachable pattern\");\n+        err.span_label(catchall, \"matches any value\");\n+    }\n+    err.emit();\n+}\n+\n+fn irrefutable_let_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, source: hir::MatchSource) {\n+    let msg = match source {\n+        hir::MatchSource::IfLetDesugar { .. } => \"irrefutable if-let pattern\",\n+        hir::MatchSource::WhileLetDesugar => \"irrefutable while-let pattern\",\n+        _ => bug!(),\n+    };\n+    tcx.lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, msg);\n+}\n+\n /// Check for unreachable patterns.\n fn check_arms<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-    arms: &[(&'p super::Pat<'tcx>, &hir::Pat<'_>, bool)],\n+    arms: &[(&'p super::Pat<'tcx>, HirId, bool)],\n     source: hir::MatchSource,\n ) -> Matrix<'p, 'tcx> {\n     let mut seen = Matrix::empty();\n     let mut catchall = None;\n-    for (arm_index, (pat, hir_pat, has_guard)) in arms.iter().enumerate() {\n+    for (arm_index, (pat, id, has_guard)) in arms.iter().copied().enumerate() {\n         let v = PatStack::from_pattern(pat);\n-\n-        match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id, true) {\n+        match is_useful(cx, &seen, &v, LeaveOutWitness, id, true) {\n             NotUseful => {\n                 match source {\n                     hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => bug!(),\n \n                     hir::MatchSource::IfLetDesugar { .. } | hir::MatchSource::WhileLetDesugar => {\n-                        // check which arm we're on.\n+                        // Check which arm we're on.\n                         match arm_index {\n                             // The arm with the user-specified pattern.\n-                            0 => {\n-                                cx.tcx.lint_hir(\n-                                    lint::builtin::UNREACHABLE_PATTERNS,\n-                                    hir_pat.hir_id,\n-                                    pat.span,\n-                                    \"unreachable pattern\",\n-                                );\n-                            }\n+                            0 => unreachable_pattern(cx.tcx, pat.span, id, None),\n                             // The arm with the wildcard pattern.\n-                            1 => {\n-                                let msg = match source {\n-                                    hir::MatchSource::IfLetDesugar { .. } => {\n-                                        \"irrefutable if-let pattern\"\n-                                    }\n-                                    hir::MatchSource::WhileLetDesugar => {\n-                                        \"irrefutable while-let pattern\"\n-                                    }\n-                                    _ => bug!(),\n-                                };\n-                                cx.tcx.lint_hir(\n-                                    lint::builtin::IRREFUTABLE_LET_PATTERNS,\n-                                    hir_pat.hir_id,\n-                                    pat.span,\n-                                    msg,\n-                                );\n-                            }\n+                            1 => irrefutable_let_pattern(cx.tcx, pat.span, id, source),\n                             _ => bug!(),\n                         }\n                     }\n \n                     hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n-                        let mut err = cx.tcx.struct_span_lint_hir(\n-                            lint::builtin::UNREACHABLE_PATTERNS,\n-                            hir_pat.hir_id,\n-                            pat.span,\n-                            \"unreachable pattern\",\n-                        );\n-                        // if we had a catchall pattern, hint at that\n-                        if let Some(catchall) = catchall {\n-                            err.span_label(pat.span, \"unreachable pattern\");\n-                            err.span_label(catchall, \"matches any value\");\n-                        }\n-                        err.emit();\n+                        unreachable_pattern(cx.tcx, pat.span, id, catchall);\n                     }\n \n                     // Unreachable patterns in try and await expressions occur when one of\n@@ -392,19 +376,14 @@ fn check_arms<'p, 'tcx>(\n             }\n             Useful(unreachable_subpatterns) => {\n                 for pat in unreachable_subpatterns {\n-                    cx.tcx.lint_hir(\n-                        lint::builtin::UNREACHABLE_PATTERNS,\n-                        hir_pat.hir_id,\n-                        pat.span,\n-                        \"unreachable pattern\",\n-                    );\n+                    unreachable_pattern(cx.tcx, pat.span, id, None);\n                 }\n             }\n             UsefulWithWitness(_) => bug!(),\n         }\n         if !has_guard {\n             seen.push(v);\n-            if catchall.is_none() && pat_is_catchall(hir_pat) {\n+            if catchall.is_none() && pat_is_catchall(pat) {\n                 catchall = Some(pat.span);\n             }\n         }"}, {"sha": "a98b4f2fd4450a1789f8526207d9921db994a07d", "filename": "src/test/ui/lint/lint-uppercase-variables.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.rs?ref=58504823f580d650a2ffc97db76bda592f6a26fd", "patch": "@@ -25,6 +25,16 @@ fn main() {\n //~^^^ WARN unused variable: `Foo`\n     }\n \n+    let Foo = foo::Foo::Foo;\n+    //~^ ERROR variable `Foo` should have a snake case name\n+    //~^^ WARN `Foo` is named the same as one of the variants of the type `foo::Foo`\n+    //~^^^ WARN unused variable: `Foo`\n+\n+    fn in_param(Foo: foo::Foo) {}\n+    //~^ ERROR variable `Foo` should have a snake case name\n+    //~^^ WARN `Foo` is named the same as one of the variants of the type `foo::Foo`\n+    //~^^^ WARN unused variable: `Foo`\n+\n     test(1);\n \n     let _ = Something { X: 0 };"}, {"sha": "a38f3e7626bca477f52863940ad277618c301646", "filename": "src/test/ui/lint/lint-uppercase-variables.stderr", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.stderr?ref=58504823f580d650a2ffc97db76bda592f6a26fd", "patch": "@@ -6,6 +6,18 @@ LL |         Foo => {}\n    |\n    = note: `#[warn(bindings_with_variant_name)]` on by default\n \n+warning[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `foo::Foo`\n+  --> $DIR/lint-uppercase-variables.rs:28:9\n+   |\n+LL |     let Foo = foo::Foo::Foo;\n+   |         ^^^ help: to match on the variant, qualify the path: `foo::Foo::Foo`\n+\n+warning[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `foo::Foo`\n+  --> $DIR/lint-uppercase-variables.rs:33:17\n+   |\n+LL |     fn in_param(Foo: foo::Foo) {}\n+   |                 ^^^ help: to match on the variant, qualify the path: `foo::Foo::Foo`\n+\n warning: unused variable: `Foo`\n   --> $DIR/lint-uppercase-variables.rs:22:9\n    |\n@@ -19,6 +31,18 @@ LL | #![warn(unused)]\n    |         ^^^^^^\n    = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n \n+warning: unused variable: `Foo`\n+  --> $DIR/lint-uppercase-variables.rs:28:9\n+   |\n+LL |     let Foo = foo::Foo::Foo;\n+   |         ^^^ help: consider prefixing with an underscore: `_Foo`\n+\n+warning: unused variable: `Foo`\n+  --> $DIR/lint-uppercase-variables.rs:33:17\n+   |\n+LL |     fn in_param(Foo: foo::Foo) {}\n+   |                 ^^^ help: consider prefixing with an underscore: `_Foo`\n+\n error: structure field `X` should have a snake case name\n   --> $DIR/lint-uppercase-variables.rs:10:5\n    |\n@@ -49,6 +73,18 @@ error: variable `Foo` should have a snake case name\n LL |         Foo => {}\n    |         ^^^ help: convert the identifier to snake case (notice the capitalization): `foo`\n \n-error: aborting due to 4 previous errors\n+error: variable `Foo` should have a snake case name\n+  --> $DIR/lint-uppercase-variables.rs:28:9\n+   |\n+LL |     let Foo = foo::Foo::Foo;\n+   |         ^^^ help: convert the identifier to snake case (notice the capitalization): `foo`\n+\n+error: variable `Foo` should have a snake case name\n+  --> $DIR/lint-uppercase-variables.rs:33:17\n+   |\n+LL |     fn in_param(Foo: foo::Foo) {}\n+   |                 ^^^ help: convert the identifier to snake case (notice the capitalization): `foo`\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0170`."}, {"sha": "95ead6b5d4a611589fa90f7bcb5377f598b81555", "filename": "src/test/ui/pattern/issue-68393-let-pat-assoc-constant.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.rs?ref=58504823f580d650a2ffc97db76bda592f6a26fd", "patch": "@@ -0,0 +1,26 @@\n+pub enum EFoo {\n+    A,\n+}\n+\n+pub trait Foo {\n+    const X: EFoo;\n+}\n+\n+struct Abc;\n+\n+impl Foo for Abc {\n+    const X: EFoo = EFoo::A;\n+}\n+\n+struct Def;\n+impl Foo for Def {\n+    const X: EFoo = EFoo::A;\n+}\n+\n+pub fn test<A: Foo, B: Foo>(arg: EFoo, A::X: EFoo) {\n+    //~^ ERROR associated consts cannot be referenced in patterns\n+    let A::X = arg;\n+    //~^ ERROR associated consts cannot be referenced in patterns\n+}\n+\n+fn main() {}"}, {"sha": "54ecc24981f80943769fdd3da5ed082c8a89c081", "filename": "src/test/ui/pattern/issue-68393-let-pat-assoc-constant.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.stderr?ref=58504823f580d650a2ffc97db76bda592f6a26fd", "patch": "@@ -0,0 +1,15 @@\n+error[E0158]: associated consts cannot be referenced in patterns\n+  --> $DIR/issue-68393-let-pat-assoc-constant.rs:20:40\n+   |\n+LL | pub fn test<A: Foo, B: Foo>(arg: EFoo, A::X: EFoo) {\n+   |                                        ^^^^\n+\n+error[E0158]: associated consts cannot be referenced in patterns\n+  --> $DIR/issue-68393-let-pat-assoc-constant.rs:22:9\n+   |\n+LL |     let A::X = arg;\n+   |         ^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0158`."}, {"sha": "f10a7f2d8a54f0be593e3b43c55d3e03215d2da3", "filename": "src/test/ui/pattern/issue-68394-let-pat-runtime-value.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Fpattern%2Fissue-68394-let-pat-runtime-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Fpattern%2Fissue-68394-let-pat-runtime-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-68394-let-pat-runtime-value.rs?ref=58504823f580d650a2ffc97db76bda592f6a26fd", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let x = 255u8;\n+    let 0u8..=x = 0;\n+    //~^ ERROR runtime values cannot be referenced in patterns\n+}"}, {"sha": "c1508bd71ff7a6c1f6cdc8d205fb258b58cdb954", "filename": "src/test/ui/pattern/issue-68394-let-pat-runtime-value.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Fpattern%2Fissue-68394-let-pat-runtime-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Fpattern%2Fissue-68394-let-pat-runtime-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-68394-let-pat-runtime-value.stderr?ref=58504823f580d650a2ffc97db76bda592f6a26fd", "patch": "@@ -0,0 +1,9 @@\n+error[E0080]: runtime values cannot be referenced in patterns\n+  --> $DIR/issue-68394-let-pat-runtime-value.rs:3:15\n+   |\n+LL |     let 0u8..=x = 0;\n+   |               ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "afc599a4b22b6a0efbedcaa4adeeb4f12fd700d2", "filename": "src/test/ui/pattern/issue-68396-let-float-bug.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.rs?ref=58504823f580d650a2ffc97db76bda592f6a26fd", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let 1234567890123456789012345678901234567890e-340: f64 = 0.0;\n+    //~^ ERROR could not evaluate float literal (see issue #31407)\n+\n+    fn param(1234567890123456789012345678901234567890e-340: f64) {}\n+    //~^ ERROR could not evaluate float literal (see issue #31407)\n+}"}, {"sha": "618aa4b5021f10e3aa053633a3403056a465c0a1", "filename": "src/test/ui/pattern/issue-68396-let-float-bug.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.stderr?ref=58504823f580d650a2ffc97db76bda592f6a26fd", "patch": "@@ -0,0 +1,15 @@\n+error[E0080]: could not evaluate float literal (see issue #31407)\n+  --> $DIR/issue-68396-let-float-bug.rs:2:9\n+   |\n+LL |     let 1234567890123456789012345678901234567890e-340: f64 = 0.0;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: could not evaluate float literal (see issue #31407)\n+  --> $DIR/issue-68396-let-float-bug.rs:5:14\n+   |\n+LL |     fn param(1234567890123456789012345678901234567890e-340: f64) {}\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "0115fc081a9701f06ce37608998fb3b15547e26c", "filename": "src/test/ui/pattern/usefulness/struct-pattern-match-useless.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-pattern-match-useless.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58504823f580d650a2ffc97db76bda592f6a26fd/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-pattern-match-useless.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-pattern-match-useless.stderr?ref=58504823f580d650a2ffc97db76bda592f6a26fd", "patch": "@@ -1,8 +1,10 @@\n error: unreachable pattern\n   --> $DIR/struct-pattern-match-useless.rs:12:9\n    |\n+LL |         Foo { x: _x, y: _y } => (),\n+   |         -------------------- matches any value\n LL |         Foo { .. } => ()\n-   |         ^^^^^^^^^^\n+   |         ^^^^^^^^^^ unreachable pattern\n    |\n note: lint level defined here\n   --> $DIR/struct-pattern-match-useless.rs:1:9"}]}