{"sha": "b634ba41e0439cbbb89b12a3d340c8463b35b93e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MzRiYTQxZTA0MzljYmJiODliMTJhM2QzNDBjODQ2M2IzNWI5M2U=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-10-29T10:04:42Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-11-01T18:57:08Z"}, "message": "Get trait assoc item resolution mostly working", "tree": {"sha": "4e4b08e6ca6a89714d372d37bdc578393219d8b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e4b08e6ca6a89714d372d37bdc578393219d8b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b634ba41e0439cbbb89b12a3d340c8463b35b93e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b634ba41e0439cbbb89b12a3d340c8463b35b93e", "html_url": "https://github.com/rust-lang/rust/commit/b634ba41e0439cbbb89b12a3d340c8463b35b93e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b634ba41e0439cbbb89b12a3d340c8463b35b93e/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed5212e1ac71e959d802a9a7ad28d06c8b18e022", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed5212e1ac71e959d802a9a7ad28d06c8b18e022", "html_url": "https://github.com/rust-lang/rust/commit/ed5212e1ac71e959d802a9a7ad28d06c8b18e022"}], "stats": {"total": 277, "additions": 261, "deletions": 16}, "files": [{"sha": "e39f06e687985279d705c5cb40688a9e37a79208", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b634ba41e0439cbbb89b12a3d340c8463b35b93e/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b634ba41e0439cbbb89b12a3d340c8463b35b93e/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=b634ba41e0439cbbb89b12a3d340c8463b35b93e", "patch": "@@ -385,13 +385,21 @@ impl SubstsBuilder {\n         self.param_count - self.vec.len()\n     }\n \n-    pub fn fill_with_bound_vars(mut self, starting_from: u32) -> Self {\n-        self.vec.extend((starting_from..starting_from + self.remaining() as u32).map(Ty::Bound));\n-        self\n+    pub fn fill_with_bound_vars(self, starting_from: u32) -> Self {\n+        self.fill((starting_from..).map(Ty::Bound))\n+    }\n+\n+    pub fn fill_with_params(self) -> Self {\n+        let start = self.vec.len() as u32;\n+        self.fill((start..).map(|idx| Ty::Param { idx, name: Name::missing() }))\n+    }\n+\n+    pub fn fill_with_unknown(self) -> Self {\n+        self.fill(iter::repeat(Ty::Unknown))\n     }\n \n-    pub fn fill_with_unknown(mut self) -> Self {\n-        self.vec.extend(iter::repeat(Ty::Unknown).take(self.remaining()));\n+    pub fn fill(mut self, filler: impl Iterator<Item = Ty>) -> Self {\n+        self.vec.extend(filler.take(self.remaining()));\n         self\n     }\n "}, {"sha": "885588174817669892ba238a5283e9113c0feef4", "filename": "crates/ra_hir/src/ty/infer/path.rs", "status": "modified", "additions": 98, "deletions": 8, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b634ba41e0439cbbb89b12a3d340c8463b35b93e/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b634ba41e0439cbbb89b12a3d340c8463b35b93e/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs?ref=b634ba41e0439cbbb89b12a3d340c8463b35b93e", "patch": "@@ -6,9 +6,11 @@ use super::{ExprOrPatId, InferenceContext, TraitRef};\n use crate::{\n     db::HirDatabase,\n     resolve::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n+    ty::{lower, traits::TraitEnvironment, Canonical},\n     ty::{Substs, Ty, TypableDef, TypeWalk},\n-    AssocItem, HasGenericParams, Namespace, Path,\n+    AssocItem, HasGenericParams, Name, Namespace, Path, Trait,\n };\n+use std::sync::Arc;\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     pub(super) fn infer_path(\n@@ -39,7 +41,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let ty = Ty::from_type_relative_path(self.db, resolver, ty, remaining_segments_for_ty);\n             self.resolve_ty_assoc_item(\n                 ty,\n-                path.segments.last().expect(\"path had at least one segment\"),\n+                &path.segments.last().expect(\"path had at least one segment\").name,\n                 id,\n             )?\n         } else {\n@@ -125,7 +127,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let segment =\n                     remaining_segments.last().expect(\"there should be at least one segment here\");\n \n-                self.resolve_ty_assoc_item(ty, segment, id)\n+                self.resolve_ty_assoc_item(ty, &segment.name, id)\n             }\n         }\n     }\n@@ -162,7 +164,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n         let substs = Substs::build_for_def(self.db, item)\n             .use_parent_substs(&trait_ref.substs)\n-            .fill_with_unknown()\n+            .fill_with_params()\n             .build();\n \n         self.write_assoc_resolution(id, item);\n@@ -172,28 +174,37 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_ty_assoc_item(\n         &mut self,\n         ty: Ty,\n-        segment: &PathSegment,\n+        name: &Name,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n         if let Ty::Unknown = ty {\n             return None;\n         }\n \n+        self.find_inherent_assoc_candidate(ty.clone(), name, id)\n+            .or_else(|| self.find_trait_assoc_candidate(ty.clone(), name, id))\n+    }\n+\n+    fn find_inherent_assoc_candidate(\n+        &mut self,\n+        ty: Ty,\n+        name: &Name,\n+        id: ExprOrPatId,\n+    ) -> Option<(ValueNs, Option<Substs>)> {\n         let krate = self.resolver.krate()?;\n \n         // Find impl\n-        // FIXME: consider trait candidates\n         let item = ty.clone().iterate_impl_items(self.db, krate, |item| match item {\n             AssocItem::Function(func) => {\n-                if segment.name == func.name(self.db) {\n+                if *name == func.name(self.db) {\n                     Some(AssocItem::Function(func))\n                 } else {\n                     None\n                 }\n             }\n \n             AssocItem::Const(konst) => {\n-                if konst.name(self.db).map_or(false, |n| n == segment.name) {\n+                if konst.name(self.db).map_or(false, |n| n == *name) {\n                     Some(AssocItem::Const(konst))\n                 } else {\n                     None\n@@ -212,6 +223,65 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         Some((def, substs))\n     }\n \n+    fn find_trait_assoc_candidate(\n+        &mut self,\n+        ty: Ty,\n+        name: &Name,\n+        _id: ExprOrPatId,\n+    ) -> Option<(ValueNs, Option<Substs>)> {\n+        let krate = self.resolver.krate()?;\n+\n+        let canonical_ty = self.canonicalizer().canonicalize_ty(ty.clone());\n+\n+        let env = lower::trait_env(self.db, &self.resolver);\n+        // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n+        let traits_from_env = env\n+            .trait_predicates_for_self_ty(&ty)\n+            .map(|tr| tr.trait_)\n+            .flat_map(|t| t.all_super_traits(self.db));\n+        let traits = traits_from_env.chain(self.resolver.traits_in_scope(self.db));\n+\n+        'traits: for t in traits {\n+            let data = t.trait_data(self.db);\n+            let mut known_implemented = false;\n+            for item in data.items() {\n+                if let AssocItem::Function(f) = *item {\n+                    if f.name(self.db) == *name {\n+                        if !known_implemented {\n+                            let goal = generic_implements_goal(\n+                                self.db,\n+                                env.clone(),\n+                                t,\n+                                canonical_ty.value.clone(),\n+                            );\n+                            if self.db.trait_solve(krate, goal).is_none() {\n+                                continue 'traits;\n+                            }\n+                        }\n+                        known_implemented = true;\n+\n+                        // we're picking this method\n+                        let trait_substs = Substs::build_for_def(self.db, t)\n+                            .push(ty.clone())\n+                            .fill(std::iter::repeat_with(|| self.new_type_var()))\n+                            .build();\n+                        let substs = Substs::build_for_def(self.db, f)\n+                            .use_parent_substs(&trait_substs)\n+                            .fill_with_params()\n+                            .build();\n+                        self.obligations.push(super::Obligation::Trait(TraitRef {\n+                            trait_: t,\n+                            substs: trait_substs,\n+                        }));\n+                        return Some((ValueNs::Function(f), Some(substs)));\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn find_self_types(&self, def: &ValueNs, actual_def_ty: Ty) -> Option<Substs> {\n         if let ValueNs::Function(func) = def {\n             // We only do the infer if parent has generic params\n@@ -242,3 +312,23 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n }\n+\n+// TODO remove duplication\n+/// This creates Substs for a trait with the given Self type and type variables\n+/// for all other parameters, to query Chalk with it.\n+fn generic_implements_goal(\n+    db: &impl HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    trait_: Trait,\n+    self_ty: Canonical<Ty>,\n+) -> Canonical<super::InEnvironment<super::Obligation>> {\n+    let num_vars = self_ty.num_vars;\n+    let substs = super::Substs::build_for_def(db, trait_)\n+        .push(self_ty.value)\n+        .fill_with_bound_vars(num_vars as u32)\n+        .build();\n+    let num_vars = substs.len() - 1 + self_ty.num_vars;\n+    let trait_ref = TraitRef { trait_, substs };\n+    let obligation = super::Obligation::Trait(trait_ref);\n+    Canonical { num_vars, value: super::InEnvironment::new(env, obligation) }\n+}"}, {"sha": "7183b205c467ccfab6300f211ac0966c62459b51", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 150, "deletions": 3, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/b634ba41e0439cbbb89b12a3d340c8463b35b93e/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b634ba41e0439cbbb89b12a3d340c8463b35b93e/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=b634ba41e0439cbbb89b12a3d340c8463b35b93e", "patch": "@@ -2782,16 +2782,163 @@ fn test() {\n     [97; 99) 's1': S\n     [105; 121) 'Defaul...efault': fn default<S>() -> Self\n     [105; 123) 'Defaul...ault()': S\n-    [133; 135) 's2': {unknown}\n-    [138; 148) 'S::default': {unknown}\n-    [138; 150) 'S::default()': {unknown}\n+    [133; 135) 's2': S\n+    [138; 148) 'S::default': fn default<S>() -> Self\n+    [138; 150) 'S::default()': S\n     [160; 162) 's3': S\n     [165; 188) '<S as ...efault': fn default<S>() -> Self\n     [165; 190) '<S as ...ault()': S\n     \"###\n     );\n }\n \n+#[test]\n+fn infer_trait_assoc_method_generics_1() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make() -> T;\n+}\n+struct S;\n+impl Trait<u32> for S {}\n+struct G<T>;\n+impl<T> Trait<T> for G<T> {}\n+fn test() {\n+    let a = S::make();\n+    let b = G::<u64>::make();\n+    let c: f64 = G::make();\n+}\n+\"#),\n+        @r###\"\n+    [127; 211) '{     ...e(); }': ()\n+    [137; 138) 'a': u32\n+    [141; 148) 'S::make': fn make<S, u32>() -> T\n+    [141; 150) 'S::make()': u32\n+    [160; 161) 'b': u64\n+    [164; 178) 'G::<u64>::make': fn make<G<u64>, u64>() -> T\n+    [164; 180) 'G::<u6...make()': u64\n+    [190; 191) 'c': f64\n+    [199; 206) 'G::make': fn make<G<f64>, f64>() -> T\n+    [199; 208) 'G::make()': f64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_2() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make<U>() -> (T, U);\n+}\n+struct S;\n+impl Trait<u32> for S {}\n+struct G<T>;\n+impl<T> Trait<T> for G<T> {}\n+fn test() {\n+    let a = S::make::<i64>();\n+    let b: (_, i64) = S::make();\n+    let c = G::<u32>::make::<i64>();\n+    let d: (u32, _) = G::make::<i64>();\n+    let e: (u32, i64) = G::make();\n+}\n+\"#),\n+        @r###\"\n+    [135; 313) '{     ...e(); }': ()\n+    [145; 146) 'a': (u32, i64)\n+    [149; 163) 'S::make::<i64>': fn make<S, u32, i64>() -> (T, U)\n+    [149; 165) 'S::mak...i64>()': (u32, i64)\n+    [175; 176) 'b': (u32, i64)\n+    [189; 196) 'S::make': fn make<S, u32, i64>() -> (T, U)\n+    [189; 198) 'S::make()': (u32, i64)\n+    [208; 209) 'c': (u32, i64)\n+    [212; 233) 'G::<u3...:<i64>': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [212; 235) 'G::<u3...i64>()': (u32, i64)\n+    [245; 246) 'd': (u32, i64)\n+    [259; 273) 'G::make::<i64>': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [259; 275) 'G::mak...i64>()': (u32, i64)\n+    [285; 286) 'e': (u32, i64)\n+    [301; 308) 'G::make': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [301; 310) 'G::make()': (u32, i64)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_3() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make() -> (Self, T);\n+}\n+struct S<T>;\n+impl Trait<i64> for S<i32> {}\n+fn test() {\n+    let a = S::make();\n+}\n+\"#),\n+        @r###\"\n+    [101; 127) '{     ...e(); }': ()\n+    [111; 112) 'a': {unknown}\n+    [115; 122) 'S::make': {unknown}\n+    [115; 124) 'S::make()': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_4() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make() -> (Self, T);\n+}\n+struct S<T>;\n+impl Trait<i64> for S<u64> {}\n+impl Trait<i32> for S<u32> {}\n+fn test() {\n+    let a: (Self<i64>, _) = S::make();\n+    let b: (_, u32) = S::make();\n+}\n+\"#),\n+        @r###\"\n+    [131; 206) '{     ...e(); }': ()\n+    [141; 142) 'a': ({unknown}, {unknown})\n+    [161; 168) 'S::make': {unknown}\n+    [161; 170) 'S::make()': ({unknown}, {unknown})\n+    [180; 181) 'b': ({unknown}, u32)\n+    [194; 201) 'S::make': {unknown}\n+    [194; 203) 'S::make()': ({unknown}, u32)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_5() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make<U>() -> (Self, T, U);\n+}\n+struct S<T>;\n+impl Trait<i64> for S<u64> {}\n+fn test() {\n+    let a = <S as Trait<i64>>::make::<u8>();\n+    let b: (S<u64>, _, _) = Trait::<i64>::make::<u8>();\n+}\n+\"#),\n+        @r###\"\n+    [107; 211) '{     ...>(); }': ()\n+    [117; 118) 'a': (S<u64>, i64, u8)\n+    [121; 150) '<S as ...::<u8>': fn make<S<u64>, i64, u8>() -> (Self, T, U)\n+    [121; 152) '<S as ...<u8>()': (S<u64>, i64, u8)\n+    [162; 163) 'b': (S<u64>, i64, u8)\n+    [182; 206) 'Trait:...::<u8>': fn make<S<u64>, i64, u8>() -> (Self, T, U)\n+    [182; 208) 'Trait:...<u8>()': (S<u64>, i64, u8)\n+    \"###\n+    );\n+}\n+\n #[test]\n fn infer_from_bound_1() {\n     assert_snapshot!("}]}