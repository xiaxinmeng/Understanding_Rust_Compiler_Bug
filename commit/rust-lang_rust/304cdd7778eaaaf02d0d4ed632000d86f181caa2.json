{"sha": "304cdd7778eaaaf02d0d4ed632000d86f181caa2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwNGNkZDc3NzhlYWFhZjAyZDBkNGVkNjMyMDAwZDg2ZjE4MWNhYTI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-08T20:20:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-08T20:20:09Z"}, "message": "Merge #8770\n\n8770: feat: add \"mentoring instructions\" test for pull up assist r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b6fc312163e09bd3eef55b9adaf48cb1ccffbe26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6fc312163e09bd3eef55b9adaf48cb1ccffbe26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/304cdd7778eaaaf02d0d4ed632000d86f181caa2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJglvJ5CRBK7hj4Ov3rIwAAm9YIAJSBIjDzDkXjs2GDv/WbL8oF\ndmD2Cn6IO78soSWDRU2+HCw8d00XCOXfQ5SgRV++mnVwrmFta38f/PBsrurgK6LJ\npNkegilnfB+T2kth91BwQ1AuHxTJR9eUaaOnVGzeAuKxVa53rjYmxYq5jAmHp97Y\nlso1uwkUy/ttxl/YJyrHCt43NSKQj0QRDcgQ3hMKmf2kAc2yPvsMDNmagZmr3A4F\n0c/AStDMmrsS8RRpg+W5AAJwAAMn5Di8HlkkqyTervvO+kAIzIbkcmnf6HwgTh/w\nN/3bI2jDOz/QNdTyNjpZWCZqmEFzQeizgRT+/32/RtCxMOMZOtJL/iHqbq4xOsc=\n=EBDm\n-----END PGP SIGNATURE-----\n", "payload": "tree b6fc312163e09bd3eef55b9adaf48cb1ccffbe26\nparent 96c5df9b171730ad69e130e074584684cee35014\nparent 1ee12b5db17f6f4396af6bfd6ba2528de7f86c78\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1620505209 +0000\ncommitter GitHub <noreply@github.com> 1620505209 +0000\n\nMerge #8770\n\n8770: feat: add \"mentoring instructions\" test for pull up assist r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/304cdd7778eaaaf02d0d4ed632000d86f181caa2", "html_url": "https://github.com/rust-lang/rust/commit/304cdd7778eaaaf02d0d4ed632000d86f181caa2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/304cdd7778eaaaf02d0d4ed632000d86f181caa2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96c5df9b171730ad69e130e074584684cee35014", "url": "https://api.github.com/repos/rust-lang/rust/commits/96c5df9b171730ad69e130e074584684cee35014", "html_url": "https://github.com/rust-lang/rust/commit/96c5df9b171730ad69e130e074584684cee35014"}, {"sha": "1ee12b5db17f6f4396af6bfd6ba2528de7f86c78", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ee12b5db17f6f4396af6bfd6ba2528de7f86c78", "html_url": "https://github.com/rust-lang/rust/commit/1ee12b5db17f6f4396af6bfd6ba2528de7f86c78"}], "stats": {"total": 201, "additions": 127, "deletions": 74}, "files": [{"sha": "28d14b9c3f14e9c4091a0efeaa25c37daaa97de1", "filename": "crates/ide_assists/src/handlers/pull_assignment_up.rs", "status": "modified", "additions": 124, "deletions": 74, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/304cdd7778eaaaf02d0d4ed632000d86f181caa2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "raw_url": "https://github.com/rust-lang/rust/raw/304cdd7778eaaaf02d0d4ed632000d86f181caa2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs?ref=304cdd7778eaaaf02d0d4ed632000d86f181caa2", "patch": "@@ -1,6 +1,6 @@\n use syntax::{\n-    ast::{self, edit::AstNodeEdit, make},\n-    AstNode,\n+    ast::{self, make},\n+    ted, AstNode,\n };\n \n use crate::{\n@@ -37,103 +37,101 @@ use crate::{\n // ```\n pub(crate) fn pull_assignment_up(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let assign_expr = ctx.find_node_at_offset::<ast::BinExpr>()?;\n-    let name_expr = if assign_expr.op_kind()? == ast::BinOp::Assignment {\n-        assign_expr.lhs()?\n-    } else {\n+\n+    let op_kind = assign_expr.op_kind()?;\n+    if op_kind != ast::BinOp::Assignment {\n+        cov_mark::hit!(test_cant_pull_non_assignments);\n         return None;\n+    }\n+\n+    let mut collector = AssignmentsCollector {\n+        sema: &ctx.sema,\n+        common_lhs: assign_expr.lhs()?,\n+        assignments: Vec::new(),\n     };\n \n-    let (old_stmt, new_stmt) = if let Some(if_expr) = ctx.find_node_at_offset::<ast::IfExpr>() {\n-        (\n-            ast::Expr::cast(if_expr.syntax().to_owned())?,\n-            exprify_if(&if_expr, &ctx.sema, &name_expr)?.indent(if_expr.indent_level()),\n-        )\n+    let tgt: ast::Expr = if let Some(if_expr) = ctx.find_node_at_offset::<ast::IfExpr>() {\n+        collector.collect_if(&if_expr)?;\n+        if_expr.into()\n     } else if let Some(match_expr) = ctx.find_node_at_offset::<ast::MatchExpr>() {\n-        (\n-            ast::Expr::cast(match_expr.syntax().to_owned())?,\n-            exprify_match(&match_expr, &ctx.sema, &name_expr)?,\n-        )\n+        collector.collect_match(&match_expr)?;\n+        match_expr.into()\n     } else {\n         return None;\n     };\n \n-    let expr_stmt = make::expr_stmt(new_stmt);\n-\n     acc.add(\n         AssistId(\"pull_assignment_up\", AssistKind::RefactorExtract),\n         \"Pull assignment up\",\n-        old_stmt.syntax().text_range(),\n+        tgt.syntax().text_range(),\n         move |edit| {\n-            edit.replace(old_stmt.syntax().text_range(), format!(\"{} = {};\", name_expr, expr_stmt));\n+            let assignments: Vec<_> = collector\n+                .assignments\n+                .into_iter()\n+                .map(|(stmt, rhs)| (edit.make_ast_mut(stmt), rhs.clone_for_update()))\n+                .collect();\n+\n+            let tgt = edit.make_ast_mut(tgt);\n+\n+            for (stmt, rhs) in assignments {\n+                ted::replace(stmt.syntax(), rhs.syntax());\n+            }\n+            let assign_expr = make::expr_assignment(collector.common_lhs, tgt.clone());\n+            let assign_stmt = make::expr_stmt(assign_expr);\n+\n+            ted::replace(tgt.syntax(), assign_stmt.syntax().clone_for_update());\n         },\n     )\n }\n \n-fn exprify_match(\n-    match_expr: &ast::MatchExpr,\n-    sema: &hir::Semantics<ide_db::RootDatabase>,\n-    name: &ast::Expr,\n-) -> Option<ast::Expr> {\n-    let new_arm_list = match_expr\n-        .match_arm_list()?\n-        .arms()\n-        .map(|arm| {\n-            if let ast::Expr::BlockExpr(block) = arm.expr()? {\n-                let new_block = exprify_block(&block, sema, name)?.indent(block.indent_level());\n-                Some(arm.replace_descendant(block, new_block))\n-            } else {\n-                None\n-            }\n-        })\n-        .collect::<Option<Vec<_>>>()?;\n-    let new_arm_list = match_expr\n-        .match_arm_list()?\n-        .replace_descendants(match_expr.match_arm_list()?.arms().zip(new_arm_list));\n-    Some(make::expr_match(match_expr.expr()?, new_arm_list))\n+struct AssignmentsCollector<'a> {\n+    sema: &'a hir::Semantics<'a, ide_db::RootDatabase>,\n+    common_lhs: ast::Expr,\n+    assignments: Vec<(ast::ExprStmt, ast::Expr)>,\n }\n \n-fn exprify_if(\n-    statement: &ast::IfExpr,\n-    sema: &hir::Semantics<ide_db::RootDatabase>,\n-    name: &ast::Expr,\n-) -> Option<ast::Expr> {\n-    let then_branch = exprify_block(&statement.then_branch()?, sema, name)?;\n-    let else_branch = match statement.else_branch()? {\n-        ast::ElseBranch::Block(ref block) => {\n-            ast::ElseBranch::Block(exprify_block(block, sema, name)?)\n-        }\n-        ast::ElseBranch::IfExpr(expr) => {\n-            cov_mark::hit!(test_pull_assignment_up_chained_if);\n-            ast::ElseBranch::IfExpr(ast::IfExpr::cast(\n-                exprify_if(&expr, sema, name)?.syntax().to_owned(),\n-            )?)\n+impl<'a> AssignmentsCollector<'a> {\n+    fn collect_match(&mut self, match_expr: &ast::MatchExpr) -> Option<()> {\n+        for arm in match_expr.match_arm_list()?.arms() {\n+            match arm.expr()? {\n+                ast::Expr::BlockExpr(block) => self.collect_block(&block)?,\n+                _ => return None,\n+            }\n         }\n-    };\n-    Some(make::expr_if(statement.condition()?, then_branch, Some(else_branch)))\n-}\n \n-fn exprify_block(\n-    block: &ast::BlockExpr,\n-    sema: &hir::Semantics<ide_db::RootDatabase>,\n-    name: &ast::Expr,\n-) -> Option<ast::BlockExpr> {\n-    if block.tail_expr().is_some() {\n-        return None;\n+        Some(())\n     }\n+    fn collect_if(&mut self, if_expr: &ast::IfExpr) -> Option<()> {\n+        let then_branch = if_expr.then_branch()?;\n+        self.collect_block(&then_branch)?;\n+\n+        match if_expr.else_branch()? {\n+            ast::ElseBranch::Block(block) => self.collect_block(&block),\n+            ast::ElseBranch::IfExpr(expr) => {\n+                cov_mark::hit!(test_pull_assignment_up_chained_if);\n+                self.collect_if(&expr)\n+            }\n+        }\n+    }\n+    fn collect_block(&mut self, block: &ast::BlockExpr) -> Option<()> {\n+        if block.tail_expr().is_some() {\n+            return None;\n+        }\n \n-    let mut stmts: Vec<_> = block.statements().collect();\n-    let stmt = stmts.pop()?;\n-\n-    if let ast::Stmt::ExprStmt(stmt) = stmt {\n-        if let ast::Expr::BinExpr(expr) = stmt.expr()? {\n-            if expr.op_kind()? == ast::BinOp::Assignment && is_equivalent(sema, &expr.lhs()?, name)\n-            {\n-                // The last statement in the block is an assignment to the name we want\n-                return Some(make::block_expr(stmts, Some(expr.rhs()?)));\n+        let last_stmt = block.statements().last()?;\n+        if let ast::Stmt::ExprStmt(stmt) = last_stmt {\n+            if let ast::Expr::BinExpr(expr) = stmt.expr()? {\n+                if expr.op_kind()? == ast::BinOp::Assignment\n+                    && is_equivalent(self.sema, &expr.lhs()?, &self.common_lhs)\n+                {\n+                    self.assignments.push((stmt, expr.rhs()?));\n+                    return Some(());\n+                }\n             }\n         }\n+\n+        None\n     }\n-    None\n }\n \n fn is_equivalent(\n@@ -242,6 +240,38 @@ fn foo() {\n         );\n     }\n \n+    #[test]\n+    #[ignore]\n+    fn test_pull_assignment_up_assignment_expressions() {\n+        check_assist(\n+            pull_assignment_up,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+\n+    match 1 {\n+        1 => { $0a = 2; },\n+        2 => a = 3,\n+        3 => {\n+            a = 4\n+        }\n+    }\n+}\"#,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+\n+    a = match 1 {\n+        1 => { 2 },\n+        2 => 3,\n+        3 => {\n+            4\n+        }\n+    };\n+}\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_pull_assignment_up_not_last_not_applicable() {\n         check_assist_not_applicable(\n@@ -436,6 +466,26 @@ fn foo() {\n         3\n     };\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_cant_pull_non_assignments() {\n+        cov_mark::check!(test_cant_pull_non_assignments);\n+        check_assist_not_applicable(\n+            pull_assignment_up,\n+            r#\"\n+fn foo() {\n+    let mut a = 1;\n+    let b = &mut a;\n+\n+    if true {\n+        $0*b + 2;\n+    } else {\n+        *b + 3;\n+    }\n+}\n \"#,\n         )\n     }"}, {"sha": "5a6687397236f12924c11f0eccf84255162158f2", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/304cdd7778eaaaf02d0d4ed632000d86f181caa2/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/304cdd7778eaaaf02d0d4ed632000d86f181caa2/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=304cdd7778eaaaf02d0d4ed632000d86f181caa2", "patch": "@@ -275,6 +275,9 @@ pub fn expr_tuple(elements: impl IntoIterator<Item = ast::Expr>) -> ast::Expr {\n     let expr = elements.into_iter().format(\", \");\n     expr_from_text(&format!(\"({})\", expr))\n }\n+pub fn expr_assignment(lhs: ast::Expr, rhs: ast::Expr) -> ast::Expr {\n+    expr_from_text(&format!(\"{} = {}\", lhs, rhs))\n+}\n fn expr_from_text(text: &str) -> ast::Expr {\n     ast_from_text(&format!(\"const C: () = {};\", text))\n }"}]}