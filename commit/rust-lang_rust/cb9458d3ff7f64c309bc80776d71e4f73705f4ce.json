{"sha": "cb9458d3ff7f64c309bc80776d71e4f73705f4ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiOTQ1OGQzZmY3ZjY0YzMwOWJjODA3NzZkNzFlNGY3MzcwNWY0Y2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-04-21T08:52:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-04-21T08:57:14Z"}, "message": "sccs are computed in dependency order\n\nWe don't need the `scc_dependency_order` vector, `all_sccs` is already\nin dependency order.", "tree": {"sha": "50f1e9dc6733e08b6257e039b4185fa60dc33af1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50f1e9dc6733e08b6257e039b4185fa60dc33af1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb9458d3ff7f64c309bc80776d71e4f73705f4ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb9458d3ff7f64c309bc80776d71e4f73705f4ce", "html_url": "https://github.com/rust-lang/rust/commit/cb9458d3ff7f64c309bc80776d71e4f73705f4ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb9458d3ff7f64c309bc80776d71e4f73705f4ce/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7526fec8ae3bbab08e7c4a59f9b4c9e627fbdda", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7526fec8ae3bbab08e7c4a59f9b4c9e627fbdda", "html_url": "https://github.com/rust-lang/rust/commit/c7526fec8ae3bbab08e7c4a59f9b4c9e627fbdda"}], "stats": {"total": 63, "additions": 10, "deletions": 53}, "files": [{"sha": "57eaf56f268f86505a86f67ecb7ec0c4cd73d132", "filename": "src/librustc_data_structures/graph/scc/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb9458d3ff7f64c309bc80776d71e4f73705f4ce/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb9458d3ff7f64c309bc80776d71e4f73705f4ce/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs?ref=cb9458d3ff7f64c309bc80776d71e4f73705f4ce", "patch": "@@ -47,6 +47,11 @@ impl<N: Idx, S: Idx> Sccs<N, S> {\n     }\n \n     /// Returns an iterator over the SCCs in the graph.\n+    ///\n+    /// The SCCs will be iterated in **dependency order** (or **post order**),\n+    /// meaning that if `S1 -> S2`, we will visit `S2` first and `S1` after.\n+    /// This is convenient when the edges represent dependencies: when you visit\n+    /// `S1`, the value for `S2` will already have been computed.\n     pub fn all_sccs(&self) -> impl Iterator<Item = S> {\n         (0..self.scc_data.len()).map(S::new)\n     }"}, {"sha": "09eb1bb2fc482eca729a5e4a115318db2f77c4a5", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 5, "deletions": 53, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cb9458d3ff7f64c309bc80776d71e4f73705f4ce/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb9458d3ff7f64c309bc80776d71e4f73705f4ce/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=cb9458d3ff7f64c309bc80776d71e4f73705f4ce", "patch": "@@ -6,7 +6,6 @@ use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_hir::def_id::DefId;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n@@ -67,12 +66,6 @@ pub struct RegionInferenceContext<'tcx> {\n     /// compute the values of each region.\n     constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n-    /// SCCs in \"dependency order\" (or \"post order\"), meaning that if S1 -> S2,\n-    /// then S2 appears first. If you process the SCCs in this order, then you\n-    /// are always ensured that when you proces a given SCC, all of its\n-    /// successors have been processed.\n-    scc_dependency_order: Vec<ConstraintSccIndex>,\n-\n     /// Reverse of the SCC constraint graph --  i.e., an edge `A -> B` exists if\n     /// `B: A`. This is used to compute the universal regions that are required\n     /// to outlive a given SCC. Computed lazily.\n@@ -283,10 +276,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             scc_values.merge_liveness(scc, region, &liveness_constraints);\n         }\n \n-        let scc_dependency_order = Self::compute_scc_dependency_order(&constraint_sccs);\n-\n-        let scc_universes =\n-            Self::compute_scc_universes(&constraint_sccs, &scc_dependency_order, &definitions);\n+        let scc_universes = Self::compute_scc_universes(&constraint_sccs, &definitions);\n \n         let scc_representatives = Self::compute_scc_representatives(&constraint_sccs, &definitions);\n \n@@ -299,7 +289,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             constraints,\n             constraint_graph,\n             constraint_sccs,\n-            scc_dependency_order,\n             rev_scc_graph: None,\n             member_constraints,\n             member_constraints_applied: Vec::new(),\n@@ -317,43 +306,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         result\n     }\n \n-    /// Returns a vector of all scc-ids in \"dependency\" or \"post order\". See the\n-    /// `scc_dependency_order` field for more details.\n-    fn compute_scc_dependency_order(\n-        constraints_scc: &Sccs<RegionVid, ConstraintSccIndex>,\n-    ) -> Vec<ConstraintSccIndex> {\n-        let mut visited = &mut BitSet::new_empty(constraints_scc.num_sccs());\n-        let mut output = vec![];\n-\n-        for scc in constraints_scc.all_sccs() {\n-            Self::compute_scc_dependency_order_if_new(\n-                constraints_scc,\n-                scc,\n-                &mut visited,\n-                &mut output,\n-            );\n-        }\n-\n-        output\n-    }\n-\n-    fn compute_scc_dependency_order_if_new(\n-        constraints_scc: &Sccs<RegionVid, ConstraintSccIndex>,\n-        index: ConstraintSccIndex,\n-        visited: &mut BitSet<ConstraintSccIndex>,\n-        output: &mut Vec<ConstraintSccIndex>,\n-    ) {\n-        if !visited.insert(index) {\n-            return;\n-        }\n-\n-        for &succ in constraints_scc.successors(index) {\n-            Self::compute_scc_dependency_order_if_new(constraints_scc, succ, visited, output);\n-        }\n-\n-        output.push(index);\n-    }\n-\n     /// Each SCC is the combination of many region variables which\n     /// have been equated. Therefore, we can associate a universe with\n     /// each SCC which is minimum of all the universes of its\n@@ -363,7 +315,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// the minimum, or narrowest, universe.\n     fn compute_scc_universes(\n         constraint_sccs: &Sccs<RegionVid, ConstraintSccIndex>,\n-        scc_dependency_order: &[ConstraintSccIndex],\n         definitions: &IndexVec<RegionVid, RegionDefinition<'tcx>>,\n     ) -> IndexVec<ConstraintSccIndex, ty::UniverseIndex> {\n         let num_sccs = constraint_sccs.num_sccs();\n@@ -420,7 +371,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // constraint lowers the universe of `R1` to `U0`, which in turn\n         // means that the `R1: !1` constraint will (later) cause\n         // `R1` to become `'static`.\n-        for &scc_a in scc_dependency_order {\n+        for scc_a in constraint_sccs.all_sccs() {\n             for &scc_b in constraint_sccs.successors(scc_a) {\n                 let scc_universe_a = scc_universes[scc_a];\n                 let scc_universe_b = scc_universes[scc_b];\n@@ -664,8 +615,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // SCC. For each SCC, we visit its successors and compute\n         // their values, then we union all those values to get our\n         // own.\n-        for i in 0..self.scc_dependency_order.len() {\n-            self.compute_value_for_scc(self.scc_dependency_order[i]);\n+        let constraint_sccs = self.constraint_sccs.clone();\n+        for scc in constraint_sccs.all_sccs() {\n+            self.compute_value_for_scc(scc);\n         }\n \n         // Sort the applied member constraints so we can binary search"}]}