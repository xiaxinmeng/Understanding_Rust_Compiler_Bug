{"sha": "f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNDQwOWM1MjgxMjU4MzZhNWNiZTlkNGQ3YTM5YjhkNjY5NWY3YjE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-18T06:20:36Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-25T15:49:34Z"}, "message": "libsyntax: progress on making syntax::visit vecs_implicitly_copyable-free", "tree": {"sha": "7953b69703588cb654de1445d9f2cfad377dc23c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7953b69703588cb654de1445d9f2cfad377dc23c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "html_url": "https://github.com/rust-lang/rust/commit/f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ac5262bdf27c964d1e9496479994aff2ae80acc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ac5262bdf27c964d1e9496479994aff2ae80acc", "html_url": "https://github.com/rust-lang/rust/commit/9ac5262bdf27c964d1e9496479994aff2ae80acc"}], "stats": {"total": 1983, "additions": 1061, "deletions": 922}, "files": [{"sha": "1887b83ebebdaf90168234d416725aa61cbfa85b", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -134,7 +134,7 @@ pub pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n \n pub fn safe_to_steal_ty(t: @ast::Ty, tm: test_mode) -> bool {\n     // Restrictions happen to be the same.\n-    safe_to_replace_ty(t.node, tm)\n+    safe_to_replace_ty(&t.node, tm)\n }\n \n // Not type-parameterized: https://github.com/mozilla/rust/issues/898 (FIXED)\n@@ -175,8 +175,8 @@ pub fn steal(crate: ast::crate, tm: test_mode) -> StolenStuff {\n }\n \n \n-pub fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n-    match e {\n+pub fn safe_to_replace_expr(e: &ast::expr_, _tm: test_mode) -> bool {\n+    match *e {\n       // https://github.com/mozilla/rust/issues/652\n       ast::expr_if(*) => { false }\n       ast::expr_block(_) => { false }\n@@ -188,8 +188,8 @@ pub fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n     }\n }\n \n-pub fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n-    match t {\n+pub fn safe_to_replace_ty(t: &ast::ty_, _tm: test_mode) -> bool {\n+    match *t {\n       ast::ty_infer => { false } // always implicit, always top level\n       ast::ty_bot => { false }   // in source, can only appear\n                               // as the out type of a function\n@@ -204,7 +204,7 @@ pub fn replace_expr_in_crate(crate: ast::crate, i: uint,\n    ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_expr_rep(j_: @mut uint, i_: uint, newexpr_: ast::expr_,\n-                     original: ast::expr_, fld: fold::ast_fold,\n+                     original: &ast::expr_, fld: fold::ast_fold,\n                      tm_: test_mode) ->\n        ast::expr_ {\n         *j_ += 1u;\n@@ -221,7 +221,7 @@ pub fn replace_expr_in_crate(crate: ast::crate, i: uint,\n         .. *fold::default_ast_fold()\n     };\n     let af = fold::make_fold(afp);\n-    let crate2: @ast::crate = @af.fold_crate(crate);\n+    let crate2: @ast::crate = @af.fold_crate(&crate);\n     *crate2\n }\n \n@@ -231,7 +231,7 @@ pub fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n                            tm: test_mode) -> ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_ty_rep(j_: @mut uint, i_: uint, newty_: ast::ty_,\n-                   original: ast::ty_, fld: fold::ast_fold,\n+                   original: &ast::ty_, fld: fold::ast_fold,\n                    tm_: test_mode) ->\n        ast::ty_ {\n         *j_ += 1u;\n@@ -244,7 +244,7 @@ pub fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n         .. *fold::default_ast_fold()\n     };\n     let af = fold::make_fold(afp);\n-    let crate2: @ast::crate = @af.fold_crate(crate);\n+    let crate2: @ast::crate = @af.fold_crate(&crate);\n     *crate2\n }\n "}, {"sha": "61bb03dd7f902f37d74b0f3390ad79a068278f9f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -396,7 +396,7 @@ pub fn pretty_print_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n           pprust::node_block(s, ref blk) => {\n             pp::space(s.s);\n             pprust::synth_comment(\n-                s, ~\"block \" + int::to_str((*blk).node.id));\n+                s, ~\"block \" + int::to_str(blk.node.id));\n           }\n           pprust::node_expr(s, expr) => {\n             pp::space(s.s);"}, {"sha": "faa1ad9854af7cd3a2ce793dd18621faf1bf406d", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -45,7 +45,7 @@ pub fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n           .. *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n-    let res = @fold.fold_crate(*crate);\n+    let res = @fold.fold_crate(&*crate);\n     return res;\n }\n \n@@ -63,7 +63,7 @@ fn filter_view_item(cx: @Context, &&view_item: @ast::view_item\n     }\n }\n \n-fn fold_mod(cx: @Context, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n+fn fold_mod(cx: @Context, m: &ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     let filtered_items =\n         m.items.filter_mapped(|a| filter_item(cx, *a));\n     let filtered_view_items =\n@@ -83,7 +83,7 @@ fn filter_foreign_item(cx: @Context, &&item: @ast::foreign_item) ->\n \n fn fold_foreign_mod(\n     cx: @Context,\n-    nm: ast::foreign_mod,\n+    nm: &ast::foreign_mod,\n     fld: fold::ast_fold\n ) -> ast::foreign_mod {\n     let filtered_items =\n@@ -98,21 +98,21 @@ fn fold_foreign_mod(\n     }\n }\n \n-fn fold_item_underscore(cx: @Context, +item: ast::item_,\n+fn fold_item_underscore(cx: @Context, item: &ast::item_,\n                         fld: fold::ast_fold) -> ast::item_ {\n-    let item = match item {\n-        ast::item_impl(a, b, c, methods) => {\n+    let item = match *item {\n+        ast::item_impl(ref a, b, c, ref methods) => {\n             let methods = methods.filtered(|m| method_in_cfg(cx, *m) );\n-            ast::item_impl(a, b, c, methods)\n+            ast::item_impl(/*bad*/ copy *a, b, c, methods)\n         }\n         ast::item_trait(ref a, ref b, ref methods) => {\n             let methods = methods.filtered(|m| trait_method_in_cfg(cx, m) );\n             ast::item_trait(/*bad*/copy *a, /*bad*/copy *b, methods)\n         }\n-        item => item\n+        ref item => /*bad*/ copy *item\n     };\n \n-    fold::noop_fold_item_underscore(item, fld)\n+    fold::noop_fold_item_underscore(&item, fld)\n }\n \n fn filter_stmt(cx: @Context, &&stmt: @ast::stmt) ->\n@@ -134,7 +134,7 @@ fn filter_stmt(cx: @Context, &&stmt: @ast::stmt) ->\n \n fn fold_block(\n     cx: @Context,\n-    b: ast::blk_,\n+    b: &ast::blk_,\n     fld: fold::ast_fold\n ) -> ast::blk_ {\n     let filtered_stmts ="}, {"sha": "b7df99795924b2953d6518ef479d3afdfb090055", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -66,10 +66,13 @@ fn inject_libcore_ref(sess: Session,\n                 view_items: vis,\n                 ../*bad*/copy crate.module\n             };\n-            new_module = fld.fold_mod(new_module);\n+            new_module = fld.fold_mod(&new_module);\n \n             // FIXME #2543: Bad copy.\n-            let new_crate = ast::crate_ { module: new_module, ..copy crate };\n+            let new_crate = ast::crate_ {\n+                module: new_module,\n+                ..copy *crate\n+            };\n             (new_crate, span)\n         },\n         fold_mod: |module, fld| {\n@@ -95,12 +98,15 @@ fn inject_libcore_ref(sess: Session,\n             let vis = vec::append(~[vi2], module.view_items);\n \n             // FIXME #2543: Bad copy.\n-            let new_module = ast::_mod { view_items: vis, ..copy module };\n-            fold::noop_fold_mod(new_module, fld)\n+            let new_module = ast::_mod {\n+                view_items: vis,\n+                ..copy *module\n+            };\n+            fold::noop_fold_mod(&new_module, fld)\n         },\n         ..*fold::default_ast_fold()\n     };\n \n     let fold = fold::make_fold(precursor);\n-    @fold.fold_crate(*crate)\n+    @fold.fold_crate(crate)\n }"}, {"sha": "4e845d156f462ce473405d9ff2942955960a3a44", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -91,7 +91,7 @@ fn generate_test_harness(sess: session::Session,\n         fold_mod: |a,b| fold_mod(cx, a, b),.. *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n-    let res = @fold.fold_crate(*crate);\n+    let res = @fold.fold_crate(&*crate);\n     cx.ext_cx.bt_pop();\n     return res;\n }\n@@ -106,7 +106,7 @@ fn strip_test_functions(crate: @ast::crate) -> @ast::crate {\n }\n \n fn fold_mod(cx: @mut TestCtxt,\n-            m: ast::_mod,\n+            m: &ast::_mod,\n             fld: fold::ast_fold)\n          -> ast::_mod {\n     // Remove any #[main] from the AST so it doesn't clash with\n@@ -125,19 +125,21 @@ fn fold_mod(cx: @mut TestCtxt,\n         items: vec::map(m.items, |i| nomain(cx, *i)),\n     };\n \n-    fold::noop_fold_mod(mod_nomain, fld)\n+    fold::noop_fold_mod(&mod_nomain, fld)\n }\n \n fn fold_crate(cx: @mut TestCtxt,\n-              c: ast::crate_,\n+              c: &ast::crate_,\n               fld: fold::ast_fold)\n            -> ast::crate_ {\n     let folded = fold::noop_fold_crate(c, fld);\n \n     // Add a special __test module to the crate that will contain code\n     // generated for the test harness\n-    ast::crate_ { module: add_test_module(cx, /*bad*/copy folded.module),\n-                  .. folded }\n+    ast::crate_ {\n+        module: add_test_module(cx, &folded.module),\n+        .. folded\n+    }\n }\n \n \n@@ -238,11 +240,11 @@ fn should_fail(i: @ast::item) -> bool {\n     vec::len(attr::find_attrs_by_name(i.attrs, ~\"should_fail\")) > 0u\n }\n \n-fn add_test_module(cx: &TestCtxt, +m: ast::_mod) -> ast::_mod {\n+fn add_test_module(cx: &TestCtxt, m: &ast::_mod) -> ast::_mod {\n     let testmod = mk_test_module(cx);\n     ast::_mod {\n         items: vec::append_one(/*bad*/copy m.items, testmod),\n-        .. m\n+        .. /*bad*/ copy *m\n     }\n }\n "}, {"sha": "8324721c33a7982df0d962b52416057548990f6e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -323,7 +323,7 @@ fn encode_path(ecx: @EncodeContext, ebml_w: writer::Encoder,\n }\n \n fn encode_info_for_mod(ecx: @EncodeContext, ebml_w: writer::Encoder,\n-                       md: _mod, id: node_id, path: &[ast_map::path_elt],\n+                       md: &_mod, id: node_id, path: &[ast_map::path_elt],\n                        name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n@@ -621,7 +621,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         }\n         ebml_w.end_tag();\n       }\n-      item_mod(m) => {\n+      item_mod(ref m) => {\n         add_to_index();\n         encode_info_for_mod(ecx, ebml_w, m, item.id, path, item.ident);\n       }\n@@ -856,8 +856,8 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         // method info, we output static methods with type signatures as\n         // written. Here, we output the *real* type signatures. I feel like\n         // maybe we should only ever handle the real type signatures.\n-        for vec::each((*ms)) |m| {\n-            let ty_m = ast_util::trait_method_to_ty_method(*m);\n+        for ms.each |m| {\n+            let ty_m = ast_util::trait_method_to_ty_method(m);\n             if ty_m.self_ty.node != ast::sty_static { loop; }\n \n             index.push(entry { val: ty_m.id, pos: ebml_w.writer.tell() });\n@@ -927,7 +927,7 @@ fn encode_info_for_items(ecx: @EncodeContext, ebml_w: writer::Encoder,\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n     index.push(entry { val: crate_node_id, pos: ebml_w.writer.tell() });\n-    encode_info_for_mod(ecx, ebml_w, crate.node.module,\n+    encode_info_for_mod(ecx, ebml_w, &crate.node.module,\n                         crate_node_id, ~[],\n                         syntax::parse::token::special_idents::invalid);\n     visit::visit_crate(*crate, (), visit::mk_vt(@visit::Visitor {"}, {"sha": "2658e5c467403149c4b76bc6c149eb9c0197f162", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -298,7 +298,7 @@ fn encode_ast(ebml_w: writer::Encoder, item: ast::inlined_item) {\n // nested items, as otherwise it would get confused when translating\n // inlined items.\n fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n-    fn drop_nested_items(blk: ast::blk_, fld: fold::ast_fold) -> ast::blk_ {\n+    fn drop_nested_items(blk: &ast::blk_, fld: fold::ast_fold) -> ast::blk_ {\n         let stmts_sans_items = do blk.stmts.filtered |stmt| {\n             match stmt.node {\n               ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n@@ -317,7 +317,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n             id: blk.id,\n             rules: blk.rules\n         };\n-        fold::noop_fold_block(blk_sans_items, fld)\n+        fold::noop_fold_block(&blk_sans_items, fld)\n     }\n \n     let fld = fold::make_fold(@fold::AstFoldFns {\n@@ -336,7 +336,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n       ast::ii_dtor(ref dtor, nm, ref tps, parent_id) => {\n-        let dtor_body = fld.fold_block((*dtor).node.body);\n+        let dtor_body = fld.fold_block(&dtor.node.body);\n         ast::ii_dtor(\n             codemap::spanned {\n                 node: ast::struct_dtor_ { body: dtor_body,\n@@ -372,7 +372,7 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n       ast::ii_dtor(ref dtor, nm, ref tps, parent_id) => {\n-        let dtor_body = fld.fold_block((*dtor).node.body);\n+        let dtor_body = fld.fold_block(&dtor.node.body);\n         let dtor_attrs = fld.fold_attributes(/*bad*/copy (*dtor).node.attrs);\n         let new_params = fold::fold_ty_params(/*bad*/copy *tps, fld);\n         let dtor_id = fld.new_id((*dtor).node.id);"}, {"sha": "6efcc0b97c0ee44480dc2ccd79eb61a5694005cc", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -580,8 +580,8 @@ impl CheckLoanCtxt {\n }\n \n fn check_loans_in_fn(fk: &visit::fn_kind,\n-                     decl: ast::fn_decl,\n-                     body: ast::blk,\n+                     decl: &ast::fn_decl,\n+                     body: &ast::blk,\n                      sp: span,\n                      id: ast::node_id,\n                      &&self: @mut CheckLoanCtxt,\n@@ -753,7 +753,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n     visit::visit_expr(expr, self, vt);\n }\n \n-fn check_loans_in_block(blk: ast::blk,\n+fn check_loans_in_block(blk: &ast::blk,\n                         &&self: @mut CheckLoanCtxt,\n                         vt: visit::vt<@mut CheckLoanCtxt>) {\n     do save_and_restore_managed(self.declared_purity) {"}, {"sha": "eea11fa06754f0f5fc9b58fec5794a67698205e8", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -96,8 +96,8 @@ pub fn gather_loans(bccx: @BorrowckCtxt, crate: @ast::crate) -> ReqMaps {\n }\n \n fn req_loans_in_fn(fk: &visit::fn_kind,\n-                   decl: ast::fn_decl,\n-                   body: ast::blk,\n+                   decl: &ast::fn_decl,\n+                   body: &ast::blk,\n                    sp: span,\n                    id: ast::node_id,\n                    &&self: @mut GatherLoanCtxt,\n@@ -269,13 +269,13 @@ fn req_loans_in_expr(ex: @ast::expr,\n         (vt.visit_expr)(cond, self, vt);\n \n         // during body, can only root for the body\n-        self.root_ub = (*body).node.id;\n-        (vt.visit_block)((*body), self, vt);\n+        self.root_ub = body.node.id;\n+        (vt.visit_block)(body, self, vt);\n       }\n \n       // see explanation attached to the `root_ub` field:\n       ast::expr_loop(ref body, _) => {\n-        self.root_ub = (*body).node.id;\n+        self.root_ub = body.node.id;\n         visit::visit_expr(ex, self, vt);\n       }\n "}, {"sha": "15f64b0fa2f0c0b8892ef4191b09615111751c1f", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -33,10 +33,10 @@ pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n             match e.node {\n               expr_while(e, ref b) => {\n                 (v.visit_expr)(e, cx, v);\n-                (v.visit_block)((*b), Context { in_loop: true,.. cx }, v);\n+                (v.visit_block)(b, Context { in_loop: true,.. cx }, v);\n               }\n               expr_loop(ref b, _) => {\n-                (v.visit_block)((*b), Context { in_loop: true,.. cx }, v);\n+                (v.visit_block)(b, Context { in_loop: true,.. cx }, v);\n               }\n               expr_fn(*) => {\n                 visit::visit_expr(e, Context {\n@@ -45,18 +45,18 @@ pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n                                      }, v);\n               }\n               expr_fn_block(_, ref b) => {\n-                (v.visit_block)((*b), Context {\n+                (v.visit_block)(b, Context {\n                                          in_loop: false,\n                                          can_ret: false\n                                       }, v);\n               }\n               expr_loop_body(@expr {node: expr_fn_block(_, ref b), _}) => {\n                 let sigil = ty::ty_closure_sigil(ty::expr_ty(tcx, e));\n                 let blk = (sigil == BorrowedSigil);\n-                (v.visit_block)((*b), Context {\n+                (v.visit_block)(b, Context {\n                                          in_loop: true,\n                                          can_ret: blk\n-                                      }, v);\n+                                     }, v);\n               }\n               expr_break(_) => {\n                 if !cx.in_loop {"}, {"sha": "8666ae0fa448af5be18aa02e1834f04013d57e60", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -670,8 +670,8 @@ pub fn check_local(cx: @MatchCheckCtxt,\n \n pub fn check_fn(cx: @MatchCheckCtxt,\n                 kind: &visit::fn_kind,\n-                decl: fn_decl,\n-                body: blk,\n+                decl: &fn_decl,\n+                body: &blk,\n                 sp: span,\n                 id: node_id,\n                 &&s: (),"}, {"sha": "f69e0e2d454ded3168daa2e10d6442451e409a20", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -39,7 +39,7 @@ pub type freevar_map = HashMap<ast::node_id, freevar_info>;\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n-fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n+fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n     -> freevar_info {\n     let seen = HashMap();\n     let refs = @mut ~[];\n@@ -100,8 +100,8 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n    freevar_map {\n     let freevars = HashMap();\n \n-    let walk_fn = fn@(_fk: &visit::fn_kind, _decl: ast::fn_decl,\n-                      blk: ast::blk, _sp: span, nid: ast::node_id) {\n+    let walk_fn = fn@(_fk: &visit::fn_kind, _decl: &ast::fn_decl,\n+                      blk: &ast::blk, _sp: span, nid: ast::node_id) {\n         let vars = collect_freevars(def_map, blk);\n         freevars.insert(nid, vars);\n     };"}, {"sha": "1b1e9afa924d5dcf1b2b4a655dc04f9bcaa0d81b", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -153,8 +153,14 @@ fn with_appropriate_checker(cx: Context, id: node_id, b: fn(check_fn)) {\n \n // Check that the free variables used in a shared/sendable closure conform\n // to the copy/move kind bounds. Then recursively check the function body.\n-fn check_fn(fk: &visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n-            fn_id: node_id, cx: Context, v: visit::vt<Context>) {\n+fn check_fn(\n+    fk: &visit::fn_kind,\n+    decl: &fn_decl,\n+    body: &blk,\n+    sp: span,\n+    fn_id: node_id,\n+    cx: Context,\n+    v: visit::vt<Context>) {\n \n     // Check kinds on free variables:\n     do with_appropriate_checker(cx, fn_id) |chk| {\n@@ -166,7 +172,7 @@ fn check_fn(fk: &visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n     visit::visit_fn(fk, decl, body, sp, fn_id, cx, v);\n }\n \n-fn check_arm(a: arm, cx: Context, v: visit::vt<Context>) {\n+fn check_arm(a: &arm, cx: Context, v: visit::vt<Context>) {\n     for vec::each(a.pats) |p| {\n         do pat_util::pat_bindings(cx.tcx.def_map, *p) |mode, id, span, _pth| {\n             if mode == bind_by_copy {"}, {"sha": "c69bba8c25d5cbe17d3e0d9d7e2ec18d53cffa28", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -726,7 +726,7 @@ fn check_item_structural_records(cx: ty::ctxt, it: @ast::item) {\n fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n \n     fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,\n-                       decl: ast::fn_decl) {\n+                       decl: &ast::fn_decl) {\n         let tys = vec::map(decl.inputs, |a| a.ty );\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n@@ -760,7 +760,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n             either::Right(ast::foreign_abi_rust_intrinsic) => {\n         for nmod.items.each |ni| {\n             match /*bad*/copy ni.node {\n-              ast::foreign_item_fn(decl, _, _) => {\n+              ast::foreign_item_fn(ref decl, _, _) => {\n                 check_foreign_fn(cx, it.id, decl);\n               }\n               // FIXME #4622: Not implemented.\n@@ -923,8 +923,8 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n     }\n }\n \n-fn check_fn(tcx: ty::ctxt, fk: &visit::fn_kind, decl: ast::fn_decl,\n-            _body: ast::blk, span: span, id: ast::node_id) {\n+fn check_fn(tcx: ty::ctxt, fk: &visit::fn_kind, decl: &ast::fn_decl,\n+            _body: &ast::blk, span: span, id: ast::node_id) {\n     debug!(\"lint check_fn fk=%? id=%?\", fk, id);\n \n     // don't complain about blocks, since they tend to get their modes\n@@ -938,7 +938,7 @@ fn check_fn(tcx: ty::ctxt, fk: &visit::fn_kind, decl: ast::fn_decl,\n     check_fn_deprecated_modes(tcx, fn_ty, decl, span, id);\n }\n \n-fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: ast::fn_decl,\n+fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: &ast::fn_decl,\n                              span: span, id: ast::node_id) {\n     match ty::get(fn_ty).sty {\n         ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) |\n@@ -990,7 +990,7 @@ fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: ast::fn_decl,\n                             ast::ty_closure(@ast::TyClosure{decl: ref d, _}) |\n                             ast::ty_bare_fn(@ast::TyBareFn{decl: ref d, _})=>{\n                                 check_fn_deprecated_modes(tcx, arg_ty.ty,\n-                                                          *d, span, id);\n+                                                          d, span, id);\n                             }\n                             ast::ty_path(*) => {\n                                 // This is probably a typedef, so we can't\n@@ -1026,7 +1026,7 @@ fn check_item_deprecated_modes(tcx: ty::ctxt, it: @ast::item) {\n                 ast::ty_bare_fn(@ast::TyBareFn {decl: ref decl, _}) => {\n                     let fn_ty = ty::node_id_to_type(tcx, it.id);\n                     check_fn_deprecated_modes(\n-                        tcx, fn_ty, *decl, ty.span, it.id)\n+                        tcx, fn_ty, decl, ty.span, it.id)\n                 }\n                 _ => ()\n             }"}, {"sha": "e6c8a3f1aa537646c1d9573f01c024d725add986", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -436,8 +436,8 @@ impl IrMaps {\n }\n \n fn visit_fn(fk: &visit::fn_kind,\n-            decl: fn_decl,\n-            body: blk,\n+            decl: &fn_decl,\n+            body: &blk,\n             sp: span,\n             id: node_id,\n             &&self: @mut IrMaps,\n@@ -540,7 +540,7 @@ fn visit_local(local: @local, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     visit::visit_local(local, self, vt);\n }\n \n-fn visit_arm(arm: arm, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n+fn visit_arm(arm: &arm, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     let def_map = self.tcx.def_map;\n     for arm.pats.each |pat| {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n@@ -979,7 +979,7 @@ impl Liveness {\n \n     // _______________________________________________________________________\n \n-    fn compute(&self, decl: fn_decl, body: blk) -> LiveNode {\n+    fn compute(&self, decl: &fn_decl, body: &blk) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n@@ -1004,7 +1004,7 @@ impl Liveness {\n         entry_ln\n     }\n \n-    fn propagate_through_fn_block(&self, decl: fn_decl, blk: blk)\n+    fn propagate_through_fn_block(&self, decl: &fn_decl, blk: &blk)\n                                  -> LiveNode {\n         // inputs passed by & mode should be considered live on exit:\n         for decl.inputs.each |arg| {\n@@ -1038,7 +1038,7 @@ impl Liveness {\n         self.propagate_through_block(blk, self.s.fallthrough_ln)\n     }\n \n-    fn propagate_through_block(&self, blk: blk, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_block(&self, blk: &blk, succ: LiveNode) -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.node.expr, succ);\n         do blk.node.stmts.foldr(succ) |stmt, succ| {\n             self.propagate_through_stmt(*stmt, succ)\n@@ -1134,7 +1134,7 @@ impl Liveness {\n               The next-node for a break is the successor of the entire\n               loop. The next-node for a continue is the top of this loop.\n               */\n-              self.with_loop_nodes((*blk).node.id, succ,\n+              self.with_loop_nodes(blk.node.id, succ,\n                   self.live_node(expr.id, expr.span), || {\n \n                  // the construction of a closure itself is not important,\n@@ -1164,21 +1164,21 @@ impl Liveness {\n             //   (  succ  )\n             //\n             let else_ln = self.propagate_through_opt_expr(els, succ);\n-            let then_ln = self.propagate_through_block((*then), succ);\n+            let then_ln = self.propagate_through_block(then, succ);\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_from_succ(ln, else_ln);\n             self.merge_from_succ(ln, then_ln, false);\n             self.propagate_through_expr(cond, ln)\n           }\n \n           expr_while(cond, ref blk) => {\n-            self.propagate_through_loop(expr, Some(cond), (*blk), succ)\n+            self.propagate_through_loop(expr, Some(cond), blk, succ)\n           }\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n           expr_loop(ref blk, _) => {\n-            self.propagate_through_loop(expr, None, (*blk), succ)\n+            self.propagate_through_loop(expr, None, blk, succ)\n           }\n \n           expr_match(e, ref arms) => {\n@@ -1199,9 +1199,9 @@ impl Liveness {\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_empty(ln, succ);\n             let mut first_merge = true;\n-            for (*arms).each |arm| {\n+            for arms.each |arm| {\n                 let body_succ =\n-                    self.propagate_through_block(arm.body, succ);\n+                    self.propagate_through_block(&arm.body, succ);\n                 let guard_succ =\n                     self.propagate_through_opt_expr(arm.guard, body_succ);\n                 let arm_succ =\n@@ -1362,7 +1362,7 @@ impl Liveness {\n           }\n \n           expr_block(ref blk) => {\n-            self.propagate_through_block((*blk), succ)\n+            self.propagate_through_block(blk, succ)\n           }\n \n           expr_mac(*) => {\n@@ -1463,7 +1463,7 @@ impl Liveness {\n \n     fn propagate_through_loop(&self, expr: @expr,\n                               cond: Option<@expr>,\n-                              body: blk,\n+                              body: &blk,\n                               succ: LiveNode) -> LiveNode {\n \n         /*\n@@ -1568,7 +1568,7 @@ fn check_local(local: @local, &&self: @Liveness, vt: vt<@Liveness>) {\n     visit::visit_local(local, self, vt);\n }\n \n-fn check_arm(arm: arm, &&self: @Liveness, vt: vt<@Liveness>) {\n+fn check_arm(arm: &arm, &&self: @Liveness, vt: vt<@Liveness>) {\n     do self.arm_pats_bindings(arm.pats) |ln, var, sp| {\n         self.warn_about_unused(sp, ln, var);\n     }\n@@ -1639,8 +1639,8 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n     }\n }\n \n-fn check_fn(_fk: &visit::fn_kind, _decl: fn_decl,\n-            _body: blk, _sp: span, _id: node_id,\n+fn check_fn(_fk: &visit::fn_kind, _decl: &fn_decl,\n+            _body: &blk, _sp: span, _id: node_id,\n             &&_self: @Liveness, _v: vt<@Liveness>) {\n     // do not check contents of nested fns\n }\n@@ -1885,7 +1885,7 @@ impl @Liveness {\n         if name[0] == ('_' as u8) { None } else { Some(name) }\n     }\n \n-    fn warn_about_unused_args(&self, decl: fn_decl, entry_ln: LiveNode) {\n+    fn warn_about_unused_args(&self, decl: &fn_decl, entry_ln: LiveNode) {\n         for decl.inputs.each |arg| {\n             do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n                     |_bm, p_id, sp, _n| {"}, {"sha": "74f485d08af4963d34d6126a3a2fcc55360d6c8f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -221,7 +221,7 @@ pub fn record_parent(cx: ctxt, child_id: ast::node_id) {\n     }\n }\n \n-pub fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_block(blk: &ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Record the parent of this block.\n     record_parent(cx, blk.node.id);\n \n@@ -230,7 +230,7 @@ pub fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n     visit::visit_block(blk, new_cx, visitor);\n }\n \n-pub fn resolve_arm(arm: ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_arm(arm: &ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n     visit::visit_arm(arm, cx, visitor);\n }\n \n@@ -317,8 +317,8 @@ pub fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n }\n \n pub fn resolve_fn(fk: &visit::fn_kind,\n-                  decl: ast::fn_decl,\n-                  body: ast::blk,\n+                  decl: &ast::fn_decl,\n+                  body: &ast::blk,\n                   sp: span,\n                   id: ast::node_id,\n                   cx: ctxt,\n@@ -608,8 +608,8 @@ pub fn determine_rp_in_item(item: @ast::item,\n }\n \n pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n-                          decl: ast::fn_decl,\n-                          body: ast::blk,\n+                          decl: &ast::fn_decl,\n+                          body: &ast::blk,\n                           _: span,\n                           _: ast::node_id,\n                           &&cx: @mut DetermineRpCtxt,\n@@ -626,7 +626,7 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n     }\n }\n \n-pub fn determine_rp_in_ty_method(ty_m: ast::ty_method,\n+pub fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n                                  &&cx: @mut DetermineRpCtxt,\n                                  visitor: visit::vt<@mut DetermineRpCtxt>) {\n     do cx.with(cx.item_id, false) {"}, {"sha": "cff6603cf0532c0b0fa925954559fcf058ee1d74", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -1027,7 +1027,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn block_needs_anonymous_module(@mut self, block: blk) -> bool {\n+    fn block_needs_anonymous_module(@mut self, block: &blk) -> bool {\n         // If the block has view items, we need an anonymous module.\n         if block.node.view_items.len() > 0 {\n             return true;\n@@ -1276,7 +1276,7 @@ pub impl Resolver {\n                 // methods, so check that first.\n                 let mut has_static_methods = false;\n                 for (*methods).each |method| {\n-                    let ty_m = trait_method_to_ty_method(*method);\n+                    let ty_m = trait_method_to_ty_method(method);\n                     match ty_m.self_ty.node {\n                         sty_static => {\n                             has_static_methods = true;\n@@ -1304,7 +1304,7 @@ pub impl Resolver {\n                 // Add the names of all the methods to the trait info.\n                 let method_names = @HashMap();\n                 for (*methods).each |method| {\n-                    let ty_m = trait_method_to_ty_method(*method);\n+                    let ty_m = trait_method_to_ty_method(method);\n \n                     let ident = ty_m.ident;\n                     // Add it to the trait info if not static,\n@@ -1534,7 +1534,7 @@ pub impl Resolver {\n     }\n \n     fn build_reduced_graph_for_block(@mut self,\n-                                     block: blk,\n+                                     block: &blk,\n                                      parent: ReducedGraphParent,\n                                      &&visitor: vt<ReducedGraphParent>) {\n         let mut new_parent;\n@@ -3788,7 +3788,7 @@ pub impl Resolver {\n                                          item.id,\n                                          0,\n                                          OpaqueFunctionRibKind),\n-                                      (*block),\n+                                      block,\n                                       NoSelfBinding,\n                                       visitor);\n             }\n@@ -3866,7 +3866,7 @@ pub impl Resolver {\n                         rib_kind: RibKind,\n                         optional_declaration: Option<@fn_decl>,\n                         type_parameters: TypeParameters,\n-                        block: blk,\n+                        block: &blk,\n                         self_binding: SelfBinding,\n                         visitor: ResolveVisitor) {\n         // Create a value rib for the function.\n@@ -3982,7 +3982,7 @@ pub impl Resolver {\n                     self.resolve_function(NormalRibKind,\n                                           None,\n                                           NoTypeParameters,\n-                                          (*destructor).node.body,\n+                                          &destructor.node.body,\n                                           HasSelfBinding\n                                             ((*destructor).node.self_id,\n                                              true),\n@@ -4015,7 +4015,7 @@ pub impl Resolver {\n         self.resolve_function(rib_kind,\n                               Some(@/*bad*/copy method.decl),\n                               type_parameters,\n-                              method.body,\n+                              &method.body,\n                               self_binding,\n                               visitor);\n     }\n@@ -4140,7 +4140,7 @@ pub impl Resolver {\n         return result;\n     }\n \n-    fn check_consistent_bindings(@mut self, arm: arm) {\n+    fn check_consistent_bindings(@mut self, arm: &arm) {\n         if arm.pats.len() == 0 { return; }\n         let map_0 = self.binding_mode_map(arm.pats[0]);\n         for arm.pats.eachi() |i, p| {\n@@ -4179,7 +4179,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_arm(@mut self, arm: arm, visitor: ResolveVisitor) {\n+    fn resolve_arm(@mut self, arm: &arm, visitor: ResolveVisitor) {\n         (*self.value_ribs).push(@Rib(NormalRibKind));\n \n         let bindings_list = HashMap();\n@@ -4193,12 +4193,12 @@ pub impl Resolver {\n         self.check_consistent_bindings(arm);\n \n         visit_expr_opt(arm.guard, (), visitor);\n-        self.resolve_block(arm.body, visitor);\n+        self.resolve_block(&arm.body, visitor);\n \n         (*self.value_ribs).pop();\n     }\n \n-    fn resolve_block(@mut self, block: blk, visitor: ResolveVisitor) {\n+    fn resolve_block(@mut self, block: &blk, visitor: ResolveVisitor) {\n         debug!(\"(resolving block) entering block\");\n         (*self.value_ribs).push(@Rib(NormalRibKind));\n \n@@ -4910,7 +4910,7 @@ pub impl Resolver {\n                 self.resolve_function(FunctionRibKind(expr.id, block.node.id),\n                                       Some(@/*bad*/copy *fn_decl),\n                                       NoTypeParameters,\n-                                      (*block),\n+                                      block,\n                                       NoSelfBinding,\n                                       visitor);\n             }"}, {"sha": "d2896216459281442454359df1654e084de9f8cb", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -2093,7 +2093,7 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n                      vec::append(/*bad*/copy *path, ~[path_name(item.ident)]),\n                      decl, body, llfndecl, no_self, None, item.id, None);\n         } else {\n-            for vec::each((*body).node.stmts) |stmt| {\n+            for body.node.stmts.each |stmt| {\n                 match stmt.node {\n                   ast::stmt_decl(@codemap::spanned { node: ast::decl_item(i),\n                                                  _ }, _) => {\n@@ -2108,7 +2108,7 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n         meth::trans_impl(ccx, /*bad*/copy *path, item.ident, ms, tps, None,\n                          item.id);\n       }\n-      ast::item_mod(m) => {\n+      ast::item_mod(ref m) => {\n         trans_mod(ccx, m);\n       }\n       ast::item_enum(ref enum_definition, ref tps) => {\n@@ -2121,11 +2121,10 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n         }\n       }\n       ast::item_const(_, expr) => consts::trans_const(ccx, expr, item.id),\n-      ast::item_foreign_mod(foreign_mod) => {\n+      ast::item_foreign_mod(ref foreign_mod) => {\n         let abi = match attr::foreign_abi(item.attrs) {\n-          either::Right(abi_) => abi_,\n-          either::Left(ref msg) => ccx.sess.span_fatal(item.span,\n-                                                       /*bad*/copy *msg)\n+            Right(abi_) => abi_,\n+            Left(ref msg) => ccx.sess.span_fatal(item.span, /*bad*/copy *msg)\n         };\n         foreign::trans_foreign_mod(ccx, foreign_mod, abi);\n       }\n@@ -2165,9 +2164,9 @@ pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::struct_def,\n // separate modules in the compiled program.  That's because modules exist\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n-pub fn trans_mod(ccx: @CrateContext, m: ast::_mod) {\n+pub fn trans_mod(ccx: @CrateContext, m: &ast::_mod) {\n     let _icx = ccx.insn_ctxt(\"trans_mod\");\n-    for vec::each(m.items) |item| {\n+    for m.items.each |item| {\n         trans_item(ccx, **item);\n     }\n }\n@@ -3130,7 +3129,7 @@ pub fn trans_crate(sess: session::Session,\n \n         {\n             let _icx = ccx.insn_ctxt(\"text\");\n-            trans_mod(ccx, crate.node.module);\n+            trans_mod(ccx, &crate.node.module);\n         }\n \n         decl_gc_metadata(ccx, llmod_id);"}, {"sha": "3782bb9c3fdce82aa6aeeaabbb89d68cfcc2c667", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -390,7 +390,7 @@ pub fn trans_rtcall_or_lang_call_with_type_params(bcx: block,\n         ArgVals(args), dest, DontAutorefArg);\n }\n \n-pub fn body_contains_ret(body: ast::blk) -> bool {\n+pub fn body_contains_ret(body: &ast::blk) -> bool {\n     let cx = @mut false;\n     visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n         visit_item: |_i, _cx, _v| { },\n@@ -424,7 +424,7 @@ pub fn trans_call_inner(\n               ast::expr_loop_body(@ast::expr {\n                 node: ast::expr_fn_block(_, ref body),\n                 _\n-              }) =>  body_contains_ret((*body)),\n+              }) =>  body_contains_ret(body),\n               _ => false\n             }\n           }"}, {"sha": "b0a2539b81eb52361cf79b29c499806c2d0068d0", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -202,7 +202,7 @@ fn build_wrap_fn_(ccx: @CrateContext,\n // function itself is unnecessary). We used to do this, in fact, and will\n // perhaps do so in the future.\n pub fn trans_foreign_mod(ccx: @CrateContext,\n-                         foreign_mod: ast::foreign_mod,\n+                         foreign_mod: &ast::foreign_mod,\n                          abi: ast::foreign_abi) {\n \n     let _icx = ccx.insn_ctxt(\"foreign::trans_foreign_mod\");"}, {"sha": "825dcbb44d2046434f91fc4926ab9b0f6a817da8", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -310,7 +310,7 @@ pub fn trans_static_method_callee(bcx: block,\n     let mname = if method_id.crate == ast::local_crate {\n         match bcx.tcx().items.get(&method_id.node) {\n             ast_map::node_trait_method(trait_method, _, _) => {\n-                ast_util::trait_method_to_ty_method(*trait_method).ident\n+                ast_util::trait_method_to_ty_method(trait_method).ident\n             }\n             _ => fail!(~\"callee is not a trait method\")\n         }"}, {"sha": "ac2abcac1e2769110fd44a3868544e5ada1a4565", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -109,15 +109,15 @@ fn traverse_public_item(cx: ctx, item: @item) {\n       item_fn(_, _, ref tps, ref blk) => {\n         if tps.len() > 0u ||\n            attr::find_inline_attr(item.attrs) != attr::ia_none {\n-            traverse_inline_body(cx, (*blk));\n+            traverse_inline_body(cx, blk);\n         }\n       }\n       item_impl(tps, _, _, ms) => {\n         for vec::each(ms) |m| {\n             if tps.len() > 0u || m.tps.len() > 0u ||\n                attr::find_inline_attr(m.attrs) != attr::ia_none {\n                 cx.rmap.insert(m.id, ());\n-                traverse_inline_body(cx, m.body);\n+                traverse_inline_body(cx, &m.body);\n             }\n         }\n       }\n@@ -129,7 +129,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             cx.rmap.insert(dtor.node.id, ());\n             if tps.len() > 0u || attr::find_inline_attr(dtor.node.attrs)\n                      != attr::ia_none {\n-                traverse_inline_body(cx, dtor.node.body);\n+                traverse_inline_body(cx, &dtor.node.body);\n             }\n         }\n       }\n@@ -168,7 +168,7 @@ fn traverse_ty(ty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n     }\n }\n \n-fn traverse_inline_body(cx: ctx, body: blk) {\n+fn traverse_inline_body(cx: ctx, body: &blk) {\n     fn traverse_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         match e.node {\n           expr_path(_) => {\n@@ -217,7 +217,7 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n     fn traverse_item(i: @item, cx: ctx, _v: visit::vt<ctx>) {\n       traverse_public_item(cx, i);\n     }\n-     visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n+    visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n         visit_expr: traverse_expr,\n         visit_item: traverse_item,\n          ..*visit::default_visitor()"}, {"sha": "47762ce45741a9f6cf2a26e02db96a1adb4ba4aa", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -103,7 +103,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n       ast_map::node_item(@ast::item { node: item_fn(_, _, _, ref body),\n                                       _ }, _) |\n       ast_map::node_method(@ast::method {body: ref body, _}, _, _) => {\n-        handle_body(cx, (*body));\n+        handle_body(cx, body);\n       }\n       ast_map::node_trait_method(*) => {\n         // This will be a static trait method. For now, we just assume\n@@ -159,8 +159,8 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n             for uint::range(0u, n_tps) |n| { cx.uses[n] |= flags;}\n         }\n       }\n-      ast_map::node_dtor(_, dtor, _, _) => {\n-        handle_body(cx, dtor.node.body);\n+      ast_map::node_dtor(_, ref dtor, _, _) => {\n+        handle_body(cx, &dtor.node.body);\n       }\n       ast_map::node_struct_ctor(*) => {\n         // Similarly to node_variant, this monomorphized function just uses\n@@ -359,7 +359,7 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n     }\n }\n \n-pub fn handle_body(cx: Context, body: blk) {\n+pub fn handle_body(cx: Context, body: &blk) {\n     let v = visit::mk_vt(@visit::Visitor {\n         visit_expr: |e, cx, v| {\n             visit::visit_expr(e, cx, v);"}, {"sha": "3dedd169c8566f177341d6db797b6676981eeece", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -3850,7 +3850,7 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n                             ast_map::path_name(method.ident))\n           }\n           ast_map::node_trait_method(trait_method, _, path) => {\n-            let method = ast_util::trait_method_to_ty_method(*trait_method);\n+            let method = ast_util::trait_method_to_ty_method(&*trait_method);\n             vec::append_one(/*bad*/copy *path,\n                             ast_map::path_name(method.ident))\n           }"}, {"sha": "c026cc4845c4eca4681a09d9a04e4486d66a7ef0", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -332,14 +332,14 @@ pub fn ast_ty_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n         };\n         ty::mk_rec(tcx, flds)\n       }\n-      ast::ty_bare_fn(bf) => {\n+      ast::ty_bare_fn(ref bf) => {\n           ty::mk_bare_fn(tcx, ty_of_bare_fn(self, rscope, bf.purity,\n-                                            bf.abi, bf.decl))\n+                                            bf.abi, &bf.decl))\n       }\n-      ast::ty_closure(f) => {\n+      ast::ty_closure(ref f) => {\n           let fn_decl = ty_of_closure(self, rscope, f.sigil,\n                                       f.purity, f.onceness,\n-                                      f.region, f.decl, None,\n+                                      f.region, &f.decl, None,\n                                       ast_ty.span);\n           ty::mk_closure(tcx, fn_decl)\n       }\n@@ -473,7 +473,7 @@ pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + Durable>(\n         rscope: RS,\n         purity: ast::purity,\n         abi: ast::Abi,\n-        decl: ast::fn_decl)\n+        decl: &ast::fn_decl)\n      -> ty::BareFnTy {\n     debug!(\"ty_of_fn_decl\");\n \n@@ -501,7 +501,7 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + Durable>(\n         purity: ast::purity,\n         onceness: ast::Onceness,\n         opt_region: Option<@ast::region>,\n-        decl: ast::fn_decl,\n+        decl: &ast::fn_decl,\n         expected_tys: Option<ty::FnSig>,\n         span: span)\n      -> ty::ClosureTy {"}, {"sha": "8c39beac6bb3df061a06bf859207373c7782e211", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -58,7 +58,7 @@ pub fn check_match(fcx: @mut FnCtxt,\n           Some(e) => { check_expr_has_type(fcx, e, ty::mk_bool(tcx)); },\n           None => ()\n         }\n-        if !check_block(fcx, arm.body) { arm_non_bot = true; }\n+        if !check_block(fcx, &arm.body) { arm_non_bot = true; }\n         let bty = fcx.node_ty(arm.body.node.id);\n         demand::suptype(fcx, arm.body.span, result_ty, bty);\n     }"}, {"sha": "309a4a9b0fabebf90912258e372473834707775b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -244,7 +244,7 @@ pub fn check_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n \n pub fn check_bare_fn(ccx: @mut CrateCtxt,\n                      decl: &ast::fn_decl,\n-                     body: ast::blk,\n+                     body: &ast::blk,\n                      id: ast::node_id,\n                      self_info: Option<SelfInfo>) {\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n@@ -264,7 +264,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 sigil: Option<ast::Sigil>,\n                 fn_sig: &ty::FnSig,\n                 decl: &ast::fn_decl,\n-                body: ast::blk,\n+                body: &ast::blk,\n                 fn_kind: FnKind,\n                 old_fcx: Option<@mut FnCtxt>) {\n     let tcx = ccx.tcx;\n@@ -381,7 +381,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n \n     fn gather_locals(fcx: @mut FnCtxt,\n                      decl: &ast::fn_decl,\n-                     body: ast::blk,\n+                     body: &ast::blk,\n                      arg_tys: &[ty::t],\n                      self_info: Option<SelfInfo>) {\n         let tcx = fcx.ccx.tcx;\n@@ -459,7 +459,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             visit::visit_pat(p, e, v);\n         };\n \n-        let visit_block = fn@(b: ast::blk, &&e: (), v: visit::vt<()>) {\n+        let visit_block = fn@(b: &ast::blk, &&e: (), v: visit::vt<()>) {\n             // non-obvious: the `blk` variable maps to region lb, so\n             // we have to keep this up-to-date.  This\n             // is... unfortunate.  It'd be nice to not need this.\n@@ -469,8 +469,8 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         };\n \n         // Don't descend into fns and items\n-        fn visit_fn(_fk: &visit::fn_kind, _decl: ast::fn_decl,\n-                    _body: ast::blk, _sp: span,\n+        fn visit_fn(_fk: &visit::fn_kind, _decl: &ast::fn_decl,\n+                    _body: &ast::blk, _sp: span,\n                     _id: ast::node_id, &&_t: (), _v: visit::vt<()>) {\n         }\n         fn visit_item(_i: @ast::item, &&_e: (), _v: visit::vt<()>) { }\n@@ -497,7 +497,13 @@ pub fn check_method(ccx: @mut CrateCtxt,\n         def_id: self_impl_def_id,\n         explicit_self: method.self_ty\n     };\n-    check_bare_fn(ccx, &method.decl, method.body, method.id, Some(self_info));\n+    check_bare_fn(\n+        ccx,\n+        &method.decl,\n+        &method.body,\n+        method.id,\n+        Some(self_info)\n+    );\n }\n \n pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n@@ -541,9 +547,13 @@ pub fn check_struct(ccx: @mut CrateCtxt,\n         };\n         // typecheck the dtor\n         let dtor_dec = ast_util::dtor_dec();\n-        check_bare_fn(ccx, &dtor_dec,\n-                      dtor.node.body, dtor.node.id,\n-                      Some(class_t));\n+        check_bare_fn(\n+            ccx,\n+            &dtor_dec,\n+            &dtor.node.body,\n+            dtor.node.id,\n+            Some(class_t)\n+        );\n     };\n \n     // Check that the class is instantiable\n@@ -565,7 +575,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n                             it.id);\n       }\n       ast::item_fn(ref decl, _, _, ref body) => {\n-        check_bare_fn(ccx, decl, (*body), it.id, None);\n+        check_bare_fn(ccx, decl, body, it.id, None);\n       }\n       ast::item_impl(_, _, ty, ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id);\n@@ -1397,7 +1407,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     fn check_for(fcx: @mut FnCtxt,\n                  local: @ast::local,\n                  element_ty: ty::t,\n-                 body: ast::blk,\n+                 body: &ast::blk,\n                  node_id: ast::node_id)\n               -> bool {\n         let local_ty = fcx.local_ty(local.span, local.node.id);\n@@ -1411,7 +1421,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // A generic function for checking the then and else in an if\n     // or if-check\n     fn check_then_else(fcx: @mut FnCtxt,\n-                       thn: ast::blk,\n+                       thn: &ast::blk,\n                        elsopt: Option<@ast::expr>,\n                        id: ast::node_id,\n                        _sp: span)\n@@ -1609,7 +1619,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                      expr: @ast::expr,\n                      ast_sigil_opt: Option<ast::Sigil>,\n                      decl: &ast::fn_decl,\n-                     body: ast::blk,\n+                     body: &ast::blk,\n                      fn_kind: FnKind,\n                      expected: Option<ty::t>) {\n         let tcx = fcx.ccx.tcx;\n@@ -1653,7 +1663,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let mut fn_ty = astconv::ty_of_closure(\n             fcx, fcx,\n             sigil, purity, expected_onceness,\n-            None, *decl, expected_tys, expr.span);\n+            None, decl, expected_tys, expr.span);\n \n         let fty = ty::mk_closure(tcx, copy fn_ty);\n \n@@ -2094,7 +2104,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 // message because of the indirect_ret_ty.\n                 let fn_kind = if err_happened {Vanilla} else {ForLoop};\n                 check_expr_fn(fcx, loop_body, None,\n-                              decl, *body, fn_kind, Some(inner_ty));\n+                              decl, body, fn_kind, Some(inner_ty));\n                 demand::suptype(fcx, loop_body.span,\n                                 inner_ty, fcx.expr_ty(loop_body));\n             }\n@@ -2341,28 +2351,28 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       }\n       ast::expr_if(cond, ref thn, elsopt) => {\n         bot = check_expr_has_type(fcx, cond, ty::mk_bool(tcx));\n-        bot |= check_then_else(fcx, *thn, elsopt, id, expr.span);\n+        bot |= check_then_else(fcx, thn, elsopt, id, expr.span);\n       }\n       ast::expr_while(cond, ref body) => {\n         bot = check_expr_has_type(fcx, cond, ty::mk_bool(tcx));\n-        check_block_no_value(fcx, (*body));\n+        check_block_no_value(fcx, body);\n         fcx.write_ty(id, ty::mk_nil(tcx));\n       }\n       ast::expr_loop(ref body, _) => {\n-        check_block_no_value(fcx, (*body));\n+        check_block_no_value(fcx, body);\n         fcx.write_ty(id, ty::mk_nil(tcx));\n-        bot = !may_break(tcx, expr.id, (*body));\n+        bot = !may_break(tcx, expr.id, body);\n       }\n       ast::expr_match(discrim, ref arms) => {\n         bot = _match::check_match(fcx, expr, discrim, (/*bad*/copy *arms));\n       }\n       ast::expr_fn(sigil, ref decl, ref body, _) => {\n         check_expr_fn(fcx, expr, Some(sigil),\n-                      decl, (*body), Vanilla, expected);\n+                      decl, body, Vanilla, expected);\n       }\n       ast::expr_fn_block(ref decl, ref body) => {\n         check_expr_fn(fcx, expr, None,\n-                      decl, (*body), Vanilla, expected);\n+                      decl, body, Vanilla, expected);\n       }\n       ast::expr_loop_body(loop_body) => {\n           check_loop_body(fcx, expr, expected, loop_body);\n@@ -2392,7 +2402,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         match b.node {\n           ast::expr_fn_block(ref decl, ref body) => {\n             check_expr_fn(fcx, b, None,\n-                          decl, *body, DoBlock, Some(inner_ty));\n+                          decl, body, DoBlock, Some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n           }\n           // argh\n@@ -2402,7 +2412,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       }\n       ast::expr_block(ref b) => {\n         // If this is an unchecked block, turn off purity-checking\n-        bot = check_block_with_expected(fcx, *b, expected);\n+        bot = check_block_with_expected(fcx, b, expected);\n         let typ =\n             match b.node.expr {\n               Some(expr) => fcx.expr_ty(expr),\n@@ -2692,7 +2702,7 @@ pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::stmt) -> bool {\n     return bot;\n }\n \n-pub fn check_block_no_value(fcx: @mut FnCtxt, blk: ast::blk) -> bool {\n+pub fn check_block_no_value(fcx: @mut FnCtxt, blk: &ast::blk) -> bool {\n     let bot = check_block(fcx, blk);\n     if !bot {\n         let blkty = fcx.node_ty(blk.node.id);\n@@ -2702,12 +2712,12 @@ pub fn check_block_no_value(fcx: @mut FnCtxt, blk: ast::blk) -> bool {\n     return bot;\n }\n \n-pub fn check_block(fcx0: @mut FnCtxt, blk: ast::blk) -> bool {\n+pub fn check_block(fcx0: @mut FnCtxt, blk: &ast::blk) -> bool {\n     check_block_with_expected(fcx0, blk, None)\n }\n \n pub fn check_block_with_expected(fcx0: @mut FnCtxt,\n-                                 blk: ast::blk,\n+                                 blk: &ast::blk,\n                                  expected: Option<ty::t>)\n                               -> bool {\n     let fcx = match blk.node.rules {\n@@ -3102,7 +3112,7 @@ pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n }\n \n // Returns true if b contains a break that can exit from b\n-pub fn may_break(cx: ty::ctxt, id: ast::node_id, b: ast::blk) -> bool {\n+pub fn may_break(cx: ty::ctxt, id: ast::node_id, b: &ast::blk) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n     (loop_query(b, |e| {"}, {"sha": "bf6ddc4f5421e1fd8d6713c4bdf1a54723e0a0a4", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -125,7 +125,7 @@ pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::expr) {\n     fcx.infcx().resolve_regions();\n }\n \n-pub fn regionck_fn(fcx: @mut FnCtxt, blk: ast::blk) {\n+pub fn regionck_fn(fcx: @mut FnCtxt, blk: &ast::blk) {\n     let rcx = @mut Rcx { fcx: fcx, errors_reported: 0 };\n     let v = regionck_visitor();\n     (v.visit_block)(blk, rcx, v);\n@@ -176,7 +176,7 @@ pub fn visit_local(l: @ast::local, &&rcx: @mut Rcx, v: rvt) {\n     }\n }\n \n-pub fn visit_block(b: ast::blk, &&rcx: @mut Rcx, v: rvt) {\n+pub fn visit_block(b: &ast::blk, &&rcx: @mut Rcx, v: rvt) {\n     visit::visit_block(b, rcx, v);\n }\n "}, {"sha": "c8cd7c05fe864fce3d6178815e2752f13f9585af", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -731,7 +731,7 @@ pub fn resolve_expr(ex: @ast::expr,\n \n // Detect points where a trait-bounded type parameter is\n // instantiated, resolve the impls for the parameters.\n-pub fn resolve_in_block(fcx: @mut FnCtxt, bl: ast::blk) {\n+pub fn resolve_in_block(fcx: @mut FnCtxt, bl: &ast::blk) {\n     visit::visit_block(bl, fcx, visit::mk_vt(@visit::Visitor {\n         visit_expr: resolve_expr,\n         visit_item: |_,_,_| {},"}, {"sha": "7fb896a902ca1c6db49ce65995fff7636af0030c", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -200,7 +200,7 @@ fn visit_expr(e: @ast::expr, &&wbcx: @mut WbCtxt, v: wb_vt) {\n     }\n     visit::visit_expr(e, wbcx, v);\n }\n-fn visit_block(b: ast::blk, &&wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_block(b: &ast::blk, &&wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, b.span, b.node.id);\n     visit::visit_block(b, wbcx, v);\n@@ -260,7 +260,7 @@ pub fn resolve_type_vars_in_expr(fcx: @mut FnCtxt, e: @ast::expr) -> bool {\n \n pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n                                decl: &ast::fn_decl,\n-                               blk: ast::blk,\n+                               blk: &ast::blk,\n                                self_info: Option<SelfInfo>) -> bool {\n     let wbcx = @mut WbCtxt { fcx: fcx, success: true };\n     let visit = mk_visitor();"}, {"sha": "0c44c20b25e99fc2b85ac1e53dc8bf212867f130", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -228,7 +228,7 @@ pub fn ensure_trait_methods(ccx: @mut CrateCtxt,\n     }\n \n     fn make_static_method_ty(ccx: @mut CrateCtxt,\n-                             am: ast::ty_method,\n+                             am: &ast::ty_method,\n                              rp: Option<ty::region_variance>,\n                              m: ty::method,\n                              // Take this as an argument b/c we may check\n@@ -289,10 +289,11 @@ pub fn ensure_trait_methods(ccx: @mut CrateCtxt,\n             }\n \n             let trait_bounds = ty_param_bounds(ccx, *params);\n-            let ty_m = trait_method_to_ty_method(*m);\n-            let method_ty = ty_of_ty_method(ccx, ty_m, region_paramd, def_id);\n+            let ty_m = trait_method_to_ty_method(m);\n+            let method_ty = ty_of_ty_method(ccx, &ty_m, region_paramd,\n+                                            def_id);\n             if ty_m.self_ty.node == ast::sty_static {\n-                make_static_method_ty(ccx, ty_m, region_paramd,\n+                make_static_method_ty(ccx, &ty_m, region_paramd,\n                                       method_ty, trait_ty,\n                                       trait_bounds);\n             }\n@@ -689,7 +690,7 @@ pub fn convert_struct(ccx: @mut CrateCtxt,\n             astconv::ty_of_bare_fn(\n                 ccx, type_rscope(rp),\n                 ast::impure_fn, ast::RustAbi,\n-                ast_util::dtor_dec()));\n+                &ast_util::dtor_dec()));\n         write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n         tcx.tcache.insert(local_def(dtor.node.id),\n                           ty_param_bounds_and_ty {\n@@ -748,22 +749,22 @@ pub fn ty_of_method(ccx: @mut CrateCtxt,\n         ident: m.ident,\n         tps: ty_param_bounds(ccx, m.tps),\n         fty: astconv::ty_of_bare_fn(ccx, type_rscope(rp), m.purity,\n-                                    ast::RustAbi, m.decl),\n+                                    ast::RustAbi, &m.decl),\n         self_ty: m.self_ty.node,\n         vis: m.vis,\n         def_id: local_def(m.id)\n     }\n }\n \n pub fn ty_of_ty_method(self: @mut CrateCtxt,\n-                       m: ast::ty_method,\n+                       m: &ast::ty_method,\n                        rp: Option<ty::region_variance>,\n                        id: ast::def_id) -> ty::method {\n     ty::method {\n         ident: m.ident,\n         tps: ty_param_bounds(self, m.tps),\n         fty: astconv::ty_of_bare_fn(self, type_rscope(rp), m.purity,\n-                                    ast::RustAbi, m.decl),\n+                                    ast::RustAbi, &m.decl),\n         // assume public, because this is only invoked on trait methods\n         self_ty: m.self_ty.node,\n         vis: ast::public,\n@@ -819,7 +820,7 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n       ast::item_fn(decl, purity, tps, _) => {\n         let bounds = ty_param_bounds(ccx, tps);\n         let tofd = astconv::ty_of_bare_fn(ccx, empty_rscope, purity,\n-                                          ast::RustAbi, decl);\n+                                          ast::RustAbi, &decl);\n         let tpt = ty_param_bounds_and_ty {\n             bounds: bounds,\n             region_param: None,\n@@ -903,17 +904,17 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n pub fn ty_of_foreign_item(ccx: @mut CrateCtxt, it: @ast::foreign_item)\n     -> ty::ty_param_bounds_and_ty {\n     match /*bad*/copy it.node {\n-      ast::foreign_item_fn(fn_decl, _, params) => {\n-        return ty_of_foreign_fn_decl(ccx, fn_decl, params, local_def(it.id));\n-      }\n-      ast::foreign_item_const(t) => {\n-        let rb = in_binding_rscope(empty_rscope);\n-        return ty::ty_param_bounds_and_ty {\n-            bounds: @~[],\n-            region_param: None,\n-            ty: ast_ty_to_ty(ccx, rb, t)\n-        };\n-      }\n+        ast::foreign_item_fn(ref fn_decl, _, ref params) => {\n+            ty_of_foreign_fn_decl(ccx, fn_decl, *params, local_def(it.id))\n+        }\n+        ast::foreign_item_const(t) => {\n+            let rb = in_binding_rscope(empty_rscope);\n+            ty::ty_param_bounds_and_ty {\n+                bounds: @~[],\n+                region_param: None,\n+                ty: ast_ty_to_ty(ccx, rb, t)\n+            }\n+        }\n     }\n }\n \n@@ -958,7 +959,7 @@ pub fn compute_bounds(ccx: @mut CrateCtxt,\n }\n \n pub fn ty_param_bounds(ccx: @mut CrateCtxt,\n-                       params: ~[ast::ty_param])\n+                       params: &[ast::ty_param])\n                     -> @~[ty::param_bounds] {\n     @do params.map |param| {\n         match ccx.tcx.ty_param_bounds.find(&param.id) {\n@@ -973,8 +974,8 @@ pub fn ty_param_bounds(ccx: @mut CrateCtxt,\n }\n \n pub fn ty_of_foreign_fn_decl(ccx: @mut CrateCtxt,\n-                             decl: ast::fn_decl,\n-                             +ty_params: ~[ast::ty_param],\n+                             decl: &ast::fn_decl,\n+                             ty_params: &[ast::ty_param],\n                              def_id: ast::def_id)\n                           -> ty::ty_param_bounds_and_ty {\n     let bounds = ty_param_bounds(ccx, ty_params);"}, {"sha": "59fe85cf173cd7f462fb9c6c14ffc51dfa933a2b", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -56,7 +56,7 @@ pub fn field_exprs(fields: ~[ast::field]) -> ~[@ast::expr] {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query(b: ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n+pub fn loop_query(b: &ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n     let rs = @mut false;\n     let visit_expr: @fn(@ast::expr,\n                         &&flag: @mut bool,\n@@ -79,7 +79,7 @@ pub fn loop_query(b: ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query(b: ast::blk, p: fn@(@ast::expr) -> bool) -> bool {\n+pub fn block_query(b: &ast::blk, p: fn@(@ast::expr) -> bool) -> bool {\n     let rs = @mut false;\n     let visit_expr: @fn(@ast::expr,\n                         &&flag: @mut bool,"}, {"sha": "f262b2219e9c9ff07253bdd5618bb53fc21d61c4", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -70,7 +70,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n       re_scope(node_id) => {\n         match cx.items.find(&node_id) {\n           Some(ast_map::node_block(ref blk)) => {\n-            explain_span(cx, \"block\", (*blk).span)\n+            explain_span(cx, \"block\", blk.span)\n           }\n           Some(ast_map::node_expr(expr)) => {\n             match expr.node {\n@@ -108,7 +108,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n \n         match cx.items.find(&id) {\n           Some(ast_map::node_block(ref blk)) => {\n-            let (msg, opt_span) = explain_span(cx, \"block\", (*blk).span);\n+            let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n             (fmt!(\"%s %s\", prefix, msg), opt_span)\n           }\n           Some(_) | None => {\n@@ -159,7 +159,7 @@ pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n     match cx.items.find(&node_id) {\n       Some(ast_map::node_block(ref blk)) => {\n         fmt!(\"<block at %s>\",\n-             cx.sess.codemap.span_to_str((*blk).span))\n+             cx.sess.codemap.span_to_str(blk.span))\n       }\n       Some(ast_map::node_expr(expr)) => {\n         match expr.node {"}, {"sha": "fdabe86359a6b01d6e11ffb0445c9bf9b87790e7", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -76,7 +76,7 @@ struct ReadyCtx {\n     fns: ~[ListenerFn]\n }\n \n-fn fold_mod(_ctx: @mut ReadyCtx, m: ast::_mod,\n+fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod,\n             fold: fold::ast_fold) -> ast::_mod {\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n@@ -87,11 +87,11 @@ fn fold_mod(_ctx: @mut ReadyCtx, m: ast::_mod,\n         }\n     }\n \n-    fold::noop_fold_mod(ast::_mod {\n-        items: do vec::map(m.items) |item| {\n+    fold::noop_fold_mod(&ast::_mod {\n+        items: do m.items.map |item| {\n             strip_main(*item)\n         },\n-        .. m\n+        .. copy *m\n     }, fold)\n }\n \n@@ -199,7 +199,7 @@ pub fn ready_crate(sess: session::Session,\n \n     let fold = fold::make_fold(precursor);\n \n-    @fold.fold_crate(*crate)\n+    @fold.fold_crate(crate)\n }\n \n pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {"}, {"sha": "b56dfeffd7a77a34f6fc44ec79aabf5211633181", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -186,8 +186,8 @@ pub fn map_decoded_item(diag: span_handler,\n \n pub fn map_fn(\n     fk: &visit::fn_kind,\n-    decl: fn_decl,\n-    body: blk,\n+    decl: &fn_decl,\n+    body: &blk,\n     sp: codemap::span,\n     id: node_id,\n     &&cx: @mut Ctx,\n@@ -205,7 +205,7 @@ pub fn map_fn(\n                     id: id,\n                     attrs: /* FIXME (#2543) */ vec::from_slice(*attrs),\n                     self_id: self_id,\n-                    body: /* FIXME (#2543) */ copy body,\n+                    body: /* FIXME (#2543) */ copy *body,\n                 },\n                 span: sp,\n             };\n@@ -222,8 +222,8 @@ pub fn map_fn(\n     visit::visit_fn(fk, decl, body, sp, id, cx, v);\n }\n \n-pub fn map_block(b: blk, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n-    cx.map.insert(b.node.id, node_block(/* FIXME (#2543) */ copy b));\n+pub fn map_block(b: &blk, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+    cx.map.insert(b.node.id, node_block(/* FIXME (#2543) */ copy *b));\n     visit::visit_block(b, cx, v);\n }\n \n@@ -244,7 +244,7 @@ pub fn map_local(loc: @local, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     visit::visit_local(loc, cx, v);\n }\n \n-pub fn map_arm(arm: arm, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_arm(arm: &arm, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     number_pat(cx, arm.pats[0]);\n     visit::visit_arm(arm, cx, v);\n }\n@@ -308,7 +308,7 @@ pub fn map_item(i: @item, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n                 cx.map.insert(p.ref_id, node_item(i, item_path));\n             }\n             for methods.each |tm| {\n-                let id = ast_util::trait_method_to_ty_method(*tm).id;\n+                let id = ast_util::trait_method_to_ty_method(tm).id;\n                 let d_id = ast_util::local_def(i.id);\n                 cx.map.insert(id, node_trait_method(@*tm, d_id, item_path));\n             }\n@@ -387,14 +387,14 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n         fmt!(\"method %s in %s (id=%?)\",\n              *itr.get(m.ident), path_to_str(*path, itr), id)\n       }\n-      Some(node_trait_method(tm, _, path)) => {\n-        let m = ast_util::trait_method_to_ty_method(*tm);\n+      Some(node_trait_method(ref tm, _, path)) => {\n+        let m = ast_util::trait_method_to_ty_method(&**tm);\n         fmt!(\"method %s in %s (id=%?)\",\n              *itr.get(m.ident), path_to_str(*path, itr), id)\n       }\n       Some(node_variant(ref variant, _, path)) => {\n         fmt!(\"variant %s in %s (id=%?)\",\n-             *itr.get((*variant).node.name), path_to_str(*path, itr), id)\n+             *itr.get(variant.node.name), path_to_str(*path, itr), id)\n       }\n       Some(node_expr(expr)) => {\n         fmt!(\"expr %s (id=%?)\", pprust::expr_to_str(expr, itr), id)"}, {"sha": "7bf08aaaf76fc3ece1ff257b7d78167fdd8119e5", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -260,9 +260,9 @@ pub fn public_methods(ms: ~[@method]) -> ~[@method] {\n \n // extract a ty_method from a trait_method. if the trait_method is\n // a default, pull out the useful fields to make a ty_method\n-pub fn trait_method_to_ty_method(method: trait_method) -> ty_method {\n-    match method {\n-        required(ref m) => (*m),\n+pub fn trait_method_to_ty_method(method: &trait_method) -> ty_method {\n+    match *method {\n+        required(ref m) => copy *m,\n         provided(ref m) => {\n             ty_method {\n                 ident: m.ident,\n@@ -278,7 +278,7 @@ pub fn trait_method_to_ty_method(method: trait_method) -> ty_method {\n     }\n }\n \n-pub fn split_trait_methods(trait_methods: ~[trait_method])\n+pub fn split_trait_methods(trait_methods: &[trait_method])\n     -> (~[ty_method], ~[@method]) {\n     let mut reqd = ~[], provd = ~[];\n     for trait_methods.each |trt_method| {\n@@ -425,15 +425,15 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             vfn(l.node.id);\n         },\n \n-        visit_block: fn@(b: blk) {\n+        visit_block: fn@(b: &blk) {\n             vfn(b.node.id);\n         },\n \n         visit_stmt: fn@(s: @stmt) {\n             vfn(ast_util::stmt_id(*s));\n         },\n \n-        visit_arm: fn@(_a: arm) { },\n+        visit_arm: fn@(_a: &arm) { },\n \n         visit_pat: fn@(p: @pat) {\n             vfn(p.id)\n@@ -463,8 +463,8 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             }\n         },\n \n-        visit_fn: fn@(fk: &visit::fn_kind, d: ast::fn_decl,\n-                      _b: ast::blk, _sp: span, id: ast::node_id) {\n+        visit_fn: fn@(fk: &visit::fn_kind, d: &ast::fn_decl,\n+                      _b: &ast::blk, _sp: span, id: ast::node_id) {\n             vfn(id);\n \n             match *fk {\n@@ -491,10 +491,10 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             }\n         },\n \n-        visit_ty_method: fn@(_ty_m: ty_method) {\n+        visit_ty_method: fn@(_ty_m: &ty_method) {\n         },\n \n-        visit_trait_method: fn@(_ty_m: trait_method) {\n+        visit_trait_method: fn@(_ty_m: &trait_method) {\n         },\n \n         visit_struct_def: fn@(_sd: @struct_def, _id: ident, _tps: &[ty_param],"}, {"sha": "5b2d6f7600b54005bbed12e26578013be09d6875", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -183,28 +183,28 @@ pub fn contains(haystack: &[@ast::meta_item],\n }\n \n fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n-    return match a.node {\n-          ast::meta_word(ref na) => match b.node {\n+    match a.node {\n+        ast::meta_word(ref na) => match b.node {\n             ast::meta_word(ref nb) => (*na) == (*nb),\n             _ => false\n-          },\n-          ast::meta_name_value(ref na, va) => match b.node {\n+        },\n+        ast::meta_name_value(ref na, va) => match b.node {\n             ast::meta_name_value(ref nb, vb) => {\n                 (*na) == (*nb) && va.node == vb.node\n             }\n             _ => false\n-          },\n-          ast::meta_list(ref na, misa) => match b.node {\n-            ast::meta_list(ref nb, misb) => {\n+        },\n+        ast::meta_list(ref na, ref misa) => match b.node {\n+            ast::meta_list(ref nb, ref misb) => {\n                 if na != nb { return false; }\n-                for misa.each |&mi| {\n-                    if !contains(misb, mi) { return false; }\n+                for misa.each |mi| {\n+                    if !misb.contains(mi) { return false; }\n                 }\n                 true\n             }\n             _ => false\n-          }\n         }\n+    }\n }\n \n pub fn contains_name(metas: &[@ast::meta_item], name: &str) -> bool {\n@@ -260,21 +260,23 @@ pub fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: &str)\n \n /* Higher-level applications */\n \n-pub fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n+pub fn sort_meta_items(items: &[@ast::meta_item]) -> ~[@ast::meta_item] {\n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let mut v = items;\n+    let mut v = vec::from_slice(items);\n     do std::sort::quick_sort(v) |ma, mb| {\n         get_meta_item_name(*ma) <= get_meta_item_name(*mb)\n     }\n \n     // There doesn't seem to be a more optimal way to do this\n-    do v.map |&m| {\n+    do v.map |m| {\n         match m.node {\n-          ast::meta_list(n, mis) => @spanned {\n-              node: ast::meta_list(n, sort_meta_items(mis)),\n-              .. *m\n-          },\n-          _ => m\n+            ast::meta_list(n, ref mis) => {\n+                @spanned {\n+                    node: ast::meta_list(n, sort_meta_items(*mis)),\n+                    .. /*bad*/ copy **m\n+                }\n+            }\n+            _ => /*bad*/ copy *m\n         }\n     }\n }"}, {"sha": "d26b566ecf67a4c72856edbf582448ed73d75c29", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 69, "deletions": 62, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -24,63 +24,71 @@ use core::vec;\n use std::oldmap::HashMap;\n \n pub fn expand_expr(exts: SyntaxExtensions, cx: ext_ctxt,\n-                   e: expr_, s: span, fld: ast_fold,\n-                   orig: fn@(expr_, span, ast_fold) -> (expr_, span))\n+                   e: &expr_, s: span, fld: ast_fold,\n+                   orig: fn@(&expr_, span, ast_fold) -> (expr_, span))\n                 -> (expr_, span) {\n-    return match e {\n-      // expr_mac should really be expr_ext or something; it's the\n-      // entry-point for all syntax extensions.\n-          expr_mac(ref mac) => {\n-\n+    match *e {\n+        // expr_mac should really be expr_ext or something; it's the\n+        // entry-point for all syntax extensions.\n+        expr_mac(ref mac) => {\n             match (*mac).node {\n-\n-              // Token-tree macros, these will be the only case when we're\n-              // finished transitioning.\n-              mac_invoc_tt(pth, ref tts) => {\n-                assert (vec::len(pth.idents) == 1u);\n-                /* using idents and token::special_idents would make the\n-                the macro names be hygienic */\n-                let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-                match exts.find(&extname) {\n-                  None => {\n-                    cx.span_fatal(pth.span,\n-                                  fmt!(\"macro undefined: '%s'\", *extname))\n-                  }\n-                  Some(NormalTT(SyntaxExpanderTT{expander: exp,\n-                                                 span: exp_sp})) => {\n-                    cx.bt_push(ExpandedFrom(CallInfo{\n-                        call_site: s,\n-                        callee: NameAndSpan {\n-                            name: *extname, span: exp_sp\n+                // Token-tree macros, these will be the only case when we're\n+                // finished transitioning.\n+                mac_invoc_tt(pth, ref tts) => {\n+                    assert (vec::len(pth.idents) == 1u);\n+                    /* using idents and token::special_idents would make the\n+                    the macro names be hygienic */\n+                    let extname = cx.parse_sess().interner.get(pth.idents[0]);\n+                    match exts.find(&extname) {\n+                        None => {\n+                            cx.span_fatal(\n+                                pth.span,\n+                                fmt!(\"macro undefined: '%s'\", *extname))\n                         }\n-                    }));\n-\n-                    let expanded = match exp(cx, (*mac).span, (*tts)) {\n-                      MRExpr(e) => e,\n-                      MRAny(expr_maker,_,_) => expr_maker(),\n-                      _ => cx.span_fatal(\n-                          pth.span, fmt!(\"non-expr macro in expr pos: %s\",\n-                                         *extname))\n-                    };\n-\n-                    //keep going, outside-in\n-                    let fully_expanded = fld.fold_expr(expanded).node;\n-                    cx.bt_pop();\n-\n-                    (fully_expanded, s)\n-                  }\n-                  _ => {\n-                    cx.span_fatal(pth.span,\n-                                  fmt!(\"'%s' is not a tt-style macro\",\n-                                       *extname))\n-                  }\n-\n+                        Some(NormalTT(SyntaxExpanderTT{\n+                            expander: exp,\n+                            span: exp_sp\n+                        })) => {\n+                            cx.bt_push(ExpandedFrom(CallInfo {\n+                                call_site: s,\n+                                callee: NameAndSpan {\n+                                    name: *extname,\n+                                    span: exp_sp,\n+                                },\n+                            }));\n+\n+                            let expanded = match exp(cx, mac.span, *tts) {\n+                                MRExpr(e) => e,\n+                                MRAny(expr_maker,_,_) => expr_maker(),\n+                                _ => {\n+                                    cx.span_fatal(\n+                                        pth.span,\n+                                        fmt!(\n+                                            \"non-expr macro in expr pos: %s\",\n+                                            *extname\n+                                        )\n+                                    )\n+                                }\n+                            };\n+\n+                            //keep going, outside-in\n+                            let fully_expanded = fld.fold_expr(expanded).node;\n+                            cx.bt_pop();\n+\n+                            (fully_expanded, s)\n+                        }\n+                        _ => {\n+                            cx.span_fatal(\n+                                pth.span,\n+                                fmt!(\"'%s' is not a tt-style macro\", *extname)\n+                            )\n+                        }\n+                    }\n                 }\n-              }\n             }\n-          }\n-          _ => orig(e, s, fld)\n-        };\n+        }\n+        _ => orig(e, s, fld)\n+    }\n }\n \n // This is a secondary mechanism for invoking syntax extensions on items:\n@@ -93,8 +101,8 @@ pub fn expand_expr(exts: SyntaxExtensions, cx: ext_ctxt,\n // NB: there is some redundancy between this and expand_item, below, and\n // they might benefit from some amount of semantic and language-UI merger.\n pub fn expand_mod_items(exts: SyntaxExtensions, cx: ext_ctxt,\n-                        module_: ast::_mod, fld: ast_fold,\n-                        orig: fn@(ast::_mod, ast_fold) -> ast::_mod)\n+                        module_: &ast::_mod, fld: ast_fold,\n+                        orig: fn@(&ast::_mod, ast_fold) -> ast::_mod)\n                      -> ast::_mod {\n     // Fold the contents first:\n     let module_ = orig(module_, fld);\n@@ -130,8 +138,8 @@ pub fn expand_mod_items(exts: SyntaxExtensions, cx: ext_ctxt,\n \n // When we enter a module, record it, for the sake of `module!`\n pub fn expand_item(exts: SyntaxExtensions,\n-                   cx: ext_ctxt, &&it: @ast::item, fld: ast_fold,\n-                   orig: fn@(&&v: @ast::item, ast_fold) -> Option<@ast::item>)\n+                   cx: ext_ctxt, it: @ast::item, fld: ast_fold,\n+                   orig: fn@(@ast::item, ast_fold) -> Option<@ast::item>)\n                 -> Option<@ast::item> {\n     let is_mod = match it.node {\n       ast::item_mod(_) | ast::item_foreign_mod(_) => true,\n@@ -223,13 +231,13 @@ pub fn expand_item_mac(exts: SyntaxExtensions,\n }\n \n pub fn expand_stmt(exts: SyntaxExtensions, cx: ext_ctxt,\n-                   && s: stmt_, sp: span, fld: ast_fold,\n-                   orig: fn@(&&s: stmt_, span, ast_fold) -> (stmt_, span))\n+                   s: &stmt_, sp: span, fld: ast_fold,\n+                   orig: fn@(s: &stmt_, span, ast_fold) -> (stmt_, span))\n                 -> (stmt_, span) {\n \n-    let (mac, pth, tts, semi) = match s {\n+    let (mac, pth, tts, semi) = match *s {\n         stmt_mac(ref mac, semi) => {\n-            match (*mac).node {\n+            match mac.node {\n                 mac_invoc_tt(pth, ref tts) => ((*mac), pth, (*tts), semi)\n             }\n         }\n@@ -361,8 +369,7 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     // as it registers all the core macros as expanders.\n     f.fold_expr(cm);\n \n-    let res = @f.fold_crate(*c);\n-    return res;\n+    @f.fold_crate(&*c)\n }\n // Local Variables:\n // mode: rust"}, {"sha": "e74376afb08314d0009427b918b2a53633d3b7dc", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 465, "deletions": 384, "changes": 849, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -18,27 +18,27 @@ use core::option;\n use core::vec;\n \n pub trait ast_fold {\n-    fn fold_crate(crate) -> crate;\n-    fn fold_view_item(&&v: @view_item) -> @view_item;\n-    fn fold_foreign_item(&&v: @foreign_item) -> @foreign_item;\n-    fn fold_item(&&v: @item) -> Option<@item>;\n-    fn fold_struct_field(&&v: @struct_field) -> @struct_field;\n-    fn fold_item_underscore(item_) -> item_;\n-    fn fold_method(&&v: @method) -> @method;\n-    fn fold_block(blk) -> blk;\n-    fn fold_stmt(&&v: @stmt) -> @stmt;\n-    fn fold_arm(arm) -> arm;\n-    fn fold_pat(&&v: @pat) -> @pat;\n-    fn fold_decl(&&v: @decl) -> @decl;\n-    fn fold_expr(&&v: @expr) -> @expr;\n-    fn fold_ty(&&v: @Ty) -> @Ty;\n-    fn fold_mod(_mod) -> _mod;\n-    fn fold_foreign_mod(foreign_mod) -> foreign_mod;\n-    fn fold_variant(variant) -> variant;\n-    fn fold_ident(&&v: ident) -> ident;\n-    fn fold_path(&&v: @path) -> @path;\n-    fn fold_local(&&v: @local) -> @local;\n-    fn map_exprs(fn@(&&v: @expr) -> @expr, ~[@expr]) -> ~[@expr];\n+    fn fold_crate(&crate) -> crate;\n+    fn fold_view_item(@view_item) -> @view_item;\n+    fn fold_foreign_item(@foreign_item) -> @foreign_item;\n+    fn fold_item(@item) -> Option<@item>;\n+    fn fold_struct_field(@struct_field) -> @struct_field;\n+    fn fold_item_underscore(&item_) -> item_;\n+    fn fold_method(@method) -> @method;\n+    fn fold_block(&blk) -> blk;\n+    fn fold_stmt(&stmt) -> @stmt;\n+    fn fold_arm(&arm) -> arm;\n+    fn fold_pat(@pat) -> @pat;\n+    fn fold_decl(@decl) -> @decl;\n+    fn fold_expr(@expr) -> @expr;\n+    fn fold_ty(@Ty) -> @Ty;\n+    fn fold_mod(&_mod) -> _mod;\n+    fn fold_foreign_mod(&foreign_mod) -> foreign_mod;\n+    fn fold_variant(&variant) -> variant;\n+    fn fold_ident(ident) -> ident;\n+    fn fold_path(@path) -> @path;\n+    fn fold_local(@local) -> @local;\n+    fn map_exprs(fn@(@expr) -> @expr, &[@expr]) -> ~[@expr];\n     fn new_id(node_id) -> node_id;\n     fn new_span(span) -> span;\n }\n@@ -47,27 +47,27 @@ pub trait ast_fold {\n \n pub struct AstFoldFns {\n     //unlike the others, item_ is non-trivial\n-    fold_crate: fn@(crate_, span, ast_fold) -> (crate_, span),\n+    fold_crate: fn@(&crate_, span, ast_fold) -> (crate_, span),\n     fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n-    fold_foreign_item: fn@(&&v: @foreign_item, ast_fold) -> @foreign_item,\n-    fold_item: fn@(&&v: @item, ast_fold) -> Option<@item>,\n-    fold_struct_field: fn@(&&v: @struct_field, ast_fold) -> @struct_field,\n-    fold_item_underscore: fn@(item_, ast_fold) -> item_,\n-    fold_method: fn@(&&v: @method, ast_fold) -> @method,\n-    fold_block: fn@(blk_, span, ast_fold) -> (blk_, span),\n-    fold_stmt: fn@(stmt_, span, ast_fold) -> (stmt_, span),\n-    fold_arm: fn@(arm, ast_fold) -> arm,\n-    fold_pat: fn@(pat_, span, ast_fold) -> (pat_, span),\n-    fold_decl: fn@(decl_, span, ast_fold) -> (decl_, span),\n-    fold_expr: fn@(expr_, span, ast_fold) -> (expr_, span),\n-    fold_ty: fn@(ty_, span, ast_fold) -> (ty_, span),\n-    fold_mod: fn@(_mod, ast_fold) -> _mod,\n-    fold_foreign_mod: fn@(foreign_mod, ast_fold) -> foreign_mod,\n-    fold_variant: fn@(variant_, span, ast_fold) -> (variant_, span),\n-    fold_ident: fn@(&&v: ident, ast_fold) -> ident,\n-    fold_path: fn@(path, ast_fold) -> path,\n-    fold_local: fn@(local_, span, ast_fold) -> (local_, span),\n-    map_exprs: fn@(fn@(&&v: @expr) -> @expr, ~[@expr]) -> ~[@expr],\n+    fold_foreign_item: fn@(@foreign_item, ast_fold) -> @foreign_item,\n+    fold_item: fn@(@item, ast_fold) -> Option<@item>,\n+    fold_struct_field: fn@(@struct_field, ast_fold) -> @struct_field,\n+    fold_item_underscore: fn@(&item_, ast_fold) -> item_,\n+    fold_method: fn@(@method, ast_fold) -> @method,\n+    fold_block: fn@(&blk_, span, ast_fold) -> (blk_, span),\n+    fold_stmt: fn@(&stmt_, span, ast_fold) -> (stmt_, span),\n+    fold_arm: fn@(&arm, ast_fold) -> arm,\n+    fold_pat: fn@(&pat_, span, ast_fold) -> (pat_, span),\n+    fold_decl: fn@(&decl_, span, ast_fold) -> (decl_, span),\n+    fold_expr: fn@(&expr_, span, ast_fold) -> (expr_, span),\n+    fold_ty: fn@(&ty_, span, ast_fold) -> (ty_, span),\n+    fold_mod: fn@(&_mod, ast_fold) -> _mod,\n+    fold_foreign_mod: fn@(&foreign_mod, ast_fold) -> foreign_mod,\n+    fold_variant: fn@(&variant_, span, ast_fold) -> (variant_, span),\n+    fold_ident: fn@(ident, ast_fold) -> ident,\n+    fold_path: fn@(@path, ast_fold) -> path,\n+    fold_local: fn@(&local_, span, ast_fold) -> (local_, span),\n+    map_exprs: fn@(fn@(@expr) -> @expr, &[@expr]) -> ~[@expr],\n     new_id: fn@(node_id) -> node_id,\n     new_span: fn@(span) -> span\n }\n@@ -77,18 +77,20 @@ pub type ast_fold_fns = @AstFoldFns;\n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n+fn fold_meta_item_(mi: @meta_item, fld: ast_fold) -> @meta_item {\n     @spanned {\n         node:\n             match mi.node {\n-                meta_word(ref id) => meta_word((*id)),\n-                meta_list(ref id, ref mis) => {\n+                meta_word(id) => meta_word(id),\n+                meta_list(id, ref mis) => {\n                     let fold_meta_item = |x| fold_meta_item_(x, fld);\n-                    meta_list(/* FIXME: (#2543) */ copy *id,\n-                              mis.map(|e| fold_meta_item(*e)))\n+                    meta_list(\n+                        id,\n+                        mis.map(|e| fold_meta_item(*e))\n+                    )\n                 }\n-                meta_name_value(ref id, s) => {\n-                    meta_name_value((*id), /* FIXME (#2543) */ copy s)\n+                meta_name_value(id, s) => {\n+                    meta_name_value(id, /* FIXME (#2543) */ copy s)\n                 }\n             },\n         span: fld.new_span(mi.span) }\n@@ -116,43 +118,48 @@ fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n }\n //used in noop_fold_expr, and possibly elsewhere in the future\n fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n-    spanned { node: match m.node {\n-                        mac_invoc_tt(*) => m.node,\n-                    },\n-              span: fld.new_span(m.span) }\n+    spanned {\n+        node: match m.node { mac_invoc_tt(*) => copy m.node },\n+        span: fld.new_span(m.span),\n+    }\n }\n \n-pub fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n+pub fn fold_fn_decl(decl: &ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n     ast::fn_decl {\n         inputs: decl.inputs.map(|x| fold_arg_(*x, fld)),\n         output: fld.fold_ty(decl.output),\n         cf: decl.cf,\n     }\n }\n \n-fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n-    match tpb {\n+fn fold_ty_param_bound(\n+    tpb: &ty_param_bound,\n+    fld: ast_fold\n+) -> ty_param_bound {\n+    match *tpb {\n         TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_ty(ty)),\n         RegionTyParamBound => RegionTyParamBound\n     }\n }\n \n-pub fn fold_ty_param(tp: ty_param, fld: ast_fold) -> ty_param {\n-    ast::ty_param { ident: /* FIXME (#2543) */ copy tp.ident,\n-                    id: fld.new_id(tp.id),\n-                    bounds: @tp.bounds.map(|x| fold_ty_param_bound(*x, fld) )}\n+pub fn fold_ty_param(tp: &ty_param, fld: ast_fold) -> ty_param {\n+    ast::ty_param {\n+        ident: /* FIXME (#2543) */ copy tp.ident,\n+        id: fld.new_id(tp.id),\n+        bounds: @tp.bounds.map(|x| fold_ty_param_bound(x, fld)),\n+    }\n }\n \n-pub fn fold_ty_params(tps: ~[ty_param], fld: ast_fold) -> ~[ty_param] {\n-    tps.map(|x| fold_ty_param(*x, fld))\n+pub fn fold_ty_params(tps: &[ty_param], fld: ast_fold) -> ~[ty_param] {\n+    tps.map(|x| fold_ty_param(x, fld))\n }\n \n-pub fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n+pub fn noop_fold_crate(c: &crate_, fld: ast_fold) -> crate_ {\n     let fold_meta_item = |x| fold_meta_item_(x, fld);\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n     crate_ {\n-        module: fld.fold_mod(c.module),\n+        module: fld.fold_mod(&c.module),\n         attrs: c.attrs.map(|x| fold_attribute(*x)),\n         config: c.config.map(|x| fold_meta_item(*x)),\n     }\n@@ -163,25 +170,25 @@ fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n }\n \n \n-fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n+fn noop_fold_foreign_item(ni: @foreign_item, fld: ast_fold)\n     -> @foreign_item {\n     let fold_arg = |x| fold_arg_(x, fld);\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n     @ast::foreign_item {\n         ident: fld.fold_ident(ni.ident),\n-        attrs: vec::map(ni.attrs, |x| fold_attribute(*x)),\n+        attrs: ni.attrs.map(|x| fold_attribute(*x)),\n         node:\n             match ni.node {\n-                foreign_item_fn(fdec, purity, typms) => {\n+                foreign_item_fn(ref fdec, purity, ref tps) => {\n                     foreign_item_fn(\n                         ast::fn_decl {\n                             inputs: fdec.inputs.map(|a| fold_arg(*a)),\n                             output: fld.fold_ty(fdec.output),\n                             cf: fdec.cf,\n                         },\n                         purity,\n-                        fold_ty_params(typms, fld))\n+                        fold_ty_params(*tps, fld))\n                 }\n                 foreign_item_const(t) => {\n                     foreign_item_const(fld.fold_ty(t))\n@@ -193,57 +200,70 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n     }\n }\n \n-pub fn noop_fold_item(&&i: @item, fld: ast_fold) -> Option<@item> {\n+pub fn noop_fold_item(i: @item, fld: ast_fold) -> Option<@item> {\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n     Some(@ast::item { ident: fld.fold_ident(i.ident),\n                       attrs: i.attrs.map(|e| fold_attribute(*e)),\n                       id: fld.new_id(i.id),\n-                      node: fld.fold_item_underscore(i.node),\n+                      node: fld.fold_item_underscore(&i.node),\n                       vis: i.vis,\n                       span: fld.new_span(i.span) })\n }\n \n-fn noop_fold_struct_field(&&sf: @struct_field, fld: ast_fold)\n+fn noop_fold_struct_field(sf: @struct_field, fld: ast_fold)\n                        -> @struct_field {\n     @spanned { node: ast::struct_field_ { kind: copy sf.node.kind,\n                                           id: sf.node.id,\n                                           ty: fld.fold_ty(sf.node.ty) },\n                span: sf.span }\n }\n \n-pub fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n-    match i {\n-        item_const(t, e) => item_const(fld.fold_ty(t), fld.fold_expr(e)),\n-        item_fn(ref decl, purity, ref typms, ref body) => {\n-            item_fn(fold_fn_decl(/* FIXME (#2543) */ copy *decl, fld),\n-                    purity,\n-                    fold_ty_params(/* FIXME (#2543) */ copy *typms, fld),\n-                    fld.fold_block(*body))\n-        }\n-        item_mod(m) => item_mod(fld.fold_mod(m)),\n-        item_foreign_mod(nm) => item_foreign_mod(fld.fold_foreign_mod(nm)),\n-        item_ty(t, typms) => item_ty(fld.fold_ty(t),\n-                                     fold_ty_params(typms, fld)),\n-        item_enum(ref enum_definition, ref typms) => {\n-            item_enum(ast::enum_def(ast::enum_def_ {\n-                variants: enum_definition.variants.map(\n-                    |x| fld.fold_variant(*x)),\n-                common: enum_definition.common.map(\n-                    |x| fold_struct_def(*x, fld)),\n-            }), fold_ty_params(/* FIXME (#2543) */ copy *typms, fld))\n-        }\n-        item_struct(ref struct_def, ref typms) => {\n-            let struct_def = fold_struct_def(\n-                /* FIXME (#2543) */ copy *struct_def,\n-                fld);\n-            item_struct(struct_def, /* FIXME (#2543) */ copy *typms)\n+pub fn noop_fold_item_underscore(i: &item_, fld: ast_fold) -> item_ {\n+    match *i {\n+        item_const(t, e) => {\n+            item_const(fld.fold_ty(t), fld.fold_expr(e))\n+        }\n+        item_fn(ref decl, purity, ref tps, ref body) => {\n+            item_fn(\n+                fold_fn_decl(decl, fld),\n+                purity,\n+                fold_ty_params(*tps, fld),\n+                fld.fold_block(body)\n+            )\n+        }\n+        item_mod(ref m) => item_mod(fld.fold_mod(m)),\n+        item_foreign_mod(ref nm) => {\n+            item_foreign_mod(fld.fold_foreign_mod(nm))\n+        }\n+        item_ty(t, ref tps) => {\n+            item_ty(fld.fold_ty(t), fold_ty_params(*tps, fld))\n+        }\n+        item_enum(ref enum_definition, ref tps) => {\n+            item_enum(\n+                ast::enum_def(\n+                    ast::enum_def_ {\n+                        variants: do enum_definition.variants.map |x| {\n+                            fld.fold_variant(x)\n+                        },\n+                        common: do enum_definition.common.map |x| {\n+                            fold_struct_def(*x, fld)\n+                        }\n+                    }\n+                ),\n+                fold_ty_params(*tps, fld))\n+        }\n+        item_struct(ref struct_def, ref tps) => {\n+            let struct_def = fold_struct_def(*struct_def, fld);\n+            item_struct(struct_def, /* FIXME (#2543) */ copy *tps)\n         }\n         item_impl(ref tps, ifce, ty, ref methods) => {\n-            item_impl(fold_ty_params(/* FIXME (#2543) */ copy *tps, fld),\n-                      ifce.map(|p| fold_trait_ref(*p, fld)),\n-                      fld.fold_ty(ty),\n-                      methods.map(|x| fld.fold_method(*x)))\n+            item_impl(\n+                fold_ty_params(*tps, fld),\n+                ifce.map(|p| fold_trait_ref(*p, fld)),\n+                fld.fold_ty(ty),\n+                methods.map(|x| fld.fold_method(*x))\n+            )\n         }\n         item_trait(ref tps, ref traits, ref methods) => {\n             let methods = do methods.map |method| {\n@@ -252,9 +272,11 @@ pub fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                     provided(method) => provided(fld.fold_method(method))\n                 }\n             };\n-            item_trait(fold_ty_params(/* FIXME (#2543) */ copy *tps, fld),\n-                       traits.map(|p| fold_trait_ref(*p, fld)),\n-                       methods)\n+            item_trait(\n+                fold_ty_params(*tps, fld),\n+                traits.map(|p| fold_trait_ref(*p, fld)),\n+                methods\n+            )\n         }\n         item_mac(ref m) => {\n             // FIXME #2888: we might actually want to do something here.\n@@ -266,12 +288,16 @@ pub fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n                 -> @ast::struct_def {\n     let dtor = do option::map(&struct_def.dtor) |dtor| {\n-        let dtor_body = fld.fold_block(dtor.node.body);\n+        let dtor_body = fld.fold_block(&dtor.node.body);\n         let dtor_id   = fld.new_id(dtor.node.id);\n-        spanned { node: ast::struct_dtor_ { body: dtor_body,\n-                                            id: dtor_id,\n-                                            .. dtor.node},\n-                  span: dtor.span }\n+        spanned {\n+            node: ast::struct_dtor_ {\n+                body: dtor_body,\n+                id: dtor_id,\n+                .. copy dtor.node\n+            },\n+            span: copy dtor.span\n+        }\n     };\n     @ast::struct_def {\n         fields: struct_def.fields.map(|f| fold_struct_field(*f, fld)),\n@@ -280,29 +306,33 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n     }\n }\n \n-fn fold_trait_ref(&&p: @trait_ref, fld: ast_fold) -> @trait_ref {\n+fn fold_trait_ref(p: @trait_ref, fld: ast_fold) -> @trait_ref {\n     @ast::trait_ref {\n         path: fld.fold_path(p.path),\n         ref_id: fld.new_id(p.ref_id),\n     }\n }\n \n-fn fold_struct_field(&&f: @struct_field, fld: ast_fold) -> @struct_field {\n-    @spanned { node: ast::struct_field_ { kind: copy f.node.kind,\n-                                          id: fld.new_id(f.node.id),\n-                                          ty: fld.fold_ty(f.node.ty) },\n-               span: fld.new_span(f.span) }\n+fn fold_struct_field(f: @struct_field, fld: ast_fold) -> @struct_field {\n+    @spanned {\n+        node: ast::struct_field_ {\n+            kind: copy f.node.kind,\n+            id: fld.new_id(f.node.id),\n+            ty: fld.fold_ty(f.node.ty),\n+        },\n+        span: fld.new_span(f.span),\n+    }\n }\n \n-fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n+fn noop_fold_method(m: @method, fld: ast_fold) -> @method {\n     @ast::method {\n         ident: fld.fold_ident(m.ident),\n         attrs: /* FIXME (#2543) */ copy m.attrs,\n         tps: fold_ty_params(m.tps, fld),\n         self_ty: m.self_ty,\n         purity: m.purity,\n-        decl: fold_fn_decl(m.decl, fld),\n-        body: fld.fold_block(m.body),\n+        decl: fold_fn_decl(&m.decl, fld),\n+        body: fld.fold_block(&m.body),\n         id: fld.new_id(m.id),\n         span: fld.new_span(m.span),\n         self_id: fld.new_id(m.self_id),\n@@ -311,7 +341,7 @@ fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n }\n \n \n-pub fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n+pub fn noop_fold_block(b: &blk_, fld: ast_fold) -> blk_ {\n     ast::blk_ {\n         view_items: b.view_items.map(|x| fld.fold_view_item(*x)),\n         stmts: b.stmts.map(|x| fld.fold_stmt(*x)),\n@@ -321,47 +351,51 @@ pub fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n     }\n }\n \n-fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n+fn noop_fold_stmt(s: &stmt_, fld: ast_fold) -> stmt_ {\n     let fold_mac = |x| fold_mac_(x, fld);\n-    return match s {\n-      stmt_decl(d, nid) => stmt_decl(fld.fold_decl(d), fld.new_id(nid)),\n-      stmt_expr(e, nid) => stmt_expr(fld.fold_expr(e), fld.new_id(nid)),\n-      stmt_semi(e, nid) => stmt_semi(fld.fold_expr(e), fld.new_id(nid)),\n-      stmt_mac(ref mac, semi) => stmt_mac(fold_mac((*mac)), semi)\n-    };\n+    match *s {\n+        stmt_decl(d, nid) => stmt_decl(fld.fold_decl(d), fld.new_id(nid)),\n+        stmt_expr(e, nid) => stmt_expr(fld.fold_expr(e), fld.new_id(nid)),\n+        stmt_semi(e, nid) => stmt_semi(fld.fold_expr(e), fld.new_id(nid)),\n+        stmt_mac(ref mac, semi) => stmt_mac(fold_mac((*mac)), semi)\n+    }\n }\n \n-fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n+fn noop_fold_arm(a: &arm, fld: ast_fold) -> arm {\n     arm {\n-        pats: vec::map(a.pats, |x| fld.fold_pat(*x)),\n-        guard: option::map(&a.guard, |x| fld.fold_expr(*x)),\n-        body: fld.fold_block(a.body),\n-    }\n-}\n-\n-pub fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n-    return match p {\n-          pat_wild => pat_wild,\n-          pat_ident(binding_mode, pth, sub) => {\n-            pat_ident(binding_mode,\n-                      fld.fold_path(pth),\n-                      option::map(&sub, |x| fld.fold_pat(*x)))\n-          }\n-          pat_lit(e) => pat_lit(fld.fold_expr(e)),\n-          pat_enum(pth, pats) => {\n-              pat_enum(fld.fold_path(pth), option::map(&pats,\n-                       |pats| vec::map(*pats, |x| fld.fold_pat(*x))))\n-          }\n-          pat_rec(fields, etc) => {\n+        pats: a.pats.map(|x| fld.fold_pat(*x)),\n+        guard: a.guard.map(|x| fld.fold_expr(*x)),\n+        body: fld.fold_block(&a.body),\n+    }\n+}\n+\n+pub fn noop_fold_pat(p: &pat_, fld: ast_fold) -> pat_ {\n+    match *p {\n+        pat_wild => pat_wild,\n+        pat_ident(binding_mode, pth, sub) => {\n+            pat_ident(\n+                binding_mode,\n+                fld.fold_path(pth),\n+                sub.map(|x| fld.fold_pat(*x))\n+            )\n+        }\n+        pat_lit(e) => pat_lit(fld.fold_expr(e)),\n+        pat_enum(pth, pats) => {\n+            pat_enum(\n+                fld.fold_path(pth),\n+                pats.map(|pats| pats.map(|x| fld.fold_pat(*x)))\n+            )\n+        }\n+        pat_rec(fields, etc) => {\n             let fs = do fields.map |f| {\n                 ast::field_pat {\n                     ident: /* FIXME (#2543) */ copy f.ident,\n                     pat: fld.fold_pat(f.pat),\n                 }\n             };\n             pat_rec(fs, etc)\n-          }\n-          pat_struct(pth, fields, etc) => {\n+        }\n+        pat_struct(pth, fields, etc) => {\n             let pth_ = fld.fold_path(pth);\n             let fs = do fields.map |f| {\n                 ast::field_pat {\n@@ -370,40 +404,44 @@ pub fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n                 }\n             };\n             pat_struct(pth_, fs, etc)\n-          }\n-          pat_tup(elts) => pat_tup(vec::map(elts, |x| fld.fold_pat(*x))),\n-          pat_box(inner) => pat_box(fld.fold_pat(inner)),\n-          pat_uniq(inner) => pat_uniq(fld.fold_pat(inner)),\n-          pat_region(inner) => pat_region(fld.fold_pat(inner)),\n-          pat_range(e1, e2) => {\n+        }\n+        pat_tup(ref elts) => pat_tup(elts.map(|x| fld.fold_pat(*x))),\n+        pat_box(inner) => pat_box(fld.fold_pat(inner)),\n+        pat_uniq(inner) => pat_uniq(fld.fold_pat(inner)),\n+        pat_region(inner) => pat_region(fld.fold_pat(inner)),\n+        pat_range(e1, e2) => {\n             pat_range(fld.fold_expr(e1), fld.fold_expr(e2))\n-          },\n-          pat_vec(elts, tail) => pat_vec(\n-            vec::map(elts, |x| fld.fold_pat(*x)),\n-            option::map(&tail, |tail| fld.fold_pat(*tail))\n-          )\n-        };\n+        },\n+        pat_vec(elts, tail) => {\n+            pat_vec(\n+                elts.map(|x| fld.fold_pat(*x)),\n+                tail.map(|tail| fld.fold_pat(*tail))\n+            )\n+        }\n+    }\n }\n \n-fn noop_fold_decl(d: decl_, fld: ast_fold) -> decl_ {\n-    match d {\n-      decl_local(ls) => decl_local(vec::map(ls, |x| fld.fold_local(*x))),\n-      decl_item(it) => match fld.fold_item(it) {\n-        Some(it_folded) => decl_item(it_folded),\n-        None => decl_local(~[])\n-      }\n+fn noop_fold_decl(d: &decl_, fld: ast_fold) -> decl_ {\n+    match *d {\n+        decl_local(ls) => decl_local(ls.map(|x| fld.fold_local(*x))),\n+        decl_item(it) => {\n+            match fld.fold_item(it) {\n+                Some(it_folded) => decl_item(it_folded),\n+                None => decl_local(~[]),\n+            }\n+        }\n     }\n }\n \n-pub fn wrap<T>(f: fn@(T, ast_fold) -> T)\n-    -> fn@(T, span, ast_fold) -> (T, span)\n+pub fn wrap<T>(f: fn@(&T, ast_fold) -> T)\n+    -> fn@(&T, span, ast_fold) -> (T, span)\n {\n-    return fn@(x: T, s: span, fld: ast_fold) -> (T, span) {\n+    fn@(x: &T, s: span, fld: ast_fold) -> (T, span) {\n         (f(x, fld), s)\n     }\n }\n \n-pub fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n+pub fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n     fn fold_field_(field: field, fld: ast_fold) -> field {\n         spanned {\n             node: ast::field_ {\n@@ -418,157 +456,196 @@ pub fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n \n     let fold_mac = |x| fold_mac_(x, fld);\n \n-    return match e {\n-          expr_vstore(e, v) => {\n+    match *e {\n+        expr_vstore(e, v) => {\n             expr_vstore(fld.fold_expr(e), v)\n-          }\n-          expr_vec(exprs, mutt) => {\n-            expr_vec(fld.map_exprs(|x| fld.fold_expr(x), exprs), mutt)\n-          }\n-          expr_repeat(expr, count, mutt) =>\n-            expr_repeat(fld.fold_expr(expr), fld.fold_expr(count), mutt),\n-          expr_rec(ref fields, maybe_expr) => {\n-            expr_rec(vec::map((*fields), |x| fold_field(*x)),\n-                     option::map(&maybe_expr, |x| fld.fold_expr(*x)))\n-          }\n-          expr_tup(elts) => expr_tup(vec::map(elts, |x| fld.fold_expr(*x))),\n-          expr_call(f, args, blk) => {\n-            expr_call(fld.fold_expr(f),\n-                      fld.map_exprs(|x| fld.fold_expr(x), args),\n-                      blk)\n-          }\n-          expr_method_call(f, i, tps, args, blk) => {\n-            expr_method_call(fld.fold_expr(f),\n-                             fld.fold_ident(i),\n-                             vec::map(tps, |x| fld.fold_ty(*x)),\n-                             fld.map_exprs(|x| fld.fold_expr(x), args),\n-                             blk)\n-          }\n-          expr_binary(binop, lhs, rhs) => {\n+        }\n+        expr_vec(ref exprs, mutt) => {\n+            expr_vec(fld.map_exprs(|x| fld.fold_expr(x), *exprs), mutt)\n+        }\n+        expr_repeat(expr, count, mutt) => {\n+            expr_repeat(fld.fold_expr(expr), fld.fold_expr(count), mutt)\n+        }\n+        expr_rec(ref fields, maybe_expr) => {\n+            expr_rec(\n+                fields.map(|x| fold_field(*x)),\n+                maybe_expr.map(|x| fld.fold_expr(*x))\n+            )\n+        }\n+        expr_tup(ref elts) => expr_tup(elts.map(|x| fld.fold_expr(*x))),\n+        expr_call(f, ref args, blk) => {\n+            expr_call(\n+                fld.fold_expr(f),\n+                fld.map_exprs(|x| fld.fold_expr(x), *args),\n+                blk\n+            )\n+        }\n+        expr_method_call(f, i, ref tps, ref args, blk) => {\n+            expr_method_call(\n+                fld.fold_expr(f),\n+                fld.fold_ident(i),\n+                tps.map(|x| fld.fold_ty(*x)),\n+                fld.map_exprs(|x| fld.fold_expr(x), *args),\n+                blk\n+            )\n+        }\n+        expr_binary(binop, lhs, rhs) => {\n             expr_binary(binop, fld.fold_expr(lhs), fld.fold_expr(rhs))\n-          }\n-          expr_unary(binop, ohs) => expr_unary(binop, fld.fold_expr(ohs)),\n-          expr_loop_body(f) => expr_loop_body(fld.fold_expr(f)),\n-          expr_do_body(f) => expr_do_body(fld.fold_expr(f)),\n-          expr_lit(_) => copy e,\n-          expr_cast(expr, ty) => expr_cast(fld.fold_expr(expr), ty),\n-          expr_addr_of(m, ohs) => expr_addr_of(m, fld.fold_expr(ohs)),\n-          expr_if(cond, ref tr, fl) => {\n-            expr_if(fld.fold_expr(cond), fld.fold_block((*tr)),\n-                    option::map(&fl, |x| fld.fold_expr(*x)))\n-          }\n-          expr_while(cond, ref body) => {\n-            expr_while(fld.fold_expr(cond), fld.fold_block((*body)))\n-          }\n-          expr_loop(ref body, opt_ident) => {\n-              expr_loop(fld.fold_block((*body)),\n-                        option::map(&opt_ident, |x| fld.fold_ident(*x)))\n-          }\n-          expr_match(expr, ref arms) => {\n-            expr_match(fld.fold_expr(expr),\n-                     vec::map((*arms), |x| fld.fold_arm(*x)))\n-          }\n-          expr_fn(proto, ref decl, ref body, _) => {\n-            expr_fn(proto,\n-                    fold_fn_decl(/* FIXME (#2543) */ copy *decl, fld),\n-                    fld.fold_block(*body),\n-                    @())\n-          }\n-          expr_fn_block(ref decl, ref body) => {\n-            expr_fn_block(fold_fn_decl(/* FIXME (#2543) */ copy *decl, fld),\n-                          fld.fold_block(*body))\n-          }\n-          expr_block(ref blk) => expr_block(fld.fold_block((*blk))),\n-          expr_copy(e) => expr_copy(fld.fold_expr(e)),\n-          expr_assign(el, er) => {\n+        }\n+        expr_unary(binop, ohs) => expr_unary(binop, fld.fold_expr(ohs)),\n+        expr_loop_body(f) => expr_loop_body(fld.fold_expr(f)),\n+        expr_do_body(f) => expr_do_body(fld.fold_expr(f)),\n+        expr_lit(_) => copy *e,\n+        expr_cast(expr, ty) => expr_cast(fld.fold_expr(expr), ty),\n+        expr_addr_of(m, ohs) => expr_addr_of(m, fld.fold_expr(ohs)),\n+        expr_if(cond, ref tr, fl) => {\n+            expr_if(\n+                fld.fold_expr(cond),\n+                fld.fold_block(tr),\n+                fl.map(|x| fld.fold_expr(*x))\n+            )\n+        }\n+        expr_while(cond, ref body) => {\n+            expr_while(fld.fold_expr(cond), fld.fold_block(body))\n+        }\n+        expr_loop(ref body, opt_ident) => {\n+            expr_loop(\n+                fld.fold_block(body),\n+                opt_ident.map(|x| fld.fold_ident(*x))\n+            )\n+        }\n+        expr_match(expr, ref arms) => {\n+            expr_match(\n+                fld.fold_expr(expr),\n+                arms.map(|x| fld.fold_arm(x))\n+            )\n+        }\n+        expr_fn(proto, ref decl, ref body, _) => {\n+            expr_fn(\n+                proto,\n+                fold_fn_decl(decl, fld),\n+                fld.fold_block(body),\n+                @()\n+            )\n+        }\n+        expr_fn_block(ref decl, ref body) => {\n+            expr_fn_block(\n+                fold_fn_decl(decl, fld),\n+                fld.fold_block(body)\n+            )\n+        }\n+        expr_block(ref blk) => expr_block(fld.fold_block(blk)),\n+        expr_copy(e) => expr_copy(fld.fold_expr(e)),\n+        expr_assign(el, er) => {\n             expr_assign(fld.fold_expr(el), fld.fold_expr(er))\n-          }\n-          expr_swap(el, er) => {\n+        }\n+        expr_swap(el, er) => {\n             expr_swap(fld.fold_expr(el), fld.fold_expr(er))\n-          }\n-          expr_assign_op(op, el, er) => {\n+        }\n+        expr_assign_op(op, el, er) => {\n             expr_assign_op(op, fld.fold_expr(el), fld.fold_expr(er))\n-          }\n-          expr_field(el, id, tys) => {\n-            expr_field(fld.fold_expr(el), fld.fold_ident(id),\n-                       vec::map(tys, |x| fld.fold_ty(*x)))\n-          }\n-          expr_index(el, er) => {\n+        }\n+        expr_field(el, id, ref tys) => {\n+            expr_field(\n+                fld.fold_expr(el), fld.fold_ident(id),\n+                tys.map(|x| fld.fold_ty(*x))\n+            )\n+        }\n+        expr_index(el, er) => {\n             expr_index(fld.fold_expr(el), fld.fold_expr(er))\n-          }\n-          expr_path(pth) => expr_path(fld.fold_path(pth)),\n-          expr_break(opt_ident) =>\n-            expr_break(option::map(&opt_ident, |x| fld.fold_ident(*x))),\n-          expr_again(opt_ident) =>\n-            expr_again(option::map(&opt_ident, |x| fld.fold_ident(*x))),\n-          expr_ret(e) => expr_ret(option::map(&e, |x| fld.fold_expr(*x))),\n-          expr_log(i, lv, e) => expr_log(i, fld.fold_expr(lv),\n-                                         fld.fold_expr(e)),\n-          expr_assert(e) => expr_assert(fld.fold_expr(e)),\n-          expr_mac(ref mac) => expr_mac(fold_mac((*mac))),\n-          expr_struct(path, ref fields, maybe_expr) => {\n-            expr_struct(fld.fold_path(path),\n-                        vec::map((*fields), |x| fold_field(*x)),\n-                        option::map(&maybe_expr, |x| fld.fold_expr(*x)))\n-          },\n-          expr_paren(ex) => expr_paren(fld.fold_expr(ex))\n-        }\n-}\n-\n-pub fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n+        }\n+        expr_path(pth) => expr_path(fld.fold_path(pth)),\n+        expr_break(ref opt_ident) => {\n+            expr_break(opt_ident.map(|x| fld.fold_ident(*x)))\n+        }\n+        expr_again(ref opt_ident) => {\n+            expr_again(opt_ident.map(|x| fld.fold_ident(*x)))\n+        }\n+        expr_ret(ref e) => {\n+            expr_ret(e.map(|x| fld.fold_expr(*x)))\n+        }\n+        expr_log(i, lv, e) => {\n+            expr_log(\n+                i,\n+                fld.fold_expr(lv),\n+                fld.fold_expr(e)\n+            )\n+        }\n+        expr_assert(e) => expr_assert(fld.fold_expr(e)),\n+        expr_mac(ref mac) => expr_mac(fold_mac((*mac))),\n+        expr_struct(path, ref fields, maybe_expr) => {\n+            expr_struct(\n+                fld.fold_path(path),\n+                fields.map(|x| fold_field(*x)),\n+                maybe_expr.map(|x| fld.fold_expr(*x))\n+            )\n+        },\n+        expr_paren(ex) => expr_paren(fld.fold_expr(ex))\n+    }\n+}\n+\n+pub fn noop_fold_ty(t: &ty_, fld: ast_fold) -> ty_ {\n     let fold_mac = |x| fold_mac_(x, fld);\n-    fn fold_mt(mt: mt, fld: ast_fold) -> mt {\n-        mt { ty: fld.fold_ty(mt.ty), mutbl: mt.mutbl }\n+    fn fold_mt(mt: &mt, fld: ast_fold) -> mt {\n+        mt {\n+            ty: fld.fold_ty(mt.ty),\n+            mutbl: mt.mutbl,\n+        }\n     }\n     fn fold_field(f: ty_field, fld: ast_fold) -> ty_field {\n         spanned {\n             node: ast::ty_field_ {\n                 ident: fld.fold_ident(f.node.ident),\n-                mt: fold_mt(f.node.mt, fld),\n+                mt: fold_mt(&f.node.mt, fld),\n             },\n             span: fld.new_span(f.span),\n         }\n     }\n-    match t {\n-      ty_nil | ty_bot | ty_infer => copy t,\n-      ty_box(mt) => ty_box(fold_mt(mt, fld)),\n-      ty_uniq(mt) => ty_uniq(fold_mt(mt, fld)),\n-      ty_vec(mt) => ty_vec(fold_mt(mt, fld)),\n-      ty_ptr(mt) => ty_ptr(fold_mt(mt, fld)),\n-      ty_rptr(region, mt) => ty_rptr(region, fold_mt(mt, fld)),\n-      ty_rec(ref fields) =>\n-        ty_rec(vec::map((*fields), |f| fold_field(*f, fld))),\n-      ty_closure(f) =>\n-        ty_closure(@TyClosure {\n-            sigil: f.sigil,\n-            purity: f.purity,\n-            region: f.region,\n-            onceness: f.onceness,\n-            decl: fold_fn_decl(f.decl, fld)\n-        }),\n-      ty_bare_fn(f) =>\n-        ty_bare_fn(@TyBareFn {\n-            purity: f.purity,\n-            abi: f.abi,\n-            decl: fold_fn_decl(f.decl, fld)\n-        }),\n-      ty_tup(tys) => ty_tup(vec::map(tys, |ty| fld.fold_ty(*ty))),\n-      ty_path(path, id) => ty_path(fld.fold_path(path), fld.new_id(id)),\n-      ty_fixed_length_vec(mt, vs) =>\n-        ty_fixed_length_vec(fold_mt(mt, fld), vs),\n-      ty_mac(ref mac) => ty_mac(fold_mac((*mac)))\n+    match *t {\n+        ty_nil | ty_bot | ty_infer => copy *t,\n+        ty_box(ref mt) => ty_box(fold_mt(mt, fld)),\n+        ty_uniq(ref mt) => ty_uniq(fold_mt(mt, fld)),\n+        ty_vec(ref mt) => ty_vec(fold_mt(mt, fld)),\n+        ty_ptr(ref mt) => ty_ptr(fold_mt(mt, fld)),\n+        ty_rptr(region, ref mt) => ty_rptr(region, fold_mt(mt, fld)),\n+        ty_rec(ref fields) => ty_rec(fields.map(|f| fold_field(*f, fld))),\n+        ty_closure(ref f) => {\n+            ty_closure(@TyClosure {\n+                sigil: f.sigil,\n+                purity: f.purity,\n+                region: f.region,\n+                onceness: f.onceness,\n+                decl: fold_fn_decl(&f.decl, fld)\n+            })\n+        }\n+        ty_bare_fn(ref f) => {\n+            ty_bare_fn(@TyBareFn {\n+                purity: f.purity,\n+                abi: f.abi,\n+                decl: fold_fn_decl(&f.decl, fld)\n+            })\n+        }\n+        ty_tup(ref tys) => ty_tup(tys.map(|ty| fld.fold_ty(*ty))),\n+        ty_path(path, id) => ty_path(fld.fold_path(path), fld.new_id(id)),\n+        ty_fixed_length_vec(ref mt, vs) => {\n+            ty_fixed_length_vec(\n+                fold_mt(mt, fld),\n+                vs\n+            )\n+        }\n+        ty_mac(ref mac) => ty_mac(fold_mac(*mac))\n     }\n }\n \n // ...nor do modules\n-pub fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n+pub fn noop_fold_mod(m: &_mod, fld: ast_fold) -> _mod {\n     ast::_mod {\n         view_items: vec::map(m.view_items, |x| fld.fold_view_item(*x)),\n         items: vec::filter_mapped(m.items, |x| fld.fold_item(*x)),\n     }\n }\n \n-fn noop_fold_foreign_mod(nm: foreign_mod, fld: ast_fold) -> foreign_mod {\n+fn noop_fold_foreign_mod(nm: &foreign_mod, fld: ast_fold) -> foreign_mod {\n     ast::foreign_mod {\n         sort: nm.sort,\n         abi: nm.abi,\n@@ -577,25 +654,31 @@ fn noop_fold_foreign_mod(nm: foreign_mod, fld: ast_fold) -> foreign_mod {\n     }\n }\n \n-fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n+fn noop_fold_variant(v: &variant_, fld: ast_fold) -> variant_ {\n     fn fold_variant_arg_(va: variant_arg, fld: ast_fold) -> variant_arg {\n         ast::variant_arg { ty: fld.fold_ty(va.ty), id: fld.new_id(va.id) }\n     }\n     let fold_variant_arg = |x| fold_variant_arg_(x, fld);\n \n     let kind;\n     match v.kind {\n-        tuple_variant_kind(variant_args) =>\n-            kind = tuple_variant_kind(vec::map(variant_args,\n-                                               |x| fold_variant_arg(*x))),\n+        tuple_variant_kind(ref variant_args) => {\n+            kind = tuple_variant_kind(do variant_args.map |x| {\n+                fold_variant_arg(*x)\n+            })\n+        }\n         struct_variant_kind(struct_def) => {\n             let dtor = do option::map(&struct_def.dtor) |dtor| {\n-                let dtor_body = fld.fold_block(dtor.node.body);\n+                let dtor_body = fld.fold_block(&dtor.node.body);\n                 let dtor_id   = fld.new_id(dtor.node.id);\n-                spanned { node: ast::struct_dtor_ { body: dtor_body,\n-                                                    id: dtor_id,\n-                                                    .. dtor.node},\n-                          .. *dtor }\n+                spanned {\n+                    node: ast::struct_dtor_ {\n+                        body: dtor_body,\n+                        id: dtor_id,\n+                        .. copy dtor.node\n+                    },\n+                    .. copy *dtor\n+                }\n             };\n             kind = struct_variant_kind(@ast::struct_def {\n                 fields: vec::map(struct_def.fields,\n@@ -604,12 +687,13 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n                 ctor_id: option::map(&struct_def.ctor_id, |c| fld.new_id(*c))\n             })\n         }\n-\n         enum_variant_kind(ref enum_definition) => {\n-            let variants = vec::map((*enum_definition).variants,\n-                                    |x| fld.fold_variant(*x));\n-            let common = option::map(&(*enum_definition).common,\n-                                     |x| fold_struct_def(*x, fld));\n+            let variants = do (*enum_definition).variants.map |x| {\n+                fld.fold_variant(x)\n+            };\n+            let common = do (*enum_definition).common.map |x| {\n+                fold_struct_def(*x, fld)\n+            };\n             kind = enum_variant_kind(\n                 ast::enum_def(ast::enum_def_ {\n                     variants: variants,\n@@ -620,7 +704,7 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     }\n \n     let fold_attribute = |x| fold_attribute_(x, fld);\n-    let attrs = vec::map(v.attrs, |x| fold_attribute(*x));\n+    let attrs = v.attrs.map(|x| fold_attribute(*x));\n \n     let de = match v.disr_expr {\n       Some(e) => Some(fld.fold_expr(e)),\n@@ -636,19 +720,19 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     }\n }\n \n-fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident {\n-    return /* FIXME (#2543) */ copy i;\n+fn noop_fold_ident(i: ident, _fld: ast_fold) -> ident {\n+    /* FIXME (#2543) */ copy i\n }\n \n-fn noop_fold_path(&&p: path, fld: ast_fold) -> path {\n+fn noop_fold_path(p: @path, fld: ast_fold) -> path {\n     ast::path { span: fld.new_span(p.span),\n                 global: p.global,\n                 idents: p.idents.map(|x| fld.fold_ident(*x)),\n                 rp: p.rp,\n                 types: p.types.map(|x| fld.fold_ty(*x)) }\n }\n \n-fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n+fn noop_fold_local(l: &local_, fld: ast_fold) -> local_ {\n     local_ {\n         is_mutbl: l.is_mutbl,\n         ty: fld.fold_ty(l.ty),\n@@ -660,47 +744,49 @@ fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n \n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n    value */\n-fn noop_map_exprs(f: fn@(&&v: @expr) -> @expr, es: ~[@expr]) -> ~[@expr] {\n-    return vec::map(es, |x| f(*x));\n+fn noop_map_exprs(f: fn@(@expr) -> @expr, es: &[@expr]) -> ~[@expr] {\n+    es.map(|x| f(*x))\n }\n \n fn noop_id(i: node_id) -> node_id { return i; }\n \n fn noop_span(sp: span) -> span { return sp; }\n \n pub fn default_ast_fold() -> ast_fold_fns {\n-    return @AstFoldFns {fold_crate: wrap(noop_fold_crate),\n-          fold_view_item: noop_fold_view_item,\n-          fold_foreign_item: noop_fold_foreign_item,\n-          fold_item: noop_fold_item,\n-          fold_struct_field: noop_fold_struct_field,\n-          fold_item_underscore: noop_fold_item_underscore,\n-          fold_method: noop_fold_method,\n-          fold_block: wrap(noop_fold_block),\n-          fold_stmt: wrap(noop_fold_stmt),\n-          fold_arm: noop_fold_arm,\n-          fold_pat: wrap(noop_fold_pat),\n-          fold_decl: wrap(noop_fold_decl),\n-          fold_expr: wrap(noop_fold_expr),\n-          fold_ty: wrap(noop_fold_ty),\n-          fold_mod: noop_fold_mod,\n-          fold_foreign_mod: noop_fold_foreign_mod,\n-          fold_variant: wrap(noop_fold_variant),\n-          fold_ident: noop_fold_ident,\n-          fold_path: noop_fold_path,\n-          fold_local: wrap(noop_fold_local),\n-          map_exprs: noop_map_exprs,\n-          new_id: noop_id,\n-          new_span: noop_span};\n+    @AstFoldFns {\n+        fold_crate: wrap(noop_fold_crate),\n+        fold_view_item: noop_fold_view_item,\n+        fold_foreign_item: noop_fold_foreign_item,\n+        fold_item: noop_fold_item,\n+        fold_struct_field: noop_fold_struct_field,\n+        fold_item_underscore: noop_fold_item_underscore,\n+        fold_method: noop_fold_method,\n+        fold_block: wrap(noop_fold_block),\n+        fold_stmt: wrap(noop_fold_stmt),\n+        fold_arm: noop_fold_arm,\n+        fold_pat: wrap(noop_fold_pat),\n+        fold_decl: wrap(noop_fold_decl),\n+        fold_expr: wrap(noop_fold_expr),\n+        fold_ty: wrap(noop_fold_ty),\n+        fold_mod: noop_fold_mod,\n+        fold_foreign_mod: noop_fold_foreign_mod,\n+        fold_variant: wrap(noop_fold_variant),\n+        fold_ident: noop_fold_ident,\n+        fold_path: noop_fold_path,\n+        fold_local: wrap(noop_fold_local),\n+        map_exprs: noop_map_exprs,\n+        new_id: noop_id,\n+        new_span: noop_span\n+    }\n }\n \n pub impl ast_fold for ast_fold_fns {\n     /* naturally, a macro to write these would be nice */\n-    fn fold_crate(c: crate) -> crate {\n-        let (n, s) = (self.fold_crate)(c.node, c.span, self as ast_fold);\n+    fn fold_crate(c: &crate) -> crate {\n+        let (n, s) = (self.fold_crate)(&c.node, c.span, self as ast_fold);\n         spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_view_item(&&x: @view_item) ->\n+    fn fold_view_item(x: @view_item) ->\n        @view_item {\n         @ast::view_item {\n             node: (self.fold_view_item)(x.node, self as ast_fold),\n@@ -710,14 +796,13 @@ pub impl ast_fold for ast_fold_fns {\n             span: (self.new_span)(x.span),\n         }\n     }\n-    fn fold_foreign_item(&&x: @foreign_item)\n-        -> @foreign_item {\n-        return (self.fold_foreign_item)(x, self as ast_fold);\n+    fn fold_foreign_item(x: @foreign_item) -> @foreign_item {\n+        (self.fold_foreign_item)(x, self as ast_fold)\n     }\n-    fn fold_item(&&i: @item) -> Option<@item> {\n-        return (self.fold_item)(i, self as ast_fold);\n+    fn fold_item(i: @item) -> Option<@item> {\n+        (self.fold_item)(i, self as ast_fold)\n     }\n-    fn fold_struct_field(&&sf: @struct_field) -> @struct_field {\n+    fn fold_struct_field(sf: @struct_field) -> @struct_field {\n         @spanned {\n             node: ast::struct_field_ {\n                 kind: copy sf.node.kind,\n@@ -727,77 +812,73 @@ pub impl ast_fold for ast_fold_fns {\n             span: (self.new_span)(sf.span),\n         }\n     }\n-    fn fold_item_underscore(i: item_) ->\n-       item_ {\n-        return (self.fold_item_underscore)(i, self as ast_fold);\n+    fn fold_item_underscore(i: &item_) -> item_ {\n+        (self.fold_item_underscore)(i, self as ast_fold)\n     }\n-    fn fold_method(&&x: @method)\n-        -> @method {\n-        return (self.fold_method)(x, self as ast_fold);\n+    fn fold_method(x: @method) -> @method {\n+        (self.fold_method)(x, self as ast_fold)\n     }\n-    fn fold_block(x: blk) -> blk {\n-        let (n, s) = (self.fold_block)(x.node, x.span, self as ast_fold);\n+    fn fold_block(x: &blk) -> blk {\n+        let (n, s) = (self.fold_block)(&x.node, x.span, self as ast_fold);\n         spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_stmt(&&x: @stmt) -> @stmt {\n-        let (n, s) = (self.fold_stmt)(x.node, x.span, self as ast_fold);\n+    fn fold_stmt(x: &stmt) -> @stmt {\n+        let (n, s) = (self.fold_stmt)(&x.node, x.span, self as ast_fold);\n         @spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_arm(x: arm) -> arm {\n-        return (self.fold_arm)(x, self as ast_fold);\n+    fn fold_arm(x: &arm) -> arm {\n+        (self.fold_arm)(x, self as ast_fold)\n     }\n-    fn fold_pat(&&x: @pat) -> @pat {\n-        let (n, s) =  (self.fold_pat)(x.node, x.span, self as ast_fold);\n+    fn fold_pat(x: @pat) -> @pat {\n+        let (n, s) =  (self.fold_pat)(&x.node, x.span, self as ast_fold);\n         @pat {\n             id: (self.new_id)(x.id),\n             node: n,\n             span: (self.new_span)(s),\n         }\n     }\n-    fn fold_decl(&&x: @decl) -> @decl {\n-        let (n, s) = (self.fold_decl)(x.node, x.span, self as ast_fold);\n+    fn fold_decl(x: @decl) -> @decl {\n+        let (n, s) = (self.fold_decl)(&x.node, x.span, self as ast_fold);\n         @spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_expr(&&x: @expr) -> @expr {\n-        let (n, s) = (self.fold_expr)(x.node, x.span, self as ast_fold);\n+    fn fold_expr(x: @expr) -> @expr {\n+        let (n, s) = (self.fold_expr)(&x.node, x.span, self as ast_fold);\n         @expr {\n             id: (self.new_id)(x.id),\n             callee_id: (self.new_id)(x.callee_id),\n             node: n,\n             span: (self.new_span)(s),\n         }\n     }\n-    fn fold_ty(&&x: @Ty) -> @Ty {\n-        let (n, s) = (self.fold_ty)(x.node, x.span, self as ast_fold);\n+    fn fold_ty(x: @Ty) -> @Ty {\n+        let (n, s) = (self.fold_ty)(&x.node, x.span, self as ast_fold);\n         @Ty {\n             id: (self.new_id)(x.id),\n             node: n,\n             span: (self.new_span)(s),\n         }\n     }\n-    fn fold_mod(x: _mod) -> _mod {\n-        return (self.fold_mod)(x, self as ast_fold);\n+    fn fold_mod(x: &_mod) -> _mod {\n+        (self.fold_mod)(x, self as ast_fold)\n     }\n-    fn fold_foreign_mod(x: foreign_mod) ->\n-       foreign_mod {\n-        return (self.fold_foreign_mod)(x, self as ast_fold);\n+    fn fold_foreign_mod(x: &foreign_mod) -> foreign_mod {\n+        (self.fold_foreign_mod)(x, self as ast_fold)\n     }\n-    fn fold_variant(x: variant) ->\n-       variant {\n-        let (n, s) = (self.fold_variant)(x.node, x.span, self as ast_fold);\n+    fn fold_variant(x: &variant) -> variant {\n+        let (n, s) = (self.fold_variant)(&x.node, x.span, self as ast_fold);\n         spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_ident(&&x: ident) -> ident {\n-        return (self.fold_ident)(x, self as ast_fold);\n+    fn fold_ident(x: ident) -> ident {\n+        (self.fold_ident)(x, self as ast_fold)\n     }\n-    fn fold_path(&&x: @path) -> @path {\n-        @(self.fold_path)(*x, self as ast_fold)\n+    fn fold_path(x: @path) -> @path {\n+        @(self.fold_path)(x, self as ast_fold)\n     }\n-    fn fold_local(&&x: @local) -> @local {\n-        let (n, s) = (self.fold_local)(x.node, x.span, self as ast_fold);\n+    fn fold_local(x: @local) -> @local {\n+        let (n, s) = (self.fold_local)(&x.node, x.span, self as ast_fold);\n         @spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn map_exprs(f: fn@(&&v: @expr) -> @expr, e: ~[@expr]) -> ~[@expr] {\n+    fn map_exprs(f: fn@(@expr) -> @expr, e: &[@expr]) -> ~[@expr] {\n         (self.map_exprs)(f, e)\n     }\n     fn new_id(node_id: ast::node_id) -> node_id {"}, {"sha": "b4773fe2f97b9d91fcadd1b7f152688f8556bffc", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -38,8 +38,8 @@ use core::u64;\n use core::vec;\n \n // The @ps is stored here to prevent recursive type.\n-pub enum ann_node {\n-    node_block(@ps, ast::blk),\n+pub enum ann_node/& {\n+    node_block(@ps, &ast::blk),\n     node_item(@ps, @ast::item),\n     node_expr(@ps, @ast::expr),\n     node_pat(@ps, @ast::pat),\n@@ -183,7 +183,7 @@ pub fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n     }\n }\n \n-pub fn block_to_str(blk: ast::blk, intr: @ident_interner) -> ~str {\n+pub fn block_to_str(blk: &ast::blk, intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n         // containing cbox, will be closed by print-block at }\n@@ -510,7 +510,7 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n             item.vis\n         );\n         word(s.s, ~\" \");\n-        print_block_with_attrs(s, (*body), item.attrs);\n+        print_block_with_attrs(s, body, item.attrs);\n       }\n       ast::item_mod(_mod) => {\n         head(s, visibility_qualified(item.vis, ~\"mod\"));\n@@ -607,8 +607,8 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n         }\n         word(s.s, ~\" \");\n         bopen(s);\n-        for (*methods).each |meth| {\n-            print_trait_method(s, *meth);\n+        for methods.each |meth| {\n+            print_trait_method(s, meth);\n         }\n         bclose(s, item.span);\n       }\n@@ -741,7 +741,7 @@ pub fn print_struct(s: @ps,\n           maybe_print_comment(s, dtor.span.lo);\n           print_outer_attributes(s, dtor.node.attrs);\n           head(s, ~\"drop\");\n-          print_block(s, dtor.node.body);\n+          print_block(s, &dtor.node.body);\n         }\n \n         for struct_def.fields.each |field| {\n@@ -839,7 +839,7 @@ pub fn print_variant(s: @ps, v: ast::variant) {\n     }\n }\n \n-pub fn print_ty_method(s: @ps, m: ast::ty_method) {\n+pub fn print_ty_method(s: @ps, m: &ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n@@ -849,10 +849,10 @@ pub fn print_ty_method(s: @ps, m: ast::ty_method) {\n     word(s.s, ~\";\");\n }\n \n-pub fn print_trait_method(s: @ps, m: ast::trait_method) {\n-    match m {\n-      required(ref ty_m) => print_ty_method(s, (*ty_m)),\n-      provided(m)    => print_method(s, m)\n+pub fn print_trait_method(s: @ps, m: &ast::trait_method) {\n+    match *m {\n+        required(ref ty_m) => print_ty_method(s, ty_m),\n+        provided(m) => print_method(s, m)\n     }\n }\n \n@@ -864,7 +864,7 @@ pub fn print_method(s: @ps, meth: @ast::method) {\n              meth.ident, meth.tps, Some(meth.self_ty.node),\n              meth.vis);\n     word(s.s, ~\" \");\n-    print_block_with_attrs(s, meth.body, meth.attrs);\n+    print_block_with_attrs(s, &meth.body, meth.attrs);\n }\n \n pub fn print_outer_attributes(s: @ps, attrs: ~[ast::attribute]) {\n@@ -935,22 +935,22 @@ pub fn print_stmt(s: @ps, st: ast::stmt) {\n     maybe_print_trailing_comment(s, st.span, None);\n }\n \n-pub fn print_block(s: @ps, blk: ast::blk) {\n+pub fn print_block(s: @ps, blk: &ast::blk) {\n     print_possibly_embedded_block(s, blk, block_normal, indent_unit);\n }\n \n-pub fn print_block_unclosed(s: @ps, blk: ast::blk) {\n+pub fn print_block_unclosed(s: @ps, blk: &ast::blk) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, ~[],\n                                  false);\n }\n \n-pub fn print_block_unclosed_indent(s: @ps, blk: ast::blk, indented: uint) {\n+pub fn print_block_unclosed_indent(s: @ps, blk: &ast::blk, indented: uint) {\n     print_possibly_embedded_block_(s, blk, block_normal, indented, ~[],\n                                    false);\n }\n \n pub fn print_block_with_attrs(s: @ps,\n-                              blk: ast::blk,\n+                              blk: &ast::blk,\n                               attrs: ~[ast::attribute]) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs,\n                                   true);\n@@ -959,15 +959,15 @@ pub fn print_block_with_attrs(s: @ps,\n pub enum embed_type { block_block_fn, block_normal, }\n \n pub fn print_possibly_embedded_block(s: @ps,\n-                                     blk: ast::blk,\n+                                     blk: &ast::blk,\n                                      embedded: embed_type,\n                                      indented: uint) {\n     print_possibly_embedded_block_(\n         s, blk, embedded, indented, ~[], true);\n }\n \n pub fn print_possibly_embedded_block_(s: @ps,\n-                                      blk: ast::blk,\n+                                      blk: &ast::blk,\n                                       embedded: embed_type,\n                                       indented: uint,\n                                       attrs: ~[ast::attribute],\n@@ -1002,7 +1002,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n     (s.ann.post)(ann_node);\n }\n \n-pub fn print_if(s: @ps, test: @ast::expr, blk: ast::blk,\n+pub fn print_if(s: @ps, test: @ast::expr, blk: &ast::blk,\n                 elseopt: Option<@ast::expr>, chk: bool) {\n     head(s, ~\"if\");\n     if chk { word_nbsp(s, ~\"check\"); }\n@@ -1020,15 +1020,15 @@ pub fn print_if(s: @ps, test: @ast::expr, blk: ast::blk,\n                 word(s.s, ~\" else if \");\n                 print_expr(s, i);\n                 space(s.s);\n-                print_block(s, (*t));\n+                print_block(s, t);\n                 do_else(s, e);\n               }\n               // \"final else\"\n               ast::expr_block(ref b) => {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n                 word(s.s, ~\" else \");\n-                print_block(s, (*b));\n+                print_block(s, b);\n               }\n               // BLEAH, constraints would be great here\n               _ => {\n@@ -1263,13 +1263,13 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         print_type_ex(s, ty, true);\n       }\n       ast::expr_if(test, ref blk, elseopt) => {\n-        print_if(s, test, (*blk), elseopt, false);\n+        print_if(s, test, blk, elseopt, false);\n       }\n       ast::expr_while(test, ref blk) => {\n         head(s, ~\"while\");\n         print_expr(s, test);\n         space(s.s);\n-        print_block(s, (*blk));\n+        print_block(s, blk);\n       }\n       ast::expr_loop(ref blk, opt_ident) => {\n         head(s, ~\"loop\");\n@@ -1278,7 +1278,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n             print_ident(s, *ident);\n             word_space(s, ~\":\");\n         });\n-        print_block(s, (*blk));\n+        print_block(s, blk);\n       }\n       ast::expr_match(expr, ref arms) => {\n         cbox(s, match_indent_unit);\n@@ -1323,7 +1323,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n                             ast::expr_block(ref blk) => {\n                                 // the block will close the pattern's ibox\n                                 print_block_unclosed_indent(\n-                                    s, (*blk), match_indent_unit);\n+                                    s, blk, match_indent_unit);\n                             }\n                             _ => {\n                                 end(s); // close the ibox for the pattern\n@@ -1340,7 +1340,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n                 }\n             } else {\n                 // the block will close the pattern's ibox\n-                print_block_unclosed_indent(s, arm.body, match_indent_unit);\n+                print_block_unclosed_indent(s, &arm.body, match_indent_unit);\n             }\n         }\n         bclose_(s, expr.span, match_indent_unit);\n@@ -1354,7 +1354,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n                              Some(sigil), ast::inherited);\n         print_fn_args_and_ret(s, /* FIXME (#2543) */ copy *decl, None);\n         space(s.s);\n-        print_block(s, (*body));\n+        print_block(s, body);\n       }\n       ast::expr_fn_block(ref decl, ref body) => {\n         // in do/for blocks we don't want to show an empty\n@@ -1365,16 +1365,16 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         print_fn_block_args(s, /* FIXME (#2543) */ copy *decl);\n         space(s.s);\n         // }\n-        assert (*body).node.stmts.is_empty();\n-        assert (*body).node.expr.is_some();\n+        assert body.node.stmts.is_empty();\n+        assert body.node.expr.is_some();\n         // we extract the block, so as not to create another set of boxes\n-        match (*body).node.expr.get().node {\n+        match body.node.expr.get().node {\n             ast::expr_block(ref blk) => {\n-                print_block_unclosed(s, (*blk));\n+                print_block_unclosed(s, blk);\n             }\n             _ => {\n                 // this is a bare expression\n-                print_expr(s, (*body).node.expr.get());\n+                print_expr(s, body.node.expr.get());\n                 end(s); // need to close a box\n             }\n         }\n@@ -1394,7 +1394,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block after {\n         ibox(s, 0u);\n-        print_block(s, (*blk));\n+        print_block(s, blk);\n       }\n       ast::expr_copy(e) => { word_space(s, ~\"copy\"); print_expr(s, e); }\n       ast::expr_assign(lhs, rhs) => {"}, {"sha": "1b0842dbd86aec1214bb36a78afc06c24ed1d450", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 225, "deletions": 200, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f14409c528125836a5cbe9d4d7a39b8d6695f7b1/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=f14409c528125836a5cbe9d4d7a39b8d6695f7b1", "patch": "@@ -67,18 +67,18 @@ pub struct Visitor<E> {\n     visit_foreign_item: fn@(@foreign_item, E, vt<E>),\n     visit_item: fn@(@item, E, vt<E>),\n     visit_local: fn@(@local, E, vt<E>),\n-    visit_block: fn@(ast::blk, E, vt<E>),\n+    visit_block: fn@(&blk, E, vt<E>),\n     visit_stmt: fn@(@stmt, E, vt<E>),\n-    visit_arm: fn@(arm, E, vt<E>),\n+    visit_arm: fn@(&arm, E, vt<E>),\n     visit_pat: fn@(@pat, E, vt<E>),\n     visit_decl: fn@(@decl, E, vt<E>),\n     visit_expr: fn@(@expr, E, vt<E>),\n     visit_expr_post: fn@(@expr, E, vt<E>),\n     visit_ty: fn@(@Ty, E, vt<E>),\n     visit_ty_params: fn@(&[ty_param], E, vt<E>),\n-    visit_fn: fn@(&fn_kind, fn_decl, blk, span, node_id, E, vt<E>),\n-    visit_ty_method: fn@(ty_method, E, vt<E>),\n-    visit_trait_method: fn@(trait_method, E, vt<E>),\n+    visit_fn: fn@(&fn_kind, &fn_decl, &blk, span, node_id, E, vt<E>),\n+    visit_ty_method: fn@(&ty_method, E, vt<E>),\n+    visit_trait_method: fn@(&trait_method, E, vt<E>),\n     visit_struct_def: fn@(@struct_def, ident, &[ty_param], node_id, E,\n                           vt<E>),\n     visit_struct_field: fn@(@struct_field, E, vt<E>),\n@@ -146,8 +146,8 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n                     *tps,\n                     purity\n                 ),\n-                /* FIXME (#2543) */ copy *decl,\n-                *body,\n+                decl,\n+                body,\n                 i.span,\n                 i.id,\n                 e,\n@@ -190,20 +190,20 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n             (v.visit_ty_params)(*tps, e, v);\n             for traits.each |p| { visit_path(p.path, e, v); }\n             for (*methods).each |m| {\n-                (v.visit_trait_method)(*m, e, v);\n+                (v.visit_trait_method)(m, e, v);\n             }\n         }\n         item_mac(ref m) => visit_mac((*m), e, v)\n     }\n }\n \n pub fn visit_enum_def<E>(enum_definition: ast::enum_def,\n-                         tps: ~[ast::ty_param],\n+                         tps: &[ast::ty_param],\n                          e: E,\n                          v: vt<E>) {\n     for enum_definition.variants.each |vr| {\n         match vr.node.kind {\n-            tuple_variant_kind(variant_args) => {\n+            tuple_variant_kind(ref variant_args) => {\n                 for variant_args.each |va| { (v.visit_ty)(va.ty, e, v); }\n             }\n             struct_variant_kind(struct_def) => {\n@@ -223,30 +223,31 @@ pub fn skip_ty<E>(_t: @Ty, _e: E, _v: vt<E>) {}\n \n pub fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n     match t.node {\n-      ty_box(mt) | ty_uniq(mt) |\n-      ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n-        (v.visit_ty)(mt.ty, e, v);\n-      }\n-      ty_rec(ref flds) => for (*flds).each |f| {\n-        (v.visit_ty)(f.node.mt.ty, e, v);\n-      },\n-      ty_tup(ts) => for ts.each |tt| {\n-        (v.visit_ty)(*tt, e, v);\n-      },\n-      ty_closure(f) => {\n-        for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n-        (v.visit_ty)(f.decl.output, e, v);\n-      }\n-      ty_bare_fn(f) => {\n-        for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n-        (v.visit_ty)(f.decl.output, e, v);\n-      }\n-      ty_path(p, _) => visit_path(p, e, v),\n-      ty_fixed_length_vec(mt, _) => (v.visit_ty)(mt.ty, e, v),\n-      ty_nil |\n-      ty_bot |\n-      ty_mac(_) |\n-      ty_infer => ()\n+        ty_box(mt) | ty_uniq(mt) |\n+        ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n+            (v.visit_ty)(mt.ty, e, v);\n+        },\n+        ty_rec(ref flds) => {\n+            for flds.each |f| {\n+                (v.visit_ty)(f.node.mt.ty, e, v);\n+            }\n+        },\n+        ty_tup(ref ts) => {\n+            for ts.each |tt| {\n+                (v.visit_ty)(*tt, e, v);\n+            }\n+        },\n+        ty_closure(ref f) => {\n+            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n+            (v.visit_ty)(f.decl.output, e, v);\n+        },\n+        ty_bare_fn(ref f) => {\n+            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n+            (v.visit_ty)(f.decl.output, e, v);\n+        },\n+        ty_path(p, _) => visit_path(p, e, v),\n+        ty_fixed_length_vec(ref mt, _) => (v.visit_ty)(mt.ty, e, v),\n+        ty_nil | ty_bot | ty_mac(_) | ty_infer => ()\n     }\n }\n \n@@ -256,49 +257,55 @@ pub fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n \n pub fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     match p.node {\n-      pat_enum(path, children) => {\n-        visit_path(path, e, v);\n-        do option::iter(&children) |children| {\n-            for children.each |child| { (v.visit_pat)(*child, e, v); }}\n-      }\n-      pat_rec(fields, _) => for fields.each |f| {\n-        (v.visit_pat)(f.pat, e, v)\n-      },\n-      pat_struct(path, fields, _) => {\n-        visit_path(path, e, v);\n-        for fields.each |f| {\n-            (v.visit_pat)(f.pat, e, v);\n+        pat_enum(path, ref children) => {\n+            visit_path(path, e, v);\n+            do children.iter |children| {\n+                for children.each |child| { (v.visit_pat)(*child, e, v); }\n+            }\n         }\n-      }\n-      pat_tup(elts) => for elts.each |elt| {\n-        (v.visit_pat)(*elt, e, v)\n-      },\n-      pat_box(inner) | pat_uniq(inner) | pat_region(inner) =>\n-          (v.visit_pat)(inner, e, v),\n-      pat_ident(_, path, inner) => {\n-          visit_path(path, e, v);\n-          do option::iter(&inner) |subpat| { (v.visit_pat)(*subpat, e, v)};\n-      }\n-      pat_lit(ex) => (v.visit_expr)(ex, e, v),\n-      pat_range(e1, e2) => {\n-        (v.visit_expr)(e1, e, v);\n-        (v.visit_expr)(e2, e, v);\n-      }\n-      pat_wild => (),\n-      pat_vec(elts, tail) => {\n-        for elts.each |elt| {\n-          (v.visit_pat)(*elt, e, v);\n+        pat_rec(ref fields, _) => {\n+            for fields.each |f| {\n+                (v.visit_pat)(f.pat, e, v)\n+            }\n+        },\n+        pat_struct(path, ref fields, _) => {\n+            visit_path(path, e, v);\n+            for fields.each |f| {\n+                (v.visit_pat)(f.pat, e, v);\n+            }\n+        }\n+        pat_tup(ref elts) => {\n+            for elts.each |elt| {\n+                (v.visit_pat)(*elt, e, v)\n+            }\n+        },\n+        pat_box(inner) | pat_uniq(inner) | pat_region(inner) => {\n+            (v.visit_pat)(inner, e, v)\n+        },\n+        pat_ident(_, path, ref inner) => {\n+            visit_path(path, e, v);\n+            do inner.iter |subpat| { (v.visit_pat)(*subpat, e, v) }\n         }\n-        do option::iter(&tail) |tail| {\n-          (v.visit_pat)(*tail, e, v);\n+        pat_lit(ex) => (v.visit_expr)(ex, e, v),\n+        pat_range(e1, e2) => {\n+            (v.visit_expr)(e1, e, v);\n+            (v.visit_expr)(e2, e, v);\n+        }\n+        pat_wild => (),\n+        pat_vec(ref elts, ref tail) => {\n+            for elts.each |elt| {\n+                (v.visit_pat)(*elt, e, v);\n+            }\n+            do tail.iter |tail| {\n+                (v.visit_pat)(*tail, e, v);\n+            }\n         }\n-      }\n     }\n }\n \n pub fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n     match ni.node {\n-        foreign_item_fn(fd, _, ref tps) => {\n+        foreign_item_fn(ref fd, _, ref tps) => {\n             (v.visit_ty_params)(*tps, e, v);\n             visit_fn_decl(fd, e, v);\n         }\n@@ -323,7 +330,7 @@ pub fn visit_ty_params<E>(tps: &[ty_param], e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n+pub fn visit_fn_decl<E>(fd: &fn_decl, e: E, v: vt<E>) {\n     for fd.inputs.each |a| {\n         (v.visit_pat)(a.pat, e, v);\n         (v.visit_ty)(a.ty, e, v);\n@@ -342,8 +349,8 @@ pub fn visit_method_helper<E>(m: &method, e: E, v: vt<E>) {\n             m.tps,\n             m\n         ),\n-        m.decl,\n-        m.body,\n+        &m.decl,\n+        &m.body,\n         m.span,\n         m.id,\n         e,\n@@ -360,8 +367,8 @@ pub fn visit_struct_dtor_helper<E>(dtor: struct_dtor, tps: &[ty_param],\n             dtor.node.self_id,\n             parent_id\n         ),\n-        ast_util::dtor_dec(),\n-        dtor.node.body,\n+        &ast_util::dtor_dec(),\n+        &dtor.node.body,\n         dtor.span,\n         dtor.node.id,\n         e,\n@@ -370,22 +377,22 @@ pub fn visit_struct_dtor_helper<E>(dtor: struct_dtor, tps: &[ty_param],\n \n }\n \n-pub fn visit_fn<E>(fk: &fn_kind, decl: fn_decl, body: blk, _sp: span,\n+pub fn visit_fn<E>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n                    _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);\n     (v.visit_ty_params)(tps_of_fn(fk), e, v);\n     (v.visit_block)(body, e, v);\n }\n \n-pub fn visit_ty_method<E>(m: ty_method, e: E, v: vt<E>) {\n+pub fn visit_ty_method<E>(m: &ty_method, e: E, v: vt<E>) {\n     for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n     (v.visit_ty_params)(m.tps, e, v);\n     (v.visit_ty)(m.decl.output, e, v);\n }\n \n-pub fn visit_trait_method<E>(m: trait_method, e: E, v: vt<E>) {\n-    match m {\n-      required(ref ty_m) => (v.visit_ty_method)((*ty_m), e, v),\n+pub fn visit_trait_method<E>(m: &trait_method, e: E, v: vt<E>) {\n+    match *m {\n+      required(ref ty_m) => (v.visit_ty_method)(ty_m, e, v),\n       provided(m) => visit_method_helper(m, e, v)\n     }\n }\n@@ -408,7 +415,7 @@ pub fn visit_struct_method<E>(m: @method, e: E, v: vt<E>) {\n     visit_method_helper(m, e, v);\n }\n \n-pub fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n+pub fn visit_block<E>(b: &blk, e: E, v: vt<E>) {\n     for b.node.view_items.each |vi| {\n         (v.visit_view_item)(*vi, e, v);\n     }\n@@ -429,18 +436,20 @@ pub fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n \n pub fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n     match d.node {\n-      decl_local(locs) => for locs.each |loc| {\n-        (v.visit_local)(*loc, e, v)\n-      },\n-      decl_item(it) => (v.visit_item)(it, e, v)\n+        decl_local(ref locs) => {\n+            for locs.each |loc| {\n+                (v.visit_local)(*loc, e, v)\n+            }\n+        },\n+        decl_item(it) => (v.visit_item)(it, e, v)\n     }\n }\n \n pub fn visit_expr_opt<E>(eo: Option<@expr>, e: E, v: vt<E>) {\n     match eo { None => (), Some(ex) => (v.visit_expr)(ex, e, v) }\n }\n \n-pub fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n+pub fn visit_exprs<E>(exprs: &[@expr], e: E, v: vt<E>) {\n     for exprs.each |ex| { (v.visit_expr)(*ex, e, v); }\n }\n \n@@ -450,112 +459,121 @@ pub fn visit_mac<E>(_m: mac, _e: E, _v: vt<E>) {\n \n pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n     match ex.node {\n-      expr_vstore(x, _) => (v.visit_expr)(x, e, v),\n-      expr_vec(es, _) => visit_exprs(es, e, v),\n-      expr_repeat(element, count, _) => {\n-        (v.visit_expr)(element, e, v);\n-        (v.visit_expr)(count, e, v);\n-      }\n-      expr_rec(ref flds, base) => {\n-        for (*flds).each |f| { (v.visit_expr)(f.node.expr, e, v); }\n-        visit_expr_opt(base, e, v);\n-      }\n-      expr_struct(p, ref flds, base) => {\n-        visit_path(p, e, v);\n-        for (*flds).each |f| { (v.visit_expr)(f.node.expr, e, v); }\n-        visit_expr_opt(base, e, v);\n-      }\n-      expr_tup(elts) => for elts.each |el| { (v.visit_expr)(*el, e, v); },\n-      expr_call(callee, args, _) => {\n-        visit_exprs(args, e, v);\n-        (v.visit_expr)(callee, e, v);\n-      }\n-      expr_method_call(callee, _, tys, args, _) => {\n-        visit_exprs(args, e, v);\n-        for tys.each |tp| { (v.visit_ty)(*tp, e, v); }\n-        (v.visit_expr)(callee, e, v);\n-      }\n-      expr_binary(_, a, b) => {\n-        (v.visit_expr)(a, e, v); (v.visit_expr)(b, e, v);\n-      }\n-      expr_addr_of(_, x) | expr_unary(_, x) |\n-      expr_loop_body(x) | expr_do_body(x) |\n-      expr_assert(x) => (v.visit_expr)(x, e, v),\n-      expr_lit(_) => (),\n-      expr_cast(x, t) => { (v.visit_expr)(x, e, v); (v.visit_ty)(t, e, v); }\n-      expr_if(x, ref b, eo) => {\n-        (v.visit_expr)(x, e, v);\n-        (v.visit_block)((*b), e, v);\n-        visit_expr_opt(eo, e, v);\n-      }\n-      expr_while(x, ref b) => {\n-        (v.visit_expr)(x, e, v);\n-        (v.visit_block)((*b), e, v);\n-      }\n-      expr_loop(ref b, _) => (v.visit_block)((*b), e, v),\n-      expr_match(x, ref arms) => {\n-        (v.visit_expr)(x, e, v);\n-        for (*arms).each |a| { (v.visit_arm)(*a, e, v); }\n-      }\n-      expr_fn(proto, ref decl, ref body, _) => {\n-        (v.visit_fn)(\n-            &fk_anon(proto),\n-            /* FIXME (#2543) */ copy *decl,\n-            *body,\n-            ex.span,\n-            ex.id,\n-            e,\n-            v\n-        );\n-      }\n-      expr_fn_block(ref decl, ref body) => {\n-        (v.visit_fn)(\n-            &fk_fn_block,\n-            /* FIXME (#2543) */ copy *decl,\n-            *body,\n-            ex.span,\n-            ex.id,\n-            e,\n-            v\n-        );\n-      }\n-      expr_block(ref b) => (v.visit_block)((*b), e, v),\n-      expr_assign(a, b) => {\n-        (v.visit_expr)(b, e, v);\n-        (v.visit_expr)(a, e, v);\n-      }\n-      expr_copy(a) => (v.visit_expr)(a, e, v),\n-      expr_swap(a, b) => { (v.visit_expr)(a, e, v); (v.visit_expr)(b, e, v); }\n-      expr_assign_op(_, a, b) => {\n-        (v.visit_expr)(b, e, v);\n-        (v.visit_expr)(a, e, v);\n-      }\n-      expr_field(x, _, tys) => {\n-        (v.visit_expr)(x, e, v);\n-        for tys.each |tp| { (v.visit_ty)(*tp, e, v); }\n-      }\n-      expr_index(a, b) => {\n-        (v.visit_expr)(a, e, v);\n-        (v.visit_expr)(b, e, v);\n-      }\n-      expr_path(p) => visit_path(p, e, v),\n-      expr_break(_) => (),\n-      expr_again(_) => (),\n-      expr_ret(eo) => visit_expr_opt(eo, e, v),\n-      expr_log(_, lv, x) => {\n-        (v.visit_expr)(lv, e, v);\n-        (v.visit_expr)(x, e, v);\n-      }\n-      expr_mac(ref mac) => visit_mac((*mac), e, v),\n-      expr_paren(x) => (v.visit_expr)(x, e, v),\n+        expr_vstore(x, _) => (v.visit_expr)(x, e, v),\n+        expr_vec(ref es, _) => visit_exprs(*es, e, v),\n+        expr_repeat(element, count, _) => {\n+            (v.visit_expr)(element, e, v);\n+            (v.visit_expr)(count, e, v);\n+        }\n+        expr_rec(ref flds, base) => {\n+            for flds.each |f| { (v.visit_expr)(f.node.expr, e, v); }\n+            visit_expr_opt(base, e, v);\n+        }\n+        expr_struct(p, ref flds, base) => {\n+            visit_path(p, e, v);\n+            for flds.each |f| { (v.visit_expr)(f.node.expr, e, v); }\n+            visit_expr_opt(base, e, v);\n+        }\n+        expr_tup(ref elts) => {\n+            for elts.each |el| { (v.visit_expr)(*el, e, v) }\n+        }\n+        expr_call(callee, ref args, _) => {\n+            visit_exprs(*args, e, v);\n+            (v.visit_expr)(callee, e, v);\n+        }\n+        expr_method_call(callee, _, ref tys, ref args, _) => {\n+            visit_exprs(*args, e, v);\n+            for tys.each |tp| { (v.visit_ty)(*tp, e, v); }\n+            (v.visit_expr)(callee, e, v);\n+        }\n+        expr_binary(_, a, b) => {\n+            (v.visit_expr)(a, e, v);\n+            (v.visit_expr)(b, e, v);\n+        }\n+        expr_addr_of(_, x) | expr_unary(_, x) |\n+        expr_loop_body(x) | expr_do_body(x) |\n+        expr_assert(x) => (v.visit_expr)(x, e, v),\n+        expr_lit(_) => (),\n+        expr_cast(x, t) => {\n+            (v.visit_expr)(x, e, v);\n+            (v.visit_ty)(t, e, v);\n+        }\n+        expr_if(x, ref b, eo) => {\n+            (v.visit_expr)(x, e, v);\n+            (v.visit_block)(b, e, v);\n+            visit_expr_opt(eo, e, v);\n+        }\n+        expr_while(x, ref b) => {\n+            (v.visit_expr)(x, e, v);\n+            (v.visit_block)(b, e, v);\n+        }\n+        expr_loop(ref b, _) => (v.visit_block)(b, e, v),\n+        expr_match(x, ref arms) => {\n+            (v.visit_expr)(x, e, v);\n+            for arms.each |a| { (v.visit_arm)(a, e, v); }\n+        }\n+        expr_fn(proto, ref decl, ref body, _) => {\n+            (v.visit_fn)(\n+                &fk_anon(proto),\n+                decl,\n+                body,\n+                ex.span,\n+                ex.id,\n+                e,\n+                v\n+            );\n+        }\n+        expr_fn_block(ref decl, ref body) => {\n+            (v.visit_fn)(\n+                &fk_fn_block,\n+                decl,\n+                body,\n+                ex.span,\n+                ex.id,\n+                e,\n+                v\n+            );\n+        }\n+        expr_block(ref b) => (v.visit_block)(b, e, v),\n+        expr_assign(a, b) => {\n+            (v.visit_expr)(b, e, v);\n+            (v.visit_expr)(a, e, v);\n+        }\n+        expr_copy(a) => (v.visit_expr)(a, e, v),\n+        expr_swap(a, b) => {\n+            (v.visit_expr)(a, e, v);\n+            (v.visit_expr)(b, e, v);\n+        }\n+        expr_assign_op(_, a, b) => {\n+            (v.visit_expr)(b, e, v);\n+            (v.visit_expr)(a, e, v);\n+        }\n+        expr_field(x, _, ref tys) => {\n+            (v.visit_expr)(x, e, v);\n+            for tys.each |tp| { (v.visit_ty)(*tp, e, v); }\n+        }\n+        expr_index(a, b) => {\n+            (v.visit_expr)(a, e, v);\n+            (v.visit_expr)(b, e, v);\n+        }\n+        expr_path(p) => visit_path(p, e, v),\n+        expr_break(_) => (),\n+        expr_again(_) => (),\n+        expr_ret(eo) => visit_expr_opt(eo, e, v),\n+        expr_log(_, lv, x) => {\n+            (v.visit_expr)(lv, e, v);\n+            (v.visit_expr)(x, e, v);\n+        }\n+        expr_mac(ref mac) => visit_mac((*mac), e, v),\n+        expr_paren(x) => (v.visit_expr)(x, e, v),\n     }\n     (v.visit_expr_post)(ex, e, v);\n }\n \n-pub fn visit_arm<E>(a: arm, e: E, v: vt<E>) {\n+pub fn visit_arm<E>(a: &arm, e: E, v: vt<E>) {\n     for a.pats.each |p| { (v.visit_pat)(*p, e, v); }\n     visit_expr_opt(a.guard, e, v);\n-    (v.visit_block)(a.body, e, v);\n+    (v.visit_block)(&a.body, e, v);\n }\n \n // Simpler, non-context passing interface. Always walks the whole tree, simply\n@@ -567,18 +585,18 @@ pub struct SimpleVisitor {\n     visit_foreign_item: fn@(@foreign_item),\n     visit_item: fn@(@item),\n     visit_local: fn@(@local),\n-    visit_block: fn@(ast::blk),\n+    visit_block: fn@(&blk),\n     visit_stmt: fn@(@stmt),\n-    visit_arm: fn@(arm),\n+    visit_arm: fn@(&arm),\n     visit_pat: fn@(@pat),\n     visit_decl: fn@(@decl),\n     visit_expr: fn@(@expr),\n     visit_expr_post: fn@(@expr),\n     visit_ty: fn@(@Ty),\n     visit_ty_params: fn@(&[ty_param]),\n-    visit_fn: fn@(&fn_kind, fn_decl, blk, span, node_id),\n-    visit_ty_method: fn@(ty_method),\n-    visit_trait_method: fn@(trait_method),\n+    visit_fn: fn@(&fn_kind, &fn_decl, &blk, span, node_id),\n+    visit_ty_method: fn@(&ty_method),\n+    visit_trait_method: fn@(&trait_method),\n     visit_struct_def: fn@(@struct_def, ident, &[ty_param], node_id),\n     visit_struct_field: fn@(@struct_field),\n     visit_struct_method: fn@(@method)\n@@ -604,10 +622,10 @@ pub fn default_simple_visitor() -> @SimpleVisitor {\n         visit_expr_post: |_e| { },\n         visit_ty: simple_ignore_ty,\n         visit_ty_params: fn@(_ps: &[ty_param]) { },\n-        visit_fn: fn@(_fk: &fn_kind, _d: fn_decl, _b: blk, _sp: span,\n+        visit_fn: fn@(_fk: &fn_kind, _d: &fn_decl, _b: &blk, _sp: span,\n                       _id: node_id) { },\n-        visit_ty_method: fn@(_m: ty_method) { },\n-        visit_trait_method: fn@(_m: trait_method) { },\n+        visit_ty_method: fn@(_m: &ty_method) { },\n+        visit_trait_method: fn@(_m: &trait_method) { },\n         visit_struct_def: fn@(_sd: @struct_def, _nm: ident,\n                               _tps: &[ty_param], _id: node_id) { },\n         visit_struct_field: fn@(_f: @struct_field) { },\n@@ -644,15 +662,15 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(l);\n         visit_local(l, e, v);\n     }\n-    fn v_block(f: fn@(ast::blk), bl: ast::blk, &&e: (), v: vt<()>) {\n+    fn v_block(f: fn@(&blk), bl: &blk, &&e: (), v: vt<()>) {\n         f(bl);\n         visit_block(bl, e, v);\n     }\n     fn v_stmt(f: fn@(@stmt), st: @stmt, &&e: (), v: vt<()>) {\n         f(st);\n         visit_stmt(st, e, v);\n     }\n-    fn v_arm(f: fn@(arm), a: arm, &&e: (), v: vt<()>) {\n+    fn v_arm(f: fn@(&arm), a: &arm, &&e: (), v: vt<()>) {\n         f(a);\n         visit_arm(a, e, v);\n     }\n@@ -675,11 +693,11 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(ty);\n         visit_ty(ty, e, v);\n     }\n-    fn v_ty_method(f: fn@(ty_method), ty: ty_method, &&e: (), v: vt<()>) {\n+    fn v_ty_method(f: fn@(&ty_method), ty: &ty_method, &&e: (), v: vt<()>) {\n         f(ty);\n         visit_ty_method(ty, e, v);\n     }\n-    fn v_trait_method(f: fn@(trait_method), m: trait_method, &&e: (),\n+    fn v_trait_method(f: fn@(&trait_method), m: &trait_method, &&e: (),\n                       v: vt<()>) {\n         f(m);\n         visit_trait_method(m, e, v);\n@@ -697,9 +715,16 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(ps);\n         visit_ty_params(ps, e, v);\n     }\n-    fn v_fn(f: fn@(&fn_kind, fn_decl, blk, span, node_id),\n-            fk: &fn_kind, decl: fn_decl, body: blk, sp: span,\n-            id: node_id, &&e: (), v: vt<()>) {\n+    fn v_fn(\n+        f: fn@(&fn_kind, &fn_decl, &blk, span, node_id),\n+        fk: &fn_kind,\n+        decl: &fn_decl,\n+        body: &blk,\n+        sp: span,\n+        id: node_id,\n+        &&e: (),\n+        v: vt<()>\n+    ) {\n         f(fk, decl, body, sp, id);\n         visit_fn(fk, decl, body, sp, id, e, v);\n     }"}]}