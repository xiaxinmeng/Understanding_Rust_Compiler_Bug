{"sha": "5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMTUwY2YwY2EyMTQ1YzdkMDNhMmI1ZWQ5MmQ5ZjY1Y2MwZWJjY2E=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-20T18:45:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-02T15:47:10Z"}, "message": "add borrowck info inline in main snippet\n\nThis uses the new `span_label` APIs", "tree": {"sha": "b41983574afcb3195506870a8ee35329f26199ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b41983574afcb3195506870a8ee35329f26199ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca", "html_url": "https://github.com/rust-lang/rust/commit/5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7c7a18d94cf672d6a031455d091e0bebe1a6b7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c7a18d94cf672d6a031455d091e0bebe1a6b7c", "html_url": "https://github.com/rust-lang/rust/commit/e7c7a18d94cf672d6a031455d091e0bebe1a6b7c"}], "stats": {"total": 333, "additions": 146, "deletions": 187}, "files": [{"sha": "efef259dcad9b5fef94d20c2b61781a2df7eb1d6", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca", "patch": "@@ -1569,5 +1569,5 @@ register_diagnostics! {\n     E0490, // a value of type `..` is borrowed for too long\n     E0491, // in type `..`, reference has a longer lifetime than the data it...\n     E0495, // cannot infer an appropriate lifetime due to conflicting requirements\n-    E0524, // expected a closure that implements `..` but this closure only implements `..`\n+    E0525, // expected a closure that implements `..` but this closure only implements `..`\n }"}, {"sha": "bbd9cd4526d95a840ecc7a93b2616fcc741b0cf0", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 85, "deletions": 57, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca", "patch": "@@ -447,49 +447,105 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             //     borrow ends\n \n             let common = new_loan.loan_path.common(&old_loan.loan_path);\n-            let (nl, ol, new_loan_msg, old_loan_msg) =\n+            let (nl, ol, new_loan_msg, old_loan_msg) = {\n                 if new_loan.loan_path.has_fork(&old_loan.loan_path) && common.is_some() {\n                     let nl = self.bccx.loan_path_to_string(&common.unwrap());\n                     let ol = nl.clone();\n-                    let new_loan_msg = format!(\" (here through borrowing `{}`)\",\n+                    let new_loan_msg = format!(\" (via `{}`)\",\n                                                self.bccx.loan_path_to_string(\n                                                    &new_loan.loan_path));\n-                    let old_loan_msg = format!(\" (through borrowing `{}`)\",\n+                    let old_loan_msg = format!(\" (via `{}`)\",\n                                                self.bccx.loan_path_to_string(\n                                                    &old_loan.loan_path));\n                     (nl, ol, new_loan_msg, old_loan_msg)\n                 } else {\n                     (self.bccx.loan_path_to_string(&new_loan.loan_path),\n                      self.bccx.loan_path_to_string(&old_loan.loan_path),\n-                     String::new(), String::new())\n-                };\n+                     String::new(),\n+                     String::new())\n+                }\n+            };\n \n             let ol_pronoun = if new_loan.loan_path == old_loan.loan_path {\n                 \"it\".to_string()\n             } else {\n                 format!(\"`{}`\", ol)\n             };\n \n+            // We want to assemble all the relevant locations for the error.\n+            //\n+            // 1. Where did the new loan occur.\n+            //    - if due to closure creation, where was the variable used in closure?\n+            // 2. Where did old loan occur.\n+            // 3. Where does old loan expire.\n+\n+            let previous_end_span =\n+                self.tcx().map.span(old_loan.kill_scope.node_id(&self.tcx().region_maps))\n+                              .end_point();\n+\n             let mut err = match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n                     struct_span_err!(self.bccx, new_loan.span, E0499,\n                                      \"cannot borrow `{}`{} as mutable \\\n                                       more than once at a time\",\n                                      nl, new_loan_msg)\n+                        .span_label(\n+                            old_loan.span,\n+                            &format!(\"first mutable borrow occurs here{}\", old_loan_msg))\n+                        .span_label(\n+                            new_loan.span,\n+                            &format!(\"second mutable borrow occurs here{}\", new_loan_msg))\n+                        .span_label(\n+                            previous_end_span,\n+                            &format!(\"first borrow ends here\"))\n+                }\n+\n+                (ty::UniqueImmBorrow, ty::UniqueImmBorrow) => {\n+                    struct_span_err!(self.bccx, new_loan.span, E0524,\n+                                     \"two closures require unique access to `{}` \\\n+                                      at the same time\",\n+                                     nl)\n+                        .span_label(\n+                            old_loan.span,\n+                            &format!(\"first closure is constructed here\"))\n+                        .span_label(\n+                            new_loan.span,\n+                            &format!(\"second closure is constructed here\"))\n+                        .span_label(\n+                            previous_end_span,\n+                            &format!(\"borrow from first closure ends here\"))\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n                     struct_span_err!(self.bccx, new_loan.span, E0500,\n                                      \"closure requires unique access to `{}` \\\n                                       but {} is already borrowed{}\",\n                                      nl, ol_pronoun, old_loan_msg)\n+                        .span_label(\n+                            new_loan.span,\n+                            &format!(\"closure construction occurs here{}\", new_loan_msg))\n+                        .span_label(\n+                            old_loan.span,\n+                            &format!(\"borrow occurs here{}\", old_loan_msg))\n+                        .span_label(\n+                            previous_end_span,\n+                            &format!(\"borrow ends here\"))\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n                     struct_span_err!(self.bccx, new_loan.span, E0501,\n                                      \"cannot borrow `{}`{} as {} because \\\n                                       previous closure requires unique access\",\n                                      nl, new_loan_msg, new_loan.kind.to_user_str())\n+                        .span_label(\n+                            new_loan.span,\n+                            &format!(\"borrow occurs here{}\", new_loan_msg))\n+                        .span_label(\n+                            old_loan.span,\n+                            &format!(\"closure construction occurs here{}\", old_loan_msg))\n+                        .span_label(\n+                            previous_end_span,\n+                            &format!(\"borrow from closure ends here\"))\n                 }\n \n                 (_, _) => {\n@@ -502,70 +558,42 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                      ol_pronoun,\n                                      old_loan.kind.to_user_str(),\n                                      old_loan_msg)\n+                        .span_label(\n+                            new_loan.span,\n+                            &format!(\"{} borrow occurs here{}\",\n+                                     new_loan.kind.to_user_str(),\n+                                     new_loan_msg))\n+                        .span_label(\n+                            old_loan.span,\n+                            &format!(\"{} borrow occurs here{}\",\n+                                     old_loan.kind.to_user_str(),\n+                                     old_loan_msg))\n+                        .span_label(\n+                            previous_end_span,\n+                            &format!(\"{} borrow ends here\",\n+                                     old_loan.kind.to_user_str()))\n                 }\n             };\n \n             match new_loan.cause {\n                 euv::ClosureCapture(span) => {\n-                    err.span_note(\n+                    err = err.span_label(\n                         span,\n-                        &format!(\"borrow occurs due to use of `{}` in closure\",\n-                                nl));\n+                        &format!(\"borrow occurs due to use of `{}` in closure\", nl));\n                 }\n                 _ => { }\n             }\n \n-            let rule_summary = match old_loan.kind {\n-                ty::MutBorrow => {\n-                    format!(\"the mutable borrow prevents subsequent \\\n-                            moves, borrows, or modification of `{0}` \\\n-                            until the borrow ends\",\n-                            ol)\n-                }\n-\n-                ty::ImmBorrow => {\n-                    format!(\"the immutable borrow prevents subsequent \\\n-                            moves or mutable borrows of `{0}` \\\n-                            until the borrow ends\",\n-                            ol)\n-                }\n-\n-                ty::UniqueImmBorrow => {\n-                    format!(\"the unique capture prevents subsequent \\\n-                            moves or borrows of `{0}` \\\n-                            until the borrow ends\",\n-                            ol)\n-                }\n-            };\n-\n-            let borrow_summary = match old_loan.cause {\n-                euv::ClosureCapture(_) => {\n-                    format!(\"previous borrow of `{}` occurs here{} due to \\\n-                            use in closure\",\n-                            ol, old_loan_msg)\n-                }\n-\n-                euv::OverloadedOperator |\n-                euv::AddrOf |\n-                euv::AutoRef |\n-                euv::AutoUnsafe |\n-                euv::ClosureInvocation |\n-                euv::ForLoop |\n-                euv::RefBinding |\n-                euv::MatchDiscriminant => {\n-                    format!(\"previous borrow of `{}` occurs here{}\",\n-                            ol, old_loan_msg)\n+            match old_loan.cause {\n+                euv::ClosureCapture(span) => {\n+                    err = err.span_label(\n+                        span,\n+                        &format!(\"previous borrow occurs due to use of `{}` in closure\",\n+                                 ol));\n                 }\n-            };\n-\n-            err.span_note(\n-                old_loan.span,\n-                &format!(\"{}; {}\", borrow_summary, rule_summary));\n+                _ => { }\n+            }\n \n-            let old_loan_span = self.tcx().map.span(\n-                old_loan.kill_scope.node_id(&self.tcx().region_maps));\n-            err.span_end_note(old_loan_span,\n-                              \"previous borrow ends here\");\n             err.emit();\n             return false;\n         }"}, {"sha": "87000749598a78d27c6021c4b3a1fbfc66f689c7", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 59, "deletions": 129, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca", "patch": "@@ -34,14 +34,14 @@ use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, TyCtxt};\n \n use std::fmt;\n use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::Span;\n+use syntax::codemap::{MultiSpan, Span};\n use syntax::errors::DiagnosticBuilder;\n \n use rustc::hir;\n@@ -633,23 +633,22 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                          lp: &LoanPath<'tcx>,\n                                          the_move: &move_data::Move,\n                                          moved_lp: &LoanPath<'tcx>,\n-                                         param_env: &ty::ParameterEnvironment<'b,'tcx>) {\n-        let verb = match use_kind {\n-            MovedInUse => \"use\",\n-            MovedInCapture => \"capture\",\n+                                         _param_env: &ty::ParameterEnvironment<'b,'tcx>) {\n+        let (verb, verb_participle) = match use_kind {\n+            MovedInUse => (\"use\", \"used\"),\n+            MovedInCapture => (\"capture\", \"captured\"),\n         };\n \n-        let (ol, moved_lp_msg, mut err) = match the_move.kind {\n+        let (_ol, _moved_lp_msg, mut err) = match the_move.kind {\n             move_data::Declared => {\n-                let err = struct_span_err!(\n+                // If this is an uninitialized variable, just emit a simple warning\n+                // and return.\n+                struct_span_err!(\n                     self.tcx.sess, use_span, E0381,\n                     \"{} of possibly uninitialized variable: `{}`\",\n                     verb,\n-                    self.loan_path_to_string(lp));\n-\n-                (self.loan_path_to_string(moved_lp),\n-                 String::new(),\n-                 err)\n+                    self.loan_path_to_string(lp)).emit();\n+                return;\n             }\n             _ => {\n                 // If moved_lp is something like `x.a`, and lp is something like `x.b`, we would\n@@ -688,122 +687,52 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     self.tcx.sess, use_span, E0382,\n                     \"{} of {}moved value: `{}`\",\n                     verb, msg, nl);\n-                (ol, moved_lp_msg, err)\n+                (ol, moved_lp_msg, err)}\n+        };\n+\n+        // Get type of value and span where it was previously\n+        // moved.\n+        let (move_span, move_note) = match the_move.kind {\n+            move_data::Declared => {\n+                unreachable!();\n             }\n+\n+            move_data::MoveExpr |\n+            move_data::MovePat =>\n+                (self.tcx.map.span(the_move.id), \"\"),\n+\n+            move_data::Captured =>\n+                (match self.tcx.map.expect_expr(the_move.id).node {\n+                    hir::ExprClosure(_, _, _, fn_decl_span) => fn_decl_span,\n+                    ref r => bug!(\"Captured({}) maps to non-closure: {:?}\",\n+                                  the_move.id, r),\n+                }, \" (into closure)\"),\n         };\n \n-        match the_move.kind {\n-            move_data::Declared => {}\n+        // Annotate the use and the move in the span. Watch out for\n+        // the case where the use and the move are the same. This\n+        // means the use is in a loop.\n+        err = if use_span == move_span {\n+            err.span_label(\n+                use_span,\n+                &format!(\"value moved{} here in previous iteration of loop\",\n+                         move_note))\n+        } else {\n+            err.span_label(use_span, &format!(\"value {} here after move\", verb_participle))\n+               .span_label(move_span, &format!(\"value moved{} here\", move_note))\n+        };\n \n-            move_data::MoveExpr => {\n-                let (expr_ty, expr_span) = match self.tcx\n-                                                     .map\n-                                                     .find(the_move.id) {\n-                    Some(hir_map::NodeExpr(expr)) => {\n-                        (self.tcx.expr_ty_adjusted(&expr), expr.span)\n-                    }\n-                    r => {\n-                        bug!(\"MoveExpr({}) maps to {:?}, not Expr\",\n-                             the_move.id,\n-                             r)\n-                    }\n-                };\n-                let (suggestion, _) =\n-                    move_suggestion(param_env, expr_span, expr_ty, (\"moved by default\", \"\"));\n-                // If the two spans are the same, it's because the expression will be evaluated\n-                // multiple times. Avoid printing the same span and adjust the wording so it makes\n-                // more sense that it's from multiple evalutations.\n-                if expr_span == use_span {\n-                    err.note(\n-                        &format!(\"`{}` was previously moved here{} because it has type `{}`, \\\n-                                  which is {}\",\n-                                 ol,\n-                                 moved_lp_msg,\n-                                 expr_ty,\n-                                 suggestion));\n-                } else {\n-                    err.span_note(\n-                        expr_span,\n-                        &format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n-                                 ol,\n-                                 moved_lp_msg,\n-                                 expr_ty,\n-                                 suggestion));\n-                }\n-            }\n+        err.note(&format!(\"move occurs because `{}` has type `{}`, \\\n+                           which does not implement the `Copy` trait\",\n+                          self.loan_path_to_string(moved_lp),\n+                          moved_lp.ty));\n \n-            move_data::MovePat => {\n-                let pat_ty = self.tcx.node_id_to_type(the_move.id);\n-                let span = self.tcx.map.span(the_move.id);\n-                err.span_note(span,\n-                    &format!(\"`{}` moved here{} because it has type `{}`, \\\n-                             which is moved by default\",\n-                            ol,\n-                            moved_lp_msg,\n-                            pat_ty));\n-                match self.tcx.sess.codemap().span_to_snippet(span) {\n-                    Ok(string) => {\n-                        err.span_suggestion(\n-                            span,\n-                            &format!(\"if you would like to borrow the value instead, \\\n-                                      use a `ref` binding as shown:\"),\n-                            format!(\"ref {}\", string));\n-                    },\n-                    Err(_) => {\n-                        err.fileline_help(span,\n-                            \"use `ref` to override\");\n-                    },\n-                }\n-            }\n+        // Note: we used to suggest adding a `ref binding` or calling\n+        // `clone` but those suggestions have been removed because\n+        // they are often not what you actually want to do, and were\n+        // not considered particularly helpful.\n \n-            move_data::Captured => {\n-                let (expr_ty, expr_span) = match self.tcx\n-                                                     .map\n-                                                     .find(the_move.id) {\n-                    Some(hir_map::NodeExpr(expr)) => {\n-                        (self.tcx.expr_ty_adjusted(&expr), expr.span)\n-                    }\n-                    r => {\n-                        bug!(\"Captured({}) maps to {:?}, not Expr\",\n-                             the_move.id,\n-                             r)\n-                    }\n-                };\n-                let (suggestion, help) =\n-                    move_suggestion(param_env,\n-                                    expr_span,\n-                                    expr_ty,\n-                                    (\"moved by default\",\n-                                     \"make a copy and capture that instead to override\"));\n-                err.span_note(\n-                    expr_span,\n-                    &format!(\"`{}` moved into closure environment here{} because it \\\n-                            has type `{}`, which is {}\",\n-                            ol,\n-                            moved_lp_msg,\n-                            moved_lp.ty,\n-                            suggestion));\n-                err.fileline_help(expr_span, help);\n-            }\n-        }\n         err.emit();\n-\n-        fn move_suggestion<'a,'tcx>(param_env: &ty::ParameterEnvironment<'a,'tcx>,\n-                                    span: Span,\n-                                    ty: Ty<'tcx>,\n-                                    default_msgs: (&'static str, &'static str))\n-                                    -> (&'static str, &'static str) {\n-            match ty.sty {\n-                _ => {\n-                    if ty.moves_by_default(param_env, span) {\n-                        (\"non-copyable\",\n-                         \"perhaps you meant to use `clone()`?\")\n-                    } else {\n-                        default_msgs\n-                    }\n-                }\n-            }\n-        }\n     }\n \n     pub fn report_partial_reinitialization_of_uninitialized_structure(\n@@ -833,19 +762,20 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err(s, m);\n     }\n \n-    pub fn struct_span_err(&self, s: Span, m: &str) -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_err<S: Into<MultiSpan>>(&self, s: S, m: &str)\n+                                              -> DiagnosticBuilder<'a> {\n         self.tcx.sess.struct_span_err(s, m)\n     }\n \n-    pub fn struct_span_err_with_code(&self,\n-                                     s: Span,\n-                                     msg: &str,\n-                                     code: &str)\n-                                     -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_err_with_code<S: Into<MultiSpan>>(&self,\n+                                                         s: S,\n+                                                         msg: &str,\n+                                                         code: &str)\n+                                                         -> DiagnosticBuilder<'a> {\n         self.tcx.sess.struct_span_err_with_code(s, msg, code)\n     }\n \n-    pub fn span_err_with_code(&self, s: Span, msg: &str, code: &str) {\n+    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, s: S, msg: &str, code: &str) {\n         self.tcx.sess.span_err_with_code(s, msg, code);\n     }\n "}, {"sha": "c7ad0b6a6c60640a1464bc503954004d206bed94", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca", "patch": "@@ -444,4 +444,5 @@ register_diagnostics! {\n     E0506, // cannot assign to `..` because it is borrowed\n     E0508, // cannot move out of type `..`, a non-copy fixed-size array\n     E0509, // cannot move out of type `..`, which defines the `Drop` trait\n+    E0524, // two closures require unique access to `..` at the same time\n }"}]}