{"sha": "7f1a6cd421d699aa249a282d7b5b7a8f486e3b01", "node_id": "C_kwDOAAsO6NoAKDdmMWE2Y2Q0MjFkNjk5YWEyNDlhMjgyZDdiNWI3YThmNDg2ZTNiMDE", "commit": {"author": {"name": "Ed Page", "email": "eopage@gmail.com", "date": "2023-05-13T16:47:14Z"}, "committer": {"name": "Ed Page", "email": "eopage@gmail.com", "date": "2023-05-13T16:47:14Z"}, "message": "refactor: Remove redundant, private OsStr::bytes", "tree": {"sha": "511041437bc484108fb22ec179cd2c8134ec93e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/511041437bc484108fb22ec179cd2c8134ec93e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01", "html_url": "https://github.com/rust-lang/rust/commit/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/comments", "author": {"login": "epage", "id": 60961, "node_id": "MDQ6VXNlcjYwOTYx", "avatar_url": "https://avatars.githubusercontent.com/u/60961?v=4", "gravatar_id": "", "url": "https://api.github.com/users/epage", "html_url": "https://github.com/epage", "followers_url": "https://api.github.com/users/epage/followers", "following_url": "https://api.github.com/users/epage/following{/other_user}", "gists_url": "https://api.github.com/users/epage/gists{/gist_id}", "starred_url": "https://api.github.com/users/epage/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/epage/subscriptions", "organizations_url": "https://api.github.com/users/epage/orgs", "repos_url": "https://api.github.com/users/epage/repos", "events_url": "https://api.github.com/users/epage/events{/privacy}", "received_events_url": "https://api.github.com/users/epage/received_events", "type": "User", "site_admin": false}, "committer": {"login": "epage", "id": 60961, "node_id": "MDQ6VXNlcjYwOTYx", "avatar_url": "https://avatars.githubusercontent.com/u/60961?v=4", "gravatar_id": "", "url": "https://api.github.com/users/epage", "html_url": "https://github.com/epage", "followers_url": "https://api.github.com/users/epage/followers", "following_url": "https://api.github.com/users/epage/following{/other_user}", "gists_url": "https://api.github.com/users/epage/gists{/gist_id}", "starred_url": "https://api.github.com/users/epage/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/epage/subscriptions", "organizations_url": "https://api.github.com/users/epage/orgs", "repos_url": "https://api.github.com/users/epage/repos", "events_url": "https://api.github.com/users/epage/events{/privacy}", "received_events_url": "https://api.github.com/users/epage/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d2beb50c2b228f4bd6f8e2d81d82c9e1f5e5ba2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d2beb50c2b228f4bd6f8e2d81d82c9e1f5e5ba2", "html_url": "https://github.com/rust-lang/rust/commit/8d2beb50c2b228f4bd6f8e2d81d82c9e1f5e5ba2"}], "stats": {"total": 89, "additions": 41, "deletions": 48}, "files": [{"sha": "90cbd57a9298f98a4800ce7c4710d9036e8b0178", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=7f1a6cd421d699aa249a282d7b5b7a8f486e3b01", "patch": "@@ -702,7 +702,7 @@ impl OsStr {\n     /// [conversions]: super#conversions\n     #[inline]\n     #[unstable(feature = \"os_str_bytes\", issue = \"111544\")]\n-    pub fn from_os_str_bytes_unchecked(bytes: &[u8]) -> &Self {\n+    pub unsafe fn from_os_str_bytes_unchecked(bytes: &[u8]) -> &Self {\n         Self::from_inner(Slice::from_os_str_bytes_unchecked(bytes))\n     }\n \n@@ -891,15 +891,6 @@ impl OsStr {\n         self.inner.as_os_str_bytes()\n     }\n \n-    /// Gets the underlying byte representation.\n-    ///\n-    /// Note: it is *crucial* that this API is not externally public, to avoid\n-    /// revealing the internal, platform-specific encodings.\n-    #[inline]\n-    pub(crate) fn bytes(&self) -> &[u8] {\n-        self.as_os_str_bytes()\n-    }\n-\n     /// Converts this string to its ASCII lower case equivalent in-place.\n     ///\n     /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n@@ -1185,7 +1176,7 @@ impl Default for &OsStr {\n impl PartialEq for OsStr {\n     #[inline]\n     fn eq(&self, other: &OsStr) -> bool {\n-        self.bytes().eq(other.bytes())\n+        self.as_os_str_bytes().eq(other.as_os_str_bytes())\n     }\n }\n \n@@ -1212,23 +1203,23 @@ impl Eq for OsStr {}\n impl PartialOrd for OsStr {\n     #[inline]\n     fn partial_cmp(&self, other: &OsStr) -> Option<cmp::Ordering> {\n-        self.bytes().partial_cmp(other.bytes())\n+        self.as_os_str_bytes().partial_cmp(other.as_os_str_bytes())\n     }\n     #[inline]\n     fn lt(&self, other: &OsStr) -> bool {\n-        self.bytes().lt(other.bytes())\n+        self.as_os_str_bytes().lt(other.as_os_str_bytes())\n     }\n     #[inline]\n     fn le(&self, other: &OsStr) -> bool {\n-        self.bytes().le(other.bytes())\n+        self.as_os_str_bytes().le(other.as_os_str_bytes())\n     }\n     #[inline]\n     fn gt(&self, other: &OsStr) -> bool {\n-        self.bytes().gt(other.bytes())\n+        self.as_os_str_bytes().gt(other.as_os_str_bytes())\n     }\n     #[inline]\n     fn ge(&self, other: &OsStr) -> bool {\n-        self.bytes().ge(other.bytes())\n+        self.as_os_str_bytes().ge(other.as_os_str_bytes())\n     }\n }\n \n@@ -1247,7 +1238,7 @@ impl PartialOrd<str> for OsStr {\n impl Ord for OsStr {\n     #[inline]\n     fn cmp(&self, other: &OsStr) -> cmp::Ordering {\n-        self.bytes().cmp(other.bytes())\n+        self.as_os_str_bytes().cmp(other.as_os_str_bytes())\n     }\n }\n \n@@ -1297,7 +1288,7 @@ impl_cmp!(Cow<'a, OsStr>, OsString);\n impl Hash for OsStr {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.bytes().hash(state)\n+        self.as_os_str_bytes().hash(state)\n     }\n }\n "}, {"sha": "6f770d4c91b19d0cf0bfe76cc16b76c4b08f6dc7", "filename": "library/std/src/path.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=7f1a6cd421d699aa249a282d7b5b7a8f486e3b01", "patch": "@@ -193,7 +193,7 @@ impl<'a> Prefix<'a> {\n     fn len(&self) -> usize {\n         use self::Prefix::*;\n         fn os_str_len(s: &OsStr) -> usize {\n-            s.bytes().len()\n+            s.as_os_str_bytes().len()\n         }\n         match *self {\n             Verbatim(x) => 4 + os_str_len(x),\n@@ -330,15 +330,15 @@ fn has_physical_root(s: &[u8], prefix: Option<Prefix<'_>>) -> bool {\n \n // basic workhorse for splitting stem and extension\n fn rsplit_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n-    if file.bytes() == b\"..\" {\n+    if file.as_os_str_bytes() == b\"..\" {\n         return (Some(file), None);\n     }\n \n     // The unsafety here stems from converting between &OsStr and &[u8]\n     // and back. This is safe to do because (1) we only look at ASCII\n     // contents of the encoding and (2) new &OsStr values are produced\n     // only from ASCII-bounded slices of existing &OsStr values.\n-    let mut iter = file.bytes().rsplitn(2, |b| *b == b'.');\n+    let mut iter = file.as_os_str_bytes().rsplitn(2, |b| *b == b'.');\n     let after = iter.next();\n     let before = iter.next();\n     if before == Some(b\"\") {\n@@ -349,7 +349,7 @@ fn rsplit_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n }\n \n fn split_file_at_dot(file: &OsStr) -> (&OsStr, Option<&OsStr>) {\n-    let slice = file.bytes();\n+    let slice = file.as_os_str_bytes();\n     if slice == b\"..\" {\n         return (file, None);\n     }\n@@ -1481,17 +1481,17 @@ impl PathBuf {\n     fn _set_extension(&mut self, extension: &OsStr) -> bool {\n         let file_stem = match self.file_stem() {\n             None => return false,\n-            Some(f) => f.bytes(),\n+            Some(f) => f.as_os_str_bytes(),\n         };\n \n         // truncate until right after the file stem\n         let end_file_stem = file_stem[file_stem.len()..].as_ptr().addr();\n-        let start = self.inner.bytes().as_ptr().addr();\n+        let start = self.inner.as_os_str_bytes().as_ptr().addr();\n         let v = self.as_mut_vec();\n         v.truncate(end_file_stem.wrapping_sub(start));\n \n         // add the new extension, if any\n-        let new = extension.bytes();\n+        let new = extension.as_os_str_bytes();\n         if !new.is_empty() {\n             v.reserve_exact(new.len() + 1);\n             v.push(b'.');\n@@ -2015,7 +2015,7 @@ impl Path {\n     }\n     // The following (private!) function reveals the byte encoding used for OsStr.\n     fn as_u8_slice(&self) -> &[u8] {\n-        self.inner.bytes()\n+        self.inner.as_os_str_bytes()\n     }\n \n     /// Directly wraps a string slice as a `Path` slice."}, {"sha": "963d17a47e4c022e3681ef96e1d8ab424855951d", "filename": "library/std/src/sys/common/small_c_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fsmall_c_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fsmall_c_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fsmall_c_string.rs?ref=7f1a6cd421d699aa249a282d7b5b7a8f486e3b01", "patch": "@@ -19,7 +19,7 @@ pub fn run_path_with_cstr<T, F>(path: &Path, f: F) -> io::Result<T>\n where\n     F: FnOnce(&CStr) -> io::Result<T>,\n {\n-    run_with_cstr(path.as_os_str().bytes(), f)\n+    run_with_cstr(path.as_os_str().as_os_str_bytes(), f)\n }\n \n #[inline]"}, {"sha": "0a1cbcbe8ef3789ed3554b7ab5a5832a0bacebaa", "filename": "library/std/src/sys/common/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Ftests.rs?ref=7f1a6cd421d699aa249a282d7b5b7a8f486e3b01", "patch": "@@ -8,7 +8,7 @@ use core::iter::repeat;\n fn stack_allocation_works() {\n     let path = Path::new(\"abc\");\n     let result = run_path_with_cstr(path, |p| {\n-        assert_eq!(p, &*CString::new(path.as_os_str().bytes()).unwrap());\n+        assert_eq!(p, &*CString::new(path.as_os_str().as_os_str_bytes()).unwrap());\n         Ok(42)\n     });\n     assert_eq!(result.unwrap(), 42);\n@@ -25,7 +25,7 @@ fn heap_allocation_works() {\n     let path = repeat(\"a\").take(384).collect::<String>();\n     let path = Path::new(&path);\n     let result = run_path_with_cstr(path, |p| {\n-        assert_eq!(p, &*CString::new(path.as_os_str().bytes()).unwrap());\n+        assert_eq!(p, &*CString::new(path.as_os_str().as_os_str_bytes()).unwrap());\n         Ok(42)\n     });\n     assert_eq!(result.unwrap(), 42);"}, {"sha": "935245f637b8670b03f42416224899df1f2eb7b3", "filename": "library/std/src/sys/unix/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs?ref=7f1a6cd421d699aa249a282d7b5b7a8f486e3b01", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn absolute(path: &Path) -> io::Result<PathBuf> {\n \n     // Get the components, skipping the redundant leading \".\" component if it exists.\n     let mut components = path.strip_prefix(\".\").unwrap_or(path).components();\n-    let path_os = path.as_os_str().bytes();\n+    let path_os = path.as_os_str().as_os_str_bytes();\n \n     let mut normalized = if path.is_absolute() {\n         // \"If a pathname begins with two successive <slash> characters, the"}, {"sha": "640648e870748b4e60dc2100bcb5cfcc3a0ee92c", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=7f1a6cd421d699aa249a282d7b5b7a8f486e3b01", "patch": "@@ -164,9 +164,9 @@ pub enum ProgramKind {\n \n impl ProgramKind {\n     fn new(program: &OsStr) -> Self {\n-        if program.bytes().starts_with(b\"/\") {\n+        if program.as_os_str_bytes().starts_with(b\"/\") {\n             Self::Absolute\n-        } else if program.bytes().contains(&b'/') {\n+        } else if program.as_os_str_bytes().contains(&b'/') {\n             // If the program has more than one component in it, it is a relative path.\n             Self::Relative\n         } else {"}, {"sha": "6b597f499bcdc18a2b74d8b4965c166faddc5e33", "filename": "library/std/src/sys/windows/args.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs?ref=7f1a6cd421d699aa249a282d7b5b7a8f486e3b01", "patch": "@@ -226,7 +226,7 @@ pub(crate) fn append_arg(cmd: &mut Vec<u16>, arg: &Arg, force_quotes: bool) -> i\n     // that it actually gets passed through on the command line or otherwise\n     // it will be dropped entirely when parsed on the other end.\n     ensure_no_nuls(arg)?;\n-    let arg_bytes = arg.bytes();\n+    let arg_bytes = arg.as_os_str_bytes();\n     let (quote, escape) = match quote {\n         Quote::Always => (true, true),\n         Quote::Auto => {\n@@ -297,7 +297,9 @@ pub(crate) fn make_bat_command_line(\n         // * `|<>` pipe/redirect characters.\n         const SPECIAL: &[u8] = b\"\\t &()[]{}^=;!'+,`~%|<>\";\n         let force_quotes = match arg {\n-            Arg::Regular(arg) if !force_quotes => arg.bytes().iter().any(|c| SPECIAL.contains(c)),\n+            Arg::Regular(arg) if !force_quotes => {\n+                arg.as_os_str_bytes().iter().any(|c| SPECIAL.contains(c))\n+            }\n             _ => force_quotes,\n         };\n         append_arg(&mut cmd, arg, force_quotes)?;"}, {"sha": "7a65d901ad2e1873b24b022f8c01db7e027c2850", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=7f1a6cd421d699aa249a282d7b5b7a8f486e3b01", "patch": "@@ -33,12 +33,12 @@ pub fn is_verbatim_sep(b: u8) -> bool {\n \n /// Returns true if `path` looks like a lone filename.\n pub(crate) fn is_file_name(path: &OsStr) -> bool {\n-    !path.bytes().iter().copied().any(is_sep_byte)\n+    !path.as_os_str_bytes().iter().copied().any(is_sep_byte)\n }\n pub(crate) fn has_trailing_slash(path: &OsStr) -> bool {\n-    let is_verbatim = path.bytes().starts_with(br\"\\\\?\\\");\n+    let is_verbatim = path.as_os_str_bytes().starts_with(br\"\\\\?\\\");\n     let is_separator = if is_verbatim { is_verbatim_sep } else { is_sep_byte };\n-    if let Some(&c) = path.bytes().last() { is_separator(c) } else { false }\n+    if let Some(&c) = path.as_os_str_bytes().last() { is_separator(c) } else { false }\n }\n \n /// Appends a suffix to a path.\n@@ -60,7 +60,7 @@ impl<'a, const LEN: usize> PrefixParser<'a, LEN> {\n     fn get_prefix(path: &OsStr) -> [u8; LEN] {\n         let mut prefix = [0; LEN];\n         // SAFETY: Only ASCII characters are modified.\n-        for (i, &ch) in path.bytes().iter().take(LEN).enumerate() {\n+        for (i, &ch) in path.as_os_str_bytes().iter().take(LEN).enumerate() {\n             prefix[i] = if ch == b'/' { b'\\\\' } else { ch };\n         }\n         prefix\n@@ -93,15 +93,15 @@ impl<'a> PrefixParserSlice<'a, '_> {\n     }\n \n     fn prefix_bytes(&self) -> &'a [u8] {\n-        &self.path.bytes()[..self.index]\n+        &self.path.as_os_str_bytes()[..self.index]\n     }\n \n     fn finish(self) -> &'a OsStr {\n         // SAFETY: The unsafety here stems from converting between &OsStr and\n         // &[u8] and back. This is safe to do because (1) we only look at ASCII\n         // contents of the encoding and (2) new &OsStr values are produced only\n         // from ASCII-bounded slices of existing &OsStr values.\n-        unsafe { bytes_as_os_str(&self.path.bytes()[self.index..]) }\n+        unsafe { bytes_as_os_str(&self.path.as_os_str_bytes()[self.index..]) }\n     }\n }\n \n@@ -173,7 +173,7 @@ fn parse_drive(path: &OsStr) -> Option<u8> {\n         drive.is_ascii_alphabetic()\n     }\n \n-    match path.bytes() {\n+    match path.as_os_str_bytes() {\n         [drive, b':', ..] if is_valid_drive_letter(drive) => Some(drive.to_ascii_uppercase()),\n         _ => None,\n     }\n@@ -182,7 +182,7 @@ fn parse_drive(path: &OsStr) -> Option<u8> {\n // Parses a drive prefix exactly, e.g. \"C:\"\n fn parse_drive_exact(path: &OsStr) -> Option<u8> {\n     // only parse two bytes: the drive letter and the drive separator\n-    if path.bytes().get(2).map(|&x| is_sep_byte(x)).unwrap_or(true) {\n+    if path.as_os_str_bytes().get(2).map(|&x| is_sep_byte(x)).unwrap_or(true) {\n         parse_drive(path)\n     } else {\n         None\n@@ -196,15 +196,15 @@ fn parse_drive_exact(path: &OsStr) -> Option<u8> {\n fn parse_next_component(path: &OsStr, verbatim: bool) -> (&OsStr, &OsStr) {\n     let separator = if verbatim { is_verbatim_sep } else { is_sep_byte };\n \n-    match path.bytes().iter().position(|&x| separator(x)) {\n+    match path.as_os_str_bytes().iter().position(|&x| separator(x)) {\n         Some(separator_start) => {\n             let separator_end = separator_start + 1;\n \n-            let component = &path.bytes()[..separator_start];\n+            let component = &path.as_os_str_bytes()[..separator_start];\n \n             // Panic safe\n             // The max `separator_end` is `bytes.len()` and `bytes[bytes.len()..]` is a valid index.\n-            let path = &path.bytes()[separator_end..];\n+            let path = &path.as_os_str_bytes()[separator_end..];\n \n             // SAFETY: `path` is a valid wtf8 encoded slice and each of the separators ('/', '\\')\n             // is encoded in a single byte, therefore `bytes[separator_start]` and\n@@ -329,7 +329,7 @@ pub(crate) fn absolute(path: &Path) -> io::Result<PathBuf> {\n     // Verbatim paths should not be modified.\n     if prefix.map(|x| x.is_verbatim()).unwrap_or(false) {\n         // NULs in verbatim paths are rejected for consistency.\n-        if path.bytes().contains(&0) {\n+        if path.as_os_str_bytes().contains(&0) {\n             return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n                 \"strings passed to WinAPI cannot contain NULs\","}, {"sha": "a573a05c39cd913c5482068b5686cde87a248aec", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1a6cd421d699aa249a282d7b5b7a8f486e3b01/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=7f1a6cd421d699aa249a282d7b5b7a8f486e3b01", "patch": "@@ -395,7 +395,7 @@ fn resolve_exe<'a>(\n     // Test if the file name has the `exe` extension.\n     // This does a case-insensitive `ends_with`.\n     let has_exe_suffix = if exe_path.len() >= EXE_SUFFIX.len() {\n-        exe_path.bytes()[exe_path.len() - EXE_SUFFIX.len()..]\n+        exe_path.as_os_str_bytes()[exe_path.len() - EXE_SUFFIX.len()..]\n             .eq_ignore_ascii_case(EXE_SUFFIX.as_bytes())\n     } else {\n         false\n@@ -425,7 +425,7 @@ fn resolve_exe<'a>(\n         // From the `CreateProcessW` docs:\n         // > If the file name does not contain an extension, .exe is appended.\n         // Note that this rule only applies when searching paths.\n-        let has_extension = exe_path.bytes().contains(&b'.');\n+        let has_extension = exe_path.as_os_str_bytes().contains(&b'.');\n \n         // Search the directories given by `search_paths`.\n         let result = search_paths(parent_paths, child_paths, |mut path| {"}]}