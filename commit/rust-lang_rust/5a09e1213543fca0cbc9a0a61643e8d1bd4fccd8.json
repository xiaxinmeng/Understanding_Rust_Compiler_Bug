{"sha": "5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8", "node_id": "C_kwDOAAsO6NoAKDVhMDllMTIxMzU0M2ZjYTBjYmM5YTBhNjE2NDNlOGQxYmQ0ZmNjZDg", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-11-05T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-11-05T16:47:11Z"}, "message": "Initialize LLVM time trace profiler on each code generation thread\n\nIn https://reviews.llvm.org/D71059 LLVM 11, the time trace profiler was\nextended to support multiple threads.\n\n`timeTraceProfilerInitialize` creates a thread local profiler instance.\nWhen a thread finishes `timeTraceProfilerFinishThread` moves a thread\nlocal instance into a global collection of instances. Finally when all\ncodegen work is complete `timeTraceProfilerWrite` writes data from the\ncurrent thread local instance and the instances in global collection\nof instances.\n\nPreviously, the profiler was intialized on a single thread only. Since\nthis thread performs no code generation on its own, the resulting\nprofile was empty.\n\nUpdate LLVM codegen to initialize & finish time trace profiler on each\ncode generation thread.", "tree": {"sha": "ad40a748f2f13decb0537bf651da8d2c0230e568", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad40a748f2f13decb0537bf651da8d2c0230e568"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8", "html_url": "https://github.com/rust-lang/rust/commit/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d22dd65835190278f315e06442614142653ec98f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d22dd65835190278f315e06442614142653ec98f", "html_url": "https://github.com/rust-lang/rust/commit/d22dd65835190278f315e06442614142653ec98f"}], "stats": {"total": 184, "additions": 128, "deletions": 56}, "files": [{"sha": "64fedb7bc1a5cbb7b20559e67dd126d563a9e403", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8", "patch": "@@ -76,6 +76,27 @@ mod value;\n #[derive(Clone)]\n pub struct LlvmCodegenBackend(());\n \n+struct TimeTraceProfiler {\n+    enabled: bool,\n+}\n+\n+impl TimeTraceProfiler {\n+    fn new(enabled: bool) -> Self {\n+        if enabled {\n+            unsafe { llvm::LLVMTimeTraceProfilerInitialize() }\n+        }\n+        TimeTraceProfiler { enabled }\n+    }\n+}\n+\n+impl Drop for TimeTraceProfiler {\n+    fn drop(&mut self) {\n+        if self.enabled {\n+            unsafe { llvm::LLVMTimeTraceProfilerFinishThread() }\n+        }\n+    }\n+}\n+\n impl ExtraBackendMethods for LlvmCodegenBackend {\n     fn new_metadata(&self, tcx: TyCtxt<'_>, mod_name: &str) -> ModuleLlvm {\n         ModuleLlvm::new_metadata(tcx, mod_name)\n@@ -119,6 +140,34 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n     fn tune_cpu<'b>(&self, sess: &'b Session) -> Option<&'b str> {\n         llvm_util::tune_cpu(sess)\n     }\n+\n+    fn spawn_thread<F, T>(time_trace: bool, f: F) -> std::thread::JoinHandle<T>\n+    where\n+        F: FnOnce() -> T,\n+        F: Send + 'static,\n+        T: Send + 'static,\n+    {\n+        std::thread::spawn(move || {\n+            let _profiler = TimeTraceProfiler::new(time_trace);\n+            f()\n+        })\n+    }\n+\n+    fn spawn_named_thread<F, T>(\n+        time_trace: bool,\n+        name: String,\n+        f: F,\n+    ) -> std::io::Result<std::thread::JoinHandle<T>>\n+    where\n+        F: FnOnce() -> T,\n+        F: Send + 'static,\n+        T: Send + 'static,\n+    {\n+        std::thread::Builder::new().name(name).spawn(move || {\n+            let _profiler = TimeTraceProfiler::new(time_trace);\n+            f()\n+        })\n+    }\n }\n \n impl WriteBackendMethods for LlvmCodegenBackend {"}, {"sha": "749eec459aca1334be2f17da146280b6cb3fcc5c", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8", "patch": "@@ -1737,6 +1737,8 @@ extern \"C\" {\n \n     pub fn LLVMTimeTraceProfilerInitialize();\n \n+    pub fn LLVMTimeTraceProfilerFinishThread();\n+\n     pub fn LLVMTimeTraceProfilerFinish(FileName: *const c_char);\n \n     pub fn LLVMAddAnalysisPasses(T: &'a TargetMachine, PM: &PassManager<'a>);"}, {"sha": "34c28938c85d3591f217aa00a0ba83714b0ffc42", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8", "patch": "@@ -113,11 +113,6 @@ unsafe fn configure_llvm(sess: &Session) {\n     }\n \n     if sess.opts.debugging_opts.llvm_time_trace {\n-        // time-trace is not thread safe and running it in parallel will cause seg faults.\n-        if !sess.opts.debugging_opts.no_parallel_llvm {\n-            bug!(\"`-Z llvm-time-trace` requires `-Z no-parallel-llvm\")\n-        }\n-\n         llvm::LLVMTimeTraceProfilerInitialize();\n     }\n "}, {"sha": "b2edc6c0183a0b8ce13475e2d3b406c18105221a", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8", "patch": "@@ -310,6 +310,7 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub no_landing_pads: bool,\n     pub save_temps: bool,\n     pub fewer_names: bool,\n+    pub time_trace: bool,\n     pub exported_symbols: Option<Arc<ExportedSymbols>>,\n     pub opts: Arc<config::Options>,\n     pub crate_types: Vec<CrateType>,\n@@ -1039,6 +1040,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         no_landing_pads: sess.panic_strategy() == PanicStrategy::Abort,\n         fewer_names: sess.fewer_names(),\n         save_temps: sess.opts.cg.save_temps,\n+        time_trace: sess.opts.debugging_opts.llvm_time_trace,\n         opts: Arc::new(sess.opts.clone()),\n         prof: sess.prof.clone(),\n         exported_symbols,\n@@ -1198,7 +1200,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     // Each LLVM module is automatically sent back to the coordinator for LTO if\n     // necessary. There's already optimizations in place to avoid sending work\n     // back to the coordinator if LTO isn't requested.\n-    return thread::spawn(move || {\n+    return B::spawn_thread(cgcx.time_trace, move || {\n         let mut worker_id_counter = 0;\n         let mut free_worker_ids = Vec::new();\n         let mut get_worker_id = |free_worker_ids: &mut Vec<usize>| {\n@@ -1615,59 +1617,57 @@ fn start_executing_work<B: ExtraBackendMethods>(\n pub struct WorkerFatalError;\n \n fn spawn_work<B: ExtraBackendMethods>(cgcx: CodegenContext<B>, work: WorkItem<B>) {\n-    let builder = thread::Builder::new().name(work.short_description());\n-    builder\n-        .spawn(move || {\n-            // Set up a destructor which will fire off a message that we're done as\n-            // we exit.\n-            struct Bomb<B: ExtraBackendMethods> {\n-                coordinator_send: Sender<Box<dyn Any + Send>>,\n-                result: Option<Result<WorkItemResult<B>, FatalError>>,\n-                worker_id: usize,\n-            }\n-            impl<B: ExtraBackendMethods> Drop for Bomb<B> {\n-                fn drop(&mut self) {\n-                    let worker_id = self.worker_id;\n-                    let msg = match self.result.take() {\n-                        Some(Ok(WorkItemResult::Compiled(m))) => {\n-                            Message::Done::<B> { result: Ok(m), worker_id }\n-                        }\n-                        Some(Ok(WorkItemResult::NeedsLink(m))) => {\n-                            Message::NeedsLink::<B> { module: m, worker_id }\n-                        }\n-                        Some(Ok(WorkItemResult::NeedsFatLTO(m))) => {\n-                            Message::NeedsFatLTO::<B> { result: m, worker_id }\n-                        }\n-                        Some(Ok(WorkItemResult::NeedsThinLTO(name, thin_buffer))) => {\n-                            Message::NeedsThinLTO::<B> { name, thin_buffer, worker_id }\n-                        }\n-                        Some(Err(FatalError)) => {\n-                            Message::Done::<B> { result: Err(Some(WorkerFatalError)), worker_id }\n-                        }\n-                        None => Message::Done::<B> { result: Err(None), worker_id },\n-                    };\n-                    drop(self.coordinator_send.send(Box::new(msg)));\n-                }\n+    B::spawn_named_thread(cgcx.time_trace, work.short_description(), move || {\n+        // Set up a destructor which will fire off a message that we're done as\n+        // we exit.\n+        struct Bomb<B: ExtraBackendMethods> {\n+            coordinator_send: Sender<Box<dyn Any + Send>>,\n+            result: Option<Result<WorkItemResult<B>, FatalError>>,\n+            worker_id: usize,\n+        }\n+        impl<B: ExtraBackendMethods> Drop for Bomb<B> {\n+            fn drop(&mut self) {\n+                let worker_id = self.worker_id;\n+                let msg = match self.result.take() {\n+                    Some(Ok(WorkItemResult::Compiled(m))) => {\n+                        Message::Done::<B> { result: Ok(m), worker_id }\n+                    }\n+                    Some(Ok(WorkItemResult::NeedsLink(m))) => {\n+                        Message::NeedsLink::<B> { module: m, worker_id }\n+                    }\n+                    Some(Ok(WorkItemResult::NeedsFatLTO(m))) => {\n+                        Message::NeedsFatLTO::<B> { result: m, worker_id }\n+                    }\n+                    Some(Ok(WorkItemResult::NeedsThinLTO(name, thin_buffer))) => {\n+                        Message::NeedsThinLTO::<B> { name, thin_buffer, worker_id }\n+                    }\n+                    Some(Err(FatalError)) => {\n+                        Message::Done::<B> { result: Err(Some(WorkerFatalError)), worker_id }\n+                    }\n+                    None => Message::Done::<B> { result: Err(None), worker_id },\n+                };\n+                drop(self.coordinator_send.send(Box::new(msg)));\n             }\n+        }\n \n-            let mut bomb = Bomb::<B> {\n-                coordinator_send: cgcx.coordinator_send.clone(),\n-                result: None,\n-                worker_id: cgcx.worker,\n-            };\n+        let mut bomb = Bomb::<B> {\n+            coordinator_send: cgcx.coordinator_send.clone(),\n+            result: None,\n+            worker_id: cgcx.worker,\n+        };\n \n-            // Execute the work itself, and if it finishes successfully then flag\n-            // ourselves as a success as well.\n-            //\n-            // Note that we ignore any `FatalError` coming out of `execute_work_item`,\n-            // as a diagnostic was already sent off to the main thread - just\n-            // surface that there was an error in this worker.\n-            bomb.result = {\n-                let _prof_timer = work.start_profiling(&cgcx);\n-                Some(execute_work_item(&cgcx, work))\n-            };\n-        })\n-        .expect(\"failed to spawn thread\");\n+        // Execute the work itself, and if it finishes successfully then flag\n+        // ourselves as a success as well.\n+        //\n+        // Note that we ignore any `FatalError` coming out of `execute_work_item`,\n+        // as a diagnostic was already sent off to the main thread - just\n+        // surface that there was an error in this worker.\n+        bomb.result = {\n+            let _prof_timer = work.start_profiling(&cgcx);\n+            Some(execute_work_item(&cgcx, work))\n+        };\n+    })\n+    .expect(\"failed to spawn thread\");\n }\n \n enum SharedEmitterMessage {"}, {"sha": "9c8bc3b2109881be537bd36682c4cc80cab8adb5", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8", "patch": "@@ -142,4 +142,26 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n     ) -> TargetMachineFactoryFn<Self>;\n     fn target_cpu<'b>(&self, sess: &'b Session) -> &'b str;\n     fn tune_cpu<'b>(&self, sess: &'b Session) -> Option<&'b str>;\n+\n+    fn spawn_thread<F, T>(_time_trace: bool, f: F) -> std::thread::JoinHandle<T>\n+    where\n+        F: FnOnce() -> T,\n+        F: Send + 'static,\n+        T: Send + 'static,\n+    {\n+        std::thread::spawn(f)\n+    }\n+\n+    fn spawn_named_thread<F, T>(\n+        _time_trace: bool,\n+        name: String,\n+        f: F,\n+    ) -> std::io::Result<std::thread::JoinHandle<T>>\n+    where\n+        F: FnOnce() -> T,\n+        F: Send + 'static,\n+        T: Send + 'static,\n+    {\n+        std::thread::Builder::new().name(name).spawn(f)\n+    }\n }"}, {"sha": "ddbc3c5912836f1f8a9b3525c6045d9715fbca41", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=5a09e1213543fca0cbc9a0a61643e8d1bd4fccd8", "patch": "@@ -75,6 +75,10 @@ extern \"C\" void LLVMTimeTraceProfilerInitialize() {\n       /* ProcName */ \"rustc\");\n }\n \n+extern \"C\" void LLVMTimeTraceProfilerFinishThread() {\n+  timeTraceProfilerFinishThread();\n+}\n+\n extern \"C\" void LLVMTimeTraceProfilerFinish(const char* FileName) {\n   StringRef FN(FileName);\n   std::error_code EC;"}]}