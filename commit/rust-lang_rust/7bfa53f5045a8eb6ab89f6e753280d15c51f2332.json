{"sha": "7bfa53f5045a8eb6ab89f6e753280d15c51f2332", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiZmE1M2Y1MDQ1YThlYjZhYjg5ZjZlNzUzMjgwZDE1YzUxZjIzMzI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-01T17:46:18Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-01T17:46:18Z"}, "message": "Almost there", "tree": {"sha": "3e313634308e1497ef287f55cb19c0a0752c3779", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e313634308e1497ef287f55cb19c0a0752c3779"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bfa53f5045a8eb6ab89f6e753280d15c51f2332", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bfa53f5045a8eb6ab89f6e753280d15c51f2332", "html_url": "https://github.com/rust-lang/rust/commit/7bfa53f5045a8eb6ab89f6e753280d15c51f2332", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bfa53f5045a8eb6ab89f6e753280d15c51f2332/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f0fd15da9b65a738f20f1fdad6dcc728bcf6c11", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f0fd15da9b65a738f20f1fdad6dcc728bcf6c11", "html_url": "https://github.com/rust-lang/rust/commit/6f0fd15da9b65a738f20f1fdad6dcc728bcf6c11"}], "stats": {"total": 229, "additions": 70, "deletions": 159}, "files": [{"sha": "b38b906b4a65659befc57f17196cdf433cb29490", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 60, "deletions": 54, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/7bfa53f5045a8eb6ab89f6e753280d15c51f2332/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfa53f5045a8eb6ab89f6e753280d15c51f2332/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=7bfa53f5045a8eb6ab89f6e753280d15c51f2332", "patch": "@@ -3,14 +3,15 @@\n use rustc::lint::LateContext;\n use rustc::hir::def::Def;\n use rustc_const_eval::lookup_const_by_id;\n-use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n+use rustc_const_math::ConstInt;\n use rustc::hir::*;\n+use rustc::ty::{TyCtxt, self};\n use std::cmp::Ordering::{self, Equal};\n use std::cmp::PartialOrd;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::rc::Rc;\n-use syntax::ast::{FloatTy, LitIntType, LitKind, StrStyle, UintTy, IntTy, NodeId};\n+use syntax::ast::{FloatTy, LitKind, StrStyle, NodeId};\n use syntax::ptr::P;\n \n #[derive(Debug, Copy, Clone)]\n@@ -174,29 +175,36 @@ impl PartialOrd for Constant {\n \n /// parse a `LitKind` to a `Constant`\n #[allow(cast_possible_wrap)]\n-pub fn lit_to_constant(lit: &LitKind) -> Constant {\n+pub fn lit_to_constant<'a, 'tcx>(lit: &LitKind, tcx: TyCtxt<'a, 'tcx, 'tcx>, mut ty: ty::Ty<'tcx>) -> Constant {\n+    use syntax::ast::*;\n+    use syntax::ast::LitIntType::*;\n+    use rustc::ty::util::IntTypeExt;\n+\n+    if let ty::TyAdt(adt, _) = ty.sty {\n+        if adt.is_enum() {\n+            ty = adt.repr.discr_type().to_ty(tcx)\n+        }\n+    }\n     match *lit {\n         LitKind::Str(ref is, style) => Constant::Str(is.to_string(), style),\n         LitKind::Byte(b) => Constant::Int(ConstInt::U8(b)),\n         LitKind::ByteStr(ref s) => Constant::Binary(s.clone()),\n         LitKind::Char(c) => Constant::Char(c),\n-        LitKind::Int(value, LitIntType::Unsuffixed) => Constant::Int(ConstInt::U128(value as u128)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U8)) => Constant::Int(ConstInt::U8(value as u8)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U16)) => Constant::Int(ConstInt::U16(value as u16)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U32)) => Constant::Int(ConstInt::U32(value as u32)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U64)) => Constant::Int(ConstInt::U64(value as u64)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U128)) => Constant::Int(ConstInt::U128(value as u128)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::Us)) => {\n-            Constant::Int(ConstInt::Usize(ConstUsize::Us32(value as u32)))\n-        },\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I8)) => Constant::Int(ConstInt::I8(value as i8)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I16)) => Constant::Int(ConstInt::I16(value as i16)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I32)) => Constant::Int(ConstInt::I32(value as i32)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I64)) => Constant::Int(ConstInt::I64(value as i64)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I128)) => Constant::Int(ConstInt::I128(value as i128)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::Is)) => {\n-            Constant::Int(ConstInt::Isize(ConstIsize::Is32(value as i32)))\n-        },\n+        LitKind::Int(n, hint) => {\n+            match (&ty.sty, hint) {\n+                (&ty::TyInt(ity), _) |\n+                (_, Signed(ity)) => {\n+                    Constant::Int(ConstInt::new_signed_truncating(n as i128,\n+                        ity, tcx.sess.target.int_type))\n+                }\n+                (&ty::TyUint(uty), _) |\n+                (_, Unsigned(uty)) => {\n+                    Constant::Int(ConstInt::new_unsigned_truncating(n as u128,\n+                        uty, tcx.sess.target.uint_type))\n+                }\n+                _ => bug!()\n+            }\n+        }\n         LitKind::Float(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n         LitKind::FloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FloatWidth::Any),\n         LitKind::Bool(b) => Constant::Bool(b),\n@@ -231,22 +239,20 @@ fn neg_float_str(s: &str) -> String {\n \n pub fn constant(lcx: &LateContext, e: &Expr) -> Option<(Constant, bool)> {\n     let mut cx = ConstEvalLateContext {\n-        lcx: Some(lcx),\n+        tcx: lcx.tcx,\n+        tables: lcx.tables,\n         needed_resolution: false,\n     };\n     cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n }\n \n-pub fn constant_simple(e: &Expr) -> Option<Constant> {\n-    let mut cx = ConstEvalLateContext {\n-        lcx: None,\n-        needed_resolution: false,\n-    };\n-    cx.expr(e)\n+pub fn constant_simple(lcx: &LateContext, e: &Expr) -> Option<Constant> {\n+    constant(lcx, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n }\n \n-struct ConstEvalLateContext<'c, 'cc: 'c> {\n-    lcx: Option<&'c LateContext<'c, 'cc>>,\n+struct ConstEvalLateContext<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::TypeckTables<'tcx>,\n     needed_resolution: bool,\n }\n \n@@ -257,17 +263,14 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             ExprPath(ref qpath) => self.fetch_path(qpath, e.id),\n             ExprBlock(ref block) => self.block(block),\n             ExprIf(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n-            ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n+            ExprLit(ref lit) => Some(lit_to_constant(&lit.node, self.tcx, self.tables.expr_ty(e))),\n             ExprArray(ref vec) => self.multi(vec).map(Constant::Vec),\n             ExprTup(ref tup) => self.multi(tup).map(Constant::Tuple),\n             ExprRepeat(ref value, number_id) => {\n-                if let Some(lcx) = self.lcx {\n-                    self.binop_apply(value,\n-                                     &lcx.tcx.hir.body(number_id).value,\n-                                     |v, n| Some(Constant::Repeat(Box::new(v), n.as_u64() as usize)))\n-                } else {\n-                    None\n-                }\n+                let val = &self.tcx.hir.body(number_id).value;\n+                self.binop_apply(value,\n+                                 val,\n+                                 |v, n| Some(Constant::Repeat(Box::new(v), n.as_u64() as usize)))\n             },\n             ExprUnary(op, ref operand) => {\n                 self.expr(operand).and_then(|o| match op {\n@@ -292,24 +295,27 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n \n     /// lookup a possibly constant expression from a ExprPath\n     fn fetch_path(&mut self, qpath: &QPath, id: NodeId) -> Option<Constant> {\n-        if let Some(lcx) = self.lcx {\n-            let def = lcx.tables.qpath_def(qpath, id);\n-            match def {\n-                Def::Const(def_id) |\n-                Def::AssociatedConst(def_id) => {\n-                    let substs = lcx.tables\n-                        .node_id_item_substs(id)\n-                        .unwrap_or_else(|| lcx.tcx.intern_substs(&[]));\n-                    if let Some((const_expr, _ty)) = lookup_const_by_id(lcx.tcx, def_id, substs) {\n-                        let ret = self.expr(const_expr);\n-                        if ret.is_some() {\n-                            self.needed_resolution = true;\n-                        }\n-                        return ret;\n+        let def = self.tables.qpath_def(qpath, id);\n+        match def {\n+            Def::Const(def_id) |\n+            Def::AssociatedConst(def_id) => {\n+                let substs = self.tables\n+                    .node_id_item_substs(id)\n+                    .unwrap_or_else(|| self.tcx.intern_substs(&[]));\n+                if let Some((const_expr, tables)) = lookup_const_by_id(self.tcx, def_id, substs) {\n+                    let mut cx = ConstEvalLateContext {\n+                        tcx: self.tcx,\n+                        tables,\n+                        needed_resolution: false,\n+                    };\n+                    let ret = cx.expr(const_expr);\n+                    if ret.is_some() {\n+                        self.needed_resolution = true;\n                     }\n-                },\n-                _ => {},\n-            }\n+                    return ret;\n+                }\n+            },\n+            _ => {},\n         }\n         None\n     }"}, {"sha": "a0a61a0ee1efde8b547807d6f9c6d446a5a0b81d", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bfa53f5045a8eb6ab89f6e753280d15c51f2332/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfa53f5045a8eb6ab89f6e753280d15c51f2332/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=7bfa53f5045a8eb6ab89f6e753280d15c51f2332", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n \n \n fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n-    if let Some(Constant::Int(v)) = constant_simple(e) {\n+    if let Some(Constant::Int(v)) = constant_simple(cx, e) {\n         if match m {\n             0 => v.to_u128_unchecked() == 0,\n             -1 => match v.int_type() {"}, {"sha": "2c6553e90c93de2ad8b73bef87a1366e4debc425", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bfa53f5045a8eb6ab89f6e753280d15c51f2332/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfa53f5045a8eb6ab89f6e753280d15c51f2332/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=7bfa53f5045a8eb6ab89f6e753280d15c51f2332", "patch": "@@ -65,9 +65,9 @@ fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'\n             let def_id = cx.tables.qpath_def(qpath, path.id).def_id();\n \n             if match_def_path(cx.tcx, def_id, &paths::CMP_MIN) {\n-                fetch_const(args, MinMax::Min)\n+                fetch_const(cx, args, MinMax::Min)\n             } else if match_def_path(cx.tcx, def_id, &paths::CMP_MAX) {\n-                fetch_const(args, MinMax::Max)\n+                fetch_const(cx, args, MinMax::Max)\n             } else {\n                 None\n             }\n@@ -79,18 +79,18 @@ fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'\n     }\n }\n \n-fn fetch_const(args: &[Expr], m: MinMax) -> Option<(MinMax, Constant, &Expr)> {\n+fn fetch_const<'a>(cx: &LateContext, args: &'a [Expr], m: MinMax) -> Option<(MinMax, Constant, &'a Expr)> {\n     if args.len() != 2 {\n         return None;\n     }\n-    if let Some(c) = constant_simple(&args[0]) {\n-        if constant_simple(&args[1]).is_none() {\n+    if let Some(c) = constant_simple(cx, &args[0]) {\n+        if constant_simple(cx, &args[1]).is_none() {\n             // otherwise ignore\n             Some((m, c, &args[1]))\n         } else {\n             None\n         }\n-    } else if let Some(c) = constant_simple(&args[1]) {\n+    } else if let Some(c) = constant_simple(cx, &args[1]) {\n         Some((m, c, &args[0]))\n     } else {\n         None"}, {"sha": "d7437f34cff393bfbb48285032273ee9590ab498", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bfa53f5045a8eb6ab89f6e753280d15c51f2332/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfa53f5045a8eb6ab89f6e753280d15c51f2332/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=7bfa53f5045a8eb6ab89f6e753280d15c51f2332", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n fn check_mul(cx: &LateContext, span: Span, lit: &Expr, exp: &Expr) {\n     if_let_chain!([\n         let ExprLit(ref l) = lit.node,\n-        let Constant::Int(ref ci) = consts::lit_to_constant(&l.node),\n+        let Constant::Int(ref ci) = consts::lit_to_constant(&l.node, cx.tcx, cx.tables.expr_ty(lit)),\n         let Some(val) = ci.to_u64(),\n         val == 1,\n         cx.tables.expr_ty(exp).is_integral()"}, {"sha": "eb298f9bc7b3211d221b72420ec4c2a258ffa97d", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bfa53f5045a8eb6ab89f6e753280d15c51f2332/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfa53f5045a8eb6ab89f6e753280d15c51f2332/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=7bfa53f5045a8eb6ab89f6e753280d15c51f2332", "patch": "@@ -36,8 +36,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would\n             // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too.\n-            let Some(Constant::Float(ref lhs_value, lhs_width)) = constant_simple(left),\n-            let Some(Constant::Float(ref rhs_value, rhs_width)) = constant_simple(right),\n+            let Some(Constant::Float(ref lhs_value, lhs_width)) = constant_simple(cx, left),\n+            let Some(Constant::Float(ref rhs_value, rhs_width)) = constant_simple(cx, right),\n             let Ok(0.0) = lhs_value.parse(),\n             let Ok(0.0) = rhs_value.parse()\n         ], {"}, {"sha": "3ec5d7ab03a7c486e83414933e8d0b5ac2b6eaa9", "filename": "tests/consts.rs", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6f0fd15da9b65a738f20f1fdad6dcc728bcf6c11/tests%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0fd15da9b65a738f20f1fdad6dcc728bcf6c11/tests%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconsts.rs?ref=6f0fd15da9b65a738f20f1fdad6dcc728bcf6c11", "patch": "@@ -1,95 +0,0 @@\n-#![feature(rustc_private)]\n-\n-extern crate clippy_lints;\n-extern crate rustc;\n-extern crate rustc_const_eval;\n-extern crate rustc_const_math;\n-extern crate syntax;\n-\n-use clippy_lints::consts::{constant_simple, Constant, FloatWidth};\n-use rustc_const_math::ConstInt;\n-use rustc::hir::*;\n-use syntax::ast::{LitIntType, LitKind, NodeId, StrStyle};\n-use syntax::codemap::{Spanned, COMMAND_LINE_SP};\n-use syntax::symbol::Symbol;\n-use syntax::ptr::P;\n-use syntax::util::ThinVec;\n-\n-fn spanned<T>(t: T) -> Spanned<T> {\n-    Spanned {\n-        node: t,\n-        span: COMMAND_LINE_SP,\n-    }\n-}\n-\n-fn expr(n: Expr_) -> Expr {\n-    Expr {\n-        id: NodeId::new(1),\n-        node: n,\n-        span: COMMAND_LINE_SP,\n-        attrs: ThinVec::new(),\n-    }\n-}\n-\n-fn lit(l: LitKind) -> Expr {\n-    expr(ExprLit(P(spanned(l))))\n-}\n-\n-fn binop(op: BinOp_, l: Expr, r: Expr) -> Expr {\n-    expr(ExprBinary(spanned(op), P(l), P(r)))\n-}\n-\n-fn check(expect: Constant, expr: &Expr) {\n-    assert_eq!(Some(expect), constant_simple(expr))\n-}\n-\n-const TRUE: Constant = Constant::Bool(true);\n-const FALSE: Constant = Constant::Bool(false);\n-const ZERO: Constant = Constant::Int(ConstInt::U8(0));\n-const ONE: Constant = Constant::Int(ConstInt::U8(1));\n-const TWO: Constant = Constant::Int(ConstInt::U8(2));\n-\n-#[test]\n-fn test_lit() {\n-    check(TRUE, &lit(LitKind::Bool(true)));\n-    check(FALSE, &lit(LitKind::Bool(false)));\n-    check(ZERO, &lit(LitKind::Int(0, LitIntType::Unsuffixed)));\n-    check(Constant::Str(\"cool!\".into(), StrStyle::Cooked),\n-          &lit(LitKind::Str(Symbol::intern(\"cool!\"), StrStyle::Cooked)));\n-}\n-\n-#[test]\n-fn test_ops() {\n-    check(TRUE, &binop(BiOr, lit(LitKind::Bool(false)), lit(LitKind::Bool(true))));\n-    check(FALSE, &binop(BiAnd, lit(LitKind::Bool(false)), lit(LitKind::Bool(true))));\n-\n-    let litzero = lit(LitKind::Int(0, LitIntType::Unsuffixed));\n-    let litone = lit(LitKind::Int(1, LitIntType::Unsuffixed));\n-    check(TRUE, &binop(BiEq, litzero.clone(), litzero.clone()));\n-    check(TRUE, &binop(BiGe, litzero.clone(), litzero.clone()));\n-    check(TRUE, &binop(BiLe, litzero.clone(), litzero.clone()));\n-    check(FALSE, &binop(BiNe, litzero.clone(), litzero.clone()));\n-    check(FALSE, &binop(BiGt, litzero.clone(), litzero.clone()));\n-    check(FALSE, &binop(BiLt, litzero.clone(), litzero.clone()));\n-\n-    check(ZERO, &binop(BiAdd, litzero.clone(), litzero.clone()));\n-    check(TWO, &binop(BiAdd, litone.clone(), litone.clone()));\n-    check(ONE, &binop(BiSub, litone.clone(), litzero.clone()));\n-    check(ONE, &binop(BiMul, litone.clone(), litone.clone()));\n-    check(ONE, &binop(BiDiv, litone.clone(), litone.clone()));\n-\n-    let half_any = Constant::Float(\"0.5\".into(), FloatWidth::Any);\n-    let half32 = Constant::Float(\"0.5\".into(), FloatWidth::F32);\n-    let half64 = Constant::Float(\"0.5\".into(), FloatWidth::F64);\n-    let pos_zero = Constant::Float(\"0.0\".into(), FloatWidth::F64);\n-    let neg_zero = Constant::Float(\"-0.0\".into(), FloatWidth::F64);\n-\n-    assert_eq!(pos_zero, pos_zero);\n-    assert_eq!(neg_zero, neg_zero);\n-    assert_eq!(None, pos_zero.partial_cmp(&neg_zero));\n-\n-    assert_eq!(half_any, half32);\n-    assert_eq!(half_any, half64);\n-    // for transitivity\n-    assert_eq!(half32, half64);\n-}"}]}