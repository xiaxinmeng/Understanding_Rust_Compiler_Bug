{"sha": "deeca5d586bfaa4aa60246f671a8d611d38f6248", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZWNhNWQ1ODZiZmFhNGFhNjAyNDZmNjcxYThkNjExZDM4ZjYyNDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-25T07:46:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-25T07:46:11Z"}, "message": "auto merge of #10054 : alexcrichton/rust/basic-event-loop, r=brson\n\nThis is more progress towards #9128 and all its related tree of issues. This implements a new `BasicLoop` on top of pthreads synchronization primitives (wrapped in `LittleLock`). This also removes the wonky `callback_ms` function from the interface of the event loop.\r\n\r\nAfter #9901 is taking forever to land, I'm going to try to do all this runtime work in much smaller chunks than before. Right now this will not work unless #9901 lands first, but I'm close to landing it (hopefully), and I wanted to go ahead and get this reviewed before throwing it at bors later on down the road.\r\n\r\nThis \"pausible idle callback\" is also a bit of a weird idea, but it wasn't as difficult to implement as callback_ms so I'm more semi-ok with it.", "tree": {"sha": "a0aaa22d41ef38f3ef93ab72e399860edd31ff25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0aaa22d41ef38f3ef93ab72e399860edd31ff25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/deeca5d586bfaa4aa60246f671a8d611d38f6248", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/deeca5d586bfaa4aa60246f671a8d611d38f6248", "html_url": "https://github.com/rust-lang/rust/commit/deeca5d586bfaa4aa60246f671a8d611d38f6248", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/deeca5d586bfaa4aa60246f671a8d611d38f6248/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac82d185b0a9d04bb4e85578aad558da784a2be4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac82d185b0a9d04bb4e85578aad558da784a2be4", "html_url": "https://github.com/rust-lang/rust/commit/ac82d185b0a9d04bb4e85578aad558da784a2be4"}, {"sha": "64a5c3bc1ee869990f8205374f9dac837a475dbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/64a5c3bc1ee869990f8205374f9dac837a475dbd", "html_url": "https://github.com/rust-lang/rust/commit/64a5c3bc1ee869990f8205374f9dac837a475dbd"}], "stats": {"total": 582, "additions": 494, "deletions": 88}, "files": [{"sha": "5cc5c140fd5d1503afb21a4941039df056815a5c", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -136,7 +136,7 @@ pub fn rendezvous<T: Send>() -> (SyncPort<T>, SyncChan<T>) {\n #[cfg(test)]\n mod test {\n     use comm::{DuplexStream, rendezvous};\n-    use std::rt::test::run_in_newsched_task;\n+    use std::rt::test::run_in_uv_task;\n     use std::task::spawn_unlinked;\n \n \n@@ -165,7 +165,7 @@ mod test {\n     #[test]\n     fn recv_a_lot() {\n         // Rendezvous streams should be able to handle any number of messages being sent\n-        do run_in_newsched_task {\n+        do run_in_uv_task {\n             let (port, chan) = rendezvous();\n             do spawn {\n                 do 1000000.times { chan.send(()) }"}, {"sha": "86d3f8a52bace385c47fc3d29fa45be24fd1ee76", "filename": "src/libstd/rt/basic.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbasic.rs?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -0,0 +1,256 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This is a basic event loop implementation not meant for any \"real purposes\"\n+//! other than testing the scheduler and proving that it's possible to have a\n+//! pluggable event loop.\n+\n+use prelude::*;\n+\n+use cast;\n+use rt::rtio::{EventLoop, IoFactory, RemoteCallback, PausibleIdleCallback};\n+use unstable::sync::Exclusive;\n+use util;\n+\n+/// This is the only exported function from this module.\n+pub fn event_loop() -> ~EventLoop {\n+    ~BasicLoop::new() as ~EventLoop\n+}\n+\n+struct BasicLoop {\n+    work: ~[~fn()],               // pending work\n+    idle: Option<*BasicPausible>, // only one is allowed\n+    remotes: ~[(uint, ~fn())],\n+    next_remote: uint,\n+    messages: Exclusive<~[Message]>\n+}\n+\n+enum Message { RunRemote(uint), RemoveRemote(uint) }\n+\n+struct Time {\n+    sec: u64,\n+    nsec: u64,\n+}\n+\n+impl Ord for Time {\n+    fn lt(&self, other: &Time) -> bool {\n+        self.sec < other.sec || self.nsec < other.nsec\n+    }\n+}\n+\n+impl BasicLoop {\n+    fn new() -> BasicLoop {\n+        BasicLoop {\n+            work: ~[],\n+            idle: None,\n+            next_remote: 0,\n+            remotes: ~[],\n+            messages: Exclusive::new(~[]),\n+        }\n+    }\n+\n+    /// Process everything in the work queue (continually)\n+    fn work(&mut self) {\n+        while self.work.len() > 0 {\n+            for work in util::replace(&mut self.work, ~[]).move_iter() {\n+                work();\n+            }\n+        }\n+    }\n+\n+    fn remote_work(&mut self) {\n+        let messages = unsafe {\n+            do self.messages.with |messages| {\n+                if messages.len() > 0 {\n+                    Some(util::replace(messages, ~[]))\n+                } else {\n+                    None\n+                }\n+            }\n+        };\n+        let messages = match messages {\n+            Some(m) => m, None => return\n+        };\n+        for message in messages.iter() {\n+            self.message(*message);\n+        }\n+    }\n+\n+    fn message(&mut self, message: Message) {\n+        match message {\n+            RunRemote(i) => {\n+                match self.remotes.iter().find(|& &(id, _)| id == i) {\n+                    Some(&(_, ref f)) => (*f)(),\n+                    None => unreachable!()\n+                }\n+            }\n+            RemoveRemote(i) => {\n+                match self.remotes.iter().position(|&(id, _)| id == i) {\n+                    Some(i) => { self.remotes.remove(i); }\n+                    None => unreachable!()\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Run the idle callback if one is registered\n+    fn idle(&mut self) {\n+        unsafe {\n+            match self.idle {\n+                Some(idle) => {\n+                    if (*idle).active {\n+                        (*(*idle).work.get_ref())();\n+                    }\n+                }\n+                None => {}\n+            }\n+        }\n+    }\n+\n+    fn has_idle(&self) -> bool {\n+        unsafe { self.idle.is_some() && (**self.idle.get_ref()).active }\n+    }\n+}\n+\n+impl EventLoop for BasicLoop {\n+    fn run(&mut self) {\n+        // Not exactly efficient, but it gets the job done.\n+        while self.remotes.len() > 0 || self.work.len() > 0 || self.has_idle() {\n+\n+            self.work();\n+            self.remote_work();\n+\n+            if self.has_idle() {\n+                self.idle();\n+                continue\n+            }\n+\n+            unsafe {\n+                // We block here if we have no messages to process and we may\n+                // receive a message at a later date\n+                do self.messages.hold_and_wait |messages| {\n+                    self.remotes.len() > 0 &&\n+                        messages.len() == 0 &&\n+                        self.work.len() == 0\n+                }\n+            }\n+        }\n+    }\n+\n+    fn callback(&mut self, f: ~fn()) {\n+        self.work.push(f);\n+    }\n+\n+    // XXX: Seems like a really weird requirement to have an event loop provide.\n+    fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback {\n+        let callback = ~BasicPausible::new(self);\n+        rtassert!(self.idle.is_none());\n+        unsafe {\n+            let cb_ptr: &*BasicPausible = cast::transmute(&callback);\n+            self.idle = Some(*cb_ptr);\n+        }\n+        return callback as ~PausibleIdleCallback;\n+    }\n+\n+    fn remote_callback(&mut self, f: ~fn()) -> ~RemoteCallback {\n+        let id = self.next_remote;\n+        self.next_remote += 1;\n+        self.remotes.push((id, f));\n+        ~BasicRemote::new(self.messages.clone(), id) as ~RemoteCallback\n+    }\n+\n+    /// This has no bindings for local I/O\n+    fn io<'a>(&'a mut self, _: &fn(&'a mut IoFactory)) {}\n+}\n+\n+struct BasicRemote {\n+    queue: Exclusive<~[Message]>,\n+    id: uint,\n+}\n+\n+impl BasicRemote {\n+    fn new(queue: Exclusive<~[Message]>, id: uint) -> BasicRemote {\n+        BasicRemote { queue: queue, id: id }\n+    }\n+}\n+\n+impl RemoteCallback for BasicRemote {\n+    fn fire(&mut self) {\n+        unsafe {\n+            do self.queue.hold_and_signal |queue| {\n+                queue.push(RunRemote(self.id));\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for BasicRemote {\n+    fn drop(&mut self) {\n+        unsafe {\n+            do self.queue.hold_and_signal |queue| {\n+                queue.push(RemoveRemote(self.id));\n+            }\n+        }\n+    }\n+}\n+\n+struct BasicPausible {\n+    eloop: *mut BasicLoop,\n+    work: Option<~fn()>,\n+    active: bool,\n+}\n+\n+impl BasicPausible {\n+    fn new(eloop: &mut BasicLoop) -> BasicPausible {\n+        BasicPausible {\n+            active: false,\n+            work: None,\n+            eloop: eloop,\n+        }\n+    }\n+}\n+\n+impl PausibleIdleCallback for BasicPausible {\n+    fn start(&mut self, f: ~fn()) {\n+        rtassert!(!self.active && self.work.is_none());\n+        self.active = true;\n+        self.work = Some(f);\n+    }\n+    fn pause(&mut self) {\n+        self.active = false;\n+    }\n+    fn resume(&mut self) {\n+        self.active = true;\n+    }\n+    fn close(&mut self) {\n+        self.active = false;\n+        self.work = None;\n+    }\n+}\n+\n+impl Drop for BasicPausible {\n+    fn drop(&mut self) {\n+        unsafe {\n+            (*self.eloop).idle = None;\n+        }\n+    }\n+}\n+\n+fn time() -> Time {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    extern {\n+        fn get_time(sec: &mut i64, nsec: &mut i32);\n+    }\n+    let mut sec = 0;\n+    let mut nsec = 0;\n+    unsafe { get_time(&mut sec, &mut nsec) }\n+\n+    Time { sec: sec as u64, nsec: nsec as u64 }\n+}"}, {"sha": "decf801d59294faf174f182b35913b05073a687d", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -606,6 +606,13 @@ pub fn standard_error(kind: IoErrorKind) -> IoError {\n                 detail: None\n             }\n         }\n+        IoUnavailable => {\n+            IoError {\n+                kind: IoUnavailable,\n+                desc: \"I/O is unavailable\",\n+                detail: None\n+            }\n+        }\n         _ => fail!()\n     }\n }"}, {"sha": "5113c28aa085e3a4ca429f120a913f932813fe4b", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -102,6 +102,9 @@ pub mod shouldnt_be_public {\n // Internal macros used by the runtime.\n mod macros;\n \n+/// Basic implementation of an EventLoop, provides no I/O interfaces\n+mod basic;\n+\n /// The global (exchange) heap.\n pub mod global_heap;\n "}, {"sha": "29f728a5e0cb8051553cdebff094f79675c0ce37", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -28,7 +28,6 @@ pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, ~fn());\n     fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback;\n-    fn callback_ms(&mut self, ms: u64, ~fn());\n     fn remote_callback(&mut self, ~fn()) -> ~RemoteCallback;\n \n     /// The asynchronous I/O services. Not all event loops may provide one"}, {"sha": "b008a8a74f2cb4678a6379bb153f5338d8224310", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -62,8 +62,6 @@ pub struct Scheduler {\n     /// no longer try to go to sleep, but exit instead.\n     no_sleep: bool,\n     stack_pool: StackPool,\n-    /// The event loop used to drive the scheduler and perform I/O\n-    event_loop: ~EventLoop,\n     /// The scheduler runs on a special task. When it is not running\n     /// it is stored here instead of the work queue.\n     priv sched_task: Option<~Task>,\n@@ -85,7 +83,17 @@ pub struct Scheduler {\n     priv yield_check_count: uint,\n     /// A flag to tell the scheduler loop it needs to do some stealing\n     /// in order to introduce randomness as part of a yield\n-    priv steal_for_yield: bool\n+    priv steal_for_yield: bool,\n+\n+    // n.b. currently destructors of an object are run in top-to-bottom in order\n+    //      of field declaration. Due to its nature, the pausible idle callback\n+    //      must have some sort of handle to the event loop, so it needs to get\n+    //      destroyed before the event loop itself. For this reason, we destroy\n+    //      the event loop last to ensure that any unsafe references to it are\n+    //      destroyed before it's actually destroyed.\n+\n+    /// The event loop used to drive the scheduler and perform I/O\n+    event_loop: ~EventLoop,\n }\n \n /// An indication of how hard to work on a given operation, the difference\n@@ -905,7 +913,7 @@ mod test {\n     use cell::Cell;\n     use rt::thread::Thread;\n     use rt::task::{Task, Sched};\n-    use rt::rtio::EventLoop;\n+    use rt::basic;\n     use rt::util;\n     use option::{Some};\n \n@@ -1005,7 +1013,6 @@ mod test {\n     #[test]\n     fn test_schedule_home_states() {\n \n-        use rt::uv::uvio::UvEventLoop;\n         use rt::sleeper_list::SleeperList;\n         use rt::work_queue::WorkQueue;\n         use rt::sched::Shutdown;\n@@ -1021,7 +1028,7 @@ mod test {\n \n             // Our normal scheduler\n             let mut normal_sched = ~Scheduler::new(\n-                ~UvEventLoop::new() as ~EventLoop,\n+                basic::event_loop(),\n                 normal_queue,\n                 queues.clone(),\n                 sleepers.clone());\n@@ -1032,7 +1039,7 @@ mod test {\n \n             // Our special scheduler\n             let mut special_sched = ~Scheduler::new_special(\n-                ~UvEventLoop::new() as ~EventLoop,\n+                basic::event_loop(),\n                 special_queue.clone(),\n                 queues.clone(),\n                 sleepers.clone(),\n@@ -1137,22 +1144,15 @@ mod test {\n \n     #[test]\n     fn test_io_callback() {\n+        use rt::io::timer;\n+\n         // This is a regression test that when there are no schedulable tasks\n         // in the work queue, but we are performing I/O, that once we do put\n         // something in the work queue again the scheduler picks it up and doesn't\n         // exit before emptying the work queue\n-        do run_in_newsched_task {\n+        do run_in_uv_task {\n             do spawntask {\n-                let sched: ~Scheduler = Local::take();\n-                do sched.deschedule_running_task_and_then |sched, task| {\n-                    let task = Cell::new(task);\n-                    do sched.event_loop.callback_ms(10) {\n-                        rtdebug!(\"in callback\");\n-                        let mut sched: ~Scheduler = Local::take();\n-                        sched.enqueue_blocked_task(task.take());\n-                        Local::put(sched);\n-                    }\n-                }\n+                timer::sleep(10);\n             }\n         }\n     }\n@@ -1192,7 +1192,6 @@ mod test {\n         use rt::work_queue::WorkQueue;\n         use rt::sleeper_list::SleeperList;\n         use rt::stack::StackPool;\n-        use rt::uv::uvio::UvEventLoop;\n         use rt::sched::{Shutdown, TaskFromFriend};\n         use util;\n \n@@ -1203,7 +1202,7 @@ mod test {\n                 let queues = ~[queue.clone()];\n \n                 let mut sched = ~Scheduler::new(\n-                    ~UvEventLoop::new() as ~EventLoop,\n+                    basic::event_loop(),\n                     queue,\n                     queues.clone(),\n                     sleepers.clone());"}, {"sha": "7bf124ad3129216867a9dd7a6b9f0ffc865b265e", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -637,7 +637,7 @@ mod test {\n \n     #[test]\n     fn rng() {\n-        do run_in_newsched_task() {\n+        do run_in_uv_task() {\n             use rand::{rng, Rng};\n             let mut r = rng();\n             let _ = r.next_u32();\n@@ -646,7 +646,7 @@ mod test {\n \n     #[test]\n     fn logging() {\n-        do run_in_newsched_task() {\n+        do run_in_uv_task() {\n             info!(\"here i am. logging in a newsched task\");\n         }\n     }"}, {"sha": "e4bbfe0a5a3e99be4016b1caa7fcbb9426920a5b", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -21,6 +21,7 @@ use iter::{Iterator, range};\n use super::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n use vec::{OwnedVector, MutableVector, ImmutableVector};\n use path::GenericPath;\n+use rt::basic;\n use rt::sched::Scheduler;\n use rt::rtio::EventLoop;\n use unstable::{run_in_bare_thread};\n@@ -48,14 +49,36 @@ pub fn new_test_uv_sched() -> Scheduler {\n \n }\n \n+pub fn new_test_sched() -> Scheduler {\n+\n+    let queue = WorkQueue::new();\n+    let queues = ~[queue.clone()];\n+\n+    let mut sched = Scheduler::new(basic::event_loop(),\n+                                   queue,\n+                                   queues,\n+                                   SleeperList::new());\n+\n+    // Don't wait for the Shutdown message\n+    sched.no_sleep = true;\n+    return sched;\n+}\n+\n+pub fn run_in_uv_task(f: ~fn()) {\n+    let f = Cell::new(f);\n+    do run_in_bare_thread {\n+        run_in_uv_task_core(f.take());\n+    }\n+}\n+\n pub fn run_in_newsched_task(f: ~fn()) {\n     let f = Cell::new(f);\n     do run_in_bare_thread {\n         run_in_newsched_task_core(f.take());\n     }\n }\n \n-pub fn run_in_newsched_task_core(f: ~fn()) {\n+pub fn run_in_uv_task_core(f: ~fn()) {\n \n     use rt::sched::Shutdown;\n \n@@ -72,6 +95,23 @@ pub fn run_in_newsched_task_core(f: ~fn()) {\n     sched.bootstrap(task);\n }\n \n+pub fn run_in_newsched_task_core(f: ~fn()) {\n+\n+    use rt::sched::Shutdown;\n+\n+    let mut sched = ~new_test_sched();\n+    let exit_handle = Cell::new(sched.make_handle());\n+\n+    let on_exit: ~fn(bool) = |exit_status| {\n+        exit_handle.take().send(Shutdown);\n+        rtassert!(exit_status);\n+    };\n+    let mut task = ~Task::new_root(&mut sched.stack_pool, None, f);\n+    task.death.on_exit = Some(on_exit);\n+\n+    sched.bootstrap(task);\n+}\n+\n #[cfg(target_os=\"macos\")]\n #[allow(non_camel_case_types)]\n mod darwin_fd_limit {\n@@ -310,7 +350,7 @@ pub fn spawntask_thread(f: ~fn()) -> Thread {\n /// Get a ~Task for testing purposes other than actually scheduling it.\n pub fn with_test_task(blk: ~fn(~Task) -> ~Task) {\n     do run_in_bare_thread {\n-        let mut sched = ~new_test_uv_sched();\n+        let mut sched = ~new_test_sched();\n         let task = blk(~Task::new_root(&mut sched.stack_pool, None, ||{}));\n         cleanup_task(task);\n     }"}, {"sha": "eee89365fb5b101ead05c80f4d0987628edb9a1a", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -222,15 +222,6 @@ impl EventLoop for UvEventLoop {\n         } as ~PausibleIdleCallback\n     }\n \n-    fn callback_ms(&mut self, ms: u64, f: ~fn()) {\n-        let mut timer =  TimerWatcher::new(self.uvio.uv_loop());\n-        do timer.start(ms, 0) |timer, status| {\n-            assert!(status.is_none());\n-            timer.close(||());\n-            f();\n-        }\n-    }\n-\n     fn remote_callback(&mut self, f: ~fn()) -> ~RemoteCallback {\n         ~UvRemoteCallback::new(self.uvio.uv_loop(), f) as ~RemoteCallback\n     }"}, {"sha": "75b09187f04ccfb47aa3806436bf2ea029a7430c", "filename": "src/libstd/select.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -183,22 +183,22 @@ mod test {\n \n     #[test]\n     fn select_one() {\n-        do run_in_newsched_task { select_helper(1, [0]) }\n+        do run_in_uv_task { select_helper(1, [0]) }\n     }\n \n     #[test]\n     fn select_two() {\n         // NB. I would like to have a test that tests the first one that is\n         // ready is the one that's returned, but that can't be reliably tested\n         // with the randomized behaviour of optimistic_check.\n-        do run_in_newsched_task { select_helper(2, [1]) }\n-        do run_in_newsched_task { select_helper(2, [0]) }\n-        do run_in_newsched_task { select_helper(2, [1,0]) }\n+        do run_in_uv_task { select_helper(2, [1]) }\n+        do run_in_uv_task { select_helper(2, [0]) }\n+        do run_in_uv_task { select_helper(2, [1,0]) }\n     }\n \n     #[test]\n     fn select_a_lot() {\n-        do run_in_newsched_task { select_helper(12, [7,8,9]) }\n+        do run_in_uv_task { select_helper(12, [7,8,9]) }\n     }\n \n     #[test]\n@@ -208,7 +208,7 @@ mod test {\n \n         // Sends 10 buffered packets, and uses select to retrieve them all.\n         // Puts the port in a different spot in the vector each time.\n-        do run_in_newsched_task {\n+        do run_in_uv_task {\n             let (ports, _) = unzip(range(0u, 10).map(|_| stream::<int>()));\n             let (port, chan) = stream();\n             do 10.times { chan.send(31337); }\n@@ -229,7 +229,7 @@ mod test {\n \n     #[test]\n     fn select_unkillable() {\n-        do run_in_newsched_task {\n+        do run_in_uv_task {\n             do task::unkillable { select_helper(2, [1]) }\n         }\n     }\n@@ -242,7 +242,7 @@ mod test {\n         select_blocking_helper(false);\n \n         fn select_blocking_helper(killable: bool) {\n-            do run_in_newsched_task {\n+            do run_in_uv_task {\n                 let (p1,_c) = oneshot();\n                 let (p2,c2) = oneshot();\n                 let mut ports = [p1,p2];\n@@ -287,7 +287,7 @@ mod test {\n         fn select_racing_senders_helper(killable: bool, send_on_chans: ~[uint]) {\n             use rt::test::spawntask_random;\n \n-            do run_in_newsched_task {\n+            do run_in_uv_task {\n                 // A bit of stress, since ordinarily this is just smoke and mirrors.\n                 do 4.times {\n                     let send_on_chans = send_on_chans.clone();\n@@ -318,7 +318,7 @@ mod test {\n \n     #[test]\n     fn select_killed() {\n-        do run_in_newsched_task {\n+        do run_in_uv_task {\n             let (success_p, success_c) = oneshot::<bool>();\n             let success_c = Cell::new(success_c);\n             do task::try {"}, {"sha": "b72d6773ec567774bed2c38f30d0d7374aee39cf", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -645,7 +645,7 @@ fn test_kill_unkillable_task() {\n     // CPU, *after* the spawner is already switched-back-to (and passes the\n     // killed check at the start of its timeslice). As far as I know, it's not\n     // possible to make this race deterministic, or even more likely to happen.\n-    do run_in_newsched_task {\n+    do run_in_uv_task {\n         do task::try {\n             do task::spawn {\n                 fail!();\n@@ -662,7 +662,7 @@ fn test_kill_rekillable_task() {\n \n     // Tests that when a kill signal is received, 'rekillable' and\n     // 'unkillable' unwind correctly in conjunction with each other.\n-    do run_in_newsched_task {\n+    do run_in_uv_task {\n         do task::try {\n             do task::unkillable {\n                 do task::rekillable {\n@@ -730,8 +730,8 @@ fn block_forever() { let (po, _ch) = stream::<()>(); po.recv(); }\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         let (po, ch) = stream();\n         let ch = SharedChan::new(ch);\n         do spawn_unlinked {\n@@ -749,16 +749,16 @@ fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         do spawn_unlinked { fail!(); }\n     }\n }\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         do spawn_supervised { fail!(); }\n         // Give child a chance to fail-but-not-kill-us.\n         do 16.times { task::deschedule(); }\n@@ -767,8 +767,8 @@ fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_unlinked_sup_fail_down() {\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         let result: Result<(),()> = do try {\n             do spawn_supervised { block_forever(); }\n             fail!(); // Shouldn't leave a child hanging around.\n@@ -780,8 +780,8 @@ fn test_spawn_unlinked_sup_fail_down() {\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         let result: Result<(),()> = do try {\n             // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n             // We have to cheat with opts - the interface doesn't support them because\n@@ -801,8 +801,8 @@ fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         let result: Result<(),()> = do try {\n             // We have to cheat with opts - the interface doesn't support them because\n             // they don't make sense (redundant with task().supervised()).\n@@ -818,8 +818,8 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         let result: Result<(),()> = do try {\n             // Default options are to spawn linked & unsupervised.\n             do spawn { fail!(); }\n@@ -831,8 +831,8 @@ fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         let result: Result<(),()> = do try {\n             // Default options are to spawn linked & unsupervised.\n             do spawn { block_forever(); }\n@@ -844,8 +844,8 @@ fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         let result: Result<(),()> = do try {\n             // Make sure the above test is the same as this one.\n             let mut builder = task();\n@@ -863,8 +863,8 @@ fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_failure_propagate_grandchild() {\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         let result: Result<(),()> = do try {\n             // Middle task exits; does grandparent's failure propagate across the gap?\n             do spawn_supervised {\n@@ -880,8 +880,8 @@ fn test_spawn_failure_propagate_grandchild() {\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_failure_propagate_secondborn() {\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         let result: Result<(),()> = do try {\n             // First-born child exits; does parent's failure propagate to sibling?\n             do spawn_supervised {\n@@ -897,8 +897,8 @@ fn test_spawn_failure_propagate_secondborn() {\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_failure_propagate_nephew_or_niece() {\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         let result: Result<(),()> = do try {\n             // Our sibling exits; does our failure propagate to sibling's child?\n             do spawn { // linked\n@@ -914,8 +914,8 @@ fn test_spawn_failure_propagate_nephew_or_niece() {\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_linked_sup_propagate_sibling() {\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         let result: Result<(),()> = do try {\n             // Middle sibling exits - does eldest's failure propagate to youngest?\n             do spawn { // linked\n@@ -930,9 +930,9 @@ fn test_spawn_linked_sup_propagate_sibling() {\n \n #[test]\n fn test_unnamed_task() {\n-    use rt::test::run_in_newsched_task;\n+    use rt::test::run_in_uv_task;\n \n-    do run_in_newsched_task {\n+    do run_in_uv_task {\n         do spawn {\n             do with_task_name |name| {\n                 assert!(name.is_none());\n@@ -943,9 +943,9 @@ fn test_unnamed_task() {\n \n #[test]\n fn test_owned_named_task() {\n-    use rt::test::run_in_newsched_task;\n+    use rt::test::run_in_uv_task;\n \n-    do run_in_newsched_task {\n+    do run_in_uv_task {\n         let mut t = task();\n         t.name(~\"ada lovelace\");\n         do t.spawn {\n@@ -958,9 +958,9 @@ fn test_owned_named_task() {\n \n #[test]\n fn test_static_named_task() {\n-    use rt::test::run_in_newsched_task;\n+    use rt::test::run_in_uv_task;\n \n-    do run_in_newsched_task {\n+    do run_in_uv_task {\n         let mut t = task();\n         t.name(\"ada lovelace\");\n         do t.spawn {\n@@ -973,9 +973,9 @@ fn test_static_named_task() {\n \n #[test]\n fn test_send_named_task() {\n-    use rt::test::run_in_newsched_task;\n+    use rt::test::run_in_uv_task;\n \n-    do run_in_newsched_task {\n+    do run_in_uv_task {\n         let mut t = task();\n         t.name(\"ada lovelace\".into_send_str());\n         do t.spawn {\n@@ -1326,18 +1326,18 @@ fn test_child_doesnt_ref_parent() {\n \n #[test]\n fn test_simple_newsched_spawn() {\n-    use rt::test::run_in_newsched_task;\n+    use rt::test::run_in_uv_task;\n \n-    do run_in_newsched_task {\n+    do run_in_uv_task {\n         spawn(||())\n     }\n }\n \n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_watched() {\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         let result = do try {\n             let mut t = task();\n             t.unlinked();\n@@ -1359,8 +1359,8 @@ fn test_spawn_watched() {\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_indestructible() {\n-    use rt::test::run_in_newsched_task;\n-    do run_in_newsched_task {\n+    use rt::test::run_in_uv_task;\n+    do run_in_uv_task {\n         let result = do try {\n             let mut t = task();\n             t.watched();"}, {"sha": "2b036c318bac7464a0647af0dafef24ac13915fa", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -334,6 +334,23 @@ impl LittleLock {\n             }\n         }\n     }\n+\n+    pub unsafe fn signal(&self) {\n+        rust_signal_little_lock(self.l);\n+    }\n+\n+    pub unsafe fn lock_and_wait(&self, f: &fn() -> bool) {\n+        do atomically {\n+            rust_lock_little_lock(self.l);\n+            do (|| {\n+                if f() {\n+                    rust_wait_little_lock(self.l);\n+                }\n+            }).finally {\n+                rust_unlock_little_lock(self.l);\n+            }\n+        }\n+    }\n }\n \n struct ExData<T> {\n@@ -402,6 +419,34 @@ impl<T:Send> Exclusive<T> {\n         }\n     }\n \n+    #[inline]\n+    pub unsafe fn hold_and_signal(&self, f: &fn(x: &mut T)) {\n+        let rec = self.x.get();\n+        do (*rec).lock.lock {\n+            if (*rec).failed {\n+                fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n+            }\n+            (*rec).failed = true;\n+            f(&mut (*rec).data);\n+            (*rec).failed = false;\n+            (*rec).lock.signal();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn hold_and_wait(&self, f: &fn(x: &T) -> bool) {\n+        let rec = self.x.get();\n+        do (*rec).lock.lock_and_wait {\n+            if (*rec).failed {\n+                fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n+            }\n+            (*rec).failed = true;\n+            let result = f(&(*rec).data);\n+            (*rec).failed = false;\n+            result\n+        }\n+    }\n+\n     pub fn unwrap(self) -> T {\n         let Exclusive { x: x } = self;\n         // Someday we might need to unkillably unwrap an Exclusive, but not today.\n@@ -415,6 +460,8 @@ externfn!(fn rust_create_little_lock() -> rust_little_lock)\n externfn!(fn rust_destroy_little_lock(lock: rust_little_lock))\n externfn!(fn rust_lock_little_lock(lock: rust_little_lock))\n externfn!(fn rust_unlock_little_lock(lock: rust_little_lock))\n+externfn!(fn rust_signal_little_lock(lock: rust_little_lock))\n+externfn!(fn rust_wait_little_lock(lock: rust_little_lock))\n \n #[cfg(test)]\n mod tests {"}, {"sha": "a8eec52943ee004d8918cf746cd2ebf6296365df", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -377,6 +377,16 @@ rust_unlock_little_lock(lock_and_signal *lock) {\n     lock->unlock();\n }\n \n+extern \"C\" void\n+rust_wait_little_lock(lock_and_signal *lock) {\n+    lock->wait();\n+}\n+\n+extern \"C\" void\n+rust_signal_little_lock(lock_and_signal *lock) {\n+    lock->signal();\n+}\n+\n typedef void(startfn)(void*, void*);\n \n class raw_thread: public rust_thread {"}, {"sha": "06f4c0006f17a6828009d401eebfd7e5b7a96acf", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -128,6 +128,8 @@ rust_create_little_lock\n rust_destroy_little_lock\n rust_lock_little_lock\n rust_unlock_little_lock\n+rust_signal_little_lock\n+rust_wait_little_lock\n tdefl_compress_mem_to_heap\n tinfl_decompress_mem_to_heap\n rust_uv_ip4_port"}, {"sha": "1d4c08f0bb5def4231d1cc1fd5cf4a40e6298cd3", "filename": "src/test/run-pass/field-destruction-order.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Ftest%2Frun-pass%2Ffield-destruction-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deeca5d586bfaa4aa60246f671a8d611d38f6248/src%2Ftest%2Frun-pass%2Ffield-destruction-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffield-destruction-order.rs?ref=deeca5d586bfaa4aa60246f671a8d611d38f6248", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// In theory, it doesn't matter what order destructors are run in for rust\n+// because we have explicit ownership of values meaning that there's no need to\n+// run one before another. With unsafe code, however, there may be a safe\n+// interface which relies on fields having their destructors run in a particular\n+// order. At the time of this writing, std::rt::sched::Scheduler is an example\n+// of a structure which contains unsafe handles to FFI-like types, and the\n+// destruction order of the fields matters in the sense that some handles need\n+// to get destroyed before others.\n+//\n+// In C++, destruction order happens bottom-to-top in order of field\n+// declarations, but we currently run them top-to-bottom. I don't think the\n+// order really matters that much as long as we define what it is.\n+\n+struct A;\n+struct B;\n+struct C {\n+    a: A,\n+    b: B,\n+}\n+\n+static mut hit: bool = false;\n+\n+impl Drop for A {\n+    fn drop(&mut self) {\n+        unsafe {\n+            assert!(!hit);\n+            hit = true;\n+        }\n+    }\n+}\n+\n+impl Drop for B {\n+    fn drop(&mut self) {\n+        unsafe {\n+            assert!(hit);\n+        }\n+    }\n+}\n+\n+pub fn main() {\n+    let _c = C { a: A, b: B };\n+}"}]}