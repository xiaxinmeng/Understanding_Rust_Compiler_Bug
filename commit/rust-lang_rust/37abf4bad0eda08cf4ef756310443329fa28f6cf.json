{"sha": "37abf4bad0eda08cf4ef756310443329fa28f6cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3YWJmNGJhZDBlZGEwOGNmNGVmNzU2MzEwNDQzMzI5ZmEyOGY2Y2Y=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-27T01:52:15Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-29T21:30:57Z"}, "message": "librustc: Forbid type implementations on typedefs.", "tree": {"sha": "e9bdcfadf21cd0d1a6001a09af5a336cb9db7d50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9bdcfadf21cd0d1a6001a09af5a336cb9db7d50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37abf4bad0eda08cf4ef756310443329fa28f6cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37abf4bad0eda08cf4ef756310443329fa28f6cf", "html_url": "https://github.com/rust-lang/rust/commit/37abf4bad0eda08cf4ef756310443329fa28f6cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37abf4bad0eda08cf4ef756310443329fa28f6cf/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "670ab8ac367cd8cfe8b86a1338667e7825d8d68d", "url": "https://api.github.com/repos/rust-lang/rust/commits/670ab8ac367cd8cfe8b86a1338667e7825d8d68d", "html_url": "https://github.com/rust-lang/rust/commit/670ab8ac367cd8cfe8b86a1338667e7825d8d68d"}], "stats": {"total": 277, "additions": 193, "deletions": 84}, "files": [{"sha": "522eebaf327efb57727db7f77dc83f23c92bcc96", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=37abf4bad0eda08cf4ef756310443329fa28f6cf", "patch": "@@ -395,58 +395,103 @@ pub mod oneshot {\n }\n \n /// The send end of a oneshot pipe.\n-pub type ChanOne<T> = oneshot::client::Oneshot<T>;\n+pub struct ChanOne<T> {\n+    contents: oneshot::client::Oneshot<T>\n+}\n+\n+impl<T> ChanOne<T> {\n+    pub fn new(contents: oneshot::client::Oneshot<T>) -> ChanOne<T> {\n+        ChanOne {\n+            contents: contents\n+        }\n+    }\n+}\n+\n /// The receive end of a oneshot pipe.\n-pub type PortOne<T> = oneshot::server::Oneshot<T>;\n+pub struct PortOne<T> {\n+    contents: oneshot::server::Oneshot<T>\n+}\n+\n+impl<T> PortOne<T> {\n+    pub fn new(contents: oneshot::server::Oneshot<T>) -> PortOne<T> {\n+        PortOne {\n+            contents: contents\n+        }\n+    }\n+}\n \n /// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n     let (chan, port) = oneshot::init();\n-    (port, chan)\n+    (PortOne::new(port), ChanOne::new(chan))\n }\n \n pub impl<T: Owned> PortOne<T> {\n     fn recv(self) -> T { recv_one(self) }\n     fn try_recv(self) -> Option<T> { try_recv_one(self) }\n+    fn unwrap(self) -> oneshot::server::Oneshot<T> {\n+        match self {\n+            PortOne { contents: s } => s\n+        }\n+    }\n }\n \n pub impl<T: Owned> ChanOne<T> {\n     fn send(self, data: T) { send_one(self, data) }\n     fn try_send(self, data: T) -> bool { try_send_one(self, data) }\n+    fn unwrap(self) -> oneshot::client::Oneshot<T> {\n+        match self {\n+            ChanOne { contents: s } => s\n+        }\n+    }\n }\n \n /**\n  * Receive a message from a oneshot pipe, failing if the connection was\n  * closed.\n  */\n pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n-    let oneshot::send(message) = recv(port);\n-    message\n+    match port {\n+        PortOne { contents: port } => {\n+            let oneshot::send(message) = recv(port);\n+            message\n+        }\n+    }\n }\n \n /// Receive a message from a oneshot pipe unless the connection was closed.\n pub fn try_recv_one<T: Owned> (port: PortOne<T>) -> Option<T> {\n-    let message = try_recv(port);\n-\n-    if message.is_none() { None }\n-    else {\n-        let oneshot::send(message) = message.unwrap();\n-        Some(message)\n+    match port {\n+        PortOne { contents: port } => {\n+            let message = try_recv(port);\n+\n+            if message.is_none() {\n+                None\n+            } else {\n+                let oneshot::send(message) = message.unwrap();\n+                Some(message)\n+            }\n+        }\n     }\n }\n \n /// Send a message on a oneshot pipe, failing if the connection was closed.\n pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n-    oneshot::client::send(chan, data);\n+    match chan {\n+        ChanOne { contents: chan } => oneshot::client::send(chan, data),\n+    }\n }\n \n /**\n  * Send a message on a oneshot pipe, or return false if the connection was\n  * closed.\n  */\n-pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T)\n-        -> bool {\n-    oneshot::client::try_send(chan, data).is_some()\n+pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T) -> bool {\n+    match chan {\n+        ChanOne { contents: chan } => {\n+            oneshot::client::try_send(chan, data).is_some()\n+        }\n+    }\n }\n \n "}, {"sha": "462c5be3bcf751b49a7eddc5cbe9e097f04aaee7", "filename": "src/libcore/path.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=37abf4bad0eda08cf4ef756310443329fa28f6cf", "patch": "@@ -21,6 +21,11 @@ use str;\n use to_str::ToStr;\n use ascii::{AsciiCast, AsciiStr};\n \n+#[cfg(windows)]\n+pub use Path = self::WindowsPath;\n+#[cfg(unix)]\n+pub use Path = self::PosixPath;\n+\n #[deriving(Clone, Eq)]\n pub struct WindowsPath {\n     host: Option<~str>,\n@@ -72,22 +77,6 @@ pub trait GenericPath {\n     fn is_absolute(&self) -> bool;\n }\n \n-#[cfg(windows)]\n-pub type Path = WindowsPath;\n-\n-#[cfg(windows)]\n-pub fn Path(s: &str) -> Path {\n-    WindowsPath(s)\n-}\n-\n-#[cfg(unix)]\n-pub type Path = PosixPath;\n-\n-#[cfg(unix)]\n-pub fn Path(s: &str) -> Path {\n-    PosixPath(s)\n-}\n-\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"android\")]\n mod stat {"}, {"sha": "05b2f6f577b8278f28320a7b3ab7c55d6ac6ca24", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 65, "deletions": 36, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=37abf4bad0eda08cf4ef756310443329fa28f6cf", "patch": "@@ -38,8 +38,9 @@ use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar};\n use middle::typeck::infer::{resolve_nested_tvar, resolve_type};\n-use syntax::ast::{crate, def_id, def_mod, def_trait};\n-use syntax::ast::{item, item_impl, item_mod, local_crate, method, trait_ref};\n+use syntax::ast::{crate, def_id, def_mod, def_struct, def_trait, def_ty};\n+use syntax::ast::{item, item_enum, item_impl, item_mod, item_struct};\n+use syntax::ast::{local_crate, method, trait_ref, ty_path};\n use syntax::ast;\n use syntax::ast_map::node_item;\n use syntax::ast_map;\n@@ -661,7 +662,19 @@ pub impl CoherenceChecker {\n                         // Then visit the module items.\n                         visit_mod(module_, item.span, item.id, (), visitor);\n                     }\n-                    item_impl(_, opt_trait, _, _) => {\n+                    item_impl(_, None, ast_ty, _) => {\n+                        if !self.ast_type_is_defined_in_local_crate(ast_ty) {\n+                            // This is an error.\n+                            let session = self.crate_context.tcx.sess;\n+                            session.span_err(item.span,\n+                                             ~\"cannot associate methods with \\\n+                                               a type outside the crate the \\\n+                                               type is defined in; define \\\n+                                               and implement a trait or new \\\n+                                               type instead\");\n+                        }\n+                    }\n+                    item_impl(_, Some(trait_ref), _, _) => {\n                         // `for_ty` is `Type` in `impl Trait for Type`\n                         let for_ty =\n                             ty::node_id_to_type(self.crate_context.tcx,\n@@ -671,40 +684,16 @@ pub impl CoherenceChecker {\n                             // type. This still might be OK if the trait is\n                             // defined in the same crate.\n \n-                            match opt_trait {\n-                                None => {\n-                                    // There is no trait to implement, so\n-                                    // this is an error.\n-\n-                                    let session = self.crate_context.tcx.sess;\n-                                    session.span_err(item.span,\n-                                                     ~\"cannot implement \\\n-                                                      inherent methods for a \\\n-                                                      type outside the crate \\\n-                                                      the type was defined \\\n-                                                      in; define and \\\n-                                                      implement a trait or \\\n-                                                      new type instead\");\n-                                }\n+                            let trait_def_id =\n+                                self.trait_ref_to_trait_def_id(trait_ref);\n \n-                                Some(trait_ref) => {\n-                                    // This is OK if and only if the trait was\n-                                    // defined in this crate.\n-\n-                                    let trait_def_id =\n-                                        self.trait_ref_to_trait_def_id(\n-                                            trait_ref);\n-\n-                                    if trait_def_id.crate != local_crate {\n-                                        let session = self.crate_context.tcx.sess;\n-                                        session.span_err(item.span,\n-                                                         ~\"cannot provide an \\\n-                                                           extension \\\n-                                                           implementation for a \\\n-                                                           trait not defined in \\\n-                                                           this crate\");\n-                                    }\n-                                }\n+                            if trait_def_id.crate != local_crate {\n+                                let session = self.crate_context.tcx.sess;\n+                                session.span_err(item.span,\n+                                                 ~\"cannot provide an \\\n+                                                   extension implementation \\\n+                                                   for a trait not defined \\\n+                                                   in this crate\");\n                             }\n                         }\n \n@@ -754,6 +743,46 @@ pub impl CoherenceChecker {\n         }\n     }\n \n+    /// For coherence, when we have `impl Type`, we need to guarantee that\n+    /// `Type` is \"local\" to the crate. For our purposes, this means that it\n+    /// must precisely name some nominal type defined in this crate.\n+    pub fn ast_type_is_defined_in_local_crate(&self, original_type: @ast::Ty)\n+                                              -> bool {\n+        match original_type.node {\n+            ty_path(_, path_id) => {\n+                match *self.crate_context.tcx.def_map.get(&path_id) {\n+                    def_ty(def_id) | def_struct(def_id) => {\n+                        if def_id.crate != local_crate {\n+                            return false;\n+                        }\n+\n+                        // Make sure that this type precisely names a nominal\n+                        // type.\n+                        match self.crate_context\n+                                  .tcx\n+                                  .items\n+                                  .find(&def_id.node) {\n+                            None => {\n+                                self.crate_context.tcx.sess.span_bug(\n+                                    original_type.span,\n+                                    ~\"resolve didn't resolve this type?!\");\n+                            }\n+                            Some(&node_item(item, _)) => {\n+                                match item.node {\n+                                    item_struct(*) | item_enum(*) => true,\n+                                    _ => false,\n+                                }\n+                            }\n+                            Some(_) => false,\n+                        }\n+                    }\n+                    _ => false\n+                }\n+            }\n+            _ => false\n+        }\n+    }\n+\n     // Converts an implementation in the AST to an Impl structure.\n     fn create_impl_from_item(&self, item: @item) -> @Impl {\n         fn add_provided_methods(all_methods: &mut ~[@MethodInfo],"}, {"sha": "c6c593d7b4a971f774d9739a1f5e8f58447cfbe3", "filename": "src/libstd/future.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=37abf4bad0eda08cf4ef756310443329fa28f6cf", "patch": "@@ -23,7 +23,7 @@\n \n use core::cast;\n use core::cell::Cell;\n-use core::comm::{oneshot, PortOne, send_one};\n+use core::comm::{ChanOne, PortOne, oneshot, send_one};\n use core::pipes::recv;\n use core::task;\n \n@@ -120,8 +120,7 @@ pub fn from_value<A>(val: A) -> Future<A> {\n     Future {state: Forced(val)}\n }\n \n-pub fn from_port<A:Owned>(port: PortOne<A>) ->\n-        Future<A> {\n+pub fn from_port<A:Owned>(port: PortOne<A>) -> Future<A> {\n     /*!\n      * Create a future from a port\n      *\n@@ -131,7 +130,7 @@ pub fn from_port<A:Owned>(port: PortOne<A>) ->\n \n     let port = Cell(port);\n     do from_fn || {\n-        let port = port.take();\n+        let port = port.take().unwrap();\n         match recv(port) {\n             oneshot::send(data) => data\n         }\n@@ -158,10 +157,10 @@ pub fn spawn<A:Owned>(blk: ~fn() -> A) -> Future<A> {\n      * value of the future.\n      */\n \n-    let (chan, port) = oneshot::init();\n+    let (port, chan) = oneshot();\n \n     let chan = Cell(chan);\n-    do task::spawn || {\n+    do task::spawn {\n         let chan = chan.take();\n         send_one(chan, blk());\n     }\n@@ -186,7 +185,7 @@ mod test {\n \n     #[test]\n     fn test_from_port() {\n-        let (ch, po) = oneshot::init();\n+        let (ch, po) = oneshot();\n         send_one(ch, ~\"whale\");\n         let f = from_port(po);\n         assert!(f.get() == ~\"whale\");"}, {"sha": "bb4a9e97ea1f4adb43727e013e01deea95f58518", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=37abf4bad0eda08cf4ef756310443329fa28f6cf", "patch": "@@ -16,10 +16,13 @@ use serialize::{Encoder, Encodable, Decoder, Decodable};\n use sort;\n \n use core::cell::Cell;\n-use core::comm::{oneshot, PortOne, send_one};\n+use core::cmp;\n+use core::comm::{ChanOne, PortOne, oneshot, send_one};\n+use core::either::{Either, Left, Right};\n+use core::hashmap::HashMap;\n+use core::io;\n use core::pipes::recv;\n use core::run;\n-use core::hashmap::HashMap;\n use core::to_bytes;\n \n /**\n@@ -340,13 +343,13 @@ impl TPrep for Prep {\n             }\n \n             _ => {\n-                let (chan, port) = oneshot::init();\n+                let (port, chan) = oneshot();\n                 let mut blk = None;\n                 blk <-> bo;\n                 let blk = blk.unwrap();\n                 let chan = Cell(chan);\n \n-                do task::spawn || {\n+                do task::spawn {\n                     let exe = Exec {\n                         discovered_inputs: WorkMap::new(),\n                         discovered_outputs: WorkMap::new(),\n@@ -383,7 +386,7 @@ fn unwrap<T:Owned +\n         None => fail!(),\n         Some(Left(v)) => v,\n         Some(Right(port)) => {\n-            let (exe, v) = match recv(port) {\n+            let (exe, v) = match recv(port.unwrap()) {\n                 oneshot::send(data) => data\n             };\n "}, {"sha": "2ceb6f0c4bb759e5976346f460eba201cfba841b", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=37abf4bad0eda08cf4ef756310443329fa28f6cf", "patch": "@@ -215,7 +215,50 @@ pub fn expand_auto_decode(\n     }\n }\n \n-priv impl @ext_ctxt {\n+trait ExtCtxtMethods {\n+    fn bind_path(&self,\n+                 span: span,\n+                 ident: ast::ident,\n+                 path: @ast::Path,\n+                 bounds: @OptVec<ast::TyParamBound>)\n+                 -> ast::TyParam;\n+    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr;\n+    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n+    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n+    fn path_tps(&self, span: span, strs: ~[ast::ident], tps: ~[@ast::Ty])\n+                -> @ast::Path;\n+    fn path_tps_global(&self,\n+                       span: span,\n+                       strs: ~[ast::ident],\n+                       tps: ~[@ast::Ty])\n+                       -> @ast::Path;\n+    fn ty_path(&self, span: span, strs: ~[ast::ident], tps: ~[@ast::Ty])\n+               -> @ast::Ty;\n+    fn binder_pat(&self, span: span, nm: ast::ident) -> @ast::pat;\n+    fn stmt(&self, expr: @ast::expr) -> @ast::stmt;\n+    fn lit_str(&self, span: span, s: @~str) -> @ast::expr;\n+    fn lit_uint(&self, span: span, i: uint) -> @ast::expr;\n+    fn lambda(&self, blk: ast::blk) -> @ast::expr;\n+    fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk;\n+    fn expr_blk(&self, expr: @ast::expr) -> ast::blk;\n+    fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n+    fn expr_path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n+    fn expr_var(&self, span: span, var: ~str) -> @ast::expr;\n+    fn expr_field(&self, span: span, expr: @ast::expr, ident: ast::ident)\n+                  -> @ast::expr;\n+    fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr])\n+                 -> @ast::expr;\n+    fn expr_method_call(&self,\n+                        span: span,\n+                        expr: @ast::expr,\n+                        ident: ast::ident,\n+                        args: ~[@ast::expr])\n+                        -> @ast::expr;\n+    fn lambda_expr(&self, expr: @ast::expr) -> @ast::expr;\n+    fn lambda_stmts(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr;\n+}\n+\n+impl ExtCtxtMethods for @ext_ctxt {\n     fn bind_path(\n         &self,\n         _span: span,"}, {"sha": "d82608846ab98519eb6e781fe3acda4f6d0dc72a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=37abf4bad0eda08cf4ef756310443329fa28f6cf", "patch": "@@ -867,7 +867,11 @@ impl ast_fold for AstFoldFns {\n     }\n }\n \n-pub impl @ast_fold {\n+pub trait AstFoldExtensions {\n+    fn fold_attributes(&self, attrs: ~[attribute]) -> ~[attribute];\n+}\n+\n+impl AstFoldExtensions for @ast_fold {\n     fn fold_attributes(&self, attrs: ~[attribute]) -> ~[attribute] {\n         attrs.map(|x| fold_attribute_(*x, *self))\n     }"}, {"sha": "fa32b9603a5da42f57730d7af294e7fc8f08935c", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37abf4bad0eda08cf4ef756310443329fa28f6cf/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=37abf4bad0eda08cf4ef756310443329fa28f6cf", "patch": "@@ -56,6 +56,3 @@ fn context_res() -> context_res {\n \n pub type context = arc_destruct<context_res>;\n \n-pub impl context {\n-    fn socket(&self) { }\n-}"}]}