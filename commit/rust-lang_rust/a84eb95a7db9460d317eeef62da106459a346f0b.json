{"sha": "a84eb95a7db9460d317eeef62da106459a346f0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NGViOTVhN2RiOTQ2MGQzMTdlZWVmNjJkYTEwNjQ1OWEzNDZmMGI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-02-20T17:18:31Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-02-20T18:36:30Z"}, "message": "check_match: don't treat privately uninhabited types as uninhabited\n\nFixes #38972.", "tree": {"sha": "b35ca0102407b69235cad5c68f4512034cd14373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b35ca0102407b69235cad5c68f4512034cd14373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a84eb95a7db9460d317eeef62da106459a346f0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a84eb95a7db9460d317eeef62da106459a346f0b", "html_url": "https://github.com/rust-lang/rust/commit/a84eb95a7db9460d317eeef62da106459a346f0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a84eb95a7db9460d317eeef62da106459a346f0b/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "306035c21741928bef75b8915d2195cce400b70a", "url": "https://api.github.com/repos/rust-lang/rust/commits/306035c21741928bef75b8915d2195cce400b70a", "html_url": "https://github.com/rust-lang/rust/commit/306035c21741928bef75b8915d2195cce400b70a"}], "stats": {"total": 181, "additions": 144, "deletions": 37}, "files": [{"sha": "5a9f885719c8fd8ab52e425218d1621600bb513a", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 62, "deletions": 30, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a84eb95a7db9460d317eeef62da106459a346f0b/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84eb95a7db9460d317eeef62da106459a346f0b/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=a84eb95a7db9460d317eeef62da106459a346f0b", "patch": "@@ -196,6 +196,28 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n             }\n         }).clone()\n     }\n+\n+    fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n+        if self.tcx.sess.features.borrow().never_type {\n+            ty.is_uninhabited_from(self.module, self.tcx)\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn is_variant_uninhabited(&self,\n+                              variant: &'tcx ty::VariantDef,\n+                              substs: &'tcx ty::subst::Substs<'tcx>) -> bool\n+    {\n+        if self.tcx.sess.features.borrow().never_type {\n+            let forest = variant.uninhabited_from(\n+                &mut FxHashMap::default(), self.tcx, substs, AdtKind::Enum\n+            );\n+            forest.contains(self.tcx, self.module)\n+        } else {\n+            false\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -379,48 +401,32 @@ impl<'tcx> Witness<'tcx> {\n fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                   pcx: PatternContext<'tcx>) -> Vec<Constructor>\n {\n-    let check_inhabited = cx.tcx.sess.features.borrow().never_type;\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     match pcx.ty.sty {\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n         ty::TySlice(ref sub_ty) => {\n-            if sub_ty.is_uninhabited_from(cx.module, cx.tcx)\n-                && check_inhabited\n-            {\n+            if cx.is_uninhabited(sub_ty) {\n                 vec![Slice(0)]\n             } else {\n                 (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n             }\n         }\n         ty::TyArray(ref sub_ty, length) => {\n-            if length == 0 || !(sub_ty.is_uninhabited_from(cx.module, cx.tcx)\n-                                && check_inhabited)\n-            {\n-                vec![Slice(length)]\n-            } else {\n+            if length > 0 && cx.is_uninhabited(sub_ty) {\n                 vec![]\n+            } else {\n+                vec![Slice(length)]\n             }\n         }\n         ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n-            def.variants.iter().filter_map(|v| {\n-                let mut visited = FxHashMap::default();\n-                let forest = v.uninhabited_from(&mut visited,\n-                                                cx.tcx, substs,\n-                                                AdtKind::Enum);\n-                if forest.contains(cx.tcx, cx.module)\n-                    && check_inhabited\n-                {\n-                    None\n-                } else {\n-                    Some(Variant(v.did))\n-                }\n-            }).collect()\n+            def.variants.iter()\n+                .filter(|v| !cx.is_variant_uninhabited(v, substs))\n+                .map(|v| Variant(v.did))\n+                .collect()\n         }\n         _ => {\n-            if pcx.ty.is_uninhabited_from(cx.module, cx.tcx)\n-                    && check_inhabited\n-            {\n+            if cx.is_uninhabited(pcx.ty) {\n                 vec![]\n             } else {\n                 vec![Single]\n@@ -564,7 +570,6 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n-\n     let pcx = PatternContext {\n         ty: rows.iter().map(|r| r[0].ty).find(|ty| !ty.references_error())\n             .unwrap_or(v[0].ty),\n@@ -590,7 +595,6 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         let missing_ctors: Vec<Constructor> = all_ctors.iter().filter(|c| {\n             !used_ctors.contains(*c)\n         }).cloned().collect();\n-        debug!(\"missing_ctors = {:?}\", missing_ctors);\n \n         // `missing_ctors` is the set of constructors from the same type as the\n         // first column of `matrix` that are matched only by wildcard patterns\n@@ -599,8 +603,23 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         // Therefore, if there is some pattern that is unmatched by `matrix`,\n         // it will still be unmatched if the first constructor is replaced by\n         // any of the constructors in `missing_ctors`\n-\n-        if missing_ctors.is_empty() {\n+        //\n+        // However, if our scrutinee is *privately* an empty enum, we\n+        // must treat it as though it had an \"unknown\" constructor (in\n+        // that case, all other patterns obviously can't be variants)\n+        // to avoid exposing its emptyness. See the `match_privately_empty`\n+        // test for details.\n+        //\n+        // FIXME: currently the only way I know of something can\n+        // be a privately-empty enum is when the never_type\n+        // feature flag is not present, so this is only\n+        // needed for that case.\n+\n+        let is_privately_empty =\n+            all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n+        debug!(\"missing_ctors={:?} is_privately_empty={:?}\", missing_ctors,\n+               is_privately_empty);\n+        if missing_ctors.is_empty() && !is_privately_empty {\n             all_ctors.into_iter().map(|c| {\n                 is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n             }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n@@ -649,6 +668,7 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     lty: Ty<'tcx>,\n     witness: WitnessPreference) -> Usefulness<'tcx>\n {\n+    debug!(\"is_useful_specialized({:?}, {:?}, {:?})\", v, ctor, lty);\n     let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n     let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n         Pattern {\n@@ -754,7 +774,19 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n         ty::TyRef(_, ref ty_and_mut) => vec![ty_and_mut.ty],\n         ty::TyAdt(adt, substs) => {\n             adt.variants[ctor.variant_index_for_adt(adt)].fields.iter().map(|field| {\n-                field.ty(cx.tcx, substs)\n+                let is_visible = adt.is_enum()\n+                    || field.vis.is_accessible_from(cx.module, cx.tcx);\n+                if is_visible {\n+                    field.ty(cx.tcx, substs)\n+                } else {\n+                    // Treat all non-visible fields as nil. They\n+                    // can't appear in any other pattern from\n+                    // this match (because they are private),\n+                    // so their type does not matter - but\n+                    // we don't want to know they are\n+                    // uninhabited.\n+                    cx.tcx.mk_nil()\n+                }\n             }).collect()\n         }\n         _ => vec![],"}, {"sha": "e5362a70e53b6fbc44ed648fbf1f5f0670548af5", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a84eb95a7db9460d317eeef62da106459a346f0b/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84eb95a7db9460d317eeef62da106459a346f0b/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=a84eb95a7db9460d317eeef62da106459a346f0b", "patch": "@@ -177,6 +177,26 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Fourth, check for unreachable arms.\n             check_arms(cx, &inlined_arms, source);\n \n+            // Then, if the match has no arms, check whether the scrutinee\n+            // is uninhabited.\n+            let pat_ty = self.tables.node_id_to_type(scrut.id);\n+            let module = self.tcx.hir.local_def_id(self.tcx.hir.get_module_parent(scrut.id));\n+            if inlined_arms.is_empty() {\n+                if !pat_ty.is_uninhabited_from(module, self.tcx) {\n+                    // We know the type is inhabited, so this must be wrong\n+                    let mut err = create_e0004(self.tcx.sess, scrut.span,\n+                                               format!(\"non-exhaustive patterns: type {} \\\n+                                                        is non-empty\",\n+                                                       pat_ty));\n+                    span_help!(&mut err, scrut.span,\n+                               \"Please ensure that all possible cases are being handled; \\\n+                                possibly adding wildcards or more match arms.\");\n+                    err.emit();\n+                }\n+                // If the type *is* uninhabited, it's vacuously exhaustive\n+                return;\n+            }\n+\n             let matrix: Matrix = inlined_arms\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())"}, {"sha": "3affb1c03e952ab3bc8276794cbcb2acd8299148", "filename": "src/test/compile-fail/match-privately-empty.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a84eb95a7db9460d317eeef62da106459a346f0b/src%2Ftest%2Fcompile-fail%2Fmatch-privately-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84eb95a7db9460d317eeef62da106459a346f0b/src%2Ftest%2Fcompile-fail%2Fmatch-privately-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-privately-empty.rs?ref=a84eb95a7db9460d317eeef62da106459a346f0b", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+\n+mod private {\n+    pub struct Private {\n+        _bot: !,\n+        pub misc: bool,\n+    }\n+    pub const DATA: Option<Private> = None;\n+}\n+\n+fn main() {\n+    match private::DATA {\n+    //~^ ERROR non-exhaustive patterns: `Some(Private { misc: true, .. })` not covered\n+        None => {}\n+        Some(private::Private {\n+            misc: false,\n+            ..\n+        }) => {}\n+    }\n+}"}, {"sha": "68781a407cc00e5f550e7182436d8cdc0b989679", "filename": "src/test/compile-fail/uninhabited-matches-feature-gated.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a84eb95a7db9460d317eeef62da106459a346f0b/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84eb95a7db9460d317eeef62da106459a346f0b/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs?ref=a84eb95a7db9460d317eeef62da106459a346f0b", "patch": "@@ -19,16 +19,13 @@ fn main() {\n     };\n \n     let x: &Void = unsafe { std::mem::uninitialized() };\n-    let _ = match x {};\n-    //~^ ERROR non-exhaustive\n+    let _ = match x {}; // okay\n \n     let x: (Void,) = unsafe { std::mem::uninitialized() };\n-    let _ = match x {};\n-    //~^ ERROR non-exhaustive\n+    let _ = match x {}; // okay\n \n     let x: [Void; 1] = unsafe { std::mem::uninitialized() };\n-    let _ = match x {};\n-    //~^ ERROR non-exhaustive\n+    let _ = match x {}; // okay\n \n     let x: &[Void] = unsafe { std::mem::uninitialized() };\n     let _ = match x {   //~ ERROR non-exhaustive\n@@ -47,4 +44,3 @@ fn main() {\n     let Ok(x) = x;\n     //~^ ERROR refutable\n }\n-"}, {"sha": "9c440503214e6c7be0b5708fb7341940c59044d5", "filename": "src/test/run-pass/issue-38972.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a84eb95a7db9460d317eeef62da106459a346f0b/src%2Ftest%2Frun-pass%2Fissue-38972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84eb95a7db9460d317eeef62da106459a346f0b/src%2Ftest%2Frun-pass%2Fissue-38972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-38972.rs?ref=a84eb95a7db9460d317eeef62da106459a346f0b", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This issue tracks a regression (a new warning) without\n+// feature(never_type). When we make that the default, please\n+// remove this test.\n+\n+enum Foo { }\n+\n+fn make_foo() -> Option<Foo> { None }\n+\n+fn use_foo(v: &Foo) -> ! {\n+    match v { }\n+}\n+\n+#[deny(warnings)]\n+fn main() {\n+    match make_foo() {\n+        None => {},\n+        Some(ref v) => use_foo(v),\n+    }\n+}"}]}