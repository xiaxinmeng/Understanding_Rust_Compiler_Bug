{"sha": "d07f7533b0f336ff27ca4ba90aec0e0204ca7b92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwN2Y3NTMzYjBmMzM2ZmYyN2NhNGJhOTBhZWMwZTAyMDRjYTdiOTI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-01T21:54:40Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-01T21:54:40Z"}, "message": "Sketch out #fmt syntax extension in rustboot.", "tree": {"sha": "b306c236c22eeb47fa67849ad8a50a3f0fb66bd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b306c236c22eeb47fa67849ad8a50a3f0fb66bd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d07f7533b0f336ff27ca4ba90aec0e0204ca7b92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d07f7533b0f336ff27ca4ba90aec0e0204ca7b92", "html_url": "https://github.com/rust-lang/rust/commit/d07f7533b0f336ff27ca4ba90aec0e0204ca7b92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d07f7533b0f336ff27ca4ba90aec0e0204ca7b92/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e0d07540702ac6cabcc5670660c72f898d5cbd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e0d07540702ac6cabcc5670660c72f898d5cbd2", "html_url": "https://github.com/rust-lang/rust/commit/2e0d07540702ac6cabcc5670660c72f898d5cbd2"}], "stats": {"total": 459, "additions": 415, "deletions": 44}, "files": [{"sha": "a0fe6cc3f1d29492df3aaf60747c756e3c7ee70f", "filename": "src/Makefile", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d07f7533b0f336ff27ca4ba90aec0e0204ca7b92/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d07f7533b0f336ff27ca4ba90aec0e0204ca7b92/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=d07f7533b0f336ff27ca4ba90aec0e0204ca7b92", "patch": "@@ -235,8 +235,8 @@ IL_MLS := $(addprefix boot/be/, asm.ml il.ml abi.ml)\n ME_MLS := $(addprefix boot/me/, walk.ml semant.ml resolve.ml alias.ml \\\n             simplify.ml type.ml dead.ml effect.ml typestate.ml loop.ml \\\n             layout.ml transutil.ml trans.ml dwarf.ml)\n-FE_MLS := $(addprefix boot/fe/, ast.ml token.ml lexer.ml parser.ml pexp.ml \\\n-            item.ml cexp.ml fuzz.ml)\n+FE_MLS := $(addprefix boot/fe/, ast.ml token.ml lexer.ml parser.ml \\\n+            extfmt.ml pexp.ml item.ml cexp.ml fuzz.ml)\n DRIVER_TOP_MLS := $(addprefix boot/driver/, lib.ml $(VARIANT)/glue.ml main.ml)\n \n BOOT_MLS := $(UTIL_BOT_MLS) $(DRIVER_BOT_MLS) $(FE_MLS) $(IL_MLS) $(ME_MLS) \\\n@@ -540,6 +540,7 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                       str-concat.rs \\\n                       str-idx.rs \\\n                       structured-compare.rs \\\n+                      syntax-extension-fmt.rs \\\n                       tag.rs \\\n                       tail-call-arg-leak.rs \\\n                       tail-cps.rs \\"}, {"sha": "8b0b149abc340375dfbe1cac9f1c1e5c60bc795a", "filename": "src/boot/fe/extfmt.ml", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/d07f7533b0f336ff27ca4ba90aec0e0204ca7b92/src%2Fboot%2Ffe%2Fextfmt.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d07f7533b0f336ff27ca4ba90aec0e0204ca7b92/src%2Fboot%2Ffe%2Fextfmt.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fextfmt.ml?ref=d07f7533b0f336ff27ca4ba90aec0e0204ca7b92", "patch": "@@ -0,0 +1,229 @@\n+(* The 'fmt' extension is modeled on the posix printf system.\n+ * \n+ * A posix conversion ostensibly looks like this:\n+ * \n+ * %[parameter][flags][width][.precision][length]type\n+ * \n+ * Given the different numeric type bestiary we have, we omit the 'length'\n+ * parameter and support slightly different conversions for 'type':\n+ * \n+ * %[parameter][flags][width][.precision]type\n+ * \n+ * we also only support translating-to-rust a tiny subset of the possible\n+ * combinations at the moment.\n+ *)\n+\n+exception Malformed of string\n+;;\n+\n+type case =\n+    CASE_upper\n+  | CASE_lower\n+;;\n+\n+type signedness =\n+    SIGNED\n+  | UNSIGNED\n+;;\n+\n+type ty =\n+    TY_bool\n+  | TY_str\n+  | TY_char\n+  | TY_int of signedness\n+  | TY_bits\n+  | TY_hex of case\n+      (* FIXME: Support more later. *)\n+;;\n+\n+type flag =\n+    FLAG_left_justify\n+  | FLAG_left_zero_pad\n+  | FLAG_left_space_pad\n+  | FLAG_plus_if_positive\n+  | FLAG_alternate\n+;;\n+\n+type count =\n+    COUNT_is of int\n+  | COUNT_is_param of int\n+  | COUNT_is_next_param\n+  | COUNT_implied\n+\n+type conv =\n+    { conv_parameter: int option;\n+      conv_flags: flag list;\n+      conv_width: count;\n+      conv_precision: count;\n+      conv_ty: ty }\n+\n+type piece =\n+    PIECE_string of string\n+  | PIECE_conversion of conv\n+\n+\n+let rec peek_num (s:string) (i:int) (lim:int)\n+    : (int * int) option =\n+  if i >= lim\n+  then None\n+  else\n+    let c = s.[i] in\n+      if '0' <= c && c <= '9'\n+      then\n+        let n = (Char.code c) - (Char.code '0') in\n+          match peek_num s (i+1) lim with\n+              None -> Some (n, i+1)\n+            | Some (m, i) -> Some (n * 10 + m, i)\n+      else None\n+;;\n+\n+let parse_parameter (s:string) (i:int) (lim:int)\n+    : (int option * int) =\n+  if i >= lim\n+  then (None, i)\n+  else\n+    match peek_num s i lim with\n+        None -> (None, i)\n+      | Some (n, j) ->\n+          if j < (String.length s) && s.[j] = '$'\n+          then (Some n, j+1)\n+          else (None, i)\n+;;\n+\n+let rec parse_flags (s:string) (i:int) (lim:int)\n+    : (flag list * int) =\n+  if i >= lim\n+  then ([], i)\n+  else\n+    let cont flag =\n+      let (rest, j) = parse_flags s (i+1) lim in\n+        (flag :: rest, j)\n+    in\n+      match s.[i] with\n+          '-' -> cont FLAG_left_justify\n+        | '0' -> cont FLAG_left_zero_pad\n+        | ' ' -> cont FLAG_left_space_pad\n+        | '+' -> cont FLAG_plus_if_positive\n+        | '#' -> cont FLAG_alternate\n+        | _ -> ([], i)\n+;;\n+\n+let parse_count (s:string) (i:int) (lim:int)\n+    : (count * int) =\n+  if i >= lim\n+  then (COUNT_implied, i)\n+  else\n+    if s.[i] = '*'\n+    then\n+      begin\n+        match parse_parameter s (i+1) lim with\n+            (None, j) -> (COUNT_is_next_param, j)\n+          | (Some n, j) -> (COUNT_is_param n, j)\n+      end\n+    else\n+      begin\n+        match peek_num s i lim with\n+            None -> (COUNT_implied, i)\n+          | Some (n, j) -> (COUNT_is n, j)\n+      end\n+;;\n+\n+let parse_precision (s:string) (i:int) (lim:int)\n+    : (count * int) =\n+  if i >= lim\n+  then (COUNT_implied, i)\n+  else\n+    if s.[i] = '.'\n+    then parse_count s (i+1) lim\n+    else (COUNT_implied, i)\n+;;\n+\n+let parse_type (s:string) (i:int) (lim:int)\n+    : (ty * int) =\n+  if i >= lim\n+  then raise (Malformed \"missing type in conversion\")\n+  else\n+    let t =\n+      match s.[i] with\n+          'b' -> TY_bool\n+        | 's' -> TY_str\n+        | 'c' -> TY_char\n+        | 'd' | 'i' -> TY_int SIGNED\n+        | 'u' -> TY_int UNSIGNED\n+        | 'x' -> TY_hex CASE_lower\n+        | 'X' -> TY_hex CASE_upper\n+        | 't' -> TY_bits\n+        | _ -> raise (Malformed \"unknown type in conversion\")\n+    in\n+      (t, i+1)\n+;;\n+\n+let parse_conversion (s:string) (i:int) (lim:int)\n+    : (piece * int) =\n+  let (parameter, i) = parse_parameter s i lim in\n+  let (flags, i) = parse_flags s i lim in\n+  let (width, i) = parse_count s i lim in\n+  let (precision, i) = parse_precision s i lim in\n+  let (ty, i) = parse_type s i lim in\n+    (PIECE_conversion  { conv_parameter = parameter;\n+                         conv_flags = flags;\n+                         conv_width = width;\n+                         conv_precision = precision;\n+                         conv_ty = ty }, i)\n+;;\n+\n+let parse_fmt_string (s:string) : piece array =\n+  let pieces = Queue.create () in\n+  let i = ref 0 in\n+  let lim = String.length s in\n+  let buf = Buffer.create 10 in\n+  let flush_buf _ =\n+    if (Buffer.length buf) <> 0\n+    then\n+      let piece =\n+        PIECE_string (Buffer.contents buf)\n+      in\n+        Queue.add piece pieces;\n+        Buffer.clear buf;\n+  in\n+    while (!i) < lim\n+    do\n+      if s.[!i] = '%'\n+      then\n+        begin\n+          incr i;\n+          if (!i) >= lim\n+          then raise (Malformed \"unterminated conversion at end of string\");\n+          if s.[!i] = '%'\n+          then\n+            begin\n+              Buffer.add_char buf '%';\n+              incr i;\n+            end\n+          else\n+            begin\n+              flush_buf();\n+              let (piece, j) = parse_conversion s (!i) lim in\n+                Queue.add piece pieces;\n+                i := j\n+            end\n+        end\n+      else\n+        begin\n+          Buffer.add_char buf s.[!i];\n+          incr i;\n+        end\n+    done;\n+    flush_buf ();\n+    Common.queue_to_arr pieces\n+;;\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "85eb32c46dfc89f3b1ac7c56f5d91245dc1f8d1b", "filename": "src/boot/fe/pexp.ml", "status": "modified", "additions": 178, "deletions": 42, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/d07f7533b0f336ff27ca4ba90aec0e0204ca7b92/src%2Fboot%2Ffe%2Fpexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d07f7533b0f336ff27ca4ba90aec0e0204ca7b92/src%2Fboot%2Ffe%2Fpexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fpexp.ml?ref=d07f7533b0f336ff27ca4ba90aec0e0204ca7b92", "patch": "@@ -903,44 +903,6 @@ and parse_mutable_and_pexp_list (ps:pstate)\n \n ;;\n \n-(* \n- * FIXME: This is a crude approximation of the syntax-extension system,\n- * for purposes of prototyping and/or hard-wiring any extensions we\n- * wish to use in the bootstrap compiler. The eventual aim is to permit\n- * loading rust crates to process extensions, but this will likely\n- * require a rust-based frontend, or an ocaml-FFI-based connection to\n- * rust crates. At the moment we have neither.\n- *)\n-\n-let expand_pexp_custom\n-    (ps:pstate)\n-    (dst_lval:Ast.lval)\n-    (name:Ast.name)\n-    (args:Ast.atom array)\n-    (body:string option)\n-    (spanner:'a -> 'a identified)\n-    : (Ast.stmt array) =\n-  let nstr = Fmt.fmt_to_str Ast.fmt_name name in\n-    match (nstr, (Array.length args), body) with\n-\n-        (\"shell\", 0, Some cmd) ->\n-          let c = Unix.open_process_in cmd in\n-          let b = Buffer.create 32 in\n-          let rec r _ =\n-            try\n-              Buffer.add_char b (input_char c);\n-              r ()\n-            with\n-                End_of_file ->\n-                  ignore (Unix.close_process_in c);\n-                  Buffer.contents b\n-          in\n-            [| spanner (Ast.STMT_new_str (dst_lval, r())) |]\n-\n-      | _ ->\n-          raise (err (\"unknown syntax extension: \" ^ nstr) ps)\n-;;\n-\n (* \n  * Desugarings depend on context:\n  * \n@@ -1253,11 +1215,185 @@ and desugar_expr_init\n             aa arg_stmts [| stmt |]\n \n       | Ast.PEXP_custom (n, a, b) ->\n-          let (arg_stmts, args) = desugar_expr_atoms ps a in\n-          let stmts =\n-            expand_pexp_custom ps dst_lval n args b ss\n+          expand_pexp_custom ps apos bpos dst_lval n a b\n+\n+(* \n+ * FIXME: This is a crude approximation of the syntax-extension system,\n+ * for purposes of prototyping and/or hard-wiring any extensions we\n+ * wish to use in the bootstrap compiler. The eventual aim is to permit\n+ * loading rust crates to process extensions, but this will likely\n+ * require a rust-based frontend, or an ocaml-FFI-based connection to\n+ * rust crates. At the moment we have neither.\n+ *)\n+\n+and expand_pexp_custom\n+    (ps:pstate)\n+    (apos:pos)\n+    (bpos:pos)\n+    (dst_lval:Ast.lval)\n+    (name:Ast.name)\n+    (pexp_args:Ast.pexp array)\n+    (body:string option)\n+    : (Ast.stmt array) =\n+  let nstr = Fmt.fmt_to_str Ast.fmt_name name in\n+    match (nstr, (Array.length pexp_args), body) with\n+\n+        (\"shell\", 0, Some cmd) ->\n+          let c = Unix.open_process_in cmd in\n+          let b = Buffer.create 32 in\n+          let rec r _ =\n+            try\n+              Buffer.add_char b (input_char c);\n+              r ()\n+            with\n+                End_of_file ->\n+                  ignore (Unix.close_process_in c);\n+                  Buffer.contents b\n           in\n-            aa arg_stmts stmts\n+            [| span ps apos bpos\n+                 (Ast.STMT_new_str (dst_lval, r())) |]\n+\n+      | (\"fmt\", nargs, None) ->\n+            if nargs = 0\n+            then raise (err \"malformed #fmt call\" ps)\n+            else\n+              begin\n+                match pexp_args.(0).node with\n+                    Ast.PEXP_str s ->\n+                      let (arg_stmts, args) =\n+                        desugar_expr_atoms ps\n+                          (Array.sub pexp_args 1 (nargs-1))\n+                      in\n+\n+                      let pieces = Extfmt.parse_fmt_string s in\n+                      let fmt_stmts =\n+                        fmt_pieces_to_stmts\n+                          ps apos bpos dst_lval pieces args\n+                      in\n+                        Array.append arg_stmts fmt_stmts\n+                  | _ ->\n+                      raise (err \"malformed #fmt call\" ps)\n+              end\n+\n+      | _ ->\n+          raise (err (\"unknown syntax extension: \" ^ nstr) ps)\n+\n+and fmt_pieces_to_stmts\n+    (ps:pstate)\n+    (apos:pos)\n+    (bpos:pos)\n+    (dst_lval:Ast.lval)\n+    (pieces:Extfmt.piece array)\n+    (args:Ast.atom array)\n+    : (Ast.stmt array) =\n+\n+  let stmts = Queue.create () in\n+\n+  let make_new_tmp _ =\n+    let (_, tmp, decl_stmt) = build_tmp ps slot_auto apos bpos in\n+      Queue.add decl_stmt stmts;\n+      tmp\n+  in\n+\n+  let make_new_str s =\n+    let tmp = make_new_tmp () in\n+    let init_stmt =\n+      span ps apos bpos (Ast.STMT_new_str (clone_lval ps tmp, s))\n+    in\n+      Queue.add init_stmt stmts;\n+      tmp\n+  in\n+\n+  let make_append dst_lval src_atom =\n+    let stmt =\n+      span ps apos bpos\n+        (Ast.STMT_copy_binop\n+           ((clone_lval ps dst_lval), Ast.BINOP_add, src_atom))\n+    in\n+      Queue.add stmt stmts\n+  in\n+\n+  let make_append_lval dst_lval src_lval =\n+      make_append dst_lval (Ast.ATOM_lval (clone_lval ps src_lval))\n+  in\n+\n+  let rec make_lval' path =\n+    match path with\n+        [n] ->\n+          Ast.LVAL_base (span ps apos bpos (Ast.BASE_ident n))\n+\n+      | x :: xs ->\n+          Ast.LVAL_ext (make_lval' xs,\n+                        Ast.COMP_named (Ast.COMP_ident x))\n+\n+      | [] -> (bug () \"make_lval on empty list in #fmt\")\n+  in\n+\n+  let make_lval path = make_lval' (List.rev path) in\n+\n+  let make_call dst path args =\n+    let callee = make_lval path in\n+    let stmt =\n+      span ps apos bpos (Ast.STMT_call (dst, callee, args ))\n+    in\n+      Queue.add stmt stmts\n+  in\n+\n+  let ulit i =\n+    Ast.ATOM_literal (span ps apos bpos (Ast.LIT_uint (Int64.of_int i)))\n+  in\n+\n+  let n = ref 0 in\n+  let tmp_lval = make_new_str \"\" in\n+  let final_stmt =\n+    span ps apos bpos\n+      (Ast.STMT_copy\n+         (clone_lval ps dst_lval,\n+          Ast.EXPR_atom (Ast.ATOM_lval tmp_lval)))\n+  in\n+    Array.iter\n+      begin\n+        fun piece ->\n+          match piece with\n+              Extfmt.PIECE_string s ->\n+                let s_lval = make_new_str s in\n+                  make_append_lval tmp_lval s_lval\n+\n+            | Extfmt.PIECE_conversion conv ->\n+                if not\n+                  ((conv.Extfmt.conv_parameter = None) &&\n+                     (conv.Extfmt.conv_flags = []) &&\n+                     (conv.Extfmt.conv_width = Extfmt.COUNT_implied) &&\n+                     (conv.Extfmt.conv_precision = Extfmt.COUNT_implied))\n+                then\n+                  raise (err \"conversion not supported in #fmt string\" ps);\n+                if !n >= Array.length args\n+                then raise (err \"too many conversions in #fmt string\" ps);\n+                let arg = args.(!n) in\n+                  incr n;\n+                  match conv.Extfmt.conv_ty with\n+                      Extfmt.TY_str ->\n+                        make_append tmp_lval arg\n+\n+                    | Extfmt.TY_int Extfmt.SIGNED ->\n+                        let t = make_new_tmp () in\n+                          make_call t\n+                            [\"std\"; \"_int\"; \"to_str\" ] [| arg; ulit 10 |];\n+\n+                          make_append_lval tmp_lval t\n+\n+                    | Extfmt.TY_int Extfmt.UNSIGNED ->\n+                        let t = make_new_tmp () in\n+                          make_call t\n+                            [\"std\"; \"_uint\"; \"to_str\" ] [| arg; ulit 10 |];\n+                          make_append_lval tmp_lval t\n+\n+                    | _ ->\n+                        raise (err \"conversion not supported in #fmt\" ps);\n+      end\n+      pieces;\n+    Queue.add final_stmt stmts;\n+    queue_to_arr stmts;\n \n \n and atom_lval (_:pstate) (at:Ast.atom) : Ast.lval ="}, {"sha": "65e7647ee8b50dd70da376ca1f3fc06a18be93fb", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d07f7533b0f336ff27ca4ba90aec0e0204ca7b92/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07f7533b0f336ff27ca4ba90aec0e0204ca7b92/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=d07f7533b0f336ff27ca4ba90aec0e0204ca7b92", "patch": "@@ -0,0 +1,5 @@\n+use std;\n+fn main() {\n+  auto s = #fmt(\"hello %d friends and %s things\", 10, \"formatted\");\n+  log s;\n+}"}, {"sha": "509b6d8b468d5274d08cf812a86e676edf36a716", "filename": "src/test/run-pass/syntax-extension-shell.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d07f7533b0f336ff27ca4ba90aec0e0204ca7b92/src%2Ftest%2Frun-pass%2Fsyntax-extension-shell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07f7533b0f336ff27ca4ba90aec0e0204ca7b92/src%2Ftest%2Frun-pass%2Fsyntax-extension-shell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-shell.rs?ref=d07f7533b0f336ff27ca4ba90aec0e0204ca7b92", "previous_filename": "src/test/run-pass/syntax-extension.rs"}]}