{"sha": "78e572c62782b4bd027c23b9d56a14b0b42ba93a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ZTU3MmM2Mjc4MmI0YmQwMjdjMjNiOWQ1NmExNGIwYjQyYmE5M2E=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-06T09:59:35Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-11T10:40:24Z"}, "message": "move useless_asref to its own module", "tree": {"sha": "ad3ba546a31ebdbc33aa64814f8e7a7b6e8dcf95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad3ba546a31ebdbc33aa64814f8e7a7b6e8dcf95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78e572c62782b4bd027c23b9d56a14b0b42ba93a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78e572c62782b4bd027c23b9d56a14b0b42ba93a", "html_url": "https://github.com/rust-lang/rust/commit/78e572c62782b4bd027c23b9d56a14b0b42ba93a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78e572c62782b4bd027c23b9d56a14b0b42ba93a/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caaba8270c7de1bf3446f3345e7e794295db59fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/caaba8270c7de1bf3446f3345e7e794295db59fd", "html_url": "https://github.com/rust-lang/rust/commit/caaba8270c7de1bf3446f3345e7e794295db59fd"}], "stats": {"total": 90, "additions": 50, "deletions": 40}, "files": [{"sha": "eaf247536b6e3b18d0ba8b28fe272580d487353a", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 40, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/78e572c62782b4bd027c23b9d56a14b0b42ba93a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e572c62782b4bd027c23b9d56a14b0b42ba93a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=78e572c62782b4bd027c23b9d56a14b0b42ba93a", "patch": "@@ -42,6 +42,7 @@ mod uninit_assumed_init;\n mod unnecessary_filter_map;\n mod unnecessary_lazy_eval;\n mod unwrap_used;\n+mod useless_asref;\n mod wrong_self_convention;\n mod zst_offset;\n \n@@ -65,11 +66,11 @@ use rustc_typeck::hir_ty_to_ty;\n use crate::utils::eager_or_lazy::is_lazyness_candidate;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n-    contains_return, contains_ty, get_parent_expr, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of,\n+    contains_return, contains_ty, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of,\n     is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath, match_trait_method,\n     match_type, meets_msrv, method_calls, method_chain_args, path_to_local_id, paths, remove_blocks, return_ty,\n     single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_help, span_lint_and_sugg, strip_pat_refs, walk_ptrs_ty_depth, SpanlessEq,\n+    span_lint_and_help, span_lint_and_sugg, strip_pat_refs, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -1733,8 +1734,8 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"step_by\", ..] => iterator_step_by_zero::check(cx, expr, arg_lists[0]),\n             [\"next\", \"skip\"] => iter_skip_next::check(cx, expr, arg_lists[1]),\n             [\"collect\", \"cloned\"] => iter_cloned_collect::check(cx, expr, arg_lists[1]),\n-            [\"as_ref\"] => lint_asref(cx, expr, \"as_ref\", arg_lists[0]),\n-            [\"as_mut\"] => lint_asref(cx, expr, \"as_mut\", arg_lists[0]),\n+            [\"as_ref\"] => useless_asref::check(cx, expr, \"as_ref\", arg_lists[0]),\n+            [\"as_mut\"] => useless_asref::check(cx, expr, \"as_mut\", arg_lists[0]),\n             [\"fold\", ..] => lint_unnecessary_fold(cx, expr, arg_lists[0], method_spans[0]),\n             [\"filter_map\", ..] => {\n                 unnecessary_filter_map::check(cx, expr, arg_lists[0]);\n@@ -2751,42 +2752,6 @@ fn get_hint_if_single_char_arg(\n     }\n }\n \n-/// Checks for the `USELESS_ASREF` lint.\n-fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_ref_args: &[hir::Expr<'_>]) {\n-    // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n-    // check if the call is to the actual `AsRef` or `AsMut` trait\n-    if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n-        // check if the type after `as_ref` or `as_mut` is the same as before\n-        let recvr = &as_ref_args[0];\n-        let rcv_ty = cx.typeck_results().expr_ty(recvr);\n-        let res_ty = cx.typeck_results().expr_ty(expr);\n-        let (base_res_ty, res_depth) = walk_ptrs_ty_depth(res_ty);\n-        let (base_rcv_ty, rcv_depth) = walk_ptrs_ty_depth(rcv_ty);\n-        if base_rcv_ty == base_res_ty && rcv_depth >= res_depth {\n-            // allow the `as_ref` or `as_mut` if it is followed by another method call\n-            if_chain! {\n-                if let Some(parent) = get_parent_expr(cx, expr);\n-                if let hir::ExprKind::MethodCall(_, ref span, _, _) = parent.kind;\n-                if span != &expr.span;\n-                then {\n-                    return;\n-                }\n-            }\n-\n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                USELESS_ASREF,\n-                expr.span,\n-                &format!(\"this call to `{}` does nothing\", call_name),\n-                \"try this\",\n-                snippet_with_applicability(cx, recvr.span, \"..\", &mut applicability).to_string(),\n-                applicability,\n-            );\n-        }\n-    }\n-}\n-\n const FN_HEADER: hir::FnHeader = hir::FnHeader {\n     unsafety: hir::Unsafety::Normal,\n     constness: hir::Constness::NotConst,"}, {"sha": "e4554f8d4897e21470d34605ec481ab7d4d34dec", "filename": "clippy_lints/src/methods/useless_asref.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/78e572c62782b4bd027c23b9d56a14b0b42ba93a/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e572c62782b4bd027c23b9d56a14b0b42ba93a/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs?ref=78e572c62782b4bd027c23b9d56a14b0b42ba93a", "patch": "@@ -0,0 +1,45 @@\n+use crate::utils::{\n+    get_parent_expr, match_trait_method, paths, snippet_with_applicability, span_lint_and_sugg, walk_ptrs_ty_depth,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::USELESS_ASREF;\n+\n+/// Checks for the `USELESS_ASREF` lint.\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_ref_args: &[hir::Expr<'_>]) {\n+    // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n+    // check if the call is to the actual `AsRef` or `AsMut` trait\n+    if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n+        // check if the type after `as_ref` or `as_mut` is the same as before\n+        let recvr = &as_ref_args[0];\n+        let rcv_ty = cx.typeck_results().expr_ty(recvr);\n+        let res_ty = cx.typeck_results().expr_ty(expr);\n+        let (base_res_ty, res_depth) = walk_ptrs_ty_depth(res_ty);\n+        let (base_rcv_ty, rcv_depth) = walk_ptrs_ty_depth(rcv_ty);\n+        if base_rcv_ty == base_res_ty && rcv_depth >= res_depth {\n+            // allow the `as_ref` or `as_mut` if it is followed by another method call\n+            if_chain! {\n+                if let Some(parent) = get_parent_expr(cx, expr);\n+                if let hir::ExprKind::MethodCall(_, ref span, _, _) = parent.kind;\n+                if span != &expr.span;\n+                then {\n+                    return;\n+                }\n+            }\n+\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                USELESS_ASREF,\n+                expr.span,\n+                &format!(\"this call to `{}` does nothing\", call_name),\n+                \"try this\",\n+                snippet_with_applicability(cx, recvr.span, \"..\", &mut applicability).to_string(),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}]}