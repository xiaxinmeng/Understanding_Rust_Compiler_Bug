{"sha": "e6dde28c95b66a46a0dc05bfc9a5586b64e08575", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZGRlMjhjOTViNjZhNDZhMGRjMDViZmM5YTU1ODZiNjRlMDg1NzU=", "commit": {"author": {"name": "niftynif", "email": "nif.ward@gmail.com", "date": "2013-11-05T00:45:49Z"}, "committer": {"name": "niftynif", "email": "nif.ward@gmail.com", "date": "2013-11-05T00:45:49Z"}, "message": "Added skeleton implementation of a B-tree with a few bells and\nwhistles.  No major functionality added yet (such as insertion and\nremoval).", "tree": {"sha": "601deaf4c33e40feddf1dd69a7755461587c871f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/601deaf4c33e40feddf1dd69a7755461587c871f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6dde28c95b66a46a0dc05bfc9a5586b64e08575", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6dde28c95b66a46a0dc05bfc9a5586b64e08575", "html_url": "https://github.com/rust-lang/rust/commit/e6dde28c95b66a46a0dc05bfc9a5586b64e08575", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6dde28c95b66a46a0dc05bfc9a5586b64e08575/comments", "author": {"login": "niftynif", "id": 2904787, "node_id": "MDQ6VXNlcjI5MDQ3ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/2904787?v=4", "gravatar_id": "", "url": "https://api.github.com/users/niftynif", "html_url": "https://github.com/niftynif", "followers_url": "https://api.github.com/users/niftynif/followers", "following_url": "https://api.github.com/users/niftynif/following{/other_user}", "gists_url": "https://api.github.com/users/niftynif/gists{/gist_id}", "starred_url": "https://api.github.com/users/niftynif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/niftynif/subscriptions", "organizations_url": "https://api.github.com/users/niftynif/orgs", "repos_url": "https://api.github.com/users/niftynif/repos", "events_url": "https://api.github.com/users/niftynif/events{/privacy}", "received_events_url": "https://api.github.com/users/niftynif/received_events", "type": "User", "site_admin": false}, "committer": {"login": "niftynif", "id": 2904787, "node_id": "MDQ6VXNlcjI5MDQ3ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/2904787?v=4", "gravatar_id": "", "url": "https://api.github.com/users/niftynif", "html_url": "https://github.com/niftynif", "followers_url": "https://api.github.com/users/niftynif/followers", "following_url": "https://api.github.com/users/niftynif/following{/other_user}", "gists_url": "https://api.github.com/users/niftynif/gists{/gist_id}", "starred_url": "https://api.github.com/users/niftynif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/niftynif/subscriptions", "organizations_url": "https://api.github.com/users/niftynif/orgs", "repos_url": "https://api.github.com/users/niftynif/repos", "events_url": "https://api.github.com/users/niftynif/events{/privacy}", "received_events_url": "https://api.github.com/users/niftynif/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "658637baf45b41e4cff049440bc07f267d810218", "url": "https://api.github.com/repos/rust-lang/rust/commits/658637baf45b41e4cff049440bc07f267d810218", "html_url": "https://github.com/rust-lang/rust/commit/658637baf45b41e4cff049440bc07f267d810218"}], "stats": {"total": 372, "additions": 372, "deletions": 0}, "files": [{"sha": "5a4892a23911b82e6107fba52146f3f11e5afe63", "filename": "src/libextra/btree.rs", "status": "added", "additions": 372, "deletions": 0, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/e6dde28c95b66a46a0dc05bfc9a5586b64e08575/src%2Flibextra%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6dde28c95b66a46a0dc05bfc9a5586b64e08575/src%2Flibextra%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbtree.rs?ref=e6dde28c95b66a46a0dc05bfc9a5586b64e08575", "patch": "@@ -0,0 +1,372 @@\n+//\n+// btree.rs\n+// Nif Ward\n+// 10/24/13\n+//\n+// starting implementation of a btree for rust\n+// inspired by github user davidhalperin's gist\n+\n+\n+//What's in a BTree?\n+pub struct BTree<K, V>{\n+    root: Node<K, V>,\n+    len: uint,\n+    lower_bound: uint,\n+    upper_bound: uint\n+}\n+\n+\n+impl<K: Clone + TotalOrd, V: Clone> BTree<K, V>{\n+    \n+    //Returns new BTree with root node (leaf) and user-supplied lower bound\n+    fn new(k: K, v: V, lb: uint) -> BTree<K, V>{\n+        BTree{\n+\t    root: Node::new_leaf(~[LeafElt::new(k, v)]),\n+\t    len: 1,\n+\t    lower_bound: lb,\n+\t    upper_bound: 2 * lb\n+        }\n+    }\n+\n+    //Helper function for clone\n+    fn new_with_node_len(n: Node<K, V>, length: uint, lb: uint) -> BTree<K, V>{\n+        BTree{\n+\t    root: n,\n+\t    len: length,\n+\t    lower_bound: lb,\n+\t    upper_bound: 2 * lb\n+\t}\n+    }\n+\n+\n+    fn clone(&self) -> BTree<K, V>{\n+        return BTree::new_with_node_len(self.root.clone(), self.len, self.lower_bound);\n+    }\n+\n+    fn get(self, k: K) -> Option<V>{\n+        return self.root.get(k);\n+    }\n+\n+\n+    fn add(self, k: K, v: V) -> bool{\n+        let is_get = &self.clone().get(k.clone());\n+\tif is_get.is_some(){ return false; }\n+\telse{\n+\t    std::util::replace(&mut self.root.clone(),self.root.add(k.clone(), v));\n+\t    return true;\n+\t}\n+\n+    }\n+\n+\n+\n+}\n+\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for BTree<K, V>{\n+    //Returns a string representation of the BTree\n+    fn to_str(&self) -> ~str{\n+        let ret=self.root.to_str();\n+\treturn ret;\n+    }\n+}\n+\n+\n+//Node types\n+enum Node<K, V>{\n+    LeafNode(Leaf<K, V>),\n+    BranchNode(Branch<K, V>)\n+}\n+\n+\n+//Node functions/methods\n+impl<K: Clone + TotalOrd, V: Clone> Node<K, V>{\n+    //differentiates between leaf and branch nodes\n+    fn is_leaf(&self) -> bool{\n+        match self{\n+\t    &LeafNode(*) => true,\n+\t    &BranchNode(*) => false\n+        }\n+    }\n+    \n+    //Creates a new leaf or branch node\n+    fn new_leaf(vec: ~[LeafElt<K, V>]) -> Node<K,V>{\n+         LeafNode(Leaf::new(vec))\n+    }\n+    fn new_branch(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Node<K, V>{\n+        BranchNode(Branch::new(vec, right))\n+    }\n+\n+    fn get(&self, k: K) -> Option<V>{\n+        match *self{\n+\t    LeafNode(ref leaf) => return leaf.get(k),\n+\t    BranchNode(ref branch) => return branch.get(k)\n+        }\n+    }\n+\n+    //A placeholder for add\n+    //Currently returns a leaf node with a single value (the added one)\n+    fn add(self, k: K, v: V) -> Node<K, V>{\n+        return Node::new_leaf(~[LeafElt::new(k, v)]);\n+    }\n+}\n+\n+\n+impl<K: Clone + TotalOrd, V: Clone> Clone for Node<K, V>{\n+    fn clone(&self) -> Node<K, V>{\n+        match *self{\n+\t    LeafNode(ref leaf) => return Node::new_leaf(leaf.elts.clone()),\n+\t    BranchNode(ref branch) => return Node::new_branch(branch.elts.clone(), branch.rightmost_child.clone())\n+\t}\n+    }\n+}\n+\n+impl<K: Clone + TotalOrd, V: Clone> TotalOrd for Node<K, V>{\n+    #[allow(unused_variable)]\n+    fn cmp(&self, other: &Node<K, V>) -> Ordering{\n+        //Requires a match statement--defer these procs to branch and leaf.\n+        /* if self.elts[0].less_than(other.elts[0]) { return Less}\n+\tif self.elts[0].greater_than(other.elts[0]) {return Greater}\n+\telse {return Equal}\n+\t*/\n+\treturn Equal;\n+    }\n+}\n+\n+impl<K: Clone + TotalOrd, V: Clone> TotalEq for Node<K, V>{\n+    //Making sure Nodes have TotalEq\n+    #[allow(unused_variable)]\n+    fn equals(&self, other: &Node<K, V>) -> bool{\n+    /* put in a match and defer this stuff to branch and leaf\n+\n+        let mut shorter = 0;\n+        if self.elts.len() <= other.elts.len(){\n+\t    shorter = self.elts.len();\n+\t}\n+\telse{\n+\t    shorter = other.elts.len();\n+\t}\n+\tlet mut i = 0;\n+\twhile i < shorter{\n+\t    if !self.elts[i].has_key(other.elts[i].key){\n+\t        return false;\n+\t    }\n+\t    i +=1;\n+        }\n+\treturn true;\n+    */\n+    return true;\n+    }\n+}\n+\n+\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Node<K, V>{\n+    fn to_str(&self) -> ~str{\n+       match *self{\n+           LeafNode(ref leaf) => leaf.to_str(),\n+\t   BranchNode(*) => ~\"\"\n+       }\n+    }\n+}\n+\n+\n+//Array with no children\n+struct Leaf<K, V>{\n+    elts: ~[LeafElt<K, V>]\n+}\n+\n+//Array of values with children, plus a rightmost child (greater than all)\n+struct Branch<K, V>{\n+    elts: ~[BranchElt<K,V>],\n+    rightmost_child: ~Node<K, V>\n+}\n+\n+\n+impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V>{\n+    //Constructor takes in a vector of leaves\n+    fn new(vec: ~[LeafElt<K, V>]) -> Leaf<K, V>{\n+        Leaf{\n+            elts: vec\n+        }\n+    }\n+\n+\n+    fn get(&self, k: K) -> Option<V>{\n+        for s in self.elts.iter(){\n+\t    let order=s.key.cmp(&k);\n+\t    match order{\n+\t        Equal => return Some(s.value.clone()),\n+\t\t_ => {}\n+\t    }\n+\t}\n+\treturn None;\n+    }\n+\n+    //Add method in progress\n+    fn add(&self, k: K, v: V) -> Node<K, V>{\n+        return Node::new_leaf(~[LeafElt::new(k, v)]);\n+    }\n+\n+}\n+\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Leaf<K, V>{\n+    fn to_str(&self) -> ~str{\n+       let mut ret=~\"\";\n+       for s in self.elts.iter(){\n+           ret = ret+\" // \"+ s.to_str();\n+       }\n+       return ret;\n+    }\n+\n+}\n+\n+\n+impl<K: Clone + TotalOrd, V: Clone> Branch<K, V>{\n+    //constructor takes a branch vector and a rightmost child\n+    fn new(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Branch<K, V>{\n+        Branch{\n+\t    elts: vec,\n+\t    rightmost_child: right\n+        }\n+    }\n+\n+    fn get(&self, k: K) -> Option<V>{\n+        for s in self.elts.iter(){\n+\t    let order = s.key.cmp(&k);\n+\t    match order{\n+\t        Less => return s.left.get(k),\n+\t\tEqual => return Some(s.value.clone()),\n+\t\t_ => {}\n+\t    }\n+\t}\n+\treturn self.rightmost_child.get(k);\n+    }\n+\n+\n+    //Add method in progress\n+    fn add(&self, k: K, v: V) -> Node<K, V>{\n+        return Node::new_leaf(~[LeafElt::new(k, v)]);\n+    }\n+}\n+\n+//No left child\n+struct LeafElt<K, V>{\n+    key: K,\n+    value: V\n+}\n+\n+//Has a left child\n+struct BranchElt<K, V>{\n+    left: Node<K, V>,\n+    key: K,\n+    value: V\n+}\n+\n+impl<K: Clone + TotalOrd, V> LeafElt<K, V>{\n+    fn new(k: K, v: V) -> LeafElt<K, V>{\n+        LeafElt{\n+            key: k,\n+\t    value: v\n+\t}\n+    }\n+\n+    fn less_than(&self, other: LeafElt<K, V>) -> bool{\n+        let order = self.key.cmp(&other.key);\n+\tmatch order{\n+\t    Less => true,\n+\t    _ => false\n+\t}\n+    }\n+\n+    fn greater_than(&self, other: LeafElt<K, V>) -> bool{\n+        let order = self.key.cmp(&other.key);\n+\tmatch order{\n+\t    Greater => true,\n+\t    _ => false\n+\t}\n+    }\n+\n+\n+    fn has_key(&self, other: K) -> bool{\n+        let order = self.key.cmp(&other);\n+\tmatch order{\n+\t    Equal => true,\n+\t    _ => false\n+\t}\n+    }\n+\n+}\n+\n+impl<K: Clone + TotalOrd, V: Clone> Clone for LeafElt<K, V>{\n+    fn clone(&self) -> LeafElt<K, V>{\n+        return LeafElt::new(self.key.clone(), self.value.clone());\n+    }\n+}\n+\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for LeafElt<K, V>{\n+    fn to_str(&self) -> ~str{\n+        return \"Key: \"+self.key.to_str()+\", value: \"+self.value.to_str()+\"; \";\n+    }\n+\n+}\n+\n+impl<K: Clone + TotalOrd, V: Clone> BranchElt<K, V>{\n+    fn new(k: K, v: V, n: Node<K, V>) -> BranchElt<K, V>{\n+        BranchElt{\n+            left: n,\n+            key: k,\n+            value: v\n+        }\n+    }\n+\n+    //Add method in progress.  Should it return a branch or a leaf elt?  It will depend on implementation.\n+    fn add(&self, k: K, v: V) -> LeafElt<K, V>{\n+        return LeafElt::new(k, v);\n+    }\n+}\n+\n+impl<K: Clone + TotalOrd, V: Clone> Clone for BranchElt<K, V>{\n+    fn clone(&self) -> BranchElt<K, V>{\n+        return BranchElt::new(self.key.clone(), self.value.clone(), self.left.clone());\n+    }\n+}\n+\n+#[test]\n+fn add_test(){\n+    let b = BTree::new(1, ~\"abc\", 2);\n+    let is_add = b.add(2, ~\"xyz\");\n+    assert!(is_add);\n+\n+}\n+\n+#[test]\n+fn get_test(){\n+    let b = BTree::new(1, ~\"abc\", 2);\n+    let val = b.get(1);\n+    assert_eq!(val, Some(~\"abc\"));\n+}\n+\n+//Testing LeafElt<K, V> functions (less_than, greater_than, and has_key)\n+#[test]\n+fn leaf_lt(){\n+    let l1 = LeafElt::new(1, ~\"abc\");\n+    let l2 = LeafElt::new(2, ~\"xyz\");\n+    assert!(l1.less_than(l2));\n+}\n+\n+#[test]\n+fn leaf_gt(){\n+    let l1 = LeafElt::new(1, ~\"abc\");\n+    let l2 = LeafElt::new(2, ~\"xyz\");\n+    assert!(l2.greater_than(l1));\n+}\n+\n+#[test]\n+fn leaf_hk(){\n+    let l1 = LeafElt::new(1, ~\"abc\");\n+    assert!(l1.has_key(1));\n+}\n+\n+fn main(){\n+\n+\n+}"}]}