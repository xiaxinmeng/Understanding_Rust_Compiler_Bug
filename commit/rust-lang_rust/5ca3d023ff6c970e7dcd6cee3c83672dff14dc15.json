{"sha": "5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYTNkMDIzZmY2Yzk3MGU3ZGNkNmNlZTNjODM2NzJkZmYxNGRjMTU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-03-30T19:36:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-30T19:36:28Z"}, "message": "Merge pull request #4100 from calebcartwright/rustfmt1x-rustc-v650\n\nbump rustfmt 1x to rustc-ap v651", "tree": {"sha": "2cc8d28e47d2d970c06829e3a5eb01ed48bde0ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cc8d28e47d2d970c06829e3a5eb01ed48bde0ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJegko8CRBK7hj4Ov3rIwAAdHIIACABMx+KicPGQueY16XWC2P5\nTvvL+tZL8WCiISA9K/tm1L+m8PMnYXM2NlfmcSz5MAJIA/N9bXfDQJoIS9AElLg6\nH7+1TbYEVK8rjEaVsqy3ac75duWYZszT/UWEEb3Sqfvl7jxG6Bt+kNLqjpV7/bEP\nXHvOmAep8L/RhN99u2o8i0R43JEDa7P6esbzvTx2NqdMHbf6+ZtBdOZtiUX9tOe6\nFL583ta1oBuj4ooKMqCYYq6RyobU0Pyh7kDwdeKSo/rmxrWVQeoMSQk1P2a+btGA\nkz8JaKjPDwE+qMZwOkwX+5OJlIl0G+lBD+9hFFOYy2Uv9UpGifT6/2ndWfNVl7w=\n=2lQH\n-----END PGP SIGNATURE-----\n", "payload": "tree 2cc8d28e47d2d970c06829e3a5eb01ed48bde0ea\nparent 9f53665f91be16c9aa7afd83f7c79357fec9152b\nparent 9714a140c99a8968b0becb5cf9227b1787768088\nauthor Manish Goregaokar <manishsmail@gmail.com> 1585596988 -0700\ncommitter GitHub <noreply@github.com> 1585596988 -0700\n\nMerge pull request #4100 from calebcartwright/rustfmt1x-rustc-v650\n\nbump rustfmt 1x to rustc-ap v651"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "html_url": "https://github.com/rust-lang/rust/commit/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f53665f91be16c9aa7afd83f7c79357fec9152b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f53665f91be16c9aa7afd83f7c79357fec9152b", "html_url": "https://github.com/rust-lang/rust/commit/9f53665f91be16c9aa7afd83f7c79357fec9152b"}, {"sha": "9714a140c99a8968b0becb5cf9227b1787768088", "url": "https://api.github.com/repos/rust-lang/rust/commits/9714a140c99a8968b0becb5cf9227b1787768088", "html_url": "https://github.com/rust-lang/rust/commit/9714a140c99a8968b0becb5cf9227b1787768088"}], "stats": {"total": 2572, "additions": 1455, "deletions": 1117}, "files": [{"sha": "d8b087503d8a393d2e95a899eb98f0c23bb2db06", "filename": "Cargo.lock", "status": "modified", "additions": 175, "deletions": 112, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -494,6 +494,15 @@ dependencies = [\n  \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"lock_api 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot_core 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"parking_lot_core\"\n version = \"0.6.2\"\n@@ -508,6 +517,19 @@ dependencies = [\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"redox_syscall 0.1.56 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"proc-macro-error\"\n version = \"0.2.6\"\n@@ -617,64 +639,97 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-arena\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-ap-rustc_data_structures 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smallvec 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-graphviz\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"rustc-ap-rustc_ast\"\n+version = \"651.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_index 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_lexer 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_macros 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_span 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rustc-ap-rustc_ast_passes\"\n+version = \"651.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_ast 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_ast_pretty 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_attr 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_errors 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_feature 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_parse 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_session 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_span 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustc-ap-rustc_ast_pretty\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_span 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_ast 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_span 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_attr\"\n-version = \"642.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"rustc-ap-rustc_ast_pretty 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_errors 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_feature 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_macros 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_session 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_span 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+version = \"651.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rustc-ap-rustc_ast 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_ast_pretty 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_errors 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_feature 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_macros 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_session 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_span 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smallvec 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-utils 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"indexmap 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"measureme 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-graphviz 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_index 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-graphviz 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_index 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-rayon 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-rayon-core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -685,59 +740,79 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"annotate-snippets 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"atty 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_span 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_span 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"termcolor 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"termize 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rustc-ap-rustc_expand\"\n+version = \"651.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_ast 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_ast_passes 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_ast_pretty 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_attr 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_errors 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_feature 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_lexer 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_parse 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_session 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_span 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustc-ap-rustc_feature\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_span 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_span 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_fs_util\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"rustc-ap-rustc_index\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-ap-serialize 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smallvec 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -746,97 +821,80 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_parse\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_ast_pretty 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_attr 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_errors 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_feature 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_lexer 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_session 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_span 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_ast 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_ast_pretty 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_errors 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_feature 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_lexer 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_session 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_span 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smallvec 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-normalization 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_session\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_errors 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_feature 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_fs_util 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_index 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_span 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_target 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_ast 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_errors 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_feature 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_fs_util 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_index 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_span 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_target 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_span\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-arena 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_index 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_macros 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-arena 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_index 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_macros 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_index 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_macros 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_span 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_index 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_macros 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_span 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-serialize\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"indexmap 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smallvec 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"rustc-ap-syntax\"\n-version = \"642.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_index 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_lexer 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_macros 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_span 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"rustc-demangle\"\n version = \"0.1.16\"\n@@ -912,14 +970,15 @@ dependencies = [\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_ast_pretty 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_errors 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_parse 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_session 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_span 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_target 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_ast 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_ast_pretty 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_errors 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_expand 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_parse 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_session 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_span 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_target 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-workspace-hack 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustfmt-config_proc_macro 0.2.0\",\n  \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1261,8 +1320,10 @@ dependencies = [\n \"checksum nodrop 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"72ef4a56884ca558e5ddb05a1d1e7e1bfd9a68d9ed024c21704cc98872dae1bb\"\n \"checksum num_cpus 1.10.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bcef43580c035376c0705c42792c294b66974abbfd2789b511784023f71f3273\"\n \"checksum packed_simd 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a85ea9fc0d4ac0deb6fe7911d38786b32fc11119afd9e9d38b84ff691ce64220\"\n+\"checksum parking_lot 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"92e98c49ab0b7ce5b222f2cc9193fc4efe11c6d0bd4f648e374684a6857b1cfc\"\n \"checksum parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f842b1982eb6c2fe34036a4fbfb06dd185a3f5c8edfaacdf7d1ea10b07de6252\"\n \"checksum parking_lot_core 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b876b1b9e7ac6e1a74a6da34d25c42e17e8862aa409cbbbdcfc8d86c6f3bc62b\"\n+\"checksum parking_lot_core 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7582838484df45743c8434fbff785e8edf260c28748353d44bc0da32e0ceabf1\"\n \"checksum proc-macro-error 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aeccfe4d5d8ea175d5f0e4a2ad0637e0f4121d63bd99d356fb1f39ab2e7c6097\"\n \"checksum proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9c9e470a8dc4aeae2dee2f335e8f533e2d4b347e1434e5671afc49b054592f27\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n@@ -1276,23 +1337,25 @@ dependencies = [\n \"checksum regex 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dc220bd33bdce8f093101afe22a037b8eb0e5af33592e6a9caafff0d4cb81cbd\"\n \"checksum regex-syntax 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11a7e20d1cce64ef2fed88b66d347f88bd9babb82845b2b858f3edbf59a4f716\"\n \"checksum rust-argon2 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4ca4eaef519b494d1f2848fc602d18816fed808a981aedf4f1f00ceb7c9d32cf\"\n-\"checksum rustc-ap-arena 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea82fa3d9a8add7422228ca1a2cbba0784fa8861f56148ff64da08b3c7921b03\"\n-\"checksum rustc-ap-graphviz 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"638d0b2b3bcf99824e0cb5a25dbc547b61dc20942e11daf6a97e981918aa18e5\"\n-\"checksum rustc-ap-rustc_ast_pretty 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d38bab04dd676dee6d2f9670506a18c31bfce38bf7f8420aa83eb1140ecde049\"\n-\"checksum rustc-ap-rustc_attr 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"10b843ba8b1ed43739133047673b9f6a54d3b3b4d328d69c6ea89ff971395f35\"\n-\"checksum rustc-ap-rustc_data_structures 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dc3d1c6d0a80ab0c1df76405377cec0f3d5423fb5b0953a8eac70a2ad6c44df2\"\n-\"checksum rustc-ap-rustc_errors 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4909a1eca29331332257230f29120a8ff68c9e37d868c564fcd599e430cf8914\"\n-\"checksum rustc-ap-rustc_feature 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"63ab887a181d795cf5fd3edadf367760deafb90aefb844f168ab5255266e3478\"\n-\"checksum rustc-ap-rustc_fs_util 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"70814116df3c5fbec8f06f6a1d013ca481f620fd22a9475754e9bf3ee9ba70d8\"\n-\"checksum rustc-ap-rustc_index 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ac1bf1d3cf3d119d41353d6fd229ef7272d5097bc0924de021c0294bf86d48bf\"\n-\"checksum rustc-ap-rustc_lexer 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4cda21a32cebdc11ec4f5393aa2fcde5ed1b2f673a8571e5a4dcdf07e4ae9cac\"\n-\"checksum rustc-ap-rustc_macros 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"75c47b48ea51910ecfd853c9248a9bf4c767bc823449ab6a1d864dff65fbae16\"\n-\"checksum rustc-ap-rustc_parse 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"abd88e89cd5b5d28dcd3a347a3d534c08627d9455570dc1a2d402cb8437b9d30\"\n-\"checksum rustc-ap-rustc_session 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5b8487b4575fbb2d1fc6f1cd61225efd108a4d36817e6fb9b643d57fcae9cb12\"\n-\"checksum rustc-ap-rustc_span 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f69746c0d4c21bf20a5bb2bd247261a1aa8631f04202d7303352942dde70d987\"\n-\"checksum rustc-ap-rustc_target 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8bbc6ae09b5d42ec66edd520e8412e0615c53a7c93607fe33dc4abab60ba7c8b\"\n-\"checksum rustc-ap-serialize 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e13a1ead0252fc3d96da4c336a95950be6795f2b00c84a67ccadf26142f8cb41\"\n-\"checksum rustc-ap-syntax 642.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1f59f48ca3a2ec16a7e82e718ed5aadf9c9e08cf63015d28b4e774767524a6a\"\n+\"checksum rustc-ap-arena 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"632704fb93ca8148957191e5d2d827082f93c4aa20cdd242fb46d8cca57029da\"\n+\"checksum rustc-ap-graphviz 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bdd4689b814859c9f1b3e314ed2bde596acac428a256a16894635f600bed46b4\"\n+\"checksum rustc-ap-rustc_ast 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"101c1517d3fd19d083aaca5b113f9965e6ae353a0bb09c49959b0f62b95b75d9\"\n+\"checksum rustc-ap-rustc_ast_passes 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ab3f5a7e939b37c99d8ca371f09b10bb5b5c85ad5d5b8d1d736ce8248c71be0\"\n+\"checksum rustc-ap-rustc_ast_pretty 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"05046d3a2b8de22b20bcda9a1c063dc5c1f2f721f042b6c2809df2d23c64a13e\"\n+\"checksum rustc-ap-rustc_attr 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f00b7ccad6fc3628fb44950435772945a425575f9ea0b3708c536fe75623a6e8\"\n+\"checksum rustc-ap-rustc_data_structures 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c6121ab6766644fa76b711f65d4c39f2e335488ab768324567fed0ed191166e\"\n+\"checksum rustc-ap-rustc_errors 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"adab84c842003ad1c8435fd71b8d0cc19bf0d702a8a2147d5be06e083db2d207\"\n+\"checksum rustc-ap-rustc_expand 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb001df541ea02b65c8e294252530010c6f90e3c6a5716e8e24e58c12dd1cd86\"\n+\"checksum rustc-ap-rustc_feature 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"446cc60613cc3b05d0bdbcab7feb02305790b5617fa43c532d51ae3223d677a4\"\n+\"checksum rustc-ap-rustc_fs_util 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9ac99d6f67e7db3bb300895630e769ed41bd3e336c0e725870c70e676c1a5ff1\"\n+\"checksum rustc-ap-rustc_index 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5608c1cf50d2251b7e10a138cf6dd388e97f139b21c00b06a22d06f89c6591f6\"\n+\"checksum rustc-ap-rustc_lexer 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"74e9c1c6f5dc85977b3adb6fb556b2ff23354d1a12021da15eb1d36353458bde\"\n+\"checksum rustc-ap-rustc_macros 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3226b5ec864312a5d23eb40a5d621ee06bdc0754228d20d6eb76d4ddc4f2d4a1\"\n+\"checksum rustc-ap-rustc_parse 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ba3b042344c2280b50d5df0058d11379028a8f016a407e575bb3ea8b6c798049\"\n+\"checksum rustc-ap-rustc_session 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff35ef4b5d9fbcb2fd539c7c908eb3cdd1f68ddbccd042945ef50ae65564f941\"\n+\"checksum rustc-ap-rustc_span 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e323b1f4a824039886eed8e33cad20ea4f492a9f9b3c9441009797c91de3e87a\"\n+\"checksum rustc-ap-rustc_target 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e161eb7b3a5b7993c6b480135296dc61476db80041d49dd446422742426e390b\"\n+\"checksum rustc-ap-serialize 651.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"af510a659098d8c45a7303fb882fa780f4a87ec5f5d7a2053521e7d5d7f332c4\"\n \"checksum rustc-demangle 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c691c0e608126e00913e33f0ccf3727d5fc84573623b8d65b2df340b5201783\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc-rayon 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f32767f90d938f1b7199a174ef249ae1924f6e5bbdb9d112fea141e016f25b3a\""}, {"sha": "de934e60b8fe91257746d8b7b327182ccf48df5e", "filename": "Cargo.toml", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -56,43 +56,45 @@ ignore = \"0.4.11\"\n annotate-snippets = { version = \"0.6\", features = [\"ansi_term\"] }\n structopt = \"0.3\"\n rustfmt-config_proc_macro = { version = \"0.2\", path = \"config_proc_macro\" }\n+lazy_static = \"1.0.0\"\n \n # A noop dependency that changes in the Rust repository, it's a bit of a hack.\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n # for more information.\n rustc-workspace-hack = \"1.0.0\"\n \n+[dependencies.rustc_ast]\n+package = \"rustc-ap-rustc_ast\"\n+version = \"651.0.0\"\n+\n [dependencies.rustc_ast_pretty]\n package = \"rustc-ap-rustc_ast_pretty\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n \n [dependencies.rustc_data_structures]\n package = \"rustc-ap-rustc_data_structures\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n \n [dependencies.rustc_errors]\n package = \"rustc-ap-rustc_errors\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n+\n+[dependencies.rustc_expand]\n+package = \"rustc-ap-rustc_expand\"\n+version = \"651.0.0\"\n \n [dependencies.rustc_parse]\n package = \"rustc-ap-rustc_parse\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n \n [dependencies.rustc_session]\n package = \"rustc-ap-rustc_session\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n \n [dependencies.rustc_span]\n package = \"rustc-ap-rustc_span\"\n-version = \"642.0.0\"\n+version = \"651.0.0\"\n \n [dependencies.rustc_target]\n package = \"rustc-ap-rustc_target\"\n-version = \"642.0.0\"\n-\n-[dependencies.syntax]\n-package = \"rustc-ap-syntax\"\n-version = \"642.0.0\"\n-\n-[dev-dependencies]\n-lazy_static = \"1.0.0\"\n+version = \"651.0.0\""}, {"sha": "b9e160020fb94167cc3ac0de2d21dec47ad32c0f", "filename": "src/attr.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattr.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -1,7 +1,8 @@\n //! Format attributes and meta items.\n \n+use rustc_ast::ast;\n+use rustc_ast::attr::HasAttrs;\n use rustc_span::{symbol::sym, BytePos, Span, DUMMY_SP};\n-use syntax::ast;\n \n use self::doc_comment::DocCommentFormatter;\n use crate::comment::{contains_comment, rewrite_doc_comment, CommentStyle};\n@@ -19,23 +20,19 @@ mod doc_comment;\n \n /// Returns attributes on the given statement.\n pub(crate) fn get_attrs_from_stmt(stmt: &ast::Stmt) -> &[ast::Attribute] {\n-    match stmt.kind {\n-        ast::StmtKind::Local(ref local) => &local.attrs,\n-        ast::StmtKind::Item(ref item) => &item.attrs,\n-        ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => &expr.attrs,\n-        ast::StmtKind::Mac(ref mac) => &mac.2,\n-    }\n+    stmt.attrs()\n }\n \n pub(crate) fn get_span_without_attrs(stmt: &ast::Stmt) -> Span {\n     match stmt.kind {\n         ast::StmtKind::Local(ref local) => local.span,\n         ast::StmtKind::Item(ref item) => item.span,\n         ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => expr.span,\n-        ast::StmtKind::Mac(ref mac) => {\n+        ast::StmtKind::MacCall(ref mac) => {\n             let (ref mac, _, _) = **mac;\n             mac.span()\n         }\n+        ast::StmtKind::Empty => stmt.span,\n     }\n }\n "}, {"sha": "40e4d483993c606cea4fa809a0ac79b1b7764c64", "filename": "src/chains.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -58,8 +58,8 @@\n use std::borrow::Cow;\n use std::cmp::min;\n \n+use rustc_ast::{ast, ptr};\n use rustc_span::{BytePos, Span};\n-use syntax::{ast, ptr};\n \n use crate::comment::{rewrite_comment, CharClasses, FullCodeCharKind, RichChar};\n use crate::config::IndentStyle;\n@@ -148,7 +148,15 @@ impl ChainItemKind {\n             ast::ExprKind::MethodCall(ref segment, ref expressions) => {\n                 let types = if let Some(ref generic_args) = segment.args {\n                     if let ast::GenericArgs::AngleBracketed(ref data) = **generic_args {\n-                        data.args.clone()\n+                        data.args\n+                            .iter()\n+                            .filter_map(|x| match x {\n+                                ast::AngleBracketedArg::Arg(ref generic_arg) => {\n+                                    Some(generic_arg.clone())\n+                                }\n+                                _ => None,\n+                            })\n+                            .collect::<Vec<_>>()\n                     } else {\n                         vec![]\n                     }\n@@ -403,7 +411,7 @@ impl Chain {\n \n     fn convert_try(expr: &ast::Expr, context: &RewriteContext<'_>) -> ast::Expr {\n         match expr.kind {\n-            ast::ExprKind::Mac(ref mac) if context.config.use_try_shorthand() => {\n+            ast::ExprKind::MacCall(ref mac) if context.config.use_try_shorthand() => {\n                 if let Some(subexpr) = convert_try_mac(mac, context) {\n                     subexpr\n                 } else {"}, {"sha": "82c49d806b59299b03ecbe718513c27db9c130fe", "filename": "src/closures.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -1,5 +1,5 @@\n+use rustc_ast::{ast, ptr};\n use rustc_span::Span;\n-use syntax::{ast, ptr};\n \n use crate::attr::get_attrs_from_stmt;\n use crate::config::lists::*;\n@@ -25,7 +25,7 @@ use crate::utils::{last_line_width, left_most_sub_expr, stmt_expr, NodeIdExt};\n \n pub(crate) fn rewrite_closure(\n     capture: ast::CaptureBy,\n-    is_async: &ast::IsAsync,\n+    is_async: &ast::Async,\n     movability: ast::Movability,\n     fn_decl: &ast::FnDecl,\n     body: &ast::Expr,\n@@ -43,14 +43,14 @@ pub(crate) fn rewrite_closure(\n \n     if let ast::ExprKind::Block(ref block, _) = body.kind {\n         // The body of the closure is an empty block.\n-        if block.stmts.is_empty() && !block_contains_comment(block, context.source_map) {\n+        if block.stmts.is_empty() && !block_contains_comment(context, block) {\n             return body\n                 .rewrite(context, shape)\n                 .map(|s| format!(\"{} {}\", prefix, s));\n         }\n \n         let result = match fn_decl.output {\n-            ast::FunctionRetTy::Default(_) if !context.inside_macro() => {\n+            ast::FnRetTy::Default(_) if !context.inside_macro() => {\n                 try_rewrite_without_block(body, &prefix, context, shape, body_shape)\n             }\n             _ => None,\n@@ -112,7 +112,7 @@ fn needs_block(block: &ast::Block, prefix: &str, context: &RewriteContext<'_>) -\n     is_unsafe_block(block)\n         || block.stmts.len() > 1\n         || has_attributes\n-        || block_contains_comment(block, context.source_map)\n+        || block_contains_comment(context, block)\n         || prefix.contains('\\n')\n }\n \n@@ -214,7 +214,7 @@ fn rewrite_closure_block(\n // Return type is (prefix, extra_offset)\n fn rewrite_closure_fn_decl(\n     capture: ast::CaptureBy,\n-    asyncness: &ast::IsAsync,\n+    asyncness: &ast::Async,\n     movability: ast::Movability,\n     fn_decl: &ast::FnDecl,\n     body: &ast::Expr,\n@@ -305,7 +305,7 @@ pub(crate) fn rewrite_last_closure(\n             ast::ExprKind::Block(ref block, _)\n                 if !is_unsafe_block(block)\n                     && !context.inside_macro()\n-                    && is_simple_block(block, Some(&body.attrs), context.source_map) =>\n+                    && is_simple_block(context, block, Some(&body.attrs)) =>\n             {\n                 stmt_expr(&block.stmts[0]).unwrap_or(body)\n             }"}, {"sha": "518f2bcda0c38dbd3db5a83a9a552e3173b0709a", "filename": "src/comment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -1556,10 +1556,10 @@ pub(crate) fn recover_comment_removed(\n         // We missed some comments. Warn and keep the original text.\n         if context.config.error_on_unformatted() {\n             context.report.append(\n-                context.source_map.span_to_filename(span).into(),\n+                context.parse_sess.span_to_filename(span),\n                 vec![FormattingError::from_span(\n                     span,\n-                    &context.source_map,\n+                    &context.parse_sess,\n                     ErrorKind::LostComment,\n                 )],\n             );"}, {"sha": "8545b0f6f29c1ab9ac7b8df217772ccc419d55de", "filename": "src/expr.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -2,9 +2,9 @@ use std::borrow::Cow;\n use std::cmp::min;\n \n use itertools::Itertools;\n-use rustc_span::{source_map::SourceMap, BytePos, Span};\n-use syntax::token::{DelimToken, LitKind};\n-use syntax::{ast, ptr};\n+use rustc_ast::token::{DelimToken, LitKind};\n+use rustc_ast::{ast, ptr};\n+use rustc_span::{BytePos, Span};\n \n use crate::chains::rewrite_chain;\n use crate::closures;\n@@ -199,7 +199,7 @@ pub(crate) fn format_expr(\n         ast::ExprKind::Try(..) | ast::ExprKind::Field(..) | ast::ExprKind::MethodCall(..) => {\n             rewrite_chain(expr, context, shape)\n         }\n-        ast::ExprKind::Mac(ref mac) => {\n+        ast::ExprKind::MacCall(ref mac) => {\n             rewrite_macro(mac, None, context, shape, MacroPosition::Expression).or_else(|| {\n                 wrap_str(\n                     context.snippet(expr.span).to_owned(),\n@@ -322,7 +322,7 @@ pub(crate) fn format_expr(\n         }\n         // We do not format these expressions yet, but they should still\n         // satisfy our width restrictions.\n-        ast::ExprKind::InlineAsm(..) => Some(context.snippet(expr.span).to_owned()),\n+        ast::ExprKind::LlvmInlineAsm(..) => Some(context.snippet(expr.span).to_owned()),\n         ast::ExprKind::TryBlock(ref block) => {\n             if let rw @ Some(_) =\n                 rewrite_single_line_block(context, \"try \", block, Some(&expr.attrs), None, shape)\n@@ -430,7 +430,7 @@ fn rewrite_empty_block(\n         return None;\n     }\n \n-    if !block_contains_comment(block, context.source_map) && shape.width >= 2 {\n+    if !block_contains_comment(context, block) && shape.width >= 2 {\n         return Some(format!(\"{}{}{{}}\", prefix, label_str));\n     }\n \n@@ -487,7 +487,7 @@ fn rewrite_single_line_block(\n     label: Option<ast::Label>,\n     shape: Shape,\n ) -> Option<String> {\n-    if is_simple_block(block, attrs, context.source_map) {\n+    if is_simple_block(context, block, attrs) {\n         let expr_shape = shape.offset_left(last_line_width(prefix))?;\n         let expr_str = block.stmts[0].rewrite(context, expr_shape)?;\n         let label_str = rewrite_label(label);\n@@ -750,8 +750,8 @@ impl<'a> ControlFlow<'a> {\n         let fixed_cost = self.keyword.len() + \"  {  } else {  }\".len();\n \n         if let ast::ExprKind::Block(ref else_node, _) = else_block.kind {\n-            if !is_simple_block(self.block, None, context.source_map)\n-                || !is_simple_block(else_node, None, context.source_map)\n+            if !is_simple_block(context, self.block, None)\n+                || !is_simple_block(context, else_node, None)\n                 || pat_expr_str.contains('\\n')\n             {\n                 return None;\n@@ -1134,47 +1134,46 @@ fn extract_comment(span: Span, context: &RewriteContext<'_>, shape: Shape) -> Op\n     }\n }\n \n-pub(crate) fn block_contains_comment(block: &ast::Block, source_map: &SourceMap) -> bool {\n-    let snippet = source_map.span_to_snippet(block.span).unwrap();\n-    contains_comment(&snippet)\n+pub(crate) fn block_contains_comment(context: &RewriteContext<'_>, block: &ast::Block) -> bool {\n+    contains_comment(context.snippet(block.span))\n }\n \n // Checks that a block contains no statements, an expression and no comments or\n // attributes.\n // FIXME: incorrectly returns false when comment is contained completely within\n // the expression.\n pub(crate) fn is_simple_block(\n+    context: &RewriteContext<'_>,\n     block: &ast::Block,\n     attrs: Option<&[ast::Attribute]>,\n-    source_map: &SourceMap,\n ) -> bool {\n     block.stmts.len() == 1\n         && stmt_is_expr(&block.stmts[0])\n-        && !block_contains_comment(block, source_map)\n+        && !block_contains_comment(context, block)\n         && attrs.map_or(true, |a| a.is_empty())\n }\n \n /// Checks whether a block contains at most one statement or expression, and no\n /// comments or attributes.\n pub(crate) fn is_simple_block_stmt(\n+    context: &RewriteContext<'_>,\n     block: &ast::Block,\n     attrs: Option<&[ast::Attribute]>,\n-    source_map: &SourceMap,\n ) -> bool {\n     block.stmts.len() <= 1\n-        && !block_contains_comment(block, source_map)\n+        && !block_contains_comment(context, block)\n         && attrs.map_or(true, |a| a.is_empty())\n }\n \n /// Checks whether a block contains no statements, expressions, comments, or\n /// inner attributes.\n pub(crate) fn is_empty_block(\n+    context: &RewriteContext<'_>,\n     block: &ast::Block,\n     attrs: Option<&[ast::Attribute]>,\n-    source_map: &SourceMap,\n ) -> bool {\n     block.stmts.is_empty()\n-        && !block_contains_comment(block, source_map)\n+        && !block_contains_comment(context, block)\n         && attrs.map_or(true, |a| inner_attributes(a).is_empty())\n }\n \n@@ -1313,9 +1312,9 @@ pub(crate) fn can_be_overflowed_expr(\n             context.config.overflow_delimited_expr()\n                 || (context.use_block_indent() && args_len == 1)\n         }\n-        ast::ExprKind::Mac(ref mac) => {\n+        ast::ExprKind::MacCall(ref mac) => {\n             match (\n-                syntax::ast::MacDelimiter::from_token(mac.args.delim()),\n+                rustc_ast::ast::MacDelimiter::from_token(mac.args.delim()),\n                 context.config.overflow_delimited_expr(),\n             ) {\n                 (Some(ast::MacDelimiter::Bracket), true)\n@@ -1341,7 +1340,7 @@ pub(crate) fn can_be_overflowed_expr(\n \n pub(crate) fn is_nested_call(expr: &ast::Expr) -> bool {\n     match expr.kind {\n-        ast::ExprKind::Call(..) | ast::ExprKind::Mac(..) => true,\n+        ast::ExprKind::Call(..) | ast::ExprKind::MacCall(..) => true,\n         ast::ExprKind::AddrOf(_, _, ref expr)\n         | ast::ExprKind::Box(ref expr)\n         | ast::ExprKind::Try(ref expr)"}, {"sha": "8178342f28cd93f8324e3e0cbafaa3e730f36962", "filename": "src/formatting.rs", "status": "modified", "additions": 43, "deletions": 422, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -1,29 +1,20 @@\n // High level formatting functions.\n \n-use std::cell::RefCell;\n use std::collections::HashMap;\n use std::io::{self, Write};\n-use std::panic::{catch_unwind, AssertUnwindSafe};\n-use std::rc::Rc;\n use std::time::{Duration, Instant};\n \n-use rustc_data_structures::sync::{Lrc, Send};\n-use rustc_errors::emitter::{Emitter, EmitterWriter};\n-use rustc_errors::{ColorConfig, Diagnostic, DiagnosticBuilder, Handler, Level as DiagnosticLevel};\n-use rustc_session::parse::ParseSess;\n-use rustc_span::{\n-    source_map::{FilePathMapping, SourceMap},\n-    Span, DUMMY_SP,\n-};\n-use syntax::ast;\n+use rustc_ast::ast;\n+use rustc_span::Span;\n \n use self::newline_style::apply_newline_style;\n use crate::comment::{CharClasses, FullCodeCharKind};\n use crate::config::{Config, FileName, Verbosity};\n-use crate::ignore_path::IgnorePathSet;\n use crate::issues::BadIssueSeeker;\n+use crate::syntux::parser::{DirectoryOwnership, Parser, ParserError};\n+use crate::syntux::session::ParseSess;\n use crate::utils::count_newlines;\n-use crate::visitor::{FmtVisitor, SnippetProvider};\n+use crate::visitor::FmtVisitor;\n use crate::{modules, source_file, ErrorKind, FormatReport, Input, Session};\n \n mod newline_style;\n@@ -38,7 +29,7 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n             return Err(ErrorKind::VersionMismatch);\n         }\n \n-        syntax::with_globals(self.config.edition().to_libsyntax_pos_edition(), || {\n+        rustc_ast::with_globals(self.config.edition().to_libsyntax_pos_edition(), || {\n             if self.config.disable_all_formatting() {\n                 // When the input is from stdin, echo back the input.\n                 if let Input::Text(ref buf) = input {\n@@ -71,54 +62,42 @@ fn format_project<T: FormatHandler>(\n     let main_file = input.file_name();\n     let input_is_stdin = main_file == FileName::Stdin;\n \n-    let ignore_path_set = match IgnorePathSet::from_ignore_list(&config.ignore()) {\n-        Ok(set) => Rc::new(set),\n-        Err(e) => return Err(ErrorKind::InvalidGlobPattern(e)),\n-    };\n-    if config.skip_children() && ignore_path_set.is_match(&main_file) {\n+    let mut parse_session = ParseSess::new(config)?;\n+    if config.skip_children() && parse_session.ignore_file(&main_file) {\n         return Ok(FormatReport::new());\n     }\n \n     // Parse the crate.\n-    let can_reset_parser_errors = Rc::new(RefCell::new(false));\n-    let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n-    let mut parse_session = make_parse_sess(\n-        source_map.clone(),\n-        config,\n-        Rc::clone(&ignore_path_set),\n-        can_reset_parser_errors.clone(),\n-    );\n     let mut report = FormatReport::new();\n     let directory_ownership = input.to_directory_ownership();\n-    let krate = match parse_crate(\n-        input,\n-        &parse_session,\n-        config,\n-        &mut report,\n-        directory_ownership,\n-        can_reset_parser_errors.clone(),\n-    ) {\n+    let krate = match Parser::parse_crate(config, input, directory_ownership, &parse_session) {\n         Ok(krate) => krate,\n         // Surface parse error via Session (errors are merged there from report)\n-        Err(ErrorKind::ParseError) => return Ok(report),\n-        Err(e) => return Err(e),\n+        Err(e) => {\n+            let forbid_verbose = input_is_stdin || e != ParserError::ParsePanicError;\n+            should_emit_verbose(forbid_verbose, config, || {\n+                eprintln!(\"The Rust parser panicked\");\n+            });\n+            report.add_parsing_error();\n+            return Ok(report);\n+        }\n     };\n     timer = timer.done_parsing();\n \n     // Suppress error output if we have to do any further parsing.\n-    let silent_emitter = silent_emitter();\n-    parse_session.span_diagnostic = Handler::with_emitter(true, None, silent_emitter);\n+    parse_session.set_silent_emitter();\n \n     let mut context = FormatContext::new(&krate, report, parse_session, config, handler);\n     let files = modules::ModResolver::new(\n         &context.parse_session,\n-        directory_ownership.unwrap_or(rustc_parse::DirectoryOwnership::UnownedViaMod),\n-        !(input_is_stdin || config.skip_children()),\n+        directory_ownership.unwrap_or(DirectoryOwnership::UnownedViaMod),\n+        !input_is_stdin && !config.skip_children(),\n     )\n     .visit_crate(&krate)\n     .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n+\n     for (path, module) in files {\n-        let should_ignore = !input_is_stdin && ignore_path_set.is_match(&path);\n+        let should_ignore = !input_is_stdin && context.ignore_file(&path);\n         if (config.skip_children() && path != main_file) || should_ignore {\n             continue;\n         }\n@@ -150,22 +129,19 @@ struct FormatContext<'a, T: FormatHandler> {\n }\n \n impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n+    fn ignore_file(&self, path: &FileName) -> bool {\n+        self.parse_session.ignore_file(path)\n+    }\n+\n     // Formats a single file/module.\n     fn format_file(\n         &mut self,\n         path: FileName,\n         module: &ast::Mod,\n         is_root: bool,\n     ) -> Result<(), ErrorKind> {\n-        let source_file = self\n-            .parse_session\n-            .source_map()\n-            .lookup_char_pos(module.inner.lo())\n-            .file;\n-        let big_snippet = source_file.src.as_ref().unwrap();\n-        let snippet_provider =\n-            SnippetProvider::new(source_file.start_pos, source_file.end_pos, big_snippet);\n-        let mut visitor = FmtVisitor::from_source_map(\n+        let snippet_provider = self.parse_session.snippet_provider(module.inner);\n+        let mut visitor = FmtVisitor::from_parse_sess(\n             &self.parse_session,\n             &self.config,\n             &snippet_provider,\n@@ -175,16 +151,16 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n \n         // Format inner attributes if available.\n         if !self.krate.attrs.is_empty() && is_root {\n-            visitor.skip_empty_lines(source_file.end_pos);\n+            visitor.skip_empty_lines(snippet_provider.end_pos());\n             if visitor.visit_attrs(&self.krate.attrs, ast::AttrStyle::Inner) {\n                 visitor.push_rewrite(module.inner, None);\n             } else {\n-                visitor.format_separate_mod(module, &*source_file);\n+                visitor.format_separate_mod(module, snippet_provider.end_pos());\n             }\n         } else {\n-            visitor.last_pos = source_file.start_pos;\n-            visitor.skip_empty_lines(source_file.end_pos);\n-            visitor.format_separate_mod(module, &*source_file);\n+            visitor.last_pos = snippet_provider.start_pos();\n+            visitor.skip_empty_lines(snippet_provider.end_pos());\n+            visitor.format_separate_mod(module, snippet_provider.end_pos());\n         };\n \n         debug_assert_eq!(\n@@ -209,7 +185,7 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n         apply_newline_style(\n             self.config.newline_style(),\n             &mut visitor.buffer,\n-            &big_snippet,\n+            snippet_provider.entire_snippet(),\n         );\n \n         if visitor.macro_rewrite_failure {\n@@ -219,7 +195,7 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n             .add_non_formatted_ranges(visitor.skipped_range.borrow().clone());\n \n         self.handler.handle_formatted_file(\n-            self.parse_session.source_map(),\n+            &self.parse_session,\n             path,\n             visitor.buffer.to_owned(),\n             &mut self.report,\n@@ -231,7 +207,7 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n trait FormatHandler {\n     fn handle_formatted_file(\n         &mut self,\n-        source_map: &SourceMap,\n+        parse_session: &ParseSess,\n         path: FileName,\n         result: String,\n         report: &mut FormatReport,\n@@ -242,14 +218,14 @@ impl<'b, T: Write + 'b> FormatHandler for Session<'b, T> {\n     // Called for each formatted file.\n     fn handle_formatted_file(\n         &mut self,\n-        source_map: &SourceMap,\n+        parse_session: &ParseSess,\n         path: FileName,\n         result: String,\n         report: &mut FormatReport,\n     ) -> Result<(), ErrorKind> {\n         if let Some(ref mut out) = self.out {\n             match source_file::write_file(\n-                Some(source_map),\n+                Some(parse_session),\n                 &path,\n                 &result,\n                 out,\n@@ -282,23 +258,15 @@ pub(crate) struct FormattingError {\n impl FormattingError {\n     pub(crate) fn from_span(\n         span: Span,\n-        source_map: &SourceMap,\n+        parse_sess: &ParseSess,\n         kind: ErrorKind,\n     ) -> FormattingError {\n         FormattingError {\n-            line: source_map.lookup_char_pos(span.lo()).line,\n+            line: parse_sess.line_of_byte_pos(span.lo()),\n             is_comment: kind.is_comment(),\n             kind,\n             is_string: false,\n-            line_buffer: source_map\n-                .span_to_lines(span)\n-                .ok()\n-                .and_then(|fl| {\n-                    fl.file\n-                        .get_line(fl.lines[0].line_index)\n-                        .map(std::borrow::Cow::into_owned)\n-                })\n-                .unwrap_or_else(String::new),\n+            line_buffer: parse_sess.span_to_first_line_string(span),\n         }\n     }\n \n@@ -633,358 +601,11 @@ impl<'a> FormatLines<'a> {\n     }\n }\n \n-fn parse_crate(\n-    input: Input,\n-    parse_session: &ParseSess,\n-    config: &Config,\n-    report: &mut FormatReport,\n-    directory_ownership: Option<rustc_parse::DirectoryOwnership>,\n-    can_reset_parser_errors: Rc<RefCell<bool>>,\n-) -> Result<ast::Crate, ErrorKind> {\n-    let input_is_stdin = input.is_text();\n-\n-    let parser = match input {\n-        Input::File(ref file) => {\n-            // Use `new_sub_parser_from_file` when we the input is a submodule.\n-            Ok(if let Some(dir_own) = directory_ownership {\n-                rustc_parse::new_sub_parser_from_file(parse_session, file, dir_own, None, DUMMY_SP)\n-            } else {\n-                rustc_parse::new_parser_from_file(parse_session, file)\n-            })\n-        }\n-        Input::Text(text) => rustc_parse::maybe_new_parser_from_source_str(\n-            parse_session,\n-            rustc_span::FileName::Custom(\"stdin\".to_owned()),\n-            text,\n-        )\n-        .map(|mut parser| {\n-            parser.recurse_into_file_modules = false;\n-            parser\n-        }),\n-    };\n-\n-    let result = match parser {\n-        Ok(mut parser) => {\n-            parser.cfg_mods = false;\n-            if config.skip_children() {\n-                parser.recurse_into_file_modules = false;\n-            }\n-\n-            let mut parser = AssertUnwindSafe(parser);\n-            catch_unwind(move || parser.0.parse_crate_mod().map_err(|d| vec![d]))\n-        }\n-        Err(diagnostics) => {\n-            for diagnostic in diagnostics {\n-                parse_session.span_diagnostic.emit_diagnostic(&diagnostic);\n-            }\n-            report.add_parsing_error();\n-            return Err(ErrorKind::ParseError);\n-        }\n-    };\n-\n-    match result {\n-        Ok(Ok(c)) => {\n-            if !parse_session.span_diagnostic.has_errors() {\n-                return Ok(c);\n-            }\n-            // This scenario occurs when the parser encountered errors\n-            // but was still able to recover. If all of the parser errors\n-            // occurred in files that are ignored, then reset\n-            // the error count and continue.\n-            // https://github.com/rust-lang/rustfmt/issues/3779\n-            if *can_reset_parser_errors.borrow() {\n-                parse_session.span_diagnostic.reset_err_count();\n-                return Ok(c);\n-            }\n-        }\n-        Ok(Err(mut diagnostics)) => diagnostics.iter_mut().for_each(DiagnosticBuilder::emit),\n-        Err(_) => {\n-            // Note that if you see this message and want more information,\n-            // then run the `parse_crate_mod` function above without\n-            // `catch_unwind` so rustfmt panics and you can get a backtrace.\n-            should_emit_verbose(input_is_stdin, config, || {\n-                println!(\"The Rust parser panicked\")\n-            });\n-        }\n-    }\n-\n-    report.add_parsing_error();\n-    Err(ErrorKind::ParseError)\n-}\n-\n-struct SilentOnIgnoredFilesEmitter {\n-    ignore_path_set: Rc<IgnorePathSet>,\n-    source_map: Rc<SourceMap>,\n-    emitter: Box<dyn Emitter + Send>,\n-    has_non_ignorable_parser_errors: bool,\n-    can_reset: Rc<RefCell<bool>>,\n-}\n-\n-impl SilentOnIgnoredFilesEmitter {\n-    fn handle_non_ignoreable_error(&mut self, db: &Diagnostic) {\n-        self.has_non_ignorable_parser_errors = true;\n-        *self.can_reset.borrow_mut() = false;\n-        self.emitter.emit_diagnostic(db);\n-    }\n-}\n-\n-impl Emitter for SilentOnIgnoredFilesEmitter {\n-    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n-        None\n-    }\n-\n-    fn emit_diagnostic(&mut self, db: &Diagnostic) {\n-        if db.level == DiagnosticLevel::Fatal {\n-            return self.handle_non_ignoreable_error(db);\n-        }\n-        if let Some(primary_span) = &db.span.primary_span() {\n-            let file_name = self.source_map.span_to_filename(*primary_span);\n-            if let rustc_span::FileName::Real(ref path) = file_name {\n-                if self\n-                    .ignore_path_set\n-                    .is_match(&FileName::Real(path.to_path_buf()))\n-                {\n-                    if !self.has_non_ignorable_parser_errors {\n-                        *self.can_reset.borrow_mut() = true;\n-                    }\n-                    return;\n-                }\n-            };\n-        }\n-        self.handle_non_ignoreable_error(db);\n-    }\n-}\n-\n-/// Emitter which discards every error.\n-struct SilentEmitter;\n-\n-impl Emitter for SilentEmitter {\n-    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n-        None\n-    }\n-    fn emit_diagnostic(&mut self, _db: &Diagnostic) {}\n-}\n-\n-fn silent_emitter() -> Box<dyn Emitter + Send> {\n-    Box::new(SilentEmitter {})\n-}\n-\n-fn make_parse_sess(\n-    source_map: Rc<SourceMap>,\n-    config: &Config,\n-    ignore_path_set: Rc<IgnorePathSet>,\n-    can_reset: Rc<RefCell<bool>>,\n-) -> ParseSess {\n-    let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n-    let color_cfg = if supports_color {\n-        ColorConfig::Auto\n-    } else {\n-        ColorConfig::Never\n-    };\n-\n-    let emitter = if config.hide_parse_errors() {\n-        silent_emitter()\n-    } else {\n-        Box::new(EmitterWriter::stderr(\n-            color_cfg,\n-            Some(source_map.clone()),\n-            false,\n-            false,\n-            None,\n-            false,\n-        ))\n-    };\n-    let handler = Handler::with_emitter(\n-        true,\n-        None,\n-        Box::new(SilentOnIgnoredFilesEmitter {\n-            has_non_ignorable_parser_errors: false,\n-            source_map: source_map.clone(),\n-            emitter,\n-            ignore_path_set,\n-            can_reset,\n-        }),\n-    );\n-\n-    ParseSess::with_span_handler(handler, source_map)\n-}\n-\n-fn should_emit_verbose<F>(is_stdin: bool, config: &Config, f: F)\n+fn should_emit_verbose<F>(forbid_verbose_output: bool, config: &Config, f: F)\n where\n     F: Fn(),\n {\n-    if config.verbose() == Verbosity::Verbose && !is_stdin {\n+    if config.verbose() == Verbosity::Verbose && !forbid_verbose_output {\n         f();\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    mod emitter {\n-        use super::*;\n-        use crate::config::IgnoreList;\n-        use crate::is_nightly_channel;\n-        use crate::utils::mk_sp;\n-        use rustc_span::{BytePos, FileName as SourceMapFileName, MultiSpan, DUMMY_SP};\n-        use std::path::{Path, PathBuf};\n-\n-        struct TestEmitter {\n-            num_emitted_errors: Rc<RefCell<u32>>,\n-        }\n-\n-        impl Emitter for TestEmitter {\n-            fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n-                None\n-            }\n-            fn emit_diagnostic(&mut self, _db: &Diagnostic) {\n-                *self.num_emitted_errors.borrow_mut() += 1;\n-            }\n-        }\n-\n-        fn build_diagnostic(level: DiagnosticLevel, span: Option<MultiSpan>) -> Diagnostic {\n-            Diagnostic {\n-                level,\n-                code: None,\n-                message: vec![],\n-                children: vec![],\n-                suggestions: vec![],\n-                span: span.unwrap_or_else(MultiSpan::new),\n-                sort_span: DUMMY_SP,\n-            }\n-        }\n-\n-        fn build_emitter(\n-            num_emitted_errors: Rc<RefCell<u32>>,\n-            can_reset: Rc<RefCell<bool>>,\n-            source_map: Option<Rc<SourceMap>>,\n-            ignore_list: Option<IgnoreList>,\n-        ) -> SilentOnIgnoredFilesEmitter {\n-            let emitter_writer = TestEmitter { num_emitted_errors };\n-            let source_map =\n-                source_map.unwrap_or_else(|| Rc::new(SourceMap::new(FilePathMapping::empty())));\n-            let ignore_path_set =\n-                Rc::new(IgnorePathSet::from_ignore_list(&ignore_list.unwrap_or_default()).unwrap());\n-            SilentOnIgnoredFilesEmitter {\n-                has_non_ignorable_parser_errors: false,\n-                source_map,\n-                emitter: Box::new(emitter_writer),\n-                ignore_path_set,\n-                can_reset,\n-            }\n-        }\n-\n-        fn get_ignore_list(config: &str) -> IgnoreList {\n-            Config::from_toml(config, Path::new(\"\")).unwrap().ignore()\n-        }\n-\n-        #[test]\n-        fn handles_fatal_parse_error_in_ignored_file() {\n-            let num_emitted_errors = Rc::new(RefCell::new(0));\n-            let can_reset_errors = Rc::new(RefCell::new(false));\n-            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n-            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n-            let source =\n-                String::from(r#\"extern \"system\" fn jni_symbol!( funcName ) ( ... ) -> {} \"#);\n-            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n-            let mut emitter = build_emitter(\n-                Rc::clone(&num_emitted_errors),\n-                Rc::clone(&can_reset_errors),\n-                Some(Rc::clone(&source_map)),\n-                Some(ignore_list),\n-            );\n-            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n-            let fatal_diagnostic = build_diagnostic(DiagnosticLevel::Fatal, Some(span));\n-            emitter.emit_diagnostic(&fatal_diagnostic);\n-            assert_eq!(*num_emitted_errors.borrow(), 1);\n-            assert_eq!(*can_reset_errors.borrow(), false);\n-        }\n-\n-        #[test]\n-        fn handles_recoverable_parse_error_in_ignored_file() {\n-            if !is_nightly_channel!() {\n-                return;\n-            }\n-            let num_emitted_errors = Rc::new(RefCell::new(0));\n-            let can_reset_errors = Rc::new(RefCell::new(false));\n-            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n-            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n-            let source = String::from(r#\"pub fn bar() { 1x; }\"#);\n-            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n-            let mut emitter = build_emitter(\n-                Rc::clone(&num_emitted_errors),\n-                Rc::clone(&can_reset_errors),\n-                Some(Rc::clone(&source_map)),\n-                Some(ignore_list),\n-            );\n-            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n-            let non_fatal_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(span));\n-            emitter.emit_diagnostic(&non_fatal_diagnostic);\n-            assert_eq!(*num_emitted_errors.borrow(), 0);\n-            assert_eq!(*can_reset_errors.borrow(), true);\n-        }\n-\n-        #[test]\n-        fn handles_recoverable_parse_error_in_non_ignored_file() {\n-            if !is_nightly_channel!() {\n-                return;\n-            }\n-            let num_emitted_errors = Rc::new(RefCell::new(0));\n-            let can_reset_errors = Rc::new(RefCell::new(false));\n-            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n-            let source = String::from(r#\"pub fn bar() { 1x; }\"#);\n-            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n-            let mut emitter = build_emitter(\n-                Rc::clone(&num_emitted_errors),\n-                Rc::clone(&can_reset_errors),\n-                Some(Rc::clone(&source_map)),\n-                None,\n-            );\n-            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n-            let non_fatal_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(span));\n-            emitter.emit_diagnostic(&non_fatal_diagnostic);\n-            assert_eq!(*num_emitted_errors.borrow(), 1);\n-            assert_eq!(*can_reset_errors.borrow(), false);\n-        }\n-\n-        #[test]\n-        fn handles_mix_of_recoverable_parse_error() {\n-            if !is_nightly_channel!() {\n-                return;\n-            }\n-            let num_emitted_errors = Rc::new(RefCell::new(0));\n-            let can_reset_errors = Rc::new(RefCell::new(false));\n-            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n-            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n-            let bar_source = String::from(r#\"pub fn bar() { 1x; }\"#);\n-            let foo_source = String::from(r#\"pub fn foo() { 1x; }\"#);\n-            let fatal_source =\n-                String::from(r#\"extern \"system\" fn jni_symbol!( funcName ) ( ... ) -> {} \"#);\n-            source_map\n-                .new_source_file(SourceMapFileName::Real(PathBuf::from(\"bar.rs\")), bar_source);\n-            source_map\n-                .new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), foo_source);\n-            source_map.new_source_file(\n-                SourceMapFileName::Real(PathBuf::from(\"fatal.rs\")),\n-                fatal_source,\n-            );\n-            let mut emitter = build_emitter(\n-                Rc::clone(&num_emitted_errors),\n-                Rc::clone(&can_reset_errors),\n-                Some(Rc::clone(&source_map)),\n-                Some(ignore_list),\n-            );\n-            let bar_span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n-            let foo_span = MultiSpan::from_span(mk_sp(BytePos(21), BytePos(22)));\n-            let bar_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(bar_span));\n-            let foo_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(foo_span));\n-            let fatal_diagnostic = build_diagnostic(DiagnosticLevel::Fatal, None);\n-            emitter.emit_diagnostic(&bar_diagnostic);\n-            emitter.emit_diagnostic(&foo_diagnostic);\n-            emitter.emit_diagnostic(&fatal_diagnostic);\n-            assert_eq!(*num_emitted_errors.borrow(), 2);\n-            assert_eq!(*can_reset_errors.borrow(), false);\n-        }\n-    }\n-}"}, {"sha": "d8f963e1ec3f131d550bfd13abef89632c1552cb", "filename": "src/imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -2,8 +2,8 @@ use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::fmt;\n \n+use rustc_ast::ast::{self, UseTreeKind};\n use rustc_span::{source_map, symbol::sym, BytePos, Span, DUMMY_SP};\n-use syntax::ast::{self, UseTreeKind};\n \n use crate::comment::combine_strs_with_missing_comments;\n use crate::config::lists::*;"}, {"sha": "baa993590cad3558429e5a4bbf00a8d34dc5d8f0", "filename": "src/items.rs", "status": "modified", "additions": 68, "deletions": 57, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -4,9 +4,9 @@ use std::borrow::Cow;\n use std::cmp::{max, min, Ordering};\n \n use regex::Regex;\n+use rustc_ast::visit;\n+use rustc_ast::{ast, ptr};\n use rustc_span::{source_map, symbol, BytePos, Span, DUMMY_SP};\n-use syntax::visit;\n-use syntax::{ast, ptr};\n \n use crate::attr::filter_inline_attrs;\n use crate::comment::{\n@@ -165,10 +165,10 @@ pub(crate) struct FnSig<'a> {\n     decl: &'a ast::FnDecl,\n     generics: &'a ast::Generics,\n     ext: ast::Extern,\n-    is_async: Cow<'a, ast::IsAsync>,\n-    constness: ast::Constness,\n+    is_async: Cow<'a, ast::Async>,\n+    constness: ast::Const,\n     defaultness: ast::Defaultness,\n-    unsafety: ast::Unsafety,\n+    unsafety: ast::Unsafe,\n     visibility: ast::Visibility,\n }\n \n@@ -182,10 +182,10 @@ impl<'a> FnSig<'a> {\n             decl,\n             generics,\n             ext: ast::Extern::None,\n-            is_async: Cow::Owned(ast::IsAsync::NotAsync),\n-            constness: ast::Constness::NotConst,\n+            is_async: Cow::Owned(ast::Async::No),\n+            constness: ast::Const::No,\n             defaultness: ast::Defaultness::Final,\n-            unsafety: ast::Unsafety::Normal,\n+            unsafety: ast::Unsafe::No,\n             visibility: vis,\n         }\n     }\n@@ -196,8 +196,8 @@ impl<'a> FnSig<'a> {\n     ) -> FnSig<'a> {\n         FnSig {\n             unsafety: method_sig.header.unsafety,\n-            is_async: Cow::Borrowed(&method_sig.header.asyncness.node),\n-            constness: method_sig.header.constness.node,\n+            is_async: Cow::Borrowed(&method_sig.header.asyncness),\n+            constness: method_sig.header.constness,\n             defaultness: ast::Defaultness::Final,\n             ext: method_sig.header.ext,\n             decl: &*method_sig.decl,\n@@ -224,8 +224,8 @@ impl<'a> FnSig<'a> {\n                     decl,\n                     generics,\n                     ext: fn_sig.header.ext,\n-                    constness: fn_sig.header.constness.node,\n-                    is_async: Cow::Borrowed(&fn_sig.header.asyncness.node),\n+                    constness: fn_sig.header.constness,\n+                    is_async: Cow::Borrowed(&fn_sig.header.asyncness),\n                     defaultness,\n                     unsafety: fn_sig.header.unsafety,\n                     visibility: vis.clone(),\n@@ -298,8 +298,14 @@ impl<'a> FmtVisitor<'a> {\n \n     fn format_foreign_item(&mut self, item: &ast::ForeignItem) {\n         let rewrite = item.rewrite(&self.get_context(), self.shape());\n-        self.push_rewrite(item.span(), rewrite);\n-        self.last_pos = item.span.hi();\n+        let hi = item.span.hi();\n+        let span = if item.attrs.is_empty() {\n+            item.span\n+        } else {\n+            mk_sp(item.attrs[0].span.lo(), hi)\n+        };\n+        self.push_rewrite(span, rewrite);\n+        self.last_pos = hi;\n     }\n \n     pub(crate) fn rewrite_fn_before_block(\n@@ -363,17 +369,17 @@ impl<'a> FmtVisitor<'a> {\n             return None;\n         }\n \n-        let source_map = self.get_context().source_map;\n+        let context = self.get_context();\n \n         if self.config.empty_item_single_line()\n-            && is_empty_block(block, None, source_map)\n+            && is_empty_block(&context, block, None)\n             && self.block_indent.width() + fn_str.len() + 3 <= self.config.max_width()\n             && !last_line_contains_single_line_comment(fn_str)\n         {\n             return Some(format!(\"{} {{}}\", fn_str));\n         }\n \n-        if !self.config.fn_single_line() || !is_simple_block_stmt(block, None, source_map) {\n+        if !self.config.fn_single_line() || !is_simple_block_stmt(&context, block, None) {\n             return None;\n         }\n \n@@ -588,7 +594,7 @@ impl<'a> FmtVisitor<'a> {\n                 self.buffer.clear();\n             }\n \n-            fn is_type(ty: &Option<syntax::ptr::P<ast::Ty>>) -> bool {\n+            fn is_type(ty: &Option<rustc_ast::ptr::P<ast::Ty>>) -> bool {\n                 match ty {\n                     None => true,\n                     Some(lty) => match lty.kind.opaque_top_hack() {\n@@ -598,7 +604,7 @@ impl<'a> FmtVisitor<'a> {\n                 }\n             }\n \n-            fn is_opaque(ty: &Option<syntax::ptr::P<ast::Ty>>) -> bool {\n+            fn is_opaque(ty: &Option<rustc_ast::ptr::P<ast::Ty>>) -> bool {\n                 match ty {\n                     None => false,\n                     Some(lty) => match lty.kind.opaque_top_hack() {\n@@ -609,15 +615,15 @@ impl<'a> FmtVisitor<'a> {\n             }\n \n             fn both_type(\n-                a: &Option<syntax::ptr::P<ast::Ty>>,\n-                b: &Option<syntax::ptr::P<ast::Ty>>,\n+                a: &Option<rustc_ast::ptr::P<ast::Ty>>,\n+                b: &Option<rustc_ast::ptr::P<ast::Ty>>,\n             ) -> bool {\n                 is_type(a) && is_type(b)\n             }\n \n             fn both_opaque(\n-                a: &Option<syntax::ptr::P<ast::Ty>>,\n-                b: &Option<syntax::ptr::P<ast::Ty>>,\n+                a: &Option<rustc_ast::ptr::P<ast::Ty>>,\n+                b: &Option<rustc_ast::ptr::P<ast::Ty>>,\n             ) -> bool {\n                 is_opaque(a) && is_opaque(b)\n             }\n@@ -629,7 +635,7 @@ impl<'a> FmtVisitor<'a> {\n             use crate::ast::AssocItemKind::*;\n             fn need_empty_line(a: &ast::AssocItemKind, b: &ast::AssocItemKind) -> bool {\n                 match (a, b) {\n-                    (TyAlias(_, ref lty), TyAlias(_, ref rty))\n+                    (TyAlias(_, _, _, ref lty), TyAlias(_, _, _, ref rty))\n                         if both_type(lty, rty) || both_opaque(lty, rty) =>\n                     {\n                         false\n@@ -640,23 +646,23 @@ impl<'a> FmtVisitor<'a> {\n             }\n \n             buffer.sort_by(|(_, a), (_, b)| match (&a.kind, &b.kind) {\n-                (TyAlias(_, ref lty), TyAlias(_, ref rty))\n+                (TyAlias(_, _, _, ref lty), TyAlias(_, _, _, ref rty))\n                     if both_type(lty, rty) || both_opaque(lty, rty) =>\n                 {\n                     a.ident.as_str().cmp(&b.ident.as_str())\n                 }\n-                (Const(..), Const(..)) | (Macro(..), Macro(..)) => {\n+                (Const(..), Const(..)) | (MacCall(..), MacCall(..)) => {\n                     a.ident.as_str().cmp(&b.ident.as_str())\n                 }\n                 (Fn(..), Fn(..)) => a.span.lo().cmp(&b.span.lo()),\n-                (TyAlias(_, ref ty), _) if is_type(ty) => Ordering::Less,\n-                (_, TyAlias(_, ref ty)) if is_type(ty) => Ordering::Greater,\n+                (TyAlias(_, _, _, ref ty), _) if is_type(ty) => Ordering::Less,\n+                (_, TyAlias(_, _, _, ref ty)) if is_type(ty) => Ordering::Greater,\n                 (TyAlias(..), _) => Ordering::Less,\n                 (_, TyAlias(..)) => Ordering::Greater,\n                 (Const(..), _) => Ordering::Less,\n                 (_, Const(..)) => Ordering::Greater,\n-                (Macro(..), _) => Ordering::Less,\n-                (_, Macro(..)) => Ordering::Greater,\n+                (MacCall(..), _) => Ordering::Less,\n+                (_, MacCall(..)) => Ordering::Greater,\n             });\n             let mut prev_kind = None;\n             for (buf, item) in buffer {\n@@ -868,10 +874,9 @@ fn format_impl_ref_and_type(\n         let generics_str = rewrite_generics(context, \"impl\", generics, shape)?;\n         result.push_str(&generics_str);\n \n-        let polarity_str = if polarity == ast::ImplPolarity::Negative {\n-            \"!\"\n-        } else {\n-            \"\"\n+        let polarity_str = match polarity {\n+            ast::ImplPolarity::Negative(_) => \"!\",\n+            ast::ImplPolarity::Positive => \"\",\n         };\n \n         if let Some(ref trait_ref) = *trait_ref {\n@@ -1714,9 +1719,13 @@ pub(crate) struct StaticParts<'a> {\n \n impl<'a> StaticParts<'a> {\n     pub(crate) fn from_item(item: &'a ast::Item) -> Self {\n-        let (prefix, ty, mutability, expr) = match item.kind {\n-            ast::ItemKind::Static(ref ty, mutability, ref expr) => (\"static\", ty, mutability, expr),\n-            ast::ItemKind::Const(ref ty, ref expr) => (\"const\", ty, ast::Mutability::Not, expr),\n+        let (defaultness, prefix, ty, mutability, expr) = match item.kind {\n+            ast::ItemKind::Static(ref ty, mutability, ref expr) => {\n+                (None, \"static\", ty, mutability, expr)\n+            }\n+            ast::ItemKind::Const(defaultness, ref ty, ref expr) => {\n+                (Some(defaultness), \"const\", ty, ast::Mutability::Not, expr)\n+            }\n             _ => unreachable!(),\n         };\n         StaticParts {\n@@ -1725,15 +1734,17 @@ impl<'a> StaticParts<'a> {\n             ident: item.ident,\n             ty,\n             mutability,\n-            expr_opt: Some(expr),\n-            defaultness: None,\n+            expr_opt: expr.as_ref(),\n+            defaultness,\n             span: item.span,\n         }\n     }\n \n     pub(crate) fn from_trait_item(ti: &'a ast::AssocItem) -> Self {\n-        let (ty, expr_opt) = match ti.kind {\n-            ast::AssocItemKind::Const(ref ty, ref expr_opt) => (ty, expr_opt),\n+        let (defaultness, ty, expr_opt) = match ti.kind {\n+            ast::AssocItemKind::Const(defaultness, ref ty, ref expr_opt) => {\n+                (defaultness, ty, expr_opt)\n+            }\n             _ => unreachable!(),\n         };\n         StaticParts {\n@@ -1743,14 +1754,14 @@ impl<'a> StaticParts<'a> {\n             ty,\n             mutability: ast::Mutability::Not,\n             expr_opt: expr_opt.as_ref(),\n-            defaultness: None,\n+            defaultness: Some(defaultness),\n             span: ti.span,\n         }\n     }\n \n     pub(crate) fn from_impl_item(ii: &'a ast::AssocItem) -> Self {\n-        let (ty, expr) = match ii.kind {\n-            ast::AssocItemKind::Const(ref ty, ref expr) => (ty, expr),\n+        let (defaultness, ty, expr) = match ii.kind {\n+            ast::AssocItemKind::Const(defaultness, ref ty, ref expr) => (defaultness, ty, expr),\n             _ => unreachable!(),\n         };\n         StaticParts {\n@@ -1760,7 +1771,7 @@ impl<'a> StaticParts<'a> {\n             ty,\n             mutability: ast::Mutability::Not,\n             expr_opt: expr.as_ref(),\n-            defaultness: Some(ii.defaultness),\n+            defaultness: Some(defaultness),\n             span: ii.span,\n         }\n     }\n@@ -1903,16 +1914,16 @@ pub(crate) fn rewrite_associated_impl_type(\n     let result = rewrite_associated_type(ident, ty_opt, generics, None, context, indent)?;\n \n     match defaultness {\n-        ast::Defaultness::Default => Some(format!(\"default {}\", result)),\n+        ast::Defaultness::Default(..) => Some(format!(\"default {}\", result)),\n         _ => Some(result),\n     }\n }\n \n-impl Rewrite for ast::FunctionRetTy {\n+impl Rewrite for ast::FnRetTy {\n     fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match *self {\n-            ast::FunctionRetTy::Default(_) => Some(String::new()),\n-            ast::FunctionRetTy::Ty(ref ty) => {\n+            ast::FnRetTy::Default(_) => Some(String::new()),\n+            ast::FnRetTy::Ty(ref ty) => {\n                 if context.config.version() == Version::One\n                     || context.config.indent_style() == IndentStyle::Visual\n                 {\n@@ -2290,7 +2301,7 @@ fn rewrite_fn_base(\n     }\n \n     // Return type.\n-    if let ast::FunctionRetTy::Ty(..) = fd.output {\n+    if let ast::FnRetTy::Ty(..) = fd.output {\n         let ret_should_indent = match context.config.indent_style() {\n             // If our params are block layout then we surely must have space.\n             IndentStyle::Block if put_params_in_block || fd.inputs.is_empty() => false,\n@@ -2396,8 +2407,8 @@ fn rewrite_fn_base(\n     }\n \n     let pos_before_where = match fd.output {\n-        ast::FunctionRetTy::Default(..) => params_span.hi(),\n-        ast::FunctionRetTy::Ty(ref ty) => ty.span.hi(),\n+        ast::FnRetTy::Default(..) => params_span.hi(),\n+        ast::FnRetTy::Ty(ref ty) => ty.span.hi(),\n     };\n \n     let is_params_multi_lined = param_str.contains('\\n');\n@@ -2425,7 +2436,7 @@ fn rewrite_fn_base(\n     // If there are neither where-clause nor return type, we may be missing comments between\n     // params and `{`.\n     if where_clause_str.is_empty() {\n-        if let ast::FunctionRetTy::Default(ret_span) = fd.output {\n+        if let ast::FnRetTy::Default(ret_span) = fd.output {\n             match recover_missing_comment_in_span(\n                 mk_sp(params_span.hi(), ret_span.hi()),\n                 shape,\n@@ -3083,7 +3094,7 @@ impl Rewrite for ast::ForeignItem {\n         let span = mk_sp(self.span.lo(), self.span.hi() - BytePos(1));\n \n         let item_str = match self.kind {\n-            ast::ForeignItemKind::Fn(ref fn_sig, ref generics, _) => rewrite_fn_base(\n+            ast::ForeignItemKind::Fn(_, ref fn_sig, ref generics, _) => rewrite_fn_base(\n                 context,\n                 shape.indent,\n                 self.ident,\n@@ -3092,7 +3103,7 @@ impl Rewrite for ast::ForeignItem {\n                 FnBraceStyle::None,\n             )\n             .map(|(s, _)| format!(\"{};\", s)),\n-            ast::ForeignItemKind::Static(ref ty, mutability) => {\n+            ast::ForeignItemKind::Static(ref ty, mutability, _) => {\n                 // FIXME(#21): we're dropping potential comments in between the\n                 // function kw here.\n                 let vis = format_visibility(context, &self.vis);\n@@ -3106,15 +3117,15 @@ impl Rewrite for ast::ForeignItem {\n                 // 1 = ;\n                 rewrite_assign_rhs(context, prefix, &**ty, shape.sub_width(1)?).map(|s| s + \";\")\n             }\n-            ast::ForeignItemKind::Ty => {\n+            ast::ForeignItemKind::TyAlias(..) => {\n                 let vis = format_visibility(context, &self.vis);\n                 Some(format!(\n                     \"{}type {};\",\n                     vis,\n                     rewrite_ident(context, self.ident)\n                 ))\n             }\n-            ast::ForeignItemKind::Macro(ref mac) => {\n+            ast::ForeignItemKind::MacCall(ref mac) => {\n                 rewrite_macro(mac, None, context, shape, MacroPosition::Item)\n             }\n         }?;"}, {"sha": "ecf19ebb58604335d843df1b85af1b15f5bfcf51", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -3,7 +3,6 @@\n \n #[macro_use]\n extern crate derive_new;\n-#[cfg(test)]\n #[macro_use]\n extern crate lazy_static;\n #[macro_use]\n@@ -20,14 +19,14 @@ use std::rc::Rc;\n \n use failure::Fail;\n use ignore;\n-use rustc_parse::DirectoryOwnership;\n-use syntax::ast;\n+use rustc_ast::ast;\n \n use crate::comment::LineClasses;\n use crate::emitter::Emitter;\n use crate::formatting::{FormatErrorMap, FormattingError, ReportedErrors, SourceFile};\n use crate::issues::Issue;\n use crate::shape::Indent;\n+use crate::syntux::parser::DirectoryOwnership;\n use crate::utils::indent_next_line;\n \n pub use crate::config::{\n@@ -75,6 +74,7 @@ pub(crate) mod source_map;\n mod spanned;\n mod stmt;\n mod string;\n+mod syntux;\n #[cfg(test)]\n mod test;\n mod types;\n@@ -509,13 +509,6 @@ pub enum Input {\n }\n \n impl Input {\n-    fn is_text(&self) -> bool {\n-        match *self {\n-            Input::File(_) => false,\n-            Input::Text(_) => true,\n-        }\n-    }\n-\n     fn file_name(&self) -> FileName {\n         match *self {\n             Input::File(ref file) => FileName::Real(file.clone()),"}, {"sha": "bc55ef6686ac3ec45f50e13ea5ab0be341b0bb5c", "filename": "src/lists.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -560,7 +560,7 @@ pub(crate) struct ListItems<'a, I, F1, F2, F3>\n where\n     I: Iterator,\n {\n-    snippet_provider: &'a SnippetProvider<'a>,\n+    snippet_provider: &'a SnippetProvider,\n     inner: Peekable<I>,\n     get_lo: F1,\n     get_hi: F2,\n@@ -777,7 +777,7 @@ where\n #[allow(clippy::too_many_arguments)]\n // Creates an iterator over a list's items with associated comments.\n pub(crate) fn itemize_list<'a, T, I, F1, F2, F3>(\n-    snippet_provider: &'a SnippetProvider<'_>,\n+    snippet_provider: &'a SnippetProvider,\n     inner: I,\n     terminator: &'a str,\n     separator: &'a str,"}, {"sha": "400daa6a5aa65c71b9d3194a68ade8a1747397aa", "filename": "src/macros.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -12,12 +12,12 @@\n use std::collections::HashMap;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n+use rustc_ast::token::{BinOpToken, DelimToken, Token, TokenKind};\n+use rustc_ast::tokenstream::{Cursor, TokenStream, TokenTree};\n+use rustc_ast::{ast, ptr};\n use rustc_ast_pretty::pprust;\n use rustc_parse::{new_parser_from_tts, parser::Parser};\n use rustc_span::{symbol::kw, BytePos, Span, Symbol, DUMMY_SP};\n-use syntax::token::{BinOpToken, DelimToken, Token, TokenKind};\n-use syntax::tokenstream::{Cursor, TokenStream, TokenTree};\n-use syntax::{ast, ptr};\n \n use crate::comment::{\n     contains_comment, CharClasses, FindUncommented, FullCodeCharKind, LineClasses,\n@@ -178,16 +178,16 @@ fn return_macro_parse_failure_fallback(\n     }\n \n     context.skipped_range.borrow_mut().push((\n-        context.source_map.lookup_line(span.lo()).unwrap().line,\n-        context.source_map.lookup_line(span.hi()).unwrap().line,\n+        context.parse_sess.line_of_byte_pos(span.lo()),\n+        context.parse_sess.line_of_byte_pos(span.hi()),\n     ));\n \n     // Return the snippet unmodified if the macro is not block-like\n     Some(context.snippet(span).to_owned())\n }\n \n pub(crate) fn rewrite_macro(\n-    mac: &ast::Mac,\n+    mac: &ast::MacCall,\n     extra_ident: Option<ast::Ident>,\n     context: &RewriteContext<'_>,\n     shape: Shape,\n@@ -231,15 +231,15 @@ fn check_keyword<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n         {\n             parser.bump();\n             let macro_arg =\n-                MacroArg::Keyword(ast::Ident::with_dummy_span(keyword), parser.prev_span);\n+                MacroArg::Keyword(ast::Ident::with_dummy_span(keyword), parser.prev_token.span);\n             return Some(macro_arg);\n         }\n     }\n     None\n }\n \n fn rewrite_macro_inner(\n-    mac: &ast::Mac,\n+    mac: &ast::MacCall,\n     extra_ident: Option<ast::Ident>,\n     context: &RewriteContext<'_>,\n     shape: Shape,\n@@ -286,7 +286,7 @@ fn rewrite_macro_inner(\n         }\n     }\n \n-    let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());\n+    let mut parser = new_parser_from_tts(context.parse_sess.inner(), ts.trees().collect());\n     let mut arg_vec = Vec::new();\n     let mut vec_with_semi = false;\n     let mut trailing_comma = false;\n@@ -495,7 +495,7 @@ pub(crate) fn rewrite_macro_def(\n         None => return snippet,\n     };\n \n-    let mut result = if def.legacy {\n+    let mut result = if def.macro_rules {\n         String::from(\"macro_rules!\")\n     } else {\n         format!(\"{}macro\", format_visibility(context, vis))\n@@ -504,7 +504,7 @@ pub(crate) fn rewrite_macro_def(\n     result += \" \";\n     result += rewrite_ident(context, ident);\n \n-    let multi_branch_style = def.legacy || parsed_def.branches.len() != 1;\n+    let multi_branch_style = def.macro_rules || parsed_def.branches.len() != 1;\n \n     let arm_shape = if multi_branch_style {\n         shape\n@@ -537,7 +537,7 @@ pub(crate) fn rewrite_macro_def(\n     .collect::<Vec<_>>();\n \n     let fmt = ListFormatting::new(arm_shape, context.config)\n-        .separator(if def.legacy { \";\" } else { \"\" })\n+        .separator(if def.macro_rules { \";\" } else { \"\" })\n         .trailing_separator(SeparatorTactic::Always)\n         .preserve_newline(true);\n \n@@ -1186,11 +1186,14 @@ fn next_space(tok: &TokenKind) -> SpaceState {\n /// Tries to convert a macro use into a short hand try expression. Returns `None`\n /// when the macro is not an instance of `try!` (or parsing the inner expression\n /// failed).\n-pub(crate) fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext<'_>) -> Option<ast::Expr> {\n+pub(crate) fn convert_try_mac(\n+    mac: &ast::MacCall,\n+    context: &RewriteContext<'_>,\n+) -> Option<ast::Expr> {\n     let path = &pprust::path_to_string(&mac.path);\n     if path == \"try\" || path == \"r#try\" {\n         let ts = mac.args.inner_tokens();\n-        let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());\n+        let mut parser = new_parser_from_tts(context.parse_sess.inner(), ts.trees().collect());\n \n         Some(ast::Expr {\n             id: ast::NodeId::root(), // dummy value\n@@ -1203,7 +1206,7 @@ pub(crate) fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext<'_>) -> O\n     }\n }\n \n-pub(crate) fn macro_style(mac: &ast::Mac, context: &RewriteContext<'_>) -> DelimToken {\n+pub(crate) fn macro_style(mac: &ast::MacCall, context: &RewriteContext<'_>) -> DelimToken {\n     let snippet = context.snippet(mac.span());\n     let paren_pos = snippet.find_uncommented(\"(\").unwrap_or(usize::max_value());\n     let bracket_pos = snippet.find_uncommented(\"[\").unwrap_or(usize::max_value());\n@@ -1422,7 +1425,7 @@ fn format_lazy_static(\n     ts: &TokenStream,\n ) -> Option<String> {\n     let mut result = String::with_capacity(1024);\n-    let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());\n+    let mut parser = new_parser_from_tts(context.parse_sess.inner(), ts.trees().collect());\n     let nested_shape = shape\n         .block_indent(context.config.tab_spaces())\n         .with_max_width(context.config);"}, {"sha": "c6b1712232656a22744eb8d62cb1bbb05747f938", "filename": "src/matches.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -2,8 +2,8 @@\n \n use std::iter::repeat;\n \n+use rustc_ast::{ast, ptr};\n use rustc_span::{BytePos, Span};\n-use syntax::{ast, ptr};\n \n use crate::comment::{combine_strs_with_missing_comments, rewrite_comment};\n use crate::config::lists::*;\n@@ -276,7 +276,7 @@ fn block_can_be_flattened<'a>(\n         ast::ExprKind::Block(ref block, _)\n             if !is_unsafe_block(block)\n                 && !context.inside_macro()\n-                && is_simple_block(block, Some(&expr.attrs), context.source_map) =>\n+                && is_simple_block(context, block, Some(&expr.attrs)) =>\n         {\n             Some(&*block)\n         }\n@@ -332,10 +332,7 @@ fn rewrite_match_body(\n         shape.offset_left(extra_offset(pats_str, shape) + 4),\n     );\n     let (is_block, is_empty_block) = if let ast::ExprKind::Block(ref block, _) = body.kind {\n-        (\n-            true,\n-            is_empty_block(block, Some(&body.attrs), context.source_map),\n-        )\n+        (true, is_empty_block(context, block, Some(&body.attrs)))\n     } else {\n         (false, false)\n     };\n@@ -562,7 +559,7 @@ fn can_flatten_block_around_this(body: &ast::Expr) -> bool {\n         | ast::ExprKind::Array(..)\n         | ast::ExprKind::Call(..)\n         | ast::ExprKind::MethodCall(..)\n-        | ast::ExprKind::Mac(..)\n+        | ast::ExprKind::MacCall(..)\n         | ast::ExprKind::Struct(..)\n         | ast::ExprKind::Tup(..) => true,\n         ast::ExprKind::AddrOf(_, _, ref expr)"}, {"sha": "e6889ae97865b690a9174126a74ea05704657038", "filename": "src/missed_spans.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -86,9 +86,8 @@ impl<'a> FmtVisitor<'a> {\n \n         assert!(\n             start < end,\n-            \"Request to format inverted span: {:?} to {:?}\",\n-            self.source_map.lookup_char_pos(start),\n-            self.source_map.lookup_char_pos(end)\n+            \"Request to format inverted span: {}\",\n+            self.parse_sess.span_to_debug_info(mk_sp(start, end)),\n         );\n \n         self.last_pos = end;\n@@ -139,26 +138,22 @@ impl<'a> FmtVisitor<'a> {\n         // Get a snippet from the file start to the span's hi without allocating.\n         // We need it to determine what precedes the current comment. If the comment\n         // follows code on the same line, we won't touch it.\n-        let big_span_lo = self.source_map.lookup_char_pos(span.lo()).file.start_pos;\n-        let local_begin = self.source_map.lookup_byte_offset(big_span_lo);\n-        let local_end = self.source_map.lookup_byte_offset(span.hi());\n-        let start_index = local_begin.pos.to_usize();\n-        let end_index = local_end.pos.to_usize();\n-        let big_snippet = &local_begin.sf.src.as_ref().unwrap()[start_index..end_index];\n-\n+        let big_span_lo = self.snippet_provider.start_pos();\n+        let big_snippet = self.snippet_provider.entire_snippet();\n         let big_diff = (span.lo() - big_span_lo).to_usize();\n+\n         let snippet = self.snippet(span);\n \n         debug!(\"write_snippet `{}`\", snippet);\n \n-        self.write_snippet_inner(big_snippet, big_diff, snippet, span, process_last_snippet);\n+        self.write_snippet_inner(big_snippet, snippet, big_diff, span, process_last_snippet);\n     }\n \n     fn write_snippet_inner<F>(\n         &mut self,\n         big_snippet: &str,\n-        big_diff: usize,\n         old_snippet: &str,\n+        big_diff: usize,\n         span: Span,\n         process_last_snippet: F,\n     ) where\n@@ -167,9 +162,9 @@ impl<'a> FmtVisitor<'a> {\n         // Trim whitespace from the right hand side of each line.\n         // Annoyingly, the library functions for splitting by lines etc. are not\n         // quite right, so we must do it ourselves.\n-        let char_pos = self.source_map.lookup_char_pos(span.lo());\n-        let file_name = &char_pos.file.name.clone().into();\n-        let mut status = SnippetStatus::new(char_pos.line);\n+        let line = self.parse_sess.line_of_byte_pos(span.lo());\n+        let file_name = &self.parse_sess.span_to_filename(span);\n+        let mut status = SnippetStatus::new(line);\n \n         let snippet = &*transform_missing_snippet(self.config, old_snippet);\n "}, {"sha": "9f8dabbfaf4c03f2bfb739c8f9cfe476f0c75637", "filename": "src/modules.rs", "status": "modified", "additions": 107, "deletions": 179, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -2,24 +2,25 @@ use std::borrow::Cow;\n use std::collections::BTreeMap;\n use std::path::{Path, PathBuf};\n \n-use rustc_errors::PResult;\n-use rustc_parse::{new_sub_parser_from_file, parser, DirectoryOwnership};\n-use rustc_session::parse::ParseSess;\n+use rustc_ast::ast;\n+use rustc_ast::visit::Visitor;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{source_map, Span, DUMMY_SP};\n-use syntax::ast;\n-use syntax::token::TokenKind;\n-use syntax::visit::Visitor;\n \n use crate::attr::MetaVisitor;\n use crate::config::FileName;\n use crate::items::is_mod_decl;\n+use crate::syntux::parser::{Directory, DirectoryOwnership, ModulePathSuccess, Parser};\n+use crate::syntux::session::ParseSess;\n use crate::utils::contains_skip;\n \n mod visitor;\n \n type FileModMap<'ast> = BTreeMap<FileName, Cow<'ast, ast::Mod>>;\n \n+lazy_static! {\n+    static ref CFG_IF: Symbol = Symbol::intern(\"cfg_if\");\n+}\n+\n /// Maps each module to the corresponding file.\n pub(crate) struct ModResolver<'ast, 'sess> {\n     parse_sess: &'sess ParseSess,\n@@ -28,25 +29,10 @@ pub(crate) struct ModResolver<'ast, 'sess> {\n     recursive: bool,\n }\n \n-#[derive(Clone)]\n-struct Directory {\n-    path: PathBuf,\n-    ownership: DirectoryOwnership,\n-}\n-\n-impl<'a> Directory {\n-    fn to_syntax_directory(&'a self) -> rustc_parse::Directory<'a> {\n-        rustc_parse::Directory {\n-            path: Cow::Borrowed(&self.path),\n-            ownership: self.ownership.clone(),\n-        }\n-    }\n-}\n-\n #[derive(Clone)]\n enum SubModKind<'a, 'ast> {\n     /// `mod foo;`\n-    External(PathBuf, DirectoryOwnership),\n+    External(PathBuf, DirectoryOwnership, Cow<'ast, ast::Mod>),\n     /// `mod foo;` with multiple sources.\n     MultiExternal(Vec<(PathBuf, DirectoryOwnership, Cow<'ast, ast::Mod>)>),\n     /// `#[path = \"...\"] mod foo {}`\n@@ -78,12 +64,9 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         mut self,\n         krate: &'ast ast::Crate,\n     ) -> Result<FileModMap<'ast>, String> {\n-        let root_filename = self.parse_sess.source_map().span_to_filename(krate.span);\n+        let root_filename = self.parse_sess.span_to_filename(krate.span);\n         self.directory.path = match root_filename {\n-            source_map::FileName::Real(ref path) => path\n-                .parent()\n-                .expect(\"Parent directory should exists\")\n-                .to_path_buf(),\n+            FileName::Real(ref p) => p.parent().unwrap_or(Path::new(\"\")).to_path_buf(),\n             _ => PathBuf::new(),\n         };\n \n@@ -93,14 +76,13 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         }\n \n         self.file_map\n-            .insert(root_filename.into(), Cow::Borrowed(&krate.module));\n+            .insert(root_filename, Cow::Borrowed(&krate.module));\n         Ok(self.file_map)\n     }\n \n     /// Visit `cfg_if` macro and look for module declarations.\n     fn visit_cfg_if(&mut self, item: Cow<'ast, ast::Item>) -> Result<(), String> {\n-        let mut visitor =\n-            visitor::CfgIfVisitor::new(self.parse_sess, self.directory.to_syntax_directory());\n+        let mut visitor = visitor::CfgIfVisitor::new(self.parse_sess);\n         visitor.visit_item(&item);\n         for module_item in visitor.mods() {\n             if let ast::ItemKind::Mod(ref sub_mod) = module_item.item.kind {\n@@ -168,7 +150,6 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n             // mod foo;\n             // Look for an extern file.\n             self.find_external_module(item.ident, &item.attrs, sub_mod)\n-                .map(Some)\n         } else {\n             // An internal module (`mod foo { /* ... */ }`);\n             if let Some(path) = find_path_value(&item.attrs) {\n@@ -183,15 +164,19 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n     fn insert_sub_mod(\n         &mut self,\n         sub_mod_kind: SubModKind<'c, 'ast>,\n-        sub_mod: Cow<'ast, ast::Mod>,\n+        _sub_mod: Cow<'ast, ast::Mod>,\n     ) -> Result<(), String> {\n         match sub_mod_kind {\n-            SubModKind::External(mod_path, _) => {\n-                self.file_map.insert(FileName::Real(mod_path), sub_mod);\n+            SubModKind::External(mod_path, _, sub_mod) => {\n+                self.file_map\n+                    .entry(FileName::Real(mod_path))\n+                    .or_insert(sub_mod);\n             }\n             SubModKind::MultiExternal(mods) => {\n                 for (mod_path, _, sub_mod) in mods {\n-                    self.file_map.insert(FileName::Real(mod_path), sub_mod);\n+                    self.file_map\n+                        .entry(FileName::Real(mod_path))\n+                        .or_insert(sub_mod);\n                 }\n             }\n             _ => (),\n@@ -205,7 +190,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         sub_mod_kind: SubModKind<'c, 'ast>,\n     ) -> Result<(), String> {\n         match sub_mod_kind {\n-            SubModKind::External(mod_path, directory_ownership) => {\n+            SubModKind::External(mod_path, directory_ownership, sub_mod) => {\n                 let directory = Directory {\n                     path: mod_path.parent().unwrap().to_path_buf(),\n                     ownership: directory_ownership,\n@@ -257,48 +242,87 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         mod_name: ast::Ident,\n         attrs: &[ast::Attribute],\n         sub_mod: &Cow<'ast, ast::Mod>,\n-    ) -> Result<SubModKind<'c, 'ast>, String> {\n-        if let Some(path) = parser::Parser::submod_path_from_attr(attrs, &self.directory.path) {\n-            return Ok(SubModKind::External(\n-                path,\n-                DirectoryOwnership::Owned { relative: None },\n-            ));\n-        }\n-\n-        // Look for nested path, like `#[cfg_attr(feature = \"foo\", path = \"bar.rs\")]`.\n-        let mut mods_outside_ast = self\n-            .find_mods_ouside_of_ast(attrs, sub_mod)\n-            .unwrap_or(vec![]);\n-\n+    ) -> Result<Option<SubModKind<'c, 'ast>>, String> {\n         let relative = match self.directory.ownership {\n             DirectoryOwnership::Owned { relative } => relative,\n             DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod => None,\n         };\n-        match parser::Parser::default_submod_path(\n-            mod_name,\n-            relative,\n-            &self.directory.path,\n-            self.parse_sess.source_map(),\n-        )\n-        .result\n+        if let Some(path) = Parser::submod_path_from_attr(attrs, &self.directory.path) {\n+            if self.parse_sess.is_file_parsed(&path) {\n+                return Ok(None);\n+            }\n+            return match Parser::parse_file_as_module(self.parse_sess, &path, sub_mod.inner) {\n+                Some(m) => Ok(Some(SubModKind::External(\n+                    path,\n+                    DirectoryOwnership::Owned { relative: None },\n+                    Cow::Owned(m),\n+                ))),\n+                None => Err(format!(\n+                    \"Failed to find module {} in {:?} {:?}\",\n+                    mod_name, self.directory.path, relative,\n+                )),\n+            };\n+        }\n+\n+        // Look for nested path, like `#[cfg_attr(feature = \"foo\", path = \"bar.rs\")]`.\n+        let mut mods_outside_ast = self.find_mods_outside_of_ast(attrs, sub_mod);\n+\n+        match self\n+            .parse_sess\n+            .default_submod_path(mod_name, relative, &self.directory.path)\n+            .result\n         {\n-            Ok(parser::ModulePathSuccess {\n-                path,\n-                directory_ownership,\n-                ..\n-            }) => Ok(if mods_outside_ast.is_empty() {\n-                SubModKind::External(path, directory_ownership)\n-            } else {\n-                mods_outside_ast.push((path, directory_ownership, sub_mod.clone()));\n-                SubModKind::MultiExternal(mods_outside_ast)\n-            }),\n-            Err(_) if !mods_outside_ast.is_empty() => {\n-                Ok(SubModKind::MultiExternal(mods_outside_ast))\n+            Ok(ModulePathSuccess {\n+                path, ownership, ..\n+            }) => {\n+                let outside_mods_empty = mods_outside_ast.is_empty();\n+                let should_insert = !mods_outside_ast\n+                    .iter()\n+                    .any(|(outside_path, _, _)| outside_path == &path);\n+                if self.parse_sess.is_file_parsed(&path) {\n+                    if outside_mods_empty {\n+                        return Ok(None);\n+                    } else {\n+                        if should_insert {\n+                            mods_outside_ast.push((path, ownership, sub_mod.clone()));\n+                        }\n+                        return Ok(Some(SubModKind::MultiExternal(mods_outside_ast)));\n+                    }\n+                }\n+                match Parser::parse_file_as_module(self.parse_sess, &path, sub_mod.inner) {\n+                    Some(m) if outside_mods_empty => {\n+                        Ok(Some(SubModKind::External(path, ownership, Cow::Owned(m))))\n+                    }\n+                    Some(m) => {\n+                        mods_outside_ast.push((path.clone(), ownership, Cow::Owned(m)));\n+                        if should_insert {\n+                            mods_outside_ast.push((path, ownership, sub_mod.clone()));\n+                        }\n+                        Ok(Some(SubModKind::MultiExternal(mods_outside_ast)))\n+                    }\n+                    None if outside_mods_empty => Err(format!(\n+                        \"Failed to find module {} in {:?} {:?}\",\n+                        mod_name, self.directory.path, relative,\n+                    )),\n+                    None => {\n+                        if should_insert {\n+                            mods_outside_ast.push((path, ownership, sub_mod.clone()));\n+                        }\n+                        Ok(Some(SubModKind::MultiExternal(mods_outside_ast)))\n+                    }\n+                }\n+            }\n+            Err(mut e) if !mods_outside_ast.is_empty() => {\n+                e.cancel();\n+                Ok(Some(SubModKind::MultiExternal(mods_outside_ast)))\n+            }\n+            Err(mut e) => {\n+                e.cancel();\n+                Err(format!(\n+                    \"Failed to find module {} in {:?} {:?}\",\n+                    mod_name, self.directory.path, relative,\n+                ))\n             }\n-            Err(_) => Err(format!(\n-                \"Failed to find module {} in {:?} {:?}\",\n-                mod_name, self.directory.path, relative,\n-            )),\n         }\n     }\n \n@@ -323,21 +347,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         }\n     }\n \n-    fn find_mods_ouside_of_ast(\n-        &self,\n-        attrs: &[ast::Attribute],\n-        sub_mod: &Cow<'ast, ast::Mod>,\n-    ) -> Option<Vec<(PathBuf, DirectoryOwnership, Cow<'ast, ast::Mod>)>> {\n-        use std::panic::{catch_unwind, AssertUnwindSafe};\n-        Some(\n-            catch_unwind(AssertUnwindSafe(|| {\n-                self.find_mods_ouside_of_ast_inner(attrs, sub_mod)\n-            }))\n-            .ok()?,\n-        )\n-    }\n-\n-    fn find_mods_ouside_of_ast_inner(\n+    fn find_mods_outside_of_ast(\n         &self,\n         attrs: &[ast::Attribute],\n         sub_mod: &Cow<'ast, ast::Mod>,\n@@ -356,47 +366,21 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n             if !actual_path.exists() {\n                 continue;\n             }\n-            let file_name = rustc_span::FileName::Real(actual_path.clone());\n-            if self\n-                .parse_sess\n-                .source_map()\n-                .get_source_file(&file_name)\n-                .is_some()\n-            {\n-                // If the specfied file is already parsed, then we just use that.\n+            if self.parse_sess.is_file_parsed(&actual_path) {\n+                // If the specified file is already parsed, then we just use that.\n                 result.push((\n                     actual_path,\n                     DirectoryOwnership::Owned { relative: None },\n                     sub_mod.clone(),\n                 ));\n                 continue;\n             }\n-            let mut parser = new_sub_parser_from_file(\n-                self.parse_sess,\n-                &actual_path,\n-                self.directory.ownership,\n-                None,\n-                DUMMY_SP,\n-            );\n-            parser.cfg_mods = false;\n-            let lo = parser.token.span;\n-            // FIXME(topecongiro) Format inner attributes (#3606).\n-            let _mod_attrs = match parse_inner_attributes(&mut parser) {\n-                Ok(attrs) => attrs,\n-                Err(mut e) => {\n-                    e.cancel();\n-                    parser.sess.span_diagnostic.reset_err_count();\n-                    continue;\n-                }\n-            };\n-            let m = match parse_mod_items(&mut parser, lo) {\n-                Ok(m) => m,\n-                Err(mut e) => {\n-                    e.cancel();\n-                    parser.sess.span_diagnostic.reset_err_count();\n-                    continue;\n-                }\n+            let m = match Parser::parse_file_as_module(self.parse_sess, &actual_path, sub_mod.inner)\n+            {\n+                Some(m) => m,\n+                None => continue,\n             };\n+\n             result.push((\n                 actual_path,\n                 DirectoryOwnership::Owned { relative: None },\n@@ -422,67 +406,11 @@ fn find_path_value(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     attrs.iter().flat_map(path_value).next()\n }\n \n-// FIXME(topecongiro) Use the method from libsyntax[1] once it become public.\n-//\n-// [1] https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/attr.rs\n-fn parse_inner_attributes<'a>(parser: &mut parser::Parser<'a>) -> PResult<'a, Vec<ast::Attribute>> {\n-    let mut attrs: Vec<ast::Attribute> = vec![];\n-    loop {\n-        match parser.token.kind {\n-            TokenKind::Pound => {\n-                // Don't even try to parse if it's not an inner attribute.\n-                if !parser.look_ahead(1, |t| t == &TokenKind::Not) {\n-                    break;\n-                }\n-\n-                let attr = parser.parse_attribute(true)?;\n-                assert_eq!(attr.style, ast::AttrStyle::Inner);\n-                attrs.push(attr);\n-            }\n-            TokenKind::DocComment(s) => {\n-                // we need to get the position of this token before we bump.\n-                let attr = syntax::attr::mk_doc_comment(\n-                    syntax::util::comments::doc_comment_style(&s.as_str()),\n-                    s,\n-                    parser.token.span,\n-                );\n-                if attr.style == ast::AttrStyle::Inner {\n-                    attrs.push(attr);\n-                    parser.bump();\n-                } else {\n-                    break;\n-                }\n-            }\n-            _ => break,\n-        }\n-    }\n-    Ok(attrs)\n-}\n-\n-fn parse_mod_items<'a>(parser: &mut parser::Parser<'a>, inner_lo: Span) -> PResult<'a, ast::Mod> {\n-    let mut items = vec![];\n-    while let Some(item) = parser.parse_item()? {\n-        items.push(item);\n-    }\n-\n-    let hi = if parser.token.span.is_dummy() {\n-        inner_lo\n-    } else {\n-        parser.prev_span\n-    };\n-\n-    Ok(ast::Mod {\n-        inner: inner_lo.to(hi),\n-        items,\n-        inline: false,\n-    })\n-}\n-\n fn is_cfg_if(item: &ast::Item) -> bool {\n     match item.kind {\n-        ast::ItemKind::Mac(ref mac) => {\n+        ast::ItemKind::MacCall(ref mac) => {\n             if let Some(first_segment) = mac.path.segments.first() {\n-                if first_segment.ident.name == Symbol::intern(\"cfg_if\") {\n+                if first_segment.ident.name == *CFG_IF {\n                     return true;\n                 }\n             }"}, {"sha": "942e70d0e8840aaf65eb6300bbe459df8fef3f03", "filename": "src/modules/visitor.rs", "status": "modified", "additions": 11, "deletions": 64, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fmodules%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fmodules%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules%2Fvisitor.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -1,11 +1,10 @@\n-use rustc_parse::{stream_to_parser_with_base_dir, Directory};\n-use rustc_session::parse::ParseSess;\n-use rustc_span::{symbol::kw, Symbol};\n-use syntax::ast;\n-use syntax::token::{DelimToken, TokenKind};\n-use syntax::visit::Visitor;\n+use rustc_ast::ast;\n+use rustc_ast::visit::Visitor;\n+use rustc_span::Symbol;\n \n use crate::attr::MetaVisitor;\n+use crate::syntux::parser::Parser;\n+use crate::syntux::session::ParseSess;\n \n pub(crate) struct ModItem {\n     pub(crate) item: ast::Item,\n@@ -15,15 +14,13 @@ pub(crate) struct ModItem {\n pub(crate) struct CfgIfVisitor<'a> {\n     parse_sess: &'a ParseSess,\n     mods: Vec<ModItem>,\n-    base_dir: Directory<'a>,\n }\n \n impl<'a> CfgIfVisitor<'a> {\n-    pub(crate) fn new(parse_sess: &'a ParseSess, base_dir: Directory<'a>) -> CfgIfVisitor<'a> {\n+    pub(crate) fn new(parse_sess: &'a ParseSess) -> CfgIfVisitor<'a> {\n         CfgIfVisitor {\n             mods: vec![],\n             parse_sess,\n-            base_dir,\n         }\n     }\n \n@@ -33,7 +30,7 @@ impl<'a> CfgIfVisitor<'a> {\n }\n \n impl<'a, 'ast: 'a> Visitor<'ast> for CfgIfVisitor<'a> {\n-    fn visit_mac(&mut self, mac: &'ast ast::Mac) {\n+    fn visit_mac(&mut self, mac: &'ast ast::MacCall) {\n         match self.visit_mac_inner(mac) {\n             Ok(()) => (),\n             Err(e) => debug!(\"{}\", e),\n@@ -42,7 +39,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CfgIfVisitor<'a> {\n }\n \n impl<'a, 'ast: 'a> CfgIfVisitor<'a> {\n-    fn visit_mac_inner(&mut self, mac: &'ast ast::Mac) -> Result<(), &'static str> {\n+    fn visit_mac_inner(&mut self, mac: &'ast ast::MacCall) -> Result<(), &'static str> {\n         // Support both:\n         // ```\n         // extern crate cfg_if;\n@@ -65,59 +62,9 @@ impl<'a, 'ast: 'a> CfgIfVisitor<'a> {\n             }\n         };\n \n-        let ts = mac.args.inner_tokens();\n-        let mut parser =\n-            stream_to_parser_with_base_dir(self.parse_sess, ts.clone(), self.base_dir.clone());\n-        parser.cfg_mods = false;\n-        let mut process_if_cfg = true;\n-\n-        while parser.token.kind != TokenKind::Eof {\n-            if process_if_cfg {\n-                if !parser.eat_keyword(kw::If) {\n-                    return Err(\"Expected `if`\");\n-                }\n-                parser\n-                    .parse_attribute(false)\n-                    .map_err(|_| \"Failed to parse attributes\")?;\n-            }\n-\n-            if !parser.eat(&TokenKind::OpenDelim(DelimToken::Brace)) {\n-                return Err(\"Expected an opening brace\");\n-            }\n-\n-            while parser.token != TokenKind::CloseDelim(DelimToken::Brace)\n-                && parser.token.kind != TokenKind::Eof\n-            {\n-                let item = match parser.parse_item() {\n-                    Ok(Some(item_ptr)) => item_ptr.into_inner(),\n-                    Ok(None) => continue,\n-                    Err(mut err) => {\n-                        err.cancel();\n-                        parser.sess.span_diagnostic.reset_err_count();\n-                        return Err(\n-                            \"Expected item inside cfg_if block, but failed to parse it as an item\",\n-                        );\n-                    }\n-                };\n-                if let ast::ItemKind::Mod(..) = item.kind {\n-                    self.mods.push(ModItem { item });\n-                }\n-            }\n-\n-            if !parser.eat(&TokenKind::CloseDelim(DelimToken::Brace)) {\n-                return Err(\"Expected a closing brace\");\n-            }\n-\n-            if parser.eat(&TokenKind::Eof) {\n-                break;\n-            }\n-\n-            if !parser.eat_keyword(kw::Else) {\n-                return Err(\"Expected `else`\");\n-            }\n-\n-            process_if_cfg = parser.token.is_keyword(kw::If);\n-        }\n+        let items = Parser::parse_cfg_if(self.parse_sess, mac)?;\n+        self.mods\n+            .append(&mut items.into_iter().map(|item| ModItem { item }).collect());\n \n         Ok(())\n     }"}, {"sha": "566f0e366392e67d85ac70cdbdfa90b340cf7f2b", "filename": "src/overflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -3,9 +3,9 @@\n use std::cmp::min;\n \n use itertools::Itertools;\n+use rustc_ast::token::DelimToken;\n+use rustc_ast::{ast, ptr};\n use rustc_span::Span;\n-use syntax::token::DelimToken;\n-use syntax::{ast, ptr};\n \n use crate::closures;\n use crate::config::lists::*;"}, {"sha": "0f3d5e8f878ba7d7f08883e95c40262bf2d8adfa", "filename": "src/pairs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fpairs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fpairs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpairs.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -1,4 +1,4 @@\n-use syntax::ast;\n+use rustc_ast::ast;\n \n use crate::config::lists::*;\n use crate::config::IndentStyle;"}, {"sha": "782926202327d238d3acb2bf5b62809d55ca6848", "filename": "src/patterns.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -1,6 +1,6 @@\n+use rustc_ast::ast::{self, BindingMode, FieldPat, Pat, PatKind, RangeEnd, RangeSyntax};\n+use rustc_ast::ptr;\n use rustc_span::{BytePos, Span};\n-use syntax::ast::{self, BindingMode, FieldPat, Pat, PatKind, RangeEnd, RangeSyntax};\n-use syntax::ptr;\n \n use crate::comment::{combine_strs_with_missing_comments, FindUncommented};\n use crate::config::lists::*;\n@@ -40,7 +40,7 @@ fn is_short_pattern_inner(pat: &ast::Pat) -> bool {\n         ast::PatKind::Rest | ast::PatKind::Wild | ast::PatKind::Lit(_) => true,\n         ast::PatKind::Ident(_, _, ref pat) => pat.is_none(),\n         ast::PatKind::Struct(..)\n-        | ast::PatKind::Mac(..)\n+        | ast::PatKind::MacCall(..)\n         | ast::PatKind::Slice(..)\n         | ast::PatKind::Path(..)\n         | ast::PatKind::Range(..) => false,\n@@ -231,7 +231,9 @@ impl Rewrite for Pat {\n             PatKind::Struct(ref path, ref fields, ellipsis) => {\n                 rewrite_struct_pat(path, fields, ellipsis, self.span, context, shape)\n             }\n-            PatKind::Mac(ref mac) => rewrite_macro(mac, None, context, shape, MacroPosition::Pat),\n+            PatKind::MacCall(ref mac) => {\n+                rewrite_macro(mac, None, context, shape, MacroPosition::Pat)\n+            }\n             PatKind::Paren(ref pat) => pat\n                 .rewrite(context, shape.offset_left(1)?.sub_width(1)?)\n                 .map(|inner_pat| format!(\"({})\", inner_pat)),"}, {"sha": "3b9f2475acc1fcdef219cd03ba06213178b7562e", "filename": "src/reorder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -8,8 +8,8 @@\n \n use std::cmp::{Ord, Ordering};\n \n+use rustc_ast::{ast, attr};\n use rustc_span::{symbol::sym, Span};\n-use syntax::{ast, attr};\n \n use crate::config::Config;\n use crate::imports::{merge_use_trees, UseTree};\n@@ -207,13 +207,13 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         item_kind: ReorderableItemKind,\n         in_group: bool,\n     ) -> usize {\n-        let mut last = self.source_map.lookup_line_range(items[0].span());\n+        let mut last = self.parse_sess.lookup_line_range(items[0].span());\n         let item_length = items\n             .iter()\n             .take_while(|ppi| {\n                 item_kind.is_same_item_kind(&***ppi)\n                     && (!in_group || {\n-                        let current = self.source_map.lookup_line_range(ppi.span());\n+                        let current = self.parse_sess.lookup_line_range(ppi.span());\n                         let in_same_group = current.lo < last.hi + 2;\n                         last = current;\n                         in_same_group"}, {"sha": "86b2e9ded1c07cf7da0c9efc136a86e5379c0a55", "filename": "src/rewrite.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -3,13 +3,13 @@\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n \n-use rustc_session::parse::ParseSess;\n-use rustc_span::{source_map::SourceMap, Span};\n-use syntax::ptr;\n+use rustc_ast::ptr;\n+use rustc_span::Span;\n \n use crate::config::{Config, IndentStyle};\n use crate::shape::Shape;\n use crate::skip::SkipContext;\n+use crate::syntux::session::ParseSess;\n use crate::visitor::SnippetProvider;\n use crate::FormatReport;\n \n@@ -26,8 +26,7 @@ impl<T: Rewrite> Rewrite for ptr::P<T> {\n \n #[derive(Clone)]\n pub(crate) struct RewriteContext<'a> {\n-    pub(crate) parse_session: &'a ParseSess,\n-    pub(crate) source_map: &'a SourceMap,\n+    pub(crate) parse_sess: &'a ParseSess,\n     pub(crate) config: &'a Config,\n     pub(crate) inside_macro: Rc<Cell<bool>>,\n     // Force block indent style even if we are using visual indent style.\n@@ -37,7 +36,7 @@ pub(crate) struct RewriteContext<'a> {\n     pub(crate) is_if_else_block: Cell<bool>,\n     // When rewriting chain, veto going multi line except the last element\n     pub(crate) force_one_line_chain: Cell<bool>,\n-    pub(crate) snippet_provider: &'a SnippetProvider<'a>,\n+    pub(crate) snippet_provider: &'a SnippetProvider,\n     // Used for `format_snippet`\n     pub(crate) macro_rewrite_failure: Cell<bool>,\n     pub(crate) report: FormatReport,"}, {"sha": "fd48e67ee73cb3560244d9041b537cbe515e4e00", "filename": "src/skip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fskip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fskip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fskip.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -1,7 +1,7 @@\n //! Module that contains skip related stuffs.\n \n+use rustc_ast::ast;\n use rustc_ast_pretty::pprust;\n-use syntax::ast;\n \n /// Take care of skip name stack. You can update it by attributes slice or\n /// by other context. Query this context to know if you need skip a block.\n@@ -56,7 +56,7 @@ fn get_skip_names(kind: &str, attrs: &[ast::Attribute]) -> Vec<String> {\n     let mut skip_names = vec![];\n     let path = format!(\"{}::{}::{}\", RUSTFMT, SKIP, kind);\n     for attr in attrs {\n-        // syntax::ast::Path is implemented partialEq\n+        // rustc_ast::ast::Path is implemented partialEq\n         // but it is designed for segments.len() == 1\n         if let ast::AttrKind::Normal(attr_item) = &attr.kind {\n             if pprust::path_to_string(&attr_item.path) != path {"}, {"sha": "4f02d8224e27bef3ef8711f3bf723360cc9c6e9c", "filename": "src/source_file.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fsource_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fsource_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsource_file.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -2,10 +2,9 @@ use std::fs;\n use std::io::{self, Write};\n use std::path::Path;\n \n-use rustc_span::source_map::SourceMap;\n-\n use crate::config::FileName;\n use crate::emitter::{self, Emitter};\n+use crate::syntux::session::ParseSess;\n use crate::NewlineStyle;\n \n #[cfg(test)]\n@@ -14,6 +13,7 @@ use crate::config::Config;\n use crate::create_emitter;\n #[cfg(test)]\n use crate::formatting::FileRecord;\n+use std::rc::Rc;\n \n // Append a newline to the end of each file.\n pub(crate) fn append_newline(s: &mut String) {\n@@ -48,7 +48,7 @@ where\n }\n \n pub(crate) fn write_file<T>(\n-    source_map: Option<&SourceMap>,\n+    parse_sess: Option<&ParseSess>,\n     filename: &FileName,\n     formatted_text: &str,\n     out: &mut T,\n@@ -84,20 +84,17 @@ where\n     // source map instead of hitting the file system. This also supports getting\n     // original text for `FileName::Stdin`.\n     let original_text = if newline_style != NewlineStyle::Auto && *filename != FileName::Stdin {\n-        fs::read_to_string(ensure_real_path(filename))?\n+        Rc::new(fs::read_to_string(ensure_real_path(filename))?)\n     } else {\n-        match source_map\n-            .and_then(|x| x.get_source_file(&filename.into()))\n-            .and_then(|x| x.src.as_ref().map(ToString::to_string))\n-        {\n+        match parse_sess.and_then(|sess| sess.get_original_snippet(filename)) {\n             Some(ori) => ori,\n-            None => fs::read_to_string(ensure_real_path(filename))?,\n+            None => Rc::new(fs::read_to_string(ensure_real_path(filename))?),\n         }\n     };\n \n     let formatted_file = emitter::FormattedFile {\n         filename,\n-        original_text: &original_text,\n+        original_text: original_text.as_str(),\n         formatted_text,\n     };\n "}, {"sha": "76e0d24cf1eb6d325cb2201e7f179888f25fbace", "filename": "src/source_map.rs", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsource_map.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -1,11 +1,10 @@\n //! This module contains utilities that work with the `SourceMap` from `libsyntax`/`syntex_syntax`.\n //! This includes extension traits and methods for looking up spans and line ranges for AST nodes.\n \n-use rustc_span::{source_map::SourceMap, BytePos, Span};\n+use rustc_span::{BytePos, Span};\n \n use crate::comment::FindUncommented;\n use crate::config::file_lines::LineRange;\n-use crate::utils::starts_with_newline;\n use crate::visitor::SnippetProvider;\n \n pub(crate) trait SpanUtils {\n@@ -26,7 +25,7 @@ pub(crate) trait LineRangeUtils {\n     fn lookup_line_range(&self, span: Span) -> LineRange;\n }\n \n-impl<'a> SpanUtils for SnippetProvider<'a> {\n+impl SpanUtils for SnippetProvider {\n     fn span_after(&self, original: Span, needle: &str) -> BytePos {\n         self.opt_span_after(original, needle).unwrap_or_else(|| {\n             panic!(\n@@ -81,27 +80,3 @@ impl<'a> SpanUtils for SnippetProvider<'a> {\n         Some(original.lo() + BytePos(offset as u32))\n     }\n }\n-\n-impl LineRangeUtils for SourceMap {\n-    fn lookup_line_range(&self, span: Span) -> LineRange {\n-        let snippet = self.span_to_snippet(span).unwrap_or_default();\n-        let lo = self.lookup_line(span.lo()).unwrap();\n-        let hi = self.lookup_line(span.hi()).unwrap();\n-\n-        debug_assert_eq!(\n-            lo.sf.name, hi.sf.name,\n-            \"span crossed file boundary: lo: {:?}, hi: {:?}\",\n-            lo, hi\n-        );\n-\n-        // in case the span starts with a newline, the line range is off by 1 without the\n-        // adjustment below\n-        let offset = 1 + if starts_with_newline(&snippet) { 1 } else { 0 };\n-        // Line numbers start at 1\n-        LineRange {\n-            file: lo.sf.clone(),\n-            lo: lo.line + offset,\n-            hi: hi.line + offset,\n-        }\n-    }\n-}"}, {"sha": "60a350524faf4e0443830cc6910566c1915d7b06", "filename": "src/spanned.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fspanned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fspanned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fspanned.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -1,7 +1,7 @@\n use std::cmp::max;\n \n+use rustc_ast::{ast, ptr};\n use rustc_span::{source_map, Span};\n-use syntax::{ast, ptr};\n \n use crate::macros::MacroArg;\n use crate::utils::{mk_sp, outer_attributes};\n@@ -66,14 +66,15 @@ impl Spanned for ast::Stmt {\n             ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n                 mk_sp(expr.span().lo(), self.span.hi())\n             }\n-            ast::StmtKind::Mac(ref mac) => {\n+            ast::StmtKind::MacCall(ref mac) => {\n                 let (_, _, ref attrs) = **mac;\n                 if attrs.is_empty() {\n                     self.span\n                 } else {\n                     mk_sp(attrs[0].span.lo(), self.span.hi())\n                 }\n             }\n+            ast::StmtKind::Empty => self.span,\n         }\n     }\n }\n@@ -151,11 +152,11 @@ impl Spanned for ast::WherePredicate {\n     }\n }\n \n-impl Spanned for ast::FunctionRetTy {\n+impl Spanned for ast::FnRetTy {\n     fn span(&self) -> Span {\n         match *self {\n-            ast::FunctionRetTy::Default(span) => span,\n-            ast::FunctionRetTy::Ty(ref ty) => ty.span,\n+            ast::FnRetTy::Default(span) => span,\n+            ast::FnRetTy::Ty(ref ty) => ty.span,\n         }\n     }\n }"}, {"sha": "807cd9e5fada48d23f47519020bc0e3364d47c04", "filename": "src/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstmt.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -1,5 +1,5 @@\n+use rustc_ast::ast;\n use rustc_span::Span;\n-use syntax::ast;\n \n use crate::comment::recover_comment_removed;\n use crate::config::Version;\n@@ -106,7 +106,7 @@ fn format_stmt(\n             let shape = shape.sub_width(suffix.len())?;\n             format_expr(ex, expr_type, context, shape).map(|s| s + suffix)\n         }\n-        ast::StmtKind::Mac(..) | ast::StmtKind::Item(..) => None,\n+        ast::StmtKind::MacCall(..) | ast::StmtKind::Item(..) | ast::StmtKind::Empty => None,\n     };\n     result.and_then(|res| recover_comment_removed(res, stmt.span(), context))\n }"}, {"sha": "845576bd8d8bb1ea5015db3c864fefcb0194b22e", "filename": "src/syntux.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fsyntux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fsyntux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntux.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -0,0 +1,4 @@\n+//! This module defines a thin abstract layer on top of the rustc's parser and syntax libraries.\n+\n+pub(crate) mod parser;\n+pub(crate) mod session;"}, {"sha": "04a6f7577a0587e3014de6a1728a7f9554cc25e3", "filename": "src/syntux/parser.rs", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fsyntux%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fsyntux%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntux%2Fparser.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -0,0 +1,312 @@\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::path::{Path, PathBuf};\n+\n+use rustc_ast::ast;\n+use rustc_ast::token::{DelimToken, TokenKind};\n+use rustc_errors::{Diagnostic, PResult};\n+use rustc_parse::{new_parser_from_file, parser::Parser as RawParser};\n+use rustc_span::{symbol::kw, Span};\n+\n+use crate::syntux::session::ParseSess;\n+use crate::{Config, Input};\n+\n+pub(crate) type DirectoryOwnership = rustc_expand::module::DirectoryOwnership;\n+pub(crate) type ModulePathSuccess = rustc_expand::module::ModulePathSuccess;\n+\n+#[derive(Clone)]\n+pub(crate) struct Directory {\n+    pub(crate) path: PathBuf,\n+    pub(crate) ownership: DirectoryOwnership,\n+}\n+\n+/// A parser for Rust source code.\n+pub(crate) struct Parser<'a> {\n+    parser: RawParser<'a>,\n+    sess: &'a ParseSess,\n+}\n+\n+/// A builder for the `Parser`.\n+#[derive(Default)]\n+pub(crate) struct ParserBuilder<'a> {\n+    config: Option<&'a Config>,\n+    sess: Option<&'a ParseSess>,\n+    input: Option<Input>,\n+    directory_ownership: Option<DirectoryOwnership>,\n+}\n+\n+impl<'a> ParserBuilder<'a> {\n+    pub(crate) fn input(mut self, input: Input) -> ParserBuilder<'a> {\n+        self.input = Some(input);\n+        self\n+    }\n+\n+    pub(crate) fn sess(mut self, sess: &'a ParseSess) -> ParserBuilder<'a> {\n+        self.sess = Some(sess);\n+        self\n+    }\n+\n+    pub(crate) fn config(mut self, config: &'a Config) -> ParserBuilder<'a> {\n+        self.config = Some(config);\n+        self\n+    }\n+\n+    pub(crate) fn directory_ownership(\n+        mut self,\n+        directory_ownership: Option<DirectoryOwnership>,\n+    ) -> ParserBuilder<'a> {\n+        self.directory_ownership = directory_ownership;\n+        self\n+    }\n+\n+    pub(crate) fn build(self) -> Result<Parser<'a>, ParserError> {\n+        let sess = self.sess.ok_or(ParserError::NoParseSess)?;\n+        let input = self.input.ok_or(ParserError::NoInput)?;\n+\n+        let parser = match Self::parser(sess.inner(), input) {\n+            Ok(p) => p,\n+            Err(db) => {\n+                sess.emit_diagnostics(db);\n+                return Err(ParserError::ParserCreationError);\n+            }\n+        };\n+\n+        Ok(Parser { parser, sess })\n+    }\n+\n+    fn parser(\n+        sess: &'a rustc_session::parse::ParseSess,\n+        input: Input,\n+    ) -> Result<rustc_parse::parser::Parser<'a>, Vec<Diagnostic>> {\n+        match input {\n+            Input::File(ref file) => Ok(new_parser_from_file(sess, file, None)),\n+            Input::Text(text) => rustc_parse::maybe_new_parser_from_source_str(\n+                sess,\n+                rustc_span::FileName::Custom(\"stdin\".to_owned()),\n+                text,\n+            ),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq)]\n+pub(crate) enum ParserError {\n+    NoParseSess,\n+    NoInput,\n+    ParserCreationError,\n+    ParseError,\n+    ParsePanicError,\n+}\n+\n+impl<'a> Parser<'a> {\n+    pub(crate) fn submod_path_from_attr(attrs: &[ast::Attribute], path: &Path) -> Option<PathBuf> {\n+        rustc_expand::module::submod_path_from_attr(attrs, path)\n+    }\n+\n+    // FIXME(topecongiro) Use the method from libsyntax[1] once it become public.\n+    //\n+    // [1] https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/attr.rs\n+    fn parse_inner_attrs(parser: &mut RawParser<'a>) -> PResult<'a, Vec<ast::Attribute>> {\n+        let mut attrs: Vec<ast::Attribute> = vec![];\n+        loop {\n+            match parser.token.kind {\n+                TokenKind::Pound => {\n+                    // Don't even try to parse if it's not an inner attribute.\n+                    if !parser.look_ahead(1, |t| t == &TokenKind::Not) {\n+                        break;\n+                    }\n+\n+                    let attr = parser.parse_attribute(true)?;\n+                    assert_eq!(attr.style, ast::AttrStyle::Inner);\n+                    attrs.push(attr);\n+                }\n+                TokenKind::DocComment(s) => {\n+                    // we need to get the position of this token before we bump.\n+                    let attr = rustc_ast::attr::mk_doc_comment(\n+                        rustc_ast::util::comments::doc_comment_style(&s.as_str()),\n+                        s,\n+                        parser.token.span,\n+                    );\n+                    if attr.style == ast::AttrStyle::Inner {\n+                        attrs.push(attr);\n+                        parser.bump();\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                _ => break,\n+            }\n+        }\n+        Ok(attrs)\n+    }\n+\n+    fn parse_mod_items(parser: &mut RawParser<'a>, span: Span) -> PResult<'a, ast::Mod> {\n+        let mut items = vec![];\n+        while let Some(item) = parser.parse_item()? {\n+            items.push(item);\n+        }\n+\n+        // Handle extern mods that are empty files/files with only comments.\n+        if items.is_empty() {\n+            parser.parse_mod(&TokenKind::Eof)?;\n+        }\n+\n+        let hi = if parser.token.span.is_dummy() {\n+            span\n+        } else {\n+            parser.prev_token.span\n+        };\n+\n+        Ok(ast::Mod {\n+            inner: span.to(hi),\n+            items,\n+            inline: false,\n+        })\n+    }\n+\n+    pub(crate) fn parse_file_as_module(\n+        sess: &'a ParseSess,\n+        path: &Path,\n+        span: Span,\n+    ) -> Option<ast::Mod> {\n+        let result = catch_unwind(AssertUnwindSafe(|| {\n+            let mut parser = new_parser_from_file(sess.inner(), &path, Some(span));\n+\n+            let lo = parser.token.span;\n+            // FIXME(topecongiro) Format inner attributes (#3606).\n+            match Parser::parse_inner_attrs(&mut parser) {\n+                Ok(_attrs) => (),\n+                Err(mut e) => {\n+                    e.cancel();\n+                    sess.reset_errors();\n+                    return None;\n+                }\n+            }\n+\n+            match Parser::parse_mod_items(&mut parser, lo) {\n+                Ok(m) => Some(m),\n+                Err(mut db) => {\n+                    db.cancel();\n+                    sess.reset_errors();\n+                    None\n+                }\n+            }\n+        }));\n+        match result {\n+            Ok(Some(m)) => Some(m),\n+            _ => None,\n+        }\n+    }\n+\n+    pub(crate) fn parse_crate(\n+        config: &'a Config,\n+        input: Input,\n+        directory_ownership: Option<DirectoryOwnership>,\n+        sess: &'a ParseSess,\n+    ) -> Result<ast::Crate, ParserError> {\n+        let mut parser = ParserBuilder::default()\n+            .config(config)\n+            .input(input)\n+            .directory_ownership(directory_ownership)\n+            .sess(sess)\n+            .build()?;\n+\n+        parser.parse_crate_inner()\n+    }\n+\n+    fn parse_crate_inner(&mut self) -> Result<ast::Crate, ParserError> {\n+        let mut parser = AssertUnwindSafe(&mut self.parser);\n+\n+        match catch_unwind(move || parser.parse_crate_mod()) {\n+            Ok(Ok(krate)) => {\n+                if !self.sess.has_errors() {\n+                    return Ok(krate);\n+                }\n+\n+                if self.sess.can_reset_errors() {\n+                    self.sess.reset_errors();\n+                    return Ok(krate);\n+                }\n+\n+                Err(ParserError::ParseError)\n+            }\n+            Ok(Err(mut db)) => {\n+                db.emit();\n+                Err(ParserError::ParseError)\n+            }\n+            Err(_) => Err(ParserError::ParsePanicError),\n+        }\n+    }\n+\n+    pub(crate) fn parse_cfg_if(\n+        sess: &'a ParseSess,\n+        mac: &'a ast::MacCall,\n+    ) -> Result<Vec<ast::Item>, &'static str> {\n+        match catch_unwind(AssertUnwindSafe(|| Parser::parse_cfg_if_inner(sess, mac))) {\n+            Ok(Ok(items)) => Ok(items),\n+            Ok(err @ Err(_)) => err,\n+            Err(..) => Err(\"failed to parse cfg_if!\"),\n+        }\n+    }\n+\n+    fn parse_cfg_if_inner(\n+        sess: &'a ParseSess,\n+        mac: &'a ast::MacCall,\n+    ) -> Result<Vec<ast::Item>, &'static str> {\n+        let token_stream = mac.args.inner_tokens();\n+        let mut parser =\n+            rustc_parse::stream_to_parser(sess.inner(), token_stream.clone(), Some(\"\"));\n+\n+        let mut items = vec![];\n+        let mut process_if_cfg = true;\n+\n+        while parser.token.kind != TokenKind::Eof {\n+            if process_if_cfg {\n+                if !parser.eat_keyword(kw::If) {\n+                    return Err(\"Expected `if`\");\n+                }\n+                parser\n+                    .parse_attribute(false)\n+                    .map_err(|_| \"Failed to parse attributes\")?;\n+            }\n+\n+            if !parser.eat(&TokenKind::OpenDelim(DelimToken::Brace)) {\n+                return Err(\"Expected an opening brace\");\n+            }\n+\n+            while parser.token != TokenKind::CloseDelim(DelimToken::Brace)\n+                && parser.token.kind != TokenKind::Eof\n+            {\n+                let item = match parser.parse_item() {\n+                    Ok(Some(item_ptr)) => item_ptr.into_inner(),\n+                    Ok(None) => continue,\n+                    Err(mut err) => {\n+                        err.cancel();\n+                        parser.sess.span_diagnostic.reset_err_count();\n+                        return Err(\n+                            \"Expected item inside cfg_if block, but failed to parse it as an item\",\n+                        );\n+                    }\n+                };\n+                if let ast::ItemKind::Mod(..) = item.kind {\n+                    items.push(item);\n+                }\n+            }\n+\n+            if !parser.eat(&TokenKind::CloseDelim(DelimToken::Brace)) {\n+                return Err(\"Expected a closing brace\");\n+            }\n+\n+            if parser.eat(&TokenKind::Eof) {\n+                break;\n+            }\n+\n+            if !parser.eat_keyword(kw::Else) {\n+                return Err(\"Expected `else`\");\n+            }\n+\n+            process_if_cfg = parser.token.is_keyword(kw::If);\n+        }\n+\n+        Ok(items)\n+    }\n+}"}, {"sha": "da8741c84e5f9a11e8e247a8cc8ce204ef3395d1", "filename": "src/syntux/session.rs", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fsyntux%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fsyntux%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntux%2Fsession.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -0,0 +1,441 @@\n+use std::cell::RefCell;\n+use std::path::Path;\n+use std::rc::Rc;\n+\n+use rustc_ast::ast;\n+use rustc_data_structures::sync::{Lrc, Send};\n+use rustc_errors::emitter::{Emitter, EmitterWriter};\n+use rustc_errors::{ColorConfig, Diagnostic, Handler, Level as DiagnosticLevel};\n+use rustc_session::parse::ParseSess as RawParseSess;\n+use rustc_span::{\n+    source_map::{FilePathMapping, SourceMap},\n+    BytePos, Span,\n+};\n+\n+use crate::config::file_lines::LineRange;\n+use crate::ignore_path::IgnorePathSet;\n+use crate::source_map::LineRangeUtils;\n+use crate::utils::starts_with_newline;\n+use crate::visitor::SnippetProvider;\n+use crate::{Config, ErrorKind, FileName};\n+\n+/// ParseSess holds structs necessary for constructing a parser.\n+pub(crate) struct ParseSess {\n+    parse_sess: RawParseSess,\n+    ignore_path_set: Rc<IgnorePathSet>,\n+    can_reset_errors: Rc<RefCell<bool>>,\n+}\n+\n+/// Emitter which discards every error.\n+struct SilentEmitter;\n+\n+impl Emitter for SilentEmitter {\n+    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n+        None\n+    }\n+    fn emit_diagnostic(&mut self, _db: &Diagnostic) {}\n+}\n+\n+fn silent_emitter() -> Box<dyn Emitter + Send> {\n+    Box::new(SilentEmitter {})\n+}\n+\n+/// Emit errors against every files expect ones specified in the `ignore_path_set`.\n+struct SilentOnIgnoredFilesEmitter {\n+    ignore_path_set: Rc<IgnorePathSet>,\n+    source_map: Rc<SourceMap>,\n+    emitter: Box<dyn Emitter + Send>,\n+    has_non_ignorable_parser_errors: bool,\n+    can_reset: Rc<RefCell<bool>>,\n+}\n+\n+impl SilentOnIgnoredFilesEmitter {\n+    fn handle_non_ignoreable_error(&mut self, db: &Diagnostic) {\n+        self.has_non_ignorable_parser_errors = true;\n+        *self.can_reset.borrow_mut() = false;\n+        self.emitter.emit_diagnostic(db);\n+    }\n+}\n+\n+impl Emitter for SilentOnIgnoredFilesEmitter {\n+    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n+        None\n+    }\n+    fn emit_diagnostic(&mut self, db: &Diagnostic) {\n+        if db.level == DiagnosticLevel::Fatal {\n+            return self.handle_non_ignoreable_error(db);\n+        }\n+        if let Some(primary_span) = &db.span.primary_span() {\n+            let file_name = self.source_map.span_to_filename(*primary_span);\n+            if let rustc_span::FileName::Real(ref path) = file_name {\n+                if self\n+                    .ignore_path_set\n+                    .is_match(&FileName::Real(path.to_path_buf()))\n+                {\n+                    if !self.has_non_ignorable_parser_errors {\n+                        *self.can_reset.borrow_mut() = true;\n+                    }\n+                    return;\n+                }\n+            };\n+        }\n+        self.handle_non_ignoreable_error(db);\n+    }\n+}\n+\n+fn default_handler(\n+    source_map: Rc<SourceMap>,\n+    ignore_path_set: Rc<IgnorePathSet>,\n+    can_reset: Rc<RefCell<bool>>,\n+    hide_parse_errors: bool,\n+) -> Handler {\n+    let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n+    let color_cfg = if supports_color {\n+        ColorConfig::Auto\n+    } else {\n+        ColorConfig::Never\n+    };\n+\n+    let emitter = if hide_parse_errors {\n+        silent_emitter()\n+    } else {\n+        Box::new(EmitterWriter::stderr(\n+            color_cfg,\n+            Some(source_map.clone()),\n+            false,\n+            false,\n+            None,\n+            false,\n+        ))\n+    };\n+    Handler::with_emitter(\n+        true,\n+        None,\n+        Box::new(SilentOnIgnoredFilesEmitter {\n+            has_non_ignorable_parser_errors: false,\n+            source_map,\n+            emitter,\n+            ignore_path_set,\n+            can_reset,\n+        }),\n+    )\n+}\n+\n+impl ParseSess {\n+    pub(crate) fn new(config: &Config) -> Result<ParseSess, ErrorKind> {\n+        let ignore_path_set = match IgnorePathSet::from_ignore_list(&config.ignore()) {\n+            Ok(ignore_path_set) => Rc::new(ignore_path_set),\n+            Err(e) => return Err(ErrorKind::InvalidGlobPattern(e)),\n+        };\n+        let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n+        let can_reset_errors = Rc::new(RefCell::new(false));\n+\n+        let handler = default_handler(\n+            Rc::clone(&source_map),\n+            Rc::clone(&ignore_path_set),\n+            Rc::clone(&can_reset_errors),\n+            config.hide_parse_errors(),\n+        );\n+        let parse_sess = RawParseSess::with_span_handler(handler, source_map);\n+\n+        Ok(ParseSess {\n+            parse_sess,\n+            ignore_path_set,\n+            can_reset_errors,\n+        })\n+    }\n+\n+    pub(crate) fn default_submod_path(\n+        &self,\n+        id: ast::Ident,\n+        relative: Option<ast::Ident>,\n+        dir_path: &Path,\n+    ) -> rustc_expand::module::ModulePath<'_> {\n+        rustc_expand::module::default_submod_path(\n+            &self.parse_sess,\n+            id,\n+            rustc_span::DUMMY_SP,\n+            relative,\n+            dir_path,\n+        )\n+    }\n+\n+    pub(crate) fn is_file_parsed(&self, path: &Path) -> bool {\n+        self.parse_sess\n+            .source_map()\n+            .get_source_file(&rustc_span::FileName::Real(path.to_path_buf()))\n+            .is_some()\n+    }\n+\n+    pub(crate) fn ignore_file(&self, path: &FileName) -> bool {\n+        self.ignore_path_set.as_ref().is_match(&path)\n+    }\n+\n+    pub(crate) fn set_silent_emitter(&mut self) {\n+        self.parse_sess.span_diagnostic = Handler::with_emitter(true, None, silent_emitter());\n+    }\n+\n+    pub(crate) fn span_to_filename(&self, span: Span) -> FileName {\n+        self.parse_sess.source_map().span_to_filename(span).into()\n+    }\n+\n+    pub(crate) fn span_to_first_line_string(&self, span: Span) -> String {\n+        let file_lines = self.parse_sess.source_map().span_to_lines(span).ok();\n+\n+        match file_lines {\n+            Some(fl) => fl\n+                .file\n+                .get_line(fl.lines[0].line_index)\n+                .map_or_else(String::new, |s| s.to_string()),\n+            None => String::new(),\n+        }\n+    }\n+\n+    pub(crate) fn line_of_byte_pos(&self, pos: BytePos) -> usize {\n+        self.parse_sess.source_map().lookup_char_pos(pos).line\n+    }\n+\n+    pub(crate) fn span_to_debug_info(&self, span: Span) -> String {\n+        self.parse_sess.source_map().span_to_string(span)\n+    }\n+\n+    pub(crate) fn inner(&self) -> &RawParseSess {\n+        &self.parse_sess\n+    }\n+\n+    pub(crate) fn snippet_provider(&self, span: Span) -> SnippetProvider {\n+        let source_file = self.parse_sess.source_map().lookup_char_pos(span.lo()).file;\n+        SnippetProvider::new(\n+            source_file.start_pos,\n+            source_file.end_pos,\n+            Rc::clone(source_file.src.as_ref().unwrap()),\n+        )\n+    }\n+\n+    pub(crate) fn get_original_snippet(&self, file_name: &FileName) -> Option<Rc<String>> {\n+        self.parse_sess\n+            .source_map()\n+            .get_source_file(&file_name.into())\n+            .and_then(|source_file| source_file.src.clone())\n+    }\n+}\n+\n+// Methods that should be restricted within the syntux module.\n+impl ParseSess {\n+    pub(super) fn emit_diagnostics(&self, diagnostics: Vec<Diagnostic>) {\n+        for diagnostic in diagnostics {\n+            self.parse_sess.span_diagnostic.emit_diagnostic(&diagnostic);\n+        }\n+    }\n+\n+    pub(super) fn can_reset_errors(&self) -> bool {\n+        *self.can_reset_errors.borrow()\n+    }\n+\n+    pub(super) fn has_errors(&self) -> bool {\n+        self.parse_sess.span_diagnostic.has_errors()\n+    }\n+\n+    pub(super) fn reset_errors(&self) {\n+        self.parse_sess.span_diagnostic.reset_err_count();\n+    }\n+}\n+\n+impl LineRangeUtils for ParseSess {\n+    fn lookup_line_range(&self, span: Span) -> LineRange {\n+        let snippet = self\n+            .parse_sess\n+            .source_map()\n+            .span_to_snippet(span)\n+            .unwrap_or_default();\n+        let lo = self.parse_sess.source_map().lookup_line(span.lo()).unwrap();\n+        let hi = self.parse_sess.source_map().lookup_line(span.hi()).unwrap();\n+\n+        debug_assert_eq!(\n+            lo.sf.name, hi.sf.name,\n+            \"span crossed file boundary: lo: {:?}, hi: {:?}\",\n+            lo, hi\n+        );\n+\n+        // in case the span starts with a newline, the line range is off by 1 without the\n+        // adjustment below\n+        let offset = 1 + if starts_with_newline(&snippet) { 1 } else { 0 };\n+        // Line numbers start at 1\n+        LineRange {\n+            file: lo.sf.clone(),\n+            lo: lo.line + offset,\n+            hi: hi.line + offset,\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    mod emitter {\n+        use super::*;\n+        use crate::config::IgnoreList;\n+        use crate::is_nightly_channel;\n+        use crate::utils::mk_sp;\n+        use rustc_span::{FileName as SourceMapFileName, MultiSpan, DUMMY_SP};\n+        use std::path::PathBuf;\n+\n+        struct TestEmitter {\n+            num_emitted_errors: Rc<RefCell<u32>>,\n+        }\n+\n+        impl Emitter for TestEmitter {\n+            fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n+                None\n+            }\n+            fn emit_diagnostic(&mut self, _db: &Diagnostic) {\n+                *self.num_emitted_errors.borrow_mut() += 1;\n+            }\n+        }\n+\n+        fn build_diagnostic(level: DiagnosticLevel, span: Option<MultiSpan>) -> Diagnostic {\n+            Diagnostic {\n+                level,\n+                code: None,\n+                message: vec![],\n+                children: vec![],\n+                suggestions: vec![],\n+                span: span.unwrap_or_else(MultiSpan::new),\n+                sort_span: DUMMY_SP,\n+            }\n+        }\n+\n+        fn build_emitter(\n+            num_emitted_errors: Rc<RefCell<u32>>,\n+            can_reset: Rc<RefCell<bool>>,\n+            source_map: Option<Rc<SourceMap>>,\n+            ignore_list: Option<IgnoreList>,\n+        ) -> SilentOnIgnoredFilesEmitter {\n+            let emitter_writer = TestEmitter { num_emitted_errors };\n+            let source_map =\n+                source_map.unwrap_or_else(|| Rc::new(SourceMap::new(FilePathMapping::empty())));\n+            let ignore_path_set =\n+                Rc::new(IgnorePathSet::from_ignore_list(&ignore_list.unwrap_or_default()).unwrap());\n+            SilentOnIgnoredFilesEmitter {\n+                has_non_ignorable_parser_errors: false,\n+                source_map,\n+                emitter: Box::new(emitter_writer),\n+                ignore_path_set,\n+                can_reset,\n+            }\n+        }\n+\n+        fn get_ignore_list(config: &str) -> IgnoreList {\n+            Config::from_toml(config, Path::new(\"\")).unwrap().ignore()\n+        }\n+\n+        #[test]\n+        fn handles_fatal_parse_error_in_ignored_file() {\n+            let num_emitted_errors = Rc::new(RefCell::new(0));\n+            let can_reset_errors = Rc::new(RefCell::new(false));\n+            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n+            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n+            let source =\n+                String::from(r#\"extern \"system\" fn jni_symbol!( funcName ) ( ... ) -> {} \"#);\n+            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n+            let mut emitter = build_emitter(\n+                Rc::clone(&num_emitted_errors),\n+                Rc::clone(&can_reset_errors),\n+                Some(Rc::clone(&source_map)),\n+                Some(ignore_list),\n+            );\n+            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n+            let fatal_diagnostic = build_diagnostic(DiagnosticLevel::Fatal, Some(span));\n+            emitter.emit_diagnostic(&fatal_diagnostic);\n+            assert_eq!(*num_emitted_errors.borrow(), 1);\n+            assert_eq!(*can_reset_errors.borrow(), false);\n+        }\n+\n+        #[test]\n+        fn handles_recoverable_parse_error_in_ignored_file() {\n+            if !is_nightly_channel!() {\n+                return;\n+            }\n+            let num_emitted_errors = Rc::new(RefCell::new(0));\n+            let can_reset_errors = Rc::new(RefCell::new(false));\n+            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n+            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n+            let source = String::from(r#\"pub fn bar() { 1x; }\"#);\n+            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n+            let mut emitter = build_emitter(\n+                Rc::clone(&num_emitted_errors),\n+                Rc::clone(&can_reset_errors),\n+                Some(Rc::clone(&source_map)),\n+                Some(ignore_list),\n+            );\n+            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n+            let non_fatal_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(span));\n+            emitter.emit_diagnostic(&non_fatal_diagnostic);\n+            assert_eq!(*num_emitted_errors.borrow(), 0);\n+            assert_eq!(*can_reset_errors.borrow(), true);\n+        }\n+\n+        #[test]\n+        fn handles_recoverable_parse_error_in_non_ignored_file() {\n+            if !is_nightly_channel!() {\n+                return;\n+            }\n+            let num_emitted_errors = Rc::new(RefCell::new(0));\n+            let can_reset_errors = Rc::new(RefCell::new(false));\n+            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n+            let source = String::from(r#\"pub fn bar() { 1x; }\"#);\n+            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n+            let mut emitter = build_emitter(\n+                Rc::clone(&num_emitted_errors),\n+                Rc::clone(&can_reset_errors),\n+                Some(Rc::clone(&source_map)),\n+                None,\n+            );\n+            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n+            let non_fatal_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(span));\n+            emitter.emit_diagnostic(&non_fatal_diagnostic);\n+            assert_eq!(*num_emitted_errors.borrow(), 1);\n+            assert_eq!(*can_reset_errors.borrow(), false);\n+        }\n+\n+        #[test]\n+        fn handles_mix_of_recoverable_parse_error() {\n+            if !is_nightly_channel!() {\n+                return;\n+            }\n+            let num_emitted_errors = Rc::new(RefCell::new(0));\n+            let can_reset_errors = Rc::new(RefCell::new(false));\n+            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n+            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n+            let bar_source = String::from(r#\"pub fn bar() { 1x; }\"#);\n+            let foo_source = String::from(r#\"pub fn foo() { 1x; }\"#);\n+            let fatal_source =\n+                String::from(r#\"extern \"system\" fn jni_symbol!( funcName ) ( ... ) -> {} \"#);\n+            source_map\n+                .new_source_file(SourceMapFileName::Real(PathBuf::from(\"bar.rs\")), bar_source);\n+            source_map\n+                .new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), foo_source);\n+            source_map.new_source_file(\n+                SourceMapFileName::Real(PathBuf::from(\"fatal.rs\")),\n+                fatal_source,\n+            );\n+            let mut emitter = build_emitter(\n+                Rc::clone(&num_emitted_errors),\n+                Rc::clone(&can_reset_errors),\n+                Some(Rc::clone(&source_map)),\n+                Some(ignore_list),\n+            );\n+            let bar_span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n+            let foo_span = MultiSpan::from_span(mk_sp(BytePos(21), BytePos(22)));\n+            let bar_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(bar_span));\n+            let foo_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(foo_span));\n+            let fatal_diagnostic = build_diagnostic(DiagnosticLevel::Fatal, None);\n+            emitter.emit_diagnostic(&bar_diagnostic);\n+            emitter.emit_diagnostic(&foo_diagnostic);\n+            emitter.emit_diagnostic(&fatal_diagnostic);\n+            assert_eq!(*num_emitted_errors.borrow(), 2);\n+            assert_eq!(*can_reset_errors.borrow(), false);\n+        }\n+    }\n+}"}, {"sha": "4f92ff6246f49e9120de423650ce794e5d092548", "filename": "src/types.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -1,8 +1,8 @@\n use std::iter::ExactSizeIterator;\n use std::ops::Deref;\n \n+use rustc_ast::ast::{self, FnRetTy, Mutability};\n use rustc_span::{symbol::kw, BytePos, Span};\n-use syntax::ast::{self, FunctionRetTy, Mutability};\n \n use crate::config::lists::*;\n use crate::config::{IndentStyle, TypeDensity, Version};\n@@ -233,14 +233,18 @@ fn rewrite_segment(\n \n     if let Some(ref args) = segment.args {\n         match **args {\n-            ast::GenericArgs::AngleBracketed(ref data)\n-                if !data.args.is_empty() || !data.constraints.is_empty() =>\n-            {\n+            ast::GenericArgs::AngleBracketed(ref data) if !data.args.is_empty() => {\n                 let param_list = data\n                     .args\n                     .iter()\n-                    .map(SegmentParam::from_generic_arg)\n-                    .chain(data.constraints.iter().map(|x| SegmentParam::Binding(&*x)))\n+                    .map(|x| match x {\n+                        ast::AngleBracketedArg::Arg(generic_arg) => {\n+                            SegmentParam::from_generic_arg(generic_arg)\n+                        }\n+                        ast::AngleBracketedArg::Constraint(constraint) => {\n+                            SegmentParam::Binding(constraint)\n+                        }\n+                    })\n                     .collect::<Vec<_>>();\n \n                 // HACK: squeeze out the span between the identifier and the parameters.\n@@ -292,7 +296,7 @@ fn rewrite_segment(\n \n fn format_function_type<'a, I>(\n     inputs: I,\n-    output: &FunctionRetTy,\n+    output: &FnRetTy,\n     variadic: bool,\n     span: Span,\n     context: &RewriteContext<'_>,\n@@ -311,11 +315,11 @@ where\n         IndentStyle::Visual => shape.block_left(4)?,\n     };\n     let output = match *output {\n-        FunctionRetTy::Ty(ref ty) => {\n+        FnRetTy::Ty(ref ty) => {\n             let type_str = ty.rewrite(context, ty_shape)?;\n             format!(\" -> {}\", type_str)\n         }\n-        FunctionRetTy::Default(..) => String::new(),\n+        FnRetTy::Default(..) => String::new(),\n     };\n \n     let list_shape = if context.use_block_indent() {\n@@ -551,7 +555,7 @@ impl Rewrite for ast::GenericParam {\n             _ => (),\n         }\n \n-        if let syntax::ast::GenericParamKind::Const { ref ty } = &self.kind {\n+        if let rustc_ast::ast::GenericParamKind::Const { ref ty } = &self.kind {\n             result.push_str(\"const \");\n             result.push_str(rewrite_ident(context, self.ident));\n             result.push_str(\": \");\n@@ -732,7 +736,7 @@ impl Rewrite for ast::Ty {\n             }\n             ast::TyKind::BareFn(ref bare_fn) => rewrite_bare_fn(bare_fn, self.span, context, shape),\n             ast::TyKind::Never => Some(String::from(\"!\")),\n-            ast::TyKind::Mac(ref mac) => {\n+            ast::TyKind::MacCall(ref mac) => {\n                 rewrite_macro(mac, None, context, shape, MacroPosition::Expression)\n             }\n             ast::TyKind::ImplicitSelf => Some(String::from(\"\")),"}, {"sha": "41400399ddd6509c0b02293474330d55de71515c", "filename": "src/utils.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -1,13 +1,13 @@\n use std::borrow::Cow;\n \n-use rustc_ast_pretty::pprust;\n-use rustc_span::{sym, BytePos, ExpnId, Span, Symbol, SyntaxContext};\n-use rustc_target::spec::abi;\n-use syntax::ast::{\n+use rustc_ast::ast::{\n     self, Attribute, CrateSugar, MetaItem, MetaItemKind, NestedMetaItem, NodeId, Path, Visibility,\n     VisibilityKind,\n };\n-use syntax::ptr;\n+use rustc_ast::ptr;\n+use rustc_ast_pretty::pprust;\n+use rustc_span::{sym, BytePos, ExpnId, Span, Symbol, SyntaxContext};\n+use rustc_target::spec::abi;\n use unicode_width::UnicodeWidthStr;\n \n use crate::comment::{filter_normal_code, CharClasses, FullCodeCharKind, LineClasses};\n@@ -86,34 +86,34 @@ pub(crate) fn format_visibility(\n }\n \n #[inline]\n-pub(crate) fn format_async(is_async: &ast::IsAsync) -> &'static str {\n+pub(crate) fn format_async(is_async: &ast::Async) -> &'static str {\n     match is_async {\n-        ast::IsAsync::Async { .. } => \"async \",\n-        ast::IsAsync::NotAsync => \"\",\n+        ast::Async::Yes { .. } => \"async \",\n+        ast::Async::No => \"\",\n     }\n }\n \n #[inline]\n-pub(crate) fn format_constness(constness: ast::Constness) -> &'static str {\n+pub(crate) fn format_constness(constness: ast::Const) -> &'static str {\n     match constness {\n-        ast::Constness::Const => \"const \",\n-        ast::Constness::NotConst => \"\",\n+        ast::Const::Yes(..) => \"const \",\n+        ast::Const::No => \"\",\n     }\n }\n \n #[inline]\n pub(crate) fn format_defaultness(defaultness: ast::Defaultness) -> &'static str {\n     match defaultness {\n-        ast::Defaultness::Default => \"default \",\n+        ast::Defaultness::Default(..) => \"default \",\n         ast::Defaultness::Final => \"\",\n     }\n }\n \n #[inline]\n-pub(crate) fn format_unsafety(unsafety: ast::Unsafety) -> &'static str {\n+pub(crate) fn format_unsafety(unsafety: ast::Unsafe) -> &'static str {\n     match unsafety {\n-        ast::Unsafety::Unsafe => \"unsafe \",\n-        ast::Unsafety::Normal => \"\",\n+        ast::Unsafe::Yes(..) => \"unsafe \",\n+        ast::Unsafe::No => \"\",\n     }\n }\n \n@@ -157,7 +157,7 @@ pub(crate) fn format_extern(\n }\n \n #[inline]\n-// Transform `Vec<syntax::ptr::P<T>>` into `Vec<&T>`\n+// Transform `Vec<rustc_ast::ptr::P<T>>` into `Vec<&T>`\n pub(crate) fn ptr_vec_to_ref_vec<T>(vec: &[ptr::P<T>]) -> Vec<&T> {\n     vec.iter().map(|x| &**x).collect::<Vec<_>>()\n }\n@@ -355,7 +355,7 @@ macro_rules! out_of_file_lines_range {\n             && !$self\n                 .config\n                 .file_lines()\n-                .intersects(&$self.source_map.lookup_line_range($span))\n+                .intersects(&$self.parse_sess.lookup_line_range($span))\n     };\n }\n \n@@ -456,7 +456,7 @@ pub(crate) fn first_line_ends_with(s: &str, c: char) -> bool {\n // parens, braces, and brackets in its idiomatic formatting.\n pub(crate) fn is_block_expr(context: &RewriteContext<'_>, expr: &ast::Expr, repr: &str) -> bool {\n     match expr.kind {\n-        ast::ExprKind::Mac(..)\n+        ast::ExprKind::MacCall(..)\n         | ast::ExprKind::Call(..)\n         | ast::ExprKind::MethodCall(..)\n         | ast::ExprKind::Array(..)\n@@ -490,7 +490,7 @@ pub(crate) fn is_block_expr(context: &RewriteContext<'_>, expr: &ast::Expr, repr\n         | ast::ExprKind::Continue(..)\n         | ast::ExprKind::Err\n         | ast::ExprKind::Field(..)\n-        | ast::ExprKind::InlineAsm(..)\n+        | ast::ExprKind::LlvmInlineAsm(..)\n         | ast::ExprKind::Let(..)\n         | ast::ExprKind::Path(..)\n         | ast::ExprKind::Range(..)"}, {"sha": "95d1d5c2d7e28ac5fd80e3d26d9604d8d1bfc4c6", "filename": "src/vertical.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -3,8 +3,8 @@\n use std::cmp;\n \n use itertools::Itertools;\n+use rustc_ast::ast;\n use rustc_span::{BytePos, Span};\n-use syntax::ast;\n \n use crate::comment::combine_strs_with_missing_comments;\n use crate::config::lists::*;"}, {"sha": "346628c0b890e3bf453287ceed2c20d537ad41b6", "filename": "src/visitor.rs", "status": "modified", "additions": 77, "deletions": 71, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -1,13 +1,9 @@\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n \n-use rustc_session::parse::ParseSess;\n-use rustc_span::{\n-    source_map::{self, SourceMap},\n-    BytePos, Pos, Span,\n-};\n-use syntax::token::DelimToken;\n-use syntax::{ast, visit};\n+use rustc_ast::token::DelimToken;\n+use rustc_ast::{ast, visit};\n+use rustc_span::{BytePos, Pos, Span};\n \n use crate::attr::*;\n use crate::comment::{rewrite_comment, CodeCharKind, CommentCodeSlices};\n@@ -27,30 +23,31 @@ use crate::skip::{is_skip_attr, SkipContext};\n use crate::source_map::{LineRangeUtils, SpanUtils};\n use crate::spanned::Spanned;\n use crate::stmt::Stmt;\n+use crate::syntux::session::ParseSess;\n use crate::utils::{\n     self, contains_skip, count_newlines, depr_skip_annotation, inner_attributes, last_line_width,\n     mk_sp, ptr_vec_to_ref_vec, rewrite_ident, stmt_expr,\n };\n use crate::{ErrorKind, FormatReport, FormattingError};\n \n /// Creates a string slice corresponding to the specified span.\n-pub(crate) struct SnippetProvider<'a> {\n+pub(crate) struct SnippetProvider {\n     /// A pointer to the content of the file we are formatting.\n-    big_snippet: &'a str,\n+    big_snippet: Rc<String>,\n     /// A position of the start of `big_snippet`, used as an offset.\n     start_pos: usize,\n     /// A end position of the file that this snippet lives.\n     end_pos: usize,\n }\n \n-impl<'a> SnippetProvider<'a> {\n+impl SnippetProvider {\n     pub(crate) fn span_to_snippet(&self, span: Span) -> Option<&str> {\n         let start_index = span.lo().to_usize().checked_sub(self.start_pos)?;\n         let end_index = span.hi().to_usize().checked_sub(self.start_pos)?;\n         Some(&self.big_snippet[start_index..end_index])\n     }\n \n-    pub(crate) fn new(start_pos: BytePos, end_pos: BytePos, big_snippet: &'a str) -> Self {\n+    pub(crate) fn new(start_pos: BytePos, end_pos: BytePos, big_snippet: Rc<String>) -> Self {\n         let start_pos = start_pos.to_usize();\n         let end_pos = end_pos.to_usize();\n         SnippetProvider {\n@@ -60,22 +57,29 @@ impl<'a> SnippetProvider<'a> {\n         }\n     }\n \n+    pub(crate) fn entire_snippet(&self) -> &str {\n+        self.big_snippet.as_str()\n+    }\n+\n+    pub(crate) fn start_pos(&self) -> BytePos {\n+        BytePos::from_usize(self.start_pos)\n+    }\n+\n     pub(crate) fn end_pos(&self) -> BytePos {\n         BytePos::from_usize(self.end_pos)\n     }\n }\n \n pub(crate) struct FmtVisitor<'a> {\n     parent_context: Option<&'a RewriteContext<'a>>,\n-    pub(crate) parse_session: &'a ParseSess,\n-    pub(crate) source_map: &'a SourceMap,\n+    pub(crate) parse_sess: &'a ParseSess,\n     pub(crate) buffer: String,\n     pub(crate) last_pos: BytePos,\n     // FIXME: use an RAII util or closure for indenting\n     pub(crate) block_indent: Indent,\n     pub(crate) config: &'a Config,\n     pub(crate) is_if_else_block: bool,\n-    pub(crate) snippet_provider: &'a SnippetProvider<'a>,\n+    pub(crate) snippet_provider: &'a SnippetProvider,\n     pub(crate) line_number: usize,\n     /// List of 1-based line ranges which were annotated with skip\n     /// Both bounds are inclusifs.\n@@ -110,10 +114,8 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n     fn visit_stmt(&mut self, stmt: &Stmt<'_>) {\n         debug!(\n-            \"visit_stmt: {:?} {:?} `{}`\",\n-            self.source_map.lookup_char_pos(stmt.span().lo()),\n-            self.source_map.lookup_char_pos(stmt.span().hi()),\n-            self.snippet(stmt.span()),\n+            \"visit_stmt: {}\",\n+            self.parse_sess.span_to_debug_info(stmt.span())\n         );\n \n         // https://github.com/rust-lang/rust/issues/63679.\n@@ -144,7 +146,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                     self.push_rewrite(stmt.span(), rewrite)\n                 }\n             }\n-            ast::StmtKind::Mac(ref mac) => {\n+            ast::StmtKind::MacCall(ref mac) => {\n                 let (ref mac, _macro_style, ref attrs) = **mac;\n                 if self.visit_attrs(attrs, ast::AttrStyle::Outer) {\n                     self.push_skipped_with_span(\n@@ -157,6 +159,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 }\n                 self.format_missing(stmt.span().hi());\n             }\n+            ast::StmtKind::Empty => (),\n         }\n     }\n \n@@ -195,9 +198,8 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         has_braces: bool,\n     ) {\n         debug!(\n-            \"visit_block: {:?} {:?}\",\n-            self.source_map.lookup_char_pos(b.span.lo()),\n-            self.source_map.lookup_char_pos(b.span.hi())\n+            \"visit_block: {}\",\n+            self.parse_sess.span_to_debug_info(b.span),\n         );\n \n         // Check if this block has braces.\n@@ -497,7 +499,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                     self.format_missing_with_indent(source!(self, item.span).lo());\n                     self.format_mod(module, &item.vis, item.span, item.ident, attrs, is_inline);\n                 }\n-                ast::ItemKind::Mac(ref mac) => {\n+                ast::ItemKind::MacCall(ref mac) => {\n                     self.visit_mac(mac, Some(item.ident), MacroPosition::Item);\n                 }\n                 ast::ItemKind::ForeignMod(ref foreign_mod) => {\n@@ -507,7 +509,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => {\n                     self.visit_static(&StaticParts::from_item(item));\n                 }\n-                ast::ItemKind::Fn(ref fn_signature, ref generics, ref body) => {\n+                ast::ItemKind::Fn(defaultness, ref fn_signature, ref generics, Some(ref body)) => {\n                     let inner_attrs = inner_attributes(&item.attrs);\n                     let fn_ctxt = match fn_signature.header.ext {\n                         ast::Extern::None => visit::FnCtxt::Free,\n@@ -519,28 +521,40 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                             item.ident,\n                             &fn_signature,\n                             &item.vis,\n-                            body.as_deref(),\n+                            Some(body),\n                         ),\n                         generics,\n                         &fn_signature.decl,\n                         item.span,\n-                        ast::Defaultness::Final,\n+                        defaultness,\n                         Some(&inner_attrs),\n                     )\n                 }\n-                ast::ItemKind::TyAlias(ref ty, ref generics) => match ty.kind.opaque_top_hack() {\n-                    None => {\n+                ast::ItemKind::Fn(_, ref fn_signature, ref generics, None) => {\n+                    let indent = self.block_indent;\n+                    let rewrite = self.rewrite_required_fn(\n+                        indent,\n+                        item.ident,\n+                        &fn_signature,\n+                        generics,\n+                        item.span,\n+                    );\n+\n+                    self.push_rewrite(item.span, rewrite);\n+                }\n+                ast::ItemKind::TyAlias(_, ref generics, ref generic_bounds, ref ty) => match ty {\n+                    Some(ty) => {\n                         let rewrite = rewrite_type_alias(\n                             &self.get_context(),\n                             self.block_indent,\n                             item.ident,\n-                            ty,\n+                            &*ty,\n                             generics,\n                             &item.vis,\n                         );\n                         self.push_rewrite(item.span, rewrite);\n                     }\n-                    Some(generic_bounds) => {\n+                    None => {\n                         let rewrite = rewrite_opaque_type(\n                             &self.get_context(),\n                             self.block_indent,\n@@ -583,37 +597,36 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n         match ti.kind {\n             ast::AssocItemKind::Const(..) => self.visit_static(&StaticParts::from_trait_item(ti)),\n-            ast::AssocItemKind::Fn(ref sig, None) => {\n+            ast::AssocItemKind::Fn(_, ref sig, ref generics, None) => {\n                 let indent = self.block_indent;\n-                let rewrite =\n-                    self.rewrite_required_fn(indent, ti.ident, sig, &ti.generics, ti.span);\n+                let rewrite = self.rewrite_required_fn(indent, ti.ident, sig, generics, ti.span);\n                 self.push_rewrite(ti.span, rewrite);\n             }\n-            ast::AssocItemKind::Fn(ref sig, Some(ref body)) => {\n+            ast::AssocItemKind::Fn(defaultness, ref sig, ref generics, Some(ref body)) => {\n                 let inner_attrs = inner_attributes(&ti.attrs);\n                 let vis = rustc_span::source_map::dummy_spanned(ast::VisibilityKind::Inherited);\n                 let fn_ctxt = visit::FnCtxt::Assoc(visit::AssocCtxt::Trait);\n                 self.visit_fn(\n                     visit::FnKind::Fn(fn_ctxt, ti.ident, sig, &vis, Some(body)),\n-                    &ti.generics,\n+                    generics,\n                     &sig.decl,\n                     ti.span,\n-                    ast::Defaultness::Final,\n+                    defaultness,\n                     Some(&inner_attrs),\n                 );\n             }\n-            ast::AssocItemKind::TyAlias(ref generic_bounds, ref type_default) => {\n+            ast::AssocItemKind::TyAlias(_, ref generics, ref generic_bounds, ref type_default) => {\n                 let rewrite = rewrite_associated_type(\n                     ti.ident,\n                     type_default.as_ref(),\n-                    &ti.generics,\n+                    generics,\n                     Some(generic_bounds),\n                     &self.get_context(),\n                     self.block_indent,\n                 );\n                 self.push_rewrite(ti.span, rewrite);\n             }\n-            ast::AssocItemKind::Macro(ref mac) => {\n+            ast::AssocItemKind::MacCall(ref mac) => {\n                 self.visit_mac(mac, Some(ti.ident), MacroPosition::Item);\n             }\n         }\n@@ -628,32 +641,31 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n \n         match ii.kind {\n-            ast::AssocItemKind::Fn(ref sig, Some(ref body)) => {\n+            ast::AssocItemKind::Fn(defaultness, ref sig, ref generics, Some(ref body)) => {\n                 let inner_attrs = inner_attributes(&ii.attrs);\n                 let fn_ctxt = visit::FnCtxt::Assoc(visit::AssocCtxt::Impl);\n                 self.visit_fn(\n                     visit::FnKind::Fn(fn_ctxt, ii.ident, sig, &ii.vis, Some(body)),\n-                    &ii.generics,\n+                    generics,\n                     &sig.decl,\n                     ii.span,\n-                    ii.defaultness,\n+                    defaultness,\n                     Some(&inner_attrs),\n                 );\n             }\n-            ast::AssocItemKind::Fn(ref sig, None) => {\n+            ast::AssocItemKind::Fn(_, ref sig, ref generics, None) => {\n                 let indent = self.block_indent;\n-                let rewrite =\n-                    self.rewrite_required_fn(indent, ii.ident, sig, &ii.generics, ii.span);\n+                let rewrite = self.rewrite_required_fn(indent, ii.ident, sig, generics, ii.span);\n                 self.push_rewrite(ii.span, rewrite);\n             }\n             ast::AssocItemKind::Const(..) => self.visit_static(&StaticParts::from_impl_item(ii)),\n-            ast::AssocItemKind::TyAlias(_, ref ty) => {\n+            ast::AssocItemKind::TyAlias(defaultness, ref generics, _, ref ty) => {\n                 let rewrite_associated = || {\n                     rewrite_associated_impl_type(\n                         ii.ident,\n-                        ii.defaultness,\n+                        defaultness,\n                         ty.as_ref(),\n-                        &ii.generics,\n+                        &generics,\n                         &self.get_context(),\n                         self.block_indent,\n                     )\n@@ -664,7 +676,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                         Some(generic_bounds) => rewrite_opaque_impl_type(\n                             &self.get_context(),\n                             ii.ident,\n-                            &ii.generics,\n+                            generics,\n                             generic_bounds,\n                             self.block_indent,\n                         ),\n@@ -673,13 +685,13 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 };\n                 self.push_rewrite(ii.span, rewrite);\n             }\n-            ast::AssocItemKind::Macro(ref mac) => {\n+            ast::AssocItemKind::MacCall(ref mac) => {\n                 self.visit_mac(mac, Some(ii.ident), MacroPosition::Item);\n             }\n         }\n     }\n \n-    fn visit_mac(&mut self, mac: &ast::Mac, ident: Option<ast::Ident>, pos: MacroPosition) {\n+    fn visit_mac(&mut self, mac: &ast::MacCall, ident: Option<ast::Ident>, pos: MacroPosition) {\n         skip_out_of_file_lines_range_visitor!(self, mac.span());\n \n         // 1 = ;\n@@ -740,10 +752,10 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         // do not take into account the lines with attributes as part of the skipped range\n         let attrs_end = attrs\n             .iter()\n-            .map(|attr| self.source_map.lookup_char_pos(attr.span.hi()).line)\n+            .map(|attr| self.parse_sess.line_of_byte_pos(attr.span.hi()))\n             .max()\n             .unwrap_or(1);\n-        let first_line = self.source_map.lookup_char_pos(main_span.lo()).line;\n+        let first_line = self.parse_sess.line_of_byte_pos(main_span.lo());\n         // Statement can start after some newlines and/or spaces\n         // or it can be on the same line as the last attribute.\n         // So here we need to take a minimum between the two.\n@@ -754,8 +766,8 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     }\n \n     pub(crate) fn from_context(ctx: &'a RewriteContext<'_>) -> FmtVisitor<'a> {\n-        let mut visitor = FmtVisitor::from_source_map(\n-            ctx.parse_session,\n+        let mut visitor = FmtVisitor::from_parse_sess(\n+            ctx.parse_sess,\n             ctx.config,\n             ctx.snippet_provider,\n             ctx.report.clone(),\n@@ -765,16 +777,15 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         visitor\n     }\n \n-    pub(crate) fn from_source_map(\n+    pub(crate) fn from_parse_sess(\n         parse_session: &'a ParseSess,\n         config: &'a Config,\n-        snippet_provider: &'a SnippetProvider<'_>,\n+        snippet_provider: &'a SnippetProvider,\n         report: FormatReport,\n     ) -> FmtVisitor<'a> {\n         FmtVisitor {\n             parent_context: None,\n-            parse_session,\n-            source_map: parse_session.source_map(),\n+            parse_sess: parse_session,\n             buffer: String::with_capacity(snippet_provider.big_snippet.len() * 2),\n             last_pos: BytePos(0),\n             block_indent: Indent::empty(),\n@@ -801,12 +812,12 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     pub(crate) fn visit_attrs(&mut self, attrs: &[ast::Attribute], style: ast::AttrStyle) -> bool {\n         for attr in attrs {\n             if attr.check_name(depr_skip_annotation()) {\n-                let file_name = self.source_map.span_to_filename(attr.span).into();\n+                let file_name = self.parse_sess.span_to_filename(attr.span);\n                 self.report.append(\n                     file_name,\n                     vec![FormattingError::from_span(\n                         attr.span,\n-                        &self.source_map,\n+                        self.parse_sess,\n                         ErrorKind::DeprecatedAttr,\n                     )],\n                 );\n@@ -815,12 +826,12 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                     ast::AttrKind::Normal(ref attribute_item)\n                         if self.is_unknown_rustfmt_attr(&attribute_item.path.segments) =>\n                     {\n-                        let file_name = self.source_map.span_to_filename(attr.span).into();\n+                        let file_name = self.parse_sess.span_to_filename(attr.span);\n                         self.report.append(\n                             file_name,\n                             vec![FormattingError::from_span(\n                                 attr.span,\n-                                self.source_map,\n+                                self.parse_sess,\n                                 ErrorKind::BadAttr,\n                             )],\n                         );\n@@ -928,14 +939,10 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n     }\n \n-    pub(crate) fn format_separate_mod(\n-        &mut self,\n-        m: &ast::Mod,\n-        source_file: &source_map::SourceFile,\n-    ) {\n+    pub(crate) fn format_separate_mod(&mut self, m: &ast::Mod, end_pos: BytePos) {\n         self.block_indent = Indent::empty();\n         self.walk_mod_items(m);\n-        self.format_missing_with_indent(source_file.end_pos);\n+        self.format_missing_with_indent(end_pos);\n     }\n \n     pub(crate) fn skip_empty_lines(&mut self, end_pos: BytePos) {\n@@ -966,8 +973,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n     pub(crate) fn get_context(&self) -> RewriteContext<'_> {\n         RewriteContext {\n-            parse_session: self.parse_session,\n-            source_map: self.source_map,\n+            parse_sess: self.parse_sess,\n             config: self.config,\n             inside_macro: Rc::new(Cell::new(false)),\n             use_block: Cell::new(false),"}, {"sha": "4dfc6ed94e34f1acf717436dc73429980d01916a", "filename": "tests/source/imports.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/tests%2Fsource%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/tests%2Fsource%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fimports.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -3,7 +3,7 @@\n // Imports.\n \n // Long import.\n-use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n+use rustc_ast::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n use exceedingly::looooooooooooooooooooooooooooooooooooooooooooooooooooooooooong::import::path::{ItemA, ItemB};\n use exceedingly::loooooooooooooooooooooooooooooooooooooooooooooooooooooooong::import::path::{ItemA, ItemB};\n \n@@ -15,30 +15,30 @@ use list::{\n \n use test::{  Other          /* C   */  , /*   A   */ self  /*    B     */    };\n \n-use syntax::{self};\n+use rustc_ast::{self};\n use {/* Pre-comment! */\n      Foo, Bar /* comment */};\n use Foo::{Bar, Baz};\n-pub use syntax::ast::{Expr_, Expr, ExprAssign, ExprCall, ExprMethodCall, ExprPath};\n+pub use rustc_ast::ast::{Expr_, Expr, ExprAssign, ExprCall, ExprMethodCall, ExprPath};\n \n-use syntax::some::{};\n+use rustc_ast::some::{};\n \n use self;\n use std::io::{self};\n use std::io::self;\n \n mod Foo {\n-    pub use syntax::ast::{\n+    pub use rustc_ast::ast::{\n         ItemForeignMod,\n-        ItemImpl, \n+        ItemImpl,\n         ItemMac,\n         ItemMod,\n-        ItemStatic, \n+        ItemStatic,\n         ItemDefaultImpl\n     };\n \n     mod Foo2 {\n-        pub use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, self, ItemDefaultImpl};\n+        pub use rustc_ast::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, self, ItemDefaultImpl};\n     }\n }\n "}, {"sha": "7cd80734bd99567ca2d3d63e7ba54f305c7088e5", "filename": "tests/source/issue_4057.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/tests%2Fsource%2Fissue_4057.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/tests%2Fsource%2Fissue_4057.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue_4057.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -0,0 +1,15 @@\n+// rustfmt-format_code_in_doc_comments: true\n+\n+/// ```\n+/// # #[rustversion::since(1.36)]\n+/// # fn dox() {\n+/// # use std::pin::Pin;\n+/// # type Projection<'a> = &'a ();\n+/// # type ProjectionRef<'a> = &'a ();\n+/// # trait Dox {\n+/// fn   project_ex (self: Pin<&mut Self>) -> Projection<'_>;\n+/// fn   project_ref(self: Pin<&Self>) -> ProjectionRef<'_>;\n+/// # }\n+/// # }\n+/// ```\n+struct Foo;"}, {"sha": "87584d89f6637f3dfd6046e99cb12e9c7bfbe3bf", "filename": "tests/target/imports.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/tests%2Ftarget%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/tests%2Ftarget%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -9,7 +9,7 @@ use exceedingly::loooooooooooooooooooooooooooooooooooooooooooooooooooooooong::im\n use exceedingly::looooooooooooooooooooooooooooooooooooooooooooooooooooooooooong::import::path::{\n     ItemA, ItemB,\n };\n-use syntax::ast::{ItemDefaultImpl, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n+use rustc_ast::ast::{ItemDefaultImpl, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n \n use list::{\n     // Another item\n@@ -22,21 +22,21 @@ use list::{\n \n use test::{/* A */ self /* B */, Other /* C */};\n \n-pub use syntax::ast::{Expr, ExprAssign, ExprCall, ExprMethodCall, ExprPath, Expr_};\n-use syntax::{self};\n+pub use rustc_ast::ast::{Expr, ExprAssign, ExprCall, ExprMethodCall, ExprPath, Expr_};\n+use rustc_ast::{self};\n use Foo::{Bar, Baz};\n use {Bar /* comment */, /* Pre-comment! */ Foo};\n \n use std::io;\n use std::io::{self};\n \n mod Foo {\n-    pub use syntax::ast::{\n+    pub use rustc_ast::ast::{\n         ItemDefaultImpl, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic,\n     };\n \n     mod Foo2 {\n-        pub use syntax::ast::{\n+        pub use rustc_ast::ast::{\n             self, ItemDefaultImpl, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic,\n         };\n     }"}, {"sha": "cd8a1f2765f1865c003755601e383de8ab20fbe4", "filename": "tests/target/issue-4068.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/tests%2Ftarget%2Fissue-4068.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/tests%2Ftarget%2Fissue-4068.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-4068.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    extern \"C\" fn packet_records_options_impl_layout_length_encoding_option_len_multiplier();\n+}"}, {"sha": "467e67bca7c3c0626e3262ce08a934f63eff2b44", "filename": "tests/target/issue_4057.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/tests%2Ftarget%2Fissue_4057.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca3d023ff6c970e7dcd6cee3c83672dff14dc15/tests%2Ftarget%2Fissue_4057.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue_4057.rs?ref=5ca3d023ff6c970e7dcd6cee3c83672dff14dc15", "patch": "@@ -0,0 +1,15 @@\n+// rustfmt-format_code_in_doc_comments: true\n+\n+/// ```\n+/// # #[rustversion::since(1.36)]\n+/// # fn dox() {\n+/// # use std::pin::Pin;\n+/// # type Projection<'a> = &'a ();\n+/// # type ProjectionRef<'a> = &'a ();\n+/// # trait Dox {\n+/// fn project_ex(self: Pin<&mut Self>) -> Projection<'_>;\n+/// fn project_ref(self: Pin<&Self>) -> ProjectionRef<'_>;\n+/// # }\n+/// # }\n+/// ```\n+struct Foo;"}]}