{"sha": "c6b82c7566a2e1da7d0f1697335b47c8c999720e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2YjgyYzc1NjZhMmUxZGE3ZDBmMTY5NzMzNWI0N2M4Yzk5OTcyMGU=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-07-10T16:21:16Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-07-15T17:55:21Z"}, "message": "Deprecate `str::from_utf8_lossy`\n\nUse `String::from_utf8_lossy` instead\n\n[breaking-change]", "tree": {"sha": "e2d131432e0f2ad7d1fe56a846feeab03df1791a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2d131432e0f2ad7d1fe56a846feeab03df1791a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6b82c7566a2e1da7d0f1697335b47c8c999720e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6b82c7566a2e1da7d0f1697335b47c8c999720e", "html_url": "https://github.com/rust-lang/rust/commit/c6b82c7566a2e1da7d0f1697335b47c8c999720e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6b82c7566a2e1da7d0f1697335b47c8c999720e/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1900abdd9b5b5eef5d90b43555c1ae06743e50db", "url": "https://api.github.com/repos/rust-lang/rust/commits/1900abdd9b5b5eef5d90b43555c1ae06743e50db", "html_url": "https://github.com/rust-lang/rust/commit/1900abdd9b5b5eef5d90b43555c1ae06743e50db"}], "stats": {"total": 514, "additions": 258, "deletions": 256}, "files": [{"sha": "fb9e41f70bde2bf3cef121d2cdb25af8162bb01f", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 3, "deletions": 195, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=c6b82c7566a2e1da7d0f1697335b47c8c999720e", "patch": "@@ -402,131 +402,10 @@ macro_rules! utf8_acc_cont_byte(\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n )\n \n-static TAG_CONT_U8: u8 = 128u8;\n-\n-/// Converts a vector of bytes to a new utf-8 string.\n-/// Any invalid utf-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// let input = b\"Hello \\xF0\\x90\\x80World\";\n-/// let output = std::str::from_utf8_lossy(input);\n-/// assert_eq!(output.as_slice(), \"Hello \\uFFFDWorld\");\n-/// ```\n+/// Deprecated. Use `String::from_utf8_lossy`.\n+#[deprecated = \"Replaced by String::from_utf8_lossy\"]\n pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n-    if is_utf8(v) {\n-        return Slice(unsafe { mem::transmute(v) })\n-    }\n-\n-    static REPLACEMENT: &'static [u8] = b\"\\xEF\\xBF\\xBD\"; // U+FFFD in UTF-8\n-    let mut i = 0;\n-    let total = v.len();\n-    fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n-        unsafe { *xs.unsafe_ref(i) }\n-    }\n-    fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 {\n-        if i >= total {\n-            0\n-        } else {\n-            unsafe_get(xs, i)\n-        }\n-    }\n-\n-    let mut res = String::with_capacity(total);\n-\n-    if i > 0 {\n-        unsafe {\n-            res.push_bytes(v.slice_to(i))\n-        };\n-    }\n-\n-    // subseqidx is the index of the first byte of the subsequence we're looking at.\n-    // It's used to copy a bunch of contiguous good codepoints at once instead of copying\n-    // them one by one.\n-    let mut subseqidx = 0;\n-\n-    while i < total {\n-        let i_ = i;\n-        let byte = unsafe_get(v, i);\n-        i += 1;\n-\n-        macro_rules! error(() => ({\n-            unsafe {\n-                if subseqidx != i_ {\n-                    res.push_bytes(v.slice(subseqidx, i_));\n-                }\n-                subseqidx = i;\n-                res.push_bytes(REPLACEMENT);\n-            }\n-        }))\n-\n-        if byte < 128u8 {\n-            // subseqidx handles this\n-        } else {\n-            let w = utf8_char_width(byte);\n-\n-            match w {\n-                2 => {\n-                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n-                        error!();\n-                        continue;\n-                    }\n-                    i += 1;\n-                }\n-                3 => {\n-                    match (byte, safe_get(v, i, total)) {\n-                        (0xE0        , 0xA0 .. 0xBF) => (),\n-                        (0xE1 .. 0xEC, 0x80 .. 0xBF) => (),\n-                        (0xED        , 0x80 .. 0x9F) => (),\n-                        (0xEE .. 0xEF, 0x80 .. 0xBF) => (),\n-                        _ => {\n-                            error!();\n-                            continue;\n-                        }\n-                    }\n-                    i += 1;\n-                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n-                        error!();\n-                        continue;\n-                    }\n-                    i += 1;\n-                }\n-                4 => {\n-                    match (byte, safe_get(v, i, total)) {\n-                        (0xF0        , 0x90 .. 0xBF) => (),\n-                        (0xF1 .. 0xF3, 0x80 .. 0xBF) => (),\n-                        (0xF4        , 0x80 .. 0x8F) => (),\n-                        _ => {\n-                            error!();\n-                            continue;\n-                        }\n-                    }\n-                    i += 1;\n-                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n-                        error!();\n-                        continue;\n-                    }\n-                    i += 1;\n-                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n-                        error!();\n-                        continue;\n-                    }\n-                    i += 1;\n-                }\n-                _ => {\n-                    error!();\n-                    continue;\n-                }\n-            }\n-        }\n-    }\n-    if subseqidx < total {\n-        unsafe {\n-            res.push_bytes(v.slice(subseqidx, total))\n-        };\n-    }\n-    Owned(res.into_string())\n+    String::from_utf8_lossy(v)\n }\n \n /*\n@@ -2052,41 +1931,6 @@ String::from_str(\"\\u1111\\u1171\\u11b6\"));\n         assert_eq!(from_utf8(xs), None);\n     }\n \n-    #[test]\n-    fn test_str_from_utf8_lossy() {\n-        let xs = b\"hello\";\n-        assert_eq!(from_utf8_lossy(xs), Slice(\"hello\"));\n-\n-        let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n-        assert_eq!(from_utf8_lossy(xs), Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n-\n-        let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"Hello\\uFFFD There\\uFFFD Goodbye\")));\n-\n-        let xs = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n-        assert_eq!(from_utf8_lossy(xs),\n-                   Owned(String::from_str(\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\")));\n-\n-        let xs = b\"\\xF5foo\\xF5\\x80bar\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFDfoo\\uFFFD\\uFFFDbar\")));\n-\n-        let xs = b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\")));\n-\n-        let xs = b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\";\n-        assert_eq!(from_utf8_lossy(xs),\n-                   Owned(String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\")));\n-\n-        let xs = b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\\n-                                               foo\\U00010000bar\")));\n-\n-        // surrogates\n-        let xs = b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\";\n-        assert_eq!(from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFD\\uFFFD\\uFFFDfoo\\\n-                                               \\uFFFD\\uFFFD\\uFFFDbar\")));\n-    }\n-\n     #[test]\n     fn test_maybe_owned_traits() {\n         let s = Slice(\"abcde\");\n@@ -2296,42 +2140,6 @@ mod bench {\n         });\n     }\n \n-    #[bench]\n-    fn from_utf8_lossy_100_ascii(b: &mut Bencher) {\n-        let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n-                  Lorem ipsum dolor sit amet, consectetur. \";\n-\n-        assert_eq!(100, s.len());\n-        b.iter(|| {\n-            let _ = from_utf8_lossy(s);\n-        });\n-    }\n-\n-    #[bench]\n-    fn from_utf8_lossy_100_multibyte(b: &mut Bencher) {\n-        let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\".as_bytes();\n-        assert_eq!(100, s.len());\n-        b.iter(|| {\n-            let _ = from_utf8_lossy(s);\n-        });\n-    }\n-\n-    #[bench]\n-    fn from_utf8_lossy_invalid(b: &mut Bencher) {\n-        let s = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n-        b.iter(|| {\n-            let _ = from_utf8_lossy(s);\n-        });\n-    }\n-\n-    #[bench]\n-    fn from_utf8_lossy_100_invalid(b: &mut Bencher) {\n-        let s = Vec::from_elem(100, 0xF5u8);\n-        b.iter(|| {\n-            let _ = from_utf8_lossy(s.as_slice());\n-        });\n-    }\n-\n     #[bench]\n     fn bench_connect(b: &mut Bencher) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";"}, {"sha": "d5a666d4b4caa7d47d3adbb50ec98932d0b65552", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 231, "deletions": 34, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=c6b82c7566a2e1da7d0f1697335b47c8c999720e", "patch": "@@ -21,7 +21,7 @@ use core::raw::Slice;\n use {Collection, Mutable};\n use hash;\n use str;\n-use str::{CharRange, StrAllocating};\n+use str::{CharRange, StrAllocating, MaybeOwned, Owned, Slice};\n use vec::Vec;\n \n /// A growable string stored as a UTF-8 encoded buffer.\n@@ -91,7 +91,133 @@ impl String {\n             Err(vec)\n         }\n     }\n-    \n+\n+    /// Converts a vector of bytes to a new utf-8 string.\n+    /// Any invalid utf-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let input = b\"Hello \\xF0\\x90\\x80World\";\n+    /// let output = std::str::from_utf8_lossy(input);\n+    /// assert_eq!(output.as_slice(), \"Hello \\uFFFDWorld\");\n+    /// ```\n+    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n+        if str::is_utf8(v) {\n+            return Slice(unsafe { mem::transmute(v) })\n+        }\n+\n+        static TAG_CONT_U8: u8 = 128u8;\n+        static REPLACEMENT: &'static [u8] = b\"\\xEF\\xBF\\xBD\"; // U+FFFD in UTF-8\n+        let mut i = 0;\n+        let total = v.len();\n+        fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n+            unsafe { *xs.unsafe_ref(i) }\n+        }\n+        fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 {\n+            if i >= total {\n+                0\n+            } else {\n+                unsafe_get(xs, i)\n+            }\n+        }\n+\n+        let mut res = String::with_capacity(total);\n+\n+        if i > 0 {\n+            unsafe {\n+                res.push_bytes(v.slice_to(i))\n+            };\n+        }\n+\n+        // subseqidx is the index of the first byte of the subsequence we're looking at.\n+        // It's used to copy a bunch of contiguous good codepoints at once instead of copying\n+        // them one by one.\n+        let mut subseqidx = 0;\n+\n+        while i < total {\n+            let i_ = i;\n+            let byte = unsafe_get(v, i);\n+            i += 1;\n+\n+            macro_rules! error(() => ({\n+                unsafe {\n+                    if subseqidx != i_ {\n+                        res.push_bytes(v.slice(subseqidx, i_));\n+                    }\n+                    subseqidx = i;\n+                    res.push_bytes(REPLACEMENT);\n+                }\n+            }))\n+\n+            if byte < 128u8 {\n+                // subseqidx handles this\n+            } else {\n+                let w = str::utf8_char_width(byte);\n+\n+                match w {\n+                    2 => {\n+                        if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                            error!();\n+                            continue;\n+                        }\n+                        i += 1;\n+                    }\n+                    3 => {\n+                        match (byte, safe_get(v, i, total)) {\n+                            (0xE0        , 0xA0 .. 0xBF) => (),\n+                            (0xE1 .. 0xEC, 0x80 .. 0xBF) => (),\n+                            (0xED        , 0x80 .. 0x9F) => (),\n+                            (0xEE .. 0xEF, 0x80 .. 0xBF) => (),\n+                            _ => {\n+                                error!();\n+                                continue;\n+                            }\n+                        }\n+                        i += 1;\n+                        if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                            error!();\n+                            continue;\n+                        }\n+                        i += 1;\n+                    }\n+                    4 => {\n+                        match (byte, safe_get(v, i, total)) {\n+                            (0xF0        , 0x90 .. 0xBF) => (),\n+                            (0xF1 .. 0xF3, 0x80 .. 0xBF) => (),\n+                            (0xF4        , 0x80 .. 0x8F) => (),\n+                            _ => {\n+                                error!();\n+                                continue;\n+                            }\n+                        }\n+                        i += 1;\n+                        if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                            error!();\n+                            continue;\n+                        }\n+                        i += 1;\n+                        if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                            error!();\n+                            continue;\n+                        }\n+                        i += 1;\n+                    }\n+                    _ => {\n+                        error!();\n+                        continue;\n+                    }\n+                }\n+            }\n+        }\n+        if subseqidx < total {\n+            unsafe {\n+                res.push_bytes(v.slice(subseqidx, total))\n+            };\n+        }\n+        Owned(res.into_string())\n+    }\n+\n     /// Decode a UTF-16 encoded vector `v` into a string, returning `None`\n     /// if `v` contains any invalid data.\n     ///\n@@ -117,7 +243,7 @@ impl String {\n         }\n         Some(s)\n     }\n-    \n+\n     /// Decode a UTF-16 encoded vector `v` into a string, replacing\n     /// invalid data with the replacement character (U+FFFD).\n     ///\n@@ -449,15 +575,63 @@ mod tests {\n \n     use Mutable;\n     use str;\n-    use str::{Str, StrSlice};\n+    use str::{Str, StrSlice, MaybeOwned, Owned, Slice};\n     use super::String;\n \n     #[test]\n     fn test_from_str() {\n       let owned: Option<::std::string::String> = from_str(\"string\");\n       assert_eq!(owned.as_ref().map(|s| s.as_slice()), Some(\"string\"));\n     }\n-    \n+\n+    #[test]\n+    fn test_from_utf8() {\n+        let xs = Vec::from_slice(b\"hello\");\n+        assert_eq!(String::from_utf8(xs), Ok(\"hello\".to_string()));\n+\n+        let xs = Vec::from_slice(\"\u00e0\u00b8\u00a8\u00e0\u00b9\u201e\u00e0\u00b8\u2014\u00e0\u00b8\u00a2\u00e4\u00b8\u00ad\u00e5\u008d\u017dVi\u00e1\u00bb\u2021t Nam\".as_bytes());\n+        assert_eq!(String::from_utf8(xs), Ok(\"\u00e0\u00b8\u00a8\u00e0\u00b9\u201e\u00e0\u00b8\u2014\u00e0\u00b8\u00a2\u00e4\u00b8\u00ad\u00e5\u008d\u017dVi\u00e1\u00bb\u2021t Nam\".to_string()));\n+\n+        let xs = Vec::from_slice(b\"hello\\xFF\");\n+        assert_eq!(String::from_utf8(xs),\n+                   Err(Vec::from_slice(b\"hello\\xFF\")));\n+    }\n+\n+    #[test]\n+    fn test_from_utf8_lossy() {\n+        let xs = b\"hello\";\n+        assert_eq!(String::from_utf8_lossy(xs), Slice(\"hello\"));\n+\n+        let xs = \"\u00e0\u00b8\u00a8\u00e0\u00b9\u201e\u00e0\u00b8\u2014\u00e0\u00b8\u00a2\u00e4\u00b8\u00ad\u00e5\u008d\u017dVi\u00e1\u00bb\u2021t Nam\".as_bytes();\n+        assert_eq!(String::from_utf8_lossy(xs), Slice(\"\u00e0\u00b8\u00a8\u00e0\u00b9\u201e\u00e0\u00b8\u2014\u00e0\u00b8\u00a2\u00e4\u00b8\u00ad\u00e5\u008d\u017dVi\u00e1\u00bb\u2021t Nam\"));\n+\n+        let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n+        assert_eq!(String::from_utf8_lossy(xs), Owned(String::from_str(\"Hello\\uFFFD There\\uFFFD Goodbye\")));\n+\n+        let xs = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n+        assert_eq!(String::from_utf8_lossy(xs),\n+                   Owned(String::from_str(\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\")));\n+\n+        let xs = b\"\\xF5foo\\xF5\\x80bar\";\n+        assert_eq!(String::from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFDfoo\\uFFFD\\uFFFDbar\")));\n+\n+        let xs = b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\";\n+        assert_eq!(String::from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\")));\n+\n+        let xs = b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\";\n+        assert_eq!(String::from_utf8_lossy(xs),\n+                   Owned(String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\")));\n+\n+        let xs = b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\";\n+        assert_eq!(String::from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\\n+                                               foo\\U00010000bar\")));\n+\n+        // surrogates\n+        let xs = b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\";\n+        assert_eq!(String::from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFD\\uFFFD\\uFFFDfoo\\\n+                                               \\uFFFD\\uFFFD\\uFFFDbar\")));\n+    }\n+\n     #[test]\n     fn test_from_utf16() {\n         let pairs =\n@@ -547,35 +721,6 @@ mod tests {\n                    String::from_str(\"\\uFFFD\u00f0\u0090\u2019\u2039\\uFFFD\"));\n     }\n \n-    #[bench]\n-    fn bench_with_capacity(b: &mut Bencher) {\n-        b.iter(|| {\n-            String::with_capacity(100)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_push_str(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        b.iter(|| {\n-            let mut r = String::new();\n-            r.push_str(s);\n-        });\n-    }\n-\n-    #[test]\n-    fn test_str_from_utf8() {\n-        let xs = Vec::from_slice(b\"hello\");\n-        assert_eq!(String::from_utf8(xs), Ok(\"hello\".to_string()));\n-\n-        let xs = Vec::from_slice(\"\u00e0\u00b8\u00a8\u00e0\u00b9\u201e\u00e0\u00b8\u2014\u00e0\u00b8\u00a2\u00e4\u00b8\u00ad\u00e5\u008d\u017dVi\u00e1\u00bb\u2021t Nam\".as_bytes());\n-        assert_eq!(String::from_utf8(xs), Ok(\"\u00e0\u00b8\u00a8\u00e0\u00b9\u201e\u00e0\u00b8\u2014\u00e0\u00b8\u00a2\u00e4\u00b8\u00ad\u00e5\u008d\u017dVi\u00e1\u00bb\u2021t Nam\".to_string()));\n-\n-        let xs = Vec::from_slice(b\"hello\\xFF\");\n-        assert_eq!(String::from_utf8(xs),\n-                   Err(Vec::from_slice(b\"hello\\xFF\")));\n-    }\n-\n     #[test]\n     fn test_push_bytes() {\n         let mut s = String::from_str(\"ABC\");\n@@ -677,4 +822,56 @@ mod tests {\n         assert_eq!(b.len(), 7);\n         assert_eq!(b.as_slice(), \"1234522\");\n     }\n+\n+    #[bench]\n+    fn bench_with_capacity(b: &mut Bencher) {\n+        b.iter(|| {\n+            String::with_capacity(100)\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_push_str(b: &mut Bencher) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+        b.iter(|| {\n+            let mut r = String::new();\n+            r.push_str(s);\n+        });\n+    }\n+\n+    #[bench]\n+    fn from_utf8_lossy_100_ascii(b: &mut Bencher) {\n+        let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n+                  Lorem ipsum dolor sit amet, consectetur. \";\n+\n+        assert_eq!(100, s.len());\n+        b.iter(|| {\n+            let _ = String::from_utf8_lossy(s);\n+        });\n+    }\n+\n+    #[bench]\n+    fn from_utf8_lossy_100_multibyte(b: &mut Bencher) {\n+        let s = \"\u00f0\u0090\u0152\u20ac\u00f0\u0090\u0152\u2013\u00f0\u0090\u0152\u2039\u00f0\u0090\u0152\u201e\u00f0\u0090\u0152\u2018\u00f0\u0090\u0152\u2030\u00e0\u00b8\u203a\u00e0\u00b8\u00a3\u00d8\u00af\u00d9\u02c6\u00d9\u201e\u00d8\u00a9 \u00d8\u00a7\u00d9\u201e\u00d9\u0192\u00d9\u02c6\u00d9\u0160\u00d8\u00aa\u00e0\u00b8\u2014\u00e0\u00b8\u00a8\u00e0\u00b9\u201e\u00e0\u00b8\u2014\u00e0\u00b8\u00a2\u00e4\u00b8\u00ad\u00e5\u008d\u017d\u00f0\u0090\u008d\u2026\u00f0\u0090\u0152\u00bf\u00f0\u0090\u0152\u00bb\u00f0\u0090\u008d\u2020\u00f0\u0090\u0152\u00b9\u00f0\u0090\u0152\u00bb\u00f0\u0090\u0152\u00b0\".as_bytes();\n+        assert_eq!(100, s.len());\n+        b.iter(|| {\n+            let _ = String::from_utf8_lossy(s);\n+        });\n+    }\n+\n+    #[bench]\n+    fn from_utf8_lossy_invalid(b: &mut Bencher) {\n+        let s = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n+        b.iter(|| {\n+            let _ = String::from_utf8_lossy(s);\n+        });\n+    }\n+\n+    #[bench]\n+    fn from_utf8_lossy_100_invalid(b: &mut Bencher) {\n+        let s = Vec::from_elem(100, 0xF5u8);\n+        b.iter(|| {\n+            let _ = String::from_utf8_lossy(s.as_slice());\n+        });\n+    }\n }"}, {"sha": "6fa8a1530234e15b4f4f8392deb327be96b0c89e", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=c6b82c7566a2e1da7d0f1697335b47c8c999720e", "patch": "@@ -61,7 +61,7 @@ pub fn llvm_err(sess: &Session, msg: String) -> ! {\n             sess.fatal(msg.as_slice());\n         } else {\n             let err = CString::new(cstr, true);\n-            let err = str::from_utf8_lossy(err.as_bytes());\n+            let err = String::from_utf8_lossy(err.as_bytes());\n             sess.fatal(format!(\"{}: {}\",\n                                msg.as_slice(),\n                                err.as_slice()).as_slice());"}, {"sha": "5be0575532a3f025f274f90c0f7be09b9946209d", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=c6b82c7566a2e1da7d0f1697335b47c8c999720e", "patch": "@@ -37,7 +37,7 @@ pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n          class,\n          id,\n          &mut out).unwrap();\n-    str::from_utf8_lossy(out.unwrap().as_slice()).to_string()\n+    String::from_utf8_lossy(out.unwrap().as_slice()).into_string()\n }\n \n /// Exhausts the `lexer` writing the output into `out`."}, {"sha": "1f18200f5aad4ffbd11e5bab7ed1067de24d0135", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=c6b82c7566a2e1da7d0f1697335b47c8c999720e", "patch": "@@ -313,16 +313,15 @@ impl Command {\n     ///\n     /// ```\n     /// use std::io::Command;\n-    /// use std::str;\n     ///\n     /// let output = match Command::new(\"cat\").arg(\"foot.txt\").output() {\n     ///     Ok(output) => output,\n     ///     Err(e) => fail!(\"failed to execute process: {}\", e),\n     /// };\n     ///\n     /// println!(\"status: {}\", output.status);\n-    /// println!(\"stdout: {}\", str::from_utf8_lossy(output.output.as_slice()));\n-    /// println!(\"stderr: {}\", str::from_utf8_lossy(output.error.as_slice()));\n+    /// println!(\"stdout: {}\", String::from_utf8_lossy(output.output.as_slice()));\n+    /// println!(\"stderr: {}\", String::from_utf8_lossy(output.error.as_slice()));\n     /// ```\n     pub fn output(&self) -> IoResult<ProcessOutput> {\n         self.spawn().and_then(|p| p.wait_with_output())\n@@ -353,9 +352,9 @@ impl fmt::Show for Command {\n     /// non-utf8 data is lossily converted using the utf8 replacement\n     /// character.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{}\", str::from_utf8_lossy(self.program.as_bytes_no_nul())));\n+        try!(write!(f, \"{}\", String::from_utf8_lossy(self.program.as_bytes_no_nul())));\n         for arg in self.args.iter() {\n-            try!(write!(f, \" '{}'\", str::from_utf8_lossy(arg.as_bytes_no_nul())));\n+            try!(write!(f, \" '{}'\", String::from_utf8_lossy(arg.as_bytes_no_nul())));\n         }\n         Ok(())\n     }\n@@ -903,7 +902,7 @@ mod tests {\n         let new_env = vec![(\"RUN_TEST_NEW_ENV\", \"123\")];\n         let prog = env_cmd().env_set_all(new_env.as_slice()).spawn().unwrap();\n         let result = prog.wait_with_output().unwrap();\n-        let output = str::from_utf8_lossy(result.output.as_slice()).into_string();\n+        let output = String::from_utf8_lossy(result.output.as_slice()).into_string();\n \n         assert!(output.as_slice().contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);"}, {"sha": "11b787f0b9acb76cce8613b6bc29e5fd8cf13167", "filename": "src/libstd/os.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=c6b82c7566a2e1da7d0f1697335b47c8c999720e", "patch": "@@ -208,7 +208,7 @@ fn with_env_lock<T>(f: || -> T) -> T {\n /// Returns a vector of (variable, value) pairs, for all the environment\n /// variables of the current process.\n ///\n-/// Invalid UTF-8 bytes are replaced with \\uFFFD. See `str::from_utf8_lossy()`\n+/// Invalid UTF-8 bytes are replaced with \\uFFFD. See `String::from_utf8_lossy()`\n /// for details.\n ///\n /// # Example\n@@ -223,8 +223,8 @@ fn with_env_lock<T>(f: || -> T) -> T {\n /// ```\n pub fn env() -> Vec<(String,String)> {\n     env_as_bytes().move_iter().map(|(k,v)| {\n-        let k = String::from_str(str::from_utf8_lossy(k.as_slice()).as_slice());\n-        let v = String::from_str(str::from_utf8_lossy(v.as_slice()).as_slice());\n+        let k = String::from_utf8_lossy(k.as_slice()).into_string();\n+        let v = String::from_utf8_lossy(v.as_slice()).into_string();\n         (k,v)\n     }).collect()\n }\n@@ -316,7 +316,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n /// None if the variable isn't set.\n ///\n /// Any invalid UTF-8 bytes in the value are replaced by \\uFFFD. See\n-/// `str::from_utf8_lossy()` for details.\n+/// `String::from_utf8_lossy()` for details.\n ///\n /// # Failure\n ///\n@@ -334,7 +334,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n /// }\n /// ```\n pub fn getenv(n: &str) -> Option<String> {\n-    getenv_as_bytes(n).map(|v| String::from_str(str::from_utf8_lossy(v.as_slice()).as_slice()))\n+    getenv_as_bytes(n).map(|v| String::from_utf8_lossy(v.as_slice()).into_string())\n }\n \n #[cfg(unix)]\n@@ -1186,7 +1186,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n fn real_args() -> Vec<String> {\n     real_args_as_bytes().move_iter()\n                         .map(|v| {\n-                            str::from_utf8_lossy(v.as_slice()).into_string()\n+                            String::from_utf8_lossy(v.as_slice()).into_string()\n                         }).collect()\n }\n \n@@ -1244,7 +1244,7 @@ extern \"system\" {\n /// via the command line).\n ///\n /// The arguments are interpreted as utf-8, with invalid bytes replaced with \\uFFFD.\n-/// See `str::from_utf8_lossy` for details.\n+/// See `String::from_utf8_lossy` for details.\n /// # Example\n ///\n /// ```rust"}, {"sha": "ececfab5f743301a4e241b1cf85da2b3ab9e1161", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=c6b82c7566a2e1da7d0f1697335b47c8c999720e", "patch": "@@ -72,7 +72,7 @@ use fmt;\n use iter::Iterator;\n use option::{Option, None, Some};\n use str;\n-use str::{MaybeOwned, Str, StrSlice, from_utf8_lossy};\n+use str::{MaybeOwned, Str, StrSlice};\n use string::String;\n use slice::Vector;\n use slice::{ImmutableEqVector, ImmutableVector};\n@@ -483,7 +483,7 @@ impl<'a, P: GenericPath> Display<'a, P> {\n     /// unicode replacement char. This involves allocation.\n     #[inline]\n     pub fn as_maybe_owned(&self) -> MaybeOwned<'a> {\n-        from_utf8_lossy(if self.filename {\n+        String::from_utf8_lossy(if self.filename {\n             match self.path.filename() {\n                 None => &[],\n                 Some(v) => v"}, {"sha": "a857bc7535d9c3250061f2f376dede132923c088", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=c6b82c7566a2e1da7d0f1697335b47c8c999720e", "patch": "@@ -60,7 +60,6 @@ use std::io::stdio::StdWriter;\n use std::io::{File, ChanReader, ChanWriter};\n use std::io;\n use std::os;\n-use std::str;\n use std::string::String;\n use std::task::TaskBuilder;\n \n@@ -636,7 +635,7 @@ impl<T: Writer> ConsoleTestState<T> {\n             if stdout.len() > 0 {\n                 fail_out.push_str(format!(\"---- {} stdout ----\\n\\t\",\n                                           f.name.as_slice()).as_slice());\n-                let output = str::from_utf8_lossy(stdout.as_slice());\n+                let output = String::from_utf8_lossy(stdout.as_slice());\n                 fail_out.push_str(output.as_slice()\n                                         .replace(\"\\n\", \"\\n\\t\")\n                                         .as_slice());\n@@ -873,7 +872,7 @@ fn should_sort_failures_before_printing_them() {\n \n     st.write_failures().unwrap();\n     let s = match st.out {\n-        Raw(ref m) => str::from_utf8_lossy(m.get_ref()),\n+        Raw(ref m) => String::from_utf8_lossy(m.get_ref()),\n         Pretty(_) => unreachable!()\n     };\n "}, {"sha": "c436958171d3be1081befc91f90935a7c20ed077", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=c6b82c7566a2e1da7d0f1697335b47c8c999720e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{char, os, str};\n+use std::{char, os};\n use std::io::{File, Command};\n use std::rand::{task_rng, Rng};\n \n@@ -61,7 +61,7 @@ fn main() {\n                                           main_file.as_str()\n                                                    .unwrap()).as_slice())\n                              .output().unwrap();\n-        let err = str::from_utf8_lossy(result.error.as_slice());\n+        let err = String::from_utf8_lossy(result.error.as_slice());\n \n         // positive test so that this test will be updated when the\n         // compiler changes."}, {"sha": "913f1318ebf846e0d5226ab1f7267b1802f4df98", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=c6b82c7566a2e1da7d0f1697335b47c8c999720e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{char, os, str};\n+use std::{char, os};\n use std::io::{File, Command};\n use std::rand::{task_rng, Rng};\n \n@@ -57,7 +57,7 @@ fn main() {\n                                                    .unwrap()).as_slice())\n                              .output().unwrap();\n \n-        let err = str::from_utf8_lossy(result.error.as_slice());\n+        let err = String::from_utf8_lossy(result.error.as_slice());\n \n         // the span should end the line (e.g no extra ~'s)\n         let expected_span = format!(\"^{}\\n\", \"~\".repeat(n - 1));"}, {"sha": "7f2f9f9ece83de1ffc9398d49b99b99db0be3ea2", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b82c7566a2e1da7d0f1697335b47c8c999720e/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=c6b82c7566a2e1da7d0f1697335b47c8c999720e", "patch": "@@ -12,7 +12,6 @@\n \n use std::io::process::Command;\n use std::os;\n-use std::str;\n \n // lifted from the test module\n // Inlining to avoid llvm turning the recursive functions into tail calls,\n@@ -42,12 +41,12 @@ fn main() {\n     } else {\n         let silent = Command::new(args[0].as_slice()).arg(\"silent\").output().unwrap();\n         assert!(!silent.status.success());\n-        let error = str::from_utf8_lossy(silent.error.as_slice());\n+        let error = String::from_utf8_lossy(silent.error.as_slice());\n         assert!(error.as_slice().contains(\"has overflowed its stack\"));\n \n         let loud = Command::new(args[0].as_slice()).arg(\"loud\").output().unwrap();\n         assert!(!loud.status.success());\n-        let error = str::from_utf8_lossy(silent.error.as_slice());\n+        let error = String::from_utf8_lossy(silent.error.as_slice());\n         assert!(error.as_slice().contains(\"has overflowed its stack\"));\n     }\n }"}]}