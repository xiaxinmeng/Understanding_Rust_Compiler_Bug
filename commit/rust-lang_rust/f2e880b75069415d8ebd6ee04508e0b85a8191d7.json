{"sha": "f2e880b75069415d8ebd6ee04508e0b85a8191d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyZTg4MGI3NTA2OTQxNWQ4ZWJkNmVlMDQ1MDhlMGI4NWE4MTkxZDc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-14T08:10:47Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-14T12:43:36Z"}, "message": "Add [X].len() to core, use it in trans modules", "tree": {"sha": "d11e54f43be29d908db70833a17cb0d839ec87b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d11e54f43be29d908db70833a17cb0d839ec87b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2e880b75069415d8ebd6ee04508e0b85a8191d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2e880b75069415d8ebd6ee04508e0b85a8191d7", "html_url": "https://github.com/rust-lang/rust/commit/f2e880b75069415d8ebd6ee04508e0b85a8191d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2e880b75069415d8ebd6ee04508e0b85a8191d7/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3dba33043b4406ee4a2da5ca6e06d899e5c81cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3dba33043b4406ee4a2da5ca6e06d899e5c81cc", "html_url": "https://github.com/rust-lang/rust/commit/f3dba33043b4406ee4a2da5ca6e06d899e5c81cc"}], "stats": {"total": 165, "additions": 83, "deletions": 82}, "files": [{"sha": "bc5d12ea96ae12b881b975a6bc7a650265af023f", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=f2e880b75069415d8ebd6ee04508e0b85a8191d7", "patch": "@@ -106,7 +106,7 @@ fn expand_nested_bindings(m: match, col: uint, val: ValueRef) -> match {\n       alt br.pats[col].node {\n           ast::pat_ident(name, some(inner)) {\n             let pats = vec::slice(br.pats, 0u, col) + [inner] +\n-                vec::slice(br.pats, col + 1u, vec::len(br.pats));\n+                vec::slice(br.pats, col + 1u, br.pats.len());\n             result += [@{pats: pats,\n                         bound: br.bound + [{ident: path_to_ident(name),\n                                 val: val}]\n@@ -126,7 +126,7 @@ fn enter_match(m: match, col: uint, val: ValueRef, e: enter_pat) -> match {\n         alt e(br.pats[col]) {\n           some(sub) {\n             let pats = sub + vec::slice(br.pats, 0u, col) +\n-                vec::slice(br.pats, col + 1u, vec::len(br.pats));\n+                vec::slice(br.pats, col + 1u, br.pats.len());\n             let new_br = @{pats: pats,\n                            bound: alt br.pats[col].node {\n                              ast::pat_ident(name, none) {\n@@ -197,7 +197,7 @@ fn enter_rec(m: match, col: uint, fields: [ast::ident], val: ValueRef) ->\n             }\n             ret some(pats);\n           }\n-          _ { ret some(vec::init_elt(vec::len(fields), dummy)); }\n+          _ { ret some(vec::init_elt(fields.len(), dummy)); }\n         }\n     }\n     ret enter_match(m, col, val, bind e(dummy, fields, _));\n@@ -269,9 +269,9 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n     let blobptr = val;\n     let variants = ty::enum_variants(ccx.tcx, vdefs.enm);\n     let args = [];\n-    let size =\n-       vec::len(ty::enum_variant_with_id(ccx.tcx, vdefs.enm, vdefs.var).args);\n-    if size > 0u && vec::len(*variants) != 1u {\n+    let size = ty::enum_variant_with_id(ccx.tcx, vdefs.enm,\n+                                        vdefs.var).args.len();\n+    if size > 0u && (*variants).len() != 1u {\n         let enumptr =\n             PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n         blobptr = GEPi(bcx, enumptr, [0, 1]);\n@@ -343,7 +343,7 @@ fn pick_col(m: match) -> uint {\n           _ { 0u }\n         }\n     }\n-    let scores = vec::init_elt_mut(vec::len(m[0].pats), 0u);\n+    let scores = vec::init_elt_mut(m[0].pats.len(), 0u);\n     for br: match_branch in m {\n         let i = 0u;\n         for p: @ast::pat in br.pats { scores[i] += score(p); i += 1u; }\n@@ -366,8 +366,8 @@ fn pick_col(m: match) -> uint {\n fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n                     &exits: [exit_node]) {\n     let bcx = bcx;\n-    if vec::len(m) == 0u { Br(bcx, f()); ret; }\n-    if vec::len(m[0].pats) == 0u {\n+    if m.len() == 0u { Br(bcx, f()); ret; }\n+    if m[0].pats.len() == 0u {\n         let data = m[0].data;\n         alt data.guard {\n           some(e) {\n@@ -385,7 +385,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n             let next_cx = new_sub_block_ctxt(guard_cx, \"submatch_next\");\n             let else_cx = new_sub_block_ctxt(guard_cx, \"submatch_else\");\n             CondBr(guard_bcx, guard_val, next_cx.llbb, else_cx.llbb);\n-            compile_submatch(else_cx, vec::slice(m, 1u, vec::len(m)), vals, f,\n+            compile_submatch(else_cx, vec::slice(m, 1u, m.len()), vals, f,\n                              exits);\n             bcx = next_cx;\n           }\n@@ -408,7 +408,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n \n     let vals_left =\n         vec::slice(vals, 0u, col) +\n-            vec::slice(vals, col + 1u, vec::len(vals));\n+            vec::slice(vals, col + 1u, vals.len());\n     let ccx = bcx.fcx.ccx;\n     let pat_id = 0;\n     for br: match_branch in m {\n@@ -419,7 +419,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n \n     let rec_fields = collect_record_fields(m, col);\n     // Separate path for extracting and binding record fields\n-    if vec::len(rec_fields) > 0u {\n+    if rec_fields.len() > 0u {\n         let rec_ty = node_id_type(bcx, pat_id);\n         let fields = ty::get_fields(rec_ty);\n         let rec_vals = [];\n@@ -437,7 +437,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     if any_tup_pat(m, col) {\n         let tup_ty = node_id_type(bcx, pat_id);\n         let n_tup_elts = alt ty::get(tup_ty).struct {\n-          ty::ty_tup(elts) { vec::len(elts) }\n+          ty::ty_tup(elts) { elts.len() }\n           _ { ccx.sess.bug(\"Non-tuple type in tuple pattern\"); }\n         };\n         let tup_vals = [], i = 0u;\n@@ -473,10 +473,10 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     enum branch_kind { no_branch, single, switch, compare, }\n     let kind = no_branch;\n     let test_val = val;\n-    if vec::len(opts) > 0u {\n+    if opts.len() > 0u {\n         alt opts[0] {\n           var(_, vdef) {\n-            if vec::len(*ty::enum_variants(ccx.tcx, vdef.enm)) == 1u {\n+            if (*ty::enum_variants(ccx.tcx, vdef.enm)).len() == 1u {\n                 kind = single;\n             } else {\n                 let enumptr =\n@@ -511,7 +511,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n         };\n     let sw;\n     if kind == switch {\n-        sw = Switch(bcx, test_val, else_cx.llbb, vec::len(opts));\n+        sw = Switch(bcx, test_val, else_cx.llbb, opts.len());\n         // FIXME This statement is purely here as a work-around for a bug that\n         // I expect to be the same as issue #951. If I remove it, sw ends up\n         // holding a corrupted value (when the compiler is optimized).\n@@ -573,7 +573,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n         alt opt {\n           var(_, vdef) {\n             let args = extract_variant_args(opt_cx, pat_id, vdef, val);\n-            size = vec::len(args.vals);\n+            size = args.vals.len();\n             unpacked = args.vals;\n             opt_cx = args.bcx;\n           }\n@@ -607,7 +607,7 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n                 }\n             }\n         }\n-        if vec::len(vals) > 0u {\n+        if vals.len() > 0u {\n             let local = Phi(bcx, val_ty(vals[0]), vals, llbbs);\n             bcx.fcx.lllocals.insert(node_id, local_mem(local));\n         } else { success = false; }\n@@ -728,7 +728,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         }\n       }\n       ast::pat_enum(_, sub) {\n-        if vec::len(sub) == 0u { ret bcx; }\n+        if sub.len() == 0u { ret bcx; }\n         let vdefs = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n         let args = extract_variant_args(bcx, pat.id, vdefs, val);\n         let i = 0;"}, {"sha": "9bf815c459bf5d87dc792c44682128b88311c387", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=f2e880b75069415d8ebd6ee04508e0b85a8191d7", "patch": "@@ -162,7 +162,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n \n fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     -> TypeRef {\n-    let degen = vec::len(*ty::enum_variants(cx.tcx, did)) == 1u;\n+    let degen = (*ty::enum_variants(cx.tcx, did)).len() == 1u;\n     if check type_has_static_size(cx, t) {\n         let size = static_size_of_enum(cx, t);\n         if !degen { T_enum(cx, size) }\n@@ -289,7 +289,7 @@ fn get_simple_extern_fn(cx: @block_ctxt,\n fn trans_native_call(cx: @block_ctxt, externs: hashmap<str, ValueRef>,\n                      llmod: ModuleRef, name: str, args: [ValueRef]) ->\n    ValueRef {\n-    let n: int = vec::len::<ValueRef>(args) as int;\n+    let n = args.len() as int;\n     let llnative: ValueRef =\n         get_simple_extern_fn(cx, externs, llmod, name, n);\n     let call_args: [ValueRef] = [];\n@@ -388,7 +388,7 @@ fn GEP_tup_like(bcx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n                    t: ty::t,\n                    ixs: [int],\n                    n: uint) -> (@block_ctxt, ValueRef, ty::t) {\n-        if n == vec::len(ixs) {\n+        if n == ixs.len() {\n             ret (bcx, off, t);\n         }\n \n@@ -638,8 +638,8 @@ fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n     // promising to do so itself.\n     let n_params = ty::count_ty_params(bcx_tcx(bcx), t);\n \n-    assert (n_params == vec::len::<uint>(tys.params));\n-    assert (n_params == vec::len::<ValueRef>(tys.descs));\n+    assert n_params == tys.params.len();\n+    assert n_params == tys.descs.len();\n \n     let llparamtydescs =\n         alloca(bcx, T_array(T_ptr(bcx_ccx(bcx).tydesc_type), n_params + 1u));\n@@ -687,7 +687,7 @@ fn get_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n     alt ty::type_param(t) {\n       some(id) {\n-        if id < vec::len(cx.fcx.lltyparams) {\n+        if id < cx.fcx.lltyparams.len() {\n             ret {kind: tk_param,\n                  result: rslt(cx, cx.fcx.lltyparams[id].desc)};\n         } else {\n@@ -821,7 +821,7 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n         T_ptr(type_of(ccx, t))\n     } else { T_ptr(T_i8()) };\n \n-    let ty_param_count = vec::len(ty_params);\n+    let ty_param_count = ty_params.len();\n     let lltyparams = llvm::LLVMGetParam(llfn, 2u as c_uint);\n     let load_env_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n     let lltydescs = [mutable];\n@@ -1072,7 +1072,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n     // for type variables.\n     let val_llty = lib::llvm::fn_ty_param_tys\n         (llvm::LLVMGetElementType\n-         (llvm::LLVMTypeOf(dtor_addr)))[vec::len(args)];\n+         (llvm::LLVMTypeOf(dtor_addr)))[args.len()];\n     let val_cast = BitCast(cx, val.val, val_llty);\n     Call(cx, dtor_addr, args + [val_cast]);\n \n@@ -1244,7 +1244,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n     fn iter_variant(cx: @block_ctxt, a_tup: ValueRef,\n                     variant: ty::variant_info, tps: [ty::t], tid: ast::def_id,\n                     f: val_and_ty_fn) -> @block_ctxt {\n-        if vec::len::<ty::t>(variant.args) == 0u { ret cx; }\n+        if variant.args.len() == 0u { ret cx; }\n         let fn_ty = variant.ctor_ty;\n         let ccx = bcx_ccx(cx);\n         let cx = cx;\n@@ -1299,7 +1299,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n       }\n       ty::ty_enum(tid, tps) {\n         let variants = ty::enum_variants(bcx_tcx(cx), tid);\n-        let n_variants = vec::len(*variants);\n+        let n_variants = (*variants).len();\n \n         // Cast the enums to types we can GEP into.\n         if n_variants == 1u {\n@@ -1912,8 +1912,7 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n           }\n           ty::ty_enum(did, tps) {\n             let variants = ty::enum_variants(ccx.tcx, did);\n-            if vec::len(*variants) != 1u ||\n-                   vec::len(variants[0].args) != 1u {\n+            if (*variants).len() != 1u || variants[0].args.len() != 1u {\n                 break;\n             }\n             t1 =\n@@ -2278,7 +2277,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n         let this_tv = option::get(vec::find(*tvs, {|tv|\n             tv.id.node == fn_id.node}));\n         trans_enum_variant(ccx, enum_id.node, v, this_tv.disr_val,\n-                           vec::len(*tvs) == 1u, [], psubsts, lldecl);\n+                           (*tvs).len() == 1u, [], psubsts, lldecl);\n       }\n       ast_map::node_method(mth, impl_id, _) {\n         let selfty = ty::node_id_to_type(ccx.tcx, impl_id);\n@@ -2301,12 +2300,12 @@ fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id,\n     // monomorphized and non-monomorphized functions at the moment. If\n     // monomorphizing becomes the only approach, this'll be much simpler.\n     if ccx.sess.opts.monomorphize &&\n-       (option::is_some(substs) || vec::len(tys) > 0u) &&\n+       (option::is_some(substs) || tys.len() > 0u) &&\n        fn_id.crate == ast::local_crate &&\n        !vec::any(tys, {|t| ty::type_has_params(t)}) {\n         let mono = alt substs {\n           some((stys, dicts)) {\n-            if (vec::len(stys) + vec::len(tys)) > 0u {\n+            if (stys.len() + tys.len()) > 0u {\n                 monomorphic_fn(ccx, fn_id, stys + tys, some(dicts))\n             } else { none }\n           }\n@@ -2340,7 +2339,7 @@ fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id,\n         trans_external_path(bcx, fn_id, tpt)\n     };\n     let gen = generic_none, bcx = bcx;\n-    if vec::len(tys) > 0u {\n+    if tys.len() > 0u {\n         let tydescs = [], tis = [];\n         for t in tys {\n             // TODO: Doesn't always escape.\n@@ -2424,7 +2423,7 @@ fn trans_var(cx: @block_ctxt, def: ast::def, id: ast::node_id)\n         ret lval_static_fn(cx, did, id, none);\n       }\n       ast::def_variant(tid, vid) {\n-        if vec::len(ty::enum_variant_with_id(ccx.tcx, tid, vid).args) > 0u {\n+        if ty::enum_variant_with_id(ccx.tcx, tid, vid).args.len() > 0u {\n             // N-ary variant.\n             ret lval_static_fn(cx, vid, id, none);\n         } else {\n@@ -2616,7 +2615,7 @@ fn maybe_add_env(bcx: @block_ctxt, c: lval_maybe_callee)\n fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n     alt c.generic {\n       generic_full(gi) {\n-        let n_args = vec::len(ty::ty_fn_args(ty));\n+        let n_args = ty::ty_fn_args(ty).len();\n         let args = vec::init_elt(n_args, none::<@ast::expr>);\n         let space = alloc_ty(c.bcx, ty);\n         let bcx = closure::trans_bind_1(space.bcx, ty, c, args, ty,\n@@ -3877,10 +3876,8 @@ fn new_raw_block_ctxt(fcx: @fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n fn trans_block_cleanups(bcx: @block_ctxt, cleanup_cx: @block_ctxt) ->\n    @block_ctxt {\n     if bcx.unreachable { ret bcx; }\n-    if cleanup_cx.kind == NON_SCOPE_BLOCK {\n-        assert (vec::len::<cleanup>(cleanup_cx.cleanups) == 0u);\n-    }\n-    let i = vec::len::<cleanup>(cleanup_cx.cleanups), bcx = bcx;\n+    let i = cleanup_cx.cleanups.len(), bcx = bcx;\n+    if cleanup_cx.kind == NON_SCOPE_BLOCK { assert i == 0u; }\n     while i > 0u {\n         i -= 1u;\n         let c = cleanup_cx.cleanups[i];\n@@ -4535,7 +4532,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n         let bcx = new_top_block_ctxt(fcx, none);\n         let lltop = bcx.llbb;\n         let llargbundle = llvm::LLVMGetParam(llshimfn, 0 as c_uint);\n-        let i = 0u, n = vec::len(tys.arg_tys);\n+        let i = 0u, n = tys.arg_tys.len();\n         let llargvals = [];\n         while i < n {\n             let llargval = load_inbounds(bcx, llargbundle, [0, i as int]);\n@@ -4573,7 +4570,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n \n         // Allocate the struct and write the arguments into it.\n         let llargbundle = alloca(bcx, tys.bundle_ty);\n-        let i = 0u, n = vec::len(tys.arg_tys);\n+        let i = 0u, n = tys.arg_tys.len();\n         let implicit_args = 2u + num_tps; // ret + env\n         while i < n {\n             let llargval = llvm::LLVMGetParam(llwrapfn,\n@@ -4608,7 +4605,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n           alt ccx.item_ids.find(id) {\n             some(llwrapfn) {\n               let llshimfn = build_shim_fn(ccx, native_item, tys, cc);\n-              build_wrap_fn(ccx, tys, vec::len(tps), llshimfn, llwrapfn);\n+              build_wrap_fn(ccx, tys, tps.len(), llshimfn, llwrapfn);\n             }\n             none {\n               ccx.sess.span_fatal(\n@@ -4661,11 +4658,11 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         trans_mod(ccx, m);\n       }\n       ast::item_enum(variants, tps) {\n-        let degen = vec::len(variants) == 1u;\n+        let degen = variants.len() == 1u;\n         let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n         let i = 0;\n         for variant: ast::variant in variants {\n-            if vec::len(variant.node.args) > 0u {\n+            if variant.node.args.len() > 0u {\n                 trans_enum_variant(ccx, item.id, variant,\n                                    vi[i].disr_val, degen, tps,\n                                    none, ccx.item_ids.get(variant.node.id));\n@@ -4737,7 +4734,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n     let main_takes_argv =\n         // invariant!\n         alt ty::get(main_node_type).struct {\n-          ty::ty_fn({inputs, _}) { vec::len(inputs) != 0u }\n+          ty::ty_fn({inputs, _}) { inputs.len() != 0u }\n           _ { ccx.sess.span_fatal(sp, \"main has a non-function type\"); }\n         };\n \n@@ -4800,7 +4797,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n                     llvm::LLVMGetParam(llfn, 1 as c_uint), crate_map];\n         let result = unsafe {\n             llvm::LLVMBuildCall(bld, start, vec::to_ptr(args),\n-                                vec::len(args) as c_uint, noname())\n+                                args.len() as c_uint, noname())\n         };\n         llvm::LLVMBuildRet(bld, result);\n     }\n@@ -4938,7 +4935,7 @@ fn collect_item(ccx: @crate_ctxt, abi: @mutable option<ast::native_abi>,\n       }\n       ast::item_enum(variants, tps) {\n         for variant in variants {\n-            if vec::len(variant.node.args) != 0u {\n+            if variant.node.args.len() != 0u {\n                 register_fn(ccx, i.span,\n                             my_path + [path_name(variant.node.name)],\n                             \"enum\", tps, variant.node.id);"}, {"sha": "a65636d0e623b064cf34457eb90b3bd3bf1487ec", "filename": "src/comp/middle/trans/build.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs?ref=f2e880b75069415d8ebd6ee04508e0b85a8191d7", "patch": "@@ -43,7 +43,7 @@ fn AggregateRet(cx: @block_ctxt, RetVals: [ValueRef]) {\n     cx.terminated = true;\n     unsafe {\n         llvm::LLVMBuildAggregateRet(B(cx), vec::to_ptr(RetVals),\n-                                    vec::len(RetVals) as c_uint);\n+                                    RetVals.len() as c_uint);\n     }\n }\n \n@@ -100,7 +100,7 @@ fn Invoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n                         \", \")];\n     unsafe {\n         llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n-                              vec::len(Args) as c_uint, Then, Catch,\n+                              Args.len() as c_uint, Then, Catch,\n                               noname());\n     }\n }\n@@ -112,7 +112,7 @@ fn FastInvoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n     cx.terminated = true;\n     unsafe {\n         let v = llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n-                                      vec::len(Args) as c_uint,\n+                                      Args.len() as c_uint,\n                                       Then, Catch, noname());\n         lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n     }\n@@ -330,7 +330,7 @@ fn GEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n         ret llvm::LLVMBuildGEP(B(cx), Pointer, vec::to_ptr(Indices),\n-                               vec::len(Indices) as c_uint, noname());\n+                               Indices.len() as c_uint, noname());\n     }\n }\n \n@@ -348,7 +348,7 @@ fn InBoundsGEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) ->\n     unsafe {\n         ret llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n                                        vec::to_ptr(Indices),\n-                                       vec::len(Indices) as c_uint,\n+                                       Indices.len() as c_uint,\n                                        noname());\n     }\n }\n@@ -491,11 +491,11 @@ fn EmptyPhi(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n fn Phi(cx: @block_ctxt, Ty: TypeRef, vals: [ValueRef], bbs: [BasicBlockRef])\n    -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n-    assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n+    assert vals.len() == bbs.len();\n     let phi = EmptyPhi(cx, Ty);\n     unsafe {\n         llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n-                              vec::len(vals) as c_uint);\n+                              vals.len() as c_uint);\n         ret phi;\n     }\n }\n@@ -547,15 +547,15 @@ fn Call(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n         ret llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n-                                vec::len(Args) as c_uint, noname());\n+                                Args.len() as c_uint, noname());\n     }\n }\n \n fn FastCall(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n-                                    vec::len(Args) as c_uint, noname());\n+                                    Args.len() as c_uint, noname());\n         lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n         ret v;\n     }\n@@ -566,7 +566,7 @@ fn CallWithConv(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n-                                    vec::len(Args) as c_uint, noname());\n+                                    Args.len() as c_uint, noname());\n         lib::llvm::SetInstructionCallConv(v, Conv);\n         ret v;\n     }\n@@ -642,7 +642,7 @@ fn Trap(cx: @block_ctxt) {\n     let Args: [ValueRef] = [];\n     unsafe {\n         llvm::LLVMBuildCall(b, T, vec::to_ptr(Args),\n-                            vec::len(Args) as c_uint, noname());\n+                            Args.len() as c_uint, noname());\n     }\n }\n "}, {"sha": "16466eb092ae6275c068b6835b12d80f1db41794", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=f2e880b75069415d8ebd6ee04508e0b85a8191d7", "patch": "@@ -529,7 +529,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n       _ { (outgoing_fty, [], @[]) }\n     };\n \n-    if vec::len(bound) == 0u && vec::len(lltydescs) == 0u {\n+    if bound.len() == 0u && lltydescs.len() == 0u {\n         // Trivial 'binding': just return the closure\n         let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n         bcx = lv.bcx;"}, {"sha": "d39759ad211503cbb5584b3d158d20869283031e", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=f2e880b75069415d8ebd6ee04508e0b85a8191d7", "patch": "@@ -283,7 +283,7 @@ fn revoke_clean(cx: @block_ctxt, val: ValueRef) {\n     sc_cx.cleanups =\n         vec::slice(sc_cx.cleanups, 0u, found as uint) +\n             vec::slice(sc_cx.cleanups, (found as uint) + 1u,\n-                            vec::len(sc_cx.cleanups));\n+                            sc_cx.cleanups.len());\n     sc_cx.lpad_dirty = true;\n     ret;\n }\n@@ -495,7 +495,7 @@ fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n \n fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef unsafe {\n     ret llvm::LLVMFunctionType(output, to_ptr(inputs),\n-                               vec::len::<TypeRef>(inputs) as unsigned,\n+                               inputs.len() as unsigned,\n                                False);\n }\n \n@@ -508,7 +508,7 @@ fn T_ptr(t: TypeRef) -> TypeRef {\n }\n \n fn T_struct(elts: [TypeRef]) -> TypeRef unsafe {\n-    ret llvm::LLVMStructType(to_ptr(elts), vec::len(elts) as unsigned, False);\n+    ret llvm::LLVMStructType(to_ptr(elts), elts.len() as unsigned, False);\n }\n \n fn T_named_struct(name: str) -> TypeRef {\n@@ -518,7 +518,7 @@ fn T_named_struct(name: str) -> TypeRef {\n \n fn set_struct_body(t: TypeRef, elts: [TypeRef]) unsafe {\n     llvm::LLVMStructSetBody(t, to_ptr(elts),\n-                            vec::len(elts) as unsigned, False);\n+                            elts.len() as unsigned, False);\n }\n \n fn T_empty_struct() -> TypeRef { ret T_struct([]); }\n@@ -790,28 +790,28 @@ fn C_zero_byte_arr(size: uint) -> ValueRef unsafe {\n     let elts: [ValueRef] = [];\n     while i < size { elts += [C_u8(0u)]; i += 1u; }\n     ret llvm::LLVMConstArray(T_i8(), vec::to_ptr(elts),\n-                             vec::len(elts) as unsigned);\n+                             elts.len() as unsigned);\n }\n \n fn C_struct(elts: [ValueRef]) -> ValueRef unsafe {\n-    ret llvm::LLVMConstStruct(vec::to_ptr(elts), vec::len(elts) as unsigned,\n+    ret llvm::LLVMConstStruct(vec::to_ptr(elts), elts.len() as unsigned,\n                               False);\n }\n \n fn C_named_struct(T: TypeRef, elts: [ValueRef]) -> ValueRef unsafe {\n     ret llvm::LLVMConstNamedStruct(T, vec::to_ptr(elts),\n-                                   vec::len(elts) as unsigned);\n+                                   elts.len() as unsigned);\n }\n \n fn C_array(ty: TypeRef, elts: [ValueRef]) -> ValueRef unsafe {\n     ret llvm::LLVMConstArray(ty, vec::to_ptr(elts),\n-                             vec::len(elts) as unsigned);\n+                             elts.len() as unsigned);\n }\n \n fn C_bytes(bytes: [u8]) -> ValueRef unsafe {\n     ret llvm::LLVMConstString(\n         unsafe::reinterpret_cast(vec::to_ptr(bytes)),\n-        vec::len(bytes) as unsigned, False);\n+        bytes.len() as unsigned, False);\n }\n \n fn C_shape(ccx: @crate_ctxt, bytes: [u8]) -> ValueRef {\n@@ -835,7 +835,7 @@ pure fn valid_variant_index(ix: uint, cx: @block_ctxt, enum_id: ast::def_id,\n     unchecked{\n         let variant =\n             ty::enum_variant_with_id(bcx_tcx(cx), enum_id, variant_id);\n-        ix < vec::len(variant.args)\n+        ix < variant.args.len()\n     }\n }\n "}, {"sha": "e72bbe04ae857fe2cd9c38c75722e719315de959", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=f2e880b75069415d8ebd6ee04508e0b85a8191d7", "patch": "@@ -122,10 +122,10 @@ fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n     let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n     let generic = generic_none;\n-    if vec::len(*method.tps) > 0u || ty::type_has_params(fty) {\n+    if (*method.tps).len() > 0u || ty::type_has_params(fty) {\n         let tydescs = [], tis = [];\n         let tptys = node_id_type_params(bcx, callee_id);\n-        for t in vec::tail_n(tptys, vec::len(tptys) - vec::len(*method.tps)) {\n+        for t in vec::tail_n(tptys, tptys.len() - (*method.tps).len()) {\n             let ti = none;\n             let td = get_tydesc(bcx, t, true, ti).result;\n             tis += [ti];\n@@ -297,10 +297,10 @@ fn trans_impl_wrapper(ccx: @crate_ctxt, pt: path,\n         }\n     }\n     let env_ty = T_ptr(T_struct([T_ptr(T_i8())] + extra_ptrs));\n-    let n_extra_ptrs = vec::len(extra_ptrs);\n+    let n_extra_ptrs = extra_ptrs.len();\n \n     let wrap_args = [T_ptr(T_dict())] + vec::slice(real_args, 0u, 2u) +\n-        vec::slice(real_args, 2u + vec::len(extra_ptrs), vec::len(real_args));\n+        vec::slice(real_args, 2u + n_extra_ptrs, real_args.len());\n     let llfn_ty = T_fn(wrap_args, real_ret);\n     trans_wrapper(ccx, pt, llfn_ty, {|llfn, bcx|\n         let dict = PointerCast(bcx, LLVMGetParam(llfn, 0 as c_uint), env_ty);\n@@ -407,14 +407,14 @@ fn get_dict(bcx: @block_ctxt, origin: typeck::dict_origin) -> result {\n             ret rslt(bcx, get_static_dict(bcx, origin));\n         }\n         let {bcx, ptrs} = get_dict_ptrs(bcx, origin);\n-        let pty = T_ptr(T_i8()), dict_ty = T_array(pty, vec::len(ptrs));\n+        let pty = T_ptr(T_i8()), dict_ty = T_array(pty, ptrs.len());\n         let dict = alloca(bcx, dict_ty), i = 0;\n         for ptr in ptrs {\n             Store(bcx, PointerCast(bcx, ptr, pty), GEPi(bcx, dict, [0, i]));\n             i += 1;\n         }\n         dict = Call(bcx, ccx.upcalls.intern_dict,\n-                    [C_uint(ccx, vec::len(ptrs)),\n+                    [C_uint(ccx, ptrs.len()),\n                      PointerCast(bcx, dict, T_ptr(T_dict()))]);\n         rslt(bcx, dict)\n       }\n@@ -431,7 +431,7 @@ fn dict_id(tcx: ty::ctxt, origin: typeck::dict_origin) -> dict_id {\n     alt origin {\n       typeck::dict_static(did, ts, origs) {\n         let d_params = [], orig = 0u;\n-        if vec::len(ts) == 0u { ret @{def: did, params: d_params}; }\n+        if ts.len() == 0u { ret @{def: did, params: d_params}; }\n         let impl_params = ty::lookup_item_type(tcx, did).bounds;\n         vec::iter2(ts, *impl_params) {|t, bounds|\n             d_params += [dict_param_ty(t)];"}, {"sha": "72cb133163c89626963a814f953860a4cef12ead", "filename": "src/comp/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs?ref=f2e880b75069415d8ebd6ee04508e0b85a8191d7", "patch": "@@ -110,7 +110,7 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n          llunitsz: llunitsz,\n          unit_ty: unit_ty,\n          llunitty: llunitty} =\n-        alloc(bcx, vec_ty, vec::len(args));\n+        alloc(bcx, vec_ty, args.len());\n \n     add_clean_free(bcx, vptr, true);\n     // Store the individual elements."}, {"sha": "0c6d4daa4aa77289f1354693722eb411ed9bc311", "filename": "src/libcore/core.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=f2e880b75069415d8ebd6ee04508e0b85a8191d7", "patch": "@@ -5,7 +5,8 @@\n \n import option::{some,  none};\n import option = option::t;\n-export option, some, none;\n+import vec::vec_len;\n+export option, some, none, vec_len;\n \n // Export the log levels as global constants. Higher levels mean\n // more-verbosity. Error is the bottom level, default logging level is"}, {"sha": "1f0abca025570bf4083db0aac0e55fe8b55eb2b2", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=f2e880b75069415d8ebd6ee04508e0b85a8191d7", "patch": "@@ -1088,6 +1088,9 @@ fn as_buf<E,T>(v: [const E], f: fn(*E) -> T) -> T unsafe {\n     let buf = unsafe::to_ptr(v); f(buf)\n }\n \n+impl vec_len<T> for [T] {\n+    fn len() -> uint { len(self) }\n+}\n \n /*\n Module: unsafe"}, {"sha": "c2b698be1bcd4d29630d3ad38764001bfb7525b2", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e880b75069415d8ebd6ee04508e0b85a8191d7/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=f2e880b75069415d8ebd6ee04508e0b85a8191d7", "patch": "@@ -18,7 +18,7 @@ impl util for uint {\n }\n \n impl util<T> for [T] {\n-    fn len() -> uint { vec::len(self) }\n+    fn length() -> uint { vec::len(self) }\n     fn iter(f: fn(T)) { for x in self { f(x); } }\n     fn map<U>(f: fn(T) -> U) -> [U] {\n         let r = [];\n@@ -33,7 +33,7 @@ fn main() {\n     assert 10u.plus() == 30;\n     assert \"hi\".plus() == 200;\n \n-    assert [1].len().str() == \"1\";\n+    assert [1].length().str() == \"1\";\n     assert [3, 4].map({|a| a + 4})[0] == 7;\n     assert [3, 4].map::<uint>({|a| a as uint + 4u})[0] == 7u;\n     let x = 0u;"}]}