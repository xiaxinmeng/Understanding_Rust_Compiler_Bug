{"sha": "428d4dfe710f7fe7564e6db82c4b44caaf84655d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyOGQ0ZGZlNzEwZjdmZTc1NjRlNmRiODJjNGI0NGNhYWY4NDY1NWQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-10T17:41:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-10T17:43:37Z"}, "message": "Fix accidently quadratic behavior when processing includes\n\ncloses #3927", "tree": {"sha": "0c57256151b575836bebb0702823415f4a404613", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c57256151b575836bebb0702823415f4a404613"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/428d4dfe710f7fe7564e6db82c4b44caaf84655d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/428d4dfe710f7fe7564e6db82c4b44caaf84655d", "html_url": "https://github.com/rust-lang/rust/commit/428d4dfe710f7fe7564e6db82c4b44caaf84655d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/428d4dfe710f7fe7564e6db82c4b44caaf84655d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e2f29af851b7d89ed7f4be91bd1932d45b90eaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e2f29af851b7d89ed7f4be91bd1932d45b90eaa", "html_url": "https://github.com/rust-lang/rust/commit/5e2f29af851b7d89ed7f4be91bd1932d45b90eaa"}], "stats": {"total": 36, "additions": 19, "deletions": 17}, "files": [{"sha": "9fb5cb058370b09584f6fc6c3cd3e7c84ecd2b7c", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/428d4dfe710f7fe7564e6db82c4b44caaf84655d/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428d4dfe710f7fe7564e6db82c4b44caaf84655d/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=428d4dfe710f7fe7564e6db82c4b44caaf84655d", "patch": "@@ -137,21 +137,23 @@ impl TokenMap {\n         token_id: tt::TokenId,\n         open_relative_range: TextRange,\n         close_relative_range: TextRange,\n-    ) {\n+    ) -> usize {\n+        let res = self.entries.len();\n         self.entries\n             .push((token_id, TokenTextRange::Delimiter(open_relative_range, close_relative_range)));\n+        res\n     }\n \n-    fn update_close_delim(&mut self, token_id: tt::TokenId, close_relative_range: TextRange) {\n-        if let Some(entry) = self.entries.iter_mut().find(|(tid, _)| *tid == token_id) {\n-            if let TokenTextRange::Delimiter(dim, _) = entry.1 {\n-                entry.1 = TokenTextRange::Delimiter(dim, close_relative_range);\n-            }\n+    fn update_close_delim(&mut self, idx: usize, close_relative_range: TextRange) {\n+        let (_, token_text_range) = &mut self.entries[idx];\n+        if let TokenTextRange::Delimiter(dim, _) = token_text_range {\n+            *token_text_range = TokenTextRange::Delimiter(*dim, close_relative_range);\n         }\n     }\n \n-    fn remove_delim(&mut self, token_id: tt::TokenId) {\n-        self.entries.retain(|(tid, _)| *tid != token_id);\n+    fn remove_delim(&mut self, idx: usize) {\n+        // FIXME: This could be accidently quadratic\n+        self.entries.remove(idx);\n     }\n }\n \n@@ -238,24 +240,24 @@ impl TokenIdAlloc {\n         token_id\n     }\n \n-    fn open_delim(&mut self, open_abs_range: TextRange) -> tt::TokenId {\n+    fn open_delim(&mut self, open_abs_range: TextRange) -> (tt::TokenId, usize) {\n         let token_id = tt::TokenId(self.next_id);\n         self.next_id += 1;\n-        self.map.insert_delim(\n+        let idx = self.map.insert_delim(\n             token_id,\n             open_abs_range - self.global_offset,\n             open_abs_range - self.global_offset,\n         );\n-        token_id\n+        (token_id, idx)\n     }\n \n-    fn close_delim(&mut self, id: tt::TokenId, close_abs_range: Option<TextRange>) {\n+    fn close_delim(&mut self, idx: usize, close_abs_range: Option<TextRange>) {\n         match close_abs_range {\n             None => {\n-                self.map.remove_delim(id);\n+                self.map.remove_delim(idx);\n             }\n             Some(close) => {\n-                self.map.update_close_delim(id, close - self.global_offset);\n+                self.map.update_close_delim(idx, close - self.global_offset);\n             }\n         }\n     }\n@@ -322,7 +324,7 @@ trait TokenConvertor {\n \n             if let Some((kind, closed)) = delim {\n                 let mut subtree = tt::Subtree::default();\n-                let id = self.id_alloc().open_delim(range);\n+                let (id, idx) = self.id_alloc().open_delim(range);\n                 subtree.delimiter = Some(tt::Delimiter { kind, id });\n \n                 while self.peek().map(|it| it.kind() != closed).unwrap_or(false) {\n@@ -331,7 +333,7 @@ trait TokenConvertor {\n                 let last_range = match self.bump() {\n                     None => {\n                         // For error resilience, we insert an char punct for the opening delim here\n-                        self.id_alloc().close_delim(id, None);\n+                        self.id_alloc().close_delim(idx, None);\n                         let leaf: tt::Leaf = tt::Punct {\n                             id: self.id_alloc().alloc(range),\n                             char: token.to_char().unwrap(),\n@@ -344,7 +346,7 @@ trait TokenConvertor {\n                     }\n                     Some(it) => it.1,\n                 };\n-                self.id_alloc().close_delim(id, Some(last_range));\n+                self.id_alloc().close_delim(idx, Some(last_range));\n                 subtree.into()\n             } else {\n                 let spacing = match self.peek() {"}]}