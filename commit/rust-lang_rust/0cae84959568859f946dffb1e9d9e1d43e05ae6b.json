{"sha": "0cae84959568859f946dffb1e9d9e1d43e05ae6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjYWU4NDk1OTU2ODg1OWY5NDZkZmZiMWU5ZDllMWQ0M2UwNWFlNmI=", "commit": {"author": {"name": "Alan Andrade", "email": "alan.andradec@gmail.com", "date": "2014-05-25T00:08:00Z"}, "committer": {"name": "Alan Andrade", "email": "alan.andradec@gmail.com", "date": "2014-05-25T00:08:00Z"}, "message": "fix mostly grammar per PR comments", "tree": {"sha": "bad456cf22733937ff0e80a915e4b6bb9db86c0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bad456cf22733937ff0e80a915e4b6bb9db86c0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cae84959568859f946dffb1e9d9e1d43e05ae6b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cae84959568859f946dffb1e9d9e1d43e05ae6b", "html_url": "https://github.com/rust-lang/rust/commit/0cae84959568859f946dffb1e9d9e1d43e05ae6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cae84959568859f946dffb1e9d9e1d43e05ae6b/comments", "author": {"login": "alan-andrade", "id": 97609, "node_id": "MDQ6VXNlcjk3NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/97609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alan-andrade", "html_url": "https://github.com/alan-andrade", "followers_url": "https://api.github.com/users/alan-andrade/followers", "following_url": "https://api.github.com/users/alan-andrade/following{/other_user}", "gists_url": "https://api.github.com/users/alan-andrade/gists{/gist_id}", "starred_url": "https://api.github.com/users/alan-andrade/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alan-andrade/subscriptions", "organizations_url": "https://api.github.com/users/alan-andrade/orgs", "repos_url": "https://api.github.com/users/alan-andrade/repos", "events_url": "https://api.github.com/users/alan-andrade/events{/privacy}", "received_events_url": "https://api.github.com/users/alan-andrade/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alan-andrade", "id": 97609, "node_id": "MDQ6VXNlcjk3NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/97609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alan-andrade", "html_url": "https://github.com/alan-andrade", "followers_url": "https://api.github.com/users/alan-andrade/followers", "following_url": "https://api.github.com/users/alan-andrade/following{/other_user}", "gists_url": "https://api.github.com/users/alan-andrade/gists{/gist_id}", "starred_url": "https://api.github.com/users/alan-andrade/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alan-andrade/subscriptions", "organizations_url": "https://api.github.com/users/alan-andrade/orgs", "repos_url": "https://api.github.com/users/alan-andrade/repos", "events_url": "https://api.github.com/users/alan-andrade/events{/privacy}", "received_events_url": "https://api.github.com/users/alan-andrade/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99744653d5abb949e446daf0732be79c76aa6f79", "url": "https://api.github.com/repos/rust-lang/rust/commits/99744653d5abb949e446daf0732be79c76aa6f79", "html_url": "https://github.com/rust-lang/rust/commit/99744653d5abb949e446daf0732be79c76aa6f79"}], "stats": {"total": 38, "additions": 18, "deletions": 20}, "files": [{"sha": "40070c4dd4bba792a3ab172f2f1c956a3ba580bd", "filename": "src/doc/guide-lifetimes.md", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0cae84959568859f946dffb1e9d9e1d43e05ae6b/src%2Fdoc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/0cae84959568859f946dffb1e9d9e1d43e05ae6b/src%2Fdoc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-lifetimes.md?ref=0cae84959568859f946dffb1e9d9e1d43e05ae6b", "patch": "@@ -14,20 +14,19 @@ Despite their complete safety, a reference's representation at runtime\n is the same as that of an ordinary pointer in a C program. They introduce zero\n overhead. The compiler does all safety checks at compile time.\n \n-Although references have rather elaborate theoretical\n-underpinnings (region pointers), the core concepts will be familiar to\n-anyone who has worked with C or C++. Therefore, the best way to explain\n-how they are used\u2014and their limitations\u2014is probably just to work\n-through several examples.\n+Although references have rather elaborate theoretical underpinnings usually\n+introduced as (e.g. region pointers), the core concepts will be familiar to\n+anyone who has worked with C or C++. The best way to explain how they are\n+used\u2014and their limitations\u2014is probably just to work through several examples.\n \n # By example\n \n References, sometimes known as *borrowed pointers*, are only valid for\n a limited duration. References never claim any kind of ownership\n-over the data that they point to, instead, they are used for cases\n+over the data that they point to. Instead, they are used for cases\n where you would like to use data for a short time.\n \n-As an example, consider a simple struct type `Point`:\n+Consider a simple struct type `Point`:\n \n ~~~\n struct Point {x: f64, y: f64}\n@@ -78,9 +77,9 @@ value. We also call this _borrowing_ the local variable\n `on_the_stack`, because we have created an alias: that is, another\n name for the same data.\n \n-For the second argument, we need to grab the contents of `on_the_heap`\n-by using the `*` operator, and then get a reference to that data. In\n-order to convert `Box<T>` into a `&T`, we need to use `&*`.\n+For the second argument, we need to extract the contents of `on_the_heap`\n+by derefercing with the `*` symbol. Now that we have the data, we need\n+to create a reference with the `&` symbol.\n \n Whenever a caller lends data to a callee, there are some limitations on what\n the caller can do with the original. For example, if the contents of a\n@@ -194,7 +193,7 @@ fn example3() -> int {\n }\n ~~~\n \n-Here, as before, the interior of the variable `x` is being borrowed\n+Here, the interior of the variable `x` is being borrowed\n and `x` is declared as mutable. However, the compiler can prove that\n `x` is not assigned anywhere in the lifetime L of the variable\n `y`. Therefore, it accepts the function, even though `x` is mutable\n@@ -281,8 +280,8 @@ prevents pointers from pointing into freed memory. There is one other\n case where the compiler must be very careful to ensure that pointers\n remain valid: pointers into the interior of an `enum`.\n \n-As an example, let\u2019s look at the following `shape` type that can\n-represent both rectangles and circles:\n+Let\u2019s look at the following `shape` type that can represent both rectangles\n+and circles:\n \n ~~~\n struct Point {x: f64, y: f64}; // as before\n@@ -391,7 +390,7 @@ reference, then uses it within the same scope. It is also\n possible to return references as the result of a function, but\n as we'll see, doing so requires some explicit annotation.\n \n-For example, we could write a subroutine like this:\n+We could write a subroutine like this:\n \n ~~~\n struct Point {x: f64, y: f64}\n@@ -412,11 +411,10 @@ pointer result will always have the same lifetime as one of the\n parameters; named lifetimes indicate which parameter that\n is.\n \n-In the previous examples, function parameter types did not include a\n-lifetime name. In those examples, the compiler simply creates a fresh\n-name for the lifetime automatically: that is, the lifetime name is\n-guaranteed to refer to a distinct lifetime from the lifetimes of all\n-other parameters.\n+In the previous code samples, function parameter types did not include a\n+lifetime name. The compiler simply creates a fresh name for the lifetime\n+automatically: that is, the lifetime name is guaranteed to refer to a distinct\n+lifetime from the lifetimes of all other parameters.\n \n Named lifetimes that appear in function signatures are conceptually\n the same as the other lifetimes we have seen before, but they are a bit\n@@ -461,7 +459,7 @@ guarantees; in fact, it cannot guarantee that the pointer will remain\n valid at all once it returns, as the parameter `p` may or may not be\n live in the caller. Therefore, the compiler will report an error here.\n \n-In general, if you borrow a structs or boxes to create a\n+In general, if you borrow a struct or box to create a\n reference, it will only be valid within the function\n and cannot be returned. This is why the typical way to return references\n is to take references as input (the only other case in"}]}