{"sha": "ef54f57c5b9d894a38179d09b00610c1b337b086", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNTRmNTdjNWI5ZDg5NGEzODE3OWQwOWIwMDYxMGMxYjMzN2IwODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-07T10:22:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-07T10:22:58Z"}, "message": "Auto merge of #64246 - Centril:rollup-zey4o09, r=Centril\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #63919 (Use hygiene for AST passes)\n - #63927 (Filter linkcheck spurious failure)\n - #64149 (rustc_codegen_llvm: give names to non-alloca variable values.)\n - #64192 (Bail out when encountering likely missing turbofish in parser)\n - #64231 (Move the HIR CFG to `rustc_ast_borrowck`)\n - #64233 (Correct pluralisation of various diagnostic messages)\n - #64236 (reduce visibility)\n - #64240 (Include compiler-rt in the source tarball)\n - #64241 ([doc] Added more prereqs and note about default directory)\n - #64243 (Move injection of attributes from command line to `libsyntax_ext`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e5eda3465de3f5ce96734d326820e6a274bb11c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5eda3465de3f5ce96734d326820e6a274bb11c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef54f57c5b9d894a38179d09b00610c1b337b086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef54f57c5b9d894a38179d09b00610c1b337b086", "html_url": "https://github.com/rust-lang/rust/commit/ef54f57c5b9d894a38179d09b00610c1b337b086", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef54f57c5b9d894a38179d09b00610c1b337b086/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da13f06ea0dc368f1350bfc356b7f81a838defde", "url": "https://api.github.com/repos/rust-lang/rust/commits/da13f06ea0dc368f1350bfc356b7f81a838defde", "html_url": "https://github.com/rust-lang/rust/commit/da13f06ea0dc368f1350bfc356b7f81a838defde"}, {"sha": "3d4cb503121d1ed0567c7a0a8b236adbda613bbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d4cb503121d1ed0567c7a0a8b236adbda613bbe", "html_url": "https://github.com/rust-lang/rust/commit/3d4cb503121d1ed0567c7a0a8b236adbda613bbe"}], "stats": {"total": 1606, "additions": 857, "deletions": 749}, "files": [{"sha": "4c2e4eef6552fb3e51567480056ed80c28a0415f", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -32,6 +32,7 @@ or reading the [rustc guide][rustcguidebuild].\n    * `cmake` 3.4.3 or later\n    * `curl`\n    * `git`\n+   * `ssl` which comes in `libssl-dev` or `openssl-devel`\n \n 2. Clone the [source] with `git`:\n \n@@ -56,6 +57,8 @@ or reading the [rustc guide][rustcguidebuild].\n     an installation (using `./x.py install`) that you set the `prefix` value\n     in the `[install]` section to a directory that you have write permissions.\n \n+    Create install directory if you are not installing in default directory\n+\n 4. Build and install:\n \n     ```sh"}, {"sha": "500d5766a899e4945874793483f1630daf55a8b1", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -808,6 +808,7 @@ fn copy_src_dirs(builder: &Builder<'_>, src_dirs: &[&str], exclude_dirs: &[&str]\n             \"llvm-project/lld\", \"llvm-project\\\\lld\",\n             \"llvm-project/lldb\", \"llvm-project\\\\lldb\",\n             \"llvm-project/llvm\", \"llvm-project\\\\llvm\",\n+            \"llvm-project/compiler-rt\", \"llvm-project\\\\compiler-rt\",\n         ];\n         if spath.contains(\"llvm-project\") && !spath.ends_with(\"llvm-project\")\n             && !LLVM_PROJECTS.iter().any(|path| spath.contains(path))"}, {"sha": "646060bc8be775152611214da6074c31559e05c5", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -390,9 +390,17 @@ impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnKind {\n     Root,\n     Macro(kind, descr),\n+    AstPass(kind),\n     Desugaring(kind)\n });\n \n+impl_stable_hash_for!(enum ::syntax_pos::hygiene::AstPass {\n+    StdImports,\n+    TestHarness,\n+    ProcMacroHarness,\n+    PluginMacroDefs,\n+});\n+\n impl_stable_hash_for!(enum ::syntax_pos::hygiene::DesugaringKind {\n     CondTemporary,\n     Async,"}, {"sha": "bf4330a29a7dfe1eaf004501dce7ca8226896673", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -97,7 +97,6 @@ pub mod query;\n \n #[macro_use]\n pub mod arena;\n-pub mod cfg;\n pub mod dep_graph;\n pub mod hir;\n pub mod ich;"}, {"sha": "e33f8e27871b2aa3c335bdf7c742ead20ec3844b", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -646,6 +646,30 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n         (Level::Forbid, None) => sess.struct_err(msg),\n     };\n \n+    // Check for future incompatibility lints and issue a stronger warning.\n+    let lints = sess.lint_store.borrow();\n+    let lint_id = LintId::of(lint);\n+    let future_incompatible = lints.future_incompatible(lint_id);\n+\n+    // If this code originates in a foreign macro, aka something that this crate\n+    // did not itself author, then it's likely that there's nothing this crate\n+    // can do about it. We probably want to skip the lint entirely.\n+    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n+        // Any suggestions made here are likely to be incorrect, so anything we\n+        // emit shouldn't be automatically fixed by rustfix.\n+        err.allow_suggestions(false);\n+\n+        // If this is a future incompatible lint it'll become a hard error, so\n+        // we have to emit *something*. Also allow lints to whitelist themselves\n+        // on a case-by-case basis for emission in a foreign macro.\n+        if future_incompatible.is_none() && !lint.report_in_external_macro {\n+            err.cancel();\n+            // Don't continue further, since we don't want to have\n+            // `diag_span_note_once` called for a diagnostic that isn't emitted.\n+            return err;\n+        }\n+    }\n+\n     let name = lint.name_lower();\n     match src {\n         LintSource::Default => {\n@@ -695,10 +719,6 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n \n     err.code(DiagnosticId::Lint(name));\n \n-    // Check for future incompatibility lints and issue a stronger warning.\n-    let lints = sess.lint_store.borrow();\n-    let lint_id = LintId::of(lint);\n-    let future_incompatible = lints.future_incompatible(lint_id);\n     if let Some(future_incompatible) = future_incompatible {\n         const STANDARD_MESSAGE: &str =\n             \"this was previously accepted by the compiler but is being phased out; \\\n@@ -723,22 +743,6 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n         err.note(&citation);\n     }\n \n-    // If this code originates in a foreign macro, aka something that this crate\n-    // did not itself author, then it's likely that there's nothing this crate\n-    // can do about it. We probably want to skip the lint entirely.\n-    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n-        // Any suggestions made here are likely to be incorrect, so anything we\n-        // emit shouldn't be automatically fixed by rustfix.\n-        err.allow_suggestions(false);\n-\n-        // If this is a future incompatible lint it'll become a hard error, so\n-        // we have to emit *something*. Also allow lints to whitelist themselves\n-        // on a case-by-case basis for emission in a foreign macro.\n-        if future_incompatible.is_none() && !lint.report_in_external_macro {\n-            err.cancel()\n-        }\n-    }\n-\n     return err\n }\n \n@@ -868,7 +872,7 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n     let expn_data = span.ctxt().outer_expn_data();\n     match expn_data.kind {\n         ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n-        ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n+        ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n             if expn_data.def_site.is_dummy() {\n                 // dummy span for the def_site means it's an external macro"}, {"sha": "f67526ea4a1d9a27e35dd20aec8b6607bdfa9499", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -200,7 +200,9 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Array(_, n) => {\n                 let n = tcx.lift_to_global(&n).unwrap();\n                 match n.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n-                    Some(n) => format!(\"array of {} elements\", n).into(),\n+                    Some(n) => {\n+                        format!(\"array of {} element{}\", n, if n != 1 { \"s\" } else { \"\" }).into()\n+                    }\n                     None => \"array\".into(),\n                 }\n             }"}, {"sha": "23d5480c60562b5811acf8baff6d091a1fea1fa8", "filename": "src/librustc_ast_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -9,7 +9,6 @@ use InteriorKind::*;\n \n use rustc::hir::HirId;\n use rustc::hir::Node;\n-use rustc::cfg;\n use rustc::middle::borrowck::{BorrowCheckResult, SignalledError};\n use rustc::hir::def_id::{DefId, LocalDefId};\n use rustc::middle::mem_categorization as mc;\n@@ -28,6 +27,7 @@ use log::debug;\n \n use rustc::hir;\n \n+use crate::cfg;\n use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n \n pub mod check_loans;"}, {"sha": "67d818161b1b5d2a6cde7ba12356049b46ebed02", "filename": "src/librustc_ast_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -4,7 +4,7 @@\n use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n \n use crate::borrowck::*;\n-use rustc::cfg;\n+use crate::cfg;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n "}, {"sha": "339d92145c64fc2d4e8f084023a7ba1224b6e914", "filename": "src/librustc_ast_borrowck/cfg/construct.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -1,11 +1,11 @@\n use crate::cfg::*;\n-use crate::middle::region;\n use rustc_data_structures::graph::implementation as graph;\n-use crate::ty::{self, TyCtxt};\n+use rustc::middle::region;\n+use rustc::ty::{self, TyCtxt};\n \n-use crate::hir::{self, PatKind};\n-use crate::hir::def_id::DefId;\n-use crate::hir::ptr::P;\n+use rustc::hir::{self, PatKind};\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::ptr::P;\n \n struct CFGBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -30,7 +30,7 @@ struct LoopScope {\n     break_index: CFGIndex,    // where to go on a `break`\n }\n \n-pub fn construct(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n+pub(super) fn construct(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);\n ", "previous_filename": "src/librustc/cfg/construct.rs"}, {"sha": "46409f1a1cebf498a7ff72f357777d0a01be596b", "filename": "src/librustc_ast_borrowck/cfg/graphviz.rs", "status": "renamed", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -1,15 +1,12 @@\n /// This module provides linkage between rustc::middle::graph and\n /// libgraphviz traits.\n \n-// For clarity, rename the graphviz crate locally to dot.\n-use graphviz as dot;\n-\n use crate::cfg;\n-use crate::hir;\n-use crate::ty::TyCtxt;\n+use rustc::hir;\n+use rustc::ty::TyCtxt;\n \n-pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n-pub type Edge<'a> = &'a cfg::CFGEdge;\n+pub(crate) type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n+pub(crate) type Edge<'a> = &'a cfg::CFGEdge;\n \n pub struct LabelledCFG<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,", "previous_filename": "src/librustc/cfg/graphviz.rs"}, {"sha": "981199c91d513effe18b18fb911c4ecf593b9728", "filename": "src/librustc_ast_borrowck/cfg/mod.rs", "status": "renamed", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -2,18 +2,18 @@\n //! Uses `Graph` as the underlying representation.\n \n use rustc_data_structures::graph::implementation as graph;\n-use crate::ty::TyCtxt;\n-use crate::hir;\n-use crate::hir::def_id::DefId;\n+use rustc::ty::TyCtxt;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n \n mod construct;\n pub mod graphviz;\n \n pub struct CFG {\n-    pub owner_def_id: DefId,\n-    pub graph: CFGGraph,\n-    pub entry: CFGIndex,\n-    pub exit: CFGIndex,\n+    owner_def_id: DefId,\n+    pub(crate) graph: CFGGraph,\n+    pub(crate) entry: CFGIndex,\n+    exit: CFGIndex,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n@@ -26,7 +26,7 @@ pub enum CFGNodeData {\n }\n \n impl CFGNodeData {\n-    pub fn id(&self) -> hir::ItemLocalId {\n+    pub(crate) fn id(&self) -> hir::ItemLocalId {\n         if let CFGNodeData::AST(id) = *self {\n             id\n         } else {\n@@ -37,24 +37,19 @@ impl CFGNodeData {\n \n #[derive(Debug)]\n pub struct CFGEdgeData {\n-    pub exiting_scopes: Vec<hir::ItemLocalId>\n+    pub(crate) exiting_scopes: Vec<hir::ItemLocalId>\n }\n \n-pub type CFGIndex = graph::NodeIndex;\n+pub(crate) type CFGIndex = graph::NodeIndex;\n \n-pub type CFGGraph = graph::Graph<CFGNodeData, CFGEdgeData>;\n+pub(crate) type CFGGraph = graph::Graph<CFGNodeData, CFGEdgeData>;\n \n-pub type CFGNode = graph::Node<CFGNodeData>;\n+pub(crate) type CFGNode = graph::Node<CFGNodeData>;\n \n-pub type CFGEdge = graph::Edge<CFGEdgeData>;\n+pub(crate) type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n     pub fn new(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n         construct::construct(tcx, body)\n     }\n-\n-    pub fn node_is_reachable(&self, id: hir::ItemLocalId) -> bool {\n-        self.graph.depth_traverse(self.entry, graph::OUTGOING)\n-                  .any(|idx| self.graph.node_data(idx).id() == id)\n-    }\n }", "previous_filename": "src/librustc/cfg/mod.rs"}, {"sha": "a8562901d99c5f3c0443db6b6dc6980580533998", "filename": "src/librustc_ast_borrowck/dataflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fdataflow.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -3,9 +3,7 @@\n //! and thus uses bitvectors. Your job is simply to specify the so-called\n //! GEN and KILL bits for each expression.\n \n-use rustc::cfg;\n-use rustc::cfg::CFGIndex;\n-use rustc::ty::TyCtxt;\n+use crate::cfg::{self, CFGIndex};\n use std::mem;\n use std::usize;\n use log::debug;\n@@ -16,6 +14,7 @@ use rustc::util::nodemap::FxHashMap;\n use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::hir::print as pprust;\n+use rustc::ty::TyCtxt;\n \n #[derive(Copy, Clone, Debug)]\n pub enum EntryOrExit {"}, {"sha": "c077dc828aba22b98fe898fee4bd92039bef9832", "filename": "src/librustc_ast_borrowck/graphviz.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -4,13 +4,12 @@\n \n pub use Variant::*;\n \n-pub use rustc::cfg::graphviz::{Node, Edge};\n-use rustc::cfg::graphviz as cfg_dot;\n-\n+pub(crate) use crate::cfg::graphviz::{Node, Edge};\n+use crate::cfg::graphviz as cfg_dot;\n+use crate::cfg::CFGIndex;\n use crate::borrowck::{self, BorrowckCtxt, LoanPath};\n use crate::dataflow::{DataFlowOperator, DataFlowContext, EntryOrExit};\n use log::debug;\n-use rustc::cfg::CFGIndex;\n use std::rc::Rc;\n \n #[derive(Debug, Copy, Clone)]"}, {"sha": "aea97fea1a9fd67d5aeec911beb59e6775e17f5b", "filename": "src/librustc_ast_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_ast_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Flib.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -18,5 +18,6 @@ mod borrowck;\n pub mod graphviz;\n \n mod dataflow;\n+pub mod cfg;\n \n pub use borrowck::provide;"}, {"sha": "6dedf10f0ab837e41fb5f3094e02c757df62868a", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -32,7 +32,7 @@ use rustc_codegen_ssa::debuginfo::{FunctionDebugContext, MirDebugScope, Variable\n \n use libc::c_uint;\n use std::cell::RefCell;\n-use std::ffi::CString;\n+use std::ffi::{CStr, CString};\n \n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n@@ -224,8 +224,37 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         gdb::insert_reference_to_gdb_debug_scripts_section_global(self)\n     }\n \n-    fn set_value_name(&mut self, value: &'ll Value, name: &str) {\n-        let cname = SmallCStr::new(name);\n+    fn set_var_name(&mut self, value: &'ll Value, name: impl ToString) {\n+        // Avoid wasting time if LLVM value names aren't even enabled.\n+        if self.sess().fewer_names() {\n+            return;\n+        }\n+\n+        // Only function parameters and instructions are local to a function,\n+        // don't change the name of anything else (e.g. globals).\n+        let param_or_inst = unsafe {\n+            llvm::LLVMIsAArgument(value).is_some() ||\n+            llvm::LLVMIsAInstruction(value).is_some()\n+        };\n+        if !param_or_inst {\n+            return;\n+        }\n+\n+        let old_name = unsafe {\n+            CStr::from_ptr(llvm::LLVMGetValueName(value))\n+        };\n+        match old_name.to_str() {\n+            Ok(\"\") => {}\n+            Ok(_) => {\n+                // Avoid replacing the name if it already exists.\n+                // While we could combine the names somehow, it'd\n+                // get noisy quick, and the usefulness is dubious.\n+                return;\n+            }\n+            Err(_) => return,\n+        }\n+\n+        let cname = CString::new(name.to_string()).unwrap();\n         unsafe {\n             llvm::LLVMSetValueName(value, cname.as_ptr());\n         }"}, {"sha": "b07214fdc03f3c22b4f93d2e462369ca87cd1bff", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -806,6 +806,7 @@ extern \"C\" {\n     pub fn LLVMRustRemoveFunctionAttributes(Fn: &Value, index: c_uint, attr: Attribute);\n \n     // Operations on parameters\n+    pub fn LLVMIsAArgument(Val: &Value) -> Option<&Value>;\n     pub fn LLVMCountParams(Fn: &Value) -> c_uint;\n     pub fn LLVMGetParam(Fn: &Value, Index: c_uint) -> &Value;\n \n@@ -818,6 +819,7 @@ extern \"C\" {\n     pub fn LLVMDeleteBasicBlock(BB: &BasicBlock);\n \n     // Operations on instructions\n+    pub fn LLVMIsAInstruction(Val: &Value) -> Option<&Value>;\n     pub fn LLVMGetFirstBasicBlock(Fn: &Value) -> &BasicBlock;\n \n     // Operations on call sites"}, {"sha": "00e9ca01f4dd257c6a78d5eb6229da08e3bd8f2a", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -518,19 +518,19 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 PassMode::Ignore(IgnoreMode::CVarArgs) => {}\n                 PassMode::Direct(_) => {\n                     let llarg = bx.get_param(llarg_idx);\n-                    bx.set_value_name(llarg, &name);\n+                    bx.set_var_name(llarg, &name);\n                     llarg_idx += 1;\n                     return local(\n                         OperandRef::from_immediate_or_packed_pair(bx, llarg, arg.layout));\n                 }\n                 PassMode::Pair(..) => {\n-                    let a = bx.get_param(llarg_idx);\n-                    bx.set_value_name(a, &(name.clone() + \".0\"));\n-                    llarg_idx += 1;\n+                    let (a, b) = (bx.get_param(llarg_idx), bx.get_param(llarg_idx + 1));\n+                    llarg_idx += 2;\n \n-                    let b = bx.get_param(llarg_idx);\n-                    bx.set_value_name(b, &(name + \".1\"));\n-                    llarg_idx += 1;\n+                    // FIXME(eddyb) these are scalar components,\n+                    // maybe extract the high-level fields?\n+                    bx.set_var_name(a, format_args!(\"{}.0\", name));\n+                    bx.set_var_name(b, format_args!(\"{}.1\", name));\n \n                     return local(OperandRef {\n                         val: OperandValue::Pair(a, b),\n@@ -546,7 +546,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             // already put it in a temporary alloca and gave it up.\n             // FIXME: lifetimes\n             let llarg = bx.get_param(llarg_idx);\n-            bx.set_value_name(llarg, &name);\n+            bx.set_var_name(llarg, &name);\n             llarg_idx += 1;\n             PlaceRef::new_sized(llarg, arg.layout)\n         } else if arg.is_unsized_indirect() {"}, {"sha": "594f45c833758874caf2d4220bdc9cfe1784f35a", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -29,7 +29,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             self.codegen_rvalue_unsized(bx, cg_indirect_dest, rvalue)\n                         }\n                         LocalRef::Operand(None) => {\n-                            let (bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n+                            let (mut bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n+                            if let Some(name) = self.mir.local_decls[index].name {\n+                                match operand.val {\n+                                    OperandValue::Ref(x, ..) |\n+                                    OperandValue::Immediate(x) => {\n+                                        bx.set_var_name(x, name);\n+                                    }\n+                                    OperandValue::Pair(a, b) => {\n+                                        // FIXME(eddyb) these are scalar components,\n+                                        // maybe extract the high-level fields?\n+                                        bx.set_var_name(a, format_args!(\"{}.0\", name));\n+                                        bx.set_var_name(b, format_args!(\"{}.1\", name));\n+                                    }\n+                                }\n+                            }\n                             self.locals[index] = LocalRef::Operand(Some(operand));\n                             bx\n                         }"}, {"sha": "9c16b864ef21dce3b48d1c017b16cb8b885848ac", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -57,5 +57,5 @@ pub trait DebugInfoBuilderMethods<'tcx>: BackendTypes {\n         span: Span,\n     );\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self);\n-    fn set_value_name(&mut self, value: Self::Value, name: &str);\n+    fn set_var_name(&mut self, value: Self::Value, name: impl ToString);\n }"}, {"sha": "c4d3ad946f9f6ffe5481ff6999f61fe29e2bb49c", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -1,7 +1,5 @@\n //! The various pretty-printing routines.\n \n-use rustc::cfg;\n-use rustc::cfg::graphviz::LabelledCFG;\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks;\n@@ -14,6 +12,7 @@ use rustc::util::common::ErrorReported;\n use rustc_interface::util::ReplaceBodyWithLoop;\n use rustc_ast_borrowck as borrowck;\n use rustc_ast_borrowck::graphviz as borrowck_dot;\n+use rustc_ast_borrowck::cfg::{self, graphviz::LabelledCFG};\n use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n use syntax::ast;"}, {"sha": "7fcad4d79c204c83f9177b042b191faed9251664", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -230,10 +230,12 @@ pub fn register_plugins<'a>(\n     crate_name: &str,\n ) -> Result<(ast::Crate, PluginInfo)> {\n     krate = time(sess, \"attributes injection\", || {\n-        syntax::attr::inject(krate, &sess.parse_sess, &sess.opts.debugging_opts.crate_attr)\n+        syntax_ext::cmdline_attrs::inject(\n+            krate, &sess.parse_sess, &sess.opts.debugging_opts.crate_attr\n+        )\n     });\n \n-    let (mut krate, features) = syntax::config::features(\n+    let (krate, features) = syntax::config::features(\n         krate,\n         &sess.parse_sess,\n         sess.edition(),\n@@ -268,16 +270,6 @@ pub fn register_plugins<'a>(\n         middle::recursion_limit::update_limits(sess, &krate);\n     });\n \n-    krate = time(sess, \"crate injection\", || {\n-        let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| &**s);\n-        let (krate, name) =\n-            syntax_ext::standard_library_imports::inject(krate, alt_std_name, sess.edition());\n-        if let Some(name) = name {\n-            sess.parse_sess.injected_crate_name.set(name);\n-        }\n-        krate\n-    });\n-\n     let registrars = time(sess, \"plugin loading\", || {\n         plugin::load::load_plugins(\n             sess,\n@@ -370,6 +362,21 @@ fn configure_and_expand_inner<'a>(\n         &resolver_arenas,\n     );\n     syntax_ext::register_builtin_macros(&mut resolver, sess.edition());\n+\n+    krate = time(sess, \"crate injection\", || {\n+        let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| Symbol::intern(s));\n+        let (krate, name) = syntax_ext::standard_library_imports::inject(\n+            krate,\n+            &mut resolver,\n+            &sess.parse_sess,\n+            alt_std_name,\n+        );\n+        if let Some(name) = name {\n+            sess.parse_sess.injected_crate_name.set(name);\n+        }\n+        krate\n+    });\n+\n     syntax_ext::plugin_macro_defs::inject(\n         &mut krate, &mut resolver, plugin_info.syntax_exts, sess.edition()\n     );"}, {"sha": "81bd687e263213b28f991a9b26a956fe98ae8443", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -126,7 +126,8 @@ impl<'a> Resolver<'a> {\n     crate fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n         let def_id = match self.macro_defs.get(&expn_id) {\n             Some(def_id) => *def_id,\n-            None => return self.graph_root,\n+            None => return self.ast_transform_scopes.get(&expn_id)\n+                .unwrap_or(&self.graph_root),\n         };\n         if let Some(id) = self.definitions.as_local_node_id(def_id) {\n             self.local_macro_def_scopes[&id]"}, {"sha": "c479912b4ef814949d839341736555384865445f", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -604,6 +604,14 @@ impl<'a> Resolver<'a> {\n         if lookup_ident.span.rust_2018() {\n             let extern_prelude_names = self.extern_prelude.clone();\n             for (ident, _) in extern_prelude_names.into_iter() {\n+                if ident.span.from_expansion() {\n+                    // Idents are adjusted to the root context before being\n+                    // resolved in the extern prelude, so reporting this to the\n+                    // user is no help. This skips the injected\n+                    // `extern crate std` in the 2018 edition, which would\n+                    // otherwise cause duplicate suggestions.\n+                    continue;\n+                }\n                 if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name,\n                                                                                     ident.span) {\n                     let crate_root = self.get_module(DefId {"}, {"sha": "7f65e5dfaa2bf78c17488e51cb9dee00ae80ae46", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -880,6 +880,10 @@ pub struct Resolver<'a> {\n     /// There will be an anonymous module created around `g` with the ID of the\n     /// entry block for `f`.\n     block_map: NodeMap<Module<'a>>,\n+    /// A fake module that contains no definition and no prelude. Used so that\n+    /// some AST passes can generate identifiers that only resolve to local or\n+    /// language items.\n+    empty_module: Module<'a>,\n     module_map: FxHashMap<DefId, Module<'a>>,\n     extern_module_map: FxHashMap<(DefId, bool /* MacrosOnly? */), Module<'a>>,\n     binding_parent_modules: FxHashMap<PtrKey<'a, NameBinding<'a>>, Module<'a>>,\n@@ -914,6 +918,7 @@ pub struct Resolver<'a> {\n     non_macro_attrs: [Lrc<SyntaxExtension>; 2],\n     macro_defs: FxHashMap<ExpnId, DefId>,\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n+    ast_transform_scopes: FxHashMap<ExpnId, Module<'a>>,\n     unused_macros: NodeMap<Span>,\n     proc_macro_stubs: NodeSet,\n     /// Traces collected during macro resolution and validated when it's complete.\n@@ -1081,6 +1086,21 @@ impl<'a> Resolver<'a> {\n             no_implicit_prelude: attr::contains_name(&krate.attrs, sym::no_implicit_prelude),\n             ..ModuleData::new(None, root_module_kind, root_def_id, ExpnId::root(), krate.span)\n         });\n+        let empty_module_kind = ModuleKind::Def(\n+            DefKind::Mod,\n+            root_def_id,\n+            kw::Invalid,\n+        );\n+        let empty_module = arenas.alloc_module(ModuleData {\n+            no_implicit_prelude: true,\n+            ..ModuleData::new(\n+                Some(graph_root),\n+                empty_module_kind,\n+                root_def_id,\n+                ExpnId::root(),\n+                DUMMY_SP,\n+            )\n+        });\n         let mut module_map = FxHashMap::default();\n         module_map.insert(DefId::local(CRATE_DEF_INDEX), graph_root);\n \n@@ -1140,10 +1160,12 @@ impl<'a> Resolver<'a> {\n             label_res_map: Default::default(),\n             export_map: FxHashMap::default(),\n             trait_map: Default::default(),\n+            empty_module,\n             module_map,\n             block_map: Default::default(),\n             extern_module_map: FxHashMap::default(),\n             binding_parent_modules: FxHashMap::default(),\n+            ast_transform_scopes: FxHashMap::default(),\n \n             glob_map: Default::default(),\n "}, {"sha": "054b17fec78491b5ee6eff49205c17ee6819f2ae", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -8,6 +8,7 @@ use crate::{ModuleOrUniformRoot, KNOWN_TOOLS};\n use crate::Namespace::*;\n use crate::resolve_imports::ImportResolver;\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n+use rustc::hir::def_id;\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, NodeId, Ident};\n@@ -25,6 +26,7 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use std::{mem, ptr};\n use rustc_data_structures::sync::Lrc;\n+use syntax_pos::hygiene::AstPass;\n \n type Res = def::Res<NodeId>;\n \n@@ -95,16 +97,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.session.next_node_id()\n     }\n \n-    fn get_module_scope(&mut self, id: NodeId) -> ExpnId {\n-        let expn_id = ExpnId::fresh(Some(ExpnData::default(\n-            ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n-        )));\n-        let module = self.module_map[&self.definitions.local_def_id(id)];\n-        self.invocation_parent_scopes.insert(expn_id, ParentScope::module(module));\n-        self.definitions.set_invocation_parent(expn_id, module.def_id().unwrap().index);\n-        expn_id\n-    }\n-\n     fn resolve_dollar_crates(&mut self) {\n         hygiene::update_dollar_crate_names(|ctxt| {\n             let ident = Ident::new(kw::DollarCrate, DUMMY_SP.with_ctxt(ctxt));\n@@ -136,6 +128,37 @@ impl<'a> base::Resolver for Resolver<'a> {\n         }\n     }\n \n+    // Create a new Expansion with a definition site of the provided module, or\n+    // a fake empty `#[no_implicit_prelude]` module if no module is provided.\n+    fn expansion_for_ast_pass(\n+        &mut self,\n+        call_site: Span,\n+        pass: AstPass,\n+        features: &[Symbol],\n+        parent_module_id: Option<NodeId>,\n+    ) -> ExpnId {\n+        let expn_id = ExpnId::fresh(Some(ExpnData::allow_unstable(\n+            ExpnKind::AstPass(pass),\n+            call_site,\n+            self.session.edition(),\n+            features.into(),\n+        )));\n+\n+        let parent_scope = if let Some(module_id) = parent_module_id {\n+            let parent_def_id = self.definitions.local_def_id(module_id);\n+            self.definitions.add_parent_module_of_macro_def(expn_id, parent_def_id);\n+            self.module_map[&parent_def_id]\n+        } else {\n+            self.definitions.add_parent_module_of_macro_def(\n+                expn_id,\n+                def_id::DefId::local(def_id::CRATE_DEF_INDEX),\n+            );\n+            self.empty_module\n+        };\n+        self.ast_transform_scopes.insert(expn_id, parent_scope);\n+        expn_id\n+    }\n+\n     fn resolve_imports(&mut self) {\n         ImportResolver { r: self }.resolve_imports()\n     }"}, {"sha": "ca189e71800b36a4a9d7f59296d024e64c6ebb00", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -1307,12 +1307,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 None => continue,\n             };\n \n-            // Filter away ambiguous and gensymed imports. Gensymed imports\n-            // (e.g. implicitly injected `std`) cannot be properly encoded in metadata,\n-            // so they can cause name conflict errors downstream.\n-            let is_good_import = binding.is_import() && !binding.is_ambiguity() &&\n-                                 // Note that as_str() de-gensyms the Symbol\n-                                 !(ident.is_gensymed() && ident.name.as_str() != \"_\");\n+            // Filter away ambiguous imports and anything that has def-site\n+            // hygiene.\n+            // FIXME: Implement actual cross-crate hygiene.\n+            let is_good_import = binding.is_import() && !binding.is_ambiguity()\n+                && !ident.span.modern().from_expansion();\n             if is_good_import || binding.is_macro_def() {\n                 let res = binding.res();\n                 if res != Res::Err {"}, {"sha": "8502b89de1469b78c718075d4a5025f513e20274", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -1098,22 +1098,35 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn error_scrutinee_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {\n         struct_span_err!(\n-            self.tcx.sess, span, E0527,\n-            \"pattern requires {} elements but array has {}\",\n-            min_len, size\n+            self.tcx.sess,\n+            span,\n+            E0527,\n+            \"pattern requires {} element{} but array has {}\",\n+            min_len,\n+            if min_len != 1 { \"s\" } else { \"\" },\n+            size,\n         )\n-        .span_label(span, format!(\"expected {} elements\", size))\n+        .span_label(span, format!(\"expected {} element{}\", size, if size != 1 { \"s\" } else { \"\" }))\n         .emit();\n     }\n \n     fn error_scrutinee_with_rest_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {\n         struct_span_err!(\n-            self.tcx.sess, span, E0528,\n-            \"pattern requires at least {} elements but array has {}\",\n-            min_len, size\n-        )\n-        .span_label(span, format!(\"pattern cannot match array of {} elements\", size))\n-        .emit();\n+            self.tcx.sess,\n+            span,\n+            E0528,\n+            \"pattern requires at least {} element{} but array has {}\",\n+            min_len,\n+            if min_len != 1 { \"s\" } else { \"\" },\n+            size,\n+        ).span_label(\n+            span,\n+            format!(\n+                \"pattern cannot match array of {} element{}\",\n+                size,\n+                if size != 1 { \"s\" } else { \"\" },\n+            ),\n+        ).emit();\n     }\n \n     fn error_scrutinee_unfixed_length(&self, span: Span) {"}, {"sha": "69de3150354e7fe15537e19f4dbfd4234d6a15d7", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 13, "deletions": 46, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -16,7 +16,7 @@ use crate::mut_visit::visit_clobber;\n use crate::source_map::{BytePos, Spanned, DUMMY_SP};\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::parser::Parser;\n-use crate::parse::{self, ParseSess, PResult};\n+use crate::parse::{ParseSess, PResult};\n use crate::parse::token::{self, Token};\n use crate::ptr::P;\n use crate::symbol::{sym, Symbol};\n@@ -25,7 +25,7 @@ use crate::tokenstream::{TokenStream, TokenTree, DelimSpan};\n use crate::GLOBALS;\n \n use log::debug;\n-use syntax_pos::{FileName, Span};\n+use syntax_pos::Span;\n \n use std::iter;\n use std::ops::DerefMut;\n@@ -381,28 +381,25 @@ crate fn mk_attr_id() -> AttrId {\n     AttrId(id)\n }\n \n-/// Returns an inner attribute with the given value and span.\n-pub fn mk_attr_inner(item: MetaItem) -> Attribute {\n+pub fn mk_attr(style: AttrStyle, path: Path, tokens: TokenStream, span: Span) -> Attribute {\n     Attribute {\n         id: mk_attr_id(),\n-        style: ast::AttrStyle::Inner,\n-        path: item.path,\n-        tokens: item.node.tokens(item.span),\n+        style,\n+        path,\n+        tokens,\n         is_sugared_doc: false,\n-        span: item.span,\n+        span,\n     }\n }\n \n+/// Returns an inner attribute with the given value and span.\n+pub fn mk_attr_inner(item: MetaItem) -> Attribute {\n+    mk_attr(AttrStyle::Inner, item.path, item.node.tokens(item.span), item.span)\n+}\n+\n /// Returns an outer attribute with the given value and span.\n pub fn mk_attr_outer(item: MetaItem) -> Attribute {\n-    Attribute {\n-        id: mk_attr_id(),\n-        style: ast::AttrStyle::Outer,\n-        path: item.path,\n-        tokens: item.node.tokens(item.span),\n-        is_sugared_doc: false,\n-        span: item.span,\n-    }\n+    mk_attr(AttrStyle::Outer, item.path, item.node.tokens(item.span), item.span)\n }\n \n pub fn mk_sugared_doc_attr(text: Symbol, span: Span) -> Attribute {\n@@ -716,33 +713,3 @@ derive_has_attrs! {\n     Item, Expr, Local, ast::ForeignItem, ast::StructField, ast::ImplItem, ast::TraitItem, ast::Arm,\n     ast::Field, ast::FieldPat, ast::Variant, ast::Param\n }\n-\n-pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -> ast::Crate {\n-    for raw_attr in attrs {\n-        let mut parser = parse::new_parser_from_source_str(\n-            parse_sess,\n-            FileName::cli_crate_attr_source_code(&raw_attr),\n-            raw_attr.clone(),\n-        );\n-\n-        let start_span = parser.token.span;\n-        let (path, tokens) = panictry!(parser.parse_meta_item_unrestricted());\n-        let end_span = parser.token.span;\n-        if parser.token != token::Eof {\n-            parse_sess.span_diagnostic\n-                .span_err(start_span.to(end_span), \"invalid crate attribute\");\n-            continue;\n-        }\n-\n-        krate.attrs.push(Attribute {\n-            id: mk_attr_id(),\n-            style: AttrStyle::Inner,\n-            path,\n-            tokens,\n-            is_sugared_doc: false,\n-            span: start_span.to(end_span),\n-        });\n-    }\n-\n-    krate\n-}"}, {"sha": "5b2515d20cbab23504273eda22233492b8da7fe8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -3,7 +3,7 @@ use crate::attr::{self, HasAttrs, Stability, Deprecation};\n use crate::source_map::SourceMap;\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n-use crate::ext::hygiene::{ExpnId, Transparency};\n+use crate::ext::hygiene::ExpnId;\n use crate::mut_visit::{self, MutVisitor};\n use crate::parse::{self, parser, ParseSess, DirectoryOwnership};\n use crate::parse::token;\n@@ -16,7 +16,7 @@ use crate::visit::Visitor;\n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{FileName, Span, MultiSpan, DUMMY_SP};\n-use syntax_pos::hygiene::{ExpnData, ExpnKind};\n+use syntax_pos::hygiene::{AstPass, ExpnData, ExpnKind};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n@@ -732,13 +732,19 @@ bitflags::bitflags! {\n pub trait Resolver {\n     fn next_node_id(&mut self) -> NodeId;\n \n-    fn get_module_scope(&mut self, id: NodeId) -> ExpnId;\n-\n     fn resolve_dollar_crates(&mut self);\n     fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n                                             extra_placeholders: &[NodeId]);\n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension);\n \n+    fn expansion_for_ast_pass(\n+        &mut self,\n+        call_site: Span,\n+        pass: AstPass,\n+        features: &[Symbol],\n+        parent_module_id: Option<NodeId>,\n+    ) -> ExpnId;\n+\n     fn resolve_imports(&mut self);\n \n     fn resolve_macro_invocation(\n@@ -822,20 +828,20 @@ impl<'a> ExtCtxt<'a> {\n     /// Equivalent of `Span::def_site` from the proc macro API,\n     /// except that the location is taken from the span passed as an argument.\n     pub fn with_def_site_ctxt(&self, span: Span) -> Span {\n-        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::Opaque)\n+        span.with_def_site_ctxt(self.current_expansion.id)\n     }\n \n     /// Equivalent of `Span::call_site` from the proc macro API,\n     /// except that the location is taken from the span passed as an argument.\n     pub fn with_call_site_ctxt(&self, span: Span) -> Span {\n-        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::Transparent)\n+        span.with_call_site_ctxt(self.current_expansion.id)\n     }\n \n     /// Span with a context reproducing `macro_rules` hygiene (hygienic locals, unhygienic items).\n     /// FIXME: This should be eventually replaced either with `with_def_site_ctxt` (preferably),\n     /// or with `with_call_site_ctxt` (where necessary).\n     pub fn with_legacy_ctxt(&self, span: Span) -> Span {\n-        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::SemiTransparent)\n+        span.with_legacy_ctxt(self.current_expansion.id)\n     }\n \n     /// Returns span for the macro which originally caused the current expansion to happen."}, {"sha": "23735727fe8cfbc1c700cf83f64fca94dea1fc8f", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -345,8 +345,13 @@ impl LockstepIterSize {\n                 LockstepIterSize::Constraint(r_len, _) if l_len == r_len => self,\n                 LockstepIterSize::Constraint(r_len, r_id) => {\n                     let msg = format!(\n-                        \"meta-variable `{}` repeats {} times, but `{}` repeats {} times\",\n-                        l_id, l_len, r_id, r_len\n+                        \"meta-variable `{}` repeats {} time{}, but `{}` repeats {} time{}\",\n+                        l_id,\n+                        l_len,\n+                        if l_len != 1 { \"s\" } else { \"\" },\n+                        r_id,\n+                        r_len,\n+                        if r_len != 1 { \"s\" } else { \"\" },\n                     );\n                     LockstepIterSize::Contradiction(msg)\n                 }"}, {"sha": "d9c4baad49ded7a98a038f75a4ccbeb66549abbc", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -176,7 +176,7 @@ impl<'a> Parser<'a> {\n     /// PATH\n     /// PATH `=` TOKEN_TREE\n     /// The delimiters or `=` are still put into the resulting token stream.\n-    crate fn parse_meta_item_unrestricted(&mut self) -> PResult<'a, (ast::Path, TokenStream)> {\n+    pub fn parse_meta_item_unrestricted(&mut self) -> PResult<'a, (ast::Path, TokenStream)> {\n         let meta = match self.token.kind {\n             token::Interpolated(ref nt) => match **nt {\n                 Nonterminal::NtMeta(ref meta) => Some(meta.clone()),"}, {"sha": "d050d4f4ce705343ea27a153385c4ec4b36a120e", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -544,7 +544,7 @@ impl<'a> Parser<'a> {\n     /// Produce an error if comparison operators are chained (RFC #558).\n     /// We only need to check lhs, not rhs, because all comparison ops\n     /// have same precedence and are left-associative\n-    crate fn check_no_chained_comparison(&self, lhs: &Expr, outer_op: &AssocOp) {\n+    crate fn check_no_chained_comparison(&self, lhs: &Expr, outer_op: &AssocOp) -> PResult<'a, ()> {\n         debug_assert!(outer_op.is_comparison(),\n                       \"check_no_chained_comparison: {:?} is not comparison\",\n                       outer_op);\n@@ -563,11 +563,14 @@ impl<'a> Parser<'a> {\n                     err.help(\n                         \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n                     err.help(\"or use `(...)` if you meant to specify fn arguments\");\n+                    // These cases cause too many knock-down errors, bail out (#61329).\n+                    return Err(err);\n                 }\n                 err.emit();\n             }\n             _ => {}\n         }\n+        Ok(())\n     }\n \n     crate fn maybe_report_ambiguous_plus("}, {"sha": "ab5462baaf721283500467c42d28a3df62cc4fd5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -132,7 +132,7 @@ pub struct Parser<'a> {\n     /// into modules, and sub-parsers have new values for this name.\n     pub root_module_name: Option<String>,\n     crate expected_tokens: Vec<TokenType>,\n-    crate token_cursor: TokenCursor,\n+    token_cursor: TokenCursor,\n     desugar_doc_comments: bool,\n     /// `true` we should configure out of line modules as we parse.\n     pub cfg_mods: bool,\n@@ -161,19 +161,19 @@ impl<'a> Drop for Parser<'a> {\n }\n \n #[derive(Clone)]\n-crate struct TokenCursor {\n-    crate frame: TokenCursorFrame,\n-    crate stack: Vec<TokenCursorFrame>,\n+struct TokenCursor {\n+    frame: TokenCursorFrame,\n+    stack: Vec<TokenCursorFrame>,\n }\n \n #[derive(Clone)]\n-crate struct TokenCursorFrame {\n-    crate delim: token::DelimToken,\n-    crate span: DelimSpan,\n-    crate open_delim: bool,\n-    crate tree_cursor: tokenstream::Cursor,\n-    crate close_delim: bool,\n-    crate last_token: LastToken,\n+struct TokenCursorFrame {\n+    delim: token::DelimToken,\n+    span: DelimSpan,\n+    open_delim: bool,\n+    tree_cursor: tokenstream::Cursor,\n+    close_delim: bool,\n+    last_token: LastToken,\n }\n \n /// This is used in `TokenCursorFrame` above to track tokens that are consumed"}, {"sha": "e8c8e199fd06b9a463f4f12ac15f5742b24b4948", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -231,7 +231,7 @@ impl<'a> Parser<'a> {\n \n             self.bump();\n             if op.is_comparison() {\n-                self.check_no_chained_comparison(&lhs, &op);\n+                self.check_no_chained_comparison(&lhs, &op)?;\n             }\n             // Special cases:\n             if op == AssocOp::As {"}, {"sha": "8c1632dc7808d7a574343844c45afbb9e57f6a78", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -128,10 +128,14 @@ pub fn print_crate<'a>(cm: &'a SourceMap,\n         let fake_attr = attr::mk_attr_inner(list);\n         s.print_attribute(&fake_attr);\n \n-        // #![no_std]\n-        let no_std_meta = attr::mk_word_item(ast::Ident::with_dummy_span(sym::no_std));\n-        let fake_attr = attr::mk_attr_inner(no_std_meta);\n-        s.print_attribute(&fake_attr);\n+        // Currently on Rust 2018 we don't have `extern crate std;` at the crate\n+        // root, so this is not needed, and actually breaks things.\n+        if sess.edition == syntax_pos::edition::Edition::Edition2015 {\n+            // #![no_std]\n+            let no_std_meta = attr::mk_word_item(ast::Ident::with_dummy_span(sym::no_std));\n+            let fake_attr = attr::mk_attr_inner(no_std_meta);\n+            s.print_attribute(&fake_attr);\n+        }\n     }\n \n     s.print_mod(&krate.module, &krate.attrs);"}, {"sha": "fceaed360cdb4d408a333e764ecd9e4e61ae19a3", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -69,7 +69,7 @@ pub enum Fixity {\n \n impl AssocOp {\n     /// Creates a new AssocOP from a token\n-    pub fn from_token(t: &Token) -> Option<AssocOp> {\n+    crate fn from_token(t: &Token) -> Option<AssocOp> {\n         use AssocOp::*;\n         match t.kind {\n             token::BinOpEq(k) => Some(AssignOp(k)),"}, {"sha": "bb8e3df3db9215fcf33b57397070b190c2b5b3dd", "filename": "src/libsyntax_ext/cmdline_attrs.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Fcmdline_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Fcmdline_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcmdline_attrs.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -0,0 +1,30 @@\n+//! Attributes injected into the crate root from command line using `-Z crate-attr`.\n+\n+use syntax::ast::{self, AttrStyle};\n+use syntax::attr::mk_attr;\n+use syntax::panictry;\n+use syntax::parse::{self, token, ParseSess};\n+use syntax_pos::FileName;\n+\n+pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -> ast::Crate {\n+    for raw_attr in attrs {\n+        let mut parser = parse::new_parser_from_source_str(\n+            parse_sess,\n+            FileName::cli_crate_attr_source_code(&raw_attr),\n+            raw_attr.clone(),\n+        );\n+\n+        let start_span = parser.token.span;\n+        let (path, tokens) = panictry!(parser.parse_meta_item_unrestricted());\n+        let end_span = parser.token.span;\n+        if parser.token != token::Eof {\n+            parse_sess.span_diagnostic\n+                .span_err(start_span.to(end_span), \"invalid crate attribute\");\n+            continue;\n+        }\n+\n+        krate.attrs.push(mk_attr(AttrStyle::Inner, path, tokens, start_span.to(end_span)));\n+    }\n+\n+    krate\n+}"}, {"sha": "dec84c8286292bb03c2ee7287e42ada09dcbab6b", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -291,7 +291,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 &format!(\n                     \"{} positional argument{} in format string, but {}\",\n                     count,\n-                    if count > 1 { \"s\" } else { \"\" },\n+                    if count != 1 { \"s\" } else { \"\" },\n                     self.describe_num_args(),\n                 ),\n             );"}, {"sha": "5c0a63ebbe7cb0d29ddac8436638f2e6ff5747c9", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -40,6 +40,7 @@ mod source_util;\n mod test;\n mod trace_macros;\n \n+pub mod cmdline_attrs;\n pub mod plugin_macro_defs;\n pub mod proc_macro_harness;\n pub mod standard_library_imports;"}, {"sha": "ccdc5bd81a04b0bc133e71c0795e9ee3c01fa79a", "filename": "src/libsyntax_ext/plugin_macro_defs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -11,7 +11,7 @@ use syntax::source_map::respan;\n use syntax::symbol::sym;\n use syntax::tokenstream::*;\n use syntax_pos::{Span, DUMMY_SP};\n-use syntax_pos::hygiene::{ExpnData, ExpnKind, MacroKind};\n+use syntax_pos::hygiene::{ExpnData, ExpnKind, AstPass};\n \n use std::mem;\n \n@@ -44,7 +44,7 @@ pub fn inject(\n     if !named_exts.is_empty() {\n         let mut extra_items = Vec::new();\n         let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n-            ExpnKind::Macro(MacroKind::Attr, sym::plugin), DUMMY_SP, edition,\n+            ExpnKind::AstPass(AstPass::PluginMacroDefs), DUMMY_SP, edition,\n             [sym::rustc_attrs][..].into(),\n         ));\n         for (name, ext) in named_exts {"}, {"sha": "31d32d23a645ebd3b1a7109b0d0226323f7de770", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -3,15 +3,15 @@ use std::mem;\n use smallvec::smallvec;\n use syntax::ast::{self, Ident};\n use syntax::attr;\n-use syntax::source_map::{ExpnData, ExpnKind, respan};\n-use syntax::ext::base::{ExtCtxt, MacroKind};\n+use syntax::ext::base::ExtCtxt;\n use syntax::ext::expand::{AstFragment, ExpansionConfig};\n use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::hygiene::AstPass;\n \n struct ProcMacroDerive {\n     trait_name: ast::Name,\n@@ -308,8 +308,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n \n // Creates a new module which looks like:\n //\n-//      #[doc(hidden)]\n-//      mod $gensym {\n+//      const _: () = {\n //          extern crate proc_macro;\n //\n //          use proc_macro::bridge::client::ProcMacro;\n@@ -327,32 +326,30 @@ fn mk_decls(\n     custom_attrs: &[ProcMacroDef],\n     custom_macros: &[ProcMacroDef],\n ) -> P<ast::Item> {\n-    let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n-        ExpnKind::Macro(MacroKind::Attr, sym::proc_macro), DUMMY_SP, cx.parse_sess.edition,\n-        [sym::rustc_attrs, sym::proc_macro_internals][..].into(),\n-    ));\n-\n-    let hidden = cx.meta_list_item_word(span, sym::hidden);\n-    let doc = cx.meta_list(span, sym::doc, vec![hidden]);\n-    let doc_hidden = cx.attribute(doc);\n-\n-    let proc_macro = Ident::with_dummy_span(sym::proc_macro);\n+    let expn_id = cx.resolver.expansion_for_ast_pass(\n+        DUMMY_SP,\n+        AstPass::ProcMacroHarness,\n+        &[sym::rustc_attrs, sym::proc_macro_internals],\n+        None,\n+    );\n+    let span = DUMMY_SP.with_def_site_ctxt(expn_id);\n+\n+    let proc_macro = Ident::new(sym::proc_macro, span);\n     let krate = cx.item(span,\n                         proc_macro,\n                         Vec::new(),\n                         ast::ItemKind::ExternCrate(None));\n \n-    let bridge = Ident::from_str(\"bridge\");\n-    let client = Ident::from_str(\"client\");\n-    let proc_macro_ty = Ident::from_str(\"ProcMacro\");\n-    let custom_derive = Ident::from_str(\"custom_derive\");\n-    let attr = Ident::from_str(\"attr\");\n-    let bang = Ident::from_str(\"bang\");\n-    let crate_kw = Ident::with_dummy_span(kw::Crate);\n+    let bridge = Ident::from_str_and_span(\"bridge\", span);\n+    let client = Ident::from_str_and_span(\"client\", span);\n+    let proc_macro_ty = Ident::from_str_and_span(\"ProcMacro\", span);\n+    let custom_derive = Ident::from_str_and_span(\"custom_derive\", span);\n+    let attr = Ident::from_str_and_span(\"attr\", span);\n+    let bang = Ident::from_str_and_span(\"bang\", span);\n \n     let decls = {\n         let local_path = |sp: Span, name| {\n-            cx.expr_path(cx.path(sp.with_ctxt(span.ctxt()), vec![crate_kw, name]))\n+            cx.expr_path(cx.path(sp.with_ctxt(span.ctxt()), vec![name]))\n         };\n         let proc_macro_ty_method_path = |method| cx.expr_path(cx.path(span, vec![\n             proc_macro, bridge, client, proc_macro_ty, method,\n@@ -381,7 +378,7 @@ fn mk_decls(\n \n     let decls_static = cx.item_static(\n         span,\n-        Ident::from_str(\"_DECLS\"),\n+        Ident::from_str_and_span(\"_DECLS\", span),\n         cx.ty_rptr(span,\n             cx.ty(span, ast::TyKind::Slice(\n                 cx.ty_path(cx.path(span,\n@@ -392,22 +389,22 @@ fn mk_decls(\n     ).map(|mut i| {\n         let attr = cx.meta_word(span, sym::rustc_proc_macro_decls);\n         i.attrs.push(cx.attribute(attr));\n-        i.vis = respan(span, ast::VisibilityKind::Public);\n         i\n     });\n \n-    let module = cx.item_mod(\n+    let block = cx.expr_block(cx.block(\n         span,\n-        span,\n-        ast::Ident::from_str(\"decls\").gensym(),\n-        vec![doc_hidden],\n-        vec![krate, decls_static],\n-    ).map(|mut i| {\n-        i.vis = respan(span, ast::VisibilityKind::Public);\n-        i\n-    });\n+        vec![cx.stmt_item(span, krate), cx.stmt_item(span, decls_static)],\n+    ));\n \n-    // Integrate the new module into existing module structures.\n-    let module = AstFragment::Items(smallvec![module]);\n-    cx.monotonic_expander().fully_expand_fragment(module).make_items().pop().unwrap()\n+    let anon_constant = cx.item_const(\n+        span,\n+        ast::Ident::new(kw::Underscore, span),\n+        cx.ty(span, ast::TyKind::Tup(Vec::new())),\n+        block,\n+    );\n+\n+    // Integrate the new item into existing module structures.\n+    let items = AstFragment::Items(smallvec![anon_constant]);\n+    cx.monotonic_expander().fully_expand_fragment(items).make_items().pop().unwrap()\n }"}, {"sha": "c577b1e33cfebab0f18d8fc90d33d569bcaa051f", "filename": "src/libsyntax_ext/standard_library_imports.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fstandard_library_imports.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -1,86 +1,86 @@\n use syntax::{ast, attr};\n use syntax::edition::Edition;\n-use syntax::ext::hygiene::MacroKind;\n+use syntax::ext::expand::ExpansionConfig;\n+use syntax::ext::hygiene::AstPass;\n+use syntax::ext::base::{ExtCtxt, Resolver};\n+use syntax::parse::ParseSess;\n use syntax::ptr::P;\n-use syntax::source_map::{ExpnData, ExpnKind, dummy_spanned, respan};\n use syntax::symbol::{Ident, Symbol, kw, sym};\n use syntax_pos::DUMMY_SP;\n \n-use std::iter;\n-\n pub fn inject(\n-    mut krate: ast::Crate, alt_std_name: Option<&str>, edition: Edition\n+    mut krate: ast::Crate,\n+    resolver: &mut dyn Resolver,\n+    sess: &ParseSess,\n+    alt_std_name: Option<Symbol>,\n ) -> (ast::Crate, Option<Symbol>) {\n-    let rust_2018 = edition >= Edition::Edition2018;\n+    let rust_2018 = sess.edition >= Edition::Edition2018;\n \n     // the first name in this list is the crate name of the crate with the prelude\n-    let names: &[&str] = if attr::contains_name(&krate.attrs, sym::no_core) {\n+    let names: &[Symbol] = if attr::contains_name(&krate.attrs, sym::no_core) {\n         return (krate, None);\n     } else if attr::contains_name(&krate.attrs, sym::no_std) {\n         if attr::contains_name(&krate.attrs, sym::compiler_builtins) {\n-            &[\"core\"]\n+            &[sym::core]\n         } else {\n-            &[\"core\", \"compiler_builtins\"]\n+            &[sym::core, sym::compiler_builtins]\n         }\n     } else {\n-        &[\"std\"]\n+        &[sym::std]\n     };\n \n+    let expn_id = resolver.expansion_for_ast_pass(\n+        DUMMY_SP,\n+        AstPass::StdImports,\n+        &[sym::prelude_import],\n+        None,\n+    );\n+    let span = DUMMY_SP.with_def_site_ctxt(expn_id);\n+    let call_site = DUMMY_SP.with_call_site_ctxt(expn_id);\n+\n+    let ecfg = ExpansionConfig::default(\"std_lib_injection\".to_string());\n+    let cx = ExtCtxt::new(sess, ecfg, resolver);\n+\n+\n     // .rev() to preserve ordering above in combination with insert(0, ...)\n-    let alt_std_name = alt_std_name.map(Symbol::intern);\n-    for orig_name_str in names.iter().rev() {\n-        // HACK(eddyb) gensym the injected crates on the Rust 2018 edition,\n-        // so they don't accidentally interfere with the new import paths.\n-        let orig_name_sym = Symbol::intern(orig_name_str);\n-        let orig_name_ident = Ident::with_dummy_span(orig_name_sym);\n-        let (rename, orig_name) = if rust_2018 {\n-            (orig_name_ident.gensym(), Some(orig_name_sym))\n+    for &name in names.iter().rev() {\n+        let ident = if rust_2018 {\n+            Ident::new(name, span)\n         } else {\n-            (orig_name_ident, None)\n+            Ident::new(name, call_site)\n         };\n-        krate.module.items.insert(0, P(ast::Item {\n-            attrs: vec![attr::mk_attr_outer(\n-                attr::mk_word_item(ast::Ident::with_dummy_span(sym::macro_use))\n-            )],\n-            vis: dummy_spanned(ast::VisibilityKind::Inherited),\n-            node: ast::ItemKind::ExternCrate(alt_std_name.or(orig_name)),\n-            ident: rename,\n-            id: ast::DUMMY_NODE_ID,\n-            span: DUMMY_SP,\n-            tokens: None,\n-        }));\n+        krate.module.items.insert(0, cx.item(\n+            span,\n+            ident,\n+            vec![cx.attribute(cx.meta_word(span, sym::macro_use))],\n+            ast::ItemKind::ExternCrate(alt_std_name),\n+        ));\n     }\n \n-    // the crates have been injected, the assumption is that the first one is the one with\n-    // the prelude.\n+    // The crates have been injected, the assumption is that the first one is\n+    // the one with the prelude.\n     let name = names[0];\n \n-    let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n-        ExpnKind::Macro(MacroKind::Attr, sym::std_inject), DUMMY_SP, edition,\n-        [sym::prelude_import][..].into(),\n-    ));\n+    let import_path = if rust_2018 {\n+        [name, sym::prelude, sym::v1].iter()\n+            .map(|symbol| ast::Ident::new(*symbol, span)).collect()\n+    } else {\n+        [kw::PathRoot, name, sym::prelude, sym::v1].iter()\n+            .map(|symbol| ast::Ident::new(*symbol, span)).collect()\n+    };\n \n-    krate.module.items.insert(0, P(ast::Item {\n-        attrs: vec![attr::mk_attr_outer(\n-            attr::mk_word_item(ast::Ident::new(sym::prelude_import, span)))],\n-        vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n-        node: ast::ItemKind::Use(P(ast::UseTree {\n-            prefix: ast::Path {\n-                segments: iter::once(ast::Ident::with_dummy_span(kw::PathRoot))\n-                    .chain(\n-                        [name, \"prelude\", \"v1\"].iter().cloned()\n-                            .map(ast::Ident::from_str)\n-                    ).map(ast::PathSegment::from_ident).collect(),\n-                span,\n-            },\n+    let use_item = cx.item(\n+        span,\n+        ast::Ident::invalid(),\n+        vec![cx.attribute(cx.meta_word(span, sym::prelude_import))],\n+        ast::ItemKind::Use(P(ast::UseTree {\n+            prefix: cx.path(span, import_path),\n             kind: ast::UseTreeKind::Glob,\n             span,\n         })),\n-        id: ast::DUMMY_NODE_ID,\n-        ident: ast::Ident::invalid(),\n-        span,\n-        tokens: None,\n-    }));\n+    );\n+\n+    krate.module.items.insert(0, use_item);\n \n-    (krate, Some(Symbol::intern(name)))\n+    (krate, Some(name))\n }"}, {"sha": "be5aca73f5cb1d504849c19ece1f934b0837c2ee", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -28,11 +28,11 @@ pub fn expand_test_case(\n \n     if !ecx.ecfg.should_test { return vec![]; }\n \n-    let sp = ecx.with_legacy_ctxt(attr_sp);\n+    let sp = ecx.with_def_site_ctxt(attr_sp);\n     let mut item = anno_item.expect_item();\n     item = item.map(|mut item| {\n         item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n-        item.ident = item.ident.gensym();\n+        item.ident.span = item.ident.span.with_ctxt(sp.ctxt());\n         item.attrs.push(\n             ecx.attribute(ecx.meta_word(sp, sym::rustc_test_marker))\n         );\n@@ -92,10 +92,9 @@ pub fn expand_test_or_bench(\n         return vec![Annotatable::Item(item)];\n     }\n \n-    let (sp, attr_sp) = (cx.with_legacy_ctxt(item.span), cx.with_legacy_ctxt(attr_sp));\n+    let (sp, attr_sp) = (cx.with_def_site_ctxt(item.span), cx.with_def_site_ctxt(attr_sp));\n \n-    // Gensym \"test\" so we can extern crate without conflicting with any local names\n-    let test_id = cx.ident_of(\"test\").gensym();\n+    let test_id = ast::Ident::new(sym::test, attr_sp);\n \n     // creates test::$name\n     let test_path = |name| {\n@@ -112,7 +111,7 @@ pub fn expand_test_or_bench(\n \n     let test_fn = if is_bench {\n         // A simple ident for a lambda\n-        let b = cx.ident_of(\"b\");\n+        let b = ast::Ident::from_str_and_span(\"b\", attr_sp);\n \n         cx.expr_call(sp, cx.expr_path(test_path(\"StaticBenchFn\")), vec![\n             // |b| self::test::assert_test_result(\n@@ -143,7 +142,7 @@ pub fn expand_test_or_bench(\n         ])\n     };\n \n-    let mut test_const = cx.item(sp, ast::Ident::new(item.ident.name, sp).gensym(),\n+    let mut test_const = cx.item(sp, ast::Ident::new(item.ident.name, sp),\n         vec![\n             // #[cfg(test)]\n             cx.attribute(cx.meta_list(attr_sp, sym::cfg, vec![\n@@ -192,17 +191,17 @@ pub fn expand_test_or_bench(\n         ));\n     test_const = test_const.map(|mut tc| { tc.vis.node = ast::VisibilityKind::Public; tc});\n \n-    // extern crate test as test_gensym\n+    // extern crate test\n     let test_extern = cx.item(sp,\n         test_id,\n         vec![],\n-        ast::ItemKind::ExternCrate(Some(sym::test))\n+        ast::ItemKind::ExternCrate(None)\n     );\n \n     log::debug!(\"synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n \n     vec![\n-        // Access to libtest under a gensymed name\n+        // Access to libtest under a hygienic name\n         Annotatable::Item(test_extern),\n         // The generated test case\n         Annotatable::Item(test_const),"}, {"sha": "b93c11fad382391f3f2c4c5f40cb2854b6342991", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 95, "deletions": 148, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -5,32 +5,30 @@ use smallvec::{smallvec, SmallVec};\n use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::entry::{self, EntryPointType};\n-use syntax::ext::base::{ExtCtxt, MacroKind, Resolver};\n+use syntax::ext::base::{ExtCtxt, Resolver};\n use syntax::ext::expand::{AstFragment, ExpansionConfig};\n use syntax::feature_gate::Features;\n use syntax::mut_visit::{*, ExpectOne};\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n-use syntax::source_map::{ExpnData, ExpnKind, dummy_spanned};\n-use syntax::symbol::{kw, sym, Symbol};\n+use syntax::source_map::respan;\n+use syntax::symbol::{sym, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::hygiene::{AstPass, SyntaxContext, Transparency};\n \n use std::{iter, mem};\n \n struct Test {\n     span: Span,\n-    path: Vec<Ident>,\n+    ident: Ident,\n }\n \n struct TestCtxt<'a> {\n-    span_diagnostic: &'a errors::Handler,\n-    path: Vec<Ident>,\n     ext_cx: ExtCtxt<'a>,\n+    def_site: Span,\n     test_cases: Vec<Test>,\n     reexport_test_harness_main: Option<Symbol>,\n     test_runner: Option<ast::Path>,\n-    // top-level re-export submodule, filled out after folding is finished\n-    toplevel_reexport: Option<Ident>,\n }\n \n // Traverse the crate, collecting all the test functions, eliding any\n@@ -43,8 +41,8 @@ pub fn inject(\n     span_diagnostic: &errors::Handler,\n     features: &Features,\n ) {\n-    // Check for #[reexport_test_harness_main = \"some_name\"] which\n-    // creates a `use __test::main as some_name;`. This needs to be\n+    // Check for #![reexport_test_harness_main = \"some_name\"] which gives the\n+    // main test function the name `some_name` without hygiene. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n@@ -56,16 +54,13 @@ pub fn inject(\n \n     if should_test {\n         generate_test_harness(sess, resolver, reexport_test_harness_main,\n-                              krate, span_diagnostic, features, test_runner)\n+                              krate, features, test_runner)\n     }\n }\n \n struct TestHarnessGenerator<'a> {\n     cx: TestCtxt<'a>,\n-    tests: Vec<Ident>,\n-\n-    // submodule name, gensym'd identifier for re-exports\n-    tested_submods: Vec<(Ident, Ident)>,\n+    tests: Vec<Test>,\n }\n \n impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n@@ -77,49 +72,47 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n     }\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n-        let ident = i.ident;\n-        if ident.name != kw::Invalid {\n-            self.cx.path.push(ident);\n-        }\n-        debug!(\"current path: {}\", path_name_i(&self.cx.path));\n-\n         let mut item = i.into_inner();\n         if is_test_case(&item) {\n             debug!(\"this is a test item\");\n \n             let test = Test {\n                 span: item.span,\n-                path: self.cx.path.clone(),\n+                ident: item.ident,\n             };\n-            self.cx.test_cases.push(test);\n-            self.tests.push(item.ident);\n+            self.tests.push(test);\n         }\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n         if let ast::ItemKind::Mod(mut module) = item.node {\n             let tests = mem::take(&mut self.tests);\n-            let tested_submods = mem::take(&mut self.tested_submods);\n             noop_visit_mod(&mut module, self);\n-            let tests = mem::replace(&mut self.tests, tests);\n-            let tested_submods = mem::replace(&mut self.tested_submods, tested_submods);\n+            let mut tests = mem::replace(&mut self.tests, tests);\n \n-            if !tests.is_empty() || !tested_submods.is_empty() {\n-                let (it, sym) = mk_reexport_mod(&mut self.cx, item.id, tests, tested_submods);\n-                module.items.push(it);\n-\n-                if !self.cx.path.is_empty() {\n-                    self.tested_submods.push((self.cx.path[self.cx.path.len()-1], sym));\n+            if !tests.is_empty() {\n+                let parent = if item.id == ast::DUMMY_NODE_ID {\n+                    ast::CRATE_NODE_ID\n                 } else {\n-                    debug!(\"pushing nothing, sym: {:?}\", sym);\n-                    self.cx.toplevel_reexport = Some(sym);\n+                    item.id\n+                };\n+                // Create an identifier that will hygienically resolve the test\n+                // case name, even in another module.\n+                let expn_id = self.cx.ext_cx.resolver.expansion_for_ast_pass(\n+                    module.inner,\n+                    AstPass::TestHarness,\n+                    &[],\n+                    Some(parent),\n+                );\n+                for test in &mut tests {\n+                    // See the comment on `mk_main` for why we're using\n+                    // `apply_mark` directly.\n+                    test.ident.span = test.ident.span.apply_mark(expn_id, Transparency::Opaque);\n                 }\n+                self.cx.test_cases.extend(tests);\n             }\n             item.node = ast::ItemKind::Mod(module);\n         }\n-        if ident.name != kw::Invalid {\n-            self.cx.path.pop();\n-        }\n         smallvec![P(item)]\n     }\n \n@@ -133,6 +126,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n struct EntryPointCleaner {\n     // Current depth in the ast\n     depth: usize,\n+    def_site: Span,\n }\n \n impl MutVisitor for EntryPointCleaner {\n@@ -149,8 +143,10 @@ impl MutVisitor for EntryPointCleaner {\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n                 item.map(|ast::Item {id, ident, attrs, node, vis, span, tokens}| {\n-                    let allow_ident = Ident::with_dummy_span(sym::allow);\n-                    let dc_nested = attr::mk_nested_word_item(Ident::from_str(\"dead_code\"));\n+                    let allow_ident = Ident::new(sym::allow, self.def_site);\n+                    let dc_nested = attr::mk_nested_word_item(\n+                        Ident::from_str_and_span(\"dead_code\", self.def_site),\n+                    );\n                     let allow_dead_code_item = attr::mk_list_item(allow_ident, vec![dc_nested]);\n                     let allow_dead_code = attr::mk_attr_outer(allow_dead_code_item);\n \n@@ -181,124 +177,99 @@ impl MutVisitor for EntryPointCleaner {\n     }\n }\n \n-/// Creates an item (specifically a module) that \"pub use\"s the tests passed in.\n-/// Each tested submodule will contain a similar reexport module that we will export\n-/// under the name of the original module. That is, `submod::__test_reexports` is\n-/// reexported like so `pub use submod::__test_reexports as submod`.\n-fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n-                   parent: ast::NodeId,\n-                   tests: Vec<Ident>,\n-                   tested_submods: Vec<(Ident, Ident)>)\n-                   -> (P<ast::Item>, Ident) {\n-    let super_ = Ident::with_dummy_span(kw::Super);\n-\n-    let items = tests.into_iter().map(|r| {\n-        cx.ext_cx.item_use_simple(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public),\n-                                  cx.ext_cx.path(DUMMY_SP, vec![super_, r]))\n-    }).chain(tested_submods.into_iter().map(|(r, sym)| {\n-        let path = cx.ext_cx.path(DUMMY_SP, vec![super_, r, sym]);\n-        cx.ext_cx.item_use_simple_(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public),\n-                                   Some(r), path)\n-    })).collect();\n-\n-    let reexport_mod = ast::Mod {\n-        inline: true,\n-        inner: DUMMY_SP,\n-        items,\n-    };\n-\n-    let name = Ident::from_str(\"__test_reexports\").gensym();\n-    let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n-    cx.ext_cx.current_expansion.id = cx.ext_cx.resolver.get_module_scope(parent);\n-    let module = P(ast::Item {\n-        ident: name,\n-        attrs: Vec::new(),\n-        id: ast::DUMMY_NODE_ID,\n-        node: ast::ItemKind::Mod(reexport_mod),\n-        vis: dummy_spanned(ast::VisibilityKind::Public),\n-        span: DUMMY_SP,\n-        tokens: None,\n-    });\n-\n-    // Integrate the new module into existing module structures.\n-    let module = AstFragment::Items(smallvec![module]);\n-    let module =\n-        cx.ext_cx.monotonic_expander().fully_expand_fragment(module).make_items().pop().unwrap();\n-\n-    (module, name)\n-}\n-\n /// Crawl over the crate, inserting test reexports and the test main function\n fn generate_test_harness(sess: &ParseSess,\n                          resolver: &mut dyn Resolver,\n                          reexport_test_harness_main: Option<Symbol>,\n                          krate: &mut ast::Crate,\n-                         sd: &errors::Handler,\n                          features: &Features,\n                          test_runner: Option<ast::Path>) {\n-    // Remove the entry points\n-    let mut cleaner = EntryPointCleaner { depth: 0 };\n-    cleaner.visit_crate(krate);\n-\n     let mut econfig = ExpansionConfig::default(\"test\".to_string());\n     econfig.features = Some(features);\n \n+    let ext_cx = ExtCtxt::new(sess, econfig, resolver);\n+\n+    let expn_id = ext_cx.resolver.expansion_for_ast_pass(\n+        DUMMY_SP,\n+        AstPass::TestHarness,\n+        &[sym::main, sym::test, sym::rustc_attrs],\n+        None,\n+    );\n+    let def_site = DUMMY_SP.with_def_site_ctxt(expn_id);\n+\n+    // Remove the entry points\n+    let mut cleaner = EntryPointCleaner { depth: 0, def_site };\n+    cleaner.visit_crate(krate);\n+\n     let cx = TestCtxt {\n-        span_diagnostic: sd,\n-        ext_cx: ExtCtxt::new(sess, econfig, resolver),\n-        path: Vec::new(),\n+        ext_cx,\n+        def_site,\n         test_cases: Vec::new(),\n         reexport_test_harness_main,\n-        toplevel_reexport: None,\n         test_runner\n     };\n \n     TestHarnessGenerator {\n         cx,\n         tests: Vec::new(),\n-        tested_submods: Vec::new(),\n     }.visit_crate(krate);\n }\n \n /// Creates a function item for use as the main function of a test build.\n /// This function will call the `test_runner` as specified by the crate attribute\n+///\n+/// By default this expands to\n+///\n+/// #[main]\n+/// pub fn main() {\n+///     extern crate test;\n+///     test::test_main_static(&[\n+///         &test_const1,\n+///         &test_const2,\n+///         &test_const3,\n+///     ]);\n+/// }\n+///\n+/// Most of the Ident have the usual def-site hygiene for the AST pass. The\n+/// exception is the `test_const`s. These have a syntax context that has two\n+/// opaque marks: one from the expansion of `test` or `test_case`, and one\n+/// generated  in `TestHarnessGenerator::flat_map_item`. When resolving this\n+/// identifier after failing to find a matching identifier in the root module\n+/// we remove the outer mark, and try resolving at its def-site, which will\n+/// then resolve to `test_const`.\n+///\n+/// The expansion here can be controlled by two attributes:\n+///\n+/// `reexport_test_harness_main` provides a different name for the `main`\n+/// function and `test_runner` provides a path that replaces\n+/// `test::test_main_static`.\n fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n-    // Writing this out by hand:\n-    //        pub fn main() {\n-    //            #![main]\n-    //            test::test_main_static(&[..tests]);\n-    //        }\n-    let sp = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n-        ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, cx.ext_cx.parse_sess.edition,\n-        [sym::main, sym::test, sym::rustc_attrs][..].into(),\n-    ));\n+    let sp = cx.def_site;\n     let ecx = &cx.ext_cx;\n-    let test_id = Ident::with_dummy_span(sym::test);\n+    let test_id = Ident::new(sym::test, sp);\n \n     // test::test_main_static(...)\n     let mut test_runner = cx.test_runner.clone().unwrap_or(\n-        ecx.path(sp, vec![\n-            test_id, ecx.ident_of(\"test_main_static\")\n-        ]));\n+        ecx.path(sp, vec![test_id, Ident::from_str_and_span(\"test_main_static\", sp)]));\n \n     test_runner.span = sp;\n \n     let test_main_path_expr = ecx.expr_path(test_runner);\n     let call_test_main = ecx.expr_call(sp, test_main_path_expr,\n-                                       vec![mk_tests_slice(cx)]);\n+                                       vec![mk_tests_slice(cx, sp)]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n \n-    // #![main]\n-    let main_meta = ecx.meta_word(sp, sym::main);\n-    let main_attr = ecx.attribute(main_meta);\n-\n-    // extern crate test as test_gensym\n+    // extern crate test\n     let test_extern_stmt = ecx.stmt_item(sp, ecx.item(sp,\n         test_id,\n         vec![],\n         ast::ItemKind::ExternCrate(None)\n     ));\n \n+    // #[main]\n+    let main_meta = ecx.meta_word(sp, sym::main);\n+    let main_attr = ecx.attribute(main_meta);\n+\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n \n@@ -316,16 +287,16 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n \n     // Honor the reexport_test_harness_main attribute\n     let main_id = match cx.reexport_test_harness_main {\n-        Some(sym) => Ident::new(sym, sp),\n-        None => Ident::from_str_and_span(\"main\", sp).gensym(),\n+        Some(sym) => Ident::new(sym, sp.with_ctxt(SyntaxContext::root())),\n+        None => Ident::from_str_and_span(\"main\", sp),\n     };\n \n     let main = P(ast::Item {\n         ident: main_id,\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n-        vis: dummy_spanned(ast::VisibilityKind::Public),\n+        vis: respan(sp, ast::VisibilityKind::Public),\n         span: sp,\n         tokens: None,\n     });\n@@ -335,44 +306,20 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     cx.ext_cx.monotonic_expander().fully_expand_fragment(main).make_items().pop().unwrap()\n }\n \n-fn path_name_i(idents: &[Ident]) -> String {\n-    let mut path_name = \"\".to_string();\n-    let mut idents_iter = idents.iter().peekable();\n-    while let Some(ident) = idents_iter.next() {\n-        path_name.push_str(&ident.as_str());\n-        if idents_iter.peek().is_some() {\n-            path_name.push_str(\"::\")\n-        }\n-    }\n-    path_name\n-}\n-\n /// Creates a slice containing every test like so:\n-/// &[path::to::test1, path::to::test2]\n-fn mk_tests_slice(cx: &TestCtxt<'_>) -> P<ast::Expr> {\n+/// &[&test1, &test2]\n+fn mk_tests_slice(cx: &TestCtxt<'_>, sp: Span) -> P<ast::Expr> {\n     debug!(\"building test vector from {} tests\", cx.test_cases.len());\n     let ref ecx = cx.ext_cx;\n \n-    ecx.expr_vec_slice(DUMMY_SP,\n+\n+    ecx.expr_vec_slice(sp,\n         cx.test_cases.iter().map(|test| {\n             ecx.expr_addr_of(test.span,\n-                ecx.expr_path(ecx.path(test.span, visible_path(cx, &test.path))))\n+                ecx.expr_path(ecx.path(test.span, vec![test.ident])))\n         }).collect())\n }\n \n-/// Creates a path from the top-level __test module to the test via __test_reexports\n-fn visible_path(cx: &TestCtxt<'_>, path: &[Ident]) -> Vec<Ident>{\n-    let mut visible_path = vec![];\n-    match cx.toplevel_reexport {\n-        Some(id) => visible_path.push(id),\n-        None => {\n-            cx.span_diagnostic.bug(\"expected to find top-level re-export name, but found None\");\n-        }\n-    }\n-    visible_path.extend_from_slice(path);\n-    visible_path\n-}\n-\n fn is_test_case(i: &ast::Item) -> bool {\n     attr::contains_name(&i.attrs, sym::rustc_test_marker)\n }"}, {"sha": "f0e7344c1b9860ff950da975c486b457f2e752d2", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -360,7 +360,7 @@ impl SyntaxContext {\n     }\n \n     /// Extend a syntax context with a given expansion and transparency.\n-    pub fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> SyntaxContext {\n+    crate fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> SyntaxContext {\n         HygieneData::with(|data| data.apply_mark(self, expn_id, transparency))\n     }\n \n@@ -550,7 +550,7 @@ impl Span {\n     /// The returned span belongs to the created expansion and has the new properties,\n     /// but its location is inherited from the current span.\n     pub fn fresh_expansion(self, expn_data: ExpnData) -> Span {\n-        self.fresh_expansion_with_transparency(expn_data, Transparency::SemiTransparent)\n+        self.fresh_expansion_with_transparency(expn_data, Transparency::Transparent)\n     }\n \n     pub fn fresh_expansion_with_transparency(\n@@ -639,8 +639,9 @@ pub enum ExpnKind {\n     /// No expansion, aka root expansion. Only `ExpnId::root()` has this kind.\n     Root,\n     /// Expansion produced by a macro.\n-    /// FIXME: Some code injected by the compiler before HIR lowering also gets this kind.\n     Macro(MacroKind, Symbol),\n+    /// Transform done by the compiler on the AST.\n+    AstPass(AstPass),\n     /// Desugaring done by the compiler during HIR lowering.\n     Desugaring(DesugaringKind)\n }\n@@ -650,6 +651,7 @@ impl ExpnKind {\n         match *self {\n             ExpnKind::Root => kw::PathRoot,\n             ExpnKind::Macro(_, descr) => descr,\n+            ExpnKind::AstPass(kind) => Symbol::intern(kind.descr()),\n             ExpnKind::Desugaring(kind) => Symbol::intern(kind.descr()),\n         }\n     }\n@@ -683,6 +685,26 @@ impl MacroKind {\n     }\n }\n \n+/// The kind of AST transform.\n+#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+pub enum AstPass {\n+    StdImports,\n+    TestHarness,\n+    ProcMacroHarness,\n+    PluginMacroDefs,\n+}\n+\n+impl AstPass {\n+    fn descr(self) -> &'static str {\n+        match self {\n+            AstPass::StdImports => \"standard library imports\",\n+            AstPass::TestHarness => \"test harness\",\n+            AstPass::ProcMacroHarness => \"proc macro harness\",\n+            AstPass::PluginMacroDefs => \"plugin macro definitions\",\n+        }\n+    }\n+}\n+\n /// The kind of compiler desugaring.\n #[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum DesugaringKind {"}, {"sha": "9a296f17aaf4aa26cc274ba2b0644b4e8e1887f6", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -442,6 +442,7 @@ impl Span {\n                 let (pre, post) = match expn_data.kind {\n                     ExpnKind::Root => break,\n                     ExpnKind::Desugaring(..) => (\"desugaring of \", \"\"),\n+                    ExpnKind::AstPass(..) => (\"\", \"\"),\n                     ExpnKind::Macro(macro_kind, _) => match macro_kind {\n                         MacroKind::Bang => (\"\", \"!\"),\n                         MacroKind::Attr => (\"#[\", \"]\"),\n@@ -513,6 +514,25 @@ impl Span {\n                   span.ctxt)\n     }\n \n+    /// Equivalent of `Span::def_site` from the proc macro API,\n+    /// except that the location is taken from the `self` span.\n+    pub fn with_def_site_ctxt(self, expn_id: ExpnId) -> Span {\n+        self.with_ctxt_from_mark(expn_id, Transparency::Opaque)\n+    }\n+\n+    /// Equivalent of `Span::call_site` from the proc macro API,\n+    /// except that the location is taken from the `self` span.\n+    pub fn with_call_site_ctxt(&self, expn_id: ExpnId) -> Span {\n+        self.with_ctxt_from_mark(expn_id, Transparency::Transparent)\n+    }\n+\n+    /// Span with a context reproducing `macro_rules` hygiene (hygienic locals, unhygienic items).\n+    /// FIXME: This should be eventually replaced either with `with_def_site_ctxt` (preferably),\n+    /// or with `with_call_site_ctxt` (where necessary).\n+    pub fn with_legacy_ctxt(&self, expn_id: ExpnId) -> Span {\n+        self.with_ctxt_from_mark(expn_id, Transparency::SemiTransparent)\n+    }\n+\n     /// Produces a span with the same location as `self` and context produced by a macro with the\n     /// given ID and transparency, assuming that macro was defined directly and not produced by\n     /// some other macro (which is the case for built-in and procedural macros)."}, {"sha": "ecc31cfeb3d1f00491f7bde328ef2c7a47bea18c", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -801,21 +801,15 @@ impl Ident {\n         Ident::new(self.name, self.span.modern_and_legacy())\n     }\n \n-    /// Transforms an identifier into one with the same name, but gensymed.\n-    pub fn gensym(self) -> Ident {\n-        let name = with_interner(|interner| interner.gensymed(self.name));\n-        Ident::new(name, self.span)\n-    }\n-\n     /// Transforms an underscore identifier into one with the same name, but\n     /// gensymed. Leaves non-underscore identifiers unchanged.\n     pub fn gensym_if_underscore(self) -> Ident {\n-        if self.name == kw::Underscore { self.gensym() } else { self }\n-    }\n-\n-    // WARNING: this function is deprecated and will be removed in the future.\n-    pub fn is_gensymed(self) -> bool {\n-        with_interner(|interner| interner.is_gensymed(self.name))\n+        if self.name == kw::Underscore {\n+            let name = with_interner(|interner| interner.gensymed(self.name));\n+            Ident::new(name, self.span)\n+        } else {\n+            self\n+        }\n     }\n \n     /// Convert the name to a `LocalInternedString`. This is a slowish\n@@ -892,9 +886,12 @@ impl UseSpecializedDecodable for Ident {\n ///\n /// Examples:\n /// ```\n-/// assert_eq!(Ident::from_str(\"x\"), Ident::from_str(\"x\"))\n-/// assert_ne!(Ident::from_str(\"x\").gensym(), Ident::from_str(\"x\"))\n-/// assert_ne!(Ident::from_str(\"x\").gensym(), Ident::from_str(\"x\").gensym())\n+/// assert_eq!(Ident::from_str(\"_\"), Ident::from_str(\"_\"))\n+/// assert_ne!(Ident::from_str(\"_\").gensym_if_underscore(), Ident::from_str(\"_\"))\n+/// assert_ne!(\n+///     Ident::from_str(\"_\").gensym_if_underscore(),\n+///     Ident::from_str(\"_\").gensym_if_underscore(),\n+/// )\n /// ```\n /// Internally, a symbol is implemented as an index, and all operations\n /// (including hashing, equality, and ordering) operate on that index. The use"}, {"sha": "3140a7c6b6cc2fef663d5ed682c37f43b6c498d2", "filename": "src/test/codegen/var-names.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fcodegen%2Fvar-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fcodegen%2Fvar-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvar-names.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -O -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: define i32 @test(i32 %a, i32 %b)\n+#[no_mangle]\n+pub fn test(a: u32, b: u32) -> u32 {\n+    let c = a + b;\n+    // CHECK: %c = add i32 %a, %b\n+    let d = c;\n+    let e = d * a;\n+    // CHECK-NEXT: %e = mul i32 %c, %a\n+    e\n+    // CHECK-NEXT: ret i32 %e\n+}"}, {"sha": "596f515da2f7fc8f0a3ba8a26567c99abda2f676", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -32,13 +32,15 @@ use syntax::print::pprust;\n use syntax::ptr::P;\n \n \n-fn parse_expr(ps: &ParseSess, src: &str) -> P<Expr> {\n+fn parse_expr(ps: &ParseSess, src: &str) -> Option<P<Expr>> {\n     let src_as_string = src.to_string();\n \n-    let mut p = parse::new_parser_from_source_str(ps,\n-                                                  FileName::Custom(src_as_string.clone()),\n-                                                  src_as_string);\n-    p.parse_expr().unwrap()\n+    let mut p = parse::new_parser_from_source_str(\n+        ps,\n+        FileName::Custom(src_as_string.clone()),\n+        src_as_string,\n+    );\n+    p.parse_expr().map_err(|mut e| e.cancel()).ok()\n }\n \n \n@@ -209,22 +211,23 @@ fn run() {\n         let printed = pprust::expr_to_string(&e);\n         println!(\"printed: {}\", printed);\n \n-        let mut parsed = parse_expr(&ps, &printed);\n-\n-        // We want to know if `parsed` is structurally identical to `e`, ignoring trivial\n-        // differences like placement of `Paren`s or the exact ranges of node spans.\n-        // Unfortunately, there is no easy way to make this comparison. Instead, we add `Paren`s\n-        // everywhere we can, then pretty-print. This should give an unambiguous representation of\n-        // each `Expr`, and it bypasses nearly all of the parenthesization logic, so we aren't\n-        // relying on the correctness of the very thing we're testing.\n-        RemoveParens.visit_expr(&mut e);\n-        AddParens.visit_expr(&mut e);\n-        let text1 = pprust::expr_to_string(&e);\n-        RemoveParens.visit_expr(&mut parsed);\n-        AddParens.visit_expr(&mut parsed);\n-        let text2 = pprust::expr_to_string(&parsed);\n-        assert!(text1 == text2,\n-                \"exprs are not equal:\\n  e =      {:?}\\n  parsed = {:?}\",\n-                text1, text2);\n+        // Ignore expressions with chained comparisons that fail to parse\n+        if let Some(mut parsed) = parse_expr(&ps, &printed) {\n+            // We want to know if `parsed` is structurally identical to `e`, ignoring trivial\n+            // differences like placement of `Paren`s or the exact ranges of node spans.\n+            // Unfortunately, there is no easy way to make this comparison. Instead, we add `Paren`s\n+            // everywhere we can, then pretty-print. This should give an unambiguous representation\n+            // of each `Expr`, and it bypasses nearly all of the parenthesization logic, so we\n+            // aren't relying on the correctness of the very thing we're testing.\n+            RemoveParens.visit_expr(&mut e);\n+            AddParens.visit_expr(&mut e);\n+            let text1 = pprust::expr_to_string(&e);\n+            RemoveParens.visit_expr(&mut parsed);\n+            AddParens.visit_expr(&mut parsed);\n+            let text2 = pprust::expr_to_string(&parsed);\n+            assert!(text1 == text2,\n+                    \"exprs are not equal:\\n  e =      {:?}\\n  parsed = {:?}\",\n+                    text1, text2);\n+        }\n     });\n }"}, {"sha": "b69edcf26063738cc7d22383b64ff3649c82fa4d", "filename": "src/test/ui/coercion/coercion-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fcoercion%2Fcoercion-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fcoercion%2Fcoercion-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoercion-slice.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     let _: &[i32] = [0];\n     //~^ ERROR mismatched types\n     //~| expected type `&[i32]`\n-    //~| expected &[i32], found array of 1 elements\n+    //~| expected &[i32], found array of 1 element\n }"}, {"sha": "ccd776e9879382b0bddada16fd54304b5e64482e", "filename": "src/test/ui/coercion/coercion-slice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fcoercion%2Fcoercion-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fcoercion%2Fcoercion-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoercion-slice.stderr?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL |     let _: &[i32] = [0];\n    |                     ^^^\n    |                     |\n-   |                     expected &[i32], found array of 1 elements\n+   |                     expected &[i32], found array of 1 element\n    |                     help: consider borrowing here: `&[0]`\n    |\n    = note: expected type `&[i32]`"}, {"sha": "6902779f33d23c7a3497e96c1a5ba43d5ee7aa30", "filename": "src/test/ui/did_you_mean/issue-40396.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -1,27 +1,16 @@\n fn foo() {\n     (0..13).collect<Vec<i32>>();\n     //~^ ERROR chained comparison\n-    //~| ERROR expected value, found struct `Vec`\n-    //~| ERROR expected value, found builtin type `i32`\n-    //~| ERROR attempted to take value of method `collect`\n }\n \n fn bar() {\n     Vec<i32>::new();\n     //~^ ERROR chained comparison\n-    //~| ERROR expected value, found struct `Vec`\n-    //~| ERROR expected value, found builtin type `i32`\n-    //~| ERROR cannot find function `new` in the crate root\n }\n \n fn qux() {\n     (0..13).collect<Vec<i32>();\n     //~^ ERROR chained comparison\n-    //~| ERROR chained comparison\n-    //~| ERROR expected value, found struct `Vec`\n-    //~| ERROR expected value, found builtin type `i32`\n-    //~| ERROR attempted to take value of method `collect`\n-    //~| ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "7a08fda27e355c3d6816cfafe251d57443fcc19c", "filename": "src/test/ui/did_you_mean/issue-40396.stderr", "status": "modified", "additions": 3, "deletions": 77, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -8,7 +8,7 @@ LL |     (0..13).collect<Vec<i32>>();\n    = help: or use `(...)` if you meant to specify fn arguments\n \n error: chained comparison operators require parentheses\n-  --> $DIR/issue-40396.rs:10:8\n+  --> $DIR/issue-40396.rs:7:8\n    |\n LL |     Vec<i32>::new();\n    |        ^^^^^^^\n@@ -17,87 +17,13 @@ LL |     Vec<i32>::new();\n    = help: or use `(...)` if you meant to specify fn arguments\n \n error: chained comparison operators require parentheses\n-  --> $DIR/issue-40396.rs:18:20\n+  --> $DIR/issue-40396.rs:12:20\n    |\n LL |     (0..13).collect<Vec<i32>();\n    |                    ^^^^^^^^\n    |\n    = help: use `::<...>` instead of `<...>` if you meant to specify type arguments\n    = help: or use `(...)` if you meant to specify fn arguments\n \n-error: chained comparison operators require parentheses\n-  --> $DIR/issue-40396.rs:18:24\n-   |\n-LL |     (0..13).collect<Vec<i32>();\n-   |                        ^^^^^^\n-   |\n-   = help: use `::<...>` instead of `<...>` if you meant to specify type arguments\n-   = help: or use `(...)` if you meant to specify fn arguments\n-\n-error[E0423]: expected value, found struct `Vec`\n-  --> $DIR/issue-40396.rs:2:21\n-   |\n-LL |     (0..13).collect<Vec<i32>>();\n-   |                     ^^^ did you mean `Vec { /* fields */ }`?\n-\n-error[E0423]: expected value, found builtin type `i32`\n-  --> $DIR/issue-40396.rs:2:25\n-   |\n-LL |     (0..13).collect<Vec<i32>>();\n-   |                         ^^^ not a value\n-\n-error[E0423]: expected value, found struct `Vec`\n-  --> $DIR/issue-40396.rs:10:5\n-   |\n-LL |     Vec<i32>::new();\n-   |     ^^^ did you mean `Vec { /* fields */ }`?\n-\n-error[E0423]: expected value, found builtin type `i32`\n-  --> $DIR/issue-40396.rs:10:9\n-   |\n-LL |     Vec<i32>::new();\n-   |         ^^^ not a value\n-\n-error[E0425]: cannot find function `new` in the crate root\n-  --> $DIR/issue-40396.rs:10:15\n-   |\n-LL |     Vec<i32>::new();\n-   |               ^^^ not found in the crate root\n-\n-error[E0423]: expected value, found struct `Vec`\n-  --> $DIR/issue-40396.rs:18:21\n-   |\n-LL |     (0..13).collect<Vec<i32>();\n-   |                     ^^^ did you mean `Vec { /* fields */ }`?\n-\n-error[E0423]: expected value, found builtin type `i32`\n-  --> $DIR/issue-40396.rs:18:25\n-   |\n-LL |     (0..13).collect<Vec<i32>();\n-   |                         ^^^ not a value\n-\n-error[E0615]: attempted to take value of method `collect` on type `std::ops::Range<{integer}>`\n-  --> $DIR/issue-40396.rs:2:13\n-   |\n-LL |     (0..13).collect<Vec<i32>>();\n-   |             ^^^^^^^ help: use parentheses to call the method: `collect()`\n-\n-error[E0615]: attempted to take value of method `collect` on type `std::ops::Range<{integer}>`\n-  --> $DIR/issue-40396.rs:18:13\n-   |\n-LL |     (0..13).collect<Vec<i32>();\n-   |             ^^^^^^^ help: use parentheses to call the method: `collect()`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/issue-40396.rs:18:29\n-   |\n-LL |     (0..13).collect<Vec<i32>();\n-   |                             ^^ expected bool, found ()\n-   |\n-   = note: expected type `bool`\n-              found type `()`\n-\n-error: aborting due to 14 previous errors\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0308, E0423, E0425, E0615.\n-For more information about an error, try `rustc --explain E0308`."}, {"sha": "babba293d03bdded07a45c0a558a857cedb7445c", "filename": "src/test/ui/hygiene/auxiliary/not-libstd.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fnot-libstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fnot-libstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fnot-libstd.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -0,0 +1 @@\n+pub fn not_in_lib_std() {}"}, {"sha": "51e7bed6580b35b369281f9a7b4399d33089d3e1", "filename": "src/test/ui/hygiene/prelude-import-hygiene.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fhygiene%2Fprelude-import-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fhygiene%2Fprelude-import-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fprelude-import-hygiene.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -0,0 +1,29 @@\n+// Make sure that attribute used when injecting the prelude are resolved\n+// hygienically.\n+\n+// check-pass\n+// aux-build:not-libstd.rs\n+\n+//revisions: rust2015 rust2018\n+//[rust2018] edition:2018\n+\n+// The prelude import shouldn't see these as candidates for when it's trying to\n+// use the built-in macros.\n+extern crate core;\n+use core::prelude::v1::test as prelude_import;\n+use core::prelude::v1::test as macro_use;\n+\n+// Should not be used for the prelude import - not a concern in the 2015 edition\n+// because `std` is already declared in the crate root.\n+#[cfg(rust2018)]\n+extern crate not_libstd as std;\n+\n+#[cfg(rust2018)]\n+mod x {\n+    // The extern crate item should override `std` in the extern prelude.\n+    fn f() {\n+        std::not_in_lib_std();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "7b53f0c536ad9917b1f40e40e61b2112ce3d023e", "filename": "src/test/ui/imports/gensymed.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fimports%2Fgensymed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fimports%2Fgensymed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fgensymed.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -1,7 +1,9 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n // edition:2018\n // aux-build:gensymed.rs\n \n extern crate gensymed;\n \n+use gensymed::*;\n+\n fn main() {}"}, {"sha": "b6a817e6b1d303c6c1444105ae1c9d585ebd45a2", "filename": "src/test/ui/inaccessible-test-modules.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/da13f06ea0dc368f1350bfc356b7f81a838defde/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da13f06ea0dc368f1350bfc356b7f81a838defde/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr?ref=da13f06ea0dc368f1350bfc356b7f81a838defde", "patch": "@@ -1,21 +0,0 @@\n-error[E0432]: unresolved import `__test`\n-  --> $DIR/inaccessible-test-modules.rs:5:5\n-   |\n-LL | use __test as x;\n-   |     ------^^^^^\n-   |     |\n-   |     no `__test` in the root\n-   |     help: a similar name exists in the module: `test`\n-\n-error[E0432]: unresolved import `__test_reexports`\n-  --> $DIR/inaccessible-test-modules.rs:6:5\n-   |\n-LL | use __test_reexports as y;\n-   |     ----------------^^^^^\n-   |     |\n-   |     no `__test_reexports` in the root\n-   |     help: a similar name exists in the module: `__test_reexports`\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0432`."}, {"sha": "5189f550cfbd6c67ff23b8e4f1c055dc50e37976", "filename": "src/test/ui/issues/issue-15783.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fissues%2Fissue-15783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fissues%2Fissue-15783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15783.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -6,9 +6,9 @@ fn main() {\n     let name = \"Foo\";\n     let x = Some(&[name]);\n     let msg = foo(x);\n-//~^ ERROR mismatched types\n-//~| expected type `std::option::Option<&[&str]>`\n-//~| found type `std::option::Option<&[&str; 1]>`\n-//~| expected slice, found array of 1 elements\n+    //~^ ERROR mismatched types\n+    //~| expected type `std::option::Option<&[&str]>`\n+    //~| found type `std::option::Option<&[&str; 1]>`\n+    //~| expected slice, found array of 1 element\n     assert_eq!(msg, 3);\n }"}, {"sha": "1d54b2830d6c5b6b87470c54e87aca9edb311ae2", "filename": "src/test/ui/issues/issue-15783.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fissues%2Fissue-15783.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fissues%2Fissue-15783.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15783.stderr?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-15783.rs:8:19\n    |\n LL |     let msg = foo(x);\n-   |                   ^ expected slice, found array of 1 elements\n+   |                   ^ expected slice, found array of 1 element\n    |\n    = note: expected type `std::option::Option<&[&str]>`\n               found type `std::option::Option<&[&str; 1]>`"}, {"sha": "a3523bb689e6b326bee7c2274a5a7c0bd6f15bb7", "filename": "src/test/ui/match/match-vec-mismatch.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fmatch%2Fmatch-vec-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fmatch%2Fmatch-vec-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-vec-mismatch.stderr?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -10,7 +10,7 @@ error[E0529]: expected an array or slice, found `std::string::String`\n LL |         ['f', 'o', ..] => {}\n    |         ^^^^^^^^^^^^^^ pattern cannot match with input type `std::string::String`\n \n-error[E0527]: pattern requires 1 elements but array has 3\n+error[E0527]: pattern requires 1 element but array has 3\n   --> $DIR/match-vec-mismatch.rs:20:9\n    |\n LL |         [0] => {},"}, {"sha": "3dcc0c8f3d496eb03e6cd0a641c264b868014117", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -11,8 +11,7 @@ fn main() {\n     //~| ERROR: mismatched types\n \n     f<X>();\n-    //~^ ERROR: chained comparison operators require parentheses\n-    //~| ERROR: binary operation `<` cannot be applied to type `fn() {f::<_>}`\n+    //~^ ERROR chained comparison operators require parentheses\n     //~| HELP: use `::<...>` instead of `<...>`\n     //~| HELP: or use `(...)`\n }"}, {"sha": "e927f4c32484ededce5d662205d609a516e8fb77", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.stderr", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -37,17 +37,6 @@ LL |     false == 0 < 2;\n    = note: expected type `bool`\n               found type `{integer}`\n \n-error[E0369]: binary operation `<` cannot be applied to type `fn() {f::<_>}`\n-  --> $DIR/require-parens-for-chained-comparison.rs:13:6\n-   |\n-LL |     f<X>();\n-   |     -^- X\n-   |     |\n-   |     fn() {f::<_>}\n-   |\n-   = note: an implementation of `std::cmp::PartialOrd` might be missing for `fn() {f::<_>}`\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0308, E0369.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "c8b0eb684f33dff1c14b7017bf1990b4d66076c0", "filename": "src/test/ui/parser/trait-object-lifetime-parens.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -9,7 +9,6 @@ fn check<'a>() {\n     let _: Box<('a) + Trait>;\n     //~^ ERROR expected type, found `'a`\n     //~| ERROR expected `:`, found `)`\n-    //~| ERROR chained comparison operators require parentheses\n }\n \n fn main() {}"}, {"sha": "319a308c0137c307bddf0b693ccc617fc02d0a1f", "filename": "src/test/ui/parser/trait-object-lifetime-parens.stderr", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -16,15 +16,6 @@ error: expected `:`, found `)`\n LL |     let _: Box<('a) + Trait>;\n    |                   ^ expected `:`\n \n-error: chained comparison operators require parentheses\n-  --> $DIR/trait-object-lifetime-parens.rs:9:15\n-   |\n-LL |     let _: Box<('a) + Trait>;\n-   |               ^^^^^^^^^^^^^^^\n-   |\n-   = help: use `::<...>` instead of `<...>` if you meant to specify type arguments\n-   = help: or use `(...)` if you meant to specify fn arguments\n-\n error: expected type, found `'a`\n   --> $DIR/trait-object-lifetime-parens.rs:9:17\n    |\n@@ -33,5 +24,5 @@ LL |     let _: Box<('a) + Trait>;\n    |         |\n    |         while parsing the type for `_`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "ea06f6c1acaf993b948b6c64543e0c6c6cfe597b", "filename": "src/test/ui/proc-macro/dollar-crate-issue-57089.stdout", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -2,80 +2,80 @@ PRINT-BANG INPUT (DISPLAY): struct M ($crate :: S) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"M\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"A\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]"}, {"sha": "7ee8078b2c5d2210f7aacefc22ab4cad1da28656", "filename": "src/test/ui/proc-macro/dollar-crate-issue-62325.stdout", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -3,110 +3,110 @@ PRINT-ATTR RE-COLLECTED (DISPLAY): struct A (identity ! ($crate :: S)) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"A\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"identity\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: '!',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Group {\n                 delimiter: Parenthesis,\n                 stream: TokenStream [\n                     Ident {\n                         ident: \"$crate\",\n-                        span: #2 bytes(LO..HI),\n+                        span: #3 bytes(LO..HI),\n                     },\n                     Punct {\n                         ch: ':',\n                         spacing: Joint,\n-                        span: #2 bytes(LO..HI),\n+                        span: #3 bytes(LO..HI),\n                     },\n                     Punct {\n                         ch: ':',\n                         spacing: Alone,\n-                        span: #2 bytes(LO..HI),\n+                        span: #3 bytes(LO..HI),\n                     },\n                     Ident {\n                         ident: \"S\",\n-                        span: #2 bytes(LO..HI),\n+                        span: #3 bytes(LO..HI),\n                     },\n                 ],\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct B(identity!(::dollar_crate_external :: S));\n PRINT-ATTR RE-COLLECTED (DISPLAY): struct B (identity ! ($crate :: S)) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #7 bytes(LO..HI),\n+        span: #8 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"B\",\n-        span: #7 bytes(LO..HI),\n+        span: #8 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"identity\",\n-                span: #7 bytes(LO..HI),\n+                span: #8 bytes(LO..HI),\n             },\n             Punct {\n                 ch: '!',\n                 spacing: Alone,\n-                span: #7 bytes(LO..HI),\n+                span: #8 bytes(LO..HI),\n             },\n             Group {\n                 delimiter: Parenthesis,\n                 stream: TokenStream [\n                     Ident {\n                         ident: \"$crate\",\n-                        span: #7 bytes(LO..HI),\n+                        span: #8 bytes(LO..HI),\n                     },\n                     Punct {\n                         ch: ':',\n                         spacing: Joint,\n-                        span: #7 bytes(LO..HI),\n+                        span: #8 bytes(LO..HI),\n                     },\n                     Punct {\n                         ch: ':',\n                         spacing: Alone,\n-                        span: #7 bytes(LO..HI),\n+                        span: #8 bytes(LO..HI),\n                     },\n                     Ident {\n                         ident: \"S\",\n-                        span: #7 bytes(LO..HI),\n+                        span: #8 bytes(LO..HI),\n                     },\n                 ],\n-                span: #7 bytes(LO..HI),\n+                span: #8 bytes(LO..HI),\n             },\n         ],\n-        span: #7 bytes(LO..HI),\n+        span: #8 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #7 bytes(LO..HI),\n+        span: #8 bytes(LO..HI),\n     },\n ]"}, {"sha": "4f7e000265eb02fd757f6160b04b79851662940f", "filename": "src/test/ui/proc-macro/dollar-crate.stdout", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -2,243 +2,243 @@ PRINT-BANG INPUT (DISPLAY): struct M ($crate :: S) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"M\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"A\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): struct D(crate::S);\n PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ($crate :: S) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"D\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-BANG INPUT (DISPLAY): struct M ($crate :: S) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"M\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n         ],\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(::dollar_crate_external::S);\n PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"A\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n         ],\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): struct D(::dollar_crate_external::S);\n PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ($crate :: S) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"D\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n         ],\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n ]"}, {"sha": "60a98ab6a026be32398e5645e40e16b6bb9f175a", "filename": "src/test/ui/test-attrs/auxiliary/test_macro.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Fauxiliary%2Ftest_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Fauxiliary%2Ftest_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Fauxiliary%2Ftest_macro.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-shadowing/auxiliary/test_macro.rs"}, {"sha": "fcbe9f49e556497b49d0ed97162969ac9f86a78e", "filename": "src/test/ui/test-attrs/decl-macro-test.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Fdecl-macro-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Fdecl-macro-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Fdecl-macro-test.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -0,0 +1,22 @@\n+// Check that declarative macros can declare tests\n+\n+// check-pass\n+// compile-flags: --test\n+\n+#![feature(decl_macro)]\n+\n+macro create_test() {\n+    #[test]\n+    fn test() {}\n+}\n+\n+macro create_module_test() {\n+    mod x {\n+        #[test]\n+        fn test() {}\n+    }\n+}\n+\n+create_test!();\n+create_test!();\n+create_module_test!();"}, {"sha": "f5b34793794805cf44dbd090e16b977b5b40e670", "filename": "src/test/ui/test-attrs/inaccessible-test-modules.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -2,8 +2,8 @@\n \n // the `--test` harness creates modules with these textual names, but\n // they should be inaccessible from normal code.\n-use __test as x; //~ ERROR unresolved import `__test`\n-use __test_reexports as y; //~ ERROR unresolved import `__test_reexports`\n+use main as x; //~ ERROR unresolved import `main`\n+use test as y; //~ ERROR unresolved import `test`\n \n #[test]\n fn baz() {}", "previous_filename": "src/test/ui/inaccessible-test-modules.rs"}, {"sha": "a94ea1e79bc5199afe75779d024cf0f59551ff8d", "filename": "src/test/ui/test-attrs/inaccessible-test-modules.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.stderr?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -0,0 +1,21 @@\n+error[E0432]: unresolved import `main`\n+  --> $DIR/inaccessible-test-modules.rs:5:5\n+   |\n+LL | use main as x;\n+   |     ----^^^^^\n+   |     |\n+   |     no `main` in the root\n+   |     help: a similar name exists in the module: `main`\n+\n+error[E0432]: unresolved import `test`\n+  --> $DIR/inaccessible-test-modules.rs:6:5\n+   |\n+LL | use test as y;\n+   |     ----^^^^^\n+   |     |\n+   |     no `test` in the root\n+   |     help: a similar name exists in the module: `test`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "1a478460efc6c8954c6714450b848652cd700a85", "filename": "src/test/ui/test-attrs/test-allow-fail-attr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-allow-fail-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-allow-fail-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-allow-fail-attr.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-allow-fail-attr.rs"}, {"sha": "e475f5b4a75a515f7d97b02a1583ce120617bc94", "filename": "src/test/ui/test-attrs/test-attr-non-associated-functions.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-attr-non-associated-functions.rs"}, {"sha": "cb3ae51823e45bd993f6500b2f54613be44306ee", "filename": "src/test/ui/test-attrs/test-attr-non-associated-functions.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.stderr?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-attr-non-associated-functions.stderr"}, {"sha": "831372d4506b312288dcb831d5b4da0995a587fa", "filename": "src/test/ui/test-attrs/test-cant-be-shadowed.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-cant-be-shadowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-cant-be-shadowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-cant-be-shadowed.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-shadowing/test-cant-be-shadowed.rs"}, {"sha": "ff62d84925f2be110481038ef91511a185d28788", "filename": "src/test/ui/test-attrs/test-fn-signature-verification-for-explicit-return-type.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-fn-signature-verification-for-explicit-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-fn-signature-verification-for-explicit-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-fn-signature-verification-for-explicit-return-type.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-fn-signature-verification-for-explicit-return-type.rs"}, {"sha": "628b1896ace4f32a4b1baae1e18cf57a23b3ac8e", "filename": "src/test/ui/test-attrs/test-main-not-dead-attr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-main-not-dead-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-main-not-dead-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-main-not-dead-attr.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-main-not-dead-attr.rs"}, {"sha": "30a9c85e3d2abe503f89abd97c5541fb6feb5bdb", "filename": "src/test/ui/test-attrs/test-main-not-dead.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-main-not-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-main-not-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-main-not-dead.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-main-not-dead.rs"}, {"sha": "a238db6d716238c699c745d29922045376fd7010", "filename": "src/test/ui/test-attrs/test-on-macro.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-macro.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-on-macro.rs"}, {"sha": "256a41722fa956534e09d2b713d65b83a44c3f37", "filename": "src/test/ui/test-attrs/test-on-macro.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-macro.stderr?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-on-macro.stderr"}, {"sha": "917c09801e1750f62a25d4912abe41f17c4f083c", "filename": "src/test/ui/test-attrs/test-runner-hides-buried-main.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-buried-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-buried-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-buried-main.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-runner-hides-buried-main.rs"}, {"sha": "0de1d64f0fcc71420fb58e68fdd8fb6e84eb65b3", "filename": "src/test/ui/test-attrs/test-runner-hides-main.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-main.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-runner-hides-main.rs"}, {"sha": "56212bb6f4b7357a475baab7cd5a5612d67b77d9", "filename": "src/test/ui/test-attrs/test-runner-hides-start.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-start.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-start.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-start.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-runner-hides-start.rs"}, {"sha": "9fa759f9eb4837a25ff0b215cba976b78f849412", "filename": "src/test/ui/test-attrs/test-should-fail-good-message.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-fail-good-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-fail-good-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-fail-good-message.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-should-fail-good-message.rs"}, {"sha": "9c38322fe96fd754f209b1b26bdeb2b0d21bd645", "filename": "src/test/ui/test-attrs/test-should-panic-attr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-panic-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-panic-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-panic-attr.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-should-panic-attr.rs"}, {"sha": "4b032eba5f8d577e0d25634858b9e8d2253cad41", "filename": "src/test/ui/test-attrs/test-should-panic-attr.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-panic-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-panic-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-panic-attr.stderr?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-should-panic-attr.stderr"}, {"sha": "cd1cd33c2840b5d28b8384fd6f8f8d3d750f94bc", "filename": "src/test/ui/test-attrs/test-vs-cfg-test.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-vs-cfg-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-vs-cfg-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-vs-cfg-test.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-vs-cfg-test.rs"}, {"sha": "936461f162d688cf3c08506372f3299f724f950d", "filename": "src/test/ui/test-attrs/test-warns-dead-code.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-warns-dead-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-warns-dead-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-warns-dead-code.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-warns-dead-code.rs"}, {"sha": "62e99225dd90266c00dcba212613a50f48403c5c", "filename": "src/test/ui/test-attrs/test-warns-dead-code.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-warns-dead-code.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-warns-dead-code.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-warns-dead-code.stderr?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "previous_filename": "src/test/ui/test-warns-dead-code.stderr"}, {"sha": "d5dc9a79b5acb5678113e37d77cc446b10425f9c", "filename": "src/tools/rustbook/src/main.rs", "status": "modified", "additions": 54, "deletions": 34, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef54f57c5b9d894a38179d09b00610c1b337b086/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs?ref=ef54f57c5b9d894a38179d09b00610c1b337b086", "patch": "@@ -1,18 +1,19 @@\n-use clap::{crate_version};\n+use clap::crate_version;\n \n use std::env;\n use std::path::{Path, PathBuf};\n \n-use clap::{App, ArgMatches, SubCommand, AppSettings};\n+use clap::{App, AppSettings, ArgMatches, SubCommand};\n \n+use mdbook::errors::Result as Result3;\n use mdbook::MDBook;\n-use mdbook::errors::{Result as Result3};\n \n+#[cfg(feature = \"linkcheck\")]\n+use failure::Error;\n #[cfg(feature = \"linkcheck\")]\n use mdbook::renderer::RenderContext;\n #[cfg(feature = \"linkcheck\")]\n use mdbook_linkcheck::{self, errors::BrokenLinks};\n-use failure::Error;\n \n fn main() {\n     let d_message = \"-d, --dest-dir=[dest-dir]\n@@ -21,18 +22,22 @@ fn main() {\n 'A directory for your book{n}(Defaults to Current Directory when omitted)'\";\n \n     let matches = App::new(\"rustbook\")\n-                    .about(\"Build a book with mdBook\")\n-                    .author(\"Steve Klabnik <steve@steveklabnik.com>\")\n-                    .version(&*format!(\"v{}\", crate_version!()))\n-                    .setting(AppSettings::SubcommandRequired)\n-                    .subcommand(SubCommand::with_name(\"build\")\n-                        .about(\"Build the book from the markdown files\")\n-                        .arg_from_usage(d_message)\n-                        .arg_from_usage(dir_message))\n-                    .subcommand(SubCommand::with_name(\"linkcheck\")\n-                        .about(\"Run linkcheck with mdBook 3\")\n-                        .arg_from_usage(dir_message))\n-                    .get_matches();\n+        .about(\"Build a book with mdBook\")\n+        .author(\"Steve Klabnik <steve@steveklabnik.com>\")\n+        .version(&*format!(\"v{}\", crate_version!()))\n+        .setting(AppSettings::SubcommandRequired)\n+        .subcommand(\n+            SubCommand::with_name(\"build\")\n+                .about(\"Build the book from the markdown files\")\n+                .arg_from_usage(d_message)\n+                .arg_from_usage(dir_message),\n+        )\n+        .subcommand(\n+            SubCommand::with_name(\"linkcheck\")\n+                .about(\"Run linkcheck with mdBook 3\")\n+                .arg_from_usage(dir_message),\n+        )\n+        .get_matches();\n \n     // Check which subcomamnd the user ran...\n     match matches.subcommand() {\n@@ -46,23 +51,44 @@ fn main() {\n \n                 ::std::process::exit(101);\n             }\n-        },\n+        }\n         (\"linkcheck\", Some(sub_matches)) => {\n-            if let Err(err) = linkcheck(sub_matches) {\n-                eprintln!(\"Error: {}\", err);\n-\n-                #[cfg(feature = \"linkcheck\")]\n-                {\n-                    if let Ok(broken_links) = err.downcast::<BrokenLinks>() {\n-                        for cause in broken_links.links().iter() {\n-                            eprintln!(\"\\tCaused By: {}\", cause);\n-                        }\n+            #[cfg(feature = \"linkcheck\")]\n+            {\n+                if let Err(err) = linkcheck(sub_matches) {\n+                    eprintln!(\"Error: {}\", err);\n+\n+                    // HACK: ignore timeouts\n+                    let actually_broken = err\n+                        .downcast::<BrokenLinks>()\n+                        .map(|broken_links| {\n+                            broken_links\n+                                .links()\n+                                .iter()\n+                                .inspect(|cause| eprintln!(\"\\tCaused By: {}\", cause))\n+                                .fold(false, |already_broken, cause| {\n+                                    already_broken || !format!(\"{}\", cause).contains(\"timed out\")\n+                                })\n+                        })\n+                        .unwrap_or(false);\n+\n+                    if actually_broken {\n+                        std::process::exit(101);\n+                    } else {\n+                        std::process::exit(0);\n                     }\n                 }\n+            }\n \n-                ::std::process::exit(101);\n+            #[cfg(not(feature = \"linkcheck\"))]\n+            {\n+                // This avoids the `unused_binding` lint.\n+                println!(\n+                    \"mdbook-linkcheck is disabled, but arguments were passed: {:?}\",\n+                    sub_matches\n+                );\n             }\n-        },\n+        }\n         (_, _) => unreachable!(),\n     };\n }\n@@ -77,12 +103,6 @@ pub fn linkcheck(args: &ArgMatches<'_>) -> Result<(), Error> {\n     mdbook_linkcheck::check_links(&render_ctx)\n }\n \n-#[cfg(not(feature = \"linkcheck\"))]\n-pub fn linkcheck(_args: &ArgMatches<'_>) -> Result<(), Error> {\n-    println!(\"mdbook-linkcheck is disabled.\");\n-    Ok(())\n-}\n-\n // Build command implementation\n pub fn build(args: &ArgMatches<'_>) -> Result3<()> {\n     let book_dir = get_book_dir(args);"}]}