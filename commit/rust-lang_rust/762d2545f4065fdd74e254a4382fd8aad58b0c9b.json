{"sha": "762d2545f4065fdd74e254a4382fd8aad58b0c9b", "node_id": "C_kwDOAAsO6NoAKDc2MmQyNTQ1ZjQwNjVmZGQ3NGUyNTRhNDM4MmZkOGFhZDU4YjBjOWI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-06T12:27:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-06T12:27:44Z"}, "message": "Rollup merge of #105339 - BoxyUwU:wf_ct_kind_expr, r=TaKO8Ki\n\nsupport `ConstKind::Expr` in `is_const_evaluatable` and `WfPredicates::compute`\n\nFixes #105205\n\nCurrently we haven't implemented a way to evaluate `ConstKind::Expr(Expr::Binop(Add, 1, 2))` so I just left that with a `FIXME` and a `delay_span_bug` since I have no idea how to do that and it would make this a much larger (and more complicated) PR :P", "tree": {"sha": "7815d6f93b8a81799380bd51ff3f52f114939a6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7815d6f93b8a81799380bd51ff3f52f114939a6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/762d2545f4065fdd74e254a4382fd8aad58b0c9b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjjzVACRBK7hj4Ov3rIwAAGVwIADIGSiznEiEgRCBCtFxLkJHT\n3WSuoqVDJL31cD0s4P0T+SjJ5tN6zqu6o8PRZlX93IOxtStABcmywh2TnQ6i/LhF\nbvd8dSpnaTbIJA8jECCnwwBcIkOSzLjSziEEAkLmMZ65ZdOAwVpWDCta+rlF4WYC\nzbPuNPujSRbfu0BW4tq1tppKTVdQaqlq94NiX0Hcno1zLnUdgiBT3HU6v8ckp1dz\nr3IFm1kRIA5yiN3Q4O9B7oiwFFkTV9f4O5SnDAiFViZObVEEQz9FC1b8HSm8UwcT\nNadU7hY0Iq4omFUruAWKfw0J7khkIZQ1S4EBlrofwgnJRBoaZ6lTMohQdfUHkws=\n=rfjR\n-----END PGP SIGNATURE-----\n", "payload": "tree 7815d6f93b8a81799380bd51ff3f52f114939a6c\nparent e29a510ff0484d157e1aac200e1fde84e9b5b144\nparent c9bab74fb2cb494b99edba2f8b999dfe9281c548\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1670329664 +0100\ncommitter GitHub <noreply@github.com> 1670329664 +0100\n\nRollup merge of #105339 - BoxyUwU:wf_ct_kind_expr, r=TaKO8Ki\n\nsupport `ConstKind::Expr` in `is_const_evaluatable` and `WfPredicates::compute`\n\nFixes #105205\n\nCurrently we haven't implemented a way to evaluate `ConstKind::Expr(Expr::Binop(Add, 1, 2))` so I just left that with a `FIXME` and a `delay_span_bug` since I have no idea how to do that and it would make this a much larger (and more complicated) PR :P\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/762d2545f4065fdd74e254a4382fd8aad58b0c9b", "html_url": "https://github.com/rust-lang/rust/commit/762d2545f4065fdd74e254a4382fd8aad58b0c9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/762d2545f4065fdd74e254a4382fd8aad58b0c9b/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e29a510ff0484d157e1aac200e1fde84e9b5b144", "url": "https://api.github.com/repos/rust-lang/rust/commits/e29a510ff0484d157e1aac200e1fde84e9b5b144", "html_url": "https://github.com/rust-lang/rust/commit/e29a510ff0484d157e1aac200e1fde84e9b5b144"}, {"sha": "c9bab74fb2cb494b99edba2f8b999dfe9281c548", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9bab74fb2cb494b99edba2f8b999dfe9281c548", "html_url": "https://github.com/rust-lang/rust/commit/c9bab74fb2cb494b99edba2f8b999dfe9281c548"}], "stats": {"total": 119, "additions": 99, "deletions": 20}, "files": [{"sha": "d01c6bac2963be6e0329a384d4bfc4957689d2e7", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/762d2545f4065fdd74e254a4382fd8aad58b0c9b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762d2545f4065fdd74e254a4382fd8aad58b0c9b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=762d2545f4065fdd74e254a4382fd8aad58b0c9b", "patch": "@@ -25,15 +25,13 @@ use crate::traits::ObligationCtxt;\n #[instrument(skip(infcx), level = \"debug\")]\n pub fn is_const_evaluatable<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n-    ct: ty::Const<'tcx>,\n+    unexpanded_ct: ty::Const<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     span: Span,\n ) -> Result<(), NotConstEvaluatable> {\n     let tcx = infcx.tcx;\n-    let uv = match ct.kind() {\n-        ty::ConstKind::Unevaluated(uv) => uv,\n-        // FIXME(generic_const_exprs): this seems wrong but I couldn't find a way to get this to trigger\n-        ty::ConstKind::Expr(_) => bug!(\"unexpected expr in `is_const_evaluatable: {ct:?}\"),\n+    match unexpanded_ct.kind() {\n+        ty::ConstKind::Unevaluated(_) | ty::ConstKind::Expr(_) => (),\n         ty::ConstKind::Param(_)\n         | ty::ConstKind::Bound(_, _)\n         | ty::ConstKind::Placeholder(_)\n@@ -43,7 +41,7 @@ pub fn is_const_evaluatable<'tcx>(\n     };\n \n     if tcx.features().generic_const_exprs {\n-        let ct = tcx.expand_abstract_consts(ct);\n+        let ct = tcx.expand_abstract_consts(unexpanded_ct);\n \n         let is_anon_ct = if let ty::ConstKind::Unevaluated(uv) = ct.kind() {\n             tcx.def_kind(uv.def.did) == DefKind::AnonConst\n@@ -62,18 +60,40 @@ pub fn is_const_evaluatable<'tcx>(\n             }\n         }\n \n-        let concrete = infcx.const_eval_resolve(param_env, uv, Some(span));\n-        match concrete {\n-            Err(ErrorHandled::TooGeneric) => Err(NotConstEvaluatable::Error(\n-                infcx\n-                    .tcx\n-                    .sess\n-                    .delay_span_bug(span, \"Missing value for constant, but no error reported?\"),\n-            )),\n-            Err(ErrorHandled::Reported(e)) => Err(NotConstEvaluatable::Error(e)),\n-            Ok(_) => Ok(()),\n+        match unexpanded_ct.kind() {\n+            ty::ConstKind::Expr(_) => {\n+                // FIXME(generic_const_exprs): we have a `ConstKind::Expr` which is fully concrete, but\n+                // currently it is not possible to evaluate `ConstKind::Expr` so we are unable to tell if it\n+                // is evaluatable or not. For now we just ICE until this is implemented this.\n+                Err(NotConstEvaluatable::Error(tcx.sess.delay_span_bug(\n+                    span,\n+                    \"evaluating `ConstKind::Expr` is not currently supported\",\n+                )))\n+            }\n+            ty::ConstKind::Unevaluated(uv) => {\n+                let concrete = infcx.const_eval_resolve(param_env, uv, Some(span));\n+                match concrete {\n+                    Err(ErrorHandled::TooGeneric) => {\n+                        Err(NotConstEvaluatable::Error(infcx.tcx.sess.delay_span_bug(\n+                            span,\n+                            \"Missing value for constant, but no error reported?\",\n+                        )))\n+                    }\n+                    Err(ErrorHandled::Reported(e)) => Err(NotConstEvaluatable::Error(e)),\n+                    Ok(_) => Ok(()),\n+                }\n+            }\n+            _ => bug!(\"unexpected constkind in `is_const_evalautable: {unexpanded_ct:?}`\"),\n         }\n     } else {\n+        let uv = match unexpanded_ct.kind() {\n+            ty::ConstKind::Unevaluated(uv) => uv,\n+            ty::ConstKind::Expr(_) => {\n+                bug!(\"`ConstKind::Expr` without `feature(generic_const_exprs)` enabled\")\n+            }\n+            _ => bug!(\"unexpected constkind in `is_const_evalautable: {unexpanded_ct:?}`\"),\n+        };\n+\n         // FIXME: We should only try to evaluate a given constant here if it is fully concrete\n         // as we don't want to allow things like `[u8; std::mem::size_of::<*mut T>()]`.\n         //\n@@ -92,7 +112,7 @@ pub fn is_const_evaluatable<'tcx>(\n                     && satisfied_from_param_env(\n                         tcx,\n                         infcx,\n-                        tcx.expand_abstract_consts(ct),\n+                        tcx.expand_abstract_consts(unexpanded_ct),\n                         param_env,\n                     ) =>\n             {\n@@ -152,6 +172,7 @@ fn satisfied_from_param_env<'tcx>(\n     impl<'a, 'tcx> TypeVisitor<'tcx> for Visitor<'a, 'tcx> {\n         type BreakTy = ();\n         fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            debug!(\"is_const_evaluatable: candidate={:?}\", c);\n             if let Ok(()) = self.infcx.commit_if_ok(|_| {\n                 let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n                 if let Ok(()) = ocx.eq(&ObligationCause::dummy(), self.param_env, c.ty(), self.ct.ty())\n@@ -187,13 +208,14 @@ fn satisfied_from_param_env<'tcx>(\n                 let result = b_ct.visit_with(&mut v);\n \n                 if let ControlFlow::Break(()) = result {\n-                    debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n+                    debug!(\"is_const_evaluatable: yes\");\n                     return true;\n                 }\n             }\n             _ => {} // don't care\n         }\n     }\n \n+    debug!(\"is_const_evaluatable: no\");\n     false\n }"}, {"sha": "e47ba64245f50732f0b95a7eddf143b5341bc555", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/762d2545f4065fdd74e254a4382fd8aad58b0c9b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762d2545f4065fdd74e254a4382fd8aad58b0c9b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=762d2545f4065fdd74e254a4382fd8aad58b0c9b", "patch": "@@ -476,9 +476,24 @@ impl<'tcx> WfPredicates<'tcx> {\n                                 ty::Binder::dummy(ty::PredicateKind::WellFormed(ct.into())),\n                             ));\n                         }\n-                        // FIXME(generic_const_exprs): This seems wrong but I could not find a way to get this to trigger\n                         ty::ConstKind::Expr(_) => {\n-                            bug!(\"checking wfness of `ConstKind::Expr` is unsupported\")\n+                            // FIXME(generic_const_exprs): this doesnt verify that given `Expr(N + 1)` the\n+                            // trait bound `typeof(N): Add<typeof(1)>` holds. This is currently unnecessary\n+                            // as `ConstKind::Expr` is only produced via normalization of `ConstKind::Unevaluated`\n+                            // which means that the `DefId` would have been typeck'd elsewhere. However in\n+                            // the future we may allow directly lowering to `ConstKind::Expr` in which case\n+                            // we would not be proving bounds we should.\n+\n+                            let predicate =\n+                                ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(ct));\n+                            let cause = self.cause(traits::WellFormed(None));\n+                            self.out.push(traits::Obligation::with_depth(\n+                                self.tcx(),\n+                                cause,\n+                                self.recursion_depth,\n+                                self.param_env,\n+                                predicate,\n+                            ));\n                         }\n \n                         ty::ConstKind::Error(_)"}, {"sha": "6093fc70b16965c6153db11740f9e3a0efd02386", "filename": "src/test/ui/const-generics/generic_const_exprs/const_kind_expr/wf_obligation.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/762d2545f4065fdd74e254a4382fd8aad58b0c9b/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762d2545f4065fdd74e254a4382fd8aad58b0c9b/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.rs?ref=762d2545f4065fdd74e254a4382fd8aad58b0c9b", "patch": "@@ -0,0 +1,22 @@\n+#![feature(generic_const_exprs, generic_arg_infer)]\n+#![allow(incomplete_features)]\n+\n+// minimized repro for #105205\n+//\n+// the `foo::<_, L>` call results in a `WellFormed(_)` obligation and a\n+// `ConstEvaluatable(Unevaluated(_ + 1 + L))` obligation. Attempting to fulfill the latter\n+// unifies the `_` with `Expr(L - 1)` from the paramenv which turns the `WellFormed`\n+// obligation into `WellFormed(Expr(L - 1))`\n+\n+fn foo<const N: usize, const M: usize>(_: [(); N + 1 + M]) {}\n+\n+fn ice<const L: usize>()\n+where\n+    [(); (L - 1) + 1 + L]:,\n+{\n+    foo::<_, L>([(); L + 1 + L]);\n+    //~^ ERROR: mismatched types\n+    //~^^ ERROR: unconstrained generic constant\n+}\n+\n+fn main() {}"}, {"sha": "da5194696e657bb032741d6d31fd29cf02847321", "filename": "src/test/ui/const-generics/generic_const_exprs/const_kind_expr/wf_obligation.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/762d2545f4065fdd74e254a4382fd8aad58b0c9b/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/762d2545f4065fdd74e254a4382fd8aad58b0c9b/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.stderr?ref=762d2545f4065fdd74e254a4382fd8aad58b0c9b", "patch": "@@ -0,0 +1,20 @@\n+error[E0308]: mismatched types\n+  --> $DIR/wf_obligation.rs:17:17\n+   |\n+LL |     foo::<_, L>([(); L + 1 + L]);\n+   |                 ^^^^^^^^^^^^^^^ expected `N + 1 + M`, found `L + 1 + L`\n+   |\n+   = note: expected constant `N + 1 + M`\n+              found constant `L + 1 + L`\n+\n+error: unconstrained generic constant\n+  --> $DIR/wf_obligation.rs:17:22\n+   |\n+LL |     foo::<_, L>([(); L + 1 + L]);\n+   |                      ^^^^^^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); L + 1 + L]:`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}