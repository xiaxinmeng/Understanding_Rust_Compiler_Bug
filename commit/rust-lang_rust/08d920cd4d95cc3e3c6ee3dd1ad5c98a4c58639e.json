{"sha": "08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZDkyMGNkNGQ5NWNjM2UzYzZlZTNkZDFhZDVjOThhNGM1ODYzOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-17T04:36:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-17T04:36:02Z"}, "message": "Auto merge of #42650 - nrc:save-slim, r=eddyb\n\nsave-analysis: remove a lot of stuff\n\nThis commits us to the JSON format and the more general def/ref style of output, rather than also supporting different data formats for different data structures. This does not affect the RLS at all, but will break any clients of the CSV form - AFAIK there are none (beyond a few of my own toy projects) - DXR stopped working long ago.\n\nr? @eddyb", "tree": {"sha": "d5d681951bd035ed2c0d3deb4f486e62a013d6c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5d681951bd035ed2c0d3deb4f486e62a013d6c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e", "html_url": "https://github.com/rust-lang/rust/commit/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3438c0fa8c45255ac7b8813c1253d1b59febb081", "url": "https://api.github.com/repos/rust-lang/rust/commits/3438c0fa8c45255ac7b8813c1253d1b59febb081", "html_url": "https://github.com/rust-lang/rust/commit/3438c0fa8c45255ac7b8813c1253d1b59febb081"}, {"sha": "8a2857e6449c1b90355223367fb4884adb0ba860", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a2857e6449c1b90355223367fb4884adb0ba860", "html_url": "https://github.com/rust-lang/rust/commit/8a2857e6449c1b90355223367fb4884adb0ba860"}], "stats": {"total": 4124, "additions": 844, "deletions": 3280}, "files": [{"sha": "4d6579cb204b4af97243165611bdab1f3bb54779", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e", "patch": "@@ -935,8 +935,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     save_analysis: bool = (false, parse_bool, [UNTRACKED],\n         \"write syntax and type analysis (in JSON format) information, in \\\n          addition to normal output\"),\n-    save_analysis_csv: bool = (false, parse_bool, [UNTRACKED],\n-        \"write syntax and type analysis (in CSV format) information, in addition to normal output\"),\n     save_analysis_api: bool = (false, parse_bool, [UNTRACKED],\n         \"write syntax and type analysis information for opaque libraries (in JSON format), \\\n          in addition to normal output\"),\n@@ -2471,8 +2469,6 @@ mod tests {\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.save_analysis = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.save_analysis_csv = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.save_analysis_api = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.print_move_fragments = true;"}, {"sha": "6839274800ce30d377f589a40516fa38918af22d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e", "patch": "@@ -534,15 +534,12 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n \n fn save_analysis(sess: &Session) -> bool {\n     sess.opts.debugging_opts.save_analysis ||\n-    sess.opts.debugging_opts.save_analysis_csv ||\n     sess.opts.debugging_opts.save_analysis_api\n }\n \n fn save_analysis_format(sess: &Session) -> save::Format {\n     if sess.opts.debugging_opts.save_analysis {\n         save::Format::Json\n-    } else if sess.opts.debugging_opts.save_analysis_csv {\n-        save::Format::Csv\n     } else if sess.opts.debugging_opts.save_analysis_api {\n         save::Format::JsonApi\n     } else {"}, {"sha": "4bab135ff12f70db54b2a65ef5007de61d07dcea", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "removed", "additions": 0, "deletions": 436, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -1,436 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::io::Write;\n-\n-use super::external_data::*;\n-use super::dump::Dump;\n-\n-use rls_data::{SpanData, CratePreludeData};\n-\n-pub struct CsvDumper<'b, W: 'b> {\n-    output: &'b mut W\n-}\n-\n-impl<'b, W: Write> CsvDumper<'b, W> {\n-    pub fn new(writer: &'b mut W) -> CsvDumper<'b, W> {\n-        CsvDumper { output: writer }\n-    }\n-\n-    fn record(&mut self, kind: &str, span: SpanData, values: String) {\n-        let span_str = span_extent_str(span);\n-        if let Err(_) = write!(self.output, \"{},{}{}\\n\", kind, span_str, values) {\n-            error!(\"Error writing output\");\n-        }\n-    }\n-\n-    fn record_raw(&mut self, info: &str) {\n-        if let Err(_) = write!(self.output, \"{}\", info) {\n-            error!(\"Error writing output '{}'\", info);\n-        }\n-    }\n-}\n-\n-impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n-    fn crate_prelude(&mut self, data: CratePreludeData) {\n-        let values = make_values_str(&[\n-            (\"name\", &data.crate_name),\n-            (\"crate_root\", &data.crate_root)\n-        ]);\n-\n-        self.record(\"crate\", data.span, values);\n-\n-        for c in data.external_crates {\n-            let num = c.num.to_string();\n-            let values = make_values_str(&[\n-                (\"name\", &c.name),\n-                (\"crate\", &num),\n-                (\"file_name\", &c.file_name)\n-            ]);\n-\n-            self.record_raw(&format!(\"external_crate{}\\n\", values));\n-        }\n-\n-        self.record_raw(\"end_external_crates\\n\");\n-    }\n-\n-    fn enum_data(&mut self, data: EnumData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope),\n-            (\"value\", &data.value)\n-        ]);\n-\n-        self.record(\"enum\", data.span, values);\n-    }\n-\n-    fn extern_crate(&mut self, data: ExternCrateData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let crate_num = data.crate_num.to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"name\", &data.name),\n-            (\"location\", &data.location),\n-            (\"crate\", &crate_num),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"extern_crate\", data.span, values);\n-    }\n-\n-    fn impl_data(&mut self, data: ImplData) {\n-        let self_ref = data.self_ref.unwrap_or(null_def_id());\n-        let trait_ref = data.trait_ref.unwrap_or(null_def_id());\n-\n-        let id = data.id.index.as_u32().to_string();\n-        let ref_id = self_ref.index.as_usize().to_string();\n-        let ref_id_crate = self_ref.krate.to_string();\n-        let trait_id = trait_ref.index.as_usize().to_string();\n-        let trait_id_crate = trait_ref.krate.to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_id_crate),\n-            (\"traitid\", &trait_id),\n-            (\"traitidcrate\", &trait_id_crate),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"impl\", data.span, values);\n-    }\n-\n-    fn inheritance(&mut self, data: InheritanceData) {\n-       let base_id = data.base_id.index.as_usize().to_string();\n-       let base_crate = data.base_id.krate.to_string();\n-       let deriv_id = data.deriv_id.index.as_u32().to_string();\n-       let deriv_crate = data.deriv_id.krate.to_string();\n-       let values = make_values_str(&[\n-           (\"base\", &base_id),\n-           (\"basecrate\", &base_crate),\n-           (\"derived\", &deriv_id),\n-           (\"derivedcrate\", &deriv_crate)\n-       ]);\n-\n-       self.record(\"inheritance\", data.span, values);\n-    }\n-\n-    fn function(&mut self, data: FunctionData) {\n-        let (decl_id, decl_crate) = match data.declaration {\n-            Some(id) => (id.index.as_usize().to_string(), id.krate.to_string()),\n-            None => (String::new(), String::new())\n-        };\n-\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"qualname\", &data.qualname),\n-            (\"declid\", &decl_id),\n-            (\"declidcrate\", &decl_crate),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"function\", data.span, values);\n-    }\n-\n-    fn function_ref(&mut self, data: FunctionRefData) {\n-        let ref_id = data.ref_id.index.as_usize().to_string();\n-        let ref_crate = data.ref_id.krate.to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n-            (\"qualname\", \"\"),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"fn_ref\", data.span, values);\n-    }\n-\n-    fn function_call(&mut self, data: FunctionCallData) {\n-        let ref_id = data.ref_id.index.as_usize().to_string();\n-        let ref_crate = data.ref_id.krate.to_string();\n-        let qualname = String::new();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n-            (\"qualname\", &qualname),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"fn_call\", data.span, values);\n-    }\n-\n-    fn method(&mut self, data: MethodData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"method_decl\", data.span, values);\n-    }\n-\n-    fn method_call(&mut self, data: MethodCallData) {\n-        let (dcn, dck) = match data.decl_id {\n-            Some(declid) => (declid.index.as_usize().to_string(), declid.krate.to_string()),\n-            None => (String::new(), String::new()),\n-        };\n-\n-        let ref_id = data.ref_id.unwrap_or(null_def_id());\n-\n-        let def_id = ref_id.index.as_usize().to_string();\n-        let def_crate = ref_id.krate.to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"refid\", &def_id),\n-            (\"refidcrate\", &def_crate),\n-            (\"declid\", &dcn),\n-            (\"declidcrate\", &dck),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"method_call\", data.span, values);\n-    }\n-\n-    fn macro_data(&mut self, data: MacroData) {\n-        let values = make_values_str(&[\n-            (\"name\", &data.name),\n-            (\"qualname\", &data.qualname)\n-        ]);\n-\n-        self.record(\"macro\", data.span, values);\n-    }\n-\n-    fn macro_use(&mut self, data: MacroUseData) {\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"callee_name\", &data.name),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"macro_use\", data.span, values);\n-    }\n-\n-    fn mod_data(&mut self, data: ModData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope),\n-            (\"def_file\", &data.filename)\n-        ]);\n-\n-        self.record(\"module\", data.span, values);\n-    }\n-\n-    fn mod_ref(&mut self, data: ModRefData) {\n-        let (ref_id, ref_crate) = match data.ref_id {\n-            Some(rid) => (rid.index.as_usize().to_string(), rid.krate.to_string()),\n-            None => (0.to_string(), 0.to_string())\n-        };\n-\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"mod_ref\", data.span, values);\n-    }\n-\n-    fn struct_data(&mut self, data: StructData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let ctor_id = data.ctor_id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"ctor_id\", &ctor_id),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope),\n-            (\"value\", &data.value)\n-        ]);\n-\n-        self.record(\"struct\", data.span, values);\n-    }\n-\n-    fn struct_variant(&mut self, data: StructVariantData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"ctor_id\", &id),\n-            (\"qualname\", &data.qualname),\n-            (\"type\", &data.type_value),\n-            (\"value\", &data.value),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"variant_struct\", data.span, values);\n-    }\n-\n-    fn trait_data(&mut self, data: TraitData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope),\n-            (\"value\", &data.value)\n-        ]);\n-\n-        self.record(\"trait\", data.span, values);\n-    }\n-\n-    fn tuple_variant(&mut self, data: TupleVariantData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"name\", &data.name),\n-            (\"qualname\", &data.qualname),\n-            (\"type\", &data.type_value),\n-            (\"value\", &data.value),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"variant\", data.span, values);\n-    }\n-\n-    fn type_ref(&mut self, data: TypeRefData) {\n-        let (ref_id, ref_crate) = match data.ref_id {\n-            Some(id) => (id.index.as_usize().to_string(), id.krate.to_string()),\n-            None => (0.to_string(), 0.to_string())\n-        };\n-\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"type_ref\", data.span, values);\n-    }\n-\n-    fn typedef(&mut self, data: TypeDefData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"qualname\", &data.qualname),\n-            (\"value\", &data.value)\n-        ]);\n-\n-        self.record(\"typedef\", data.span, values);\n-    }\n-\n-    fn use_data(&mut self, data: UseData) {\n-        let mod_id = data.mod_id.unwrap_or(null_def_id());\n-\n-        let id = data.id.index.as_u32().to_string();\n-        let ref_id = mod_id.index.as_usize().to_string();\n-        let ref_crate = mod_id.krate.to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n-            (\"name\", &data.name),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"use_alias\", data.span, values);\n-    }\n-\n-    fn use_glob(&mut self, data: UseGlobData) {\n-        let names = data.names.join(\", \");\n-\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"value\", &names),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"use_glob\", data.span, values);\n-    }\n-\n-    fn variable(&mut self, data: VariableData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"name\", &data.name),\n-            (\"qualname\", &data.qualname),\n-            (\"value\", &data.value),\n-            (\"type\", &data.type_value),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"variable\", data.span, values);\n-    }\n-\n-    fn variable_ref(&mut self, data: VariableRefData) {\n-        let ref_id = data.ref_id.index.as_usize().to_string();\n-        let ref_crate = data.ref_id.krate.to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n-            (\"qualname\", \"\"),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"var_ref\", data.span, values)\n-    }\n-}\n-\n-// Helper function to escape quotes in a string\n-fn escape(s: String) -> String {\n-    s.replace(\"\\\"\", \"\\\"\\\"\")\n-}\n-\n-fn make_values_str(pairs: &[(&'static str, &str)]) -> String {\n-    let pairs = pairs.into_iter().map(|&(f, v)| {\n-        // Never take more than 1020 chars\n-        if v.len() > 1020 {\n-            (f, &v[..1020])\n-        } else {\n-            (f, v)\n-        }\n-    });\n-\n-    let strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(String::from(v))));\n-    strs.fold(String::new(), |mut s, ss| {\n-        s.push_str(&ss);\n-        s\n-    })\n-}\n-\n-fn span_extent_str(span: SpanData) -> String {\n-    format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},byte_start,{},\\\n-             file_line_end,{},file_col_end,{},byte_end,{}\",\n-             span.file_name.to_str().unwrap(), span.line_start.0, span.column_start.0,\n-             span.byte_start, span.line_end.0, span.column_end.0, span.byte_end)\n-}"}, {"sha": "e15e3f6e79e26296a48b0bc798cfbfd30950f2a5", "filename": "src/librustc_save_analysis/data.rs", "status": "removed", "additions": 0, "deletions": 421, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -1,421 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Structs representing the analysis data from a crate.\n-//!\n-//! The `Dump` trait can be used together with `DumpVisitor` in order to\n-//! retrieve the data from a crate.\n-\n-use rustc::hir;\n-use rustc::hir::def_id::{CrateNum, DefId};\n-use syntax::ast::{self, Attribute, NodeId};\n-use syntax_pos::Span;\n-\n-use rls_data::{ExternalCrateData, Signature};\n-\n-pub struct CrateData {\n-    pub name: String,\n-    pub number: u32,\n-    pub span: Span,\n-}\n-\n-/// Data for any entity in the Rust language. The actual data contained varies\n-/// with the kind of entity being queried. See the nested structs for details.\n-#[derive(Debug)]\n-pub enum Data {\n-    /// Data for Enums.\n-    EnumData(EnumData),\n-    /// Data for extern crates.\n-    ExternCrateData(ExternCrateData),\n-    /// Data about a function call.\n-    FunctionCallData(FunctionCallData),\n-    /// Data for all kinds of functions and methods.\n-    FunctionData(FunctionData),\n-    /// Data about a function ref.\n-    FunctionRefData(FunctionRefData),\n-    /// Data for impls.\n-    ImplData(ImplData2),\n-    /// Data for trait inheritance.\n-    InheritanceData(InheritanceData),\n-    /// Data about a macro declaration.\n-    MacroData(MacroData),\n-    /// Data about a macro use.\n-    MacroUseData(MacroUseData),\n-    /// Data about a method call.\n-    MethodCallData(MethodCallData),\n-    /// Data for method declarations (methods with a body are treated as functions).\n-    MethodData(MethodData),\n-    /// Data for modules.\n-    ModData(ModData),\n-    /// Data for a reference to a module.\n-    ModRefData(ModRefData),\n-    /// Data for a struct declaration.\n-    StructData(StructData),\n-    /// Data for a struct variant.\n-    StructVariantDat(StructVariantData),\n-    /// Data for a trait declaration.\n-    TraitData(TraitData),\n-    /// Data for a tuple variant.\n-    TupleVariantData(TupleVariantData),\n-    /// Data for a typedef.\n-    TypeDefData(TypeDefData),\n-    /// Data for a reference to a type or trait.\n-    TypeRefData(TypeRefData),\n-    /// Data for a use statement.\n-    UseData(UseData),\n-    /// Data for a global use statement.\n-    UseGlobData(UseGlobData),\n-    /// Data for local and global variables (consts and statics), and fields.\n-    VariableData(VariableData),\n-    /// Data for the use of some variable (e.g., the use of a local variable, which\n-    /// will refere to that variables declaration).\n-    VariableRefData(VariableRefData),\n-}\n-\n-#[derive(Eq, PartialEq, Clone, Copy, Debug)]\n-pub enum Visibility {\n-    Public,\n-    Restricted,\n-    Inherited,\n-}\n-\n-impl<'a> From<&'a ast::Visibility> for Visibility {\n-    fn from(v: &'a ast::Visibility) -> Visibility {\n-        match *v {\n-            ast::Visibility::Public => Visibility::Public,\n-            ast::Visibility::Crate(_) => Visibility::Restricted,\n-            ast::Visibility::Restricted { .. } => Visibility::Restricted,\n-            ast::Visibility::Inherited => Visibility::Inherited,\n-        }\n-    }\n-}\n-\n-impl<'a> From<&'a hir::Visibility> for Visibility {\n-    fn from(v: &'a hir::Visibility) -> Visibility {\n-        match *v {\n-            hir::Visibility::Public => Visibility::Public,\n-            hir::Visibility::Crate => Visibility::Restricted,\n-            hir::Visibility::Restricted { .. } => Visibility::Restricted,\n-            hir::Visibility::Inherited => Visibility::Inherited,\n-        }\n-    }\n-}\n-\n-/// Data for the prelude of a crate.\n-#[derive(Debug)]\n-pub struct CratePreludeData {\n-    pub crate_name: String,\n-    pub crate_root: String,\n-    pub external_crates: Vec<ExternalCrateData>,\n-    pub span: Span,\n-}\n-\n-/// Data for enum declarations.\n-#[derive(Clone, Debug)]\n-pub struct EnumData {\n-    pub id: NodeId,\n-    pub name: String,\n-    pub value: String,\n-    pub qualname: String,\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub variants: Vec<NodeId>,\n-    pub visibility: Visibility,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-/// Data for extern crates.\n-#[derive(Debug)]\n-pub struct ExternCrateData {\n-    pub id: NodeId,\n-    pub name: String,\n-    pub crate_num: CrateNum,\n-    pub location: String,\n-    pub span: Span,\n-    pub scope: NodeId,\n-}\n-\n-/// Data about a function call.\n-#[derive(Debug)]\n-pub struct FunctionCallData {\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub ref_id: DefId,\n-}\n-\n-/// Data for all kinds of functions and methods.\n-#[derive(Clone, Debug)]\n-pub struct FunctionData {\n-    pub id: NodeId,\n-    pub name: String,\n-    pub qualname: String,\n-    pub declaration: Option<DefId>,\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub value: String,\n-    pub visibility: Visibility,\n-    pub parent: Option<DefId>,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-/// Data about a function call.\n-#[derive(Debug)]\n-pub struct FunctionRefData {\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub ref_id: DefId,\n-}\n-\n-#[derive(Debug)]\n-pub struct ImplData {\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub trait_ref: Option<DefId>,\n-    pub self_ref: Option<DefId>,\n-}\n-\n-#[derive(Debug)]\n-// FIXME: this struct should not exist. However, removing it requires heavy\n-// refactoring of dump_visitor.rs. See PR 31838 for more info.\n-pub struct ImplData2 {\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub scope: NodeId,\n-    // FIXME: I'm not really sure inline data is the best way to do this. Seems\n-    // OK in this case, but generalising leads to returning chunks of AST, which\n-    // feels wrong.\n-    pub trait_ref: Option<TypeRefData>,\n-    pub self_ref: Option<TypeRefData>,\n-}\n-\n-#[derive(Debug)]\n-pub struct InheritanceData {\n-    pub span: Span,\n-    pub base_id: DefId,\n-    pub deriv_id: NodeId\n-}\n-\n-/// Data about a macro declaration.\n-#[derive(Debug)]\n-pub struct MacroData {\n-    pub span: Span,\n-    pub name: String,\n-    pub qualname: String,\n-    pub docs: String,\n-}\n-\n-/// Data about a macro use.\n-#[derive(Debug)]\n-pub struct MacroUseData {\n-    pub span: Span,\n-    pub name: String,\n-    pub qualname: String,\n-    // Because macro expansion happens before ref-ids are determined,\n-    // we use the callee span to reference the associated macro definition.\n-    pub callee_span: Span,\n-    pub scope: NodeId,\n-    pub imported: bool,\n-}\n-\n-/// Data about a method call.\n-#[derive(Debug)]\n-pub struct MethodCallData {\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub ref_id: Option<DefId>,\n-    pub decl_id: Option<DefId>,\n-}\n-\n-/// Data for method declarations (methods with a body are treated as functions).\n-#[derive(Clone, Debug)]\n-pub struct MethodData {\n-    pub id: NodeId,\n-    pub name: String,\n-    pub qualname: String,\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub value: String,\n-    pub decl_id: Option<DefId>,\n-    pub parent: Option<DefId>,\n-    pub visibility: Visibility,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-/// Data for modules.\n-#[derive(Debug)]\n-pub struct ModData {\n-    pub id: NodeId,\n-    pub name: String,\n-    pub qualname: String,\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub filename: String,\n-    pub items: Vec<NodeId>,\n-    pub visibility: Visibility,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-/// Data for a reference to a module.\n-#[derive(Debug)]\n-pub struct ModRefData {\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub ref_id: Option<DefId>,\n-    pub qualname: String\n-}\n-\n-#[derive(Debug)]\n-pub struct StructData {\n-    pub span: Span,\n-    pub name: String,\n-    pub id: NodeId,\n-    pub ctor_id: NodeId,\n-    pub qualname: String,\n-    pub scope: NodeId,\n-    pub value: String,\n-    pub fields: Vec<NodeId>,\n-    pub visibility: Visibility,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-#[derive(Debug)]\n-pub struct StructVariantData {\n-    pub span: Span,\n-    pub name: String,\n-    pub id: NodeId,\n-    pub qualname: String,\n-    pub type_value: String,\n-    pub value: String,\n-    pub scope: NodeId,\n-    pub parent: Option<DefId>,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-#[derive(Debug)]\n-pub struct TraitData {\n-    pub span: Span,\n-    pub id: NodeId,\n-    pub name: String,\n-    pub qualname: String,\n-    pub scope: NodeId,\n-    pub value: String,\n-    pub items: Vec<NodeId>,\n-    pub visibility: Visibility,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-#[derive(Debug)]\n-pub struct TupleVariantData {\n-    pub span: Span,\n-    pub id: NodeId,\n-    pub name: String,\n-    pub qualname: String,\n-    pub type_value: String,\n-    pub value: String,\n-    pub scope: NodeId,\n-    pub parent: Option<DefId>,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-/// Data for a typedef.\n-#[derive(Debug)]\n-pub struct TypeDefData {\n-    pub id: NodeId,\n-    pub name: String,\n-    pub span: Span,\n-    pub qualname: String,\n-    pub value: String,\n-    pub visibility: Visibility,\n-    pub parent: Option<DefId>,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-/// Data for a reference to a type or trait.\n-#[derive(Clone, Debug)]\n-pub struct TypeRefData {\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub ref_id: Option<DefId>,\n-    pub qualname: String,\n-}\n-\n-#[derive(Debug)]\n-pub struct UseData {\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub name: String,\n-    pub mod_id: Option<DefId>,\n-    pub scope: NodeId,\n-    pub visibility: Visibility,\n-}\n-\n-#[derive(Debug)]\n-pub struct UseGlobData {\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub names: Vec<String>,\n-    pub scope: NodeId,\n-    pub visibility: Visibility,\n-}\n-\n-/// Data for local and global variables (consts and statics).\n-#[derive(Debug)]\n-pub struct VariableData {\n-    pub id: NodeId,\n-    pub kind: VariableKind,\n-    pub name: String,\n-    pub qualname: String,\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub parent: Option<DefId>,\n-    pub value: String,\n-    pub type_value: String,\n-    pub visibility: Visibility,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-#[derive(Debug)]\n-pub enum VariableKind {\n-    Static,\n-    Const,\n-    Local,\n-    Field,\n-}\n-\n-/// Data for the use of some item (e.g., the use of a local variable, which\n-/// will refer to that variables declaration (by ref_id)).\n-#[derive(Debug)]\n-pub struct VariableRefData {\n-    pub name: String,\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub ref_id: DefId,\n-}"}, {"sha": "795ff58e20607a1f663740afc31eaa86e717d315", "filename": "src/librustc_save_analysis/dump.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibrustc_save_analysis%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibrustc_save_analysis%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -1,40 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use super::external_data::*;\n-\n-use rls_data::CratePreludeData;\n-\n-pub trait Dump {\n-    fn crate_prelude(&mut self, _: CratePreludeData) {}\n-    fn enum_data(&mut self, _: EnumData) {}\n-    fn extern_crate(&mut self, _: ExternCrateData) {}\n-    fn impl_data(&mut self, _: ImplData) {}\n-    fn inheritance(&mut self, _: InheritanceData) {}\n-    fn function(&mut self, _: FunctionData) {}\n-    fn function_ref(&mut self, _: FunctionRefData) {}\n-    fn function_call(&mut self, _: FunctionCallData) {}\n-    fn method(&mut self, _: MethodData) {}\n-    fn method_call(&mut self, _: MethodCallData) {}\n-    fn macro_data(&mut self, _: MacroData) {}\n-    fn macro_use(&mut self, _: MacroUseData) {}\n-    fn mod_data(&mut self, _: ModData) {}\n-    fn mod_ref(&mut self, _: ModRefData) {}\n-    fn struct_data(&mut self, _: StructData) {}\n-    fn struct_variant(&mut self, _: StructVariantData) {}\n-    fn trait_data(&mut self, _: TraitData) {}\n-    fn tuple_variant(&mut self, _: TupleVariantData) {}\n-    fn type_ref(&mut self, _: TypeRefData) {}\n-    fn typedef(&mut self, _: TypeDefData) {}\n-    fn use_data(&mut self, _: UseData) {}\n-    fn use_glob(&mut self, _: UseGlobData) {}\n-    fn variable(&mut self, _: VariableData) {}\n-    fn variable_ref(&mut self, _: VariableRefData) {}\n-}"}, {"sha": "cc33d3db8eba70a92abe31895ac4ddb1aced0c67", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 440, "deletions": 558, "changes": 998, "blob_url": "https://github.com/rust-lang/rust/blob/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e", "patch": "@@ -8,10 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Write the output of rustc's analysis to an implementor of Dump. The data is\n-//! primarily designed to be used as input to the DXR tool, specifically its\n-//! Rust plugin. It could also be used by IDEs or other code browsing, search, or\n-//! cross-referencing tools.\n+//! Write the output of rustc's analysis to an implementor of Dump.\n //!\n //! Dumping the analysis is implemented by walking the AST and getting a bunch of\n //! info out from all over the place. We use Def IDs to identify objects. The\n@@ -27,16 +24,12 @@\n //! is used for recording the output in a format-agnostic way (see CsvDumper\n //! for an example).\n \n-use rustc::hir;\n-use rustc::hir::def::Def;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::hir::map::{Node, NodeItem};\n+use rustc::hir::def::Def as HirDef;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::map::Node;\n use rustc::session::Session;\n-use rustc::ty::{self, TyCtxt, AssociatedItemContainer};\n+use rustc::ty::{self, TyCtxt};\n \n-use std::collections::HashSet;\n-use std::collections::hash_map::DefaultHasher;\n-use std::hash::*;\n use std::path::Path;\n \n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n@@ -48,15 +41,12 @@ use syntax::ptr::P;\n use syntax::codemap::Spanned;\n use syntax_pos::*;\n \n-use {escape, generated_code, SaveContext, PathCollector, docs_for_attrs};\n-use data::*;\n-use dump::Dump;\n-use external_data::{Lower, make_def_id};\n-use recorder;\n+use {escape, generated_code, SaveContext, PathCollector, docs_for_attrs, lower_attributes, Dump};\n use span_utils::SpanUtils;\n use sig;\n \n-use rls_data::ExternalCrateData;\n+use rls_data::{CratePreludeData, Import, ImportKind, SpanData, Ref, RefKind,\n+               Def, DefKind, Relation, RelationKind};\n \n macro_rules! down_cast_data {\n     ($id:ident, $kind:ident, $sp:expr) => {\n@@ -82,8 +72,7 @@ pub struct DumpVisitor<'l, 'tcx: 'l, 'll, D: 'll> {\n     // of macro use (callsite) spans. We store these to ensure\n     // we only write one macro def per unique macro definition, and\n     // one macro use per unique callsite span.\n-    mac_defs: HashSet<Span>,\n-    mac_uses: HashSet<Span>,\n+    // mac_defs: HashSet<Span>,\n }\n \n impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n@@ -98,8 +87,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             dumper: dumper,\n             span: span_utils.clone(),\n             cur_scope: CRATE_NODE_ID,\n-            mac_defs: HashSet::new(),\n-            mac_uses: HashSet::new(),\n+            // mac_defs: HashSet::new(),\n         }\n     }\n \n@@ -127,6 +115,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n     }\n \n+    fn span_from_span(&self, span: Span) -> SpanData {\n+        self.save_ctxt.span_from_span(span)\n+    }\n+\n     pub fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n         let source_file = self.tcx.sess.local_crate_source_file.as_ref();\n         let crate_root = source_file.map(|source_file| {\n@@ -137,25 +129,14 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             }\n         });\n \n-        // Info about all the external crates referenced from this crate.\n-        let external_crates = self.save_ctxt.get_external_crates().into_iter().map(|c| {\n-            let lo_loc = self.span.sess.codemap().lookup_char_pos(c.span.lo);\n-            ExternalCrateData {\n-                name: c.name,\n-                num: c.number,\n-                file_name: SpanUtils::make_path_string(&lo_loc.file.name),\n-            }\n-        }).collect();\n-\n-        // The current crate.\n         let data = CratePreludeData {\n             crate_name: name.into(),\n             crate_root: crate_root.unwrap_or(\"<no source>\".to_owned()),\n-            external_crates: external_crates,\n-            span: krate.span,\n+            external_crates: self.save_ctxt.get_external_crates(),\n+            span: self.span_from_span(krate.span),\n         };\n \n-        self.dumper.crate_prelude(data.lower(self.tcx));\n+        self.dumper.crate_prelude(data);\n     }\n \n     // Return all non-empty prefixes of a path.\n@@ -211,13 +192,13 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n     fn write_sub_paths(&mut self, path: &ast::Path) {\n         let sub_paths = self.process_path_prefixes(path);\n-        for (span, qualname) in sub_paths {\n-            self.dumper.mod_ref(ModRefData {\n-                span: span,\n-                qualname: qualname,\n-                scope: self.cur_scope,\n-                ref_id: None\n-            }.lower(self.tcx));\n+        for (span, _) in sub_paths {\n+            let span = self.span_from_span(span);\n+            self.dumper.dump_ref(Ref {\n+                kind: RefKind::Mod,\n+                span,\n+                ref_id: ::null_id(),\n+            });\n         }\n     }\n \n@@ -230,13 +211,13 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             return;\n         }\n \n-        for (span, qualname) in sub_paths.into_iter().take(len - 1) {\n-            self.dumper.mod_ref(ModRefData {\n-                span: span,\n-                qualname: qualname,\n-                scope: self.cur_scope,\n-                ref_id: None\n-            }.lower(self.tcx));\n+        for (span, _) in sub_paths.into_iter().take(len - 1) {\n+            let span = self.span_from_span(span);\n+            self.dumper.dump_ref(Ref {\n+                kind: RefKind::Mod,\n+                span,\n+                ref_id: ::null_id(),\n+            });\n         }\n     }\n \n@@ -251,32 +232,32 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let sub_paths = &sub_paths[.. (len-1)];\n \n         // write the trait part of the sub-path\n-        let (ref span, ref qualname) = sub_paths[len-2];\n-        self.dumper.type_ref(TypeRefData {\n-            ref_id: None,\n-            span: *span,\n-            qualname: qualname.to_owned(),\n-            scope: CRATE_NODE_ID\n-        }.lower(self.tcx));\n+        let (ref span, _) = sub_paths[len-2];\n+        let span = self.span_from_span(*span);\n+        self.dumper.dump_ref(Ref {\n+            kind: RefKind::Type,\n+            ref_id: ::null_id(),\n+            span,\n+        });\n \n         // write the other sub-paths\n         if len <= 2 {\n             return;\n         }\n         let sub_paths = &sub_paths[..len-2];\n-        for &(ref span, ref qualname) in sub_paths {\n-            self.dumper.mod_ref(ModRefData {\n-                span: *span,\n-                qualname: qualname.to_owned(),\n-                scope: self.cur_scope,\n-                ref_id: None\n-            }.lower(self.tcx));\n+        for &(ref span, _) in sub_paths {\n+            let span = self.span_from_span(*span);\n+            self.dumper.dump_ref(Ref {\n+                kind: RefKind::Mod,\n+                span,\n+                ref_id: ::null_id(),\n+            });\n         }\n     }\n \n     fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n         match self.save_ctxt.get_path_def(ref_id) {\n-            Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => None,\n+            HirDef::PrimTy(..) | HirDef::SelfTy(..) | HirDef::Err => None,\n             def => Some(def.def_id()),\n         }\n     }\n@@ -285,67 +266,67 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         ref_id: NodeId,\n                         span: Span,\n                         sub_span: Option<Span>,\n-                        def_id: DefId,\n-                        scope: NodeId) {\n+                        def_id: DefId) {\n         if self.span.filter_generated(sub_span, span) {\n             return;\n         }\n \n         let def = self.save_ctxt.get_path_def(ref_id);\n         match def {\n-            Def::Mod(_) => {\n-                self.dumper.mod_ref(ModRefData {\n-                    span: sub_span.expect(\"No span found for mod ref\"),\n-                    ref_id: Some(def_id),\n-                    scope: scope,\n-                    qualname: String::new()\n-                }.lower(self.tcx));\n+            HirDef::Mod(_) => {\n+                let span = self.span_from_span(sub_span.expect(\"No span found for mod ref\"));\n+                self.dumper.dump_ref(Ref {\n+                    kind: RefKind::Mod,\n+                    span,\n+                    ref_id: ::id_from_def_id(def_id),\n+                });\n             }\n-            Def::Struct(..) |\n-            Def::Variant(..) |\n-            Def::Union(..) |\n-            Def::Enum(..) |\n-            Def::TyAlias(..) |\n-            Def::Trait(_) => {\n-                self.dumper.type_ref(TypeRefData {\n-                    span: sub_span.expect(\"No span found for type ref\"),\n-                    ref_id: Some(def_id),\n-                    scope: scope,\n-                    qualname: String::new()\n-                }.lower(self.tcx));\n+            HirDef::Struct(..) |\n+            HirDef::Variant(..) |\n+            HirDef::Union(..) |\n+            HirDef::Enum(..) |\n+            HirDef::TyAlias(..) |\n+            HirDef::Trait(_) => {\n+                let span = self.span_from_span(sub_span.expect(\"No span found for type ref\"));\n+                self.dumper.dump_ref(Ref {\n+                    kind: RefKind::Type,\n+                    span,\n+                    ref_id: ::id_from_def_id(def_id),\n+                });\n             }\n-            Def::Static(..) |\n-            Def::Const(..) |\n-            Def::StructCtor(..) |\n-            Def::VariantCtor(..) => {\n-                self.dumper.variable_ref(VariableRefData {\n-                    span: sub_span.expect(\"No span found for var ref\"),\n-                    ref_id: def_id,\n-                    scope: scope,\n-                    name: String::new()\n-                }.lower(self.tcx));\n+            HirDef::Static(..) |\n+            HirDef::Const(..) |\n+            HirDef::StructCtor(..) |\n+            HirDef::VariantCtor(..) => {\n+                let span = self.span_from_span(sub_span.expect(\"No span found for var ref\"));\n+                self.dumper.dump_ref(Ref {\n+                    kind: RefKind::Variable,\n+                    span,\n+                    ref_id: ::id_from_def_id(def_id),\n+                });\n             }\n-            Def::Fn(..) => {\n-                self.dumper.function_ref(FunctionRefData {\n-                    span: sub_span.expect(\"No span found for fn ref\"),\n-                    ref_id: def_id,\n-                    scope: scope\n-                }.lower(self.tcx));\n+            HirDef::Fn(..) => {\n+                let span = self.span_from_span(sub_span.expect(\"No span found for fn ref\"));\n+                self.dumper.dump_ref(Ref {\n+                    kind: RefKind::Function,\n+                    span,\n+                    ref_id: ::id_from_def_id(def_id),\n+                });\n             }\n             // With macros 2.0, we can legitimately get a ref to a macro, but\n             // we don't handle it properly for now (FIXME).\n-            Def::Macro(..) => {}\n-            Def::Local(..) |\n-            Def::Upvar(..) |\n-            Def::SelfTy(..) |\n-            Def::Label(_) |\n-            Def::TyParam(..) |\n-            Def::Method(..) |\n-            Def::AssociatedTy(..) |\n-            Def::AssociatedConst(..) |\n-            Def::PrimTy(_) |\n-            Def::GlobalAsm(_) |\n-            Def::Err => {\n+            HirDef::Macro(..) => {}\n+            HirDef::Local(..) |\n+            HirDef::Upvar(..) |\n+            HirDef::SelfTy(..) |\n+            HirDef::Label(_) |\n+            HirDef::TyParam(..) |\n+            HirDef::Method(..) |\n+            HirDef::AssociatedTy(..) |\n+            HirDef::AssociatedConst(..) |\n+            HirDef::PrimTy(_) |\n+            HirDef::GlobalAsm(_) |\n+            HirDef::Err => {\n                span_bug!(span,\n                          \"process_def_kind for unexpected item: {:?}\",\n                          def);\n@@ -368,21 +349,23 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 // variable name, but who knows?)\n                 let sub_span = span_utils.span_for_last_ident(p.span);\n                 if !self.span.filter_generated(sub_span, p.span) {\n-                    self.dumper.variable(VariableData {\n-                        id: id,\n-                        kind: VariableKind::Local,\n-                        span: sub_span.expect(\"No span found for variable\"),\n+                    let id = ::id_from_node_id(id, &self.save_ctxt);\n+                    let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n+\n+                    self.dumper.dump_def(false, Def {\n+                        kind: DefKind::Local,\n+                        id,\n+                        span,\n                         name: path_to_string(p),\n                         qualname: format!(\"{}::{}\", qualname, path_to_string(p)),\n-                        type_value: typ,\n-                        value: String::new(),\n-                        scope: CRATE_NODE_ID,\n+                        value: typ,\n                         parent: None,\n-                        visibility: Visibility::Inherited,\n+                        children: vec![],\n+                        decl_id: None,\n                         docs: String::new(),\n                         sig: None,\n-                        attributes: vec![],\n-                    }.lower(self.tcx));\n+                        attributes:vec![],\n+                    });\n                 }\n             }\n         }\n@@ -393,12 +376,11 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                       body: Option<&'l ast::Block>,\n                       id: ast::NodeId,\n                       name: ast::Ident,\n-                      vis: Visibility,\n-                      attrs: &'l [Attribute],\n+                      vis: ast::Visibility,\n                       span: Span) {\n         debug!(\"process_method: {}:{}\", id, name);\n \n-        if let Some(method_data) = self.save_ctxt.get_method_data(id, name.name, span) {\n+        if let Some(mut method_data) = self.save_ctxt.get_method_data(id, name.name, span) {\n \n             let sig_str = ::make_signature(&sig.decl, &sig.generics);\n             if body.is_some() {\n@@ -407,61 +389,11 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 });\n             }\n \n-            // If the method is defined in an impl, then try and find the corresponding\n-            // method decl in a trait, and if there is one, make a decl_id for it. This\n-            // requires looking up the impl, then the trait, then searching for a method\n-            // with the right name.\n-            if !self.span.filter_generated(Some(method_data.span), span) {\n-                let container =\n-                    self.tcx.associated_item(self.tcx.hir.local_def_id(id)).container;\n-                let mut trait_id;\n-                let mut decl_id = None;\n-                match container {\n-                    AssociatedItemContainer::ImplContainer(id) => {\n-                        trait_id = self.tcx.trait_id_of_impl(id);\n-\n-                        match trait_id {\n-                            Some(id) => {\n-                                for item in self.tcx.associated_items(id) {\n-                                    if item.kind == ty::AssociatedKind::Method {\n-                                        if item.name == name.name {\n-                                            decl_id = Some(item.def_id);\n-                                            break;\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                            None => {\n-                                if let Some(NodeItem(item)) = self.tcx.hir.get_if_local(id) {\n-                                    if let hir::ItemImpl(_, _, _, _, _, ref ty, _) = item.node {\n-                                        trait_id = self.lookup_def_id(ty.id);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                    AssociatedItemContainer::TraitContainer(id) => {\n-                        trait_id = Some(id);\n-                    }\n-                }\n-\n-                self.dumper.method(MethodData {\n-                    id: method_data.id,\n-                    name: method_data.name,\n-                    span: method_data.span,\n-                    scope: method_data.scope,\n-                    qualname: method_data.qualname.clone(),\n-                    value: sig_str,\n-                    decl_id: decl_id,\n-                    parent: trait_id,\n-                    visibility: vis,\n-                    docs: docs_for_attrs(attrs),\n-                    sig: sig::method_signature(id, name, sig, &self.save_ctxt),\n-                    attributes: attrs.to_vec(),\n-                }.lower(self.tcx));\n-            }\n-\n             self.process_generic_params(&sig.generics, span, &method_data.qualname, id);\n+\n+            method_data.value = sig_str;\n+            method_data.sig = sig::method_signature(id, name, sig, &self.save_ctxt);\n+            self.dumper.dump_def(vis == ast::Visibility::Public, method_data);\n         }\n \n         // walk arg and return types\n@@ -480,22 +412,17 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     }\n \n     fn process_trait_ref(&mut self, trait_ref: &'l ast::TraitRef) {\n-        let trait_ref_data = self.save_ctxt.get_trait_ref_data(trait_ref, self.cur_scope);\n+        let trait_ref_data = self.save_ctxt.get_trait_ref_data(trait_ref);\n         if let Some(trait_ref_data) = trait_ref_data {\n-            if !self.span.filter_generated(Some(trait_ref_data.span), trait_ref.path.span) {\n-                self.dumper.type_ref(trait_ref_data.lower(self.tcx));\n-            }\n+            self.dumper.dump_ref(trait_ref_data);\n         }\n-        self.process_path(trait_ref.ref_id, &trait_ref.path, Some(recorder::TypeRef));\n+        self.process_path(trait_ref.ref_id, &trait_ref.path);\n     }\n \n     fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n-        if let Some(mut field_data) = field_data {\n-            if !self.span.filter_generated(Some(field_data.span), field.span) {\n-                field_data.value = String::new();\n-                self.dumper.variable(field_data.lower(self.tcx));\n-            }\n+        if let Some(field_data) = field_data {\n+            self.dumper.dump_def(field.vis == ast::Visibility::Public, field_data);\n         }\n     }\n \n@@ -519,18 +446,23 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                    name,\n                                    id);\n             if !self.span.filter_generated(Some(param_ss), full_span) {\n-                self.dumper.typedef(TypeDefData {\n-                    span: param_ss,\n-                    name: name,\n-                    id: param.id,\n-                    qualname: qualname,\n+                let id = ::id_from_node_id(param.id, &self.save_ctxt);\n+                let span = self.span_from_span(param_ss);\n+\n+                self.dumper.dump_def(false, Def {\n+                    kind: DefKind::Type,\n+                    id,\n+                    span,\n+                    name,\n+                    qualname,\n                     value: String::new(),\n-                    visibility: Visibility::Inherited,\n                     parent: None,\n+                    children: vec![],\n+                    decl_id: None,\n                     docs: String::new(),\n                     sig: None,\n                     attributes: vec![],\n-                }.lower(self.tcx));\n+                });\n             }\n         }\n         self.visit_generics(generics);\n@@ -542,13 +474,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                   ty_params: &'l ast::Generics,\n                   body: &'l ast::Block) {\n         if let Some(fn_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(fn_data, FunctionData, item.span);\n-            if !self.span.filter_generated(Some(fn_data.span), item.span) {\n-                self.dumper.function(fn_data.clone().lower(self.tcx));\n-            }\n-\n+            down_cast_data!(fn_data, DefData, item.span);\n             self.nest_tables(item.id, |v| v.process_formals(&decl.inputs, &fn_data.qualname));\n             self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n+            self.dumper.dump_def(item.vis == ast::Visibility::Public, fn_data);\n         }\n \n         for arg in &decl.inputs {\n@@ -567,10 +496,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                     typ: &'l ast::Ty,\n                                     expr: &'l ast::Expr) {\n         if let Some(var_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(var_data, VariableData, item.span);\n-            if !self.span.filter_generated(Some(var_data.span), item.span) {\n-                self.dumper.variable(var_data.lower(self.tcx));\n-            }\n+            down_cast_data!(var_data, DefData, item.span);\n+            self.dumper.dump_def(item.vis == ast::Visibility::Public, var_data);\n         }\n         self.visit_ty(&typ);\n         self.visit_expr(expr);\n@@ -583,29 +510,31 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                            typ: &'l ast::Ty,\n                            expr: Option<&'l ast::Expr>,\n                            parent_id: DefId,\n-                           vis: Visibility,\n+                           vis: ast::Visibility,\n                            attrs: &'l [Attribute]) {\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n \n         let sub_span = self.span.sub_span_after_keyword(span, keywords::Const);\n-        let value = expr.map(|e| self.span.snippet(e.span)).unwrap_or(String::new());\n \n         if !self.span.filter_generated(sub_span, span) {\n-            self.dumper.variable(VariableData {\n-                span: sub_span.expect(\"No span found for variable\"),\n-                kind: VariableKind::Const,\n-                id: id,\n+            let sig = sig::assoc_const_signature(id, name, typ, expr, &self.save_ctxt);\n+            let id = ::id_from_node_id(id, &self.save_ctxt);\n+            let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n+\n+            self.dumper.dump_def(vis == ast::Visibility::Public, Def {\n+                kind: DefKind::Const,\n+                id,\n+                span,\n                 name: name.to_string(),\n-                qualname: qualname,\n-                value: value,\n-                type_value: ty_to_string(&typ),\n-                scope: self.cur_scope,\n-                parent: Some(parent_id),\n-                visibility: vis,\n+                qualname,\n+                value: ty_to_string(&typ),\n+                parent: Some(::id_from_def_id(parent_id)),\n+                children: vec![],\n+                decl_id: None,\n                 docs: docs_for_attrs(attrs),\n-                sig: sig::assoc_const_signature(id, name, typ, expr, &self.save_ctxt),\n-                attributes: attrs.to_vec(),\n-            }.lower(self.tcx));\n+                sig,\n+                attributes: lower_attributes(attrs.to_owned(), &self.save_ctxt),\n+            });\n         }\n \n         // walk type and init value\n@@ -624,7 +553,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n-        let (val, fields) =\n+        let (value, fields) =\n             if let ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, _), _) = item.node\n         {\n             let fields_str = fields.iter()\n@@ -633,26 +562,28 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                                   .unwrap_or(i.to_string()))\n                                    .collect::<Vec<_>>()\n                                    .join(\", \");\n-            (format!(\"{} {{ {} }}\", name, fields_str), fields.iter().map(|f| f.id).collect())\n+            (format!(\"{} {{ {} }}\", name, fields_str),\n+             fields.iter().map(|f| ::id_from_node_id(f.id, &self.save_ctxt)).collect())\n         } else {\n             (String::new(), vec![])\n         };\n \n         if !self.span.filter_generated(sub_span, item.span) {\n-            self.dumper.struct_data(StructData {\n-                span: sub_span.expect(\"No span found for struct\"),\n-                id: item.id,\n-                name: name,\n-                ctor_id: def.id(),\n+            let span = self.span_from_span(sub_span.expect(\"No span found for struct\"));\n+            self.dumper.dump_def(item.vis == ast::Visibility::Public, Def {\n+                kind: DefKind::Struct,\n+                id: ::id_from_node_id(item.id, &self.save_ctxt),\n+                span,\n+                name,\n                 qualname: qualname.clone(),\n-                scope: self.cur_scope,\n-                value: val,\n-                fields: fields,\n-                visibility: From::from(&item.vis),\n+                value,\n+                parent: None,\n+                children: fields,\n+                decl_id: None,\n                 docs: docs_for_attrs(&item.attrs),\n                 sig: sig::item_signature(item, &self.save_ctxt),\n-                attributes: item.attrs.clone(),\n-            }.lower(self.tcx));\n+                attributes: lower_attributes(item.attrs.clone(), &self.save_ctxt),\n+            });\n         }\n \n         for field in def.fields() {\n@@ -672,10 +603,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             None => return,\n             Some(data) => data,\n         };\n-        down_cast_data!(enum_data, EnumData, item.span);\n-        if !self.span.filter_generated(Some(enum_data.span), item.span) {\n-            self.dumper.enum_data(enum_data.clone().lower(self.tcx));\n-        }\n+        down_cast_data!(enum_data, DefData, item.span);\n \n         for variant in &enum_definition.variants {\n             let name = variant.node.name.name.to_string();\n@@ -692,48 +620,62 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                                           .unwrap_or(i.to_string()))\n                                            .collect::<Vec<_>>()\n                                            .join(\", \");\n-                    let val = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n+                    let value = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n                     if !self.span.filter_generated(sub_span, variant.span) {\n-                        self.dumper.struct_variant(StructVariantData {\n-                            span: sub_span.expect(\"No span found for struct variant\"),\n-                            id: variant.node.data.id(),\n-                            name: name,\n-                            qualname: qualname,\n-                            type_value: enum_data.qualname.clone(),\n-                            value: val,\n-                            scope: enum_data.scope,\n-                            parent: Some(make_def_id(item.id, &self.tcx.hir)),\n+                        let span = self.span_from_span(\n+                            sub_span.expect(\"No span found for struct variant\"));\n+                        let id = ::id_from_node_id(variant.node.data.id(), &self.save_ctxt);\n+                        let parent = Some(::id_from_node_id(item.id, &self.save_ctxt));\n+\n+                        self.dumper.dump_def(item.vis == ast::Visibility::Public, Def {\n+                            kind: DefKind::Struct,\n+                            id,\n+                            span,\n+                            name,\n+                            qualname,\n+                            value,\n+                            parent,\n+                            children: vec![],\n+                            decl_id: None,\n                             docs: docs_for_attrs(&variant.node.attrs),\n                             sig: sig::variant_signature(variant, &self.save_ctxt),\n-                            attributes: variant.node.attrs.clone(),\n-                        }.lower(self.tcx));\n+                            attributes: lower_attributes(variant.node.attrs.clone(),\n+                                                         &self.save_ctxt),\n+                        });\n                     }\n                 }\n                 ref v => {\n                     let sub_span = self.span.span_for_first_ident(variant.span);\n-                    let mut val = format!(\"{}::{}\", enum_data.name, name);\n+                    let mut value = format!(\"{}::{}\", enum_data.name, name);\n                     if let &ast::VariantData::Tuple(ref fields, _) = v {\n-                        val.push('(');\n-                        val.push_str(&fields.iter()\n-                                            .map(|f| ty_to_string(&f.ty))\n-                                            .collect::<Vec<_>>()\n-                                            .join(\", \"));\n-                        val.push(')');\n+                        value.push('(');\n+                        value.push_str(&fields.iter()\n+                                              .map(|f| ty_to_string(&f.ty))\n+                                              .collect::<Vec<_>>()\n+                                              .join(\", \"));\n+                        value.push(')');\n                     }\n                     if !self.span.filter_generated(sub_span, variant.span) {\n-                        self.dumper.tuple_variant(TupleVariantData {\n-                            span: sub_span.expect(\"No span found for tuple variant\"),\n-                            id: variant.node.data.id(),\n-                            name: name,\n-                            qualname: qualname,\n-                            type_value: enum_data.qualname.clone(),\n-                            value: val,\n-                            scope: enum_data.scope,\n-                            parent: Some(make_def_id(item.id, &self.tcx.hir)),\n+                        let span =\n+                            self.span_from_span(sub_span.expect(\"No span found for tuple variant\"));\n+                        let id = ::id_from_node_id(variant.node.data.id(), &self.save_ctxt);\n+                        let parent = Some(::id_from_node_id(item.id, &self.save_ctxt));\n+\n+                        self.dumper.dump_def(item.vis == ast::Visibility::Public, Def {\n+                            kind: DefKind::Tuple,\n+                            id,\n+                            span,\n+                            name,\n+                            qualname,\n+                            value,\n+                            parent,\n+                            children: vec![],\n+                            decl_id: None,\n                             docs: docs_for_attrs(&variant.node.attrs),\n                             sig: sig::variant_signature(variant, &self.save_ctxt),\n-                            attributes: variant.node.attrs.clone(),\n-                        }.lower(self.tcx));\n+                            attributes: lower_attributes(variant.node.attrs.clone(),\n+                                                         &self.save_ctxt),\n+                        });\n                     }\n                 }\n             }\n@@ -744,7 +686,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 self.visit_ty(&field.ty);\n             }\n         }\n-        self.process_generic_params(ty_params, item.span, &enum_data.qualname, enum_data.id);\n+        self.process_generic_params(ty_params, item.span, &enum_data.qualname, item.id);\n+        self.dumper.dump_def(item.vis == ast::Visibility::Public, enum_data);\n     }\n \n     fn process_impl(&mut self,\n@@ -754,25 +697,17 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     typ: &'l ast::Ty,\n                     impl_items: &'l [ast::ImplItem]) {\n         if let Some(impl_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(impl_data, ImplData, item.span);\n-            if !self.span.filter_generated(Some(impl_data.span), item.span) {\n-                self.dumper.impl_data(ImplData {\n-                    id: impl_data.id,\n-                    span: impl_data.span,\n-                    scope: impl_data.scope,\n-                    trait_ref: impl_data.trait_ref.map(|d| d.ref_id.unwrap()),\n-                    self_ref: impl_data.self_ref.map(|d| d.ref_id.unwrap())\n-                }.lower(self.tcx));\n-            }\n+            down_cast_data!(impl_data, RelationData, item.span);\n+            self.dumper.dump_relation(impl_data);\n         }\n         self.visit_ty(&typ);\n         if let &Some(ref trait_ref) = trait_ref {\n-            self.process_path(trait_ref.ref_id, &trait_ref.path, Some(recorder::TypeRef));\n+            self.process_path(trait_ref.ref_id, &trait_ref.path);\n         }\n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items {\n             let map = &self.tcx.hir;\n-            self.process_impl_item(impl_item, make_def_id(item.id, map));\n+            self.process_impl_item(impl_item, map.local_def_id(item.id));\n         }\n     }\n \n@@ -793,19 +728,24 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n         if !self.span.filter_generated(sub_span, item.span) {\n-            self.dumper.trait_data(TraitData {\n-                span: sub_span.expect(\"No span found for trait\"),\n-                id: item.id,\n-                name: name,\n+            let id = ::id_from_node_id(item.id, &self.save_ctxt);\n+            let span = self.span_from_span(sub_span.expect(\"No span found for trait\"));\n+            let children =\n+                methods.iter().map(|i| ::id_from_node_id(i.id, &self.save_ctxt)).collect();\n+            self.dumper.dump_def(item.vis == ast::Visibility::Public, Def {\n+                kind: DefKind::Trait,\n+                id,\n+                span,\n+                name,\n                 qualname: qualname.clone(),\n-                scope: self.cur_scope,\n                 value: val,\n-                items: methods.iter().map(|i| i.id).collect(),\n-                visibility: From::from(&item.vis),\n+                parent: None,\n+                children,\n+                decl_id: None,\n                 docs: docs_for_attrs(&item.attrs),\n                 sig: sig::item_signature(item, &self.save_ctxt),\n-                attributes: item.attrs.clone(),\n-            }.lower(self.tcx));\n+                attributes: lower_attributes(item.attrs.clone(), &self.save_ctxt),\n+            });\n         }\n \n         // super-traits\n@@ -823,21 +763,22 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             if let Some(id) = self.lookup_def_id(trait_ref.ref_id) {\n                 let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n                 if !self.span.filter_generated(sub_span, trait_ref.path.span) {\n-                    self.dumper.type_ref(TypeRefData {\n-                        span: sub_span.expect(\"No span found for trait ref\"),\n-                        ref_id: Some(id),\n-                        scope: self.cur_scope,\n-                        qualname: String::new()\n-                    }.lower(self.tcx));\n+                    let span = self.span_from_span(sub_span.expect(\"No span found for trait ref\"));\n+                    self.dumper.dump_ref(Ref {\n+                        kind: RefKind::Type,\n+                        span,\n+                        ref_id: ::id_from_def_id(id),\n+                    });\n                 }\n \n                 if !self.span.filter_generated(sub_span, trait_ref.path.span) {\n-                    let sub_span = sub_span.expect(\"No span for inheritance\");\n-                    self.dumper.inheritance(InheritanceData {\n+                    let sub_span = self.span_from_span(sub_span.expect(\"No span for inheritance\"));\n+                    self.dumper.dump_relation(Relation {\n+                        kind: RelationKind::SuperTrait,\n                         span: sub_span,\n-                        base_id: id,\n-                        deriv_id: item.id\n-                    }.lower(self.tcx));\n+                        from: ::id_from_def_id(id),\n+                        to: ::id_from_node_id(item.id, &self.save_ctxt),\n+                    });\n                 }\n             }\n         }\n@@ -846,21 +787,19 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         self.process_generic_params(generics, item.span, &qualname, item.id);\n         for method in methods {\n             let map = &self.tcx.hir;\n-            self.process_trait_item(method, make_def_id(item.id, map))\n+            self.process_trait_item(method, map.local_def_id(item.id))\n         }\n     }\n \n     // `item` is the module in question, represented as an item.\n     fn process_mod(&mut self, item: &ast::Item) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(mod_data, ModData, item.span);\n-            if !self.span.filter_generated(Some(mod_data.span), item.span) {\n-                self.dumper.mod_data(mod_data.lower(self.tcx));\n-            }\n+            down_cast_data!(mod_data, DefData, item.span);\n+            self.dumper.dump_def(item.vis == ast::Visibility::Public, mod_data);\n         }\n     }\n \n-    fn process_path(&mut self, id: NodeId, path: &ast::Path, ref_kind: Option<recorder::Row>) {\n+    fn process_path(&mut self, id: NodeId, path: &ast::Path) {\n         let path_data = self.save_ctxt.get_path_data(id, path);\n         if generated_code(path.span) && path_data.is_none() {\n             return;\n@@ -873,81 +812,29 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             }\n         };\n \n-        match path_data {\n-            Data::VariableRefData(vrd) => {\n-                // FIXME: this whole block duplicates the code in process_def_kind\n-                if !self.span.filter_generated(Some(vrd.span), path.span) {\n-                    match ref_kind {\n-                        Some(recorder::TypeRef) => {\n-                            self.dumper.type_ref(TypeRefData {\n-                                span: vrd.span,\n-                                ref_id: Some(vrd.ref_id),\n-                                scope: vrd.scope,\n-                                qualname: String::new()\n-                            }.lower(self.tcx));\n-                        }\n-                        Some(recorder::FnRef) => {\n-                            self.dumper.function_ref(FunctionRefData {\n-                                span: vrd.span,\n-                                ref_id: vrd.ref_id,\n-                                scope: vrd.scope\n-                            }.lower(self.tcx));\n-                        }\n-                        Some(recorder::ModRef) => {\n-                            self.dumper.mod_ref( ModRefData {\n-                                span: vrd.span,\n-                                ref_id: Some(vrd.ref_id),\n-                                scope: vrd.scope,\n-                                qualname: String::new()\n-                            }.lower(self.tcx));\n-                        }\n-                        Some(recorder::VarRef) | None\n-                            => self.dumper.variable_ref(vrd.lower(self.tcx))\n-                    }\n-                }\n-\n-            }\n-            Data::TypeRefData(trd) => {\n-                if !self.span.filter_generated(Some(trd.span), path.span) {\n-                    self.dumper.type_ref(trd.lower(self.tcx));\n-                }\n-            }\n-            Data::MethodCallData(mcd) => {\n-                if !self.span.filter_generated(Some(mcd.span), path.span) {\n-                    self.dumper.method_call(mcd.lower(self.tcx));\n-                }\n-            }\n-            Data::FunctionCallData(fcd) => {\n-                if !self.span.filter_generated(Some(fcd.span), path.span) {\n-                    self.dumper.function_call(fcd.lower(self.tcx));\n-                }\n-            }\n-            _ => {\n-               span_bug!(path.span, \"Unexpected data: {:?}\", path_data);\n-            }\n-        }\n+        self.dumper.dump_ref(path_data);\n \n         // Modules or types in the path prefix.\n         match self.save_ctxt.get_path_def(id) {\n-            Def::Method(did) => {\n+            HirDef::Method(did) => {\n                 let ti = self.tcx.associated_item(did);\n                 if ti.kind == ty::AssociatedKind::Method && ti.method_has_self_argument {\n                     self.write_sub_path_trait_truncated(path);\n                 }\n             }\n-            Def::Fn(..) |\n-            Def::Const(..) |\n-            Def::Static(..) |\n-            Def::StructCtor(..) |\n-            Def::VariantCtor(..) |\n-            Def::AssociatedConst(..) |\n-            Def::Local(..) |\n-            Def::Upvar(..) |\n-            Def::Struct(..) |\n-            Def::Union(..) |\n-            Def::Variant(..) |\n-            Def::TyAlias(..) |\n-            Def::AssociatedTy(..) => self.write_sub_paths_truncated(path),\n+            HirDef::Fn(..) |\n+            HirDef::Const(..) |\n+            HirDef::Static(..) |\n+            HirDef::StructCtor(..) |\n+            HirDef::VariantCtor(..) |\n+            HirDef::AssociatedConst(..) |\n+            HirDef::Local(..) |\n+            HirDef::Upvar(..) |\n+            HirDef::Struct(..) |\n+            HirDef::Union(..) |\n+            HirDef::Variant(..) |\n+            HirDef::TyAlias(..) |\n+            HirDef::AssociatedTy(..) => self.write_sub_paths_truncated(path),\n             _ => {}\n         }\n     }\n@@ -961,20 +848,15 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         self.write_sub_paths_truncated(path);\n \n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n-            down_cast_data!(struct_lit_data, TypeRefData, ex.span);\n-            if !self.span.filter_generated(Some(struct_lit_data.span), ex.span) {\n-                self.dumper.type_ref(struct_lit_data.lower(self.tcx));\n+            down_cast_data!(struct_lit_data, RefData, ex.span);\n+            if !generated_code(ex.span) {\n+                self.dumper.dump_ref(struct_lit_data);\n             }\n \n-            let scope = self.save_ctxt.enclosing_scope(ex.id);\n-\n             for field in fields {\n                 if let Some(field_data) = self.save_ctxt\n-                                              .get_field_ref_data(field, variant, scope) {\n-\n-                    if !self.span.filter_generated(Some(field_data.span), field.ident.span) {\n-                        self.dumper.variable_ref(field_data.lower(self.tcx));\n-                    }\n+                                              .get_field_ref_data(field, variant) {\n+                    self.dumper.dump_ref(field_data);\n                 }\n \n                 self.visit_expr(&field.expr)\n@@ -986,9 +868,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n     fn process_method_call(&mut self, ex: &'l ast::Expr, args: &'l [P<ast::Expr>]) {\n         if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n-            down_cast_data!(mcd, MethodCallData, ex.span);\n-            if !self.span.filter_generated(Some(mcd.span), ex.span) {\n-                self.dumper.method_call(mcd.lower(self.tcx));\n+            down_cast_data!(mcd, RefData, ex.span);\n+            if !generated_code(ex.span) {\n+                self.dumper.dump_ref(mcd);\n             }\n         }\n \n@@ -1013,12 +895,13 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     let sub_span = self.span.span_for_first_ident(span);\n                     if let Some(f) = variant.find_field_named(field.ident.name) {\n                         if !self.span.filter_generated(sub_span, span) {\n-                            self.dumper.variable_ref(VariableRefData {\n-                                span: sub_span.expect(\"No span fund for var ref\"),\n-                                ref_id: f.did,\n-                                scope: self.cur_scope,\n-                                name: String::new()\n-                            }.lower(self.tcx));\n+                            let span =\n+                                self.span_from_span(sub_span.expect(\"No span fund for var ref\"));\n+                            self.dumper.dump_ref(Ref {\n+                                kind: RefKind::Variable,\n+                                span,\n+                                ref_id: ::id_from_def_id(f.did),\n+                            });\n                         }\n                     }\n                     self.visit_pat(&field.pat);\n@@ -1036,7 +919,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         collector.visit_pat(&p);\n         self.visit_pat(&p);\n \n-        for &(id, ref p, immut, _) in &collector.collected_paths {\n+        for &(id, ref p, immut) in &collector.collected_paths {\n             let mut value = match immut {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n@@ -1058,21 +941,24 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             let sub_span = self.span.span_for_last_ident(p.span);\n             // Rust uses the id of the pattern for var lookups, so we'll use it too.\n             if !self.span.filter_generated(sub_span, p.span) {\n-                self.dumper.variable(VariableData {\n-                    span: sub_span.expect(\"No span found for variable\"),\n-                    kind: VariableKind::Local,\n-                    id: id,\n+                let qualname = format!(\"{}${}\", path_to_string(p), id);\n+                let id = ::id_from_node_id(id, &self.save_ctxt);\n+                let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n+\n+                self.dumper.dump_def(false, Def {\n+                    kind: DefKind::Local,\n+                    id,\n+                    span,\n                     name: path_to_string(p),\n-                    qualname: format!(\"{}${}\", path_to_string(p), id),\n-                    value: value,\n-                    type_value: typ,\n-                    scope: CRATE_NODE_ID,\n+                    qualname,\n+                    value: typ,\n                     parent: None,\n-                    visibility: Visibility::Inherited,\n+                    children: vec![],\n+                    decl_id: None,\n                     docs: String::new(),\n                     sig: None,\n-                    attributes: vec![],\n-                }.lower(self.tcx));\n+                    attributes:vec![],\n+                });\n             }\n         }\n     }\n@@ -1084,46 +970,36 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     /// If the span is not macro-generated, do nothing, else use callee and\n     /// callsite spans to record macro definition and use data, using the\n     /// mac_uses and mac_defs sets to prevent multiples.\n-    fn process_macro_use(&mut self, span: Span, id: NodeId) {\n-        let data = match self.save_ctxt.get_macro_use_data(span, id) {\n+    fn process_macro_use(&mut self, span: Span) {\n+        let data = match self.save_ctxt.get_macro_use_data(span) {\n             None => return,\n             Some(data) => data,\n         };\n-        let mut hasher = DefaultHasher::new();\n-        data.callee_span.hash(&mut hasher);\n-        let hash = hasher.finish();\n-        let qualname = format!(\"{}::{}\", data.name, hash);\n+\n+        // FIXME write the macro def\n+        // let mut hasher = DefaultHasher::new();\n+        // data.callee_span.hash(&mut hasher);\n+        // let hash = hasher.finish();\n+        // let qualname = format!(\"{}::{}\", data.name, hash);\n         // Don't write macro definition for imported macros\n-        if !self.mac_defs.contains(&data.callee_span)\n-            && !data.imported {\n-            self.mac_defs.insert(data.callee_span);\n-            if let Some(sub_span) = self.span.span_for_macro_def_name(data.callee_span) {\n-                self.dumper.macro_data(MacroData {\n-                    span: sub_span,\n-                    name: data.name.clone(),\n-                    qualname: qualname.clone(),\n-                    // FIXME where do macro docs come from?\n-                    docs: String::new(),\n-                }.lower(self.tcx));\n-            }\n-        }\n-        if !self.mac_uses.contains(&data.span) {\n-            self.mac_uses.insert(data.span);\n-            if let Some(sub_span) = self.span.span_for_macro_use_name(data.span) {\n-                self.dumper.macro_use(MacroUseData {\n-                    span: sub_span,\n-                    name: data.name,\n-                    qualname: qualname,\n-                    scope: data.scope,\n-                    callee_span: data.callee_span,\n-                    imported: data.imported,\n-                }.lower(self.tcx));\n-            }\n-        }\n+        // if !self.mac_defs.contains(&data.callee_span)\n+        //     && !data.imported {\n+        //     self.mac_defs.insert(data.callee_span);\n+        //     if let Some(sub_span) = self.span.span_for_macro_def_name(data.callee_span) {\n+        //         self.dumper.macro_data(MacroData {\n+        //             span: sub_span,\n+        //             name: data.name.clone(),\n+        //             qualname: qualname.clone(),\n+        //             // FIXME where do macro docs come from?\n+        //             docs: String::new(),\n+        //         }.lower(self.tcx));\n+        //     }\n+        // }\n+        self.dumper.macro_use(data);\n     }\n \n     fn process_trait_item(&mut self, trait_item: &'l ast::TraitItem, trait_id: DefId) {\n-        self.process_macro_use(trait_item.span, trait_item.id);\n+        self.process_macro_use(trait_item.span);\n         match trait_item.node {\n             ast::TraitItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(trait_item.id,\n@@ -1132,16 +1008,15 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                          &ty,\n                                          expr.as_ref().map(|e| &**e),\n                                          trait_id,\n-                                         Visibility::Public,\n+                                         ast::Visibility::Public,\n                                          &trait_item.attrs);\n             }\n             ast::TraitItemKind::Method(ref sig, ref body) => {\n                 self.process_method(sig,\n                                     body.as_ref().map(|x| &**x),\n                                     trait_item.id,\n                                     trait_item.ident,\n-                                    Visibility::Public,\n-                                    &trait_item.attrs,\n+                                    ast::Visibility::Public,\n                                     trait_item.span);\n             }\n             ast::TraitItemKind::Type(ref bounds, ref default_ty) => {\n@@ -1151,22 +1026,27 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 let sub_span = self.span.sub_span_after_keyword(trait_item.span, keywords::Type);\n \n                 if !self.span.filter_generated(sub_span, trait_item.span) {\n-                    self.dumper.typedef(TypeDefData {\n-                        span: sub_span.expect(\"No span found for assoc type\"),\n-                        name: name,\n-                        id: trait_item.id,\n-                        qualname: qualname,\n+                    let span = self.span_from_span(sub_span.expect(\"No span found for assoc type\"));\n+                    let id = ::id_from_node_id(trait_item.id, &self.save_ctxt);\n+\n+                    self.dumper.dump_def(true, Def {\n+                        kind: DefKind::Type,\n+                        id,\n+                        span,\n+                        name,\n+                        qualname,\n                         value: self.span.snippet(trait_item.span),\n-                        visibility: Visibility::Public,\n-                        parent: Some(trait_id),\n+                        parent: Some(::id_from_def_id(trait_id)),\n+                        children: vec![],\n+                        decl_id: None,\n                         docs: docs_for_attrs(&trait_item.attrs),\n                         sig: sig::assoc_type_signature(trait_item.id,\n                                                        trait_item.ident,\n                                                        Some(bounds),\n                                                        default_ty.as_ref().map(|ty| &**ty),\n                                                        &self.save_ctxt),\n-                        attributes: trait_item.attrs.clone(),\n-                    }.lower(self.tcx));\n+                        attributes: lower_attributes(trait_item.attrs.clone(), &self.save_ctxt),\n+                    });\n                 }\n \n                 if let &Some(ref default_ty) = default_ty {\n@@ -1178,7 +1058,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     }\n \n     fn process_impl_item(&mut self, impl_item: &'l ast::ImplItem, impl_id: DefId) {\n-        self.process_macro_use(impl_item.span, impl_item.id);\n+        self.process_macro_use(impl_item.span);\n         match impl_item.node {\n             ast::ImplItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(impl_item.id,\n@@ -1187,16 +1067,15 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                          &ty,\n                                          Some(expr),\n                                          impl_id,\n-                                         From::from(&impl_item.vis),\n+                                         impl_item.vis.clone(),\n                                          &impl_item.attrs);\n             }\n             ast::ImplItemKind::Method(ref sig, ref body) => {\n                 self.process_method(sig,\n                                     Some(body),\n                                     impl_item.id,\n                                     impl_item.ident,\n-                                    From::from(&impl_item.vis),\n-                                    &impl_item.attrs,\n+                                    impl_item.vis.clone(),\n                                     impl_item.span);\n             }\n             ast::ImplItemKind::Type(ref ty) => {\n@@ -1220,35 +1099,38 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n \n         let cm = self.tcx.sess.codemap();\n         let filename = cm.span_to_filename(span);\n-        self.dumper.mod_data(ModData {\n-            id: id,\n+        let data_id = ::id_from_node_id(id, &self.save_ctxt);\n+        let children = m.items.iter().map(|i| ::id_from_node_id(i.id, &self.save_ctxt)).collect();\n+        let span = self.span_from_span(span);\n+\n+        self.dumper.dump_def(true, Def {\n+            kind: DefKind::Mod,\n+            id: data_id,\n             name: String::new(),\n-            qualname: qualname,\n-            span: span,\n-            scope: id,\n-            filename: filename,\n-            items: m.items.iter().map(|i| i.id).collect(),\n-            visibility: Visibility::Public,\n+            qualname,\n+            span,\n+            value: filename,\n+            children,\n+            parent: None,\n+            decl_id: None,\n             docs: docs_for_attrs(attrs),\n             sig: None,\n-            attributes: attrs.to_owned(),\n-        }.lower(self.tcx));\n+            attributes: lower_attributes(attrs.to_owned(), &self.save_ctxt),\n+        });\n         self.nest_scope(id, |v| visit::walk_mod(v, m));\n     }\n \n     fn visit_item(&mut self, item: &'l ast::Item) {\n         use syntax::ast::ItemKind::*;\n-        self.process_macro_use(item.span, item.id);\n+        self.process_macro_use(item.span);\n         match item.node {\n             Use(ref use_item) => {\n                 match use_item.node {\n                     ast::ViewPathSimple(ident, ref path) => {\n                         let sub_span = self.span.span_for_last_ident(path.span);\n                         let mod_id = match self.lookup_def_id(item.id) {\n                             Some(def_id) => {\n-                                let scope = self.cur_scope;\n-                                self.process_def_kind(item.id, path.span, sub_span, def_id, scope);\n-\n+                                self.process_def_kind(item.id, path.span, sub_span, def_id);\n                                 Some(def_id)\n                             }\n                             None => None,\n@@ -1263,14 +1145,15 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                         };\n \n                         if !self.span.filter_generated(sub_span, path.span) {\n-                            self.dumper.use_data(UseData {\n-                                span: sub_span.expect(\"No span found for use\"),\n-                                id: item.id,\n-                                mod_id: mod_id,\n+                            let span =\n+                                self.span_from_span(sub_span.expect(\"No span found for use\"));\n+                            self.dumper.import(item.vis == ast::Visibility::Public, Import {\n+                                kind: ImportKind::Use,\n+                                ref_id: mod_id.map(|id| ::id_from_def_id(id)),\n+                                span,\n                                 name: ident.to_string(),\n-                                scope: self.cur_scope,\n-                                visibility: From::from(&item.vis),\n-                            }.lower(self.tcx));\n+                                value: String::new(),\n+                            });\n                         }\n                         self.write_sub_paths_truncated(path);\n                     }\n@@ -1288,50 +1171,44 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                         let sub_span = self.span\n                                            .sub_span_of_token(item.span, token::BinOp(token::Star));\n                         if !self.span.filter_generated(sub_span, item.span) {\n-                            self.dumper.use_glob(UseGlobData {\n-                                span: sub_span.expect(\"No span found for use glob\"),\n-                                id: item.id,\n-                                names: names,\n-                                scope: self.cur_scope,\n-                                visibility: From::from(&item.vis),\n-                            }.lower(self.tcx));\n+                            let span =\n+                                self.span_from_span(sub_span.expect(\"No span found for use glob\"));\n+                            self.dumper.import(item.vis == ast::Visibility::Public, Import {\n+                                kind: ImportKind::GlobUse,\n+                                ref_id: None,\n+                                span,\n+                                name: \"*\".to_owned(),\n+                                value: names.join(\", \"),\n+                            });\n                         }\n                         self.write_sub_paths(path);\n                     }\n                     ast::ViewPathList(ref path, ref list) => {\n                         for plid in list {\n-                            let scope = self.cur_scope;\n                             let id = plid.node.id;\n                             if let Some(def_id) = self.lookup_def_id(id) {\n                                 let span = plid.span;\n-                                self.process_def_kind(id, span, Some(span), def_id, scope);\n+                                self.process_def_kind(id, span, Some(span), def_id);\n                             }\n                         }\n \n                         self.write_sub_paths(path);\n                     }\n                 }\n             }\n-            ExternCrate(ref s) => {\n-                let location = match *s {\n-                    Some(s) => s.to_string(),\n-                    None => item.ident.to_string(),\n-                };\n+            ExternCrate(_) => {\n                 let alias_span = self.span.span_for_last_ident(item.span);\n-                let cnum = match self.sess.cstore.extern_mod_stmt_cnum(item.id) {\n-                    Some(cnum) => cnum,\n-                    None => LOCAL_CRATE,\n-                };\n \n                 if !self.span.filter_generated(alias_span, item.span) {\n-                    self.dumper.extern_crate(ExternCrateData {\n-                        id: item.id,\n+                    let span =\n+                        self.span_from_span(alias_span.expect(\"No span found for extern crate\"));\n+                    self.dumper.import(false, Import {\n+                        kind: ImportKind::ExternCrate,\n+                        ref_id: None,\n+                        span,\n                         name: item.ident.to_string(),\n-                        crate_num: cnum,\n-                        location: location,\n-                        span: alias_span.expect(\"No span found for extern crate\"),\n-                        scope: self.cur_scope,\n-                    }.lower(self.tcx));\n+                        value: String::new(),\n+                    });\n                 }\n             }\n             Fn(ref decl, .., ref ty_params, ref body) =>\n@@ -1360,18 +1237,23 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                 let value = ty_to_string(&ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 if !self.span.filter_generated(sub_span, item.span) {\n-                    self.dumper.typedef(TypeDefData {\n-                        span: sub_span.expect(\"No span found for typedef\"),\n+                    let span = self.span_from_span(sub_span.expect(\"No span found for typedef\"));\n+                    let id = ::id_from_node_id(item.id, &self.save_ctxt);\n+\n+                    self.dumper.dump_def(item.vis == ast::Visibility::Public, Def {\n+                        kind: DefKind::Type,\n+                        id,\n+                        span,\n                         name: item.ident.to_string(),\n-                        id: item.id,\n                         qualname: qualname.clone(),\n-                        value: value,\n-                        visibility: From::from(&item.vis),\n+                        value,\n                         parent: None,\n+                        children: vec![],\n+                        decl_id: None,\n                         docs: docs_for_attrs(&item.attrs),\n                         sig: sig::item_signature(item, &self.save_ctxt),\n-                        attributes: item.attrs.clone(),\n-                    }.lower(self.tcx));\n+                        attributes: lower_attributes(item.attrs.clone(), &self.save_ctxt),\n+                    });\n                 }\n \n                 self.visit_ty(&ty);\n@@ -1396,7 +1278,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n     }\n \n     fn visit_ty(&mut self, t: &'l ast::Ty) {\n-        self.process_macro_use(t.span, t.id);\n+        self.process_macro_use(t.span);\n         match t.node {\n             ast::TyKind::Path(_, ref path) => {\n                 if generated_code(t.span) {\n@@ -1405,12 +1287,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n \n                 if let Some(id) = self.lookup_def_id(t.id) {\n                     if let Some(sub_span) = self.span.sub_span_for_type_name(t.span) {\n-                        self.dumper.type_ref(TypeRefData {\n-                            span: sub_span,\n-                            ref_id: Some(id),\n-                            scope: self.cur_scope,\n-                            qualname: String::new()\n-                        }.lower(self.tcx));\n+                        let span = self.span_from_span(sub_span);\n+                        self.dumper.dump_ref(Ref {\n+                            kind: RefKind::Type,\n+                            span,\n+                            ref_id: ::id_from_def_id(id),\n+                        });\n                     }\n                 }\n \n@@ -1427,7 +1309,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n \n     fn visit_expr(&mut self, ex: &'l ast::Expr) {\n         debug!(\"visit_expr {:?}\", ex.node);\n-        self.process_macro_use(ex.span, ex.id);\n+        self.process_macro_use(ex.span);\n         match ex.node {\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = self.save_ctxt.tcx.hir.expect_expr(ex.id);\n@@ -1446,9 +1328,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                 self.visit_expr(&sub_ex);\n \n                 if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n-                    down_cast_data!(field_data, VariableRefData, ex.span);\n-                    if !self.span.filter_generated(Some(field_data.span), ex.span) {\n-                        self.dumper.variable_ref(field_data.lower(self.tcx));\n+                    down_cast_data!(field_data, RefData, ex.span);\n+                    if !generated_code(ex.span) {\n+                        self.dumper.dump_ref(field_data);\n                     }\n                 }\n             }\n@@ -1474,12 +1356,13 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                     ty::TyAdt(def, _) => {\n                         let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n                         if !self.span.filter_generated(sub_span, ex.span) {\n-                            self.dumper.variable_ref(VariableRefData {\n-                                span: sub_span.expect(\"No span found for var ref\"),\n-                                ref_id: def.struct_variant().fields[idx.node].did,\n-                                scope: self.cur_scope,\n-                                name: String::new()\n-                            }.lower(self.tcx));\n+                            let span =\n+                                self.span_from_span(sub_span.expect(\"No span found for var ref\"));\n+                            self.dumper.dump_ref(Ref {\n+                                kind: RefKind::Variable,\n+                                span: span,\n+                                ref_id: ::id_from_def_id(def.struct_variant().fields[idx.node].did),\n+                            });\n                         }\n                     }\n                     ty::TyTuple(..) => {}\n@@ -1540,7 +1423,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n     }\n \n     fn visit_pat(&mut self, p: &'l ast::Pat) {\n-        self.process_macro_use(p.span, p.id);\n+        self.process_macro_use(p.span);\n         self.process_pat(p);\n     }\n \n@@ -1556,9 +1439,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n         let mut paths_to_process = vec![];\n \n         // process collected paths\n-        for &(id, ref p, immut, ref_kind) in &collector.collected_paths {\n+        for &(id, ref p, immut) in &collector.collected_paths {\n             match self.save_ctxt.get_path_def(id) {\n-                Def::Local(def_id) => {\n+                HirDef::Local(def_id) => {\n                     let id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     let mut value = if immut == ast::Mutability::Immutable {\n                         self.span.snippet(p.span).to_string()\n@@ -1573,53 +1456,56 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                     assert!(p.segments.len() == 1,\n                             \"qualified path for local variable def in arm\");\n                     if !self.span.filter_generated(Some(p.span), p.span) {\n-                        self.dumper.variable(VariableData {\n-                            span: p.span,\n-                            kind: VariableKind::Local,\n-                            id: id,\n+                        let qualname = format!(\"{}${}\", path_to_string(p), id);\n+                        let id = ::id_from_node_id(id, &self.save_ctxt);\n+                        let span = self.span_from_span(p.span);\n+\n+                        self.dumper.dump_def(false, Def {\n+                            kind: DefKind::Local,\n+                            id,\n+                            span,\n                             name: path_to_string(p),\n-                            qualname: format!(\"{}${}\", path_to_string(p), id),\n-                            value: value,\n-                            type_value: typ,\n-                            scope: CRATE_NODE_ID,\n+                            qualname,\n+                            value: typ,\n                             parent: None,\n-                            visibility: Visibility::Inherited,\n+                            children: vec![],\n+                            decl_id: None,\n                             docs: String::new(),\n                             sig: None,\n-                            attributes: vec![],\n-                        }.lower(self.tcx));\n+                            attributes:vec![],\n+                        });\n                     }\n                 }\n-                Def::StructCtor(..) | Def::VariantCtor(..) |\n-                Def::Const(..) | Def::AssociatedConst(..) |\n-                Def::Struct(..) | Def::Variant(..) |\n-                Def::TyAlias(..) | Def::AssociatedTy(..) |\n-                Def::SelfTy(..) => {\n-                    paths_to_process.push((id, p.clone(), Some(ref_kind)))\n+                HirDef::StructCtor(..) | HirDef::VariantCtor(..) |\n+                HirDef::Const(..) | HirDef::AssociatedConst(..) |\n+                HirDef::Struct(..) | HirDef::Variant(..) |\n+                HirDef::TyAlias(..) | HirDef::AssociatedTy(..) |\n+                HirDef::SelfTy(..) => {\n+                    paths_to_process.push((id, p.clone()))\n                 }\n                 def => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n                               def),\n             }\n         }\n \n-        for &(id, ref path, ref_kind) in &paths_to_process {\n-            self.process_path(id, path, ref_kind);\n+        for &(id, ref path) in &paths_to_process {\n+            self.process_path(id, path);\n         }\n         walk_list!(self, visit_expr, &arm.guard);\n         self.visit_expr(&arm.body);\n     }\n \n     fn visit_path(&mut self, p: &'l ast::Path, id: NodeId) {\n-        self.process_path(id, p, None);\n+        self.process_path(id, p);\n     }\n \n     fn visit_stmt(&mut self, s: &'l ast::Stmt) {\n-        self.process_macro_use(s.span, s.id);\n+        self.process_macro_use(s.span);\n         visit::walk_stmt(self, s)\n     }\n \n     fn visit_local(&mut self, l: &'l ast::Local) {\n-        self.process_macro_use(l.span, l.id);\n+        self.process_macro_use(l.span);\n         let value = l.init.as_ref().map(|i| self.span.snippet(i.span)).unwrap_or(String::new());\n         self.process_var_decl(&l.pat, value);\n \n@@ -1632,14 +1518,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 if let Some(fn_data) = self.save_ctxt.get_extern_item_data(item) {\n-                    down_cast_data!(fn_data, FunctionData, item.span);\n-                    if !self.span.filter_generated(Some(fn_data.span), item.span) {\n-                        self.dumper.function(fn_data.clone().lower(self.tcx));\n-                    }\n+                    down_cast_data!(fn_data, DefData, item.span);\n \n                     self.nest_tables(item.id, |v| v.process_formals(&decl.inputs,\n                                                                     &fn_data.qualname));\n                     self.process_generic_params(generics, item.span, &fn_data.qualname, item.id);\n+                    self.dumper.dump_def(item.vis == ast::Visibility::Public, fn_data);\n                 }\n \n                 for arg in &decl.inputs {\n@@ -1652,10 +1536,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n             }\n             ast::ForeignItemKind::Static(ref ty, _) => {\n                 if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n-                    down_cast_data!(var_data, VariableData, item.span);\n-                    if !self.span.filter_generated(Some(var_data.span), item.span) {\n-                        self.dumper.variable(var_data.lower(self.tcx));\n-                    }\n+                    down_cast_data!(var_data, DefData, item.span);\n+                    self.dumper.dump_def(item.vis == ast::Visibility::Public, var_data);\n                 }\n \n                 self.visit_ty(ty);"}, {"sha": "245a3bcc61795bf32be467652e67ce2696839f92", "filename": "src/librustc_save_analysis/external_data.rs", "status": "removed", "additions": 0, "deletions": 748, "changes": 748, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -1,748 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::hir::def_id::{CrateNum, DefId, DefIndex};\n-use rustc::hir::map::Map;\n-use rustc::ty::TyCtxt;\n-use syntax::ast::{self, NodeId};\n-use syntax::codemap::CodeMap;\n-use syntax::print::pprust;\n-use syntax_pos::Span;\n-\n-use data::{self, Visibility};\n-\n-use rls_data::{SpanData, CratePreludeData, Attribute, Signature};\n-use rls_span::{Column, Row};\n-\n-// FIXME: this should be pub(crate), but the current snapshot doesn't allow it yet\n-pub trait Lower {\n-    type Target;\n-    fn lower(self, tcx: TyCtxt) -> Self::Target;\n-}\n-\n-pub fn make_def_id(id: NodeId, map: &Map) -> DefId {\n-    map.opt_local_def_id(id).unwrap_or(null_def_id())\n-}\n-\n-pub fn null_def_id() -> DefId {\n-    DefId {\n-        krate: CrateNum::from_u32(u32::max_value()),\n-        index: DefIndex::from_u32(u32::max_value())\n-    }\n-}\n-\n-pub fn span_from_span(span: Span, cm: &CodeMap) -> SpanData {\n-    let start = cm.lookup_char_pos(span.lo);\n-    let end = cm.lookup_char_pos(span.hi);\n-\n-    SpanData {\n-        file_name: start.file.name.clone().into(),\n-        byte_start: span.lo.0,\n-        byte_end: span.hi.0,\n-        line_start: Row::new_one_indexed(start.line as u32),\n-        line_end: Row::new_one_indexed(end.line as u32),\n-        column_start: Column::new_one_indexed(start.col.0 as u32 + 1),\n-        column_end: Column::new_one_indexed(end.col.0 as u32 + 1),\n-    }\n-}\n-\n-impl Lower for Vec<ast::Attribute> {\n-    type Target = Vec<Attribute>;\n-\n-    fn lower(self, tcx: TyCtxt) -> Vec<Attribute> {\n-        self.into_iter()\n-        // Only retain real attributes. Doc comments are lowered separately.\n-        .filter(|attr| attr.path != \"doc\")\n-        .map(|mut attr| {\n-            // Remove the surrounding '#[..]' or '#![..]' of the pretty printed\n-            // attribute. First normalize all inner attribute (#![..]) to outer\n-            // ones (#[..]), then remove the two leading and the one trailing character.\n-            attr.style = ast::AttrStyle::Outer;\n-            let value = pprust::attribute_to_string(&attr);\n-            // This str slicing works correctly, because the leading and trailing characters\n-            // are in the ASCII range and thus exactly one byte each.\n-            let value = value[2..value.len()-1].to_string();\n-\n-            Attribute {\n-                value: value,\n-                span: span_from_span(attr.span, tcx.sess.codemap()),\n-            }\n-        }).collect()\n-    }\n-}\n-\n-impl Lower for data::CratePreludeData {\n-    type Target = CratePreludeData;\n-\n-    fn lower(self, tcx: TyCtxt) -> CratePreludeData {\n-        CratePreludeData {\n-            crate_name: self.crate_name,\n-            crate_root: self.crate_root,\n-            external_crates: self.external_crates,\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-        }\n-    }\n-}\n-\n-/// Data for enum declarations.\n-#[derive(Clone, Debug)]\n-pub struct EnumData {\n-    pub id: DefId,\n-    pub value: String,\n-    pub name: String,\n-    pub qualname: String,\n-    pub span: SpanData,\n-    pub scope: DefId,\n-    pub variants: Vec<DefId>,\n-    pub visibility: Visibility,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-impl Lower for data::EnumData {\n-    type Target = EnumData;\n-\n-    fn lower(self, tcx: TyCtxt) -> EnumData {\n-        EnumData {\n-            id: make_def_id(self.id, &tcx.hir),\n-            name: self.name,\n-            value: self.value,\n-            qualname: self.qualname,\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            variants: self.variants.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n-            visibility: self.visibility,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes.lower(tcx),\n-        }\n-    }\n-}\n-\n-/// Data for extern crates.\n-#[derive(Debug)]\n-pub struct ExternCrateData {\n-    pub id: DefId,\n-    pub name: String,\n-    pub crate_num: CrateNum,\n-    pub location: String,\n-    pub span: SpanData,\n-    pub scope: DefId,\n-}\n-\n-impl Lower for data::ExternCrateData {\n-    type Target = ExternCrateData;\n-\n-    fn lower(self, tcx: TyCtxt) -> ExternCrateData {\n-        ExternCrateData {\n-            id: make_def_id(self.id, &tcx.hir),\n-            name: self.name,\n-            crate_num: self.crate_num,\n-            location: self.location,\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.hir),\n-        }\n-    }\n-}\n-\n-/// Data about a function call.\n-#[derive(Debug)]\n-pub struct FunctionCallData {\n-    pub span: SpanData,\n-    pub scope: DefId,\n-    pub ref_id: DefId,\n-}\n-\n-impl Lower for data::FunctionCallData {\n-    type Target = FunctionCallData;\n-\n-    fn lower(self, tcx: TyCtxt) -> FunctionCallData {\n-        FunctionCallData {\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            ref_id: self.ref_id,\n-        }\n-    }\n-}\n-\n-/// Data for all kinds of functions and methods.\n-#[derive(Clone, Debug)]\n-pub struct FunctionData {\n-    pub id: DefId,\n-    pub name: String,\n-    pub qualname: String,\n-    pub declaration: Option<DefId>,\n-    pub span: SpanData,\n-    pub scope: DefId,\n-    pub value: String,\n-    pub visibility: Visibility,\n-    pub parent: Option<DefId>,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-impl Lower for data::FunctionData {\n-    type Target = FunctionData;\n-\n-    fn lower(self, tcx: TyCtxt) -> FunctionData {\n-        FunctionData {\n-            id: make_def_id(self.id, &tcx.hir),\n-            name: self.name,\n-            qualname: self.qualname,\n-            declaration: self.declaration,\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            value: self.value,\n-            visibility: self.visibility,\n-            parent: self.parent,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes.lower(tcx),\n-        }\n-    }\n-}\n-\n-/// Data about a function call.\n-#[derive(Debug)]\n-pub struct FunctionRefData {\n-    pub span: SpanData,\n-    pub scope: DefId,\n-    pub ref_id: DefId,\n-}\n-\n-impl Lower for data::FunctionRefData {\n-    type Target = FunctionRefData;\n-\n-    fn lower(self, tcx: TyCtxt) -> FunctionRefData {\n-        FunctionRefData {\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            ref_id: self.ref_id,\n-        }\n-    }\n-}\n-#[derive(Debug)]\n-pub struct ImplData {\n-    pub id: DefId,\n-    pub span: SpanData,\n-    pub scope: DefId,\n-    pub trait_ref: Option<DefId>,\n-    pub self_ref: Option<DefId>,\n-}\n-\n-impl Lower for data::ImplData {\n-    type Target = ImplData;\n-\n-    fn lower(self, tcx: TyCtxt) -> ImplData {\n-        ImplData {\n-            id: make_def_id(self.id, &tcx.hir),\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            trait_ref: self.trait_ref,\n-            self_ref: self.self_ref,\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct InheritanceData {\n-    pub span: SpanData,\n-    pub base_id: DefId,\n-    pub deriv_id: DefId\n-}\n-\n-impl Lower for data::InheritanceData {\n-    type Target = InheritanceData;\n-\n-    fn lower(self, tcx: TyCtxt) -> InheritanceData {\n-        InheritanceData {\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            base_id: self.base_id,\n-            deriv_id: make_def_id(self.deriv_id, &tcx.hir)\n-        }\n-    }\n-}\n-\n-/// Data about a macro declaration.\n-#[derive(Debug)]\n-pub struct MacroData {\n-    pub span: SpanData,\n-    pub name: String,\n-    pub qualname: String,\n-    pub docs: String,\n-}\n-\n-impl Lower for data::MacroData {\n-    type Target = MacroData;\n-\n-    fn lower(self, tcx: TyCtxt) -> MacroData {\n-        MacroData {\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            name: self.name,\n-            qualname: self.qualname,\n-            docs: self.docs,\n-        }\n-    }\n-}\n-\n-/// Data about a macro use.\n-#[derive(Debug)]\n-pub struct MacroUseData {\n-    pub span: SpanData,\n-    pub name: String,\n-    pub qualname: String,\n-    // Because macro expansion happens before ref-ids are determined,\n-    // we use the callee span to reference the associated macro definition.\n-    pub callee_span: SpanData,\n-    pub scope: DefId,\n-}\n-\n-impl Lower for data::MacroUseData {\n-    type Target = MacroUseData;\n-\n-    fn lower(self, tcx: TyCtxt) -> MacroUseData {\n-        MacroUseData {\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            name: self.name,\n-            qualname: self.qualname,\n-            callee_span: span_from_span(self.callee_span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.hir),\n-        }\n-    }\n-}\n-\n-/// Data about a method call.\n-#[derive(Debug)]\n-pub struct MethodCallData {\n-    pub span: SpanData,\n-    pub scope: DefId,\n-    pub ref_id: Option<DefId>,\n-    pub decl_id: Option<DefId>,\n-}\n-\n-impl Lower for data::MethodCallData {\n-    type Target = MethodCallData;\n-\n-    fn lower(self, tcx: TyCtxt) -> MethodCallData {\n-        MethodCallData {\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            ref_id: self.ref_id,\n-            decl_id: self.decl_id,\n-        }\n-    }\n-}\n-\n-/// Data for method declarations (methods with a body are treated as functions).\n-#[derive(Clone, Debug)]\n-pub struct MethodData {\n-    pub id: DefId,\n-    pub name: String,\n-    pub qualname: String,\n-    pub span: SpanData,\n-    pub scope: DefId,\n-    pub value: String,\n-    pub decl_id: Option<DefId>,\n-    pub visibility: Visibility,\n-    pub parent: Option<DefId>,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-impl Lower for data::MethodData {\n-    type Target = MethodData;\n-\n-    fn lower(self, tcx: TyCtxt) -> MethodData {\n-        MethodData {\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            name: self.name,\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            id: make_def_id(self.id, &tcx.hir),\n-            qualname: self.qualname,\n-            value: self.value,\n-            decl_id: self.decl_id,\n-            visibility: self.visibility,\n-            parent: self.parent,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes.lower(tcx),\n-        }\n-    }\n-}\n-\n-/// Data for modules.\n-#[derive(Debug)]\n-pub struct ModData {\n-    pub id: DefId,\n-    pub name: String,\n-    pub qualname: String,\n-    pub span: SpanData,\n-    pub scope: DefId,\n-    pub filename: String,\n-    pub items: Vec<DefId>,\n-    pub visibility: Visibility,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-impl Lower for data::ModData {\n-    type Target = ModData;\n-\n-    fn lower(self, tcx: TyCtxt) -> ModData {\n-        ModData {\n-            id: make_def_id(self.id, &tcx.hir),\n-            name: self.name,\n-            qualname: self.qualname,\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            filename: self.filename,\n-            items: self.items.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n-            visibility: self.visibility,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes.lower(tcx),\n-        }\n-    }\n-}\n-\n-/// Data for a reference to a module.\n-#[derive(Debug)]\n-pub struct ModRefData {\n-    pub span: SpanData,\n-    pub scope: DefId,\n-    pub ref_id: Option<DefId>,\n-    pub qualname: String\n-}\n-\n-impl Lower for data::ModRefData {\n-    type Target = ModRefData;\n-\n-    fn lower(self, tcx: TyCtxt) -> ModRefData {\n-        ModRefData {\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            ref_id: self.ref_id,\n-            qualname: self.qualname,\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct StructData {\n-    pub span: SpanData,\n-    pub name: String,\n-    pub id: DefId,\n-    pub ctor_id: DefId,\n-    pub qualname: String,\n-    pub scope: DefId,\n-    pub value: String,\n-    pub fields: Vec<DefId>,\n-    pub visibility: Visibility,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-impl Lower for data::StructData {\n-    type Target = StructData;\n-\n-    fn lower(self, tcx: TyCtxt) -> StructData {\n-        StructData {\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            name: self.name,\n-            id: make_def_id(self.id, &tcx.hir),\n-            ctor_id: make_def_id(self.ctor_id, &tcx.hir),\n-            qualname: self.qualname,\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            value: self.value,\n-            fields: self.fields.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n-            visibility: self.visibility,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes.lower(tcx),\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct StructVariantData {\n-    pub span: SpanData,\n-    pub name: String,\n-    pub id: DefId,\n-    pub qualname: String,\n-    pub type_value: String,\n-    pub value: String,\n-    pub scope: DefId,\n-    pub parent: Option<DefId>,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-impl Lower for data::StructVariantData {\n-    type Target = StructVariantData;\n-\n-    fn lower(self, tcx: TyCtxt) -> StructVariantData {\n-        StructVariantData {\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            name: self.name,\n-            id: make_def_id(self.id, &tcx.hir),\n-            qualname: self.qualname,\n-            type_value: self.type_value,\n-            value: self.value,\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            parent: self.parent,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes.lower(tcx),\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct TraitData {\n-    pub span: SpanData,\n-    pub name: String,\n-    pub id: DefId,\n-    pub qualname: String,\n-    pub scope: DefId,\n-    pub value: String,\n-    pub items: Vec<DefId>,\n-    pub visibility: Visibility,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-impl Lower for data::TraitData {\n-    type Target = TraitData;\n-\n-    fn lower(self, tcx: TyCtxt) -> TraitData {\n-        TraitData {\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            name: self.name,\n-            id: make_def_id(self.id, &tcx.hir),\n-            qualname: self.qualname,\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            value: self.value,\n-            items: self.items.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n-            visibility: self.visibility,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes.lower(tcx),\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct TupleVariantData {\n-    pub span: SpanData,\n-    pub id: DefId,\n-    pub name: String,\n-    pub qualname: String,\n-    pub type_value: String,\n-    pub value: String,\n-    pub scope: DefId,\n-    pub parent: Option<DefId>,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-impl Lower for data::TupleVariantData {\n-    type Target = TupleVariantData;\n-\n-    fn lower(self, tcx: TyCtxt) -> TupleVariantData {\n-        TupleVariantData {\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            id: make_def_id(self.id, &tcx.hir),\n-            name: self.name,\n-            qualname: self.qualname,\n-            type_value: self.type_value,\n-            value: self.value,\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            parent: self.parent,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes.lower(tcx),\n-        }\n-    }\n-}\n-\n-/// Data for a typedef.\n-#[derive(Debug)]\n-pub struct TypeDefData {\n-    pub id: DefId,\n-    pub name: String,\n-    pub span: SpanData,\n-    pub qualname: String,\n-    pub value: String,\n-    pub visibility: Visibility,\n-    pub parent: Option<DefId>,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-impl Lower for data::TypeDefData {\n-    type Target = TypeDefData;\n-\n-    fn lower(self, tcx: TyCtxt) -> TypeDefData {\n-        TypeDefData {\n-            id: make_def_id(self.id, &tcx.hir),\n-            name: self.name,\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            qualname: self.qualname,\n-            value: self.value,\n-            visibility: self.visibility,\n-            parent: self.parent,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes.lower(tcx),\n-        }\n-    }\n-}\n-\n-/// Data for a reference to a type or trait.\n-#[derive(Clone, Debug)]\n-pub struct TypeRefData {\n-    pub span: SpanData,\n-    pub scope: DefId,\n-    pub ref_id: Option<DefId>,\n-    pub qualname: String,\n-}\n-\n-impl Lower for data::TypeRefData {\n-    type Target = TypeRefData;\n-\n-    fn lower(self, tcx: TyCtxt) -> TypeRefData {\n-        TypeRefData {\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            ref_id: self.ref_id,\n-            qualname: self.qualname,\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct UseData {\n-    pub id: DefId,\n-    pub span: SpanData,\n-    pub name: String,\n-    pub mod_id: Option<DefId>,\n-    pub scope: DefId,\n-    pub visibility: Visibility,\n-}\n-\n-impl Lower for data::UseData {\n-    type Target = UseData;\n-\n-    fn lower(self, tcx: TyCtxt) -> UseData {\n-        UseData {\n-            id: make_def_id(self.id, &tcx.hir),\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            name: self.name,\n-            mod_id: self.mod_id,\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            visibility: self.visibility,\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct UseGlobData {\n-    pub id: DefId,\n-    pub span: SpanData,\n-    pub names: Vec<String>,\n-    pub scope: DefId,\n-    pub visibility: Visibility,\n-}\n-\n-impl Lower for data::UseGlobData {\n-    type Target = UseGlobData;\n-\n-    fn lower(self, tcx: TyCtxt) -> UseGlobData {\n-        UseGlobData {\n-            id: make_def_id(self.id, &tcx.hir),\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            names: self.names,\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            visibility: self.visibility,\n-        }\n-    }\n-}\n-\n-/// Data for local and global variables (consts and statics).\n-#[derive(Debug)]\n-pub struct VariableData {\n-    pub id: DefId,\n-    pub name: String,\n-    pub kind: data::VariableKind,\n-    pub qualname: String,\n-    pub span: SpanData,\n-    pub scope: DefId,\n-    pub value: String,\n-    pub type_value: String,\n-    pub parent: Option<DefId>,\n-    pub visibility: Visibility,\n-    pub docs: String,\n-    pub sig: Option<Signature>,\n-    pub attributes: Vec<Attribute>,\n-}\n-\n-impl Lower for data::VariableData {\n-    type Target = VariableData;\n-\n-    fn lower(self, tcx: TyCtxt) -> VariableData {\n-        VariableData {\n-            id: make_def_id(self.id, &tcx.hir),\n-            kind: self.kind,\n-            name: self.name,\n-            qualname: self.qualname,\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            value: self.value,\n-            type_value: self.type_value,\n-            parent: self.parent,\n-            visibility: self.visibility,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes.lower(tcx),\n-        }\n-    }\n-}\n-\n-/// Data for the use of some item (e.g., the use of a local variable, which\n-/// will refer to that variables declaration (by ref_id)).\n-#[derive(Debug)]\n-pub struct VariableRefData {\n-    pub name: String,\n-    pub span: SpanData,\n-    pub scope: DefId,\n-    pub ref_id: DefId,\n-}\n-\n-impl Lower for data::VariableRefData {\n-    type Target = VariableRefData;\n-\n-    fn lower(self, tcx: TyCtxt) -> VariableRefData {\n-        VariableRefData {\n-            name: self.name,\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.hir),\n-            ref_id: self.ref_id,\n-        }\n-    }\n-}"}, {"sha": "4b2301fd7f804dcf22f2042a994e5b5dea0df5de", "filename": "src/librustc_save_analysis/json_api_dumper.rs", "status": "modified", "additions": 11, "deletions": 297, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs?ref=08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e", "patch": "@@ -12,12 +12,9 @@ use std::io::Write;\n \n use rustc_serialize::json::as_json;\n \n-use external_data::*;\n-use data::{VariableKind, Visibility};\n-use dump::Dump;\n-use id_from_def_id;\n+use Dump;\n \n-use rls_data::{Analysis, Import, ImportKind, Def, DefKind, CratePreludeData, Format};\n+use rls_data::{Analysis, Import, Def, CratePreludeData, Format, Relation};\n \n \n // A dumper to dump a restricted set of JSON information, designed for use with\n@@ -47,306 +44,23 @@ impl<'b, W: Write> Drop for JsonApiDumper<'b, W> {\n     }\n }\n \n-macro_rules! impl_fn {\n-    ($fn_name: ident, $data_type: ident, $bucket: ident) => {\n-        fn $fn_name(&mut self, data: $data_type) {\n-            if let Some(datum) = data.into() {\n-                self.result.$bucket.push(datum);\n-            }\n-        }\n-    }\n-}\n-\n impl<'b, W: Write + 'b> Dump for JsonApiDumper<'b, W> {\n     fn crate_prelude(&mut self, data: CratePreludeData) {\n         self.result.prelude = Some(data)\n     }\n \n-    impl_fn!(use_data, UseData, imports);\n-    impl_fn!(use_glob, UseGlobData, imports);\n-\n-    impl_fn!(enum_data, EnumData, defs);\n-    impl_fn!(tuple_variant, TupleVariantData, defs);\n-    impl_fn!(struct_variant, StructVariantData, defs);\n-    impl_fn!(struct_data, StructData, defs);\n-    impl_fn!(trait_data, TraitData, defs);\n-    impl_fn!(function, FunctionData, defs);\n-    impl_fn!(method, MethodData, defs);\n-    impl_fn!(macro_data, MacroData, defs);\n-    impl_fn!(mod_data, ModData, defs);\n-    impl_fn!(typedef, TypeDefData, defs);\n-    impl_fn!(variable, VariableData, defs);\n-\n-    fn impl_data(&mut self, data: ImplData) {\n-        if data.self_ref.is_some() {\n-            self.result.relations.push(data.into());\n-        }\n-    }\n-    fn inheritance(&mut self, data: InheritanceData) {\n-        self.result.relations.push(data.into());\n+    fn dump_relation(&mut self, data: Relation) {\n+        self.result.relations.push(data);\n     }\n-}\n-\n-// FIXME methods. The defs have information about possible overriding and the\n-// refs have decl information (e.g., a trait method where we know the required\n-// method, but not the supplied method). In both cases, we are currently\n-// ignoring it.\n-\n-impl Into<Option<Import>> for UseData {\n-    fn into(self) -> Option<Import> {\n-        match self.visibility {\n-            Visibility::Public => Some(Import {\n-                kind: ImportKind::Use,\n-                ref_id: self.mod_id.map(|id| id_from_def_id(id)),\n-                span: self.span,\n-                name: self.name,\n-                value: String::new(),\n-            }),\n-            _ => None,\n+    fn import(&mut self, public: bool, import: Import) {\n+        if public {\n+            self.result.imports.push(import);\n         }\n     }\n-}\n-impl Into<Option<Import>> for UseGlobData {\n-    fn into(self) -> Option<Import> {\n-        match self.visibility {\n-            Visibility::Public => Some(Import {\n-                kind: ImportKind::GlobUse,\n-                ref_id: None,\n-                span: self.span,\n-                name: \"*\".to_owned(),\n-                value: self.names.join(\", \"),\n-            }),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-impl Into<Option<Def>> for EnumData {\n-    fn into(self) -> Option<Def> {\n-        match self.visibility {\n-            Visibility::Public => Some(Def {\n-                kind: DefKind::Enum,\n-                id: id_from_def_id(self.id),\n-                span: self.span,\n-                name: self.name,\n-                qualname: self.qualname,\n-                value: self.value,\n-                parent: None,\n-                children: self.variants.into_iter().map(|id| id_from_def_id(id)).collect(),\n-                decl_id: None,\n-                docs: self.docs,\n-                sig: self.sig,\n-                attributes: vec![],\n-            }),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-impl Into<Option<Def>> for TupleVariantData {\n-    fn into(self) -> Option<Def> {\n-        Some(Def {\n-            kind: DefKind::Tuple,\n-            id: id_from_def_id(self.id),\n-            span: self.span,\n-            name: self.name,\n-            qualname: self.qualname,\n-            value: self.value,\n-            parent: self.parent.map(|id| id_from_def_id(id)),\n-            children: vec![],\n-            decl_id: None,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: vec![],\n-        })\n-    }\n-}\n-impl Into<Option<Def>> for StructVariantData {\n-    fn into(self) -> Option<Def> {\n-        Some(Def {\n-            kind: DefKind::Struct,\n-            id: id_from_def_id(self.id),\n-            span: self.span,\n-            name: self.name,\n-            qualname: self.qualname,\n-            value: self.value,\n-            parent: self.parent.map(|id| id_from_def_id(id)),\n-            children: vec![],\n-            decl_id: None,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: vec![],\n-        })\n-    }\n-}\n-impl Into<Option<Def>> for StructData {\n-    fn into(self) -> Option<Def> {\n-        match self.visibility {\n-            Visibility::Public => Some(Def {\n-            kind: DefKind::Struct,\n-            id: id_from_def_id(self.id),\n-            span: self.span,\n-            name: self.name,\n-            qualname: self.qualname,\n-            value: self.value,\n-            parent: None,\n-            children: self.fields.into_iter().map(|id| id_from_def_id(id)).collect(),\n-            decl_id: None,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: vec![],\n-        }),\n-            _ => None,\n-        }\n-    }\n-}\n-impl Into<Option<Def>> for TraitData {\n-    fn into(self) -> Option<Def> {\n-        match self.visibility {\n-            Visibility::Public => Some(Def {\n-                kind: DefKind::Trait,\n-                id: id_from_def_id(self.id),\n-                span: self.span,\n-                name: self.name,\n-                qualname: self.qualname,\n-                value: self.value,\n-                children: self.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n-                parent: None,\n-                decl_id: None,\n-                docs: self.docs,\n-                sig: self.sig,\n-                attributes: vec![],\n-            }),\n-            _ => None,\n-        }\n-    }\n-}\n-impl Into<Option<Def>> for FunctionData {\n-    fn into(self) -> Option<Def> {\n-        match self.visibility {\n-            Visibility::Public => Some(Def {\n-                kind: DefKind::Function,\n-                id: id_from_def_id(self.id),\n-                span: self.span,\n-                name: self.name,\n-                qualname: self.qualname,\n-                value: self.value,\n-                children: vec![],\n-                parent: self.parent.map(|id| id_from_def_id(id)),\n-                decl_id: None,\n-                docs: self.docs,\n-                sig: self.sig,\n-                attributes: vec![],\n-            }),\n-            _ => None,\n-        }\n-    }\n-}\n-impl Into<Option<Def>> for MethodData {\n-    fn into(self) -> Option<Def> {\n-        match self.visibility {\n-            Visibility::Public => Some(Def {\n-                kind: DefKind::Method,\n-                id: id_from_def_id(self.id),\n-                span: self.span,\n-                name: self.name,\n-                qualname: self.qualname,\n-                value: self.value,\n-                children: vec![],\n-                parent: self.parent.map(|id| id_from_def_id(id)),\n-                decl_id: self.decl_id.map(|id| id_from_def_id(id)),\n-                docs: self.docs,\n-                sig: self.sig,\n-                attributes: vec![],\n-            }),\n-            _ => None,\n-        }\n-    }\n-}\n-impl Into<Option<Def>> for MacroData {\n-    fn into(self) -> Option<Def> {\n-        Some(Def {\n-            kind: DefKind::Macro,\n-            id: id_from_def_id(null_def_id()),\n-            span: self.span,\n-            name: self.name,\n-            qualname: self.qualname,\n-            value: String::new(),\n-            children: vec![],\n-            parent: None,\n-            decl_id: None,\n-            docs: self.docs,\n-            sig: None,\n-            attributes: vec![],\n-        })\n-    }\n-}\n-impl Into<Option<Def>> for ModData {\n-    fn into(self) -> Option<Def> {\n-        match self.visibility {\n-            Visibility::Public => Some(Def {\n-                kind: DefKind::Mod,\n-                id: id_from_def_id(self.id),\n-                span: self.span,\n-                name: self.name,\n-                qualname: self.qualname,\n-                value: self.filename,\n-                children: self.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n-                parent: None,\n-                decl_id: None,\n-                docs: self.docs,\n-                sig: self.sig.map(|s| s.into()),\n-                attributes: vec![],\n-            }),\n-            _ => None,\n-        }\n-    }\n-}\n-impl Into<Option<Def>> for TypeDefData {\n-    fn into(self) -> Option<Def> {\n-        match self.visibility {\n-            Visibility::Public => Some(Def {\n-                kind: DefKind::Type,\n-                id: id_from_def_id(self.id),\n-                span: self.span,\n-                name: self.name,\n-                qualname: self.qualname,\n-                value: self.value,\n-                children: vec![],\n-                parent: self.parent.map(|id| id_from_def_id(id)),\n-                decl_id: None,\n-                docs: String::new(),\n-                sig: self.sig.map(|s| s.into()),\n-                attributes: vec![],\n-            }),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-impl Into<Option<Def>> for VariableData {\n-    fn into(self) -> Option<Def> {\n-        match self.visibility {\n-            Visibility::Public => Some(Def {\n-                kind: match self.kind {\n-                    VariableKind::Static => DefKind::Static,\n-                    VariableKind::Const => DefKind::Const,\n-                    VariableKind::Local => { return None }\n-                    VariableKind::Field => DefKind::Field,\n-                },\n-                id: id_from_def_id(self.id),\n-                span: self.span,\n-                name: self.name,\n-                qualname: self.qualname,\n-                value: self.value,\n-                children: vec![],\n-                parent: self.parent.map(|id| id_from_def_id(id)),\n-                decl_id: None,\n-                docs: self.docs,\n-                sig: self.sig.map(|s| s.into()),\n-                attributes: vec![],\n-            }),\n-            _ => None,\n+    fn dump_def(&mut self, public: bool, mut data: Def) {\n+        if public {\n+            data.attributes = vec![];\n+            self.result.defs.push(data);\n         }\n     }\n }"}, {"sha": "9cd375e98558ad3e8005e832d519cf98f84f3ee5", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 21, "deletions": 380, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e", "patch": "@@ -12,14 +12,11 @@ use std::io::Write;\n \n use rustc_serialize::json::as_json;\n \n-use rls_data::{self, Id, Analysis, Import, ImportKind, Def, DefKind, Ref, RefKind, MacroRef,\n-               Relation, RelationKind, CratePreludeData};\n+use rls_data::{self, Analysis, Import, Def, DefKind, Ref, RefKind, MacroRef,\n+               Relation, CratePreludeData};\n use rls_span::{Column, Row};\n \n-use external_data::*;\n-use data::VariableKind;\n-use dump::Dump;\n-use id_from_def_id;\n+use Dump;\n \n pub struct JsonDumper<O: DumpOutput> {\n     result: Analysis,\n@@ -70,71 +67,35 @@ impl<O: DumpOutput> Drop for JsonDumper<O> {\n     }\n }\n \n-macro_rules! impl_fn {\n-    ($fn_name: ident, $data_type: ident, $bucket: ident) => {\n-        fn $fn_name(&mut self, data: $data_type) {\n-            self.result.$bucket.push(data.into());\n-        }\n-    }\n-}\n-\n impl<'b, O: DumpOutput + 'b> Dump for JsonDumper<O> {\n     fn crate_prelude(&mut self, data: CratePreludeData) {\n         self.result.prelude = Some(data)\n     }\n \n-    impl_fn!(extern_crate, ExternCrateData, imports);\n-    impl_fn!(use_data, UseData, imports);\n-    impl_fn!(use_glob, UseGlobData, imports);\n-\n-    impl_fn!(enum_data, EnumData, defs);\n-    impl_fn!(tuple_variant, TupleVariantData, defs);\n-    impl_fn!(struct_variant, StructVariantData, defs);\n-    impl_fn!(struct_data, StructData, defs);\n-    impl_fn!(trait_data, TraitData, defs);\n-    impl_fn!(function, FunctionData, defs);\n-    impl_fn!(method, MethodData, defs);\n-    impl_fn!(macro_data, MacroData, defs);\n-    impl_fn!(typedef, TypeDefData, defs);\n-    impl_fn!(variable, VariableData, defs);\n-\n-    impl_fn!(function_ref, FunctionRefData, refs);\n-    impl_fn!(function_call, FunctionCallData, refs);\n-    impl_fn!(method_call, MethodCallData, refs);\n-    impl_fn!(mod_ref, ModRefData, refs);\n-    impl_fn!(type_ref, TypeRefData, refs);\n-    impl_fn!(variable_ref, VariableRefData, refs);\n+    fn macro_use(&mut self, data: MacroRef) {\n+        self.result.macro_refs.push(data);\n+    }\n \n-    impl_fn!(macro_use, MacroUseData, macro_refs);\n+    fn import(&mut self, _: bool, import: Import) {\n+        self.result.imports.push(import);\n+    }\n \n-    fn mod_data(&mut self, data: ModData) {\n-        let id: Id = id_from_def_id(data.id);\n-        let mut def = Def {\n-            kind: DefKind::Mod,\n-            id: id,\n-            span: data.span.into(),\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.filename,\n-            parent: None,\n-            children: data.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n-            decl_id: None,\n-            docs: data.docs,\n-            sig: data.sig,\n-            attributes: data.attributes.into_iter().map(|a| a.into()).collect(),\n-        };\n-        if def.span.file_name.to_str().unwrap() != def.value {\n+    fn dump_ref(&mut self, data: Ref) {\n+        self.result.refs.push(data);\n+    }\n+    fn dump_def(&mut self, _: bool, mut data: Def) {\n+        if data.kind == DefKind::Mod && data.span.file_name.to_str().unwrap() != data.value {\n             // If the module is an out-of-line defintion, then we'll make the\n             // defintion the first character in the module's file and turn the\n             // the declaration into a reference to it.\n             let rf = Ref {\n                 kind: RefKind::Mod,\n-                span: def.span,\n-                ref_id: id,\n+                span: data.span,\n+                ref_id: data.id,\n             };\n             self.result.refs.push(rf);\n-            def.span = rls_data::SpanData {\n-                file_name: def.value.clone().into(),\n+            data.span = rls_data::SpanData {\n+                file_name: data.value.clone().into(),\n                 byte_start: 0,\n                 byte_end: 0,\n                 line_start: Row::new_one_indexed(1),\n@@ -143,330 +104,10 @@ impl<'b, O: DumpOutput + 'b> Dump for JsonDumper<O> {\n                 column_end: Column::new_one_indexed(1),\n             }\n         }\n-\n-        self.result.defs.push(def);\n-    }\n-\n-    fn impl_data(&mut self, data: ImplData) {\n-        if data.self_ref.is_some() {\n-            self.result.relations.push(data.into());\n-        }\n-    }\n-    fn inheritance(&mut self, data: InheritanceData) {\n-        self.result.relations.push(data.into());\n-    }\n-}\n-\n-// FIXME do we want to change ExternalData to this mode? It will break DXR.\n-// FIXME methods. The defs have information about possible overriding and the\n-// refs have decl information (e.g., a trait method where we know the required\n-// method, but not the supplied method). In both cases, we are currently\n-// ignoring it.\n-\n-impl Into<Import> for ExternCrateData {\n-    fn into(self) -> Import {\n-        Import {\n-            kind: ImportKind::ExternCrate,\n-            ref_id: None,\n-            span: self.span,\n-            name: self.name,\n-            value: String::new(),\n-        }\n-    }\n-}\n-impl Into<Import> for UseData {\n-    fn into(self) -> Import {\n-        Import {\n-            kind: ImportKind::Use,\n-            ref_id: self.mod_id.map(|id| id_from_def_id(id)),\n-            span: self.span,\n-            name: self.name,\n-            value: String::new(),\n-        }\n-    }\n-}\n-impl Into<Import> for UseGlobData {\n-    fn into(self) -> Import {\n-        Import {\n-            kind: ImportKind::GlobUse,\n-            ref_id: None,\n-            span: self.span,\n-            name: \"*\".to_owned(),\n-            value: self.names.join(\", \"),\n-        }\n-    }\n-}\n-\n-impl Into<Def> for EnumData {\n-    fn into(self) -> Def {\n-        Def {\n-            kind: DefKind::Enum,\n-            id: id_from_def_id(self.id),\n-            span: self.span,\n-            name: self.name,\n-            qualname: self.qualname,\n-            value: self.value,\n-            parent: None,\n-            children: self.variants.into_iter().map(|id| id_from_def_id(id)).collect(),\n-            decl_id: None,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes,\n-        }\n-    }\n-}\n-\n-impl Into<Def> for TupleVariantData {\n-    fn into(self) -> Def {\n-        Def {\n-            kind: DefKind::Tuple,\n-            id: id_from_def_id(self.id),\n-            span: self.span,\n-            name: self.name,\n-            qualname: self.qualname,\n-            value: self.value,\n-            parent: None,\n-            children: vec![],\n-            decl_id: None,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes,\n-        }\n-    }\n-}\n-impl Into<Def> for StructVariantData {\n-    fn into(self) -> Def {\n-        Def {\n-            kind: DefKind::Struct,\n-            id: id_from_def_id(self.id),\n-            span: self.span,\n-            name: self.name,\n-            qualname: self.qualname,\n-            value: self.value,\n-            parent: None,\n-            children: vec![],\n-            decl_id: None,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes,\n-        }\n-    }\n-}\n-impl Into<Def> for StructData {\n-    fn into(self) -> Def {\n-        Def {\n-            kind: DefKind::Struct,\n-            id: id_from_def_id(self.id),\n-            span: self.span,\n-            name: self.name,\n-            qualname: self.qualname,\n-            value: self.value,\n-            parent: None,\n-            children: self.fields.into_iter().map(|id| id_from_def_id(id)).collect(),\n-            decl_id: None,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes,\n-        }\n-    }\n-}\n-impl Into<Def> for TraitData {\n-    fn into(self) -> Def {\n-        Def {\n-            kind: DefKind::Trait,\n-            id: id_from_def_id(self.id),\n-            span: self.span,\n-            name: self.name,\n-            qualname: self.qualname,\n-            value: self.value,\n-            parent: None,\n-            children: self.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n-            decl_id: None,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes,\n-        }\n-    }\n-}\n-impl Into<Def> for FunctionData {\n-    fn into(self) -> Def {\n-        Def {\n-            kind: DefKind::Function,\n-            id: id_from_def_id(self.id),\n-            span: self.span,\n-            name: self.name,\n-            qualname: self.qualname,\n-            value: self.value,\n-            parent: None,\n-            children: vec![],\n-            decl_id: None,\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes,\n-        }\n-    }\n-}\n-impl Into<Def> for MethodData {\n-    fn into(self) -> Def {\n-        Def {\n-            kind: DefKind::Method,\n-            id: id_from_def_id(self.id),\n-            span: self.span,\n-            name: self.name,\n-            qualname: self.qualname,\n-            value: self.value,\n-            parent: None,\n-            children: vec![],\n-            decl_id: self.decl_id.map(|id| id_from_def_id(id)),\n-            docs: self.docs,\n-            sig: self.sig,\n-            attributes: self.attributes,\n-        }\n-    }\n-}\n-impl Into<Def> for MacroData {\n-    fn into(self) -> Def {\n-        Def {\n-            kind: DefKind::Macro,\n-            id: id_from_def_id(null_def_id()),\n-            span: self.span,\n-            name: self.name,\n-            qualname: self.qualname,\n-            value: String::new(),\n-            parent: None,\n-            children: vec![],\n-            decl_id: None,\n-            docs: self.docs,\n-            sig: None,\n-            attributes: vec![],\n-        }\n-    }\n-}\n-impl Into<Def> for TypeDefData {\n-    fn into(self) -> Def {\n-        Def {\n-            kind: DefKind::Type,\n-            id: id_from_def_id(self.id),\n-            span: self.span,\n-            name: self.name,\n-            qualname: self.qualname,\n-            value: self.value,\n-            parent: None,\n-            children: vec![],\n-            decl_id: None,\n-            docs: String::new(),\n-            sig: self.sig,\n-            attributes: self.attributes,\n-        }\n+        self.result.defs.push(data);\n     }\n-}\n-impl Into<Def> for VariableData {\n-    fn into(self) -> Def {\n-        Def {\n-            kind: match self.kind {\n-                VariableKind::Static => DefKind::Static,\n-                VariableKind::Const => DefKind::Const,\n-                VariableKind::Local => DefKind::Local,\n-                VariableKind::Field => DefKind::Field,\n-            },\n-            id: id_from_def_id(self.id),\n-            span: self.span,\n-            name: self.name,\n-            qualname: self.qualname,\n-            value: self.type_value,\n-            parent: None,\n-            children: vec![],\n-            decl_id: None,\n-            docs: self.docs,\n-            sig: None,\n-            attributes: self.attributes,\n-        }\n-    }\n-}\n \n-impl Into<Ref> for FunctionRefData {\n-    fn into(self) -> Ref {\n-        Ref {\n-            kind: RefKind::Function,\n-            span: self.span,\n-            ref_id: id_from_def_id(self.ref_id),\n-        }\n-    }\n-}\n-impl Into<Ref> for FunctionCallData {\n-    fn into(self) -> Ref {\n-        Ref {\n-            kind: RefKind::Function,\n-            span: self.span,\n-            ref_id: id_from_def_id(self.ref_id),\n-        }\n-    }\n-}\n-impl Into<Ref> for MethodCallData {\n-    fn into(self) -> Ref {\n-        Ref {\n-            kind: RefKind::Function,\n-            span: self.span,\n-            ref_id: id_from_def_id(self.ref_id.or(self.decl_id).unwrap_or(null_def_id())),\n-        }\n-    }\n-}\n-impl Into<Ref> for ModRefData {\n-    fn into(self) -> Ref {\n-        Ref {\n-            kind: RefKind::Mod,\n-            span: self.span,\n-            ref_id: id_from_def_id(self.ref_id.unwrap_or(null_def_id())),\n-        }\n-    }\n-}\n-impl Into<Ref> for TypeRefData {\n-    fn into(self) -> Ref {\n-        Ref {\n-            kind: RefKind::Type,\n-            span: self.span,\n-            ref_id: id_from_def_id(self.ref_id.unwrap_or(null_def_id())),\n-        }\n-    }\n-}\n-impl Into<Ref> for VariableRefData {\n-    fn into(self) -> Ref {\n-        Ref {\n-            kind: RefKind::Variable,\n-            span: self.span,\n-            ref_id: id_from_def_id(self.ref_id),\n-        }\n-    }\n-}\n-\n-impl Into<MacroRef> for MacroUseData {\n-    fn into(self) -> MacroRef {\n-        MacroRef {\n-            span: self.span,\n-            qualname: self.qualname,\n-            callee_span: self.callee_span.into(),\n-        }\n-    }\n-}\n-\n-impl Into<Relation> for ImplData {\n-    fn into(self) -> Relation {\n-        Relation {\n-            span: self.span,\n-            kind: RelationKind::Impl,\n-            from: id_from_def_id(self.self_ref.unwrap_or(null_def_id())),\n-            to: id_from_def_id(self.trait_ref.unwrap_or(null_def_id())),\n-        }\n-    }\n-}\n-\n-impl Into<Relation> for InheritanceData {\n-    fn into(self) -> Relation {\n-        Relation {\n-            span: self.span,\n-            kind: RelationKind::SuperTrait,\n-            from: id_from_def_id(self.base_id),\n-            to: id_from_def_id(self.deriv_id),\n-        }\n+    fn dump_relation(&mut self, data: Relation) {\n+        self.result.relations.push(data);\n     }\n }"}, {"sha": "4e9e72fe2496497628ad5a7fa07ff2a5f8670e48", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 334, "deletions": 301, "changes": 635, "blob_url": "https://github.com/rust-lang/rust/blob/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e", "patch": "@@ -35,20 +35,16 @@ extern crate rls_data;\n extern crate rls_span;\n \n \n-mod csv_dumper;\n mod json_api_dumper;\n mod json_dumper;\n-mod data;\n-mod dump;\n mod dump_visitor;\n-pub mod external_data;\n #[macro_use]\n-pub mod span_utils;\n+mod span_utils;\n mod sig;\n \n use rustc::hir;\n-use rustc::hir::def::Def;\n-use rustc::hir::map::Node;\n+use rustc::hir::def::Def as HirDef;\n+use rustc::hir::map::{Node, NodeItem};\n use rustc::hir::def_id::DefId;\n use rustc::session::config::CrateType::CrateTypeExecutable;\n use rustc::session::Session;\n@@ -62,33 +58,21 @@ use std::path::{Path, PathBuf};\n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n use syntax::parse::token;\n+use syntax::print::pprust;\n use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{ty_to_string, arg_to_string};\n use syntax::codemap::MacroAttribute;\n use syntax_pos::*;\n \n-pub use self::csv_dumper::CsvDumper;\n-pub use self::json_api_dumper::JsonApiDumper;\n-pub use self::json_dumper::JsonDumper;\n-pub use self::data::*;\n-pub use self::external_data::make_def_id;\n-pub use self::dump::Dump;\n-pub use self::dump_visitor::DumpVisitor;\n-use self::span_utils::SpanUtils;\n-\n-// FIXME this is legacy code and should be removed\n-pub mod recorder {\n-    pub use self::Row::*;\n-\n-    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-    pub enum Row {\n-        TypeRef,\n-        ModRef,\n-        VarRef,\n-        FnRef,\n-    }\n-}\n+pub use json_api_dumper::JsonApiDumper;\n+pub use json_dumper::JsonDumper;\n+use dump_visitor::DumpVisitor;\n+use span_utils::SpanUtils;\n+\n+use rls_data::{Ref, RefKind, SpanData, MacroRef, Def, DefKind, Relation, RelationKind,\n+               ExternalCrateData, Import, CratePreludeData};\n+\n \n pub struct SaveContext<'l, 'tcx: 'l> {\n     tcx: TyCtxt<'l, 'tcx, 'tcx>,\n@@ -97,13 +81,49 @@ pub struct SaveContext<'l, 'tcx: 'l> {\n     span_utils: SpanUtils<'tcx>,\n }\n \n+#[derive(Debug)]\n+pub enum Data {\n+    /// Data about a macro use.\n+    MacroUseData(MacroRef),\n+    RefData(Ref),\n+    DefData(Def),\n+    RelationData(Relation),\n+}\n+\n+pub trait Dump {\n+    fn crate_prelude(&mut self, _: CratePreludeData);\n+    fn macro_use(&mut self, _: MacroRef) {}\n+    fn import(&mut self, _: bool, _: Import);\n+    fn dump_ref(&mut self, _: Ref) {}\n+    fn dump_def(&mut self, _: bool, _: Def);\n+    fn dump_relation(&mut self, data: Relation);\n+}\n+\n macro_rules! option_try(\n     ($e:expr) => (match $e { Some(e) => e, None => return None })\n );\n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n+    fn span_from_span(&self, span: Span) -> SpanData {\n+        use rls_span::{Row, Column};\n+\n+        let cm = self.tcx.sess.codemap();\n+        let start = cm.lookup_char_pos(span.lo);\n+        let end = cm.lookup_char_pos(span.hi);\n+\n+        SpanData {\n+            file_name: start.file.name.clone().into(),\n+            byte_start: span.lo.0,\n+            byte_end: span.hi.0,\n+            line_start: Row::new_one_indexed(start.line as u32),\n+            line_end: Row::new_one_indexed(end.line as u32),\n+            column_start: Column::new_one_indexed(start.col.0 as u32 + 1),\n+            column_end: Column::new_one_indexed(end.col.0 as u32 + 1),\n+        }\n+    }\n+\n     // List external crates used by the current crate.\n-    pub fn get_external_crates(&self) -> Vec<CrateData> {\n+    pub fn get_external_crates(&self) -> Vec<ExternalCrateData> {\n         let mut result = Vec::new();\n \n         for n in self.tcx.sess.cstore.crates() {\n@@ -114,10 +134,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     continue;\n                 }\n             };\n-            result.push(CrateData {\n+            let lo_loc = self.span_utils.sess.codemap().lookup_char_pos(span.lo);\n+            result.push(ExternalCrateData {\n                 name: self.tcx.sess.cstore.crate_name(n).to_string(),\n-                number: n.as_u32(),\n-                span: span,\n+                num: n.as_u32(),\n+                file_name: SpanUtils::make_path_string(&lo_loc.file.name),\n             });\n         }\n \n@@ -130,39 +151,43 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n                 filter!(self.span_utils, sub_span, item.span, None);\n-                Some(Data::FunctionData(FunctionData {\n-                    id: item.id,\n+\n+                Some(Data::DefData(Def {\n+                    kind: DefKind::Function,\n+                    id: id_from_node_id(item.id, self),\n+                    span: self.span_from_span(sub_span.unwrap()),\n                     name: item.ident.to_string(),\n-                    qualname: qualname,\n-                    declaration: None,\n-                    span: sub_span.unwrap(),\n-                    scope: self.enclosing_scope(item.id),\n+                    qualname,\n                     value: make_signature(decl, generics),\n-                    visibility: From::from(&item.vis),\n                     parent: None,\n+                    children: vec![],\n+                    decl_id: None,\n                     docs: docs_for_attrs(&item.attrs),\n                     sig: sig::foreign_item_signature(item, self),\n-                    attributes: item.attrs.clone(),\n+                    attributes: lower_attributes(item.attrs.clone(), self),\n                 }))\n             }\n             ast::ForeignItemKind::Static(ref ty, m) => {\n                 let keyword = if m { keywords::Mut } else { keywords::Static };\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keyword);\n                 filter!(self.span_utils, sub_span, item.span, None);\n-                Some(Data::VariableData(VariableData {\n-                    id: item.id,\n-                    kind: VariableKind::Static,\n+\n+                let id = ::id_from_node_id(item.id, self);\n+                let span = self.span_from_span(sub_span.unwrap());\n+\n+                Some(Data::DefData(Def {\n+                    kind: DefKind::Static,\n+                    id,\n+                    span,\n                     name: item.ident.to_string(),\n-                    qualname: qualname,\n-                    span: sub_span.unwrap(),\n-                    scope: self.enclosing_scope(item.id),\n+                    qualname,\n+                    value: ty_to_string(ty),\n                     parent: None,\n-                    value: String::new(),\n-                    type_value: ty_to_string(ty),\n-                    visibility: From::from(&item.vis),\n+                    children: vec![],\n+                    decl_id: None,\n                     docs: docs_for_attrs(&item.attrs),\n                     sig: sig::foreign_item_signature(item, self),\n-                    attributes: item.attrs.clone(),\n+                    attributes: lower_attributes(item.attrs.clone(), self),\n                 }))\n             }\n         }\n@@ -174,70 +199,71 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n                 filter!(self.span_utils, sub_span, item.span, None);\n-\n-\n-                Some(Data::FunctionData(FunctionData {\n-                    id: item.id,\n+                Some(Data::DefData(Def {\n+                    kind: DefKind::Function,\n+                    id: id_from_node_id(item.id, self),\n+                    span: self.span_from_span(sub_span.unwrap()),\n                     name: item.ident.to_string(),\n-                    qualname: qualname,\n-                    declaration: None,\n-                    span: sub_span.unwrap(),\n-                    scope: self.enclosing_scope(item.id),\n+                    qualname,\n                     value: make_signature(decl, generics),\n-                    visibility: From::from(&item.vis),\n                     parent: None,\n+                    children: vec![],\n+                    decl_id: None,\n                     docs: docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: item.attrs.clone(),\n+                    attributes: lower_attributes(item.attrs.clone(), self),\n                 }))\n             }\n-            ast::ItemKind::Static(ref typ, mt, ref expr) => {\n+            ast::ItemKind::Static(ref typ, mt, _) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n-                // If the variable is immutable, save the initialising expression.\n-                let (value, keyword) = match mt {\n-                    ast::Mutability::Mutable => (String::from(\"<mutable>\"), keywords::Mut),\n-                    ast::Mutability::Immutable => {\n-                        (self.span_utils.snippet(expr.span), keywords::Static)\n-                    },\n+                let keyword = match mt {\n+                    ast::Mutability::Mutable => keywords::Mut,\n+                    ast::Mutability::Immutable => keywords::Static,\n                 };\n \n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keyword);\n                 filter!(self.span_utils, sub_span, item.span, None);\n-                Some(Data::VariableData(VariableData {\n-                    id: item.id,\n-                    kind: VariableKind::Static,\n+\n+                let id = id_from_node_id(item.id, self);\n+                let span = self.span_from_span(sub_span.unwrap());\n+\n+                Some(Data::DefData(Def {\n+                    kind: DefKind::Static,\n+                    id,\n+                    span,\n                     name: item.ident.to_string(),\n-                    qualname: qualname,\n-                    span: sub_span.unwrap(),\n-                    scope: self.enclosing_scope(item.id),\n+                    qualname,\n+                    value: ty_to_string(&typ),\n                     parent: None,\n-                    value: value,\n-                    type_value: ty_to_string(&typ),\n-                    visibility: From::from(&item.vis),\n+                    children: vec![],\n+                    decl_id: None,\n                     docs: docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: item.attrs.clone(),\n+                    attributes: lower_attributes(item.attrs.clone(), self),\n                 }))\n             }\n-            ast::ItemKind::Const(ref typ, ref expr) => {\n+            ast::ItemKind::Const(ref typ, _) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Const);\n                 filter!(self.span_utils, sub_span, item.span, None);\n-                Some(Data::VariableData(VariableData {\n-                    id: item.id,\n-                    kind: VariableKind::Const,\n+\n+                let id = id_from_node_id(item.id, self);\n+                let span = self.span_from_span(sub_span.unwrap());\n+\n+                Some(Data::DefData(Def {\n+                    kind: DefKind::Const,\n+                    id,\n+                    span,\n                     name: item.ident.to_string(),\n-                    qualname: qualname,\n-                    span: sub_span.unwrap(),\n-                    scope: self.enclosing_scope(item.id),\n+                    qualname,\n+                    value: ty_to_string(typ),\n                     parent: None,\n-                    value: self.span_utils.snippet(expr.span),\n-                    type_value: ty_to_string(&typ),\n-                    visibility: From::from(&item.vis),\n+                    children: vec![],\n+                    decl_id: None,\n                     docs: docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: item.attrs.clone(),\n+                    attributes: lower_attributes(item.attrs.clone(), self),\n                 }))\n             }\n             ast::ItemKind::Mod(ref m) => {\n@@ -249,18 +275,19 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Mod);\n                 filter!(self.span_utils, sub_span, item.span, None);\n \n-                Some(Data::ModData(ModData {\n-                    id: item.id,\n+                Some(Data::DefData(Def {\n+                    kind: DefKind::Mod,\n+                    id: id_from_node_id(item.id, self),\n                     name: item.ident.to_string(),\n-                    qualname: qualname,\n-                    span: sub_span.unwrap(),\n-                    scope: self.enclosing_scope(item.id),\n-                    filename: filename,\n-                    items: m.items.iter().map(|i| i.id).collect(),\n-                    visibility: From::from(&item.vis),\n+                    qualname,\n+                    span: self.span_from_span(sub_span.unwrap()),\n+                    value: filename,\n+                    parent: None,\n+                    children: m.items.iter().map(|i| id_from_node_id(i.id, self)).collect(),\n+                    decl_id: None,\n                     docs: docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: item.attrs.clone(),\n+                    attributes: lower_attributes(item.attrs.clone(), self),\n                 }))\n             }\n             ast::ItemKind::Enum(ref def, _) => {\n@@ -272,61 +299,47 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                       .map(|v| v.node.name.to_string())\n                                       .collect::<Vec<_>>()\n                                       .join(\", \");\n-                let val = format!(\"{}::{{{}}}\", name, variants_str);\n-                Some(Data::EnumData(EnumData {\n-                    id: item.id,\n-                    name: name,\n-                    value: val,\n-                    span: sub_span.unwrap(),\n-                    qualname: qualname,\n-                    scope: self.enclosing_scope(item.id),\n-                    variants: def.variants.iter().map(|v| v.node.data.id()).collect(),\n-                    visibility: From::from(&item.vis),\n+                let value = format!(\"{}::{{{}}}\", name, variants_str);\n+                Some(Data::DefData(Def {\n+                    kind: DefKind::Enum,\n+                    id: id_from_node_id(item.id, self),\n+                    span: self.span_from_span(sub_span.unwrap()),\n+                    name,\n+                    qualname,\n+                    value,\n+                    parent: None,\n+                    children: def.variants\n+                                 .iter()\n+                                 .map(|v| id_from_node_id(v.node.data.id(), self))\n+                                 .collect(),\n+                    decl_id: None,\n                     docs: docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: item.attrs.clone(),\n+                    attributes: lower_attributes(item.attrs.to_owned(), self),\n                 }))\n             }\n             ast::ItemKind::Impl(.., ref trait_ref, ref typ, _) => {\n-                let mut type_data = None;\n-                let sub_span;\n-\n-                let parent = self.enclosing_scope(item.id);\n-\n-                match typ.node {\n+                if let ast::TyKind::Path(None, ref path) = typ.node {\n                     // Common case impl for a struct or something basic.\n-                    ast::TyKind::Path(None, ref path) => {\n-                        if generated_code(path.span) {\n-                            return None;\n-                        }\n-                        sub_span = self.span_utils.sub_span_for_type_name(path.span);\n-                        type_data = self.lookup_ref_id(typ.id).map(|id| {\n-                            TypeRefData {\n-                                span: sub_span.unwrap(),\n-                                scope: parent,\n-                                ref_id: Some(id),\n-                                qualname: String::new() // FIXME: generate the real qualname\n-                            }\n-                        });\n-                    }\n-                    _ => {\n-                        // Less useful case, impl for a compound type.\n-                        let span = typ.span;\n-                        sub_span = self.span_utils.sub_span_for_type_name(span).or(Some(span));\n+                    if generated_code(path.span) {\n+                        return None;\n                     }\n+                    let sub_span = self.span_utils.sub_span_for_type_name(path.span);\n+                    filter!(self.span_utils, sub_span, typ.span, None);\n+\n+                    let type_data = self.lookup_ref_id(typ.id);\n+                    type_data.map(|type_data| Data::RelationData(Relation {\n+                        kind: RelationKind::Impl,\n+                        span: self.span_from_span(sub_span.unwrap()),\n+                        from: id_from_def_id(type_data),\n+                        to: trait_ref.as_ref()\n+                                     .and_then(|t| self.lookup_ref_id(t.ref_id))\n+                                     .map(id_from_def_id)\n+                                     .unwrap_or(null_id()),\n+                    }))\n+                } else {\n+                    None\n                 }\n-\n-                let trait_data = trait_ref.as_ref()\n-                                          .and_then(|tr| self.get_trait_ref_data(tr, parent));\n-\n-                filter!(self.span_utils, sub_span, typ.span, None);\n-                Some(Data::ImplData(ImplData2 {\n-                    id: item.id,\n-                    span: sub_span.unwrap(),\n-                    scope: parent,\n-                    trait_ref: trait_data,\n-                    self_ref: type_data,\n-                }))\n             }\n             _ => {\n                 // FIXME\n@@ -338,7 +351,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_field_data(&self,\n                           field: &ast::StructField,\n                           scope: NodeId)\n-                          -> Option<VariableData> {\n+                          -> Option<Def> {\n         if let Some(ident) = field.ident {\n             let name = ident.to_string();\n             let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n@@ -347,20 +360,23 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             let def_id = self.tcx.hir.local_def_id(field.id);\n             let typ = self.tcx.type_of(def_id).to_string();\n \n-            Some(VariableData {\n-                id: field.id,\n-                kind: VariableKind::Field,\n-                name: name,\n-                qualname: qualname,\n-                span: sub_span.unwrap(),\n-                scope: scope,\n-                parent: Some(make_def_id(scope, &self.tcx.hir)),\n-                value: \"\".to_owned(),\n-                type_value: typ,\n-                visibility: From::from(&field.vis),\n+\n+            let id = id_from_node_id(field.id, self);\n+            let span = self.span_from_span(sub_span.unwrap());\n+\n+            Some(Def {\n+                kind: DefKind::Field,\n+                id,\n+                span,\n+                name,\n+                qualname,\n+                value: typ,\n+                parent: Some(id_from_node_id(scope, self)),\n+                children: vec![],\n+                decl_id: None,\n                 docs: docs_for_attrs(&field.attrs),\n                 sig: sig::field_signature(field, self),\n-                attributes: field.attrs.clone(),\n+                attributes: lower_attributes(field.attrs.clone(), self),\n             })\n         } else {\n             None\n@@ -373,10 +389,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                            id: ast::NodeId,\n                            name: ast::Name,\n                            span: Span)\n-                           -> Option<FunctionData> {\n+                           -> Option<Def> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n-        let (qualname, parent_scope, decl_id, vis, docs, attributes) =\n+        let (qualname, parent_scope, decl_id, docs, attributes) =\n           match self.tcx.impl_of_method(self.tcx.hir.local_def_id(id)) {\n             Some(impl_id) => match self.tcx.hir.get_if_local(impl_id) {\n                 Some(Node::NodeItem(item)) => {\n@@ -385,19 +401,24 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             let mut result = String::from(\"<\");\n                             result.push_str(&self.tcx.hir.node_to_pretty_string(ty.id));\n \n-                            let trait_id = self.tcx.trait_id_of_impl(impl_id);\n+                            let mut trait_id = self.tcx.trait_id_of_impl(impl_id);\n                             let mut decl_id = None;\n                             if let Some(def_id) = trait_id {\n                                 result.push_str(\" as \");\n                                 result.push_str(&self.tcx.item_path_str(def_id));\n                                 self.tcx.associated_items(def_id)\n                                     .find(|item| item.name == name)\n                                     .map(|item| decl_id = Some(item.def_id));\n+                            } else {\n+                                if let Some(NodeItem(item)) = self.tcx.hir.find(id) {\n+                                    if let hir::ItemImpl(_, _, _, _, _, ref ty, _) = item.node {\n+                                        trait_id = self.lookup_ref_id(ty.id);\n+                                    }\n+                                }\n                             }\n                             result.push_str(\">\");\n \n                             (result, trait_id, decl_id,\n-                             From::from(&item.vis),\n                              docs_for_attrs(&item.attrs),\n                              item.attrs.to_vec())\n                         }\n@@ -423,7 +444,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         Some(Node::NodeItem(item)) => {\n                             (format!(\"::{}\", self.tcx.item_path_str(def_id)),\n                              Some(def_id), None,\n-                             From::from(&item.vis),\n                              docs_for_attrs(&item.attrs),\n                              item.attrs.to_vec())\n                         }\n@@ -451,39 +471,38 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let sub_span = self.span_utils.sub_span_after_keyword(span, keywords::Fn);\n         filter!(self.span_utils, sub_span, span, None);\n \n-        Some(FunctionData {\n-            id: id,\n+        Some(Def {\n+            kind: DefKind::Method,\n+            id: id_from_node_id(id, self),\n+            span: self.span_from_span(sub_span.unwrap()),\n             name: name.to_string(),\n-            qualname: qualname,\n-            declaration: decl_id,\n-            span: sub_span.unwrap(),\n-            scope: self.enclosing_scope(id),\n+            qualname,\n             // FIXME you get better data here by using the visitor.\n             value: String::new(),\n-            visibility: vis,\n-            parent: parent_scope,\n-            docs: docs,\n+            parent: parent_scope.map(|id| id_from_def_id(id)),\n+            children: vec![],\n+            decl_id: decl_id.map(|id| id_from_def_id(id)),\n+            docs,\n             sig: None,\n-            attributes: attributes,\n+            attributes: lower_attributes(attributes, self),\n         })\n     }\n \n     pub fn get_trait_ref_data(&self,\n-                              trait_ref: &ast::TraitRef,\n-                              parent: NodeId)\n-                              -> Option<TypeRefData> {\n+                              trait_ref: &ast::TraitRef)\n+                              -> Option<Ref> {\n         self.lookup_ref_id(trait_ref.ref_id).and_then(|def_id| {\n             let span = trait_ref.path.span;\n             if generated_code(span) {\n                 return None;\n             }\n             let sub_span = self.span_utils.sub_span_for_type_name(span).or(Some(span));\n             filter!(self.span_utils, sub_span, span, None);\n-            Some(TypeRefData {\n-                span: sub_span.unwrap(),\n-                scope: parent,\n-                ref_id: Some(def_id),\n-                qualname: String::new() // FIXME: generate the real qualname\n+            let span = self.span_from_span(sub_span.unwrap());\n+            Some(Ref {\n+                kind: RefKind::Type,\n+                span,\n+                ref_id: id_from_def_id(def_id),\n             })\n         })\n     }\n@@ -509,11 +528,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         let f = def.struct_variant().field_named(ident.node.name);\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n                         filter!(self.span_utils, sub_span, expr.span, None);\n-                        return Some(Data::VariableRefData(VariableRefData {\n-                            name: ident.node.to_string(),\n-                            span: sub_span.unwrap(),\n-                            scope: self.enclosing_scope(expr.id),\n-                            ref_id: f.did,\n+                        let span = self.span_from_span(sub_span.unwrap());\n+                        return Some(Data::RefData(Ref {\n+                            kind: RefKind::Variable,\n+                            span,\n+                            ref_id: id_from_def_id(f.did),\n                         }));\n                     }\n                     _ => {\n@@ -527,11 +546,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         filter!(self.span_utils, sub_span, path.span, None);\n-                        Some(Data::TypeRefData(TypeRefData {\n-                            span: sub_span.unwrap(),\n-                            scope: self.enclosing_scope(expr.id),\n-                            ref_id: Some(def.did),\n-                            qualname: String::new() // FIXME: generate the real qualname\n+                        let span = self.span_from_span(sub_span.unwrap());\n+                        Some(Data::RefData(Ref {\n+                            kind: RefKind::Type,\n+                            span,\n+                            ref_id: id_from_def_id(def.did),\n                         }))\n                     }\n                     _ => {\n@@ -550,16 +569,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 };\n                 let sub_span = self.span_utils.sub_span_for_meth_name(expr.span);\n                 filter!(self.span_utils, sub_span, expr.span, None);\n-                let parent = self.enclosing_scope(expr.id);\n-                Some(Data::MethodCallData(MethodCallData {\n-                    span: sub_span.unwrap(),\n-                    scope: parent,\n-                    ref_id: def_id,\n-                    decl_id: decl_id,\n+                let span = self.span_from_span(sub_span.unwrap());\n+                Some(Data::RefData(Ref {\n+                    kind: RefKind::Function,\n+                    span,\n+                    ref_id: def_id.or(decl_id).map(|id| id_from_def_id(id)).unwrap_or(null_id()),\n                 }))\n             }\n             ast::ExprKind::Path(_, ref path) => {\n-                self.get_path_data(expr.id, path)\n+                self.get_path_data(expr.id, path).map(|d| Data::RefData(d))\n             }\n             _ => {\n                 // FIXME\n@@ -568,7 +586,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_path_def(&self, id: NodeId) -> Def {\n+    pub fn get_path_def(&self, id: NodeId) -> HirDef {\n         match self.tcx.hir.get(id) {\n             Node::NodeTraitRef(tr) => tr.path.def,\n \n@@ -584,7 +602,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n \n             Node::NodeLocal(&hir::Pat { node: hir::PatKind::Binding(_, def_id, ..), .. }) => {\n-                Def::Local(def_id)\n+                HirDef::Local(def_id)\n             }\n \n             Node::NodeTy(ty) => {\n@@ -597,58 +615,58 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                 for item in self.tcx.associated_items(proj.trait_ref.def_id) {\n                                     if item.kind == ty::AssociatedKind::Type {\n                                         if item.name == proj.item_name(self.tcx) {\n-                                            return Def::AssociatedTy(item.def_id);\n+                                            return HirDef::AssociatedTy(item.def_id);\n                                         }\n                                     }\n                                 }\n                             }\n-                            Def::Err\n+                            HirDef::Err\n                         }\n                     }\n                 } else {\n-                    Def::Err\n+                    HirDef::Err\n                 }\n             }\n \n-            _ => Def::Err\n+            _ => HirDef::Err\n         }\n     }\n \n-    pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Data> {\n+    pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Ref> {\n         let def = self.get_path_def(id);\n         let sub_span = self.span_utils.span_for_last_ident(path.span);\n         filter!(self.span_utils, sub_span, path.span, None);\n         match def {\n-            Def::Upvar(..) |\n-            Def::Local(..) |\n-            Def::Static(..) |\n-            Def::Const(..) |\n-            Def::AssociatedConst(..) |\n-            Def::StructCtor(..) |\n-            Def::VariantCtor(..) => {\n-                Some(Data::VariableRefData(VariableRefData {\n-                    name: self.span_utils.snippet(sub_span.unwrap()),\n-                    span: sub_span.unwrap(),\n-                    scope: self.enclosing_scope(id),\n-                    ref_id: def.def_id(),\n-                }))\n+            HirDef::Upvar(..) |\n+            HirDef::Local(..) |\n+            HirDef::Static(..) |\n+            HirDef::Const(..) |\n+            HirDef::AssociatedConst(..) |\n+            HirDef::StructCtor(..) |\n+            HirDef::VariantCtor(..) => {\n+                let span = self.span_from_span(sub_span.unwrap());\n+                Some(Ref {\n+                    kind: RefKind::Variable,\n+                    span,\n+                    ref_id: id_from_def_id(def.def_id()),\n+                })\n             }\n-            Def::Struct(def_id) |\n-            Def::Variant(def_id, ..) |\n-            Def::Union(def_id) |\n-            Def::Enum(def_id) |\n-            Def::TyAlias(def_id) |\n-            Def::AssociatedTy(def_id) |\n-            Def::Trait(def_id) |\n-            Def::TyParam(def_id) => {\n-                Some(Data::TypeRefData(TypeRefData {\n-                    span: sub_span.unwrap(),\n-                    ref_id: Some(def_id),\n-                    scope: self.enclosing_scope(id),\n-                    qualname: String::new() // FIXME: generate the real qualname\n-                }))\n+            HirDef::Struct(def_id) |\n+            HirDef::Variant(def_id, ..) |\n+            HirDef::Union(def_id) |\n+            HirDef::Enum(def_id) |\n+            HirDef::TyAlias(def_id) |\n+            HirDef::AssociatedTy(def_id) |\n+            HirDef::Trait(def_id) |\n+            HirDef::TyParam(def_id) => {\n+                let span = self.span_from_span(sub_span.unwrap());\n+                Some(Ref {\n+                    kind: RefKind::Type,\n+                    span,\n+                    ref_id: id_from_def_id(def_id),\n+                })\n             }\n-            Def::Method(decl_id) => {\n+            HirDef::Method(decl_id) => {\n                 let sub_span = self.span_utils.sub_span_for_meth_name(path.span);\n                 filter!(self.span_utils, sub_span, path.span, None);\n                 let def_id = if decl_id.is_local() {\n@@ -659,67 +677,68 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 } else {\n                     None\n                 };\n-                Some(Data::MethodCallData(MethodCallData {\n-                    span: sub_span.unwrap(),\n-                    scope: self.enclosing_scope(id),\n-                    ref_id: def_id,\n-                    decl_id: Some(decl_id),\n-                }))\n+                let span = self.span_from_span(sub_span.unwrap());\n+                Some(Ref {\n+                    kind: RefKind::Function,\n+                    span,\n+                    ref_id: id_from_def_id(def_id.unwrap_or(decl_id)),\n+                })\n             }\n-            Def::Fn(def_id) => {\n-                Some(Data::FunctionCallData(FunctionCallData {\n-                    ref_id: def_id,\n-                    span: sub_span.unwrap(),\n-                    scope: self.enclosing_scope(id),\n-                }))\n+            HirDef::Fn(def_id) => {\n+                let span = self.span_from_span(sub_span.unwrap());\n+                Some(Ref {\n+                    kind: RefKind::Function,\n+                    span,\n+                    ref_id: id_from_def_id(def_id),\n+                })\n             }\n-            Def::Mod(def_id) => {\n-                Some(Data::ModRefData(ModRefData {\n-                    ref_id: Some(def_id),\n-                    span: sub_span.unwrap(),\n-                    scope: self.enclosing_scope(id),\n-                    qualname: String::new() // FIXME: generate the real qualname\n-                }))\n+            HirDef::Mod(def_id) => {\n+                let span = self.span_from_span(sub_span.unwrap());\n+                Some(Ref {\n+                    kind: RefKind::Mod,\n+                    span,\n+                    ref_id: id_from_def_id(def_id),\n+                })\n             }\n-            Def::PrimTy(..) |\n-            Def::SelfTy(..) |\n-            Def::Label(..) |\n-            Def::Macro(..) |\n-            Def::GlobalAsm(..) |\n-            Def::Err => None,\n+            HirDef::PrimTy(..) |\n+            HirDef::SelfTy(..) |\n+            HirDef::Label(..) |\n+            HirDef::Macro(..) |\n+            HirDef::GlobalAsm(..) |\n+            HirDef::Err => None,\n         }\n     }\n \n     pub fn get_field_ref_data(&self,\n                               field_ref: &ast::Field,\n-                              variant: &ty::VariantDef,\n-                              parent: NodeId)\n-                              -> Option<VariableRefData> {\n+                              variant: &ty::VariantDef)\n+                              -> Option<Ref> {\n         let f = variant.field_named(field_ref.ident.node.name);\n         // We don't really need a sub-span here, but no harm done\n         let sub_span = self.span_utils.span_for_last_ident(field_ref.ident.span);\n         filter!(self.span_utils, sub_span, field_ref.ident.span, None);\n-        Some(VariableRefData {\n-            name: field_ref.ident.node.to_string(),\n-            span: sub_span.unwrap(),\n-            scope: parent,\n-            ref_id: f.did,\n+        let span = self.span_from_span(sub_span.unwrap());\n+        Some(Ref {\n+            kind: RefKind::Variable,\n+            span,\n+            ref_id: id_from_def_id(f.did),\n         })\n     }\n \n-    /// Attempt to return MacroUseData for any AST node.\n+    /// Attempt to return MacroRef for any AST node.\n     ///\n     /// For a given piece of AST defined by the supplied Span and NodeId,\n     /// returns None if the node is not macro-generated or the span is malformed,\n-    /// else uses the expansion callsite and callee to return some MacroUseData.\n-    pub fn get_macro_use_data(&self, span: Span, id: NodeId) -> Option<MacroUseData> {\n+    /// else uses the expansion callsite and callee to return some MacroRef.\n+    pub fn get_macro_use_data(&self, span: Span) -> Option<MacroRef> {\n         if !generated_code(span) {\n             return None;\n         }\n         // Note we take care to use the source callsite/callee, to handle\n         // nested expansions and ensure we only generate data for source-visible\n         // macro uses.\n         let callsite = span.source_callsite();\n+        let callsite_span = self.span_from_span(callsite);\n         let callee = option_try!(span.source_callee());\n         let callee_span = option_try!(callee.span);\n \n@@ -733,34 +752,25 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         // when read in, and no longer correspond to the source.\n         if let Some(mac) = self.tcx.sess.imported_macro_spans.borrow().get(&callee_span) {\n             let &(ref mac_name, mac_span) = mac;\n-            return Some(MacroUseData {\n-                                        span: callsite,\n-                                        name: mac_name.clone(),\n-                                        callee_span: mac_span,\n-                                        scope: self.enclosing_scope(id),\n-                                        imported: true,\n-                                        qualname: String::new()// FIXME: generate the real qualname\n-                                    });\n+            let mac_span = self.span_from_span(mac_span);\n+            return Some(MacroRef {\n+                span: callsite_span,\n+                qualname: mac_name.clone(), // FIXME: generate the real qualname\n+                callee_span: mac_span,\n+            });\n         }\n \n-        Some(MacroUseData {\n-            span: callsite,\n-            name: callee.name().to_string(),\n-            callee_span: callee_span,\n-            scope: self.enclosing_scope(id),\n-            imported: false,\n-            qualname: String::new() // FIXME: generate the real qualname\n+        let callee_span = self.span_from_span(callee_span);\n+        Some(MacroRef {\n+            span: callsite_span,\n+            qualname: callee.name().to_string(), // FIXME: generate the real qualname\n+            callee_span,\n         })\n     }\n \n-    pub fn get_data_for_id(&self, _id: &NodeId) -> Data {\n-        // FIXME\n-        bug!();\n-    }\n-\n     fn lookup_ref_id(&self, ref_id: NodeId) -> Option<DefId> {\n         match self.get_path_def(ref_id) {\n-            Def::PrimTy(_) | Def::SelfTy(..) | Def::Err => None,\n+            HirDef::PrimTy(_) | HirDef::SelfTy(..) | HirDef::Err => None,\n             def => Some(def.def_id()),\n         }\n     }\n@@ -802,7 +812,7 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n // An AST visitor for collecting paths from patterns.\n struct PathCollector {\n     // The Row field identifies the kind of pattern.\n-    collected_paths: Vec<(NodeId, ast::Path, ast::Mutability, recorder::Row)>,\n+    collected_paths: Vec<(NodeId, ast::Path, ast::Mutability)>,\n }\n \n impl PathCollector {\n@@ -816,12 +826,12 @@ impl<'a> Visitor<'a> for PathCollector {\n         match p.node {\n             PatKind::Struct(ref path, ..) => {\n                 self.collected_paths.push((p.id, path.clone(),\n-                                           ast::Mutability::Mutable, recorder::TypeRef));\n+                                           ast::Mutability::Mutable));\n             }\n             PatKind::TupleStruct(ref path, ..) |\n             PatKind::Path(_, ref path) => {\n                 self.collected_paths.push((p.id, path.clone(),\n-                                           ast::Mutability::Mutable, recorder::VarRef));\n+                                           ast::Mutability::Mutable));\n             }\n             PatKind::Ident(bm, ref path1, _) => {\n                 debug!(\"PathCollector, visit ident in pat {}: {:?} {:?}\",\n@@ -837,7 +847,7 @@ impl<'a> Visitor<'a> for PathCollector {\n                 };\n                 // collect path for either visit_local or visit_arm\n                 let path = ast::Path::from_ident(path1.span, path1.node);\n-                self.collected_paths.push((p.id, path, immut, recorder::VarRef));\n+                self.collected_paths.push((p.id, path, immut));\n             }\n             _ => {}\n         }\n@@ -866,17 +876,13 @@ fn docs_for_attrs(attrs: &[Attribute]) -> String {\n \n #[derive(Clone, Copy, Debug, RustcEncodable)]\n pub enum Format {\n-    Csv,\n     Json,\n     JsonApi,\n }\n \n impl Format {\n     fn extension(&self) -> &'static str {\n-        match *self {\n-            Format::Csv => \".csv\",\n-            Format::Json | Format::JsonApi => \".json\",\n-        }\n+        \".json\"\n     }\n }\n \n@@ -959,7 +965,6 @@ impl<'a> SaveHandler for DumpHandler<'a> {\n         let output = &mut self.output_file(&save_ctxt.tcx.sess);\n \n         match self.format {\n-            Format::Csv => dump!(CsvDumper::new(output)),\n             Format::Json => dump!(JsonDumper::new(output)),\n             Format::JsonApi => dump!(JsonApiDumper::new(output)),\n         }\n@@ -1039,6 +1044,34 @@ fn id_from_def_id(id: DefId) -> rls_data::Id {\n }\n \n fn id_from_node_id(id: NodeId, scx: &SaveContext) -> rls_data::Id {\n-    let def_id = scx.tcx.hir.local_def_id(id);\n-    id_from_def_id(def_id)\n+    let def_id = scx.tcx.hir.opt_local_def_id(id);\n+    def_id.map(|id| id_from_def_id(id)).unwrap_or_else(null_id)\n+}\n+\n+fn null_id() -> rls_data::Id {\n+    rls_data::Id {\n+        krate: u32::max_value(),\n+        index: u32::max_value(),\n+    }\n+}\n+\n+fn lower_attributes(attrs: Vec<Attribute>, scx: &SaveContext) -> Vec<rls_data::Attribute> {\n+    attrs.into_iter()\n+    // Only retain real attributes. Doc comments are lowered separately.\n+    .filter(|attr| attr.path != \"doc\")\n+    .map(|mut attr| {\n+        // Remove the surrounding '#[..]' or '#![..]' of the pretty printed\n+        // attribute. First normalize all inner attribute (#![..]) to outer\n+        // ones (#[..]), then remove the two leading and the one trailing character.\n+        attr.style = ast::AttrStyle::Outer;\n+        let value = pprust::attribute_to_string(&attr);\n+        // This str slicing works correctly, because the leading and trailing characters\n+        // are in the ASCII range and thus exactly one byte each.\n+        let value = value[2..value.len()-1].to_string();\n+\n+        rls_data::Attribute {\n+            value: value,\n+            span: scx.span_from_span(attr.span),\n+        }\n+    }).collect()\n }"}, {"sha": "77cde33e9620575e5e8acafe755557a2a73e3386", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 38, "deletions": 91, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e", "patch": "@@ -20,7 +20,6 @@ use syntax::ast;\n use syntax::parse::lexer::{self, StringReader};\n use syntax::parse::token::{self, Token};\n use syntax::symbol::keywords;\n-use syntax::tokenstream::TokenTree;\n use syntax_pos::*;\n \n #[derive(Clone)]\n@@ -277,45 +276,6 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    /// `span` must be the span for an item such as a function or struct. This\n-    /// function returns the program text from the start of the span until the\n-    /// end of the 'signature' part, that is up to, but not including an opening\n-    /// brace or semicolon.\n-    pub fn signature_string_for_span(&self, span: Span) -> String {\n-        let mut toks = self.retokenise_span(span);\n-        toks.real_token();\n-        let mut toks = toks.parse_all_token_trees().unwrap().trees();\n-        let mut prev = toks.next().unwrap();\n-\n-        let first_span = prev.span();\n-        let mut angle_count = 0;\n-        for tok in toks {\n-            if let TokenTree::Token(_, ref tok) = prev {\n-                angle_count += match *tok {\n-                    token::Eof => { break; }\n-                    token::Lt => 1,\n-                    token::Gt => -1,\n-                    token::BinOp(token::Shl) => 2,\n-                    token::BinOp(token::Shr) => -2,\n-                    _ => 0,\n-                };\n-            }\n-            if angle_count > 0 {\n-                prev = tok;\n-                continue;\n-            }\n-            if let TokenTree::Token(_, token::Semi) = tok {\n-                return self.snippet(first_span.to(prev.span()));\n-            } else if let TokenTree::Delimited(_, ref d) = tok {\n-                if d.delim == token::Brace {\n-                    return self.snippet(first_span.to(prev.span()));\n-                }\n-            }\n-            prev = tok;\n-        }\n-        self.snippet(span)\n-    }\n-\n     pub fn sub_span_before_token(&self, span: Span, tok: Token) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         let mut prev = toks.real_token();\n@@ -385,57 +345,44 @@ impl<'a> SpanUtils<'a> {\n         self.spans_with_brackets(span, 1, number)\n     }\n \n-    pub fn report_span_err(&self, kind: &str, span: Span) {\n-        let loc = self.sess.codemap().lookup_char_pos(span.lo);\n-        info!(\"({}) Could not find sub_span in `{}` in {}, line {}\",\n-              kind,\n-              self.snippet(span),\n-              loc.file.name,\n-              loc.line);\n-        self.err_count.set(self.err_count.get() + 1);\n-        if self.err_count.get() > 1000 {\n-            bug!(\"span errors reached 1000, giving up\");\n-        }\n-    }\n-\n-    // Return the name for a macro definition (identifier after first `!`)\n-    pub fn span_for_macro_def_name(&self, span: Span) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        loop {\n-            let ts = toks.real_token();\n-            if ts.tok == token::Eof {\n-                return None;\n-            }\n-            if ts.tok == token::Not {\n-                let ts = toks.real_token();\n-                if ts.tok.is_ident() {\n-                    return Some(ts.sp);\n-                } else {\n-                    return None;\n-                }\n-            }\n-        }\n-    }\n-\n-    // Return the name for a macro use (identifier before first `!`).\n-    pub fn span_for_macro_use_name(&self, span:Span) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        let mut prev = toks.real_token();\n-        loop {\n-            if prev.tok == token::Eof {\n-                return None;\n-            }\n-            let ts = toks.real_token();\n-            if ts.tok == token::Not {\n-                if prev.tok.is_ident() {\n-                    return Some(prev.sp);\n-                } else {\n-                    return None;\n-                }\n-            }\n-            prev = ts;\n-        }\n-    }\n+    // // Return the name for a macro definition (identifier after first `!`)\n+    // pub fn span_for_macro_def_name(&self, span: Span) -> Option<Span> {\n+    //     let mut toks = self.retokenise_span(span);\n+    //     loop {\n+    //         let ts = toks.real_token();\n+    //         if ts.tok == token::Eof {\n+    //             return None;\n+    //         }\n+    //         if ts.tok == token::Not {\n+    //             let ts = toks.real_token();\n+    //             if ts.tok.is_ident() {\n+    //                 return Some(ts.sp);\n+    //             } else {\n+    //                 return None;\n+    //             }\n+    //         }\n+    //     }\n+    // }\n+\n+    // // Return the name for a macro use (identifier before first `!`).\n+    // pub fn span_for_macro_use_name(&self, span:Span) -> Option<Span> {\n+    //     let mut toks = self.retokenise_span(span);\n+    //     let mut prev = toks.real_token();\n+    //     loop {\n+    //         if prev.tok == token::Eof {\n+    //             return None;\n+    //         }\n+    //         let ts = toks.real_token();\n+    //         if ts.tok == token::Not {\n+    //             if prev.tok.is_ident() {\n+    //                 return Some(prev.sp);\n+    //             } else {\n+    //                 return None;\n+    //             }\n+    //         }\n+    //         prev = ts;\n+    //     }\n+    // }\n \n     /// Return true if the span is generated code, and\n     /// it is not a subspan of the root callsite."}, {"sha": "9ebc40d4013cd9b60db7802d8475bfa3439467fc", "filename": "src/test/run-make/save-analysis/Makefile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile?ref=08d920cd4d95cc3e3c6ee3dd1ad5c98a4c58639e", "patch": "@@ -3,6 +3,5 @@ all: code\n krate2: krate2.rs\n \t$(RUSTC) $<\n code: foo.rs krate2\n-\t$(RUSTC) foo.rs -Zsave-analysis-csv\n \t$(RUSTC) foo.rs -Zsave-analysis\n \t$(RUSTC) foo.rs -Zsave-analysis-api"}]}