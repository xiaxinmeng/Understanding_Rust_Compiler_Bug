{"sha": "9b61771ea80b476eb92bda6388fcf6f0f88e8567", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNjE3NzFlYTgwYjQ3NmViOTJiZGE2Mzg4ZmNmNmYwZjg4ZTg1Njc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-07-22T12:18:52Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-28T06:27:05Z"}, "message": "rustc_mir: conservatively deny non-noop drops in constant contexts.", "tree": {"sha": "5f727c1876d45c500443ee0691fd2290fa0010c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f727c1876d45c500443ee0691fd2290fa0010c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b61771ea80b476eb92bda6388fcf6f0f88e8567", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b61771ea80b476eb92bda6388fcf6f0f88e8567", "html_url": "https://github.com/rust-lang/rust/commit/9b61771ea80b476eb92bda6388fcf6f0f88e8567", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b61771ea80b476eb92bda6388fcf6f0f88e8567/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8c05fe90bc132f707107e6926c991437015d34f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c05fe90bc132f707107e6926c991437015d34f", "html_url": "https://github.com/rust-lang/rust/commit/b8c05fe90bc132f707107e6926c991437015d34f"}], "stats": {"total": 89, "additions": 83, "deletions": 6}, "files": [{"sha": "05ba517e2638ab5db611f2dfcf4623edd602c708", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9b61771ea80b476eb92bda6388fcf6f0f88e8567/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b61771ea80b476eb92bda6388fcf6f0f88e8567/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=9b61771ea80b476eb92bda6388fcf6f0f88e8567", "patch": "@@ -120,6 +120,7 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     return_qualif: Option<Qualif>,\n     qualif: Qualif,\n     const_fn_arg_vars: BitVector,\n+    local_needs_drop: IndexVec<Local, Option<Span>>,\n     temp_promotion_state: IndexVec<Local, TempState>,\n     promotion_candidates: Vec<Candidate>\n }\n@@ -146,6 +147,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             return_qualif: None,\n             qualif: Qualif::empty(),\n             const_fn_arg_vars: BitVector::new(mir.local_decls.len()),\n+            local_needs_drop: IndexVec::from_elem(None, &mir.local_decls),\n             temp_promotion_state: temps,\n             promotion_candidates: vec![]\n         }\n@@ -193,16 +195,26 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         self.add(original);\n     }\n \n+    /// Check for NEEDS_DROP (from an ADT or const fn call) and\n+    /// error, unless we're in a function.\n+    fn always_deny_drop(&self) {\n+        self.deny_drop_with_feature_gate_override(false);\n+    }\n+\n     /// Check for NEEDS_DROP (from an ADT or const fn call) and\n     /// error, unless we're in a function, or the feature-gate\n     /// for globals with destructors is enabled.\n     fn deny_drop(&self) {\n+        self.deny_drop_with_feature_gate_override(true);\n+    }\n+\n+    fn deny_drop_with_feature_gate_override(&self, allow_gate: bool) {\n         if self.mode == Mode::Fn || !self.qualif.intersects(Qualif::NEEDS_DROP) {\n             return;\n         }\n \n         // Static and const fn's allow destructors, but they're feature-gated.\n-        let msg = if self.mode != Mode::Const {\n+        let msg = if allow_gate && self.mode != Mode::Const {\n             // Feature-gate for globals with destructors is enabled.\n             if self.tcx.sess.features.borrow().drop_types_in_const {\n                 return;\n@@ -223,15 +235,16 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         let mut err =\n             struct_span_err!(self.tcx.sess, self.span, E0493, \"{}\", msg);\n \n-        if self.mode != Mode::Const {\n+        if allow_gate && self.mode != Mode::Const {\n             help!(&mut err,\n                   \"in Nightly builds, add `#![feature(drop_types_in_const)]` \\\n                    to the crate attributes to enable\");\n         } else {\n             self.find_drop_implementation_method_span()\n                 .map(|span| err.span_label(span, \"destructor defined here\"));\n \n-            err.span_label(self.span, \"constants cannot have destructors\");\n+            err.span_label(self.span,\n+                format!(\"{}s cannot have destructors\", self.mode));\n         }\n \n         err.emit();\n@@ -314,6 +327,15 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             return;\n         }\n \n+        // When initializing a local, record whether the *value* being\n+        // stored in it needs dropping, which it may not, even if its\n+        // type does, e.g. `None::<String>`.\n+        if let Lvalue::Local(local) = *dest {\n+            if qualif.intersects(Qualif::NEEDS_DROP) {\n+                self.local_needs_drop[local] = Some(self.span);\n+            }\n+        }\n+\n         match *dest {\n             Lvalue::Local(index) if self.mir.local_kind(index) == LocalKind::Temp => {\n                 debug!(\"store to temp {:?}\", index);\n@@ -360,7 +382,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n \n             let target = match mir[bb].terminator().kind {\n                 TerminatorKind::Goto { target } |\n-                // Drops are considered noops.\n                 TerminatorKind::Drop { target, .. } |\n                 TerminatorKind::Assert { target, .. } |\n                 TerminatorKind::Call { destination: Some((_, target)), .. } => {\n@@ -558,11 +579,16 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n         match *operand {\n-            Operand::Consume(_) => {\n+            Operand::Consume(ref lvalue) => {\n                 self.nest(|this| {\n                     this.super_operand(operand, location);\n                     this.try_consume();\n                 });\n+\n+                // Mark the consumed locals to indicate later drops are noops.\n+                if let Lvalue::Local(local) = *lvalue {\n+                    self.local_needs_drop[local] = None;\n+                }\n             }\n             Operand::Constant(ref constant) => {\n                 if let Literal::Item { def_id, substs } = constant.literal {\n@@ -864,6 +890,30 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n                 self.assign(dest, location);\n             }\n+        } else if let TerminatorKind::Drop { location: ref lvalue, .. } = *kind {\n+            self.super_terminator_kind(bb, kind, location);\n+\n+            // Deny *any* live drops anywhere other than functions.\n+            if self.mode != Mode::Fn {\n+                // HACK(eddyb) Emulate a bit of dataflow analysis,\n+                // conservatively, that drop elaboration will do.\n+                let needs_drop = if let Lvalue::Local(local) = *lvalue {\n+                    self.local_needs_drop[local]\n+                } else {\n+                    None\n+                };\n+\n+                if let Some(span) = needs_drop {\n+                    let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    self.add_type(ty);\n+\n+                    // Use the original assignment span to be more precise.\n+                    let old_span = self.span;\n+                    self.span = span;\n+                    self.always_deny_drop();\n+                    self.span = old_span;\n+                }\n+            }\n         } else {\n             // Qualify any operands inside other terminators.\n             self.super_terminator_kind(bb, kind, location);"}, {"sha": "c349aababd6c01e2448d2c759e15cf8b64eaa515", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b61771ea80b476eb92bda6388fcf6f0f88e8567/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b61771ea80b476eb92bda6388fcf6f0f88e8567/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=9b61771ea80b476eb92bda6388fcf6f0f88e8567", "patch": "@@ -86,8 +86,9 @@ static STATIC8: SafeStruct = SafeStruct{field1: SafeEnum::Variant1,\n // This example should fail because field1 in the base struct is not safe\n static STATIC9: SafeStruct = SafeStruct{field1: SafeEnum::Variant1,\n                                         ..SafeStruct{field1: SafeEnum::Variant3(WithDtor),\n+//~^ ERROR destructors in statics are an unstable feature\n+//~| ERROR statics are not allowed to have destructors\n                                                      field2: SafeEnum::Variant1}};\n-//~^^ ERROR destructors in statics are an unstable feature\n \n struct UnsafeStruct;\n "}, {"sha": "e5f10b65ceed7ef0d001130fa3ea54d01bb92428", "filename": "src/test/compile-fail/static-drop-scope.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9b61771ea80b476eb92bda6388fcf6f0f88e8567/src%2Ftest%2Fcompile-fail%2Fstatic-drop-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b61771ea80b476eb92bda6388fcf6f0f88e8567/src%2Ftest%2Fcompile-fail%2Fstatic-drop-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-drop-scope.rs?ref=9b61771ea80b476eb92bda6388fcf6f0f88e8567", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(drop_types_in_const)]\n+\n+struct WithDtor;\n+\n+impl Drop for WithDtor {\n+    fn drop(&mut self) {}\n+}\n+\n+static FOO: Option<&'static WithDtor> = Some(&WithDtor);\n+//~^ ERROR statics are not allowed to have destructors\n+//~| ERROR borrowed value does not live long enoug\n+\n+static BAR: i32 = (WithDtor, 0).1;\n+//~^ ERROR statics are not allowed to have destructors\n+\n+fn main () {}"}]}