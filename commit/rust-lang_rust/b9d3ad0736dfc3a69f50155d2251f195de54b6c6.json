{"sha": "b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ZDNhZDA3MzZkZmMzYTY5ZjUwMTU1ZDIyNTFmMTk1ZGU1NGI2YzY=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-26T07:39:18Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-26T07:39:18Z"}, "message": "Getting rid of lots more vector +=. (issue #2719)", "tree": {"sha": "20dc484a67399477c9e25a40a3995810276b1482", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20dc484a67399477c9e25a40a3995810276b1482"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "html_url": "https://github.com/rust-lang/rust/commit/b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "007b9d9acd8b04ad2e1984aeba79c2031dec0e45", "url": "https://api.github.com/repos/rust-lang/rust/commits/007b9d9acd8b04ad2e1984aeba79c2031dec0e45", "html_url": "https://github.com/rust-lang/rust/commit/007b9d9acd8b04ad2e1984aeba79c2031dec0e45"}], "stats": {"total": 509, "additions": 261, "deletions": 248}, "files": [{"sha": "5ffce95c3832b613ba9a8811a32f1fa73bd69247", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -218,7 +218,7 @@ impl extensions<A:copy> for dvec<A> {\n             }\n            };\n \n-           for ts.each { |t| v += [t]/~ };\n+           for ts.each { |t| vec::push(v, t) };\n            v\n         }\n     }"}, {"sha": "46ae0fdf34e289102438829407893c54c00c0f4c", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -31,7 +31,7 @@ export rsplit;\n export rsplitn;\n export shift;\n export pop;\n-export push;\n+export push, push_all;\n export grow;\n export grow_fn;\n export grow_set;"}, {"sha": "5ba498cb3f78bdd36a451d4b0ca2734ca4c996f9", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -229,9 +229,9 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n     }\n     alt i.node {\n       item_mod(_) | item_native_mod(_) {\n-        cx.path += [path_mod(i.ident)]/~;\n+        vec::push(cx.path, path_mod(i.ident));\n       }\n-      _ { cx.path += [path_name(i.ident)]/~; }\n+      _ { vec::push(cx.path, path_name(i.ident)); }\n     }\n     visit::visit_item(i, cx, v);\n     vec::pop(cx.path);"}, {"sha": "3068d61830ed1cc47e51fc701826f88c2c3b8bb2", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -298,13 +298,13 @@ fn split_class_items(cs: [@class_member]/~) -> ([ivar]/~, [@method]/~) {\n     for cs.each {|c|\n       alt c.node {\n         instance_var(i, t, cm, id, vis) {\n-          vs += [{ident: /* FIXME (#2543) */ copy i,\n-                  ty: t,\n-                  cm: cm,\n-                  id: id,\n-                  vis: vis}]/~;\n+          vec::push(vs, {ident: /* FIXME (#2543) */ copy i,\n+                         ty: t,\n+                         cm: cm,\n+                         id: id,\n+                         vis: vis});\n         }\n-        class_method(m) { ms += [m]/~; }\n+        class_method(m) { vec::push(ms, m); }\n       }\n     };\n     (vs, ms)"}, {"sha": "a84b6897556d4b88f4d6e225842195f70aba3930", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -74,7 +74,7 @@ fn mk_substr_filename(cm: codemap, sp: span) -> str\n }\n \n fn next_line(file: filemap, chpos: uint, byte_pos: uint) {\n-    file.lines += [{ch: chpos, byte: byte_pos + file.start_pos.byte}]/~;\n+    vec::push(file.lines, {ch: chpos, byte: byte_pos + file.start_pos.byte});\n }\n \n type lookup_fn = pure fn(file_pos) -> uint;\n@@ -185,7 +185,9 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n     let mut lines = []/~;\n-    for uint::range(lo.line - 1u, hi.line as uint) {|i| lines += [i]/~; };\n+    for uint::range(lo.line - 1u, hi.line as uint) {|i|\n+        vec::push(lines, i);\n+    };\n     ret @{file: lo.file, lines: lines};\n }\n "}, {"sha": "b6ab87ad1bcf19117843bce336391bad6e3c356a", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -44,7 +44,7 @@ fn consume_non_eol_whitespace(rdr: string_reader) {\n fn push_blank_line_comment(rdr: string_reader, &comments: [cmnt]/~) {\n     #debug(\">>> blank-line comment\");\n     let v: [str]/~ = []/~;\n-    comments += [{style: blank_line, lines: v, pos: rdr.chpos}]/~;\n+    vec::push(comments, {style: blank_line, lines: v, pos: rdr.chpos});\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n@@ -73,7 +73,7 @@ fn read_line_comments(rdr: string_reader, code_to_the_left: bool) -> cmnt {\n     while rdr.curr == '/' && nextch(rdr) == '/' {\n         let line = read_one_line_comment(rdr);\n         log(debug, line);\n-        lines += [line]/~;\n+        vec::push(lines, line);\n         consume_non_eol_whitespace(rdr);\n     }\n     #debug(\"<<< line comments\");\n@@ -98,7 +98,7 @@ fn trim_whitespace_prefix_and_push_line(&lines: [str]/~,\n         } else { s1 = \"\"; }\n     } else { s1 = s; }\n     log(debug, \"pushing line: \" + s1);\n-    lines += [s1]/~;\n+    vec::push(lines, s1);\n }\n \n fn read_block_comment(rdr: string_reader, code_to_the_left: bool) -> cmnt {\n@@ -156,11 +156,11 @@ fn consume_comment(rdr: string_reader, code_to_the_left: bool,\n                    &comments: [cmnt]/~) {\n     #debug(\">>> consume comment\");\n     if rdr.curr == '/' && nextch(rdr) == '/' {\n-        comments += [read_line_comments(rdr, code_to_the_left)]/~;\n+        vec::push(comments, read_line_comments(rdr, code_to_the_left));\n     } else if rdr.curr == '/' && nextch(rdr) == '*' {\n-        comments += [read_block_comment(rdr, code_to_the_left)]/~;\n+        vec::push(comments, read_block_comment(rdr, code_to_the_left));\n     } else if rdr.curr == '#' && nextch(rdr) == '!' {\n-        comments += [read_shebang_comment(rdr, code_to_the_left)]/~;\n+        vec::push(comments, read_shebang_comment(rdr, code_to_the_left));\n     } else { fail; }\n     #debug(\"<<< consume comment\");\n }"}, {"sha": "c6b31e520399bb6b7c72ec8d093510c67f18b581", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -277,7 +277,7 @@ class parser {\n         let mut constrs: [@constr_general<T>]/~ = []/~;\n         loop {\n             let constr = pser(self);\n-            constrs += [constr]/~;\n+            vec::push(constrs, constr);\n             if self.token == token::COMMA { self.bump(); }\n             else { ret constrs; }\n         };\n@@ -363,7 +363,7 @@ class parser {\n                 let mut ts = [self.parse_ty(false)]/~;\n                 while self.token == token::COMMA {\n                     self.bump();\n-                    ts += [self.parse_ty(false)]/~;\n+                    vec::push(ts, self.parse_ty(false));\n                 }\n                 let t = if vec::len(ts) == 1u { ts[0].node }\n                 else { ty_tup(ts) };\n@@ -591,10 +591,10 @@ class parser {\n                 && self.look_ahead(1u) == token::MOD_SEP;\n \n             if is_not_last {\n-                ids += [parse_ident(self)]/~;\n+                vec::push(ids, parse_ident(self));\n                 self.expect(token::MOD_SEP);\n             } else {\n-                ids += [parse_last_ident(self)]/~;\n+                vec::push(ids, parse_last_ident(self));\n                 break;\n             }\n         }\n@@ -718,7 +718,7 @@ class parser {\n             }\n             let mut es = [self.parse_expr()]/~;\n             while self.token == token::COMMA {\n-                self.bump(); es += [self.parse_expr()]/~;\n+                self.bump(); vec::push(es, self.parse_expr());\n             }\n             hi = self.span.hi;\n             self.expect(token::RPAREN);\n@@ -751,7 +751,7 @@ class parser {\n                         // record ends by an optional trailing comma\n                         break;\n                     }\n-                    fields += [self.parse_field(token::COLON)]/~;\n+                    vec::push(fields, self.parse_field(token::COLON));\n                 }\n                 hi = self.span.hi;\n                 self.expect(token::RBRACE);\n@@ -1393,7 +1393,7 @@ class parser {\n             if self.eat_keyword(\"if\") { guard = some(self.parse_expr()); }\n             if self.token == token::FAT_ARROW { self.bump(); }\n             let blk = self.parse_block();\n-            arms += [{pats: pats, guard: guard, body: blk}]/~;\n+            vec::push(arms, {pats: pats, guard: guard, body: blk});\n         }\n         let mut hi = self.span.hi;\n         self.bump();\n@@ -1438,7 +1438,7 @@ class parser {\n     fn parse_pats() -> [@pat]/~ {\n         let mut pats = []/~;\n         loop {\n-            pats += [self.parse_pat()]/~;\n+            vec::push(pats, self.parse_pat());\n             if self.token == token::BINOP(token::OR) { self.bump(); }\n             else { ret pats; }\n         };\n@@ -1499,7 +1499,7 @@ class parser {\n                                node: pat_ident(fieldpath, none),\n                                span: mk_sp(lo, hi)};\n                 }\n-                fields += [{ident: fieldname, pat: subpat}]/~;\n+                vec::push(fields, {ident: fieldname, pat: subpat});\n             }\n             hi = self.span.hi;\n             self.bump();\n@@ -1517,7 +1517,7 @@ class parser {\n                 let mut fields = [self.parse_pat()]/~;\n                 while self.token == token::COMMA {\n                     self.bump();\n-                    fields += [self.parse_pat()]/~;\n+                    vec::push(fields, self.parse_pat());\n                 }\n                 if vec::len(fields) == 1u { self.expect(token::COMMA); }\n                 hi = self.span.hi;\n@@ -1607,7 +1607,7 @@ class parser {\n         let lo = self.span.lo;\n         let mut locals = [self.parse_local(is_mutbl, true)]/~;\n         while self.eat(token::COMMA) {\n-            locals += [self.parse_local(is_mutbl, true)]/~;\n+            vec::push(locals, self.parse_local(is_mutbl, true));\n         }\n         ret @spanned(lo, self.last_span.hi, decl_local(locals));\n     }\n@@ -1769,13 +1769,13 @@ class parser {\n                                         but found '\"\n                                        + token_to_str(self.reader, t) + \"'\");\n                         }\n-                        stmts += [stmt]/~;\n+                        vec::push(stmts, stmt);\n                       }\n                     }\n                   }\n \n                   _ { // All other kinds of statements:\n-                    stmts += [stmt]/~;\n+                    vec::push(stmts, stmt);\n \n                     if classify::stmt_ends_with_semi(*stmt) {\n                         self.expect(token::SEMI);\n@@ -1964,7 +1964,7 @@ class parser {\n         let mut meths = []/~;\n         self.expect(token::LBRACE);\n         while !self.eat(token::RBRACE) {\n-            meths += [self.parse_method(public)]/~;\n+            vec::push(meths, self.parse_method(public));\n         }\n         (ident, item_impl(tps, rp, ifce, ty, meths), none)\n     }\n@@ -2099,7 +2099,7 @@ class parser {\n             self.expect(token::LBRACE);\n             let mut results = []/~;\n             while self.token != token::RBRACE {\n-                results += [self.parse_single_class_item(private)]/~;\n+                vec::push(results, self.parse_single_class_item(private));\n             }\n             self.bump();\n             ret members(results);\n@@ -2129,7 +2129,7 @@ class parser {\n             #debug[\"parse_mod_items: parse_item(attrs=%?)\", attrs];\n             let vis = self.parse_visibility(private);\n             alt self.parse_item(attrs, vis) {\n-              some(i) { items += [i]/~; }\n+              some(i) { vec::push(items, i); }\n               _ {\n                 self.fatal(\"expected item but found '\" +\n                            token_to_str(self.reader, self.token) + \"'\");\n@@ -2206,7 +2206,7 @@ class parser {\n         while self.token != token::RBRACE {\n             let attrs = initial_attrs + self.parse_outer_attributes();\n             initial_attrs = []/~;\n-            items += [self.parse_native_item(attrs)]/~;\n+            vec::push(items, self.parse_native_item(attrs));\n         }\n         ret {view_items: view_items,\n              items: items};\n@@ -2285,7 +2285,7 @@ class parser {\n                     seq_sep_trailing_disallowed(token::COMMA),\n                     {|p| p.parse_ty(false)});\n                 for arg_tys.each {|ty|\n-                    args += [{ty: ty, id: self.get_id()}]/~;\n+                    vec::push(args, {ty: ty, id: self.get_id()});\n                 }\n             } else if self.eat(token::EQ) {\n                 have_disr = true;\n@@ -2295,7 +2295,7 @@ class parser {\n             let vr = {name: ident, attrs: variant_attrs,\n                       args: args, id: self.get_id(),\n                       disr_expr: disr_expr, vis: vis};\n-            variants += [spanned(vlo, self.last_span.hi, vr)]/~;\n+            vec::push(variants, spanned(vlo, self.last_span.hi, vr));\n \n             if !self.eat(token::COMMA) { break; }\n         }\n@@ -2399,7 +2399,7 @@ class parser {\n             while self.token == token::MOD_SEP {\n                 self.bump();\n                 let id = self.parse_ident();\n-                path += [id]/~;\n+                vec::push(path, id);\n             }\n             let path = @{span: mk_sp(lo, self.span.hi), global: false,\n                          idents: path, rp: none, types: []/~};\n@@ -2416,7 +2416,7 @@ class parser {\n \n                   token::IDENT(i, _) {\n                     self.bump();\n-                    path += [self.get_str(i)]/~;\n+                    vec::push(path, self.get_str(i));\n                   }\n \n                   // foo::bar::{a,b,c}\n@@ -2459,7 +2459,7 @@ class parser {\n         let mut vp = [self.parse_view_path()]/~;\n         while self.token == token::COMMA {\n             self.bump();\n-            vp += [self.parse_view_path()]/~;\n+            vec::push(vp, self.parse_view_path());\n         }\n         ret vp;\n     }\n@@ -2494,7 +2494,7 @@ class parser {\n         let mut items = []/~;\n         while if only_imports { self.is_keyword(\"import\") }\n         else { self.is_view_item() } {\n-            items += [self.parse_view_item(attrs)]/~;\n+            vec::push(items, self.parse_view_item(attrs));\n             attrs = self.parse_outer_attributes();\n         }\n         {attrs_remaining: attrs, view_items: items}\n@@ -2583,7 +2583,7 @@ class parser {\n         let mut first_outer_attr = first_outer_attr;\n         while self.token != term {\n             let cdir = @self.parse_crate_directive(first_outer_attr);\n-            cdirs += [cdir]/~;\n+            vec::push(cdirs, cdir);\n             first_outer_attr = []/~;\n         }\n         ret cdirs;"}, {"sha": "0b7231565de130200c8d8b80d9653935dd399f66", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -305,14 +305,14 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n             if *attr::get_meta_item_name(meta) == \"name\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { name = some(v); }\n-                  none { cmh_items += [meta]/~; }\n+                  none { vec::push(cmh_items, meta); }\n                 }\n             } else if *attr::get_meta_item_name(meta) == \"vers\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { vers = some(v); }\n-                  none { cmh_items += [meta]/~; }\n+                  none { vec::push(cmh_items, meta); }\n                 }\n-            } else { cmh_items += [meta]/~; }\n+            } else { vec::push(cmh_items, meta); }\n         }\n         ret {name: name, vers: vers, cmh_items: cmh_items};\n     }\n@@ -591,18 +591,18 @@ fn link_binary(sess: session,\n     let cstore = sess.cstore;\n     for cstore::get_used_crate_files(cstore).each {|cratepath|\n         if str::ends_with(cratepath, \".rlib\") {\n-            cc_args += [cratepath]/~;\n+            vec::push(cc_args, cratepath);\n             cont;\n         }\n         let cratepath = cratepath;\n         let dir = path::dirname(cratepath);\n-        if dir != \"\" { cc_args += [\"-L\" + dir]/~; }\n+        if dir != \"\" { vec::push(cc_args, \"-L\" + dir); }\n         let libarg = unlib(sess.targ_cfg, path::basename(cratepath));\n-        cc_args += [\"-l\" + libarg]/~;\n+        vec::push(cc_args, \"-l\" + libarg);\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for ula.each {|arg| cc_args += [arg]/~; }\n+    for ula.each {|arg| vec::push(cc_args, arg); }\n \n     // # Native library linking\n \n@@ -613,63 +613,63 @@ fn link_binary(sess: session,\n     // forces to make sure that library can be found at runtime.\n \n     let addl_paths = sess.opts.addl_lib_search_paths;\n-    for addl_paths.each {|path| cc_args += [\"-L\" + path]/~; }\n+    for addl_paths.each {|path| vec::push(cc_args, \"-L\" + path); }\n \n     // The names of the native libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n-    for used_libs.each {|l| cc_args += [\"-l\" + l]/~; }\n+    for used_libs.each {|l| vec::push(cc_args, \"-l\" + l); }\n \n     if sess.building_library {\n-        cc_args += [lib_cmd]/~;\n+        vec::push(cc_args, lib_cmd);\n \n         // On mac we need to tell the linker to let this library\n         // be rpathed\n         if sess.targ_cfg.os == session::os_macos {\n-            cc_args += [\"-Wl,-install_name,@rpath/\"\n-                        + path::basename(output)]/~;\n+            vec::push(cc_args, \"-Wl,-install_name,@rpath/\"\n+                      + path::basename(output));\n         }\n     }\n \n     if !sess.debugging_opt(session::no_rt) {\n         // Always want the runtime linked in\n-        cc_args += [\"-lrustrt\"]/~;\n+        vec::push(cc_args, \"-lrustrt\");\n     }\n \n     // On linux librt and libdl are an indirect dependencies via rustrt,\n     // and binutils 2.22+ won't add them automatically\n     if sess.targ_cfg.os == session::os_linux {\n-        cc_args += [\"-lrt\", \"-ldl\"]/~;\n+        vec::push_all(cc_args, [\"-lrt\", \"-ldl\"]/~);\n \n         // LLVM implements the `frem` instruction as a call to `fmod`,\n         // which lives in libm. Similar to above, on some linuxes we\n         // have to be explicit about linking to it. See #2510\n-        cc_args += [\"-lm\"]/~;\n+        vec::push(cc_args, \"-lm\");\n     }\n \n     if sess.targ_cfg.os == session::os_freebsd {\n-        cc_args += [\"-pthread\", \"-lrt\",\n-                    \"-L/usr/local/lib\", \"-lexecinfo\",\n-                    \"-L/usr/local/lib/gcc46\",\n-                    \"-L/usr/local/lib/gcc44\", \"-lstdc++\",\n-                    \"-Wl,-z,origin\",\n-                    \"-Wl,-rpath,/usr/local/lib/gcc46\",\n-                    \"-Wl,-rpath,/usr/local/lib/gcc44\"]/~;\n+        vec::push_all(cc_args, [\"-pthread\", \"-lrt\",\n+                                \"-L/usr/local/lib\", \"-lexecinfo\",\n+                                \"-L/usr/local/lib/gcc46\",\n+                                \"-L/usr/local/lib/gcc44\", \"-lstdc++\",\n+                                \"-Wl,-z,origin\",\n+                                \"-Wl,-rpath,/usr/local/lib/gcc46\",\n+                                \"-Wl,-rpath,/usr/local/lib/gcc44\"]/~);\n     }\n \n     // OS X 10.6 introduced 'compact unwind info', which is produced by the\n     // linker from the dwarf unwind info. Unfortunately, it does not seem to\n     // understand how to unwind our __morestack frame, so we have to turn it\n     // off. This has impacted some other projects like GHC.\n     if sess.targ_cfg.os == session::os_macos {\n-        cc_args += [\"-Wl,-no_compact_unwind\"]/~;\n+        vec::push(cc_args, \"-Wl,-no_compact_unwind\");\n     }\n \n     // Stack growth requires statically linking a __morestack function\n-    cc_args += [\"-lmorestack\"]/~;\n+    vec::push(cc_args, \"-lmorestack\");\n \n     // FIXME (#2397): At some point we want to rpath our guesses as to where\n     // native libraries might live, based on the addl_lib_search_paths\n-    cc_args += rpath::get_rpath_flags(sess, output);\n+    vec::push_all(cc_args, rpath::get_rpath_flags(sess, output));\n \n     #debug(\"%s link args: %s\", cc_prog, str::connect(cc_args, \" \"));\n     // We run 'cc' here"}, {"sha": "1f9b2d427f831738cc8f0ba165081d1c8d5c6e8e", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -44,7 +44,7 @@ fn lookup_defs(cstore: cstore::cstore, cnum: ast::crate_num,\n     #debug(\"lookup_defs: path = %? cnum = %?\", path, cnum);\n     for resolve_path(cstore, cnum, path).each {|elt|\n         let (c, data, def) = elt;\n-        result += [decoder::lookup_def(c, data, def)]/~;\n+        vec::push(result, decoder::lookup_def(c, data, def));\n     }\n     ret result;\n }\n@@ -68,13 +68,13 @@ fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n     let mut result = []/~;\n     for decoder::resolve_path(path, cm.data).each {|def|\n         if def.crate == ast::local_crate {\n-            result += [(cnum, cm.data, def)]/~;\n+            vec::push(result, (cnum, cm.data, def));\n         } else {\n             if cm.cnum_map.contains_key(def.crate) {\n                 // This reexport is itself a reexport from another crate\n                 let next_cnum = cm.cnum_map.get(def.crate);\n                 let next_cm_data = cstore::get_crate_data(cstore, next_cnum);\n-                result += [(next_cnum, next_cm_data.data, def)]/~;\n+                vec::push(result, (next_cnum, next_cm_data.data, def));\n             }\n         }\n     }"}, {"sha": "b1eba8e3875ae92085b20850797e69dac2002976", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -113,7 +113,7 @@ fn iter_crate_data(cstore: cstore, i: fn(ast::crate_num, crate_metadata)) {\n \n fn add_used_crate_file(cstore: cstore, lib: str) {\n     if !vec::contains(p(cstore).used_crate_files, lib) {\n-        p(cstore).used_crate_files += [lib]/~;\n+        vec::push(p(cstore).used_crate_files, lib);\n     }\n }\n \n@@ -125,7 +125,7 @@ fn add_used_library(cstore: cstore, lib: str) -> bool {\n     assert lib != \"\";\n \n     if vec::contains(p(cstore).used_libraries, lib) { ret false; }\n-    p(cstore).used_libraries += [lib]/~;\n+    vec::push(p(cstore).used_libraries, lib);\n     ret true;\n }\n \n@@ -161,7 +161,7 @@ fn get_dep_hashes(cstore: cstore) -> [@str]/~ {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         #debug(\"Add hash[%s]: %s\", cdata.name, *hash);\n-        result += [{name: @cdata.name, hash: hash}]/~;\n+        vec::push(result, {name: @cdata.name, hash: hash});\n     };\n     fn lteq(a: crate_hash, b: crate_hash) -> bool {\n         ret *a.name <= *b.name;"}, {"sha": "a7f44ad2d461cd106eaa3771e8884baacc06e595", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -67,7 +67,7 @@ fn lookup_hash(d: ebml::doc, eq_fn: fn@([u8]/~) -> bool, hash: uint) ->\n     ebml::tagged_docs(bucket, belt) {|elt|\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n         if eq_fn(vec::slice::<u8>(*elt.data, elt.start + 4u, elt.end)) {\n-            result += [ebml::doc_at(d.data, pos).doc]/~;\n+            vec::push(result, ebml::doc_at(d.data, pos).doc);\n         }\n     };\n     ret result;\n@@ -170,7 +170,7 @@ fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n         let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, {|did|\n             translate_def_id(cdata, did)\n         });\n-        bounds += [bd]/~;\n+        vec::push(bounds, bd);\n     }\n     @bounds\n }\n@@ -199,7 +199,7 @@ fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> [ast::def_id]/~ {\n     let v = tag_items_data_item_variant;\n     ebml::tagged_docs(item, v) {|p|\n         let ext = parse_def_id(ebml::doc_data(p));\n-        ids += [{crate: cdata.cnum, node: ext.node}]/~;\n+        vec::push(ids, {crate: cdata.cnum, node: ext.node});\n     };\n     ret ids;\n }\n@@ -218,7 +218,7 @@ fn resolve_path(path: [ast::ident]/~, data: @[u8]/~) -> [ast::def_id]/~ {\n     #debug(\"resolve_path: looking up %s\", s);\n     for lookup_hash(paths, eqer, hash_path(s)).each {|doc|\n         let did_doc = ebml::get_doc(doc, tag_def_id);\n-        result += [parse_def_id(ebml::doc_data(did_doc))]/~;\n+        vec::push(result, parse_def_id(ebml::doc_data(did_doc)));\n     }\n     ret result;\n }\n@@ -235,10 +235,10 @@ fn item_path(item_doc: ebml::doc) -> ast_map::path {\n     ebml::docs(path_doc) {|tag, elt_doc|\n         if tag == tag_path_elt_mod {\n             let str = ebml::doc_as_str(elt_doc);\n-            result += [ast_map::path_mod(@str)]/~;\n+            vec::push(result, ast_map::path_mod(@str));\n         } else if tag == tag_path_elt_name {\n             let str = ebml::doc_as_str(elt_doc);\n-            result += [ast_map::path_name(@str)]/~;\n+            vec::push(result, ast_map::path_name(@str));\n         } else {\n             // ignore tag_path_len element\n         }\n@@ -407,16 +407,16 @@ fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n         let mut arg_tys: [ty::t]/~ = []/~;\n         alt ty::get(ctor_ty).struct {\n           ty::ty_fn(f) {\n-            for f.inputs.each {|a| arg_tys += [a.ty]/~; }\n+            for f.inputs.each {|a| vec::push(arg_tys, a.ty); }\n           }\n           _ { /* Nullary enum variant. */ }\n         }\n         alt variant_disr_val(item) {\n           some(val) { disr_val = val; }\n           _         { /* empty */ }\n         }\n-        infos += [@{args: arg_tys, ctor_ty: ctor_ty, name: name,\n-                    id: did, disr_val: disr_val}]/~;\n+        vec::push(infos, @{args: arg_tys, ctor_ty: ctor_ty, name: name,\n+                           id: did, disr_val: disr_val});\n         disr_val += 1;\n     }\n     ret infos;\n@@ -432,10 +432,10 @@ fn item_impl_methods(cdata: cmd, item: ebml::doc, base_tps: uint)\n     ebml::tagged_docs(item, tag_item_impl_method) {|doc|\n         let m_did = parse_def_id(ebml::doc_data(doc));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n-        rslt += [@{did: translate_def_id(cdata, m_did),\n+        vec::push(rslt, @{did: translate_def_id(cdata, m_did),\n                     /* FIXME (maybe #2323) tjc: take a look at this. */\n                    n_tps: item_ty_param_count(mth_item) - base_tps,\n-                   ident: item_name(mth_item)}]/~;\n+                   ident: item_name(mth_item)});\n     }\n     rslt\n }\n@@ -458,10 +458,10 @@ fn get_impls_for_mod(cdata: cmd, m_id: ast::node_id,\n         let nm = item_name(item);\n         if alt name { some(n) { n == nm } none { true } } {\n            let base_tps = item_ty_param_count(item);\n-           result += [@{\n+           vec::push(result, @{\n                 did: local_did, ident: nm,\n                 methods: item_impl_methods(impl_cdata, item, base_tps)\n-            }]/~;\n+            });\n         };\n     }\n     @result\n@@ -482,12 +482,12 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n             tcx.diag.handler().bug(\n                 \"get_iface_methods: id has non-function type\");\n         } };\n-        result += [{ident: name, tps: bounds, fty: fty,\n+        vec::push(result, {ident: name, tps: bounds, fty: fty,\n                     purity: alt check item_family(mth) {\n                       'u' { ast::unsafe_fn }\n                       'f' { ast::impure_fn }\n                       'p' { ast::pure_fn }\n-                    }, vis: ast::public}]/~;\n+                    }, vis: ast::public});\n     }\n     @result\n }\n@@ -504,8 +504,8 @@ fn get_class_members(cdata: cmd, id: ast::node_id,\n           let name = item_name(an_item);\n           let did = class_member_id(an_item, cdata);\n           let mt = field_mutability(an_item);\n-          result += [{ident: name, id: did, vis:\n-                  family_to_visibility(f), mutability: mt}]/~;\n+          vec::push(result, {ident: name, id: did, vis:\n+                  family_to_visibility(f), mutability: mt});\n        }\n     }\n     result\n@@ -581,7 +581,7 @@ fn get_meta_items(md: ebml::doc) -> [@ast::meta_item]/~ {\n     ebml::tagged_docs(md, tag_meta_item_word) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n-        items += [attr::mk_word_item(@n)]/~;\n+        vec::push(items, attr::mk_word_item(@n));\n     };\n     ebml::tagged_docs(md, tag_meta_item_name_value) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n@@ -590,13 +590,13 @@ fn get_meta_items(md: ebml::doc) -> [@ast::meta_item]/~ {\n         let v = str::from_bytes(ebml::doc_data(vd));\n         // FIXME (#623): Should be able to decode meta_name_value variants,\n         // but currently the encoder just drops them\n-        items += [attr::mk_name_value_item_str(@n, v)]/~;\n+        vec::push(items, attr::mk_name_value_item_str(@n, v));\n     };\n     ebml::tagged_docs(md, tag_meta_item_list) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n-        items += [attr::mk_list_item(@n, subitems)]/~;\n+        vec::push(items, attr::mk_list_item(@n, subitems));\n     };\n     ret items;\n }\n@@ -653,10 +653,10 @@ fn get_crate_deps(data: @[u8]/~) -> [crate_dep]/~ {\n         str::from_bytes(ebml::doc_data(ebml::get_doc(doc, tag_)))\n     }\n     ebml::tagged_docs(depsdoc, tag_crate_dep) {|depdoc|\n-        deps += [{cnum: crate_num,\n+        vec::push(deps, {cnum: crate_num,\n                   name: @docstr(depdoc, tag_crate_dep_name),\n                   vers: @docstr(depdoc, tag_crate_dep_vers),\n-                  hash: @docstr(depdoc, tag_crate_dep_hash)}]/~;\n+                  hash: @docstr(depdoc, tag_crate_dep_hash)});\n         crate_num += 1;\n     };\n     ret deps;\n@@ -732,7 +732,7 @@ fn get_crate_module_paths(bytes: @[u8]/~) -> [(ast::def_id, str)]/~ {\n         // Collect everything by now. There might be multiple\n         // paths pointing to the same did. Those will be\n         // unified later by using the mods map\n-        res += [(did, path)]/~;\n+        vec::push(res, (did, path));\n     }\n     ret vec::filter(res) {|x|\n         let (_, xp) = x;"}, {"sha": "e1467cdf2c69375a360b7d01dfe542f138c0aef8", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -238,7 +238,7 @@ fn encode_reexport_paths(ebml_w: ebml::writer,\n                          ecx: @encode_ctxt, &index: [entry<str>]/~) {\n     for ecx.reexports.each {|reexport|\n         let (path, def_id) = reexport;\n-        index += [{val: path, pos: ebml_w.writer.tell()}]/~;\n+        vec::push(index, {val: path, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_paths_data_item);\n         encode_name(ebml_w, @path);\n         encode_def_id(ebml_w, def_id);\n@@ -332,7 +332,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx, {crate: local_crate, node: id});\n     for variants.each {|variant|\n-        *index += [{val: variant.node.id, pos: ebml_w.writer.tell()}]/~;\n+        vec::push(*index, {val: variant.node.id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_family(ebml_w, 'v');\n@@ -433,8 +433,8 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         private fields to get the offsets right */\n       alt ci.node {\n         instance_var(nm, _, mt, id, vis) {\n-          *index += [{val: id, pos: ebml_w.writer.tell()}]/~;\n-          *global_index += [{val: id, pos: ebml_w.writer.tell()}]/~;\n+          vec::push(*index, {val: id, pos: ebml_w.writer.tell()});\n+          vec::push(*global_index, {val: id, pos: ebml_w.writer.tell()});\n           ebml_w.start_tag(tag_items_data_item);\n           #debug(\"encode_info_for_class: doing %s %d\", *nm, id);\n           encode_visibility(ebml_w, vis);\n@@ -448,8 +448,9 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         class_method(m) {\n            alt m.vis {\n               public {\n-                *index += [{val: m.id, pos: ebml_w.writer.tell()}]/~;\n-                *global_index += [{val: m.id, pos: ebml_w.writer.tell()}]/~;\n+                vec::push(*index, {val: m.id, pos: ebml_w.writer.tell()});\n+                vec::push(*global_index,\n+                          {val: m.id, pos: ebml_w.writer.tell()});\n                 let impl_path = path + [ast_map::path_name(m.ident)]/~;\n                 #debug(\"encode_info_for_class: doing %s %d\", *m.ident, m.id);\n                 encode_info_for_method(ecx, ebml_w, impl_path,\n@@ -539,7 +540,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n     fn add_to_index_(item: @item, ebml_w: ebml::writer,\n                      index: @mut [entry<int>]/~) {\n-        *index += [{val: item.id, pos: ebml_w.writer.tell()}]/~;\n+        vec::push(*index, {val: item.id, pos: ebml_w.writer.tell()});\n     }\n     let add_to_index = {|copy ebml_w|add_to_index_(item, ebml_w, index)};\n \n@@ -621,7 +622,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                                           items, index);\n         /* Encode the dtor */\n         option::iter(m_dtor) {|dtor|\n-          *index += [{val: dtor.node.id, pos: ebml_w.writer.tell()}]/~;\n+            vec::push(*index, {val: dtor.node.id, pos: ebml_w.writer.tell()});\n           encode_info_for_fn(ecx, ebml_w, dtor.node.id, @(*item.ident\n                              + \"_dtor\"), path, if tps.len() > 0u {\n                                some(ii_dtor(dtor, item.ident, tps,\n@@ -710,7 +711,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n         let impl_path = path + [ast_map::path_name(item.ident)]/~;\n         for methods.each {|m|\n-            *index += [{val: m.id, pos: ebml_w.writer.tell()}]/~;\n+            vec::push(*index, {val: m.id, pos: ebml_w.writer.tell()});\n             encode_info_for_method(ecx, ebml_w, impl_path,\n                    should_inline(m.attrs), item.id, m, tps + m.tps);\n         }\n@@ -745,7 +746,7 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                                index: @mut [entry<int>]/~,\n                                path: ast_map::path, abi: native_abi) {\n     if !reachable(ecx, nitem.id) { ret; }\n-    *index += [{val: nitem.id, pos: ebml_w.writer.tell()}]/~;\n+    vec::push(*index, {val: nitem.id, pos: ebml_w.writer.tell()});\n \n     ebml_w.start_tag(tag_items_data_item);\n     alt nitem.node {\n@@ -770,7 +771,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                          crate: @crate) -> [entry<int>]/~ {\n     let index = @mut []/~;\n     ebml_w.start_tag(tag_items_data);\n-    *index += [{val: crate_node_id, pos: ebml_w.writer.tell()}]/~;\n+    vec::push(*index, {val: crate_node_id, pos: ebml_w.writer.tell()});\n     encode_info_for_mod(ecx, ebml_w, crate.node.module,\n                         crate_node_id, []/~, @\"\");\n     visit::visit_crate(*crate, (), visit::mk_vt(@{\n@@ -818,7 +819,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n fn create_index<T: copy>(index: [entry<T>]/~, hash_fn: fn@(T) -> uint) ->\n    [@[entry<T>]/~]/~ {\n     let mut buckets: [@mut [entry<T>]/~]/~ = []/~;\n-    for uint::range(0u, 256u) {|_i| buckets += [@mut []/~]/~; };\n+    for uint::range(0u, 256u) {|_i| vec::push(buckets, @mut []/~); };\n     for index.each {|elt|\n         let h = hash_fn(elt.val);\n         vec::push(*buckets[h % 256u], elt);\n@@ -838,7 +839,7 @@ fn encode_index<T>(ebml_w: ebml::writer, buckets: [@[entry<T>]/~]/~,\n     let mut bucket_locs: [uint]/~ = []/~;\n     ebml_w.start_tag(tag_index_buckets);\n     for buckets.each {|bucket|\n-        bucket_locs += [ebml_w.writer.tell()]/~;\n+        vec::push(bucket_locs, ebml_w.writer.tell());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n         for vec::each(*bucket) {|elt|\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n@@ -954,7 +955,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> [attribute]/~ {\n             };\n     }\n \n-    if !found_link_attr { attrs += [synthesize_link_attr(ecx, []/~)]/~; }\n+    if !found_link_attr { vec::push(attrs, synthesize_link_attr(ecx, []/~)); }\n \n     ret attrs;\n }\n@@ -971,7 +972,7 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n             let dep = {cnum: key, name: @val.name,\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};\n-            deps += [mut dep]/~;\n+            vec::push(deps, dep);\n         };\n \n         // Sort by cnum"}, {"sha": "ffa3716f4fb0c6c3d84aaff64634cbd5d63789f0", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -89,7 +89,7 @@ fn find_library_crate_aux(cx: ctxt,\n                     option::none::<()>\n                 } else {\n                     #debug(\"found %s with matching metadata\", path);\n-                    matches += [{ident: path, data: cvec}]/~;\n+                    vec::push(matches, {ident: path, data: cvec});\n                     option::none::<()>\n                 }\n               }"}, {"sha": "fd18f2cb4b8bd809bdb686fbd8c20795cf88b98f", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -71,7 +71,7 @@ fn parse_constrs_gen<T: copy>(st: @pstate, conv: conv_did,\n       ':' {\n         loop {\n           next(st);\n-          rslt += [parse_constr(st, conv, pser)]/~;\n+          vec::push(rslt, parse_constr(st, conv, pser));\n           if peek(st) != ';' { break; }\n         }\n       }\n@@ -91,7 +91,7 @@ fn parse_ty_constrs(st: @pstate, conv: conv_did) -> [@ty::type_constr]/~ {\n fn parse_path(st: @pstate) -> @ast::path {\n     let mut idents: [ast::ident]/~ = []/~;\n     fn is_last(c: char) -> bool { ret c == '(' || c == ':'; }\n-    idents += [parse_ident_(st, is_last)]/~;\n+    vec::push(idents, parse_ident_(st, is_last));\n     loop {\n         alt peek(st) {\n           ':' { next(st); next(st); }\n@@ -100,7 +100,7 @@ fn parse_path(st: @pstate) -> @ast::path {\n                 ret @{span: ast_util::dummy_sp(),\n                       global: false, idents: idents,\n                       rp: none, types: []/~};\n-            } else { idents += [parse_ident_(st, is_last)]/~; }\n+            } else { vec::push(idents, parse_ident_(st, is_last)); }\n           }\n         }\n     };\n@@ -124,7 +124,7 @@ fn parse_constr_arg(st: @pstate) -> ast::fn_constr_arg {\n         /*\n           else {\n           auto lit = parse_lit(st, conv, ',');\n-          args += [respan(st.span, ast::carg_lit(lit))]/~;\n+          vec::push(args, respan(st.span, ast::carg_lit(lit)));\n           }\n         */\n       }\n@@ -151,7 +151,7 @@ fn parse_constr<T: copy>(st: @pstate, conv: conv_did,\n     let mut an_arg: constr_arg_general_<T>;\n     loop {\n         an_arg = pser(st);\n-        args += [@respan(sp, an_arg)]/~;\n+        vec::push(args, @respan(sp, an_arg));\n         ignore = next(st);\n         if ignore != ';' { break; }\n     }\n@@ -198,7 +198,7 @@ fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n \n     assert next(st) == '[';\n     let mut params: [ty::t]/~ = []/~;\n-    while peek(st) != ']' { params += [parse_ty(st, conv)]/~; }\n+    while peek(st) != ']' { vec::push(params, parse_ty(st, conv)); }\n     st.pos = st.pos + 1u;\n \n     ret {self_r: self_r,\n@@ -323,15 +323,15 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         let mut fields: [ty::field]/~ = []/~;\n         while peek(st) != ']' {\n             let name = @parse_str(st, '=');\n-            fields += [{ident: name, mt: parse_mt(st, conv)}]/~;\n+            vec::push(fields, {ident: name, mt: parse_mt(st, conv)});\n         }\n         st.pos = st.pos + 1u;\n         ret ty::mk_rec(st.tcx, fields);\n       }\n       'T' {\n         assert (next(st) == '[');\n         let mut params = []/~;\n-        while peek(st) != ']' { params += [parse_ty(st, conv)]/~; }\n+        while peek(st) != ']' { vec::push(params, parse_ty(st, conv)); }\n         st.pos = st.pos + 1u;\n         ret ty::mk_tup(st.tcx, params);\n       }\n@@ -404,7 +404,7 @@ fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n \n fn parse_def(st: @pstate, conv: conv_did) -> ast::def_id {\n     let mut def = []/~;\n-    while peek(st) != '|' { def += [next_byte(st)]/~; }\n+    while peek(st) != '|' { vec::push(def, next_byte(st)); }\n     st.pos = st.pos + 1u;\n     ret conv(parse_def_id(def));\n }\n@@ -456,7 +456,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n           '#' { ast::by_val }\n         };\n         st.pos += 1u;\n-        inputs += [{mode: ast::expl(mode), ty: parse_ty(st, conv)}]/~;\n+        vec::push(inputs, {mode: ast::expl(mode), ty: parse_ty(st, conv)});\n     }\n     st.pos += 1u; // eat the ']'\n     let cs = parse_constrs(st, conv);\n@@ -501,13 +501,13 @@ fn parse_bounds_data(data: @[u8]/~, start: uint,\n fn parse_bounds(st: @pstate, conv: conv_did) -> @[ty::param_bound]/~ {\n     let mut bounds = []/~;\n     loop {\n-        bounds += [alt check next(st) {\n+        vec::push(bounds, alt check next(st) {\n           'S' { ty::bound_send }\n           'C' { ty::bound_copy }\n           'K' { ty::bound_const }\n           'I' { ty::bound_iface(parse_ty(st, conv)) }\n           '.' { break; }\n-        }]/~;\n+        });\n     }\n     @bounds\n }"}, {"sha": "0ddaf7da65914e68071f136c85c0ae17e10834dc", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -120,6 +120,6 @@ fn compute_capture_vars(tcx: ty::ctxt,\n     }\n \n     let mut result = []/~;\n-    for cap_map.each_value { |cap_var| result += [cap_var]/~; }\n+    for cap_map.each_value { |cap_var| vec::push(result, cap_var); }\n     ret result;\n }"}, {"sha": "59c124928c709f0a1783c8e02c43a69465520838", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -782,12 +782,12 @@ fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n                       view_path_simple(_, _, id)\n                       | view_path_glob(_, id) {\n                         if id == my_id { found = true; }\n-                        if found { imports += [id]/~; }\n+                        if found { vec::push(imports, id); }\n                       }\n                       view_path_list(_, ids, _) {\n                         for ids.each {|id|\n                             if id.node.id == my_id { found = true; }\n-                            if found { imports += [id.node.id]/~; }\n+                            if found { vec::push(imports, id.node.id); }\n                         }\n                       }\n                     }\n@@ -1151,7 +1151,7 @@ fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n         } else if ns != ns_module {\n                 left_fn = scope_is_fn(hd);\n                 alt scope_closes(hd) {\n-                  some(node_id) { closing += [node_id]/~; }\n+                  some(node_id) { vec::push(closing, node_id); }\n                   _ { }\n                 }\n             }\n@@ -1421,7 +1421,7 @@ fn lookup_import(e: env, n_id: node_id, ns: namespace) -> option<def> {\n       }\n       resolved(val, typ, md, _, _, _) {\n         if e.used_imports.track {\n-            e.used_imports.data += [n_id]/~;\n+            vec::push(e.used_imports.data, n_id);\n         }\n         ret alt ns { ns_val { val } ns_type { typ } ns_module { md } };\n       }\n@@ -1760,7 +1760,7 @@ fn mie_span(mie: mod_index_entry) -> span {\n fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n     fn typaram_names(tps: [ast::ty_param]/~) -> [ident]/~ {\n         let mut x: [ast::ident]/~ = []/~;\n-        for tps.each {|tp| x += [tp.ident]/~; }\n+        for tps.each {|tp| vec::push(x, tp.ident); }\n         ret x;\n     }\n     visit::visit_item(i, x, v);\n@@ -2121,7 +2121,7 @@ fn check_exports(e: @env) {\n                 if ! glob_is_re_exported.contains_key(id) { cont; }\n                 iter_mod(*e, glob.def,\n                          glob.path.span, outside) {|ident, def|\n-                    _mod.globbed_exports += [ident]/~;\n+                    vec::push(_mod.globbed_exports, ident);\n                     maybe_add_reexport(e, id, some(def));\n                 }\n             }\n@@ -2180,7 +2180,8 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n                         if vec::len(found) == 0u {\n                             for vec::each(*level) {|imp|\n                                 if imp.ident == pt.idents[0] {\n-                                    found += [@{ident: name with *imp}]/~;\n+                                    vec::push(found,\n+                                              @{ident: name with *imp});\n                                 }\n                             }\n                             if vec::len(found) > 0u { impls += found; }\n@@ -2190,7 +2191,7 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n             } else {\n                 lookup_imported_impls(e, id) {|is|\n                     for vec::each(*is) {|i|\n-                        impls += [@{ident: name with *i}]/~;\n+                        vec::push(impls, @{ident: name with *i});\n                     }\n                 }\n             }\n@@ -2232,13 +2233,13 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl]/~,\n              some(m) { is_exported(e, i.ident, m) }\n              _ { true }\n            } {\n-            impls += [@{did: local_def(i.id),\n+            vec::push(impls, @{did: local_def(i.id),\n                         ident: i.ident,\n                         methods: vec::map(mthds, {|m|\n                             @{did: local_def(m.id),\n                               n_tps: vec::len(m.tps),\n                               ident: m.ident}\n-                        })}]/~;\n+                        })});\n         }\n       }\n       ast::item_class(tps, ifces, items, _, _, _) {\n@@ -2247,12 +2248,12 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl]/~,\n           vec::iter(ifces) {|p|\n               // The def_id, in this case, identifies the combination of\n               // class and iface\n-              impls += [@{did: local_def(p.id),\n+              vec::push(impls, @{did: local_def(p.id),\n                          ident: i.ident,\n                          methods: vec::map(mthds, {|m|\n                                       @{did: local_def(m.id),\n                                           n_tps: n_tps + m.tps.len(),\n-                                          ident: m.ident}})}]/~;\n+                                          ident: m.ident}})});\n           }\n       }\n       _ {}\n@@ -2287,10 +2288,10 @@ fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: [@_impl]/~,\n     alt name {\n       some(n) {\n         for vec::each(*cached) {|im|\n-            if n == im.ident { impls += [im]/~; }\n+            if n == im.ident { vec::push(impls, im); }\n         }\n       }\n-      _ { impls += *cached; }\n+      _ { vec::push_all(impls, *cached); }\n     }\n }\n "}, {"sha": "c36e1eea4e97004cb18ad7a4f0ce921613c5952e", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -110,12 +110,12 @@ fn expand_nested_bindings(m: match, col: uint, val: ValueRef) -> match {\n           ast::pat_ident(name, some(inner)) {\n             let pats = vec::slice(br.pats, 0u, col) + [inner]/~ +\n                 vec::slice(br.pats, col + 1u, br.pats.len());\n-            result += [@{pats: pats,\n+            vec::push(result, @{pats: pats,\n                         bound: br.bound + [{ident: path_to_ident(name),\n                                 val: val}]/~\n-                         with *br}]/~;\n+                         with *br});\n           }\n-          _ { result += [br]/~; }\n+          _ { vec::push(result, br); }\n         }\n     }\n     result\n@@ -138,7 +138,7 @@ fn enter_match(dm: def_map, m: match, col: uint, val: ValueRef,\n               }\n               _ { br.bound }\n             };\n-            result += [@{pats: pats, bound: bound with *br}]/~;\n+            vec::push(result, @{pats: pats, bound: bound with *br});\n           }\n           none { }\n         }\n@@ -196,7 +196,7 @@ fn enter_rec(dm: def_map, m: match, col: uint, fields: [ast::ident]/~,\n                 for vec::each(fpats) {|fpat|\n                     if str::eq(*fpat.ident, *fname) { pat = fpat.pat; break; }\n                 }\n-                pats += [pat]/~;\n+                vec::push(pats, pat);\n             }\n             some(pats)\n           }\n@@ -293,7 +293,7 @@ fn collect_record_fields(m: match, col: uint) -> [ast::ident]/~ {\n           ast::pat_rec(fs, _) {\n             for vec::each(fs) {|f|\n                 if !vec::any(fields, {|x| str::eq(*f.ident, *x)}) {\n-                    fields += [f.ident]/~;\n+                    vec::push(fields, f.ident);\n                 }\n             }\n           }\n@@ -404,8 +404,8 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef]/~,\n           _ { }\n         }\n         if !bcx.unreachable {\n-            exits += [{bound: m[0].bound, from: bcx.llbb,\n-                       to: data.bodycx.llbb}]/~;\n+            vec::push(exits, {bound: m[0].bound, from: bcx.llbb,\n+                       to: data.bodycx.llbb});\n         }\n         Br(bcx, data.bodycx.llbb);\n         ret;\n@@ -436,7 +436,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef]/~,\n         let mut rec_vals = []/~;\n         for vec::each(rec_fields) {|field_name|\n             let ix = option::get(ty::field_idx(field_name, fields));\n-            rec_vals += [GEPi(bcx, val, [0u, ix]/~)]/~;\n+            vec::push(rec_vals, GEPi(bcx, val, [0u, ix]/~));\n         }\n         compile_submatch(bcx, enter_rec(dm, m, col, rec_fields, val),\n                          rec_vals + vals_left, chk, exits);\n@@ -451,7 +451,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef]/~,\n         };\n         let mut tup_vals = []/~, i = 0u;\n         while i < n_tup_elts {\n-            tup_vals += [GEPi(bcx, val, [0u, i]/~)]/~;\n+            vec::push(tup_vals, GEPi(bcx, val, [0u, i]/~));\n             i += 1u;\n         }\n         compile_submatch(bcx, enter_tup(dm, m, col, val, n_tup_elts),\n@@ -604,7 +604,10 @@ fn make_phi_bindings(bcx: block, map: [exit_node]/~,\n         for vec::each(map) {|ex|\n             if ex.to as uint == our_block {\n                 alt assoc(name, ex.bound) {\n-                  some(val) { llbbs += [ex.from]/~; vals += [val]/~; }\n+                  some(val) {\n+                    vec::push(llbbs, ex.from);\n+                    vec::push(vals, val);\n+                  }\n                   none { }\n                 }\n             }\n@@ -644,12 +647,12 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm]/~,\n     for vec::each(arms) {|a|\n         let body = scope_block(bcx, a.body.info(), \"case_body\");\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n-        bodies += [body]/~;\n+        vec::push(bodies, body);\n         for vec::each(a.pats) {|p|\n-            match += [@{pats: [p]/~,\n+            vec::push(match, @{pats: [p]/~,\n                         bound: []/~,\n                         data: @{bodycx: body, guard: a.guard,\n-                                id_map: id_map}}]/~;\n+                                id_map: id_map}});\n         }\n     }\n \n@@ -680,10 +683,10 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm]/~,\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n         if make_phi_bindings(body_cx, exit_map, id_map) {\n             let arm_dest = dup_for_join(dest);\n-            arm_dests += [arm_dest]/~;\n+            vec::push(arm_dests, arm_dest);\n             let mut arm_cx = trans_block(body_cx, a.body, arm_dest);\n             arm_cx = trans_block_cleanups(arm_cx, body_cx);\n-            arm_cxs += [arm_cx]/~;\n+            vec::push(arm_cxs, arm_cx);\n         }\n         i += 1u;\n     }"}, {"sha": "05ec7d074c8be60f85fd7bd461d06e385d9d0082", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -102,7 +102,7 @@ impl ccx_icx for @crate_ctxt {\n     fn insn_ctxt(s: str) -> icx_popper {\n         #debug(\"new insn_ctxt: %s\", s);\n         if self.sess.count_llvm_insns() {\n-            *self.stats.llvm_insn_ctxt += [s]/~;\n+            vec::push(*self.stats.llvm_insn_ctxt, s);\n         }\n         icx_popper(self)\n     }\n@@ -172,7 +172,7 @@ fn log_fn_time(ccx: @crate_ctxt, name: str, start: time::timespec,\n                end: time::timespec) {\n     let elapsed = 1000 * ((end.sec - start.sec) as int) +\n         ((end.nsec as int) - (start.nsec as int)) / 1000000;\n-    *ccx.stats.fn_times += [{ident: name, time: elapsed}]/~;\n+    vec::push(*ccx.stats.fn_times, {ident: name, time: elapsed});\n }\n \n \n@@ -236,7 +236,7 @@ fn trans_native_call(cx: block, externs: hashmap<str, ValueRef>,\n         get_simple_extern_fn(cx, externs, llmod, name, n);\n     let mut call_args: [ValueRef]/~ = []/~;\n     for vec::each(args) {|a|\n-        call_args += [a]/~;\n+        vec::push(call_args, a);\n     }\n     ret Call(cx, llnative, call_args);\n }\n@@ -2983,7 +2983,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n             // In the event that failure occurs before the call actually\n             // happens, have to cleanup this copy:\n             add_clean_temp_mem(bcx, val, arg.ty);\n-            temp_cleanups += [val]/~;\n+            vec::push(temp_cleanups, val);\n           }\n         }\n     }\n@@ -3095,10 +3095,10 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n       by_val(_) { alloc_ty(bcx, retty) }\n     };\n \n-    llargs += [llretslot]/~;\n+    vec::push(llargs, llretslot);\n \n     // Arg 1: Env (closure-bindings / self value)\n-    llargs += [llenv]/~;\n+    vec::push(llargs, llenv);\n \n     // ... then explicit args.\n \n@@ -3114,7 +3114,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n                                    e, temp_cleanups, if i == last { ret_flag }\n                                    else { none }, 0u);\n             bcx = r.bcx;\n-            llargs += [r.val]/~;\n+            vec::push(llargs, r.val);\n         }\n       }\n       arg_vals(vs) {\n@@ -3387,7 +3387,7 @@ fn trans_tup(bcx: block, elts: [@ast::expr]/~, dest: dest) -> block {\n         let e_ty = expr_ty(bcx, e);\n         bcx = trans_expr_save_in(bcx, e, dst);\n         add_clean_temp_mem(bcx, dst, e_ty);\n-        temp_cleanups += [dst]/~;\n+        vec::push(temp_cleanups, dst);\n     }\n     for vec::each(temp_cleanups) {|cleanup| revoke_clean(bcx, cleanup); }\n     ret bcx;\n@@ -3419,7 +3419,7 @@ fn trans_rec(bcx: block, fields: [ast::field]/~,\n         let dst = GEPi(bcx, addr, [0u, ix]/~);\n         bcx = trans_expr_save_in(bcx, fld.node.expr, dst);\n         add_clean_temp_mem(bcx, dst, ty_fields[ix].mt.ty);\n-        temp_cleanups += [dst]/~;\n+        vec::push(temp_cleanups, dst);\n     }\n     alt base {\n       some(bexp) {\n@@ -4264,7 +4264,7 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n             }\n             let sub_cx = sub_block(bcx, \"cleanup\");\n             Br(bcx, sub_cx.llbb);\n-            inf.cleanup_paths += [{target: leave, dest: sub_cx.llbb}]/~;\n+            vec::push(inf.cleanup_paths, {target: leave, dest: sub_cx.llbb});\n             bcx = trans_block_cleanups_(sub_cx, cur, is_lpad);\n           }\n           _ {}\n@@ -5059,7 +5059,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let llenvarg = llvm::LLVMGetParam(llfdecl, 1 as c_uint);\n         let mut args = [lloutputarg, llenvarg]/~;\n         if takes_argv {\n-            args += [llvm::LLVMGetParam(llfdecl, 2 as c_uint)]/~;\n+            vec::push(args, llvm::LLVMGetParam(llfdecl, 2 as c_uint));\n         }\n         Call(bcx, main_llfn, args);\n         build_return(bcx);\n@@ -5369,10 +5369,10 @@ fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n     for ccx.module_data.each {|key, val|\n         let elt = C_struct([p2i(ccx, C_cstr(ccx, key)),\n                             p2i(ccx, val)]/~);\n-        elts += [elt]/~;\n+        vec::push(elts, elt);\n     };\n     let term = C_struct([C_int(ccx, 0), C_int(ccx, 0)]/~);\n-    elts += [term]/~;\n+    vec::push(elts, term);\n     llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n     ret map;\n }\n@@ -5410,10 +5410,10 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n         let cr = str::as_c_str(nm, {|buf|\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n         });\n-        subcrates += [p2i(ccx, cr)]/~;\n+        vec::push(subcrates, p2i(ccx, cr));\n         i += 1;\n     }\n-    subcrates += [C_int(ccx, 0)]/~;\n+    vec::push(subcrates, C_int(ccx, 0));\n     llvm::LLVMSetInitializer(map, C_struct(\n         [p2i(ccx, create_module_map(ccx)),\n          C_array(ccx.int_type, subcrates)]/~));\n@@ -5448,7 +5448,7 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n                     ast_map::path_to_str(*path)\n                   }\n                 };\n-                reexports += [(path, def.id)]/~;\n+                vec::push(reexports, (path, def.id));\n             }\n         }\n         ret reexports;"}, {"sha": "b5eae6caa8456b512946e56188848fd1af9bcd90", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -430,7 +430,7 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]/~) -> ValueRef {\n // in C_i32()\n fn GEPi(cx: block, base: ValueRef, ixs: [uint]/~) -> ValueRef {\n     let mut v: [ValueRef]/~ = []/~;\n-    for vec::each(ixs) {|i| v += [C_i32(i as i32)]/~; }\n+    for vec::each(ixs) {|i| vec::push(v, C_i32(i as i32)); }\n     count_insn(cx, \"gepi\");\n     ret InBoundsGEP(cx, base, v);\n }"}, {"sha": "fa114d16bfd387bd96b92b88d182314905ebc93c", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -128,12 +128,12 @@ fn mk_closure_tys(tcx: ty::ctxt,\n \n     // Compute the closed over data\n     for vec::each(bound_values) {|bv|\n-        bound_tys += [alt bv {\n+        vec::push(bound_tys, alt bv {\n             env_copy(_, t, _) { t }\n             env_move(_, t, _) { t }\n             env_ref(_, t, _) { t }\n             env_expr(_, t) { t }\n-        }]/~;\n+        });\n     }\n     let bound_data_ty = ty::mk_tup(tcx, bound_tys);\n     // FIXME[mono] remove tuple of tydescs from closure types (#2531)\n@@ -247,7 +247,7 @@ fn store_environment(bcx: block,\n           env_expr(e, _) {\n             bcx = base::trans_expr_save_in(bcx, e, bound_data);\n             add_clean_temp_mem(bcx, bound_data, bound_tys[i]);\n-            temp_cleanups += [bound_data]/~;\n+            vec::push(temp_cleanups, bound_data);\n           }\n           env_copy(val, ty, owned) {\n             let val1 = load_if_immediate(bcx, val, ty);\n@@ -303,18 +303,18 @@ fn build_closure(bcx0: block,\n           capture::cap_ref {\n             assert ck == ty::ck_block;\n             ty = ty::mk_mut_ptr(tcx, ty);\n-            env_vals += [env_ref(lv.val, ty, lv.kind)]/~;\n+            vec::push(env_vals, env_ref(lv.val, ty, lv.kind));\n           }\n           capture::cap_copy {\n             let mv = alt check ccx.maps.last_use_map.find(id) {\n               none { false }\n               some(vars) { (*vars).contains(nid) }\n             };\n-            if mv { env_vals += [env_move(lv.val, ty, lv.kind)]/~; }\n-            else { env_vals += [env_copy(lv.val, ty, lv.kind)]/~; }\n+            if mv { vec::push(env_vals, env_move(lv.val, ty, lv.kind)); }\n+            else { vec::push(env_vals, env_copy(lv.val, ty, lv.kind)); }\n           }\n           capture::cap_move {\n-            env_vals += [env_move(lv.val, ty, lv.kind)]/~;\n+            vec::push(env_vals, env_move(lv.val, ty, lv.kind));\n           }\n           capture::cap_drop {\n             assert lv.kind == owned;\n@@ -435,7 +435,7 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n     let ccx = cx.ccx();\n     let mut bound: [@ast::expr]/~ = []/~;\n     for vec::each(args) {|argopt|\n-        alt argopt { none { } some(e) { bound += [e]/~; } }\n+        alt argopt { none { } some(e) { vec::push(bound, e); } }\n     }\n     let mut bcx = f_res.bcx;\n     if dest == ignore {\n@@ -758,13 +758,13 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n               }\n               ast::by_ref | ast::by_mutbl_ref | ast::by_move { }\n             }\n-            llargs += [val]/~;\n+            vec::push(llargs, val);\n             b += 1u;\n           }\n \n           // Arg will be provided when the thunk is invoked.\n           none {\n-            llargs += [llvm::LLVMGetParam(llthunk, a as c_uint)]/~;\n+            vec::push(llargs, llvm::LLVMGetParam(llthunk, a as c_uint));\n             a += 1u;\n           }\n         }"}, {"sha": "d97d535ed8b0b9bd8829ddcacf84fd335fffab39", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -236,8 +236,8 @@ fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n            ty_to_str(cx.ccx().tcx, ty)];\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     in_scope_cx(cx) {|info|\n-        info.cleanups += [clean({|a|base::drop_ty(a, val, ty)},\n-                                cleanup_type)]/~;\n+        vec::push(info.cleanups, clean({|a|base::drop_ty(a, val, ty)},\n+                                cleanup_type));\n         scope_clean_changed(info);\n     }\n }\n@@ -256,8 +256,8 @@ fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n         }\n     }\n     in_scope_cx(cx) {|info|\n-        info.cleanups += [clean_temp(val, {|a|do_drop(a, val, ty)},\n-                                     cleanup_type)]/~;\n+        vec::push(info.cleanups, clean_temp(val, {|a|do_drop(a, val, ty)},\n+                                     cleanup_type));\n         scope_clean_changed(info);\n     }\n }\n@@ -268,17 +268,18 @@ fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n            ty_to_str(cx.ccx().tcx, ty)];\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     in_scope_cx(cx) {|info|\n-        info.cleanups += [clean_temp(val, {|a|base::drop_ty(a, val, ty)},\n-                                     cleanup_type)]/~;\n+        vec::push(info.cleanups,\n+                  clean_temp(val, {|a|base::drop_ty(a, val, ty)},\n+                             cleanup_type));\n         scope_clean_changed(info);\n     }\n }\n fn add_clean_free(cx: block, ptr: ValueRef, shared: bool) {\n     let free_fn = if shared { {|a|base::trans_unique_free(a, ptr)} }\n     else { {|a|base::trans_free(a, ptr)} };\n     in_scope_cx(cx) {|info|\n-        info.cleanups += [clean_temp(ptr, free_fn,\n-                                     normal_exit_and_unwind)]/~;\n+        vec::push(info.cleanups, clean_temp(ptr, free_fn,\n+                                     normal_exit_and_unwind));\n         scope_clean_changed(info);\n     }\n }\n@@ -849,7 +850,7 @@ fn C_postr(s: str) -> ValueRef {\n fn C_zero_byte_arr(size: uint) -> ValueRef unsafe {\n     let mut i = 0u;\n     let mut elts: [ValueRef]/~ = []/~;\n-    while i < size { elts += [C_u8(0u)]/~; i += 1u; }\n+    while i < size { vec::push(elts, C_u8(0u)); i += 1u; }\n     ret llvm::LLVMConstArray(T_i8(), vec::unsafe::to_ptr(elts),\n                              elts.len() as c_uint);\n }"}, {"sha": "fb80b1246c34037010df0b1a0e435cfdac983316", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -403,9 +403,9 @@ fn create_derived_type(type_tag: int, file: ValueRef, name: str, line: int,\n \n fn add_member(cx: @struct_ctxt, name: str, line: int, size: int, align: int,\n               ty: ValueRef) {\n-    cx.members += [create_derived_type(MemberTag, cx.file, name, line,\n+    vec::push(cx.members, create_derived_type(MemberTag, cx.file, name, line,\n                                        size * 8, align * 8, cx.total_size,\n-                                       ty)]/~;\n+                                       ty));\n     cx.total_size += size * 8;\n }\n \n@@ -550,10 +550,10 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n           ty::ty_rec(fields) {\n             let fs = []/~;\n             for field in fields {\n-                fs += [{node: {ident: field.ident,\n+                vec::push(fs, {node: {ident: field.ident,\n                                mt: {ty: t_to_ty(cx, field.mt.ty, span),\n                                     mutbl: field.mt.mutbl}},\n-                        span: span}]/~;\n+                        span: span});\n             }\n             ast::ty_rec(fs)\n           }"}, {"sha": "60cc81d119501c3704d7b9a87e2c622c6f97db65", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -292,21 +292,21 @@ fn llreg_ty(cls: [x86_64_reg_class]/~) -> TypeRef {\n     while i < e {\n         alt cls[i] {\n             integer_class {\n-                tys += [T_i64()]/~;\n+                vec::push(tys, T_i64());\n             }\n             sse_fv_class {\n                 let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n                 let vec_ty = llvm::LLVMVectorType(T_f32(),\n                                                   vec_len as c_uint);\n-                tys += [vec_ty]/~;\n+                vec::push(tys, vec_ty);\n                 i += vec_len;\n                 cont;\n             }\n             sse_fs_class {\n-                tys += [T_f32()]/~;\n+                vec::push(tys, T_f32());\n             }\n             sse_ds_class {\n-                tys += [T_f64()]/~;\n+                vec::push(tys, T_f64());\n             }\n             _ {\n                 fail \"llregtype: unhandled class\";\n@@ -375,8 +375,8 @@ fn x86_64_tys(atys: [TypeRef]/~,\n     let mut attrs = []/~;\n     for vec::each(atys) {|t|\n         let (ty, attr) = x86_64_ty(t, is_pass_byval, ByValAttribute);\n-        arg_tys += [ty]/~;\n-        attrs += [attr]/~;\n+        vec::push(arg_tys, ty);\n+        vec::push(attrs, attr);\n     }\n     let mut (ret_ty, ret_attr) = x86_64_ty(rty, is_ret_bysret,\n                                        StructRetAttribute);\n@@ -617,15 +617,15 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                         } else {\n                             load_inbounds(bcx, llargbundle, [0u, i]/~)\n                         };\n-                        llargvals += [llargval]/~;\n+                        vec::push(llargvals, llargval);\n                         i += 1u;\n                     }\n                 }\n                 _ {\n                     while i < n {\n                         let llargval = load_inbounds(bcx, llargbundle,\n                                                           [0u, i]/~);\n-                        llargvals += [llargval]/~;\n+                        vec::push(llargvals, llargval);\n                         i += 1u;\n                     }\n                 }\n@@ -952,12 +952,12 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n             let llretptr = load_inbounds(bcx, llargbundle, [0u, n]/~);\n-            llargvals += [llretptr]/~;\n+            vec::push(llargvals, llretptr);\n             let llenvptr = C_null(T_opaque_box_ptr(bcx.ccx()));\n-            llargvals += [llenvptr]/~;\n+            vec::push(llargvals, llenvptr);\n             while i < n {\n                 let llargval = load_inbounds(bcx, llargbundle, [0u, i]/~);\n-                llargvals += [llargval]/~;\n+                vec::push(llargvals, llargval);\n                 i += 1u;\n             }\n             ret llargvals;"}, {"sha": "59a762a9750c29e62ab6b45322b15f497bef921b", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -31,10 +31,10 @@ fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg]/~,\n     let mut atys: [TypeRef]/~ = []/~;\n \n     // Arg 0: Output pointer.\n-    atys += [T_ptr(type_of(cx, output))]/~;\n+    vec::push(atys, T_ptr(type_of(cx, output)));\n \n     // Arg 1: Environment\n-    atys += [T_opaque_box_ptr(cx)]/~;\n+    vec::push(atys, T_opaque_box_ptr(cx));\n \n     // ... then explicit args.\n     atys += type_of_explicit_args(cx, inputs);\n@@ -137,7 +137,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n             let mut tys: [TypeRef]/~ = []/~;\n             for vec::each(fields) {|f|\n                 let mt_ty = f.mt.ty;\n-                tys += [type_of(cx, mt_ty)]/~;\n+                vec::push(tys, type_of(cx, mt_ty));\n             }\n             T_struct(tys)\n           }\n@@ -147,7 +147,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n           ty::ty_tup(elts) {\n             let mut tys = []/~;\n             for vec::each(elts) {|elt|\n-                tys += [type_of(cx, elt)]/~;\n+                vec::push(tys, type_of(cx, elt));\n             }\n             T_struct(tys)\n           }"}, {"sha": "b45d058970e3a1e5a3463f7a844781353fab26d1", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -553,7 +553,7 @@ fn exprs_to_constr_args(tcx: ty::ctxt,\n                         args: [@expr]/~) -> [@constr_arg_use]/~ {\n     let f = {|a|expr_to_constr_arg(tcx, a)};\n     let mut rslt: [@constr_arg_use]/~ = []/~;\n-    for args.each {|e| rslt += [f(e)]/~; }\n+    for args.each {|e| vec::push(rslt, f(e)); }\n     rslt\n }\n \n@@ -589,7 +589,7 @@ fn substitute_constr_args(cx: ty::ctxt, actuals: [@expr]/~, c: @ty::constr) ->\n    tsconstr {\n     let mut rslt: [@constr_arg_use]/~ = []/~;\n     for c.node.args.each {|a|\n-        rslt += [substitute_arg(cx, actuals, a)]/~;\n+        vec::push(rslt, substitute_arg(cx, actuals, a));\n     }\n     ret {path: c.node.path,\n          def_id: c.node.id,\n@@ -668,7 +668,7 @@ fn find_instances(_fcx: fn_ctxt, subst: subst,\n                 let old_bit_num = d.node.bit_num;\n                 let newv = replace(subst, d);\n                 alt find_instance_(newv, v) {\n-                  some(d1) {res += [{from: old_bit_num, to: d1}]/~}\n+                  some(d1) {vec::push(res, {from: old_bit_num, to: d1})}\n                   _ {}\n                 }\n             } else {}\n@@ -710,12 +710,12 @@ fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>]/~ {\n         alt c.node {\n           carg_ident(p) {\n             alt find_in_subst(p.node, subst) {\n-              some(newv) { rslt += [carg_ident(newv)]/~; }\n-              _ { rslt += [c.node]/~; }\n+              some(newv) { vec::push(rslt, carg_ident(newv)); }\n+              _ { vec::push(rslt, c.node); }\n             }\n           }\n           _ {\n-            rslt += [c.node]/~;\n+            vec::push(rslt, c.node);\n           }\n         }\n     }\n@@ -866,7 +866,9 @@ fn args_mention<T>(args: [@constr_arg_use]/~,\n     ret false;\n }\n \n-fn use_var(fcx: fn_ctxt, v: node_id) { *fcx.enclosing.used_vars += [v]/~; }\n+fn use_var(fcx: fn_ctxt, v: node_id) {\n+    vec::push(*fcx.enclosing.used_vars, v);\n+}\n \n fn op_to_oper_ty(io: init_op) -> oper_type {\n     alt io { init_move { oper_move } _ { oper_assign } }\n@@ -924,14 +926,14 @@ type binding = {lhs: [dest]/~, rhs: option<initializer>};\n fn local_to_bindings(tcx: ty::ctxt, loc: @local) -> binding {\n     let mut lhs = []/~;\n     pat_bindings(tcx.def_map, loc.node.pat) {|p_id, _s, name|\n-      lhs += [local_dest({ident: path_to_ident(name), node: p_id})]/~;\n+      vec::push(lhs, local_dest({ident: path_to_ident(name), node: p_id}));\n     };\n     {lhs: lhs, rhs: loc.node.init}\n }\n \n fn locals_to_bindings(tcx: ty::ctxt, locals: [@local]/~) -> [binding]/~ {\n     let mut rslt = []/~;\n-    for locals.each {|loc| rslt += [local_to_bindings(tcx, loc)]/~; }\n+    for locals.each {|loc| vec::push(rslt, local_to_bindings(tcx, loc)); }\n     ret rslt;\n }\n \n@@ -941,7 +943,7 @@ fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [mode]/~ {\n     alt ty::get(ty).struct {\n       ty::ty_fn({inputs: args, _}) {\n         let mut modes = []/~;\n-        for args.each {|arg| modes += [arg.mode]/~; }\n+        for args.each {|arg| vec::push(modes, arg.mode); }\n         ret modes;\n       }\n       _ {"}, {"sha": "5264ee66b063c31938011661649029adf839d1e2", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -14,8 +14,10 @@ type ctxt = {cs: @mut [sp_constr]/~, tcx: ty::ctxt};\n \n fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n     alt e.node {\n-      expr_check(_, ch) { *cx.cs += [expr_to_constr(cx.tcx, ch)]/~; }\n-      expr_if_check(ex, _, _) { *cx.cs += [expr_to_constr(cx.tcx, ex)]/~; }\n+      expr_check(_, ch) { vec::push(*cx.cs, expr_to_constr(cx.tcx, ch)); }\n+      expr_if_check(ex, _, _) {\n+        vec::push(*cx.cs, expr_to_constr(cx.tcx, ex));\n+      }\n \n       // If it's a call, generate appropriate instances of the\n       // call's constraints.\n@@ -24,7 +26,7 @@ fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n             let ct: sp_constr =\n                 respan(c.span,\n                        aux::substitute_constr_args(cx.tcx, operands, c));\n-            *cx.cs += [ct]/~;\n+            vec::push(*cx.cs, ct);\n         }\n       }\n       _ { }"}, {"sha": "328151eee9c61ae47e7372a589df62bc74da46e7", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -255,7 +255,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         /* copy */\n \n         let mut args = operands;\n-        args += [operator]/~;\n+        vec::push(args, operator);\n \n         find_pre_post_exprs(fcx, args, e.id);\n         /* see if the call has any constraints on its type */\n@@ -314,7 +314,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       }\n       expr_rec(fields, maybe_base) {\n         let mut es = field_exprs(fields);\n-        alt maybe_base { none {/* no-op */ } some(b) { es += [b]/~; } }\n+        alt maybe_base { none {/* no-op */ } some(b) { vec::push(es, b); } }\n         find_pre_post_exprs(fcx, es, e.id);\n       }\n       expr_tup(elts) { find_pre_post_exprs(fcx, elts, e.id); }\n@@ -398,7 +398,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n             ret block_pp(fcx.ccx, an_alt.body);\n         }\n         let mut alt_pps = []/~;\n-        for alts.each {|a| alt_pps += [do_an_alt(fcx, a)]/~; }\n+        for alts.each {|a| vec::push(alt_pps, do_an_alt(fcx, a)); }\n         fn combine_pp(antec: pre_and_post, fcx: fn_ctxt, &&pp: pre_and_post,\n                       &&next: pre_and_post) -> pre_and_post {\n             union(pp.precondition, seq_preconds(fcx, [antec, next]/~));\n@@ -555,20 +555,20 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n     option::map::<@expr, ()>(b.node.expr, do_inner);\n \n     let mut pps: [pre_and_post]/~ = []/~;\n-    for b.node.stmts.each {|s| pps += [stmt_pp(fcx.ccx, *s)]/~; }\n+    for b.node.stmts.each {|s| vec::push(pps, stmt_pp(fcx.ccx, *s)); }\n     alt b.node.expr {\n       none {/* no-op */ }\n-      some(e) { pps += [expr_pp(fcx.ccx, e)]/~; }\n+      some(e) { vec::push(pps, expr_pp(fcx.ccx, e)); }\n     }\n \n     let block_precond = seq_preconds(fcx, pps);\n \n     let mut postconds = []/~;\n-    for pps.each {|pp| postconds += [get_post(pp)]/~; }\n+    for pps.each {|pp| vec::push(postconds, get_post(pp)); }\n \n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */\n-    postconds += [block_precond]/~;\n+    vec::push(postconds, block_precond);\n \n     let mut block_postcond = empty_poststate(nv);\n     /* conservative approximation */"}, {"sha": "fa93925fa88fe446d389f5a44100d0b1376a1838", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -2281,7 +2281,7 @@ fn occurs_check(tcx: ctxt, sp: span, vid: tv_vid, rt: t) {\n     fn vars_in_type(ty: t) -> [tv_vid]/~ {\n         let mut rslt = []/~;\n         walk_ty(ty) {|ty|\n-            alt get(ty).struct { ty_var(v) { rslt += [v]/~; } _ { } }\n+            alt get(ty).struct { ty_var(v) { vec::push(rslt, v); } _ { } }\n         }\n         rslt\n     }\n@@ -2837,8 +2837,8 @@ fn class_field_tys(items: [@class_member]/~) -> [field_ty]/~ {\n     for items.each {|it|\n        alt it.node {\n           instance_var(nm, _, cm, id, vis) {\n-              rslt += [{ident: nm, id: ast_util::local_def(id),\n-                        vis: vis, mutability: cm}]/~;\n+              vec::push(rslt, {ident: nm, id: ast_util::local_def(id),\n+                        vis: vis, mutability: cm});\n           }\n           class_method(_) { }\n        }\n@@ -2874,9 +2874,9 @@ fn class_item_fields(cx:ctxt, did: ast::def_id,\n     for lookup_class_fields(cx, did).each {|f|\n        // consider all instance vars mut, because the\n        // constructor may mutate all vars\n-       rslt += [{ident: f.ident, mt:\n+       vec::push(rslt, {ident: f.ident, mt:\n                {ty: lookup_field_type(cx, did, f.id, substs),\n-                    mutbl: frob_mutability(f.mutability)}}]/~;\n+                    mutbl: frob_mutability(f.mutability)}});\n     }\n     rslt\n }"}, {"sha": "25dfdf9bc06aab959355d44358cb9bb429417210", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -339,7 +339,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n       ast::ty_constr(t, cs) {\n         let mut out_cs = []/~;\n         for cs.each {|constr|\n-            out_cs += [ty::ast_constr_to_constr(tcx, constr)]/~;\n+            vec::push(out_cs, ty::ast_constr_to_constr(tcx, constr));\n         }\n         ty::mk_constr(tcx, ast_ty_to_ty(self, rscope, t), out_cs)\n       }"}, {"sha": "e3a5b989c52f29723fda2c6f0625b1a8d3447ba9", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -1424,7 +1424,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         for elts.eachi {|i, e|\n             check_expr(fcx, e, flds.map {|fs| fs[i]});\n             let ety = fcx.expr_ty(e);\n-            elt_ts += [ety]/~;\n+            vec::push(elt_ts, ety);\n         }\n         let typ = ty::mk_tup(tcx, elt_ts);\n         fcx.write_ty(id, typ);\n@@ -1826,14 +1826,14 @@ fn check_enum_variants(ccx: @crate_ctxt,\n             ccx.tcx.sess.span_err(v.span,\n                                   \"discriminator value already exists\");\n         }\n-        disr_vals += [disr_val]/~;\n+        vec::push(disr_vals, disr_val);\n         let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n         let arg_tys = if v.node.args.len() > 0u {\n             ty::ty_fn_args(ctor_ty).map {|a| a.ty }\n           } else { []/~ };\n-        variants += [@{args: arg_tys, ctor_ty: ctor_ty,\n+        vec::push(variants, @{args: arg_tys, ctor_ty: ctor_ty,\n               name: v.node.name, id: local_def(v.node.id),\n-              disr_val: disr_val}]/~;\n+              disr_val: disr_val});\n         disr_val += 1;\n     }\n \n@@ -1913,7 +1913,7 @@ fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr]/~,\n     for cs.each {|c|\n         let mut c_args = []/~;\n         for c.node.args.each {|a|\n-            c_args += [\n+            vec::push(c_args,\n                  // \"base\" should not occur in a fn type thing, as of\n                  // yet, b/c we don't allow constraints on the return type\n \n@@ -1953,7 +1953,7 @@ fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr]/~,\n                                        carg_ident index out of bounds\");\n                       }\n                     }\n-                  }]/~;\n+                  });\n         }\n         let p_op: ast::expr_ = ast::expr_path(c.node.path);\n         let oper: @ast::expr = @{id: c.node.id, node: p_op, span: c.span};"}, {"sha": "6e22099a247348bdcd18176efa758369e450bffb", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -12,7 +12,7 @@ fn replace_bound_regions_in_fn_ty(\n                                                   fn_ty: ty::fn_ty} {\n \n     let mut all_tys = ty::tys_in_fn_ty(fn_ty);\n-    for self_ty.each { |t| all_tys += [t]/~ }\n+    for self_ty.each { |t| vec::push(all_tys, t) }\n \n     #debug[\"replace_bound_regions_in_fn_ty(self_ty=%?, fn_ty=%s, all_tys=%?)\",\n            self_ty.map { |t| ty_to_str(tcx, t) },"}, {"sha": "f89492e11b716f0675371f7cf73368510dd72b9f", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -18,8 +18,8 @@ fn lookup_vtables(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n             alt bound {\n               ty::bound_iface(i_ty) {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n-                result += [lookup_vtable(fcx, isc, sp, ty, i_ty,\n-                                         allow_unsafe)]/~;\n+                vec::push(result, lookup_vtable(fcx, isc, sp, ty, i_ty,\n+                                         allow_unsafe));\n               }\n               _ {}\n             }\n@@ -144,7 +144,8 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n                                       iface_tps, im.did);\n                     let subres = lookup_vtables(fcx, isc, sp,\n                                                 im_bs, substs_f, false);\n-                    found += [vtable_static(im.did, substs_f.tps, subres)]/~;\n+                    vec::push(found,\n+                              vtable_static(im.did, substs_f.tps, subres));\n                 }\n \n                 alt found.len() {"}, {"sha": "205a07f92065138a4272ec5bcf28231304c3ab18", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -43,7 +43,7 @@ fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n             let mut new_tps = []/~;\n             for substs.tps.each {|subst|\n                 alt resolve_type_vars_in_type(fcx, sp, subst) {\n-                  some(t) { new_tps += [t]/~; }\n+                  some(t) { vec::push(new_tps, t); }\n                   none { wbcx.success = false; ret none; }\n                 }\n             }"}, {"sha": "2b1c88f1ea130500b4139a470fbbba217efe44d6", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3ad0736dfc3a69f50155d2251f195de54b6c6/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "patch": "@@ -31,7 +31,7 @@ fn field_expr(f: ast::field) -> @ast::expr { ret f.node.expr; }\n \n fn field_exprs(fields: [ast::field]/~) -> [@ast::expr]/~ {\n     let mut es = []/~;\n-    for fields.each {|f| es += [f.node.expr]/~; }\n+    for fields.each {|f| vec::push(es, f.node.expr); }\n     ret es;\n }\n "}]}