{"sha": "955450212aac9c2babd6cb511974092224fcf93d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NTQ1MDIxMmFhYzljMmJhYmQ2Y2I1MTE5NzQwOTIyMjRmY2Y5M2Q=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-05T16:02:52Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-11T22:13:52Z"}, "message": "Move char decoding iterators into a separate private module.", "tree": {"sha": "d9e5c468f1fa0b1128347ac3a10f83bd2031f7a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9e5c468f1fa0b1128347ac3a10f83bd2031f7a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/955450212aac9c2babd6cb511974092224fcf93d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/955450212aac9c2babd6cb511974092224fcf93d", "html_url": "https://github.com/rust-lang/rust/commit/955450212aac9c2babd6cb511974092224fcf93d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/955450212aac9c2babd6cb511974092224fcf93d/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "939692409da499ff3d498eae782620435f16a981", "url": "https://api.github.com/repos/rust-lang/rust/commits/939692409da499ff3d498eae782620435f16a981", "html_url": "https://github.com/rust-lang/rust/commit/939692409da499ff3d498eae782620435f16a981"}], "stats": {"total": 514, "additions": 265, "deletions": 249}, "files": [{"sha": "48b531104f8829f4986ccc56985a486e31d789fc", "filename": "src/libcore/char/decode.rs", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/955450212aac9c2babd6cb511974092224fcf93d/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955450212aac9c2babd6cb511974092224fcf93d/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=955450212aac9c2babd6cb511974092224fcf93d", "patch": "@@ -0,0 +1,259 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! UTF-8 and UTF-16 decoding iterators\n+\n+use fmt;\n+use iter::FusedIterator;\n+use super::from_u32_unchecked;\n+\n+/// An iterator over an iterator of bytes of the characters the bytes represent\n+/// as UTF-8\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+#[derive(Clone, Debug)]\n+pub struct DecodeUtf8<I: Iterator<Item = u8>>(::iter::Peekable<I>);\n+\n+/// Decodes an `Iterator` of bytes as UTF-8.\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+#[inline]\n+pub fn decode_utf8<I: IntoIterator<Item = u8>>(i: I) -> DecodeUtf8<I::IntoIter> {\n+    DecodeUtf8(i.into_iter().peekable())\n+}\n+\n+/// `<DecodeUtf8 as Iterator>::next` returns this for an invalid input sequence.\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+#[derive(PartialEq, Eq, Debug)]\n+pub struct InvalidSequence(());\n+\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+impl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n+    type Item = Result<char, InvalidSequence>;\n+    #[inline]\n+\n+    fn next(&mut self) -> Option<Result<char, InvalidSequence>> {\n+        self.0.next().map(|first_byte| {\n+            // Emit InvalidSequence according to\n+            // Unicode \u00a75.22 Best Practice for U+FFFD Substitution\n+            // http://www.unicode.org/versions/Unicode9.0.0/ch05.pdf#G40630\n+\n+            // Roughly: consume at least one byte,\n+            // then validate one byte at a time and stop before the first unexpected byte\n+            // (which might be the valid start of the next byte sequence).\n+\n+            let mut code_point;\n+            macro_rules! first_byte {\n+                ($mask: expr) => {\n+                    code_point = u32::from(first_byte & $mask)\n+                }\n+            }\n+            macro_rules! continuation_byte {\n+                () => { continuation_byte!(0x80...0xBF) };\n+                ($range: pat) => {\n+                    match self.0.peek() {\n+                        Some(&byte @ $range) => {\n+                            code_point = (code_point << 6) | u32::from(byte & 0b0011_1111);\n+                            self.0.next();\n+                        }\n+                        _ => return Err(InvalidSequence(()))\n+                    }\n+                }\n+            }\n+\n+            match first_byte {\n+                0x00...0x7F => {\n+                    first_byte!(0b1111_1111);\n+                }\n+                0xC2...0xDF => {\n+                    first_byte!(0b0001_1111);\n+                    continuation_byte!();\n+                }\n+                0xE0 => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!(0xA0...0xBF);  // 0x80...0x9F here are overlong\n+                    continuation_byte!();\n+                }\n+                0xE1...0xEC | 0xEE...0xEF => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xED => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!(0x80...0x9F);  // 0xA0..0xBF here are surrogates\n+                    continuation_byte!();\n+                }\n+                0xF0 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!(0x90...0xBF);  // 0x80..0x8F here are overlong\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xF1...0xF3 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xF4 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!(0x80...0x8F);  // 0x90..0xBF here are beyond char::MAX\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                _ => return Err(InvalidSequence(()))  // Illegal first byte, overlong, or beyond MAX\n+            }\n+            unsafe {\n+                Ok(from_u32_unchecked(code_point))\n+            }\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.0.size_hint();\n+\n+        // A code point is at most 4 bytes long.\n+        let min_code_points = lower / 4;\n+\n+        (min_code_points, upper)\n+    }\n+}\n+\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+impl<I: FusedIterator<Item = u8>> FusedIterator for DecodeUtf8<I> {}\n+\n+/// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+#[derive(Clone, Debug)]\n+pub struct DecodeUtf16<I>\n+    where I: Iterator<Item = u16>\n+{\n+    iter: I,\n+    buf: Option<u16>,\n+}\n+\n+/// An error that can be returned when decoding UTF-16 code points.\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct DecodeUtf16Error {\n+    code: u16,\n+}\n+\n+/// Create an iterator over the UTF-16 encoded code points in `iter`,\n+/// returning unpaired surrogates as `Err`s.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::char::decode_utf16;\n+///\n+/// fn main() {\n+///     // \ud834\udd1emus<invalid>ic<invalid>\n+///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///              0x0073, 0xDD1E, 0x0069, 0x0063,\n+///              0xD834];\n+///\n+///     assert_eq!(decode_utf16(v.iter().cloned())\n+///                            .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n+///                            .collect::<Vec<_>>(),\n+///                vec![Ok('\ud834\udd1e'),\n+///                     Ok('m'), Ok('u'), Ok('s'),\n+///                     Err(0xDD1E),\n+///                     Ok('i'), Ok('c'),\n+///                     Err(0xD834)]);\n+/// }\n+/// ```\n+///\n+/// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n+///\n+/// ```\n+/// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n+///\n+/// fn main() {\n+///     // \ud834\udd1emus<invalid>ic<invalid>\n+///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///              0x0073, 0xDD1E, 0x0069, 0x0063,\n+///              0xD834];\n+///\n+///     assert_eq!(decode_utf16(v.iter().cloned())\n+///                    .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n+///                    .collect::<String>(),\n+///                \"\ud834\udd1emus\ufffdic\ufffd\");\n+/// }\n+/// ```\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+#[inline]\n+pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n+    DecodeUtf16 {\n+        iter: iter.into_iter(),\n+        buf: None,\n+    }\n+}\n+\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+impl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n+    type Item = Result<char, DecodeUtf16Error>;\n+\n+    fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n+        let u = match self.buf.take() {\n+            Some(buf) => buf,\n+            None => self.iter.next()?\n+        };\n+\n+        if u < 0xD800 || 0xDFFF < u {\n+            // not a surrogate\n+            Some(Ok(unsafe { from_u32_unchecked(u as u32) }))\n+        } else if u >= 0xDC00 {\n+            // a trailing surrogate\n+            Some(Err(DecodeUtf16Error { code: u }))\n+        } else {\n+            let u2 = match self.iter.next() {\n+                Some(u2) => u2,\n+                // eof\n+                None => return Some(Err(DecodeUtf16Error { code: u })),\n+            };\n+            if u2 < 0xDC00 || u2 > 0xDFFF {\n+                // not a trailing surrogate so we're not a valid\n+                // surrogate pair, so rewind to redecode u2 next time.\n+                self.buf = Some(u2);\n+                return Some(Err(DecodeUtf16Error { code: u }));\n+            }\n+\n+            // all ok, so lets decode it.\n+            let c = (((u - 0xD800) as u32) << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n+            Some(Ok(unsafe { from_u32_unchecked(c) }))\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (low, high) = self.iter.size_hint();\n+        // we could be entirely valid surrogates (2 elements per\n+        // char), or entirely non-surrogates (1 element per char)\n+        (low / 2, high)\n+    }\n+}\n+\n+impl DecodeUtf16Error {\n+    /// Returns the unpaired surrogate which caused this error.\n+    #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+    pub fn unpaired_surrogate(&self) -> u16 {\n+        self.code\n+    }\n+}\n+\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+impl fmt::Display for DecodeUtf16Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"unpaired surrogate found: {:x}\", self.code)\n+    }\n+}"}, {"sha": "388bc47750d66f736c99d220f285ee91ff0eb9af", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 6, "deletions": 120, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/955450212aac9c2babd6cb511974092224fcf93d/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955450212aac9c2babd6cb511974092224fcf93d/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=955450212aac9c2babd6cb511974092224fcf93d", "patch": "@@ -15,19 +15,22 @@\n #![allow(non_snake_case)]\n #![stable(feature = \"core_char\", since = \"1.2.0\")]\n \n+mod printable;\n+mod decode;\n+\n // stable re-exports\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use unicode::char::{ToLowercase, ToUppercase};\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-pub use unicode::char::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n+pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n \n // unstable re-exports\n #[unstable(feature = \"unicode\", issue = \"27783\")]\n pub use unicode::tables::{UNICODE_VERSION};\n #[unstable(feature = \"unicode\", issue = \"27783\")]\n pub use unicode::version::UnicodeVersion;\n-\n-mod printable;\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+pub use self::decode::{decode_utf8, DecodeUtf8, InvalidSequence};\n \n use self::printable::is_printable;\n use convert::TryFrom;\n@@ -821,120 +824,3 @@ impl fmt::Display for EscapeDebug {\n         fmt::Display::fmt(&self.0, f)\n     }\n }\n-\n-\n-\n-/// An iterator over an iterator of bytes of the characters the bytes represent\n-/// as UTF-8\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[derive(Clone, Debug)]\n-pub struct DecodeUtf8<I: Iterator<Item = u8>>(::iter::Peekable<I>);\n-\n-/// Decodes an `Iterator` of bytes as UTF-8.\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[inline]\n-pub fn decode_utf8<I: IntoIterator<Item = u8>>(i: I) -> DecodeUtf8<I::IntoIter> {\n-    DecodeUtf8(i.into_iter().peekable())\n-}\n-\n-/// `<DecodeUtf8 as Iterator>::next` returns this for an invalid input sequence.\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[derive(PartialEq, Eq, Debug)]\n-pub struct InvalidSequence(());\n-\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-impl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n-    type Item = Result<char, InvalidSequence>;\n-    #[inline]\n-\n-    fn next(&mut self) -> Option<Result<char, InvalidSequence>> {\n-        self.0.next().map(|first_byte| {\n-            // Emit InvalidSequence according to\n-            // Unicode \u00a75.22 Best Practice for U+FFFD Substitution\n-            // http://www.unicode.org/versions/Unicode9.0.0/ch05.pdf#G40630\n-\n-            // Roughly: consume at least one byte,\n-            // then validate one byte at a time and stop before the first unexpected byte\n-            // (which might be the valid start of the next byte sequence).\n-\n-            let mut code_point;\n-            macro_rules! first_byte {\n-                ($mask: expr) => {\n-                    code_point = u32::from(first_byte & $mask)\n-                }\n-            }\n-            macro_rules! continuation_byte {\n-                () => { continuation_byte!(0x80...0xBF) };\n-                ($range: pat) => {\n-                    match self.0.peek() {\n-                        Some(&byte @ $range) => {\n-                            code_point = (code_point << 6) | u32::from(byte & 0b0011_1111);\n-                            self.0.next();\n-                        }\n-                        _ => return Err(InvalidSequence(()))\n-                    }\n-                }\n-            }\n-\n-            match first_byte {\n-                0x00...0x7F => {\n-                    first_byte!(0b1111_1111);\n-                }\n-                0xC2...0xDF => {\n-                    first_byte!(0b0001_1111);\n-                    continuation_byte!();\n-                }\n-                0xE0 => {\n-                    first_byte!(0b0000_1111);\n-                    continuation_byte!(0xA0...0xBF);  // 0x80...0x9F here are overlong\n-                    continuation_byte!();\n-                }\n-                0xE1...0xEC | 0xEE...0xEF => {\n-                    first_byte!(0b0000_1111);\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                0xED => {\n-                    first_byte!(0b0000_1111);\n-                    continuation_byte!(0x80...0x9F);  // 0xA0..0xBF here are surrogates\n-                    continuation_byte!();\n-                }\n-                0xF0 => {\n-                    first_byte!(0b0000_0111);\n-                    continuation_byte!(0x90...0xBF);  // 0x80..0x8F here are overlong\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                0xF1...0xF3 => {\n-                    first_byte!(0b0000_0111);\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                0xF4 => {\n-                    first_byte!(0b0000_0111);\n-                    continuation_byte!(0x80...0x8F);  // 0x90..0xBF here are beyond char::MAX\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                _ => return Err(InvalidSequence(()))  // Illegal first byte, overlong, or beyond MAX\n-            }\n-            unsafe {\n-                Ok(from_u32_unchecked(code_point))\n-            }\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (lower, upper) = self.0.size_hint();\n-\n-        // A code point is at most 4 bytes long.\n-        let min_code_points = lower / 4;\n-\n-        (min_code_points, upper)\n-    }\n-}\n-\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-impl<I: FusedIterator<Item = u8>> FusedIterator for DecodeUtf8<I> {}"}, {"sha": "fda1914a50f1b8c30095ebfe6b6e701d96b083c2", "filename": "src/libcore/unicode/char.rs", "status": "modified", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/955450212aac9c2babd6cb511974092224fcf93d/src%2Flibcore%2Funicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955450212aac9c2babd6cb511974092224fcf93d/src%2Flibcore%2Funicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fchar.rs?ref=955450212aac9c2babd6cb511974092224fcf93d", "patch": "@@ -1435,132 +1435,3 @@ impl char {\n         self.is_ascii() && (*self as u8).is_ascii_control()\n     }\n }\n-\n-/// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n-#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-#[derive(Clone, Debug)]\n-pub struct DecodeUtf16<I>\n-    where I: Iterator<Item = u16>\n-{\n-    iter: I,\n-    buf: Option<u16>,\n-}\n-\n-/// An error that can be returned when decoding UTF-16 code points.\n-#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct DecodeUtf16Error {\n-    code: u16,\n-}\n-\n-/// Create an iterator over the UTF-16 encoded code points in `iter`,\n-/// returning unpaired surrogates as `Err`s.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char::decode_utf16;\n-///\n-/// fn main() {\n-///     // \ud834\udd1emus<invalid>ic<invalid>\n-///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///              0x0073, 0xDD1E, 0x0069, 0x0063,\n-///              0xD834];\n-///\n-///     assert_eq!(decode_utf16(v.iter().cloned())\n-///                            .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n-///                            .collect::<Vec<_>>(),\n-///                vec![Ok('\ud834\udd1e'),\n-///                     Ok('m'), Ok('u'), Ok('s'),\n-///                     Err(0xDD1E),\n-///                     Ok('i'), Ok('c'),\n-///                     Err(0xD834)]);\n-/// }\n-/// ```\n-///\n-/// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n-///\n-/// ```\n-/// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n-///\n-/// fn main() {\n-///     // \ud834\udd1emus<invalid>ic<invalid>\n-///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///              0x0073, 0xDD1E, 0x0069, 0x0063,\n-///              0xD834];\n-///\n-///     assert_eq!(decode_utf16(v.iter().cloned())\n-///                    .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n-///                    .collect::<String>(),\n-///                \"\ud834\udd1emus\ufffdic\ufffd\");\n-/// }\n-/// ```\n-#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-#[inline]\n-pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n-    DecodeUtf16 {\n-        iter: iter.into_iter(),\n-        buf: None,\n-    }\n-}\n-\n-#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-impl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n-    type Item = Result<char, DecodeUtf16Error>;\n-\n-    fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n-        let u = match self.buf.take() {\n-            Some(buf) => buf,\n-            None => self.iter.next()?\n-        };\n-\n-        if u < 0xD800 || 0xDFFF < u {\n-            // not a surrogate\n-            Some(Ok(unsafe { from_u32_unchecked(u as u32) }))\n-        } else if u >= 0xDC00 {\n-            // a trailing surrogate\n-            Some(Err(DecodeUtf16Error { code: u }))\n-        } else {\n-            let u2 = match self.iter.next() {\n-                Some(u2) => u2,\n-                // eof\n-                None => return Some(Err(DecodeUtf16Error { code: u })),\n-            };\n-            if u2 < 0xDC00 || u2 > 0xDFFF {\n-                // not a trailing surrogate so we're not a valid\n-                // surrogate pair, so rewind to redecode u2 next time.\n-                self.buf = Some(u2);\n-                return Some(Err(DecodeUtf16Error { code: u }));\n-            }\n-\n-            // all ok, so lets decode it.\n-            let c = (((u - 0xD800) as u32) << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n-            Some(Ok(unsafe { from_u32_unchecked(c) }))\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (low, high) = self.iter.size_hint();\n-        // we could be entirely valid surrogates (2 elements per\n-        // char), or entirely non-surrogates (1 element per char)\n-        (low / 2, high)\n-    }\n-}\n-\n-impl DecodeUtf16Error {\n-    /// Returns the unpaired surrogate which caused this error.\n-    #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-    pub fn unpaired_surrogate(&self) -> u16 {\n-        self.code\n-    }\n-}\n-\n-#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-impl fmt::Display for DecodeUtf16Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"unpaired surrogate found: {:x}\", self.code)\n-    }\n-}"}]}