{"sha": "5aaaca0c6a837ef60260b07121f4b4c4984afc70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYWFjYTBjNmE4MzdlZjYwMjYwYjA3MTIxZjRiNGM0OTg0YWZjNzA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-22T00:20:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-26T16:53:03Z"}, "message": "Consolidate raw representations of rust values\n\nThis moves the raw struct layout of closures, vectors, boxes, and strings into a\nnew `unstable::raw` module. This is meant to be a centralized location to find\ninformation for the layout of these values.\n\nAs safe method, `repr`, is provided to convert a rust value to its raw\nrepresentation. Unsafe methods to convert back are not provided because they are\nrarely used and too numerous to write an implementation for each (not much of a\ncommon pattern).", "tree": {"sha": "69fd81f9f8669b681f5cb8d7382485045b96539d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69fd81f9f8669b681f5cb8d7382485045b96539d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5aaaca0c6a837ef60260b07121f4b4c4984afc70", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5aaaca0c6a837ef60260b07121f4b4c4984afc70", "html_url": "https://github.com/rust-lang/rust/commit/5aaaca0c6a837ef60260b07121f4b4c4984afc70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5aaaca0c6a837ef60260b07121f4b4c4984afc70/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fd23e4fe26bc9d6eef9596593ba3ddbe83f4a10", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fd23e4fe26bc9d6eef9596593ba3ddbe83f4a10", "html_url": "https://github.com/rust-lang/rust/commit/7fd23e4fe26bc9d6eef9596593ba3ddbe83f4a10"}], "stats": {"total": 477, "additions": 239, "deletions": 238}, "files": [{"sha": "0b2519e6fb45fae19e84a27e0131bf1a350bbbcc", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -10,13 +10,13 @@\n \n //! Managed vectors\n \n-use cast::transmute;\n use clone::Clone;\n use container::Container;\n use iterator::IteratorUtil;\n use option::Option;\n use sys;\n use uint;\n+use unstable::raw::Repr;\n use vec::{ImmutableVector, OwnedVector};\n \n /// Code for dealing with @-vectors. This is pretty incomplete, and\n@@ -26,8 +26,8 @@ use vec::{ImmutableVector, OwnedVector};\n #[inline]\n pub fn capacity<T>(v: @[T]) -> uint {\n     unsafe {\n-        let repr: **raw::VecRepr = transmute(&v);\n-        (**repr).unboxed.alloc / sys::size_of::<T>()\n+        let box = v.repr();\n+        (*box).data.alloc / sys::size_of::<T>()\n     }\n }\n \n@@ -45,10 +45,10 @@ pub fn capacity<T>(v: @[T]) -> uint {\n  */\n #[inline]\n pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> @[A] {\n-    let mut vec: @[A] = @[];\n+    let mut vec = @[];\n     unsafe { raw::reserve(&mut vec, size); }\n     builder(|x| unsafe { raw::push(&mut vec, x) });\n-    return unsafe { transmute(vec) };\n+    vec\n }\n \n /**\n@@ -151,7 +151,7 @@ pub fn to_managed_consume<T>(v: ~[T]) -> @[T] {\n         for v.consume_iter().advance |x| {\n             raw::push(&mut av, x);\n         }\n-        transmute(av)\n+        av\n     }\n }\n \n@@ -195,13 +195,9 @@ pub mod raw {\n     use ptr;\n     use sys;\n     use uint;\n-    use unstable::intrinsics;\n     use unstable::intrinsics::{move_val_init, TyDesc};\n-    use vec;\n-    use vec::UnboxedVecRepr;\n-\n-    pub type VecRepr = vec::raw::VecRepr;\n-    pub type SliceRepr = vec::raw::SliceRepr;\n+    use unstable::intrinsics;\n+    use unstable::raw::{Box, Vec};\n \n     /**\n      * Sets the length of a vector\n@@ -211,19 +207,21 @@ pub mod raw {\n      * the vector is actually the specified size.\n      */\n     #[inline]\n-    pub unsafe fn set_len<T>(v: @[T], new_len: uint) {\n-        let repr: **mut VecRepr = transmute(&v);\n-        (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n+    pub unsafe fn set_len<T>(v: &mut @[T], new_len: uint) {\n+        let repr: *mut Box<Vec<T>> = cast::transmute_copy(v);\n+        (*repr).data.fill = new_len * sys::size_of::<T>();\n     }\n \n     /**\n      * Pushes a new value onto this vector.\n      */\n     #[inline]\n     pub unsafe fn push<T>(v: &mut @[T], initval: T) {\n-        let repr: **VecRepr = transmute_copy(&v);\n-        let fill = (**repr).unboxed.fill;\n-        if (**repr).unboxed.alloc > fill {\n+        let full = {\n+            let repr: *Box<Vec<T>> = cast::transmute_copy(v);\n+            (*repr).data.alloc > (*repr).data.fill\n+        };\n+        if full {\n             push_fast(v, initval);\n         } else {\n             push_slow(v, initval);\n@@ -232,16 +230,15 @@ pub mod raw {\n \n     #[inline] // really pretty please\n     unsafe fn push_fast<T>(v: &mut @[T], initval: T) {\n-        let repr: **mut VecRepr = ::cast::transmute(v);\n-        let fill = (**repr).unboxed.fill;\n-        (**repr).unboxed.fill += sys::size_of::<T>();\n-        let p = &((**repr).unboxed.data);\n-        let p = ptr::offset(p, fill) as *mut T;\n+        let repr: *mut Box<Vec<T>> = cast::transmute_copy(v);\n+        let amt = v.len();\n+        (*repr).data.fill += sys::size_of::<T>();\n+        let p = ptr::offset(&(*repr).data.data as *T, amt) as *mut T;\n         move_val_init(&mut(*p), initval);\n     }\n \n     unsafe fn push_slow<T>(v: &mut @[T], initval: T) {\n-        reserve_at_least(&mut *v, v.len() + 1u);\n+        reserve_at_least(v, v.len() + 1u);\n         push_fast(v, initval);\n     }\n \n@@ -259,7 +256,7 @@ pub mod raw {\n     pub unsafe fn reserve<T>(v: &mut @[T], n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n         if capacity(*v) < n {\n-            let ptr: *mut *mut VecRepr = transmute(v);\n+            let ptr: *mut *mut Box<Vec<()>> = transmute(v);\n             let ty = intrinsics::get_tydesc::<T>();\n             // XXX transmute shouldn't be necessary\n             let ty = cast::transmute(ty);\n@@ -269,16 +266,14 @@ pub mod raw {\n \n     // Implementation detail. Shouldn't be public\n     #[allow(missing_doc)]\n-    pub fn reserve_raw(ty: *TyDesc, ptr: *mut *mut VecRepr, n: uint) {\n+    pub fn reserve_raw(ty: *TyDesc, ptr: *mut *mut Box<Vec<()>>, n: uint) {\n \n         unsafe {\n             let size_in_bytes = n * (*ty).size;\n-            if size_in_bytes > (**ptr).unboxed.alloc {\n-                let total_size = size_in_bytes + sys::size_of::<UnboxedVecRepr>();\n-                // XXX: UnboxedVecRepr has an extra u8 at the end\n-                let total_size = total_size - sys::size_of::<u8>();\n-                (*ptr) = local_realloc(*ptr as *(), total_size) as *mut VecRepr;\n-                (**ptr).unboxed.alloc = size_in_bytes;\n+            if size_in_bytes > (**ptr).data.alloc {\n+                let total_size = size_in_bytes + sys::size_of::<Vec<()>>();\n+                (*ptr) = local_realloc(*ptr as *(), total_size) as *mut Box<Vec<()>>;\n+                (**ptr).data.alloc = size_in_bytes;\n             }\n         }\n "}, {"sha": "ee91d12790953214b49a0c25327a141e8cd03ee9", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -133,6 +133,7 @@ pub unsafe fn copy_lifetime_vec<'a,S,T>(_ptr: &'a [S], ptr: &T) -> &'a T {\n #[cfg(test)]\n mod tests {\n     use cast::{bump_box_refcount, transmute};\n+    use unstable::raw;\n \n     #[test]\n     fn test_transmute_copy() {\n@@ -156,10 +157,9 @@ mod tests {\n \n     #[test]\n     fn test_transmute() {\n-        use managed::raw::BoxRepr;\n         unsafe {\n             let x = @100u8;\n-            let x: *BoxRepr = transmute(x);\n+            let x: *raw::Box<u8> = transmute(x);\n             assert!((*x).data == 100);\n             let _x: @int = transmute(x);\n         }"}, {"sha": "ed2b0e1681817a38656d32e9eed232be016ea39a", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -12,8 +12,8 @@\n \n use libc::c_void;\n use ptr::{mut_null};\n-use repr::BoxRepr;\n use unstable::intrinsics::TyDesc;\n+use unstable::raw;\n \n type DropGlue<'self> = &'self fn(**TyDesc, *c_void);\n \n@@ -30,14 +30,13 @@ struct AnnihilateStats {\n }\n \n unsafe fn each_live_alloc(read_next_before: bool,\n-                          f: &fn(box: *mut BoxRepr, uniq: bool) -> bool) -> bool {\n+                          f: &fn(box: *mut raw::Box<()>, uniq: bool) -> bool) -> bool {\n     //! Walks the internal list of allocations\n \n     use managed;\n     use rt::local_heap;\n \n-    let box = local_heap::live_allocs();\n-    let mut box: *mut BoxRepr = transmute(box);\n+    let mut box = local_heap::live_allocs();\n     while box != mut_null() {\n         let next_before = (*box).next;\n         let uniq = (*box).ref_count == managed::RC_MANAGED_UNIQUE;\n@@ -100,7 +99,7 @@ pub unsafe fn annihilate() {\n         if uniq {\n             stats.n_unique_boxes += 1;\n         } else {\n-            (*box).header.ref_count = managed::raw::RC_IMMORTAL;\n+            (*box).ref_count = managed::RC_IMMORTAL;\n         }\n     }\n \n@@ -126,9 +125,9 @@ pub unsafe fn annihilate() {\n     for each_live_alloc(true) |box, uniq| {\n         if !uniq {\n             stats.n_bytes_freed +=\n-                (*((*box).header.type_desc)).size\n-                + sys::size_of::<BoxRepr>();\n-            local_free(box as *u8);\n+                (*((*box).type_desc)).size\n+                + sys::size_of::<raw::Box<()>>();\n+            local_free(box as *i8);\n         }\n     }\n "}, {"sha": "bd4dc69537cb10c9969e19c0b5dc942af3383197", "filename": "src/libstd/managed.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -14,27 +14,8 @@ use ptr::to_unsafe_ptr;\n \n #[cfg(not(test))] use cmp::{Eq, Ord};\n \n-pub mod raw {\n-    use std::unstable::intrinsics::TyDesc;\n-\n-    pub static RC_MANAGED_UNIQUE : uint = (-2) as uint;\n-    pub static RC_IMMORTAL : uint = 0x77777777;\n-\n-    #[allow(missing_doc)]\n-    pub struct BoxHeaderRepr {\n-        ref_count: uint,\n-        type_desc: *TyDesc,\n-        prev: *BoxRepr,\n-        next: *BoxRepr,\n-    }\n-\n-    #[allow(missing_doc)]\n-    pub struct BoxRepr {\n-        header: BoxHeaderRepr,\n-        data: u8\n-    }\n-\n-}\n+pub static RC_MANAGED_UNIQUE : uint = (-2) as uint;\n+pub static RC_IMMORTAL : uint = 0x77777777;\n \n /// Determine if two shared boxes point to the same object\n #[inline]"}, {"sha": "1d093c4c14b8b2a779ccbb74fdfadb3f56b91b2f", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -19,7 +19,7 @@ Runtime type reflection\n use unstable::intrinsics::{Opaque, TyDesc, TyVisitor};\n use libc::c_void;\n use sys;\n-use vec;\n+use unstable::raw;\n \n /**\n  * Trait for visitor that wishes to reflect on data. To use this, create a\n@@ -260,7 +260,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<vec::UnboxedVecRepr>();\n+        self.align_to::<raw::Vec<()>>();\n         if ! self.inner.visit_vec(mtbl, inner) { return false; }\n         true\n     }"}, {"sha": "eb4e1918add12797da6b6bfd33b78c907fb99f42", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -22,21 +22,17 @@ use container::Container;\n use io::{Writer, WriterUtil};\n use iterator::IteratorUtil;\n use libc::c_void;\n-use managed;\n use ptr;\n use reflect;\n use reflect::{MovePtr, align};\n use str::StrSlice;\n use to_str::ToStr;\n-use vec::raw::{VecRepr, SliceRepr};\n-use vec;\n-use vec::{OwnedVector, UnboxedVecRepr};\n+use vec::OwnedVector;\n use unstable::intrinsics::{Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n+use unstable::raw;\n \n #[cfg(test)] use io;\n \n-pub use managed::raw::BoxRepr;\n-\n /// Helpers\n \n trait EscapedCharWriter {\n@@ -198,11 +194,11 @@ impl ReprVisitor {\n \n     pub fn write_vec_range(&self,\n                            _mtbl: uint,\n-                           ptr: *u8,\n+                           ptr: *(),\n                            len: uint,\n                            inner: *TyDesc)\n                            -> bool {\n-        let mut p = ptr;\n+        let mut p = ptr as *u8;\n         let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n         self.writer.write_char('[');\n         let mut first = true;\n@@ -225,7 +221,7 @@ impl ReprVisitor {\n \n     pub fn write_unboxed_vec_repr(&self,\n                                   mtbl: uint,\n-                                  v: &UnboxedVecRepr,\n+                                  v: &raw::Vec<()>,\n                                   inner: *TyDesc)\n                                   -> bool {\n         self.write_vec_range(mtbl, ptr::to_unsafe_ptr(&v.data),\n@@ -289,7 +285,7 @@ impl TyVisitor for ReprVisitor {\n     fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write_char('@');\n         self.write_mut_qualifier(mtbl);\n-        do self.get::<&managed::raw::BoxRepr> |b| {\n+        do self.get::<&raw::Box<()>> |b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n             self.visit_ptr_inner(p, inner);\n         }\n@@ -304,7 +300,7 @@ impl TyVisitor for ReprVisitor {\n \n     fn visit_uniq_managed(&self, _mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write_char('~');\n-        do self.get::<&managed::raw::BoxRepr> |b| {\n+        do self.get::<&raw::Box<()>> |b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n             self.visit_ptr_inner(p, inner);\n         }\n@@ -330,43 +326,43 @@ impl TyVisitor for ReprVisitor {\n \n \n     fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<vec::UnboxedVecRepr> |b| {\n+        do self.get::<raw::Vec<()>> |b| {\n             self.write_unboxed_vec_repr(mtbl, b, inner);\n         }\n     }\n \n     fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&VecRepr> |b| {\n+        do self.get::<&raw::Box<raw::Vec<()>>> |b| {\n             self.writer.write_char('@');\n             self.write_mut_qualifier(mtbl);\n-            self.write_unboxed_vec_repr(mtbl, &b.unboxed, inner);\n+            self.write_unboxed_vec_repr(mtbl, &b.data, inner);\n         }\n     }\n \n     fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&UnboxedVecRepr> |b| {\n+        do self.get::<&raw::Vec<()>> |b| {\n             self.writer.write_char('~');\n             self.write_unboxed_vec_repr(mtbl, *b, inner);\n         }\n     }\n \n     fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&VecRepr> |b| {\n+        do self.get::<&raw::Box<raw::Vec<()>>> |b| {\n             self.writer.write_char('~');\n-            self.write_unboxed_vec_repr(mtbl, &b.unboxed, inner);\n+            self.write_unboxed_vec_repr(mtbl, &b.data, inner);\n         }\n     }\n \n     fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<SliceRepr> |s| {\n+        do self.get::<raw::Slice<()>> |s| {\n             self.writer.write_char('&');\n             self.write_vec_range(mtbl, s.data, s.len, inner);\n         }\n     }\n \n     fn visit_evec_fixed(&self, _n: uint, sz: uint, _align: uint,\n                         mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<u8> |b| {\n+        do self.get::<()> |b| {\n             self.write_vec_range(mtbl, ptr::to_unsafe_ptr(b), sz, inner);\n         }\n     }\n@@ -547,9 +543,9 @@ impl TyVisitor for ReprVisitor {\n \n     fn visit_opaque_box(&self) -> bool {\n         self.writer.write_char('@');\n-        do self.get::<&managed::raw::BoxRepr> |b| {\n+        do self.get::<&raw::Box<()>> |b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            self.visit_ptr_inner(p, b.header.type_desc);\n+            self.visit_ptr_inner(p, b.type_desc);\n         }\n     }\n "}, {"sha": "2d489e4dbc30c76ae2bd8830eb653e17c43b058c", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -12,12 +12,12 @@ use cast::transmute;\n use libc::{c_char, c_void, size_t, STDERR_FILENO};\n use io;\n use io::{Writer, WriterUtil};\n-use managed::raw::BoxRepr;\n use option::{Option, None, Some};\n use uint;\n use str;\n use str::{OwnedStr, StrSlice};\n use sys;\n+use unstable::raw;\n use vec::ImmutableVector;\n \n #[allow(non_camel_case_types)]\n@@ -29,7 +29,7 @@ static ALL_BITS: uint = FROZEN_BIT | MUT_BIT;\n \n #[deriving(Eq)]\n struct BorrowRecord {\n-    box: *mut BoxRepr,\n+    box: *mut raw::Box<()>,\n     file: *c_char,\n     line: size_t\n }\n@@ -70,7 +70,7 @@ pub unsafe fn clear_task_borrow_list() {\n     let _ = try_take_task_borrow_list();\n }\n \n-unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n+unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) {\n     debug_borrow(\"fail_borrowed: \", box, 0, 0, file, line);\n \n     match try_take_task_borrow_list() {\n@@ -172,8 +172,8 @@ impl DebugPrints for io::fd_t {\n \n #[inline]\n pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n-    let a: *mut BoxRepr = transmute(a);\n-    let old_ref_count = (*a).header.ref_count;\n+    let a = a as *mut raw::Box<()>;\n+    let old_ref_count = (*a).ref_count;\n     let new_ref_count = old_ref_count | FROZEN_BIT;\n \n     debug_borrow(\"borrow_as_imm:\", a, old_ref_count, new_ref_count, file, line);\n@@ -182,15 +182,15 @@ pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n         fail_borrowed(a, file, line);\n     }\n \n-    (*a).header.ref_count = new_ref_count;\n+    (*a).ref_count = new_ref_count;\n \n     old_ref_count\n }\n \n #[inline]\n pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n-    let a: *mut BoxRepr = transmute(a);\n-    let old_ref_count = (*a).header.ref_count;\n+    let a = a as *mut raw::Box<()>;\n+    let old_ref_count = (*a).ref_count;\n     let new_ref_count = old_ref_count | MUT_BIT | FROZEN_BIT;\n \n     debug_borrow(\"borrow_as_mut:\", a, old_ref_count, new_ref_count, file, line);\n@@ -199,7 +199,7 @@ pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n         fail_borrowed(a, file, line);\n     }\n \n-    (*a).header.ref_count = new_ref_count;\n+    (*a).ref_count = new_ref_count;\n \n     old_ref_count\n }\n@@ -208,7 +208,7 @@ pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n                             file: *c_char, line: size_t) {\n     if (old_ref_count & ALL_BITS) == 0 {\n         // was not borrowed before\n-        let a: *mut BoxRepr = transmute(a);\n+        let a = a as *mut raw::Box<()>;\n         debug_borrow(\"record_borrow:\", a, old_ref_count, 0, file, line);\n         do swap_task_borrow_list |borrow_list| {\n             let mut borrow_list = borrow_list;\n@@ -223,7 +223,7 @@ pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n     if (old_ref_count & ALL_BITS) == 0 {\n         // was not borrowed before, so we should find the record at\n         // the end of the list\n-        let a: *mut BoxRepr = transmute(a);\n+        let a = a as *mut raw::Box<()>;\n         debug_borrow(\"unrecord_borrow:\", a, old_ref_count, 0, file, line);\n         do swap_task_borrow_list |borrow_list| {\n             let mut borrow_list = borrow_list;\n@@ -246,24 +246,24 @@ pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n     // Sometimes the box is null, if it is conditionally frozen.\n     // See e.g. #4904.\n     if !a.is_null() {\n-        let a: *mut BoxRepr = transmute(a);\n-        let old_ref_count = (*a).header.ref_count;\n+        let a = a as *mut raw::Box<()>;\n+        let old_ref_count = (*a).ref_count;\n         let new_ref_count =\n             (old_ref_count & !ALL_BITS) | (orig_ref_count & ALL_BITS);\n \n         debug_borrow(\"return_to_mut:\",\n                      a, old_ref_count, new_ref_count, file, line);\n \n-        (*a).header.ref_count = new_ref_count;\n+        (*a).ref_count = new_ref_count;\n     }\n }\n \n #[inline]\n pub unsafe fn check_not_borrowed(a: *u8,\n                                  file: *c_char,\n                                  line: size_t) {\n-    let a: *mut BoxRepr = transmute(a);\n-    let ref_count = (*a).header.ref_count;\n+    let a = a as *mut raw::Box<()>;\n+    let ref_count = (*a).ref_count;\n     debug_borrow(\"check_not_borrowed:\", a, ref_count, 0, file, line);\n     if (ref_count & FROZEN_BIT) != 0 {\n         fail_borrowed(a, file, line);"}, {"sha": "7488b08da42c5d9777f1158e452bb446ec9ebe85", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use libc::{c_void, c_char, size_t, uintptr_t, free, malloc, realloc};\n-use managed::raw::{BoxHeaderRepr, BoxRepr};\n use unstable::intrinsics::TyDesc;\n+use unstable::raw;\n use sys::size_of;\n \n extern {\n@@ -20,7 +20,7 @@ extern {\n \n #[inline]\n fn get_box_size(body_size: uint, body_align: uint) -> uint {\n-    let header_size = size_of::<BoxHeaderRepr>();\n+    let header_size = size_of::<raw::Box<()>>();\n     // FIXME (#2699): This alignment calculation is suspicious. Is it right?\n     let total_size = align_to(header_size, body_align) + body_size;\n     total_size\n@@ -82,8 +82,8 @@ pub unsafe fn closure_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     let total_size = get_box_size(size, (*td).align);\n     let p = malloc_raw(total_size as uint);\n \n-    let box: *mut BoxRepr = p as *mut BoxRepr;\n-    (*box).header.type_desc = td;\n+    let box = p as *mut raw::Box<()>;\n+    (*box).type_desc = td;\n \n     box as *c_char\n }"}, {"sha": "cd8e8549211a785b2271e2936bf151b58509236b", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -13,11 +13,11 @@\n use libc;\n use libc::{c_void, uintptr_t, size_t};\n use ops::Drop;\n-use repr::BoxRepr;\n use rt;\n use rt::OldTaskContext;\n use rt::local::Local;\n use rt::task::Task;\n+use unstable::raw;\n \n type MemoryRegion = c_void;\n \n@@ -26,7 +26,7 @@ struct Env { priv opaque: () }\n struct BoxedRegion {\n     env: *Env,\n     backing_region: *MemoryRegion,\n-    live_allocs: *BoxRepr\n+    live_allocs: *raw::Box<()>,\n }\n \n pub type OpaqueBox = c_void;\n@@ -103,7 +103,7 @@ pub unsafe fn local_free(ptr: *libc::c_char) {\n     }\n }\n \n-pub fn live_allocs() -> *BoxRepr {\n+pub fn live_allocs() -> *raw::Box<()> {\n     let region = match rt::context() {\n         OldTaskContext => {\n             unsafe { rust_current_boxed_region() }"}, {"sha": "33cfd69fcd2f40aec4d9fb004148ab5b5212a1e5", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -10,9 +10,9 @@\n \n use either::{Left, Right};\n use option::{Option, Some, None};\n-use sys;\n use cast::transmute;\n use clone::Clone;\n+use unstable::raw;\n \n use super::sleeper_list::SleeperList;\n use super::work_queue::WorkQueue;\n@@ -698,7 +698,7 @@ impl SchedHandle {\n \n // XXX: Some hacks to put a &fn in Scheduler without borrowck\n // complaining\n-type UnsafeTaskReceiver = sys::Closure;\n+type UnsafeTaskReceiver = raw::Closure;\n trait ClosureConverter {\n     fn from_fn(&fn(&mut Scheduler, BlockedTask)) -> Self;\n     fn to_fn(self) -> &fn(&mut Scheduler, BlockedTask);"}, {"sha": "8cf864b9222ef6195a563df21b37b897d49f309f", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -281,7 +281,7 @@ static UNWIND_TOKEN: uintptr_t = 839147;\n \n impl Unwinder {\n     pub fn try(&mut self, f: &fn()) {\n-        use sys::Closure;\n+        use unstable::raw::Closure;\n \n         unsafe {\n             let closure: Closure = transmute(f);"}, {"sha": "c600e7f6c09836d58a8cded78a4f10d4955c8271", "filename": "src/libstd/str.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -31,6 +31,7 @@ use ptr;\n use ptr::RawPtr;\n use to_str::ToStr;\n use uint;\n+use unstable::raw::Repr;\n use vec;\n use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector, MutableVector};\n \n@@ -114,9 +115,9 @@ pub fn from_bytes_with_null<'a>(vv: &'a [u8]) -> &'a str {\n pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n     unsafe {\n         assert!(is_utf8(vector));\n-        let (ptr, len): (*u8, uint) = ::cast::transmute(vector);\n-        let string: &'a str = ::cast::transmute((ptr, len + 1));\n-        string\n+        let mut s = vector.repr();\n+        s.len += 1;\n+        cast::transmute(s)\n     }\n }\n \n@@ -142,7 +143,7 @@ impl ToStr for @str {\n  */\n pub fn from_byte(b: u8) -> ~str {\n     assert!(b < 128u8);\n-    unsafe { ::cast::transmute(~[b, 0u8]) }\n+    unsafe { cast::transmute(~[b, 0u8]) }\n }\n \n /// Convert a char to a string\n@@ -217,7 +218,7 @@ impl<'self, S: Str> StrVector for &'self [S] {\n             do s.as_mut_buf |buf, _| {\n                 do sep.as_imm_buf |sepbuf, seplen| {\n                     let seplen = seplen - 1;\n-                    let mut buf = ::cast::transmute_mut_unsafe(buf);\n+                    let mut buf = cast::transmute_mut_unsafe(buf);\n                     for self.iter().advance |ss| {\n                         do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n                             let sslen = sslen - 1;\n@@ -771,10 +772,10 @@ pub mod raw {\n     use cast;\n     use libc;\n     use ptr;\n-    use str::raw;\n-    use str::{is_utf8};\n+    use str::is_utf8;\n     use vec;\n     use vec::MutableVector;\n+    use unstable::raw::{Slice, String};\n \n     /// Create a Rust string from a null-terminated *u8 buffer\n     pub unsafe fn from_buf(buf: *u8) -> ~str {\n@@ -797,17 +798,17 @@ pub mod raw {\n         v.push(0u8);\n \n         assert!(is_utf8(v));\n-        return ::cast::transmute(v);\n+        return cast::transmute(v);\n     }\n \n     /// Create a Rust string from a null-terminated C string\n     pub unsafe fn from_c_str(c_str: *libc::c_char) -> ~str {\n-        from_buf(::cast::transmute(c_str))\n+        from_buf(c_str as *u8)\n     }\n \n     /// Create a Rust string from a `*c_char` buffer of the given length\n     pub unsafe fn from_c_str_len(c_str: *libc::c_char, len: uint) -> ~str {\n-        from_buf_len(::cast::transmute(c_str), len)\n+        from_buf_len(c_str as *u8, len)\n     }\n \n     /// Converts a vector of bytes to a new owned string.\n@@ -832,7 +833,7 @@ pub mod raw {\n     }\n \n     /// Converts a byte to a string.\n-    pub unsafe fn from_byte(u: u8) -> ~str { raw::from_bytes([u]) }\n+    pub unsafe fn from_byte(u: u8) -> ~str { from_bytes([u]) }\n \n     /// Form a slice from a C string. Unsafe because the caller must ensure the\n     /// C string has the static lifetime, or else the return value may be\n@@ -845,9 +846,9 @@ pub mod raw {\n             len += 1u;\n             curr = ptr::offset(s, len);\n         }\n-        let v = (s, len + 1);\n-        assert!(is_utf8(::cast::transmute(v)));\n-        ::cast::transmute(v)\n+        let v = Slice { data: s, len: len + 1 };\n+        assert!(is_utf8(cast::transmute(v)));\n+        cast::transmute(v)\n     }\n \n     /**\n@@ -866,8 +867,10 @@ pub mod raw {\n              assert!((begin <= end));\n              assert!((end <= n));\n \n-             let tuple = (ptr::offset(sbuf, begin), end - begin + 1);\n-             ::cast::transmute(tuple)\n+             cast::transmute(Slice {\n+                 data: ptr::offset(sbuf, begin),\n+                 len: end - begin + 1,\n+             })\n         }\n     }\n \n@@ -909,11 +912,10 @@ pub mod raw {\n     /// Sets the length of the string and adds the null terminator\n     #[inline]\n     pub unsafe fn set_len(v: &mut ~str, new_len: uint) {\n-        let v: **mut vec::UnboxedVecRepr = cast::transmute(v);\n-        let repr: *mut vec::UnboxedVecRepr = *v;\n+        let v: **mut String = cast::transmute(v);\n+        let repr = *v;\n         (*repr).fill = new_len + 1u;\n-        let null = ptr::mut_offset(cast::transmute(&((*repr).data)),\n-                                   new_len);\n+        let null = ptr::mut_offset(&mut ((*repr).data), new_len);\n         *null = 0u8;\n     }\n \n@@ -1595,7 +1597,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         let v = at_vec::from_fn(self.len() + 1, |i| {\n             if i == self.len() { 0 } else { self[i] }\n         });\n-        unsafe { ::cast::transmute(v) }\n+        unsafe { cast::transmute(v) }\n     }\n \n     /// Converts to a vector of `u16` encoded as UTF-16.\n@@ -1750,9 +1752,9 @@ impl<'self> StrSlice<'self> for &'self str {\n      */\n     fn as_bytes(&self) -> &'self [u8] {\n         unsafe {\n-            let (ptr, len): (*u8, uint) = ::cast::transmute(*self);\n-            let outgoing_tuple: (*u8, uint) = (ptr, len - 1);\n-            ::cast::transmute(outgoing_tuple)\n+            let mut slice = self.repr();\n+            slice.len -= 1;\n+            cast::transmute(slice)\n         }\n     }\n \n@@ -2001,7 +2003,7 @@ impl NullTerminatedStr for ~str {\n      */\n     #[inline]\n     fn as_bytes_with_null<'a>(&'a self) -> &'a [u8] {\n-        let ptr: &'a ~[u8] = unsafe { ::cast::transmute(self) };\n+        let ptr: &'a ~[u8] = unsafe { cast::transmute(self) };\n         let slice: &'a [u8] = *ptr;\n         slice\n     }\n@@ -2014,7 +2016,7 @@ impl NullTerminatedStr for @str {\n      */\n     #[inline]\n     fn as_bytes_with_null<'a>(&'a self) -> &'a [u8] {\n-        let ptr: &'a @[u8] = unsafe { ::cast::transmute(self) };\n+        let ptr: &'a @[u8] = unsafe { cast::transmute(self) };\n         let slice: &'a [u8] = *ptr;\n         slice\n     }\n@@ -2058,7 +2060,7 @@ impl OwnedStr for ~str {\n             do self.as_imm_buf |lbuf, _llen| {\n                 do rhs.as_imm_buf |rbuf, _rlen| {\n                     let dst = ptr::offset(lbuf, llen);\n-                    let dst = ::cast::transmute_mut_unsafe(dst);\n+                    let dst = cast::transmute_mut_unsafe(dst);\n                     ptr::copy_memory(dst, rbuf, rlen);\n                 }\n             }\n@@ -2076,7 +2078,7 @@ impl OwnedStr for ~str {\n             do self.as_imm_buf |lbuf, _llen| {\n                 do rhs.as_imm_buf |rbuf, _rlen| {\n                     let dst = ptr::offset(lbuf, llen);\n-                    let dst = ::cast::transmute_mut_unsafe(dst);\n+                    let dst = cast::transmute_mut_unsafe(dst);\n                     ptr::copy_memory(dst, rbuf, rlen);\n                 }\n             }\n@@ -2232,7 +2234,7 @@ impl OwnedStr for ~str {\n     /// string, and includes the null terminator.\n     #[inline]\n     fn to_bytes_with_null(self) -> ~[u8] {\n-        unsafe { ::cast::transmute(self) }\n+        unsafe { cast::transmute(self) }\n     }\n \n     #[inline]"}, {"sha": "5cf77d901db4ce0c469e3a10ad8d64a69c6c999f", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -22,12 +22,6 @@ use str::StrSlice;\n use str;\n use unstable::intrinsics;\n \n-/// The representation of a Rust closure\n-pub struct Closure {\n-    code: *(),\n-    env: *(),\n-}\n-\n pub mod rustrt {\n     use libc::{c_char, size_t};\n \n@@ -278,6 +272,7 @@ mod tests {\n \n     #[test]\n     fn synthesize_closure() {\n+        use unstable::raw::Closure;\n         unsafe {\n             let x = 10;\n             let f: &fn(int) -> int = |y| x + y;"}, {"sha": "477981c65e515f0769587c015df4b920d69ed823", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -15,8 +15,8 @@ use libc;\n use local_data;\n use prelude::*;\n use ptr;\n-use sys;\n use task::rt;\n+use unstable::raw;\n use util;\n \n use super::rt::rust_task;\n@@ -158,7 +158,7 @@ unsafe fn get_local_map(handle: Handle) -> &mut TaskLocalMap {\n }\n \n unsafe fn key_to_key_value<T: 'static>(key: local_data::Key<T>) -> *libc::c_void {\n-    let pair: sys::Closure = cast::transmute_copy(&key);\n+    let pair: raw::Closure = cast::transmute_copy(&key);\n     return pair.code as *libc::c_void;\n }\n "}, {"sha": "0d8cb1e8f743da2a45001096993d3763fcb4c162", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -26,6 +26,7 @@ pub mod extfmt;\n pub mod lang;\n pub mod sync;\n pub mod atomics;\n+pub mod raw;\n \n /**\n "}, {"sha": "0e074b53d6b4b88aa6a61356d68245b608da80d7", "filename": "src/libstd/unstable/raw.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast;\n+use unstable::intrinsics::TyDesc;\n+\n+/// The representation of a Rust managed box\n+pub struct Box<T> {\n+    ref_count: uint,\n+    type_desc: *TyDesc,\n+    prev: *Box<T>,\n+    next: *Box<T>,\n+    data: T\n+}\n+\n+/// The representation of a Rust vector\n+pub struct Vec<T> {\n+    fill: uint,\n+    alloc: uint,\n+    data: T\n+}\n+\n+/// The representation of a Rust string\n+pub type String = Vec<u8>;\n+\n+/// The representation of a Rust slice\n+pub struct Slice<T> {\n+    data: *T,\n+    len: uint\n+}\n+\n+/// The representation of a Rust closure\n+pub struct Closure {\n+    code: *(),\n+    env: *(),\n+}\n+\n+/// This trait is meant to map equivalences between raw structs and their\n+/// corresponding rust values.\n+pub trait Repr<T> {\n+    /// This function \"unwraps\" a rust value (without consuming it) into its raw\n+    /// struct representation. This can be used to read/write different values\n+    /// for the struct. This is a safe method because by default it does not\n+    /// give write-access to the struct returned.\n+    fn repr(&self) -> T { unsafe { cast::transmute_copy(self) } }\n+}\n+\n+impl<'self, T> Repr<Slice<T>> for &'self [T] {}\n+impl<'self> Repr<Slice<u8>> for &'self str {}\n+impl<T> Repr<*Box<T>> for @T {}\n+impl<T> Repr<*Box<Vec<T>>> for @[T] {}\n+\n+// sure would be nice to have this\n+// impl<T> Repr<*Vec<T>> for ~[T] {}"}, {"sha": "87ac4037e8ebeed92b1726fe32e283bf446fb926", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 58, "deletions": 87, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -12,7 +12,6 @@\n \n #[warn(non_camel_case_types)];\n \n-use cast::transmute;\n use cast;\n use clone::Clone;\n use container::{Container, Mutable};\n@@ -32,6 +31,7 @@ use sys::size_of;\n use uint;\n use unstable::intrinsics;\n use unstable::intrinsics::{get_tydesc, contains_managed};\n+use unstable::raw::{Box, Repr, Slice, Vec};\n use vec;\n use util;\n \n@@ -96,7 +96,7 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n             vec\n         } else {\n             let alloc = capacity * sys::nonzero_size_of::<T>();\n-            let ptr = malloc_raw(alloc + sys::size_of::<UnboxedVecRepr>()) as *mut UnboxedVecRepr;\n+            let ptr = malloc_raw(alloc + sys::size_of::<Vec<()>>()) as *mut Vec<()>;\n             (*ptr).alloc = alloc;\n             (*ptr).fill = 0;\n             cast::transmute(ptr)\n@@ -736,8 +736,10 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         assert!(end <= self.len());\n         do self.as_imm_buf |p, _len| {\n             unsafe {\n-                transmute((ptr::offset(p, start),\n-                           (end - start) * sys::nonzero_size_of::<T>()))\n+                cast::transmute(Slice {\n+                    data: ptr::offset(p, start),\n+                    len: (end - start) * sys::nonzero_size_of::<T>(),\n+                })\n             }\n         }\n     }\n@@ -767,8 +769,8 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         unsafe {\n             let p = vec::raw::to_ptr(self);\n             VecIterator{ptr: p,\n-                        end: cast::transmute(p as uint + self.len() *\n-                                             sys::nonzero_size_of::<T>()),\n+                        end: (p as uint + self.len() *\n+                              sys::nonzero_size_of::<T>()) as *T,\n                         lifetime: cast::transmute(p)}\n         }\n     }\n@@ -947,8 +949,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     /// bounds checking.\n     #[inline]\n     unsafe fn unsafe_ref(&self, index: uint) -> *T {\n-        let (ptr, _): (*T, uint) = transmute(*self);\n-        ptr.offset(index)\n+        self.repr().data.offset(index)\n     }\n \n     /**\n@@ -1002,11 +1003,8 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         // into `s` and pass them to `f()`, but in fact they are potentially\n         // pointing at *mutable memory*.  Use `as_mut_buf` instead!\n \n-        unsafe {\n-            let v : *(*T,uint) = transmute(self);\n-            let (buf,len) = *v;\n-            f(buf, len / sys::nonzero_size_of::<T>())\n-        }\n+        let s = self.repr();\n+        f(s.data, s.len / sys::nonzero_size_of::<T>())\n     }\n }\n \n@@ -1158,17 +1156,17 @@ impl<T> OwnedVector<T> for ~[T] {\n             unsafe {\n                 let td = get_tydesc::<T>();\n                 if contains_managed::<T>() {\n-                    let ptr: *mut *mut raw::VecRepr = cast::transmute(self);\n+                    let ptr: *mut *mut Box<Vec<()>> = cast::transmute(self);\n                     ::at_vec::raw::reserve_raw(td, ptr, n);\n                 } else {\n-                    let ptr: *mut *mut UnboxedVecRepr = cast::transmute(self);\n+                    let ptr: *mut *mut Vec<()> = cast::transmute(self);\n                     let alloc = n * sys::nonzero_size_of::<T>();\n-                    let size = alloc + sys::size_of::<UnboxedVecRepr>();\n+                    let size = alloc + sys::size_of::<Vec<()>>();\n                     if alloc / sys::nonzero_size_of::<T>() != n || size < alloc {\n                         fail!(\"vector size is too large: %u\", n);\n                     }\n                     *ptr = realloc_raw(*ptr as *mut c_void, size)\n-                           as *mut UnboxedVecRepr;\n+                           as *mut Vec<()>;\n                     (**ptr).alloc = alloc;\n                 }\n             }\n@@ -1198,10 +1196,10 @@ impl<T> OwnedVector<T> for ~[T] {\n     fn capacity(&self) -> uint {\n         unsafe {\n             if contains_managed::<T>() {\n-                let repr: **raw::VecRepr = transmute(self);\n-                (**repr).unboxed.alloc / sys::nonzero_size_of::<T>()\n+                let repr: **Box<Vec<()>> = cast::transmute(self);\n+                (**repr).data.alloc / sys::nonzero_size_of::<T>()\n             } else {\n-                let repr: **UnboxedVecRepr = transmute(self);\n+                let repr: **Vec<()> = cast::transmute(self);\n                 (**repr).alloc / sys::nonzero_size_of::<T>()\n             }\n         }\n@@ -1212,16 +1210,16 @@ impl<T> OwnedVector<T> for ~[T] {\n     fn push(&mut self, t: T) {\n         unsafe {\n             if contains_managed::<T>() {\n-                let repr: **raw::VecRepr = transmute(&mut *self);\n-                let fill = (**repr).unboxed.fill;\n-                if (**repr).unboxed.alloc <= fill {\n+                let repr: **Box<Vec<()>> = cast::transmute(&mut *self);\n+                let fill = (**repr).data.fill;\n+                if (**repr).data.alloc <= fill {\n                     let new_len = self.len() + 1;\n                     self.reserve_at_least(new_len);\n                 }\n \n                 self.push_fast(t);\n             } else {\n-                let repr: **UnboxedVecRepr = transmute(&mut *self);\n+                let repr: **Vec<()> = cast::transmute(&mut *self);\n                 let fill = (**repr).fill;\n                 if (**repr).alloc <= fill {\n                     let new_len = self.len() + 1;\n@@ -1237,14 +1235,14 @@ impl<T> OwnedVector<T> for ~[T] {\n     #[inline] // really pretty please\n     unsafe fn push_fast(&mut self, t: T) {\n         if contains_managed::<T>() {\n-            let repr: **mut raw::VecRepr = transmute(self);\n-            let fill = (**repr).unboxed.fill;\n-            (**repr).unboxed.fill += sys::nonzero_size_of::<T>();\n-            let p = to_unsafe_ptr(&((**repr).unboxed.data));\n+            let repr: **mut Box<Vec<u8>> = cast::transmute(self);\n+            let fill = (**repr).data.fill;\n+            (**repr).data.fill += sys::nonzero_size_of::<T>();\n+            let p = to_unsafe_ptr(&((**repr).data.data));\n             let p = ptr::offset(p, fill) as *mut T;\n             intrinsics::move_val_init(&mut(*p), t);\n         } else {\n-            let repr: **mut UnboxedVecRepr = transmute(self);\n+            let repr: **mut Vec<u8> = cast::transmute(self);\n             let fill = (**repr).fill;\n             (**repr).fill += sys::nonzero_size_of::<T>();\n             let p = to_unsafe_ptr(&((**repr).data));\n@@ -1338,14 +1336,14 @@ impl<T> OwnedVector<T> for ~[T] {\n             {\n                 let first_slice = self.slice(0, 1);\n                 let last_slice = self.slice(next_ln, ln);\n-                raw::copy_memory(transmute(last_slice), first_slice, 1);\n+                raw::copy_memory(cast::transmute(last_slice), first_slice, 1);\n             }\n \n             // Memcopy everything to the left one element\n             {\n                 let init_slice = self.slice(0, next_ln);\n                 let tail_slice = self.slice(1, ln);\n-                raw::copy_memory(transmute(init_slice),\n+                raw::copy_memory(cast::transmute(init_slice),\n                                  tail_slice,\n                                  next_ln);\n             }\n@@ -1689,8 +1687,8 @@ pub trait MutableVector<'self, T> {\n      */\n     fn move_from(self, src: ~[T], start: uint, end: uint) -> uint;\n \n-    unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T;\n-    unsafe fn unsafe_set(&self, index: uint, val: T);\n+    unsafe fn unsafe_mut_ref(self, index: uint) -> *mut T;\n+    unsafe fn unsafe_set(self, index: uint, val: T);\n \n     fn as_mut_buf<U>(self, f: &fn(*mut T, uint) -> U) -> U;\n }\n@@ -1703,8 +1701,10 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         assert!(end <= self.len());\n         do self.as_mut_buf |p, _len| {\n             unsafe {\n-                transmute((ptr::mut_offset(p, start),\n-                           (end - start) * sys::nonzero_size_of::<T>()))\n+                cast::transmute(Slice {\n+                    data: ptr::mut_offset(p, start) as *T,\n+                    len: (end - start) * sys::nonzero_size_of::<T>()\n+                })\n             }\n         }\n     }\n@@ -1723,8 +1723,8 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         unsafe {\n             let p = vec::raw::to_mut_ptr(self);\n             VecMutIterator{ptr: p,\n-                           end: cast::transmute(p as uint + self.len() *\n-                                                sys::nonzero_size_of::<T>()),\n+                           end: (p as uint + self.len() *\n+                                 sys::nonzero_size_of::<T>()) as *mut T,\n                            lifetime: cast::transmute(p)}\n         }\n     }\n@@ -1771,22 +1771,20 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     }\n \n     #[inline]\n-    unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T {\n-        let pair_ptr: &(*mut T, uint) = transmute(self);\n-        let (ptr, _) = *pair_ptr;\n-        ptr.offset(index)\n+    unsafe fn unsafe_mut_ref(self, index: uint) -> *mut T {\n+        ptr::mut_offset(self.repr().data as *mut T, index)\n     }\n \n     #[inline]\n-    unsafe fn unsafe_set(&self, index: uint, val: T) {\n+    unsafe fn unsafe_set(self, index: uint, val: T) {\n         *self.unsafe_mut_ref(index) = val;\n     }\n \n     /// Similar to `as_imm_buf` but passing a `*mut T`\n     #[inline]\n     fn as_mut_buf<U>(self, f: &fn(*mut T, uint) -> U) -> U {\n-        let (buf, len): (*mut T, uint) = unsafe { transmute(self) };\n-        f(buf, len / sys::nonzero_size_of::<T>())\n+        let Slice{ data, len } = self.repr();\n+        f(data as *mut T, len / sys::nonzero_size_of::<T>())\n     }\n \n }\n@@ -1821,40 +1819,17 @@ pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n     raw::from_buf_raw(ptr, elts)\n }\n \n-/// The internal 'unboxed' representation of a vector\n-#[allow(missing_doc)]\n-pub struct UnboxedVecRepr {\n-    fill: uint,\n-    alloc: uint,\n-    data: u8\n-}\n-\n /// Unsafe operations\n pub mod raw {\n-    use cast::transmute;\n+    use cast;\n     use clone::Clone;\n-    use managed;\n     use option::Some;\n     use ptr;\n     use sys;\n     use unstable::intrinsics;\n-    use vec::{UnboxedVecRepr, with_capacity, ImmutableVector, MutableVector};\n+    use vec::{with_capacity, ImmutableVector, MutableVector};\n     use unstable::intrinsics::contains_managed;\n-\n-    /// The internal representation of a (boxed) vector\n-    #[allow(missing_doc)]\n-    pub struct VecRepr {\n-        box_header: managed::raw::BoxHeaderRepr,\n-        unboxed: UnboxedVecRepr\n-    }\n-\n-    /// The internal representation of a slice\n-    pub struct SliceRepr {\n-        /// Pointer to the base of this slice\n-        data: *u8,\n-        /// The length of the slice\n-        len: uint\n-    }\n+    use unstable::raw::{Box, Vec, Slice};\n \n     /**\n      * Sets the length of a vector\n@@ -1866,10 +1841,10 @@ pub mod raw {\n     #[inline]\n     pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n         if contains_managed::<T>() {\n-            let repr: **mut VecRepr = transmute(v);\n-            (**repr).unboxed.fill = new_len * sys::nonzero_size_of::<T>();\n+            let repr: **mut Box<Vec<()>> = cast::transmute(v);\n+            (**repr).data.fill = new_len * sys::nonzero_size_of::<T>();\n         } else {\n-            let repr: **mut UnboxedVecRepr = transmute(v);\n+            let repr: **mut Vec<()> = cast::transmute(v);\n             (**repr).fill = new_len * sys::nonzero_size_of::<T>();\n         }\n     }\n@@ -1885,19 +1860,13 @@ pub mod raw {\n      */\n     #[inline]\n     pub fn to_ptr<T>(v: &[T]) -> *T {\n-        unsafe {\n-            let repr: **SliceRepr = transmute(&v);\n-            transmute(&((**repr).data))\n-        }\n+        v.repr().data\n     }\n \n     /** see `to_ptr()` */\n     #[inline]\n     pub fn to_mut_ptr<T>(v: &mut [T]) -> *mut T {\n-        unsafe {\n-            let repr: **SliceRepr = transmute(&v);\n-            transmute(&((**repr).data))\n-        }\n+        v.repr().data as *mut T\n     }\n \n     /**\n@@ -1908,9 +1877,10 @@ pub mod raw {\n     pub unsafe fn buf_as_slice<T,U>(p: *T,\n                                     len: uint,\n                                     f: &fn(v: &[T]) -> U) -> U {\n-        let pair = (p, len * sys::nonzero_size_of::<T>());\n-        let v : *(&'blk [T]) = transmute(&pair);\n-        f(*v)\n+        f(cast::transmute(Slice {\n+            data: p,\n+            len: len * sys::nonzero_size_of::<T>()\n+        }))\n     }\n \n     /**\n@@ -1921,9 +1891,10 @@ pub mod raw {\n     pub unsafe fn mut_buf_as_slice<T,U>(p: *mut T,\n                                         len: uint,\n                                         f: &fn(v: &mut [T]) -> U) -> U {\n-        let pair = (p, len * sys::nonzero_size_of::<T>());\n-        let v : *(&'blk mut [T]) = transmute(&pair);\n-        f(*v)\n+        f(cast::transmute(Slice {\n+            data: p as *T,\n+            len: len * sys::nonzero_size_of::<T>()\n+        }))\n     }\n \n     /**"}, {"sha": "e91537bec3b19d2404229fa11fc01981683438fc", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaaca0c6a837ef60260b07121f4b4c4984afc70/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=5aaaca0c6a837ef60260b07121f4b4c4984afc70", "patch": "@@ -14,8 +14,8 @@ use std::int;\n use std::libc::c_void;\n use std::ptr;\n use std::sys;\n-use std::vec::UnboxedVecRepr;\n use std::unstable::intrinsics::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Opaque};\n+use std::unstable::raw::Vec;\n \n #[doc = \"High-level interfaces to `std::unstable::intrinsics::visit_ty` reflection system.\"]\n \n@@ -247,7 +247,7 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<UnboxedVecRepr>();\n+        self.align_to::<Vec<()>>();\n         // FIXME (#3732): Inner really has to move its own pointers on this one.\n         // or else possibly we could have some weird interface wherein we\n         // read-off a word from inner's pointers, but the read-word has to"}]}