{"sha": "cfe6e13b119b311c8846b762d1dabe0d58eb5e5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZTZlMTNiMTE5YjMxMWM4ODQ2Yjc2MmQxZGFiZTBkNThlYjVlNWM=", "commit": {"author": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-03-18T12:21:56Z"}, "committer": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-03-21T19:46:20Z"}, "message": "Faster sort_unstable on presorted inputs", "tree": {"sha": "6d7ecf3e8e5c808125db31912512c7b3fdd687d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d7ecf3e8e5c808125db31912512c7b3fdd687d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfe6e13b119b311c8846b762d1dabe0d58eb5e5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfe6e13b119b311c8846b762d1dabe0d58eb5e5c", "html_url": "https://github.com/rust-lang/rust/commit/cfe6e13b119b311c8846b762d1dabe0d58eb5e5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfe6e13b119b311c8846b762d1dabe0d58eb5e5c/comments", "author": null, "committer": null, "parents": [{"sha": "f0e58686277d66207a466fd07e953de98663edb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0e58686277d66207a466fd07e953de98663edb6", "html_url": "https://github.com/rust-lang/rust/commit/f0e58686277d66207a466fd07e953de98663edb6"}], "stats": {"total": 34, "additions": 21, "deletions": 13}, "files": [{"sha": "74a0a14a4c554972865626eb9efd22d7845d839c", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cfe6e13b119b311c8846b762d1dabe0d58eb5e5c/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfe6e13b119b311c8846b762d1dabe0d58eb5e5c/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=cfe6e13b119b311c8846b762d1dabe0d58eb5e5c", "patch": "@@ -464,10 +464,10 @@ fn break_patterns<T>(v: &mut [T]) {\n     }\n }\n \n-/// Chooses a pivot in `v` and returns it's index.\n+/// Chooses a pivot in `v` and returns the index and true if the slice is likely already sorted.\n ///\n /// Elements in `v` might be reordered in the process.\n-fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> usize\n+fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\n     where F: FnMut(&T, &T) -> bool\n {\n     // Minimal length to choose the median-of-medians method.\n@@ -520,12 +520,12 @@ fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> usize\n     }\n \n     if swaps < MAX_SWAPS {\n-        b\n+        (b, swaps == 0)\n     } else {\n         // The maximal number of swaps was performed. Chances are the slice is descending or mostly\n         // descending, so reversing will probably help sort it faster.\n         v.reverse();\n-        len - 1 - b\n+        (len - 1 - b, true)\n     }\n }\n \n@@ -541,8 +541,10 @@ fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T\n     // Slices of up to this length get sorted using insertion sort.\n     const MAX_INSERTION: usize = 16;\n \n-    // This is `true` if the last partitioning was balanced.\n+    // True if the last partitioning was reasonably balanced.\n     let mut was_balanced = true;\n+    // True if the last partitioning didn't shuffle elements (the slice was already partitioned).\n+    let mut was_partitioned = true;\n \n     loop {\n         let len = v.len();\n@@ -567,7 +569,17 @@ fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T\n             limit -= 1;\n         }\n \n-        let pivot = choose_pivot(v, is_less);\n+        // Choose a pivot and try guessing whether the slice is already sorted.\n+        let (pivot, likely_sorted) = choose_pivot(v, is_less);\n+\n+        // If the last partitioning was decently balanced and didn't shuffle elements, and if pivot\n+        // selection predicts the slice is likely already sorted...\n+        if was_balanced && was_partitioned && likely_sorted {\n+            // Check whether the slice really is sorted. If so, we're done.\n+            if v.windows(2).all(|w| !is_less(&w[1], &w[0])) {\n+                return;\n+            }\n+        }\n \n         // If the chosen pivot is equal to the predecessor, then it's the smallest element in the\n         // slice. Partition the slice into elements equal to and elements greater than the pivot.\n@@ -582,14 +594,10 @@ fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T\n             }\n         }\n \n-        let (mid, was_partitioned) = partition(v, pivot, is_less);\n+        // Partition the slice.\n+        let (mid, was_p) = partition(v, pivot, is_less);\n         was_balanced = cmp::min(mid, len - mid) >= len / 8;\n-\n-        // If the partitioning is decently balanced and the slice was already partitioned, there\n-        // are good chances it is also completely sorted. If so, we're done.\n-        if was_balanced && was_partitioned && v.windows(2).all(|w| !is_less(&w[1], &w[0])) {\n-            return;\n-        }\n+        was_partitioned = was_p;\n \n         // Split the slice into `left`, `pivot`, and `right`.\n         let (left, right) = {v}.split_at_mut(mid);"}]}