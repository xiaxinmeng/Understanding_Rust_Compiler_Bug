{"sha": "af6071628106bd1cdbe0ac657d4b8e726cdea9c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNjA3MTYyODEwNmJkMWNkYmUwYWM2NTdkNGI4ZTcyNmNkZWE5YzE=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-15T00:34:06Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-15T01:01:05Z"}, "message": "Get an initial implementation of boxed vectors working.", "tree": {"sha": "0b81d51b7dac018ce86ec72cbe51f8b880a90198", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b81d51b7dac018ce86ec72cbe51f8b880a90198"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af6071628106bd1cdbe0ac657d4b8e726cdea9c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af6071628106bd1cdbe0ac657d4b8e726cdea9c1", "html_url": "https://github.com/rust-lang/rust/commit/af6071628106bd1cdbe0ac657d4b8e726cdea9c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af6071628106bd1cdbe0ac657d4b8e726cdea9c1/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e9e28044638f6d0446acdc8c87fffd22b861861", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e9e28044638f6d0446acdc8c87fffd22b861861", "html_url": "https://github.com/rust-lang/rust/commit/9e9e28044638f6d0446acdc8c87fffd22b861861"}], "stats": {"total": 111, "additions": 71, "deletions": 40}, "files": [{"sha": "d46a47f0bd0e7d6d98eed38bedfc016f447be13b", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af6071628106bd1cdbe0ac657d4b8e726cdea9c1/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af6071628106bd1cdbe0ac657d4b8e726cdea9c1/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=af6071628106bd1cdbe0ac657d4b8e726cdea9c1", "patch": "@@ -706,12 +706,6 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         let bcx = drop_ty(bcx, body, body_mt.ty);\n         trans_free(bcx, v)\n       }\n-\n-      ty::ty_estr(ty::vstore_box) {\n-        let v = PointerCast(bcx, v, type_of(ccx, t));\n-        trans_free(bcx, v)\n-      }\n-\n       ty::ty_opaque_box {\n         let v = PointerCast(bcx, v, type_of(ccx, t));\n         let td = Load(bcx, GEPi(bcx, v, [0u, abi::box_field_tydesc]));\n@@ -725,8 +719,11 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         uniq::make_free_glue(bcx, v, t)\n       }\n       ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n+      ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) |\n       ty::ty_vec(_) | ty::ty_str {\n-        tvec::make_free_glue(bcx, PointerCast(bcx, v, type_of(ccx, t)), t)\n+        make_free_glue(bcx, v,\n+                       tvec::expand_boxed_vec_ty(bcx.tcx(), t));\n+        ret;\n       }\n       ty::ty_evec(_, _) {\n           bcx.sess().unimpl(\"trans::base::make_free_glue on other evec\");\n@@ -794,6 +791,9 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) {\n         free_ty(bcx, Load(bcx, v0), t)\n       }\n+      ty::ty_unboxed_vec(_) {\n+        tvec::make_drop_glue_unboxed(bcx, v0, t)\n+      }\n       ty::ty_res(did, inner, substs) {\n         trans_res_drop(bcx, v0, did, inner, substs.tps)\n       }"}, {"sha": "1d35d6548ae001fbf670c26dd05a35b88d419301", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af6071628106bd1cdbe0ac657d4b8e726cdea9c1/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af6071628106bd1cdbe0ac657d4b8e726cdea9c1/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=af6071628106bd1cdbe0ac657d4b8e726cdea9c1", "patch": "@@ -277,8 +277,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n       }\n       ty::ty_evec(mt, ty::vstore_uniq) |\n       ty::ty_vec(mt) {\n-        shape_of(ccx,\n-                 ty::mk_imm_uniq(ccx.tcx, ty::mk_unboxed_vec(ccx.tcx, mt)))\n+        shape_of(ccx, tvec::expand_boxed_vec_ty(ccx.tcx, t))\n       }\n \n       ty::ty_estr(ty::vstore_fixed(n)) {"}, {"sha": "3a543b968b762becd3677b92dc64bdefadba0a00", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/af6071628106bd1cdbe0ac657d4b8e726cdea9c1/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af6071628106bd1cdbe0ac657d4b8e726cdea9c1/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=af6071628106bd1cdbe0ac657d4b8e726cdea9c1", "patch": "@@ -5,13 +5,35 @@ import back::abi;\n import base::{call_memmove,\n                INIT, copy_val, load_if_immediate, get_tydesc,\n                sub_block, do_spill_noroot,\n-               dest, bcx_icx, non_gc_box_cast};\n+               dest, bcx_icx, non_gc_box_cast,\n+               heap, heap_exchange, heap_shared};\n import syntax::codemap::span;\n import shape::llsize_of;\n import build::*;\n import common::*;\n import util::ppaux::ty_to_str;\n \n+// Boxed vector types are in some sense currently a \"shorthand\" for a box\n+// containing an unboxed vector. This expands a boxed vector type into such an\n+// expanded type. It doesn't respect mutability, but that doesn't matter at\n+// this point.\n+fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n+    let unit_ty = ty::sequence_element_type(tcx, t);\n+    let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n+    alt ty::get(t).struct {\n+      ty::ty_vec(_) | ty::ty_str |\n+      ty::ty_estr(ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_uniq) {\n+        ty::mk_imm_uniq(tcx, unboxed_vec_ty)\n+      }\n+      ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) {\n+        ty::mk_imm_box(tcx, unboxed_vec_ty)\n+      }\n+      _ { tcx.sess.bug(\"non boxed-vec type \\\n+                        in tvec::expand_boxed_vec_ty\");\n+      }\n+    }\n+}\n+\n fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_fill\");\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n@@ -40,21 +62,25 @@ fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     ret PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n-                  fill: ValueRef, alloc: ValueRef) -> result {\n-    let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq_raw\");\n+fn alloc_raw(bcx: block, unit_ty: ty::t,\n+              fill: ValueRef, alloc: ValueRef, heap: heap) -> result {\n+    let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n \n     let vecbodyty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, ccx.opaque_vec_type));\n \n-    let {box, body} = base::malloc_unique_dyn(bcx, vecbodyty, vecsize);\n+    let {box, body} = base::malloc_general_dyn(bcx, vecbodyty, heap, vecsize);\n     Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]));\n     Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));\n     ret {bcx: bcx, val: box};\n }\n+fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n+                  fill: ValueRef, alloc: ValueRef) -> result {\n+    alloc_raw(bcx, unit_ty, fill, alloc, heap_exchange)\n+}\n \n-fn alloc_uniq(bcx: block, unit_ty: ty::t, elts: uint) -> result {\n+fn alloc_vec(bcx: block, unit_ty: ty::t, elts: uint, heap: heap) -> result {\n     let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n     let llunitty = type_of::type_of(ccx, unit_ty);\n@@ -63,7 +89,7 @@ fn alloc_uniq(bcx: block, unit_ty: ty::t, elts: uint) -> result {\n     let fill = Mul(bcx, C_uint(ccx, elts), unit_sz);\n     let alloc = if elts < 4u { Mul(bcx, C_int(ccx, 4), unit_sz) }\n                 else { fill };\n-    let {bcx: bcx, val: vptr} = alloc_uniq_raw(bcx, unit_ty, fill, alloc);\n+    let {bcx: bcx, val: vptr} = alloc_raw(bcx, unit_ty, fill, alloc, heap);\n     ret {bcx: bcx, val: vptr};\n }\n \n@@ -79,20 +105,18 @@ fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n     call_memmove(bcx, new_data_ptr, data_ptr, fill);\n \n     let bcx = if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n-        iter_vec(bcx, newptr, vec_ty, base::take_ty)\n+        iter_vec_raw(bcx, new_data_ptr, vec_ty, fill, base::take_ty)\n     } else { bcx };\n     ret rslt(bcx, newptr);\n }\n-fn make_free_glue(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n+\n+fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n    block {\n-    let _icx = bcx.insn_ctxt(\"tvec::make_free_glue\");\n+    let _icx = bcx.insn_ctxt(\"tvec::make_drop_glue_unboxed\");\n     let tcx = bcx.tcx(), unit_ty = ty::sequence_element_type(tcx, vec_ty);\n-    base::with_cond(bcx, IsNotNull(bcx, vptr)) {|bcx|\n-        let bcx = if ty::type_needs_drop(tcx, unit_ty) {\n-            iter_vec(bcx, vptr, vec_ty, base::drop_ty)\n-        } else { bcx };\n-        base::trans_unique_free(bcx, vptr)\n-    }\n+    if ty::type_needs_drop(tcx, unit_ty) {\n+        iter_vec_unboxed(bcx, vptr, vec_ty, base::drop_ty)\n+    } else { bcx }\n }\n \n fn trans_evec(bcx: block, args: [@ast::expr],\n@@ -141,13 +165,18 @@ fn trans_evec(bcx: block, args: [@ast::expr],\n             {bcx: bcx, val: p, dataptr: vp}\n           }\n           ast::vstore_uniq {\n-            let {bcx, val} = alloc_uniq(bcx, unit_ty, args.len());\n+            let {bcx, val} = alloc_vec(bcx, unit_ty, args.len(),\n+                                       heap_exchange);\n             add_clean_free(bcx, val, true);\n             let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val));\n             {bcx: bcx, val: val, dataptr: dataptr}\n           }\n           ast::vstore_box {\n-            bcx.ccx().sess.unimpl(\"unhandled tvec::trans_evec\");\n+            let {bcx, val} = alloc_vec(bcx, unit_ty, args.len(),\n+                                       heap_shared);\n+            add_clean_free(bcx, val, true);\n+            let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val));\n+            {bcx: bcx, val: val, dataptr: dataptr}\n           }\n         };\n \n@@ -223,13 +252,11 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n         let len = Load(cx, GEPi(cx, v, [0u, abi::slice_elt_len]));\n         (base, len)\n       }\n-      ty::vstore_uniq {\n+      ty::vstore_uniq | ty::vstore_box {\n+        #debug[\"get_base_and_len: %s\", val_str(ccx.tn, v)];\n         let body = tvec::get_bodyptr(cx, v);\n         (tvec::get_dataptr(cx, body), tvec::get_fill(cx, body))\n       }\n-      ty::vstore_box {\n-        cx.ccx().sess.unimpl(\"unhandled tvec::get_base_and_len\");\n-      }\n     }\n }\n \n@@ -388,7 +415,7 @@ type iter_vec_block = fn(block, ValueRef, ty::t) -> block;\n \n fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n                 fill: ValueRef, f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_uniq\");\n+    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_raw\");\n \n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n \n@@ -422,11 +449,12 @@ fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n-fn iter_vec(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n-            f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::iter_vec\");\n-    let fill = get_fill(bcx, get_bodyptr(bcx, vptr));\n-    ret iter_vec_uniq(bcx, vptr, vec_ty, fill, f);\n+fn iter_vec_unboxed(bcx: block, body_ptr: ValueRef, vec_ty: ty::t,\n+                    f: iter_vec_block) -> block {\n+    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_unboxed\");\n+    let fill = get_fill(bcx, body_ptr);\n+    let dataptr = get_dataptr(bcx, body_ptr);\n+    ret iter_vec_raw(bcx, dataptr, vec_ty, fill, f);\n }\n \n //"}, {"sha": "760b2b4ee0afb105cc33788ad248cfb009152fe7", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af6071628106bd1cdbe0ac657d4b8e726cdea9c1/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af6071628106bd1cdbe0ac657d4b8e726cdea9c1/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=af6071628106bd1cdbe0ac657d4b8e726cdea9c1", "patch": "@@ -91,7 +91,9 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n           }\n           ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n           ty::ty_estr(ty::vstore_box) { T_box_ptr(T_box(cx, T_i8())) }\n-          ty::ty_evec(mt, ty::vstore_box) |\n+          ty::ty_evec(mt, ty::vstore_box) { \n+            T_box_ptr(T_box(cx, T_vec(cx, type_of(cx, mt.ty))))\n+          }\n           ty::ty_box(mt) { T_box_ptr(T_box(cx, type_of(cx, mt.ty))) }\n           ty::ty_opaque_box { T_box_ptr(T_box(cx, T_i8())) }\n           ty::ty_uniq(mt) { T_unique_ptr(T_unique(cx, type_of(cx, mt.ty))) }"}, {"sha": "0d4cc92b1ef85dca94db83bb7704a6fe41f8b270", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af6071628106bd1cdbe0ac657d4b8e726cdea9c1/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af6071628106bd1cdbe0ac657d4b8e726cdea9c1/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=af6071628106bd1cdbe0ac657d4b8e726cdea9c1", "patch": "@@ -1112,7 +1112,7 @@ fn type_is_str(ty: t) -> bool {\n fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     alt get(ty).struct {\n       ty_str | ty_estr(_) { ret mk_mach_uint(cx, ast::ty_u8); }\n-      ty_vec(mt) | ty_evec(mt, _) { ret mt.ty; }\n+      ty_vec(mt) | ty_evec(mt, _) | ty_unboxed_vec(mt) { ret mt.ty; }\n       _ { cx.sess.bug(\"sequence_element_type called on non-sequence value\"); }\n     }\n }\n@@ -1134,7 +1134,8 @@ pure fn type_is_box(ty: t) -> bool {\n \n pure fn type_is_boxed(ty: t) -> bool {\n     alt get(ty).struct {\n-      ty_box(_) | ty_opaque_box { true }\n+      ty_box(_) | ty_opaque_box |\n+      ty_evec(_, vstore_box) | ty_estr(vstore_box) { true }\n       _ { false }\n     }\n }\n@@ -1212,6 +1213,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n       ty_estr(vstore_fixed(_)) | ty_estr(vstore_slice(_)) |\n       ty_evec(_, vstore_slice(_)) { false }\n       ty_evec(mt, vstore_fixed(_)) { type_needs_drop(cx, mt.ty) }\n+      ty_unboxed_vec(mt) { type_needs_drop(cx, mt.ty) }\n       ty_rec(flds) {\n         for flds.each {|f| if type_needs_drop(cx, f.mt.ty) { accum = true; } }\n         accum"}]}