{"sha": "bf783896569a64d661bc6c7233492943e8c2f726", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmNzgzODk2NTY5YTY0ZDY2MWJjNmM3MjMzNDkyOTQzZThjMmY3MjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-16T05:48:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-16T05:48:35Z"}, "message": "Auto merge of #29828 - sanxiyn:check-macro, r=nrc\n\nFix #27409.", "tree": {"sha": "c2949c13dbc7cf24d626fff8b8c9883c4071bed3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2949c13dbc7cf24d626fff8b8c9883c4071bed3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf783896569a64d661bc6c7233492943e8c2f726", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf783896569a64d661bc6c7233492943e8c2f726", "html_url": "https://github.com/rust-lang/rust/commit/bf783896569a64d661bc6c7233492943e8c2f726", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf783896569a64d661bc6c7233492943e8c2f726/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "531b0539b7c60dc2631b555b273616331ca74e8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/531b0539b7c60dc2631b555b273616331ca74e8d", "html_url": "https://github.com/rust-lang/rust/commit/531b0539b7c60dc2631b555b273616331ca74e8d"}, {"sha": "cce7b8bd25484a882a2be5472d6a2aadd84e9539", "url": "https://api.github.com/repos/rust-lang/rust/commits/cce7b8bd25484a882a2be5472d6a2aadd84e9539", "html_url": "https://github.com/rust-lang/rust/commit/cce7b8bd25484a882a2be5472d6a2aadd84e9539"}], "stats": {"total": 133, "additions": 83, "deletions": 50}, "files": [{"sha": "43647ea4a2e1771cab2bf5b15ff85737ca9ebd30", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 63, "deletions": 49, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/bf783896569a64d661bc6c7233492943e8c2f726/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf783896569a64d661bc6c7233492943e8c2f726/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=bf783896569a64d661bc6c7233492943e8c2f726", "patch": "@@ -10,10 +10,10 @@\n \n use ast::{self, TokenTree};\n use codemap::{Span, DUMMY_SP};\n-use ext::base::{ExtCtxt, MacResult, SyntaxExtension};\n+use ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension};\n use ext::base::{NormalTT, TTMacroExpander};\n use ext::tt::macro_parser::{Success, Error, Failure};\n-use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n+use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::parse;\n use parse::lexer::new_tt_reader;\n use parse::parser::Parser;\n@@ -129,16 +129,20 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n struct MacroRulesMacroExpander {\n     name: ast::Ident,\n     imported_from: Option<ast::Ident>,\n-    lhses: Vec<Rc<NamedMatch>>,\n-    rhses: Vec<Rc<NamedMatch>>,\n+    lhses: Vec<TokenTree>,\n+    rhses: Vec<TokenTree>,\n+    valid: bool,\n }\n \n impl TTMacroExpander for MacroRulesMacroExpander {\n     fn expand<'cx>(&self,\n                    cx: &'cx mut ExtCtxt,\n                    sp: Span,\n-                   arg: &[ast::TokenTree])\n+                   arg: &[TokenTree])\n                    -> Box<MacResult+'cx> {\n+        if !self.valid {\n+            return DummyResult::any(sp);\n+        }\n         generic_extension(cx,\n                           sp,\n                           self.name,\n@@ -154,9 +158,9 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                           sp: Span,\n                           name: ast::Ident,\n                           imported_from: Option<ast::Ident>,\n-                          arg: &[ast::TokenTree],\n-                          lhses: &[Rc<NamedMatch>],\n-                          rhses: &[Rc<NamedMatch>])\n+                          arg: &[TokenTree],\n+                          lhses: &[TokenTree],\n+                          rhses: &[TokenTree])\n                           -> Box<MacResult+'cx> {\n     if cx.trace_macros() {\n         println!(\"{}! {{ {} }}\",\n@@ -169,25 +173,17 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n     let mut best_fail_msg = \"internal error: ran no matchers\".to_string();\n \n     for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n-        match **lhs {\n-          MatchedNonterminal(NtTT(ref lhs_tt)) => {\n-            let lhs_tt = match **lhs_tt {\n-                TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n-                _ => panic!(cx.span_fatal(sp, \"malformed macro lhs\"))\n-            };\n-\n-            match TokenTree::parse(cx, lhs_tt, arg) {\n-              Success(named_matches) => {\n-                let rhs = match *rhses[i] {\n-                    // okay, what's your transcriber?\n-                    MatchedNonterminal(NtTT(ref tt)) => {\n-                        match **tt {\n-                            // ignore delimiters\n-                            TokenTree::Delimited(_, ref delimed) => delimed.tts.clone(),\n-                            _ => panic!(cx.span_fatal(sp, \"macro rhs must be delimited\")),\n-                        }\n-                    },\n-                    _ => cx.span_bug(sp, \"bad thing in rhs\")\n+        let lhs_tt = match *lhs {\n+            TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n+            _ => cx.span_bug(sp, \"malformed macro lhs\")\n+        };\n+\n+        match TokenTree::parse(cx, lhs_tt, arg) {\n+            Success(named_matches) => {\n+                let rhs = match rhses[i] {\n+                    // ignore delimiters\n+                    TokenTree::Delimited(_, ref delimed) => delimed.tts.clone(),\n+                    _ => cx.span_bug(sp, \"malformed macro rhs\"),\n                 };\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n                 let trncbr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n@@ -207,17 +203,14 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                     site_span: sp,\n                     macro_ident: name\n                 })\n-              }\n-              Failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n+            }\n+            Failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                 best_fail_spot = sp;\n                 best_fail_msg = (*msg).clone();\n-              },\n-              Error(err_sp, ref msg) => {\n+            },\n+            Error(err_sp, ref msg) => {\n                 panic!(cx.span_fatal(err_sp.substitute_dummy(sp), &msg[..]))\n-              }\n             }\n-          }\n-          _ => cx.bug(\"non-matcher found in parsed lhses\")\n         }\n     }\n \n@@ -282,9 +275,16 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n         }\n     };\n \n+    let mut valid = true;\n+\n     // Extract the arguments:\n     let lhses = match **argument_map.get(&lhs_nm.name).unwrap() {\n-        MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n+        MatchedSeq(ref s, _) => {\n+            s.iter().map(|m| match **m {\n+                MatchedNonterminal(NtTT(ref tt)) => (**tt).clone(),\n+                _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n+            }).collect()\n+        }\n         _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n     };\n \n@@ -293,41 +293,55 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     }\n \n     let rhses = match **argument_map.get(&rhs_nm.name).unwrap() {\n-        MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n+        MatchedSeq(ref s, _) => {\n+            s.iter().map(|m| match **m {\n+                MatchedNonterminal(NtTT(ref tt)) => (**tt).clone(),\n+                _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n+            }).collect()\n+        }\n         _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n     };\n \n+    for rhs in &rhses {\n+        valid &= check_rhs(cx, rhs);\n+    }\n+\n     let exp: Box<_> = Box::new(MacroRulesMacroExpander {\n         name: def.ident,\n         imported_from: def.imported_from,\n         lhses: lhses,\n         rhses: rhses,\n+        valid: valid,\n     });\n \n     NormalTT(exp, Some(def.span), def.allow_internal_unstable)\n }\n \n-fn check_lhs_nt_follows(cx: &mut ExtCtxt, lhs: &NamedMatch, sp: Span) {\n-    // lhs is going to be like MatchedNonterminal(NtTT(TokenTree::Delimited(...))), where the\n+fn check_lhs_nt_follows(cx: &mut ExtCtxt, lhs: &TokenTree, sp: Span) {\n+    // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     match lhs {\n-        &MatchedNonterminal(NtTT(ref inner)) => match &**inner {\n-            &TokenTree::Delimited(_, ref tts) => {\n-                check_matcher(cx, tts.tts.iter(), &Eof);\n-            },\n-            tt @ &TokenTree::Sequence(..) => {\n-                check_matcher(cx, Some(tt).into_iter(), &Eof);\n-            },\n-            _ => cx.span_err(sp, \"Invalid macro matcher; matchers must be contained \\\n-               in balanced delimiters or a repetition indicator\")\n+        &TokenTree::Delimited(_, ref tts) => {\n+            check_matcher(cx, tts.tts.iter(), &Eof);\n         },\n-        _ => cx.span_bug(sp, \"wrong-structured lhs for follow check (didn't find a \\\n-           MatchedNonterminal)\")\n+        tt @ &TokenTree::Sequence(..) => {\n+            check_matcher(cx, Some(tt).into_iter(), &Eof);\n+        },\n+        _ => cx.span_err(sp, \"Invalid macro matcher; matchers must be contained \\\n+                              in balanced delimiters or a repetition indicator\")\n     };\n     // we don't abort on errors on rejection, the driver will do that for us\n     // after parsing/expansion. we can report every error in every macro this way.\n }\n \n+fn check_rhs(cx: &mut ExtCtxt, rhs: &TokenTree) -> bool {\n+    match *rhs {\n+        TokenTree::Delimited(..) => return true,\n+        _ => cx.span_err(rhs.get_span(), \"macro rhs must be delimited\")\n+    }\n+    false\n+}\n+\n // returns the last token that was checked, for TokenTree::Sequence. this gets used later on.\n fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n -> Option<(Span, Token)> where I: Iterator<Item=&'a TokenTree> {"}, {"sha": "817b675aedfe8f3dc0707506ad9735ddbf870e63", "filename": "src/test/compile-fail/macro-error.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bf783896569a64d661bc6c7233492943e8c2f726/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf783896569a64d661bc6c7233492943e8c2f726/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs?ref=bf783896569a64d661bc6c7233492943e8c2f726", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we report errors at macro definition, not expansion.\n+\n+macro_rules! foo {\n+    ($a:expr) => $a; //~ ERROR macro rhs must be delimited\n+}\n+\n+fn main() {\n+    foo!(0);\n+}"}, {"sha": "756f5d4547a16b19ee25f193e5a2337f6f78dc2f", "filename": "src/test/compile-fail/type-macros-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf783896569a64d661bc6c7233492943e8c2f726/src%2Ftest%2Fcompile-fail%2Ftype-macros-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf783896569a64d661bc6c7233492943e8c2f726/src%2Ftest%2Fcompile-fail%2Ftype-macros-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-macros-fail.rs?ref=bf783896569a64d661bc6c7233492943e8c2f726", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n macro_rules! Id {\n-    { $T:tt } => $T\n+    ($T:tt) => ($T);\n }\n \n struct Foo<T> {"}]}