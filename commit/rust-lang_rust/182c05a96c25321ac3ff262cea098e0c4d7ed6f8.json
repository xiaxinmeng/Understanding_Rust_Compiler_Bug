{"sha": "182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MmMwNWE5NmMyNTMyMWFjM2ZmMjYyY2VhMDk4ZTBjNGQ3ZWQ2Zjg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-13T13:04:28Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-17T09:46:13Z"}, "message": "add name resolution from the old impl\n\nunlike the old impl, this also handles macro imports across crates", "tree": {"sha": "151c81b7b5f55dda12a555c69993a86a61b84243", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/151c81b7b5f55dda12a555c69993a86a61b84243"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "html_url": "https://github.com/rust-lang/rust/commit/182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d8d9186563637f493ac7691268319373251b18a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d8d9186563637f493ac7691268319373251b18a", "html_url": "https://github.com/rust-lang/rust/commit/0d8d9186563637f493ac7691268319373251b18a"}], "stats": {"total": 924, "additions": 739, "deletions": 185}, "files": [{"sha": "483878c78f8a21619e98a01b4bb1eb15f8200e63", "filename": "crates/ra_hir/src/nameres/crate_def_map.rs", "status": "modified", "additions": 187, "deletions": 123, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs?ref=182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "patch": "@@ -40,16 +40,21 @@\n /// syntax.\n ///\n /// TBD;\n+\n mod raw;\n mod collector;\n+#[cfg(test)]\n+mod tests;\n \n use rustc_hash::FxHashMap;\n-use ra_arena::{Arena};\n+use test_utils::tested_by;\n+use ra_arena::Arena;\n \n use crate::{\n-    Name,\n+    Name, Module, Path, PathKind, ModuleDef, Crate,\n+    PersistentHirDatabase,\n     module_tree::ModuleId,\n-    nameres::ModuleScope,\n+    nameres::{ModuleScope, ResolveMode, ResolvePathResult, PerNs, Edition, ReachedFixedPoint},\n };\n \n #[derive(Default, Debug)]\n@@ -62,143 +67,202 @@ struct ModuleData {\n /// Contans all top-level defs from a macro-expanded crate\n #[derive(Debug)]\n pub(crate) struct CrateDefMap {\n+    krate: Crate,\n+    edition: Edition,\n+    /// The prelude module for this crate. This either comes from an import\n+    /// marked with the `prelude_import` attribute, or (in the normal case) from\n+    /// a dependency (`std` or `core`).\n+    prelude: Option<Module>,\n+    extern_prelude: FxHashMap<Name, ModuleDef>,\n     root: ModuleId,\n     modules: Arena<ModuleId, ModuleData>,\n+    public_macros: FxHashMap<Name, mbe::MacroRules>,\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use std::sync::Arc;\n-\n-    use ra_db::SourceDatabase;\n-    use insta::assert_snapshot_matches;\n-\n-    use crate::{Crate, mock::MockDatabase, nameres::Resolution};\n-\n-    use super::*;\n-\n-    fn compute_crate_def_map(fixture: &str) -> Arc<CrateDefMap> {\n-        let db = MockDatabase::with_files(fixture);\n-        let crate_id = db.crate_graph().iter().next().unwrap();\n-        let krate = Crate { crate_id };\n-        collector::crate_def_map_query(&db, krate)\n+impl std::ops::Index<ModuleId> for CrateDefMap {\n+    type Output = ModuleScope;\n+    fn index(&self, id: ModuleId) -> &ModuleScope {\n+        &self.modules[id].scope\n     }\n+}\n \n-    fn render_crate_def_map(map: &CrateDefMap) -> String {\n-        let mut buf = String::new();\n-        go(&mut buf, map, \"\\ncrate\", map.root);\n-        return buf;\n-\n-        fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: ModuleId) {\n-            *buf += path;\n-            *buf += \"\\n\";\n-            for (name, res) in map.modules[module].scope.items.iter() {\n-                *buf += &format!(\"{}: {}\\n\", name, dump_resolution(res))\n+impl CrateDefMap {\n+    // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n+    // the result.\n+    #[allow(unused)]\n+    fn resolve_path_fp(\n+        &self,\n+        db: &impl PersistentHirDatabase,\n+        mode: ResolveMode,\n+        original_module: ModuleId,\n+        path: &Path,\n+    ) -> ResolvePathResult {\n+        let mut segments = path.segments.iter().enumerate();\n+        let mut curr_per_ns: PerNs<ModuleDef> = match path.kind {\n+            PathKind::Crate => {\n+                PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n             }\n-            for (name, child) in map.modules[module].children.iter() {\n-                let path = path.to_string() + &format!(\"::{}\", name);\n-                go(buf, map, &path, *child);\n+            PathKind::Self_ => {\n+                PerNs::types(Module { krate: self.krate, module_id: original_module }.into())\n             }\n-        }\n-\n-        fn dump_resolution(resolution: &Resolution) -> &'static str {\n-            match (resolution.def.types.is_some(), resolution.def.values.is_some()) {\n-                (true, true) => \"t v\",\n-                (true, false) => \"t\",\n-                (false, true) => \"v\",\n-                (false, false) => \"_\",\n+            // plain import or absolute path in 2015: crate-relative with\n+            // fallback to extern prelude (with the simplification in\n+            // rust-lang/rust#57745)\n+            // TODO there must be a nicer way to write this condition\n+            PathKind::Plain | PathKind::Abs\n+                if self.edition == Edition::Edition2015\n+                    && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n+            {\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n+                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name)\n+            }\n+            PathKind::Plain => {\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                log::debug!(\"resolving {:?} in module\", segment);\n+                self.resolve_name_in_module(db, original_module, &segment.name)\n+            }\n+            PathKind::Super => {\n+                if let Some(p) = self.modules[original_module].parent {\n+                    PerNs::types(Module { krate: self.krate, module_id: p }.into())\n+                } else {\n+                    log::debug!(\"super path in root module\");\n+                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+                }\n+            }\n+            PathKind::Abs => {\n+                // 2018-style absolute path -- only extern prelude\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                if let Some(def) = self.extern_prelude.get(&segment.name) {\n+                    log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n+                    PerNs::types(*def)\n+                } else {\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n+                }\n             }\n+        };\n+\n+        for (i, segment) in segments {\n+            let curr = match curr_per_ns.as_ref().take_types() {\n+                Some(r) => r,\n+                None => {\n+                    // we still have path segments left, but the path so far\n+                    // didn't resolve in the types namespace => no resolution\n+                    // (don't break here because `curr_per_ns` might contain\n+                    // something in the value namespace, and it would be wrong\n+                    // to return that)\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No);\n+                }\n+            };\n+            // resolve segment in curr\n+\n+            curr_per_ns = match curr {\n+                ModuleDef::Module(module) => {\n+                    if module.krate != self.krate {\n+                        let path = Path {\n+                            segments: path.segments[i..].iter().cloned().collect(),\n+                            kind: PathKind::Self_,\n+                        };\n+                        log::debug!(\"resolving {:?} in other crate\", path);\n+                        let item_map = db.item_map(module.krate);\n+                        let (def, s) = item_map.resolve_path(db, *module, &path);\n+                        return ResolvePathResult::with(\n+                            def,\n+                            ReachedFixedPoint::Yes,\n+                            s.map(|s| s + i),\n+                        );\n+                    }\n+\n+                    match self[module.module_id].items.get(&segment.name) {\n+                        Some(res) if !res.def.is_none() => res.def,\n+                        _ => {\n+                            log::debug!(\"path segment {:?} not found\", segment.name);\n+                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n+                        }\n+                    }\n+                }\n+                ModuleDef::Enum(e) => {\n+                    // enum variant\n+                    tested_by!(item_map_enum_importing);\n+                    match e.variant(db, &segment.name) {\n+                        Some(variant) => PerNs::both(variant.into(), variant.into()),\n+                        None => {\n+                            return ResolvePathResult::with(\n+                                PerNs::types((*e).into()),\n+                                ReachedFixedPoint::Yes,\n+                                Some(i),\n+                            );\n+                        }\n+                    }\n+                }\n+                s => {\n+                    // could be an inherent method call in UFCS form\n+                    // (`Struct::method`), or some other kind of associated item\n+                    log::debug!(\n+                        \"path segment {:?} resolved to non-module {:?}, but is not last\",\n+                        segment.name,\n+                        curr,\n+                    );\n+\n+                    return ResolvePathResult::with(\n+                        PerNs::types((*s).into()),\n+                        ReachedFixedPoint::Yes,\n+                        Some(i),\n+                    );\n+                }\n+            };\n         }\n+        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n     }\n \n-    fn def_map(fixtute: &str) -> String {\n-        let dm = compute_crate_def_map(fixtute);\n-        render_crate_def_map(&dm)\n+    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n+        let from_crate_root = self[self.root].items.get(name).map_or(PerNs::none(), |it| it.def);\n+        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n+\n+        from_crate_root.or(from_extern_prelude)\n     }\n \n-    #[test]\n-    fn crate_def_map_smoke_test() {\n-        let map = def_map(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-            struct S;\n-\n-            //- /foo/mod.rs\n-            pub mod bar;\n-            fn f() {}\n-\n-            //- /foo/bar.rs\n-            pub struct Baz;\n-            enum E { V }\n-        \",\n-        );\n-        assert_snapshot_matches!(\n-        map,\n-            @r###\"\n-crate\n-S: t v\n-\n-crate::foo\n-f: v\n-\n-crate::foo::bar\n-Baz: t v\n-E: t\n-\"###\n-        )\n+    fn resolve_name_in_module(\n+        &self,\n+        db: &impl PersistentHirDatabase,\n+        module: ModuleId,\n+        name: &Name,\n+    ) -> PerNs<ModuleDef> {\n+        // Resolve in:\n+        //  - current module / scope\n+        //  - extern prelude\n+        //  - std prelude\n+        let from_scope = self[module].items.get(name).map_or(PerNs::none(), |it| it.def);\n+        let from_extern_prelude =\n+            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n+        let from_prelude = self.resolve_in_prelude(db, name);\n+\n+        from_scope.or(from_extern_prelude).or(from_prelude)\n     }\n \n-    #[test]\n-    fn macro_rules_are_globally_visible() {\n-        let map = def_map(\n-            \"\n-            //- /lib.rs\n-            macro_rules! structs {\n-                ($($i:ident),*) => {\n-                    $(struct $i { field: u32 } )*\n-                }\n-            }\n-            structs!(Foo);\n-            mod nested;\n-\n-            //- /nested.rs\n-            structs!(Bar, Baz);\n-        \",\n-        );\n-        assert_snapshot_matches!(map, @r###\"\n-crate\n-Foo: t v\n-\n-crate::nested\n-Bar: t v\n-Baz: t v\n-\"###);\n+    fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n+        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n     }\n \n-    #[test]\n-    fn macro_rules_can_define_modules() {\n-        let map = def_map(\n-            \"\n-            //- /lib.rs\n-            macro_rules! m {\n-                ($name:ident) => { mod $name;  }\n-            }\n-            m!(n1);\n-\n-            //- /n1.rs\n-            m!(n2)\n-            //- /n1/n2.rs\n-            struct X;\n-        \",\n-        );\n-        assert_snapshot_matches!(map, @r###\"\n-crate\n-\n-crate::n1\n-\n-crate::n1::n2\n-X: t v\n-\"###);\n+    fn resolve_in_prelude(&self, db: &impl PersistentHirDatabase, name: &Name) -> PerNs<ModuleDef> {\n+        if let Some(prelude) = self.prelude {\n+            let resolution = if prelude.krate == self.krate {\n+                self[prelude.module_id].items.get(name).cloned()\n+            } else {\n+                db.item_map(prelude.krate)[prelude.module_id].items.get(name).cloned()\n+            };\n+            resolution.map(|r| r.def).unwrap_or_else(PerNs::none)\n+        } else {\n+            PerNs::none()\n+        }\n     }\n }"}, {"sha": "cd328b7558613b47806b7890d30d38977b4426b3", "filename": "crates/ra_hir/src/nameres/crate_def_map/collector.rs", "status": "modified", "additions": 260, "deletions": 23, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs?ref=182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "patch": "@@ -2,12 +2,13 @@ use std::sync::Arc;\n \n use rustc_hash::FxHashMap;\n use ra_arena::Arena;\n+use test_utils::tested_by;\n \n use crate::{\n     Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n     Crate, PersistentHirDatabase, HirFileId, Name, Path,\n     KnownName,\n-    nameres::{Resolution, PerNs, ModuleDef, ReachedFixedPoint},\n+    nameres::{Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode},\n     ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId},\n     module_tree::resolve_module_declaration,\n };\n@@ -19,12 +20,41 @@ pub(crate) fn crate_def_map_query(\n     db: &impl PersistentHirDatabase,\n     krate: Crate,\n ) -> Arc<CrateDefMap> {\n-    let mut modules: Arena<ModuleId, ModuleData> = Arena::default();\n-    let root = modules.alloc(ModuleData::default());\n+    let mut def_map = {\n+        let edition = krate.edition(db);\n+        let mut modules: Arena<ModuleId, ModuleData> = Arena::default();\n+        let root = modules.alloc(ModuleData::default());\n+        CrateDefMap {\n+            krate,\n+            edition,\n+            extern_prelude: FxHashMap::default(),\n+            prelude: None,\n+            root,\n+            modules,\n+            public_macros: FxHashMap::default(),\n+        }\n+    };\n+\n+    // populate external prelude\n+    for dep in krate.dependencies(db) {\n+        log::debug!(\"crate dep {:?} -> {:?}\", dep.name, dep.krate);\n+        if let Some(module) = dep.krate.root_module(db) {\n+            def_map.extern_prelude.insert(dep.name.clone(), module.into());\n+        }\n+        // look for the prelude\n+        if def_map.prelude.is_none() {\n+            let item_map = db.item_map(dep.krate);\n+            if item_map.prelude.is_some() {\n+                def_map.prelude = item_map.prelude;\n+            }\n+        }\n+    }\n+\n     let mut collector = DefCollector {\n         db,\n         krate,\n-        def_map: CrateDefMap { modules, root },\n+        def_map,\n+        glob_imports: FxHashMap::default(),\n         unresolved_imports: Vec::new(),\n         unexpanded_macros: Vec::new(),\n         global_macro_scope: FxHashMap::default(),\n@@ -39,8 +69,9 @@ struct DefCollector<DB> {\n     db: DB,\n     krate: Crate,\n     def_map: CrateDefMap,\n-    unresolved_imports: Vec<(ModuleId, raw::Import)>,\n-    unexpanded_macros: Vec<(ModuleId, MacroCallId, tt::Subtree)>,\n+    glob_imports: FxHashMap<ModuleId, Vec<(ModuleId, raw::ImportId)>>,\n+    unresolved_imports: Vec<(ModuleId, raw::ImportId, raw::ImportData)>,\n+    unexpanded_macros: Vec<(ModuleId, MacroCallId, Path, tt::Subtree)>,\n     global_macro_scope: FxHashMap<Name, mbe::MacroRules>,\n }\n \n@@ -83,8 +114,11 @@ where\n         }\n     }\n \n-    fn define_macro(&mut self, name: Name, tt: &tt::Subtree) {\n+    fn define_macro(&mut self, name: Name, tt: &tt::Subtree, export: bool) {\n         if let Ok(rules) = mbe::MacroRules::parse(tt) {\n+            if export {\n+                self.def_map.public_macros.insert(name.clone(), rules.clone());\n+            }\n             self.global_macro_scope.insert(name, rules);\n         }\n     }\n@@ -94,22 +128,218 @@ where\n     }\n \n     fn resolve_imports(&mut self) -> ReachedFixedPoint {\n+        let mut imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n+        let mut resolved = Vec::new();\n+        imports.retain(|(module_id, import, import_data)| {\n+            let (def, fp) = self.resolve_import(*module_id, import_data);\n+            if fp == ReachedFixedPoint::Yes {\n+                resolved.push((*module_id, def, *import, import_data.clone()))\n+            }\n+            fp == ReachedFixedPoint::No\n+        });\n+        self.unresolved_imports = imports;\n         // Resolves imports, filling-in module scopes\n-        ReachedFixedPoint::Yes\n+        let result =\n+            if resolved.is_empty() { ReachedFixedPoint::Yes } else { ReachedFixedPoint::No };\n+        for (module_id, def, import, import_data) in resolved {\n+            self.record_resolved_import(module_id, def, import, &import_data)\n+        }\n+        result\n     }\n \n-    fn resolve_macros(&mut self) -> ReachedFixedPoint {\n-        // Resolve macros, calling into `expand_macro` to actually do the\n-        // expansion.\n-        ReachedFixedPoint::Yes\n+    fn resolve_import(\n+        &mut self,\n+        module_id: ModuleId,\n+        import: &raw::ImportData,\n+    ) -> (PerNs<ModuleDef>, ReachedFixedPoint) {\n+        log::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n+        if import.is_extern_crate {\n+            let res = self.def_map.resolve_name_in_extern_prelude(\n+                &import\n+                    .path\n+                    .as_ident()\n+                    .expect(\"extern crate should have been desugared to one-element path\"),\n+            );\n+            // FIXME: why do we return No here?\n+            (res, if res.is_none() { ReachedFixedPoint::No } else { ReachedFixedPoint::Yes })\n+        } else {\n+            let res =\n+                self.def_map.resolve_path_fp(self.db, ResolveMode::Import, module_id, &import.path);\n+\n+            (res.resolved_def, res.reached_fixedpoint)\n+        }\n+    }\n+\n+    fn record_resolved_import(\n+        &mut self,\n+        module_id: ModuleId,\n+        def: PerNs<ModuleDef>,\n+        import_id: raw::ImportId,\n+        import: &raw::ImportData,\n+    ) {\n+        if import.is_glob {\n+            log::debug!(\"glob import: {:?}\", import);\n+            match def.take_types() {\n+                Some(ModuleDef::Module(m)) => {\n+                    if import.is_prelude {\n+                        tested_by!(std_prelude);\n+                        self.def_map.prelude = Some(m);\n+                    } else if m.krate != self.krate {\n+                        tested_by!(glob_across_crates);\n+                        // glob import from other crate => we can just import everything once\n+                        let item_map = self.db.item_map(m.krate);\n+                        let scope = &item_map[m.module_id];\n+                        let items = scope\n+                            .items\n+                            .iter()\n+                            .map(|(name, res)| (name.clone(), res.clone()))\n+                            .collect::<Vec<_>>();\n+                        self.update(module_id, Some(import_id), &items);\n+                    } else {\n+                        // glob import from same crate => we do an initial\n+                        // import, and then need to propagate any further\n+                        // additions\n+                        let scope = &self.def_map[m.module_id];\n+                        let items = scope\n+                            .items\n+                            .iter()\n+                            .map(|(name, res)| (name.clone(), res.clone()))\n+                            .collect::<Vec<_>>();\n+                        self.update(module_id, Some(import_id), &items);\n+                        // record the glob import in case we add further items\n+                        self.glob_imports\n+                            .entry(m.module_id)\n+                            .or_default()\n+                            .push((module_id, import_id));\n+                    }\n+                }\n+                Some(ModuleDef::Enum(e)) => {\n+                    tested_by!(glob_enum);\n+                    // glob import from enum => just import all the variants\n+                    let variants = e.variants(self.db);\n+                    let resolutions = variants\n+                        .into_iter()\n+                        .filter_map(|variant| {\n+                            let res = Resolution {\n+                                def: PerNs::both(variant.into(), variant.into()),\n+                                import: Some(import_id),\n+                            };\n+                            let name = variant.name(self.db)?;\n+                            Some((name, res))\n+                        })\n+                        .collect::<Vec<_>>();\n+                    self.update(module_id, Some(import_id), &resolutions);\n+                }\n+                Some(d) => {\n+                    log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n+                }\n+                None => {\n+                    log::debug!(\"glob import {:?} didn't resolve as type\", import);\n+                }\n+            }\n+        } else {\n+            let last_segment = import.path.segments.last().unwrap();\n+            let name = import.alias.clone().unwrap_or_else(|| last_segment.name.clone());\n+            log::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n+\n+            // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n+            if let Some(root_module) = self.krate.root_module(self.db) {\n+                if import.is_extern_crate && module_id == root_module.module_id {\n+                    if let Some(def) = def.take_types() {\n+                        self.def_map.extern_prelude.insert(name.clone(), def);\n+                    }\n+                }\n+            }\n+            let resolution = Resolution { def, import: Some(import_id) };\n+            self.update(module_id, None, &[(name, resolution)]);\n+        }\n+    }\n+\n+    fn update(\n+        &mut self,\n+        module_id: ModuleId,\n+        import: Option<raw::ImportId>,\n+        resolutions: &[(Name, Resolution)],\n+    ) {\n+        self.update_recursive(module_id, import, resolutions, 0)\n     }\n \n-    #[allow(unused)]\n-    fn expand_macro(&mut self, idx: usize, rules: &mbe::MacroRules) {\n-        let (module_id, call_id, arg) = self.unexpanded_macros.swap_remove(idx);\n-        if let Ok(tt) = rules.expand(&arg) {\n-            self.collect_macro_expansion(module_id, call_id, tt);\n+    fn update_recursive(\n+        &mut self,\n+        module_id: ModuleId,\n+        import: Option<raw::ImportId>,\n+        resolutions: &[(Name, Resolution)],\n+        depth: usize,\n+    ) {\n+        if depth > 100 {\n+            // prevent stack overflows (but this shouldn't be possible)\n+            panic!(\"infinite recursion in glob imports!\");\n         }\n+        let module_items = &mut self.def_map.modules[module_id].scope;\n+        let mut changed = false;\n+        for (name, res) in resolutions {\n+            let existing = module_items.items.entry(name.clone()).or_default();\n+            if existing.def.types.is_none() && res.def.types.is_some() {\n+                existing.def.types = res.def.types;\n+                existing.import = import.or(res.import);\n+                changed = true;\n+            }\n+            if existing.def.values.is_none() && res.def.values.is_some() {\n+                existing.def.values = res.def.values;\n+                existing.import = import.or(res.import);\n+                changed = true;\n+            }\n+        }\n+        if !changed {\n+            return;\n+        }\n+        let glob_imports = self\n+            .glob_imports\n+            .get(&module_id)\n+            .into_iter()\n+            .flat_map(|v| v.iter())\n+            .cloned()\n+            .collect::<Vec<_>>();\n+        for (glob_importing_module, glob_import) in glob_imports {\n+            // We pass the glob import so that the tracked import in those modules is that glob import\n+            self.update_recursive(glob_importing_module, Some(glob_import), resolutions, depth + 1);\n+        }\n+    }\n+\n+    // XXX: this is just a pile of hacks now, because `PerNs` does not handle\n+    // macro namespace.\n+    fn resolve_macros(&mut self) -> ReachedFixedPoint {\n+        let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n+        let mut resolved = Vec::new();\n+        macros.retain(|(module_id, call_id, path, tt)| {\n+            if path.segments.len() != 2 {\n+                return true;\n+            }\n+            let crate_name = &path.segments[0].name;\n+            let krate = match self.def_map.resolve_name_in_extern_prelude(crate_name).take_types() {\n+                Some(ModuleDef::Module(m)) => m.krate(self.db),\n+                _ => return true,\n+            };\n+            let krate = match krate {\n+                Some(it) => it,\n+                _ => return true,\n+            };\n+            // FIXME: this should be a proper query\n+            let def_map = crate_def_map_query(self.db, krate);\n+            let rules = def_map.public_macros.get(&path.segments[1].name).cloned();\n+            resolved.push((*module_id, *call_id, rules, tt.clone()));\n+            false\n+        });\n+        let res = if resolved.is_empty() { ReachedFixedPoint::Yes } else { ReachedFixedPoint::No };\n+\n+        for (module_id, macro_call_id, rules, arg) in resolved {\n+            if let Some(rules) = rules {\n+                if let Ok(tt) = rules.expand(&arg) {\n+                    self.collect_macro_expansion(module_id, macro_call_id, tt);\n+                }\n+            }\n+        }\n+        res\n     }\n \n     fn collect_macro_expansion(\n@@ -145,9 +375,11 @@ where\n         for item in items {\n             match *item {\n                 raw::RawItem::Module(m) => self.collect_module(&self.raw_items[m]),\n-                raw::RawItem::Import(import) => {\n-                    self.def_collector.unresolved_imports.push((self.module_id, import))\n-                }\n+                raw::RawItem::Import(import) => self.def_collector.unresolved_imports.push((\n+                    self.module_id,\n+                    import,\n+                    self.raw_items[import].clone(),\n+                )),\n                 raw::RawItem::Def(def) => self.define_def(&self.raw_items[def]),\n                 raw::RawItem::Macro(mac) => self.collect_macro(&self.raw_items[mac]),\n             }\n@@ -216,14 +448,14 @@ where\n             raw::DefKind::TypeAlias => PerNs::types(TypeAlias { id: id!() }.into()),\n         };\n         let resolution = Resolution { def, import: None };\n-        self.def_collector.def_map.modules[self.module_id].scope.items.insert(name, resolution);\n+        self.def_collector.update(self.module_id, None, &[(name, resolution)])\n     }\n \n     fn collect_macro(&mut self, mac: &raw::MacroData) {\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n-                self.def_collector.define_macro(name.clone(), &mac.arg)\n+                self.def_collector.define_macro(name.clone(), &mac.arg, mac.export)\n             }\n             return;\n         }\n@@ -247,7 +479,12 @@ where\n         }\n \n         // Case 3: path to a macro from another crate, expand during name resolution\n-        self.def_collector.unexpanded_macros.push((self.module_id, macro_call_id, mac.arg.clone()))\n+        self.def_collector.unexpanded_macros.push((\n+            self.module_id,\n+            macro_call_id,\n+            mac.path.clone(),\n+            mac.arg.clone(),\n+        ))\n     }\n }\n "}, {"sha": "fe832b8da3a04d78662361e5044bc61f210a9f66", "filename": "crates/ra_hir/src/nameres/crate_def_map/raw.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fraw.rs?ref=182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "patch": "@@ -18,7 +18,7 @@ use crate::{\n #[derive(Default, PartialEq, Eq)]\n pub(crate) struct RawItems {\n     modules: Arena<Module, ModuleData>,\n-    imports: Arena<Import, ImportData>,\n+    imports: Arena<ImportId, ImportData>,\n     defs: Arena<Def, DefData>,\n     macros: Arena<Macro, MacroData>,\n     /// items for top-level module\n@@ -60,9 +60,9 @@ impl Index<Module> for RawItems {\n     }\n }\n \n-impl Index<Import> for RawItems {\n+impl Index<ImportId> for RawItems {\n     type Output = ImportData;\n-    fn index(&self, idx: Import) -> &ImportData {\n+    fn index(&self, idx: ImportId) -> &ImportData {\n         &self.imports[idx]\n     }\n }\n@@ -84,7 +84,7 @@ impl Index<Macro> for RawItems {\n #[derive(PartialEq, Eq, Clone, Copy)]\n pub(crate) enum RawItem {\n     Module(Module),\n-    Import(Import),\n+    Import(ImportId),\n     Def(Def),\n     Macro(Macro),\n }\n@@ -99,18 +99,8 @@ pub(crate) enum ModuleData {\n     Definition { name: Name, items: Vec<RawItem> },\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct Import(RawId);\n-impl_arena_id!(Import);\n-\n-#[derive(PartialEq, Eq)]\n-pub(crate) struct ImportData {\n-    path: Path,\n-    alias: Option<Name>,\n-    is_glob: bool,\n-    is_prelude: bool,\n-    is_extern_crate: bool,\n-}\n+pub(crate) use crate::nameres::lower::ImportId;\n+pub(super) use crate::nameres::lower::ImportData;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub(crate) struct Def(RawId);\n@@ -144,6 +134,7 @@ pub(crate) struct MacroData {\n     pub(crate) path: Path,\n     pub(crate) name: Option<Name>,\n     pub(crate) arg: tt::Subtree,\n+    pub(crate) export: bool,\n }\n \n struct RawItemsCollector {\n@@ -215,9 +206,7 @@ impl RawItemsCollector {\n     }\n \n     fn add_use_item(&mut self, current_module: Option<Module>, use_item: &ast::UseItem) {\n-        let is_prelude = use_item\n-            .attrs()\n-            .any(|attr| attr.as_atom().map(|s| s == \"prelude_import\").unwrap_or(false));\n+        let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n \n         Path::expand_use_item(use_item, |path, segment, alias| {\n             let import = self.raw_items.imports.alloc(ImportData {\n@@ -261,7 +250,8 @@ impl RawItemsCollector {\n \n         let name = m.name().map(|it| it.as_name());\n         let source_item_id = self.source_file_items.id_of_unchecked(m.syntax());\n-        let m = self.raw_items.macros.alloc(MacroData { source_item_id, path, arg, name });\n+        let export = m.has_atom_attr(\"macro_export\");\n+        let m = self.raw_items.macros.alloc(MacroData { source_item_id, path, arg, name, export });\n         self.push_item(current_module, RawItem::Macro(m));\n     }\n "}, {"sha": "a56dbaf902a0f9a5254641206109f5a68f4d696a", "filename": "crates/ra_hir/src/nameres/crate_def_map/tests.rs", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests.rs?ref=182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "patch": "@@ -0,0 +1,265 @@\n+use std::sync::Arc;\n+\n+use ra_db::SourceDatabase;\n+use test_utils::covers;\n+use insta::assert_snapshot_matches;\n+\n+use crate::{Crate, mock::{MockDatabase, CrateGraphFixture}, nameres::Resolution};\n+\n+use super::*;\n+\n+fn compute_crate_def_map(fixture: &str, graph: Option<CrateGraphFixture>) -> Arc<CrateDefMap> {\n+    let mut db = MockDatabase::with_files(fixture);\n+    if let Some(graph) = graph {\n+        db.set_crate_graph_from_fixture(graph);\n+    }\n+    let crate_id = db.crate_graph().iter().next().unwrap();\n+    let krate = Crate { crate_id };\n+    collector::crate_def_map_query(&db, krate)\n+}\n+\n+fn render_crate_def_map(map: &CrateDefMap) -> String {\n+    let mut buf = String::new();\n+    go(&mut buf, map, \"\\ncrate\", map.root);\n+    return buf;\n+\n+    fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: ModuleId) {\n+        *buf += path;\n+        *buf += \"\\n\";\n+        for (name, res) in map.modules[module].scope.items.iter() {\n+            *buf += &format!(\"{}: {}\\n\", name, dump_resolution(res))\n+        }\n+        for (name, child) in map.modules[module].children.iter() {\n+            let path = path.to_string() + &format!(\"::{}\", name);\n+            go(buf, map, &path, *child);\n+        }\n+    }\n+\n+    fn dump_resolution(resolution: &Resolution) -> &'static str {\n+        match (resolution.def.types.is_some(), resolution.def.values.is_some()) {\n+            (true, true) => \"t v\",\n+            (true, false) => \"t\",\n+            (false, true) => \"v\",\n+            (false, false) => \"_\",\n+        }\n+    }\n+}\n+\n+fn def_map(fixtute: &str) -> String {\n+    let dm = compute_crate_def_map(fixtute, None);\n+    render_crate_def_map(&dm)\n+}\n+\n+fn def_map_with_crate_graph(fixtute: &str, graph: CrateGraphFixture) -> String {\n+    let dm = compute_crate_def_map(fixtute, Some(graph));\n+    render_crate_def_map(&dm)\n+}\n+\n+#[test]\n+fn crate_def_map_smoke_test() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+        struct S;\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+        fn f() {}\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        enum E { V }\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+S: t v\n+\n+crate::foo\n+f: v\n+\n+crate::foo::bar\n+Baz: t v\n+E: t\n+\"###\n+    )\n+}\n+\n+#[test]\n+fn macro_rules_are_globally_visible() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        macro_rules! structs {\n+            ($($i:ident),*) => {\n+                $(struct $i { field: u32 } )*\n+            }\n+        }\n+        structs!(Foo);\n+        mod nested;\n+\n+        //- /nested.rs\n+        structs!(Bar, Baz);\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+Foo: t v\n+\n+crate::nested\n+Bar: t v\n+Baz: t v\n+\"###);\n+}\n+\n+#[test]\n+fn macro_rules_can_define_modules() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        macro_rules! m {\n+            ($name:ident) => { mod $name;  }\n+        }\n+        m!(n1);\n+\n+        //- /n1.rs\n+        m!(n2)\n+        //- /n1/n2.rs\n+        struct X;\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+\n+crate::n1\n+\n+crate::n1::n2\n+X: t v\n+\"###);\n+}\n+\n+#[test]\n+fn macro_rules_from_other_crates_are_visible() {\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        foo::structs!(Foo, Bar)\n+        mod bar;\n+\n+        //- /bar.rs\n+        use crate::*;\n+\n+        //- /lib.rs\n+        #[macro_export]\n+        macro_rules! structs {\n+            ($($i:ident),*) => {\n+                $(struct $i { field: u32 } )*\n+            }\n+        }\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"foo\"]),\n+            \"foo\": (\"/lib.rs\", []),\n+        },\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+Foo: t v\n+Bar: t v\n+\n+crate::bar\n+Foo: t v\n+Bar: t v\n+\"###);\n+}\n+\n+#[test]\n+fn std_prelude() {\n+    covers!(std_prelude);\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        use Foo::*;\n+\n+        //- /lib.rs\n+        mod prelude;\n+        #[prelude_import]\n+        use prelude::*;\n+\n+        //- /prelude.rs\n+        pub enum Foo { Bar, Baz };\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"test_crate\"]),\n+            \"test_crate\": (\"/lib.rs\", []),\n+        },\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+Bar: t v\n+Baz: t v\n+\"###);\n+}\n+\n+#[test]\n+fn glob_across_crates() {\n+    covers!(glob_across_crates);\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        use test_crate::*;\n+\n+        //- /lib.rs\n+        pub struct Baz;\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"test_crate\"]),\n+            \"test_crate\": (\"/lib.rs\", []),\n+        },\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+Baz: t v\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn item_map_enum_importing() {\n+    covers!(item_map_enum_importing);\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        enum E { V }\n+        use self::E::V;\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+V: t v\n+E: t\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn glob_enum() {\n+    covers!(glob_enum);\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        enum Foo {\n+            Bar, Baz\n+        }\n+        use self::Foo::*;\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+Foo: t\n+Bar: t v\n+Baz: t v\n+\"###\n+    );\n+}"}, {"sha": "24707aed104768159ae9886ad9945c2a8392b0c5", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "patch": "@@ -18,8 +18,8 @@ use crate::{\n pub struct ImportId(RawId);\n impl_arena_id!(ImportId);\n \n-#[derive(Debug, PartialEq, Eq)]\n-pub(super) struct ImportData {\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ImportData {\n     pub(super) path: Path,\n     pub(super) alias: Option<Name>,\n     pub(super) is_glob: bool,"}, {"sha": "989308626b14db36fa837c81d521dd8e14e73e89", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "patch": "@@ -42,7 +42,7 @@ pub use crate::syntax_bridge::{ast_to_token_tree, token_tree_to_ast_item_list};\n /// be very confusing is that AST has almost exactly the same shape as\n /// `tt::TokenTree`, but there's a crucial difference: in macro rules, `$ident`\n /// and `$()*` have special meaning (see `Var` and `Repeat` data structures)\n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub struct MacroRules {\n     pub(crate) rules: Vec<Rule>,\n }\n@@ -56,21 +56,21 @@ impl MacroRules {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Rule {\n     pub(crate) lhs: Subtree,\n     pub(crate) rhs: Subtree,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum TokenTree {\n     Leaf(Leaf),\n     Subtree(Subtree),\n     Repeat(Repeat),\n }\n impl_froms!(TokenTree: Leaf, Subtree, Repeat);\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Leaf {\n     Literal(Literal),\n     Punct(Punct),\n@@ -79,37 +79,37 @@ pub(crate) enum Leaf {\n }\n impl_froms!(Leaf: Literal, Punct, Ident, Var);\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Subtree {\n     pub(crate) delimiter: Delimiter,\n     pub(crate) token_trees: Vec<TokenTree>,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Repeat {\n     pub(crate) subtree: Subtree,\n     pub(crate) kind: RepeatKind,\n     pub(crate) separator: Option<char>,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum RepeatKind {\n     ZeroOrMore,\n     OneOrMore,\n     ZeroOrOne,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Literal {\n     pub(crate) text: SmolStr,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Ident {\n     pub(crate) text: SmolStr,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Var {\n     pub(crate) text: SmolStr,\n     pub(crate) kind: Option<SmolStr>,"}, {"sha": "d8c2cb063f1ac03475901ba2c52bcb93a70b5f75", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "patch": "@@ -114,6 +114,9 @@ pub trait AttrsOwner: AstNode {\n     fn attrs(&self) -> AstChildren<Attr> {\n         children(self)\n     }\n+    fn has_atom_attr(&self, atom: &str) -> bool {\n+        self.attrs().filter_map(|x| x.as_atom()).any(|x| x == atom)\n+    }\n }\n \n pub trait DocCommentsOwner: AstNode {\n@@ -153,12 +156,6 @@ pub trait DocCommentsOwner: AstNode {\n     }\n }\n \n-impl FnDef {\n-    pub fn has_atom_attr(&self, atom: &str) -> bool {\n-        self.attrs().filter_map(|x| x.as_atom()).any(|x| x == atom)\n-    }\n-}\n-\n impl Attr {\n     pub fn is_inner(&self) -> bool {\n         let tt = match self.value() {"}, {"sha": "54b72f8c57bb971cb2e701a2d3131485ba610440", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "patch": "@@ -2108,6 +2108,7 @@ impl ToOwned for MacroCall {\n \n \n impl ast::NameOwner for MacroCall {}\n+impl ast::AttrsOwner for MacroCall {}\n impl MacroCall {\n     pub fn token_tree(&self) -> Option<&TokenTree> {\n         super::child_opt(self)"}, {"sha": "4f8e19bd00e48968c39ba0e77e7b7c8ef2b8c260", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/182c05a96c25321ac3ff262cea098e0c4d7ed6f8/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "patch": "@@ -557,7 +557,7 @@ Grammar(\n         \"Name\": (),\n         \"NameRef\": (),\n         \"MacroCall\": (\n-            traits: [ \"NameOwner\" ],\n+            traits: [ \"NameOwner\", \"AttrsOwner\" ],\n             options: [ \"TokenTree\", \"Path\" ],\n         ),\n         \"Attr\": ( options: [ [\"value\", \"TokenTree\"] ] ),"}]}