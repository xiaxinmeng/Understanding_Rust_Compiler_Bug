{"sha": "0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNDNjNGE4MTVhMGU4MmQ1ZTU1ZTc2YTAxZDIxYjBmN2EwMGZmNWI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-19T08:24:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-19T10:16:25Z"}, "message": "migrate ra_assists to the new AST", "tree": {"sha": "126bafdfcbcb04741b87876d6204c449113d96b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/126bafdfcbcb04741b87876d6204c449113d96b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "html_url": "https://github.com/rust-lang/rust/commit/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "html_url": "https://github.com/rust-lang/rust/commit/e2b28f5bb8043e92b10f6a40696131007fc9dfe2"}], "stats": {"total": 417, "additions": 213, "deletions": 204}, "files": [{"sha": "f19196f53d6a890daf6012ffc44a2c5a632d07dd", "filename": "crates/ra_assists/src/add_derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -9,7 +9,7 @@ use crate::{Assist, AssistCtx, AssistId};\n \n pub(crate) fn add_derive(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let nominal = ctx.node_at_offset::<ast::NominalDef>()?;\n-    let node_start = derive_insertion_offset(nominal)?;\n+    let node_start = derive_insertion_offset(&nominal)?;\n     ctx.add_action(AssistId(\"add_derive\"), \"add `#[derive]`\", |edit| {\n         let derive_attr = nominal\n             .attrs()"}, {"sha": "a69cfc8e3a36f54e8d883f271ba50609b2ef9b25", "filename": "crates/ra_assists/src/add_explicit_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -27,7 +27,7 @@ pub(crate) fn add_explicit_type(mut ctx: AssistCtx<impl HirDatabase>) -> Option<\n     // Infer type\n     let db = ctx.db;\n     let analyzer = hir::SourceAnalyzer::new(db, ctx.frange.file_id, stmt.syntax(), None);\n-    let ty = analyzer.type_of(db, expr)?;\n+    let ty = analyzer.type_of(db, &expr)?;\n     // Assist not applicable if the type is unknown\n     if is_unknown(&ty) {\n         return None;"}, {"sha": "cebc19539678e1d364f0154a661e49842b1acfee", "filename": "crates/ra_assists/src/add_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -16,7 +16,7 @@ pub(crate) fn add_impl(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         let start_offset = nominal.syntax().range().end();\n         let mut buf = String::new();\n         buf.push_str(\"\\n\\nimpl\");\n-        if let Some(type_params) = type_params {\n+        if let Some(type_params) = &type_params {\n             type_params.syntax().text().push_to(&mut buf);\n         }\n         buf.push_str(\" \");\n@@ -25,9 +25,9 @@ pub(crate) fn add_impl(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n             let lifetime_params = type_params\n                 .lifetime_params()\n                 .filter_map(|it| it.lifetime_token())\n-                .map(|it| it.text());\n+                .map(|it| it.text().clone());\n             let type_params =\n-                type_params.type_params().filter_map(|it| it.name()).map(|it| it.text());\n+                type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());\n             join(lifetime_params.chain(type_params)).surround_with(\"<\", \">\").to_buf(&mut buf);\n         }\n         buf.push_str(\" {\\n\");"}, {"sha": "b992a4dc80257c37b8213f2d882574f201788287", "filename": "crates/ra_assists/src/add_missing_impl_members.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -5,8 +5,8 @@ use crate::{\n \n use hir::{db::HirDatabase, HasSource};\n use ra_db::FilePosition;\n-use ra_syntax::ast::{self, AstNode, ImplItem, ImplItemKind, NameOwner};\n-use ra_syntax::{SmolStr, TreeArc};\n+use ra_syntax::ast::{self, AstNode, ImplItemKind, NameOwner};\n+use ra_syntax::SmolStr;\n \n #[derive(PartialEq)]\n enum AddMissingImplMembersMode {\n@@ -46,16 +46,16 @@ fn add_missing_impl_members_inner(\n         let position = FilePosition { file_id, offset: impl_node.syntax().range().start() };\n         let analyzer = hir::SourceAnalyzer::new(ctx.db, position.file_id, impl_node.syntax(), None);\n \n-        resolve_target_trait_def(ctx.db, &analyzer, impl_node)?\n+        resolve_target_trait_def(ctx.db, &analyzer, &impl_node)?\n     };\n \n-    let def_name = |kind| -> Option<&SmolStr> {\n+    let def_name = |kind| -> Option<SmolStr> {\n         match kind {\n-            ImplItemKind::FnDef(def) => def.name(),\n-            ImplItemKind::TypeAliasDef(def) => def.name(),\n-            ImplItemKind::ConstDef(def) => def.name(),\n+            ast::ImplItemKind::FnDef(def) => def.name(),\n+            ast::ImplItemKind::TypeAliasDef(def) => def.name(),\n+            ast::ImplItemKind::ConstDef(def) => def.name(),\n         }\n-        .map(ast::Name::text)\n+        .map(|it| it.text().clone())\n     };\n \n     let trait_items = trait_def.item_list()?.impl_items();\n@@ -78,18 +78,13 @@ fn add_missing_impl_members_inner(\n \n     ctx.add_action(AssistId(assist_id), label, |edit| {\n         let n_existing_items = impl_item_list.impl_items().count();\n-        let items: Vec<_> = missing_items\n-            .into_iter()\n-            .map(|it| match it.kind() {\n-                ImplItemKind::FnDef(def) => {\n-                    strip_docstring(ImplItem::cast(add_body(def).syntax()).unwrap())\n-                }\n-                _ => strip_docstring(it),\n-            })\n-            .collect();\n+        let items = missing_items.into_iter().map(|it| match it.kind() {\n+            ImplItemKind::FnDef(def) => strip_docstring(add_body(def).into()),\n+            _ => strip_docstring(it),\n+        });\n         let mut ast_editor = AstEditor::new(impl_item_list);\n \n-        ast_editor.append_items(items.iter().map(|it| &**it));\n+        ast_editor.append_items(items);\n \n         let first_new_item = ast_editor.ast().impl_items().nth(n_existing_items).unwrap();\n         let cursor_position = first_new_item.syntax().range().start();\n@@ -101,14 +96,14 @@ fn add_missing_impl_members_inner(\n     ctx.build()\n }\n \n-fn strip_docstring(item: &ast::ImplItem) -> TreeArc<ast::ImplItem> {\n+fn strip_docstring(item: ast::ImplItem) -> ast::ImplItem {\n     let mut ast_editor = AstEditor::new(item);\n     ast_editor.strip_attrs_and_docs();\n     ast_editor.ast().to_owned()\n }\n \n-fn add_body(fn_def: &ast::FnDef) -> TreeArc<ast::FnDef> {\n-    let mut ast_editor = AstEditor::new(fn_def);\n+fn add_body(fn_def: ast::FnDef) -> ast::FnDef {\n+    let mut ast_editor = AstEditor::new(fn_def.clone());\n     if fn_def.body().is_none() {\n         ast_editor.set_body(&AstBuilder::<ast::Block>::single_expr(\n             &AstBuilder::<ast::Expr>::unimplemented(),\n@@ -123,9 +118,12 @@ fn resolve_target_trait_def(\n     db: &impl HirDatabase,\n     analyzer: &hir::SourceAnalyzer,\n     impl_block: &ast::ImplBlock,\n-) -> Option<TreeArc<ast::TraitDef>> {\n-    let ast_path =\n-        impl_block.target_trait().map(AstNode::syntax).and_then(ast::PathType::cast)?.path()?;\n+) -> Option<ast::TraitDef> {\n+    let ast_path = impl_block\n+        .target_trait()\n+        .map(|it| it.syntax().clone())\n+        .and_then(ast::PathType::cast)?\n+        .path()?;\n \n     match analyzer.resolve_path(db, &ast_path) {\n         Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def.source(db).ast),"}, {"sha": "e52085f85dfd55b87520d3f26bd9c44f05461a7c", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -49,7 +49,7 @@ pub(crate) enum Assist {\n pub(crate) struct AssistCtx<'a, DB> {\n     pub(crate) db: &'a DB,\n     pub(crate) frange: FileRange,\n-    source_file: &'a SourceFile,\n+    source_file: SourceFile,\n     should_compute_edit: bool,\n     assist: Assist,\n }\n@@ -59,7 +59,7 @@ impl<'a, DB> Clone for AssistCtx<'a, DB> {\n         AssistCtx {\n             db: self.db,\n             frange: self.frange,\n-            source_file: self.source_file,\n+            source_file: self.source_file.clone(),\n             should_compute_edit: self.should_compute_edit,\n             assist: self.assist.clone(),\n         }\n@@ -104,18 +104,18 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n         Some(self.assist)\n     }\n \n-    pub(crate) fn token_at_offset(&self) -> TokenAtOffset<SyntaxToken<'a>> {\n+    pub(crate) fn token_at_offset(&self) -> TokenAtOffset<SyntaxToken> {\n         find_token_at_offset(self.source_file.syntax(), self.frange.range.start())\n     }\n \n-    pub(crate) fn node_at_offset<N: AstNode>(&self) -> Option<&'a N> {\n+    pub(crate) fn node_at_offset<N: AstNode>(&self) -> Option<N> {\n         find_node_at_offset(self.source_file.syntax(), self.frange.range.start())\n     }\n-    pub(crate) fn covering_element(&self) -> SyntaxElement<'a> {\n+    pub(crate) fn covering_element(&self) -> SyntaxElement {\n         find_covering_element(self.source_file.syntax(), self.frange.range)\n     }\n \n-    pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement<'a> {\n+    pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement {\n         find_covering_element(self.source_file.syntax(), range)\n     }\n }\n@@ -139,7 +139,7 @@ impl AssistBuilder {\n     ) {\n         let mut replace_with = replace_with.into();\n         if let Some(indent) = leading_indent(node) {\n-            replace_with = reindent(&replace_with, indent)\n+            replace_with = reindent(&replace_with, &indent)\n         }\n         self.replace(node.range(), replace_with)\n     }"}, {"sha": "5fbcadfee80f94356672d5f293c390be64c5ecbf", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "modified", "additions": 65, "deletions": 58, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -4,18 +4,18 @@ use arrayvec::ArrayVec;\n use hir::Name;\n use ra_fmt::leading_indent;\n use ra_syntax::{\n-    ast, AstNode, Direction, InsertPosition, SourceFile, SyntaxElement, SyntaxKind::*, TreeArc, T,\n+    ast, AstNode, Direction, InsertPosition, SourceFile, SyntaxElement, SyntaxKind::*, T,\n };\n use ra_text_edit::TextEditBuilder;\n \n pub struct AstEditor<N: AstNode> {\n-    original_ast: TreeArc<N>,\n-    ast: TreeArc<N>,\n+    original_ast: N,\n+    ast: N,\n }\n \n impl<N: AstNode> AstEditor<N> {\n-    pub fn new(node: &N) -> AstEditor<N> {\n-        AstEditor { original_ast: node.to_owned(), ast: node.to_owned() }\n+    pub fn new(node: N) -> AstEditor<N> {\n+        AstEditor { original_ast: node.clone(), ast: node }\n     }\n \n     pub fn into_text_edit(self, builder: &mut TextEditBuilder) {\n@@ -26,27 +26,27 @@ impl<N: AstNode> AstEditor<N> {\n     }\n \n     pub fn ast(&self) -> &N {\n-        &*self.ast\n+        &self.ast\n     }\n \n     #[must_use]\n-    fn insert_children<'a>(\n+    fn insert_children(\n         &self,\n-        position: InsertPosition<SyntaxElement<'_>>,\n-        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n-    ) -> TreeArc<N> {\n+        position: InsertPosition<SyntaxElement>,\n+        to_insert: impl Iterator<Item = SyntaxElement>,\n+    ) -> N {\n         let new_syntax = self.ast().syntax().insert_children(position, to_insert);\n-        N::cast(&new_syntax).unwrap().to_owned()\n+        N::cast(new_syntax).unwrap()\n     }\n \n     #[must_use]\n-    fn replace_children<'a>(\n+    fn replace_children(\n         &self,\n-        to_delete: RangeInclusive<SyntaxElement<'_>>,\n-        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n-    ) -> TreeArc<N> {\n+        to_delete: RangeInclusive<SyntaxElement>,\n+        to_insert: impl Iterator<Item = SyntaxElement>,\n+    ) -> N {\n         let new_syntax = self.ast().syntax().replace_children(to_delete, to_insert);\n-        N::cast(&new_syntax).unwrap().to_owned()\n+        N::cast(new_syntax).unwrap()\n     }\n \n     fn do_make_multiline(&mut self) {\n@@ -66,16 +66,18 @@ impl<N: AstNode> AstEditor<N> {\n                 if ws.text().contains('\\n') {\n                     return;\n                 }\n-                Some(ws)\n+                Some(ws.clone())\n             }\n         };\n \n-        let indent = leading_indent(self.ast().syntax()).unwrap_or(\"\");\n+        let indent = leading_indent(self.ast().syntax()).unwrap_or(\"\".into());\n         let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n         let to_insert = iter::once(ws.ws().into());\n         self.ast = match existing_ws {\n             None => self.insert_children(InsertPosition::After(l_curly), to_insert),\n-            Some(ws) => self.replace_children(RangeInclusive::new(ws.into(), ws.into()), to_insert),\n+            Some(ws) => {\n+                self.replace_children(RangeInclusive::new(ws.clone().into(), ws.into()), to_insert)\n+            }\n         };\n     }\n }\n@@ -95,7 +97,7 @@ impl AstEditor<ast::NamedFieldList> {\n         let space = if is_multiline {\n             ws = tokens::WsBuilder::new(&format!(\n                 \"\\n{}    \",\n-                leading_indent(self.ast().syntax()).unwrap_or(\"\")\n+                leading_indent(self.ast().syntax()).unwrap_or(\"\".into())\n             ));\n             ws.ws()\n         } else {\n@@ -104,7 +106,7 @@ impl AstEditor<ast::NamedFieldList> {\n \n         let mut to_insert: ArrayVec<[SyntaxElement; 4]> = ArrayVec::new();\n         to_insert.push(space.into());\n-        to_insert.push(field.syntax().into());\n+        to_insert.push(field.syntax().clone().into());\n         to_insert.push(tokens::comma().into());\n \n         macro_rules! after_l_curly {\n@@ -127,7 +129,7 @@ impl AstEditor<ast::NamedFieldList> {\n                     InsertPosition::After(comma)\n                 } else {\n                     to_insert.insert(0, tokens::comma().into());\n-                    InsertPosition::After($anchor.syntax().into())\n+                    InsertPosition::After($anchor.syntax().clone().into())\n                 }\n             };\n         };\n@@ -144,7 +146,9 @@ impl AstEditor<ast::NamedFieldList> {\n                     None => after_l_curly!(),\n                 }\n             }\n-            InsertPosition::Before(anchor) => InsertPosition::Before(anchor.syntax().into()),\n+            InsertPosition::Before(anchor) => {\n+                InsertPosition::Before(anchor.syntax().clone().into())\n+            }\n             InsertPosition::After(anchor) => after_field!(anchor),\n         };\n \n@@ -157,30 +161,31 @@ impl AstEditor<ast::NamedFieldList> {\n }\n \n impl AstEditor<ast::ItemList> {\n-    pub fn append_items<'a>(&mut self, items: impl Iterator<Item = &'a ast::ImplItem>) {\n+    pub fn append_items(&mut self, items: impl Iterator<Item = ast::ImplItem>) {\n         let n_existing_items = self.ast().impl_items().count();\n         if n_existing_items == 0 {\n             self.do_make_multiline();\n         }\n         items.for_each(|it| self.append_item(it));\n     }\n \n-    pub fn append_item(&mut self, item: &ast::ImplItem) {\n+    pub fn append_item(&mut self, item: ast::ImplItem) {\n         let (indent, position) = match self.ast().impl_items().last() {\n             Some(it) => (\n-                leading_indent(it.syntax()).unwrap_or(\"\").to_string(),\n-                InsertPosition::After(it.syntax().into()),\n+                leading_indent(it.syntax()).unwrap_or_default().to_string(),\n+                InsertPosition::After(it.syntax().clone().into()),\n             ),\n             None => match self.l_curly() {\n                 Some(it) => (\n-                    \"    \".to_string() + leading_indent(self.ast().syntax()).unwrap_or(\"\"),\n+                    \"    \".to_string() + &leading_indent(self.ast().syntax()).unwrap_or_default(),\n                     InsertPosition::After(it),\n                 ),\n                 None => return,\n             },\n         };\n         let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n-        let to_insert: ArrayVec<[SyntaxElement; 2]> = [ws.ws().into(), item.syntax().into()].into();\n+        let to_insert: ArrayVec<[SyntaxElement; 2]> =\n+            [ws.ws().into(), item.syntax().clone().into()].into();\n         self.ast = self.insert_children(position, to_insert.into_iter());\n     }\n \n@@ -197,9 +202,9 @@ impl AstEditor<ast::ImplItem> {\n             .children_with_tokens()\n             .find(|it| it.kind() == ATTR || it.kind() == COMMENT)\n         {\n-            let end = match start.next_sibling_or_token() {\n-                Some(el) if el.kind() == WHITESPACE => el,\n-                Some(_) | None => start,\n+            let end = match &start.next_sibling_or_token() {\n+                Some(el) if el.kind() == WHITESPACE => el.clone(),\n+                Some(_) | None => start.clone(),\n             };\n             self.ast = self.replace_children(RangeInclusive::new(start, end), iter::empty());\n         }\n@@ -210,18 +215,18 @@ impl AstEditor<ast::FnDef> {\n     pub fn set_body(&mut self, body: &ast::Block) {\n         let mut to_insert: ArrayVec<[SyntaxElement; 2]> = ArrayVec::new();\n         let old_body_or_semi: SyntaxElement = if let Some(old_body) = self.ast().body() {\n-            old_body.syntax().into()\n+            old_body.syntax().clone().into()\n         } else if let Some(semi) = self.ast().semicolon_token() {\n             to_insert.push(tokens::single_space().into());\n             semi.into()\n         } else {\n             to_insert.push(tokens::single_space().into());\n-            to_insert.push(body.syntax().into());\n+            to_insert.push(body.syntax().clone().into());\n             self.ast = self.insert_children(InsertPosition::Last, to_insert.into_iter());\n             return;\n         };\n-        to_insert.push(body.syntax().into());\n-        let replace_range = RangeInclusive::new(old_body_or_semi, old_body_or_semi);\n+        to_insert.push(body.syntax().clone().into());\n+        let replace_range = RangeInclusive::new(old_body_or_semi.clone(), old_body_or_semi);\n         self.ast = self.replace_children(replace_range, to_insert.into_iter())\n     }\n }\n@@ -231,15 +236,15 @@ pub struct AstBuilder<N: AstNode> {\n }\n \n impl AstBuilder<ast::NamedField> {\n-    pub fn from_name(name: &Name) -> TreeArc<ast::NamedField> {\n+    pub fn from_name(name: &Name) -> ast::NamedField {\n         ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}: (), }} }}\", name))\n     }\n \n-    fn from_text(text: &str) -> TreeArc<ast::NamedField> {\n+    fn from_text(text: &str) -> ast::NamedField {\n         ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}, }} }}\", text))\n     }\n \n-    pub fn from_pieces(name: &ast::NameRef, expr: Option<&ast::Expr>) -> TreeArc<ast::NamedField> {\n+    pub fn from_pieces(name: &ast::NameRef, expr: Option<&ast::Expr>) -> ast::NamedField {\n         match expr {\n             Some(expr) => Self::from_text(&format!(\"{}: {}\", name.syntax(), expr.syntax())),\n             None => Self::from_text(&name.syntax().to_string()),\n@@ -248,84 +253,86 @@ impl AstBuilder<ast::NamedField> {\n }\n \n impl AstBuilder<ast::Block> {\n-    fn from_text(text: &str) -> TreeArc<ast::Block> {\n+    fn from_text(text: &str) -> ast::Block {\n         ast_node_from_file_text(&format!(\"fn f() {}\", text))\n     }\n \n-    pub fn single_expr(e: &ast::Expr) -> TreeArc<ast::Block> {\n+    pub fn single_expr(e: &ast::Expr) -> ast::Block {\n         Self::from_text(&format!(\"{{ {} }}\", e.syntax()))\n     }\n }\n \n impl AstBuilder<ast::Expr> {\n-    fn from_text(text: &str) -> TreeArc<ast::Expr> {\n+    fn from_text(text: &str) -> ast::Expr {\n         ast_node_from_file_text(&format!(\"fn f() {{ {}; }}\", text))\n     }\n \n-    pub fn unit() -> TreeArc<ast::Expr> {\n+    pub fn unit() -> ast::Expr {\n         Self::from_text(\"()\")\n     }\n \n-    pub fn unimplemented() -> TreeArc<ast::Expr> {\n+    pub fn unimplemented() -> ast::Expr {\n         Self::from_text(\"unimplemented!()\")\n     }\n }\n \n impl AstBuilder<ast::NameRef> {\n-    pub fn new(text: &str) -> TreeArc<ast::NameRef> {\n+    pub fn new(text: &str) -> ast::NameRef {\n         ast_node_from_file_text(&format!(\"fn f() {{ {}; }}\", text))\n     }\n }\n \n-fn ast_node_from_file_text<N: AstNode>(text: &str) -> TreeArc<N> {\n+fn ast_node_from_file_text<N: AstNode>(text: &str) -> N {\n     let parse = SourceFile::parse(text);\n     let res = parse.tree().syntax().descendants().find_map(N::cast).unwrap().to_owned();\n     res\n }\n \n mod tokens {\n     use once_cell::sync::Lazy;\n-    use ra_syntax::{AstNode, SourceFile, SyntaxKind::*, SyntaxToken, TreeArc, T};\n+    use ra_syntax::{AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken, T};\n \n-    static SOURCE_FILE: Lazy<TreeArc<SourceFile>> =\n-        Lazy::new(|| SourceFile::parse(\",\\n; ;\").tree().to_owned());\n+    static SOURCE_FILE: Lazy<Parse<SourceFile>> = Lazy::new(|| SourceFile::parse(\",\\n; ;\"));\n \n-    pub(crate) fn comma() -> SyntaxToken<'static> {\n+    pub(crate) fn comma() -> SyntaxToken {\n         SOURCE_FILE\n+            .tree()\n             .syntax()\n             .descendants_with_tokens()\n-            .filter_map(|it| it.as_token())\n+            .filter_map(|it| it.as_token().cloned())\n             .find(|it| it.kind() == T![,])\n             .unwrap()\n     }\n \n-    pub(crate) fn single_space() -> SyntaxToken<'static> {\n+    pub(crate) fn single_space() -> SyntaxToken {\n         SOURCE_FILE\n+            .tree()\n             .syntax()\n             .descendants_with_tokens()\n-            .filter_map(|it| it.as_token())\n+            .filter_map(|it| it.as_token().cloned())\n             .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \" \")\n             .unwrap()\n     }\n \n     #[allow(unused)]\n-    pub(crate) fn single_newline() -> SyntaxToken<'static> {\n+    pub(crate) fn single_newline() -> SyntaxToken {\n         SOURCE_FILE\n+            .tree()\n             .syntax()\n             .descendants_with_tokens()\n-            .filter_map(|it| it.as_token())\n+            .filter_map(|it| it.as_token().cloned())\n             .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \"\\n\")\n             .unwrap()\n     }\n \n-    pub(crate) struct WsBuilder(TreeArc<SourceFile>);\n+    pub(crate) struct WsBuilder(SourceFile);\n \n     impl WsBuilder {\n         pub(crate) fn new(text: &str) -> WsBuilder {\n             WsBuilder(SourceFile::parse(text).ok().unwrap())\n         }\n-        pub(crate) fn ws(&self) -> SyntaxToken<'_> {\n-            self.0.syntax().first_child_or_token().unwrap().as_token().unwrap()\n+        pub(crate) fn ws(&self) -> SyntaxToken {\n+            self.0.syntax().first_child_or_token().unwrap().as_token().cloned().unwrap()\n         }\n     }\n "}, {"sha": "0eb4bdb6225bcb78d2d2030289a6c2739f1df30d", "filename": "crates/ra_assists/src/auto_import.rs", "status": "modified", "additions": 76, "deletions": 67, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fauto_import.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -12,25 +12,25 @@ use ra_syntax::{\n     SyntaxNode, TextRange, T,\n };\n \n-fn collect_path_segments_raw<'a>(\n-    segments: &mut Vec<&'a ast::PathSegment>,\n-    mut path: &'a ast::Path,\n+fn collect_path_segments_raw(\n+    segments: &mut Vec<ast::PathSegment>,\n+    mut path: ast::Path,\n ) -> Option<usize> {\n     let oldlen = segments.len();\n     loop {\n         let mut children = path.syntax().children_with_tokens();\n         let (first, second, third) = (\n-            children.next().map(|n| (n, n.kind())),\n-            children.next().map(|n| (n, n.kind())),\n-            children.next().map(|n| (n, n.kind())),\n+            children.next().map(|n| (n.clone(), n.kind())),\n+            children.next().map(|n| (n.clone(), n.kind())),\n+            children.next().map(|n| (n.clone(), n.kind())),\n         );\n         match (first, second, third) {\n             (Some((subpath, PATH)), Some((_, T![::])), Some((segment, PATH_SEGMENT))) => {\n-                path = ast::Path::cast(subpath.as_node()?)?;\n-                segments.push(ast::PathSegment::cast(segment.as_node()?)?);\n+                path = ast::Path::cast(subpath.as_node()?.clone())?;\n+                segments.push(ast::PathSegment::cast(segment.as_node()?.clone())?);\n             }\n             (Some((segment, PATH_SEGMENT)), _, _) => {\n-                segments.push(ast::PathSegment::cast(segment.as_node()?)?);\n+                segments.push(ast::PathSegment::cast(segment.as_node()?.clone())?);\n                 break;\n             }\n             (_, _, _) => return None,\n@@ -60,7 +60,7 @@ fn fmt_segments_raw(segments: &[SmolStr], buf: &mut String) {\n }\n \n // Returns the numeber of common segments.\n-fn compare_path_segments(left: &[SmolStr], right: &[&ast::PathSegment]) -> usize {\n+fn compare_path_segments(left: &[SmolStr], right: &[ast::PathSegment]) -> usize {\n     left.iter().zip(right).filter(|(l, r)| compare_path_segment(l, r)).count()\n }\n \n@@ -81,43 +81,43 @@ fn compare_path_segment_with_name(a: &SmolStr, b: &ast::Name) -> bool {\n     a == b.text()\n }\n \n-#[derive(Copy, Clone)]\n-enum ImportAction<'a> {\n+#[derive(Clone)]\n+enum ImportAction {\n     Nothing,\n     // Add a brand new use statement.\n     AddNewUse {\n-        anchor: Option<&'a SyntaxNode>, // anchor node\n+        anchor: Option<SyntaxNode>, // anchor node\n         add_after_anchor: bool,\n     },\n \n     // To split an existing use statement creating a nested import.\n     AddNestedImport {\n         // how may segments matched with the target path\n         common_segments: usize,\n-        path_to_split: &'a ast::Path,\n+        path_to_split: ast::Path,\n         // the first segment of path_to_split we want to add into the new nested list\n-        first_segment_to_split: Option<&'a ast::PathSegment>,\n+        first_segment_to_split: Option<ast::PathSegment>,\n         // Wether to add 'self' in addition to the target path\n         add_self: bool,\n     },\n     // To add the target path to an existing nested import tree list.\n     AddInTreeList {\n         common_segments: usize,\n         // The UseTreeList where to add the target path\n-        tree_list: &'a ast::UseTreeList,\n+        tree_list: ast::UseTreeList,\n         add_self: bool,\n     },\n }\n \n-impl<'a> ImportAction<'a> {\n-    fn add_new_use(anchor: Option<&'a SyntaxNode>, add_after_anchor: bool) -> Self {\n+impl ImportAction {\n+    fn add_new_use(anchor: Option<SyntaxNode>, add_after_anchor: bool) -> Self {\n         ImportAction::AddNewUse { anchor, add_after_anchor }\n     }\n \n     fn add_nested_import(\n         common_segments: usize,\n-        path_to_split: &'a ast::Path,\n-        first_segment_to_split: Option<&'a ast::PathSegment>,\n+        path_to_split: ast::Path,\n+        first_segment_to_split: Option<ast::PathSegment>,\n         add_self: bool,\n     ) -> Self {\n         ImportAction::AddNestedImport {\n@@ -130,14 +130,14 @@ impl<'a> ImportAction<'a> {\n \n     fn add_in_tree_list(\n         common_segments: usize,\n-        tree_list: &'a ast::UseTreeList,\n+        tree_list: ast::UseTreeList,\n         add_self: bool,\n     ) -> Self {\n         ImportAction::AddInTreeList { common_segments, tree_list, add_self }\n     }\n \n-    fn better<'b>(left: &'b ImportAction<'a>, right: &'b ImportAction<'a>) -> &'b ImportAction<'a> {\n-        if left.is_better(right) {\n+    fn better(left: ImportAction, right: ImportAction) -> ImportAction {\n+        if left.is_better(&right) {\n             left\n         } else {\n             right\n@@ -166,12 +166,12 @@ impl<'a> ImportAction<'a> {\n \n // Find out the best ImportAction to import target path against current_use_tree.\n // If current_use_tree has a nested import the function gets called recursively on every UseTree inside a UseTreeList.\n-fn walk_use_tree_for_best_action<'a>(\n-    current_path_segments: &mut Vec<&'a ast::PathSegment>, // buffer containing path segments\n-    current_parent_use_tree_list: Option<&'a ast::UseTreeList>, // will be Some value if we are in a nested import\n-    current_use_tree: &'a ast::UseTree, // the use tree we are currently examinating\n-    target: &[SmolStr],                 // the path we want to import\n-) -> ImportAction<'a> {\n+fn walk_use_tree_for_best_action(\n+    current_path_segments: &mut Vec<ast::PathSegment>, // buffer containing path segments\n+    current_parent_use_tree_list: Option<ast::UseTreeList>, // will be Some value if we are in a nested import\n+    current_use_tree: ast::UseTree, // the use tree we are currently examinating\n+    target: &[SmolStr],             // the path we want to import\n+) -> ImportAction {\n     // We save the number of segments in the buffer so we can restore the correct segments\n     // before returning. Recursive call will add segments so we need to delete them.\n     let prev_len = current_path_segments.len();\n@@ -188,32 +188,36 @@ fn walk_use_tree_for_best_action<'a>(\n                     .syntax()\n                     .ancestors()\n                     .find_map(ast::UseItem::cast)\n-                    .map(AstNode::syntax),\n+                    .map(|it| it.syntax().clone()),\n                 true,\n             );\n         }\n     };\n \n     // This can happen only if current_use_tree is a direct child of a UseItem\n-    if let Some(name) = alias.and_then(ast::NameOwner::name) {\n-        if compare_path_segment_with_name(&target[0], name) {\n+    if let Some(name) = alias.and_then(|it| it.name()) {\n+        if compare_path_segment_with_name(&target[0], &name) {\n             return ImportAction::Nothing;\n         }\n     }\n \n-    collect_path_segments_raw(current_path_segments, path);\n+    collect_path_segments_raw(current_path_segments, path.clone());\n \n     // We compare only the new segments added in the line just above.\n     // The first prev_len segments were already compared in 'parent' recursive calls.\n     let left = target.split_at(prev_len).1;\n     let right = current_path_segments.split_at(prev_len).1;\n-    let common = compare_path_segments(left, right);\n+    let common = compare_path_segments(left, &right);\n     let mut action = match common {\n         0 => ImportAction::add_new_use(\n             // e.g: target is std::fmt and we can have\n             // use foo::bar\n             // We add a brand new use statement\n-            current_use_tree.syntax().ancestors().find_map(ast::UseItem::cast).map(AstNode::syntax),\n+            current_use_tree\n+                .syntax()\n+                .ancestors()\n+                .find_map(ast::UseItem::cast)\n+                .map(|it| it.syntax().clone()),\n             true,\n         ),\n         common if common == left.len() && left.len() == right.len() => {\n@@ -223,9 +227,9 @@ fn walk_use_tree_for_best_action<'a>(\n             if let Some(list) = tree_list {\n                 // In case 2 we need to add self to the nested list\n                 // unless it's already there\n-                let has_self = list.use_trees().map(ast::UseTree::path).any(|p| {\n-                    p.and_then(ast::Path::segment)\n-                        .and_then(ast::PathSegment::kind)\n+                let has_self = list.use_trees().map(|it| it.path()).any(|p| {\n+                    p.and_then(|it| it.segment())\n+                        .and_then(|it| it.kind())\n                         .filter(|k| *k == ast::PathSegmentKind::SelfKw)\n                         .is_some()\n                 });\n@@ -248,7 +252,7 @@ fn walk_use_tree_for_best_action<'a>(\n             ImportAction::add_nested_import(\n                 prev_len + common,\n                 path,\n-                Some(segments_to_split[0]),\n+                Some(segments_to_split[0].clone()),\n                 false,\n             )\n         }\n@@ -263,14 +267,18 @@ fn walk_use_tree_for_best_action<'a>(\n                     .syntax()\n                     .ancestors()\n                     .find_map(ast::UseItem::cast)\n-                    .map(AstNode::syntax),\n+                    .map(|it| it.syntax().clone()),\n                 true,\n             );\n             if let Some(list) = tree_list {\n                 // Case 2, check recursively if the path is already imported in the nested list\n                 for u in list.use_trees() {\n-                    let child_action =\n-                        walk_use_tree_for_best_action(current_path_segments, Some(list), u, target);\n+                    let child_action = walk_use_tree_for_best_action(\n+                        current_path_segments,\n+                        Some(list.clone()),\n+                        u,\n+                        target,\n+                    );\n                     if child_action.is_better(&better_action) {\n                         better_action = child_action;\n                         if let ImportAction::Nothing = better_action {\n@@ -291,7 +299,7 @@ fn walk_use_tree_for_best_action<'a>(\n             ImportAction::add_nested_import(\n                 prev_len + common,\n                 path,\n-                Some(segments_to_split[0]),\n+                Some(segments_to_split[0].clone()),\n                 true,\n             )\n         }\n@@ -302,7 +310,7 @@ fn walk_use_tree_for_best_action<'a>(\n             ImportAction::add_nested_import(\n                 prev_len + common,\n                 path,\n-                Some(segments_to_split[0]),\n+                Some(segments_to_split[0].clone()),\n                 false,\n             )\n         }\n@@ -311,7 +319,7 @@ fn walk_use_tree_for_best_action<'a>(\n \n     // If we are inside a UseTreeList adding a use statement become adding to the existing\n     // tree list.\n-    action = match (current_parent_use_tree_list, action) {\n+    action = match (current_parent_use_tree_list, action.clone()) {\n         (Some(use_tree_list), ImportAction::AddNewUse { .. }) => {\n             ImportAction::add_in_tree_list(prev_len, use_tree_list, false)\n         }\n@@ -323,19 +331,20 @@ fn walk_use_tree_for_best_action<'a>(\n     action\n }\n \n-fn best_action_for_target<'b, 'a: 'b>(\n-    container: &'a SyntaxNode,\n-    anchor: &'a SyntaxNode,\n-    target: &'b [SmolStr],\n-) -> ImportAction<'a> {\n+fn best_action_for_target(\n+    container: SyntaxNode,\n+    anchor: SyntaxNode,\n+    target: &[SmolStr],\n+) -> ImportAction {\n     let mut storage = Vec::with_capacity(16); // this should be the only allocation\n     let best_action = container\n         .children()\n         .filter_map(ast::UseItem::cast)\n-        .filter_map(ast::UseItem::use_tree)\n+        .filter_map(|it| it.use_tree())\n         .map(|u| walk_use_tree_for_best_action(&mut storage, None, u, target))\n-        .fold(None, |best, a| {\n-            best.and_then(|best| Some(*ImportAction::better(&best, &a))).or_else(|| Some(a))\n+        .fold(None, |best, a| match best {\n+            Some(best) => Some(ImportAction::better(best, a)),\n+            None => Some(a),\n         });\n \n     match best_action {\n@@ -386,7 +395,7 @@ fn make_assist(action: &ImportAction, target: &[SmolStr], edit: &mut TextEditBui\n }\n \n fn make_assist_add_new_use(\n-    anchor: &Option<&SyntaxNode>,\n+    anchor: &Option<SyntaxNode>,\n     after: bool,\n     target: &[SmolStr],\n     edit: &mut TextEditBuilder,\n@@ -396,7 +405,7 @@ fn make_assist_add_new_use(\n         let mut buf = String::new();\n         if after {\n             buf.push_str(\"\\n\");\n-            if let Some(spaces) = indent {\n+            if let Some(spaces) = &indent {\n                 buf.push_str(spaces);\n             }\n         }\n@@ -405,8 +414,8 @@ fn make_assist_add_new_use(\n         buf.push_str(\";\");\n         if !after {\n             buf.push_str(\"\\n\\n\");\n-            if let Some(spaces) = indent {\n-                buf.push_str(spaces);\n+            if let Some(spaces) = &indent {\n+                buf.push_str(&spaces);\n             }\n         }\n         let position = if after { anchor.range().end() } else { anchor.range().start() };\n@@ -444,7 +453,7 @@ fn make_assist_add_in_tree_list(\n \n fn make_assist_add_nested_import(\n     path: &ast::Path,\n-    first_segment_to_split: &Option<&ast::PathSegment>,\n+    first_segment_to_split: &Option<ast::PathSegment>,\n     target: &[SmolStr],\n     add_self: bool,\n     edit: &mut TextEditBuilder,\n@@ -482,7 +491,7 @@ fn apply_auto_import(\n     target: &[SmolStr],\n     edit: &mut TextEditBuilder,\n ) {\n-    let action = best_action_for_target(container, path.syntax(), target);\n+    let action = best_action_for_target(container.clone(), path.syntax().clone(), target);\n     make_assist(&action, target, edit);\n     if let Some(last) = path.segment() {\n         // Here we are assuming the assist will provide a  correct use statement\n@@ -522,26 +531,26 @@ pub fn auto_import_text_edit(\n     edit: &mut TextEditBuilder,\n ) {\n     let container = position.ancestors().find_map(|n| {\n-        if let Some(module) = ast::Module::cast(n) {\n-            return module.item_list().map(ast::AstNode::syntax);\n+        if let Some(module) = ast::Module::cast(n.clone()) {\n+            return module.item_list().map(|it| it.syntax().clone());\n         }\n-        ast::SourceFile::cast(n).map(ast::AstNode::syntax)\n+        ast::SourceFile::cast(n).map(|it| it.syntax().clone())\n     });\n \n     if let Some(container) = container {\n-        let action = best_action_for_target(container, anchor, target);\n+        let action = best_action_for_target(container, anchor.clone(), target);\n         make_assist(&action, target, edit);\n     }\n }\n \n pub(crate) fn auto_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let path: &ast::Path = ctx.node_at_offset()?;\n+    let path: ast::Path = ctx.node_at_offset()?;\n     // We don't want to mess with use statements\n     if path.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n         return None;\n     }\n \n-    let hir_path = hir::Path::from_ast(path)?;\n+    let hir_path = hir::Path::from_ast(path.clone())?;\n     let segments = collect_hir_path_segments(&hir_path);\n     if segments.len() < 2 {\n         return None;\n@@ -554,7 +563,7 @@ pub(crate) fn auto_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n                 format!(\"import {} in mod {}\", fmt_segments(&segments), name.text()),\n                 |edit| {\n                     let mut text_edit = TextEditBuilder::default();\n-                    apply_auto_import(item_list.syntax(), path, &segments, &mut text_edit);\n+                    apply_auto_import(item_list.syntax(), &path, &segments, &mut text_edit);\n                     edit.set_edit_builder(text_edit);\n                 },\n             );\n@@ -566,7 +575,7 @@ pub(crate) fn auto_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n             format!(\"import {} in the current file\", fmt_segments(&segments)),\n             |edit| {\n                 let mut text_edit = TextEditBuilder::default();\n-                apply_auto_import(current_file.syntax(), path, &segments, &mut text_edit);\n+                apply_auto_import(current_file.syntax(), &path, &segments, &mut text_edit);\n                 edit.set_edit_builder(text_edit);\n             },\n         );"}, {"sha": "ab10d2aa44c16307d3a0a33b80061e9b2a7b44e1", "filename": "crates/ra_assists/src/change_visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -35,7 +35,7 @@ fn add_vis(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         if parent.children().any(|child| child.kind() == VISIBILITY) {\n             return None;\n         }\n-        (vis_offset(parent), keyword.range())\n+        (vis_offset(&parent), keyword.range())\n     } else {\n         let ident = ctx.token_at_offset().find(|leaf| leaf.kind() == IDENT)?;\n         let field = ident.parent().ancestors().find_map(ast::NamedFieldDef::cast)?;\n@@ -65,7 +65,7 @@ fn vis_offset(node: &SyntaxNode) -> TextUnit {\n         .unwrap_or_else(|| node.range().start())\n }\n \n-fn change_vis(mut ctx: AssistCtx<impl HirDatabase>, vis: &ast::Visibility) -> Option<Assist> {\n+fn change_vis(mut ctx: AssistCtx<impl HirDatabase>, vis: ast::Visibility) -> Option<Assist> {\n     if vis.syntax().text() == \"pub\" {\n         ctx.add_action(AssistId(\"change_visibility\"), \"change to pub(crate)\", |edit| {\n             edit.target(vis.syntax().range());"}, {"sha": "b96806ac6659dc4b6d4af5c9efab1cfc9eaa2e90", "filename": "crates/ra_assists/src/fill_match_arms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -27,7 +27,7 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n         let mut arm_iter = arm_list.arms();\n         let first = arm_iter.next();\n \n-        match first {\n+        match &first {\n             // If there arm list is empty or there is only one trivial arm, then proceed.\n             Some(arm) if is_trivial_arm(arm) => {\n                 if arm_iter.next() != None {\n@@ -44,7 +44,7 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n \n     let expr = match_expr.expr()?;\n     let analyzer = hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, expr.syntax(), None);\n-    let match_expr_ty = analyzer.type_of(ctx.db, expr)?;\n+    let match_expr_ty = analyzer.type_of(ctx.db, &expr)?;\n     let enum_def = analyzer.autoderef(ctx.db, match_expr_ty).find_map(|ty| match ty.as_adt() {\n         Some((AdtDef::Enum(e), _)) => Some(e),\n         _ => None,"}, {"sha": "2e591ad3bd40c293bc727eea8e2b6a7bb8d02e2f", "filename": "crates/ra_assists/src/flip_binexpr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fflip_binexpr.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -6,8 +6,8 @@ use crate::{Assist, AssistCtx, AssistId};\n /// Flip binary expression assist.\n pub(crate) fn flip_binexpr(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let expr = ctx.node_at_offset::<BinExpr>()?;\n-    let lhs = expr.lhs()?.syntax();\n-    let rhs = expr.rhs()?.syntax();\n+    let lhs = expr.lhs()?.syntax().clone();\n+    let rhs = expr.rhs()?.syntax().clone();\n     let op_range = expr.op_token()?.range();\n     // The assist should be applied only if the cursor is on the operator\n     let cursor_in_range = ctx.frange.range.is_subrange(&op_range);"}, {"sha": "13016ae06d64608b50e613ecab20f8ba7519bff5", "filename": "crates/ra_assists/src/flip_comma.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -5,8 +5,8 @@ use crate::{Assist, AssistCtx, AssistId};\n \n pub(crate) fn flip_comma(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let comma = ctx.token_at_offset().find(|leaf| leaf.kind() == T![,])?;\n-    let prev = non_trivia_sibling(comma.into(), Direction::Prev)?;\n-    let next = non_trivia_sibling(comma.into(), Direction::Next)?;\n+    let prev = non_trivia_sibling(comma.clone().into(), Direction::Prev)?;\n+    let next = non_trivia_sibling(comma.clone().into(), Direction::Next)?;\n     ctx.add_action(AssistId(\"flip_comma\"), \"flip comma\", |edit| {\n         edit.target(comma.range());\n         edit.replace(prev.range(), next.to_string());"}, {"sha": "3c17089deb920e737e06fdd5d1f5eef429b3eae1", "filename": "crates/ra_assists/src/inline_local_variable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -16,18 +16,18 @@ pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Opt\n     if bind_pat.is_mutable() {\n         return None;\n     }\n-    let initializer_expr = let_stmt.initializer();\n+    let initializer_expr = let_stmt.initializer()?;\n     let delete_range = if let Some(whitespace) = let_stmt\n         .syntax()\n         .next_sibling_or_token()\n-        .and_then(|it| ast::Whitespace::cast(it.as_token()?))\n+        .and_then(|it| ast::Whitespace::cast(it.as_token()?.clone()))\n     {\n         TextRange::from_to(let_stmt.syntax().range().start(), whitespace.syntax().range().end())\n     } else {\n         let_stmt.syntax().range()\n     };\n     let analyzer = hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, bind_pat.syntax(), None);\n-    let refs = analyzer.find_all_refs(bind_pat);\n+    let refs = analyzer.find_all_refs(&bind_pat);\n \n     let mut wrap_in_parens = vec![true; refs.len()];\n \n@@ -45,7 +45,7 @@ pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Opt\n             }\n         };\n \n-        wrap_in_parens[i] = match (initializer_expr?.kind(), usage_parent.kind()) {\n+        wrap_in_parens[i] = match (initializer_expr.kind(), usage_parent.kind()) {\n             (ExprKind::CallExpr(_), _)\n             | (ExprKind::IndexExpr(_), _)\n             | (ExprKind::MethodCallExpr(_), _)\n@@ -71,7 +71,7 @@ pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Opt\n         };\n     }\n \n-    let init_str = initializer_expr?.syntax().text().to_string();\n+    let init_str = initializer_expr.syntax().text().to_string();\n     let init_in_paren = format!(\"({})\", &init_str);\n \n     ctx.add_action("}, {"sha": "ce28132c9af93c233d7d84eebb17fae9fdbbbe01", "filename": "crates/ra_assists/src/introduce_variable.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -20,8 +20,8 @@ pub(crate) fn introduce_variable(mut ctx: AssistCtx<impl HirDatabase>) -> Option\n         return None;\n     }\n     let expr = node.ancestors().find_map(valid_target_expr)?;\n-    let (anchor_stmt, wrap_in_block) = anchor_stmt(expr)?;\n-    let indent = anchor_stmt.prev_sibling_or_token()?.as_token()?;\n+    let (anchor_stmt, wrap_in_block) = anchor_stmt(expr.clone())?;\n+    let indent = anchor_stmt.prev_sibling_or_token()?.as_token()?.clone();\n     if indent.kind() != WHITESPACE {\n         return None;\n     }\n@@ -37,9 +37,9 @@ pub(crate) fn introduce_variable(mut ctx: AssistCtx<impl HirDatabase>) -> Option\n         };\n \n         expr.syntax().text().push_to(&mut buf);\n-        let full_stmt = ast::ExprStmt::cast(anchor_stmt);\n-        let is_full_stmt = if let Some(expr_stmt) = full_stmt {\n-            Some(expr.syntax()) == expr_stmt.expr().map(|e| e.syntax())\n+        let full_stmt = ast::ExprStmt::cast(anchor_stmt.clone());\n+        let is_full_stmt = if let Some(expr_stmt) = &full_stmt {\n+            Some(expr.syntax().clone()) == expr_stmt.expr().map(|e| e.syntax().clone())\n         } else {\n             false\n         };\n@@ -81,7 +81,7 @@ pub(crate) fn introduce_variable(mut ctx: AssistCtx<impl HirDatabase>) -> Option\n \n /// Check whether the node is a valid expression which can be extracted to a variable.\n /// In general that's true for any expression, but in some cases that would produce invalid code.\n-fn valid_target_expr(node: &SyntaxNode) -> Option<&ast::Expr> {\n+fn valid_target_expr(node: SyntaxNode) -> Option<ast::Expr> {\n     match node.kind() {\n         PATH_EXPR => None,\n         BREAK_EXPR => ast::BreakExpr::cast(node).and_then(|e| e.expr()),\n@@ -96,14 +96,10 @@ fn valid_target_expr(node: &SyntaxNode) -> Option<&ast::Expr> {\n /// to produce correct code.\n /// It can be a statement, the last in a block expression or a wanna be block\n /// expression like a lambda or match arm.\n-fn anchor_stmt(expr: &ast::Expr) -> Option<(&SyntaxNode, bool)> {\n+fn anchor_stmt(expr: ast::Expr) -> Option<(SyntaxNode, bool)> {\n     expr.syntax().ancestors().find_map(|node| {\n-        if ast::Stmt::cast(node).is_some() {\n-            return Some((node, false));\n-        }\n-\n         if let Some(expr) = node.parent().and_then(ast::Block::cast).and_then(|it| it.expr()) {\n-            if expr.syntax() == node {\n+            if expr.syntax() == &node {\n                 tested_by!(test_introduce_var_last_expr);\n                 return Some((node, false));\n             }\n@@ -115,6 +111,10 @@ fn anchor_stmt(expr: &ast::Expr) -> Option<(&SyntaxNode, bool)> {\n             }\n         }\n \n+        if ast::Stmt::cast(node.clone()).is_some() {\n+            return Some((node, false));\n+        }\n+\n         None\n     })\n }"}, {"sha": "313c9ad1878ca9260d79a95419d2f87915b23762", "filename": "crates/ra_assists/src/move_guard.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fmove_guard.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -18,9 +18,9 @@ pub(crate) fn move_guard_to_arm_body(mut ctx: AssistCtx<impl HirDatabase>) -> Op\n \n     ctx.add_action(AssistId(\"move_guard_to_arm_body\"), \"move guard to arm body\", |edit| {\n         edit.target(guard.syntax().range());\n-        let offseting_amount = match space_before_guard {\n+        let offseting_amount = match &space_before_guard {\n             Some(SyntaxElement::Token(tok)) => {\n-                if let Some(_) = ast::Whitespace::cast(tok) {\n+                if let Some(_) = ast::Whitespace::cast(tok.clone()) {\n                     let ele = space_before_guard.unwrap().range();\n                     edit.delete(ele);\n                     ele.len()\n@@ -39,11 +39,11 @@ pub(crate) fn move_guard_to_arm_body(mut ctx: AssistCtx<impl HirDatabase>) -> Op\n }\n \n pub(crate) fn move_arm_cond_to_match_guard(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let match_arm: &MatchArm = ctx.node_at_offset::<MatchArm>()?;\n+    let match_arm: MatchArm = ctx.node_at_offset::<MatchArm>()?;\n     let last_match_pat = match_arm.pats().last()?;\n \n     let arm_body = match_arm.expr()?;\n-    let if_expr: &IfExpr = IfExpr::cast(arm_body.syntax())?;\n+    let if_expr: IfExpr = IfExpr::cast(arm_body.syntax().clone())?;\n     let cond = if_expr.condition()?;\n     let then_block = if_expr.then_branch()?;\n \n@@ -65,7 +65,7 @@ pub(crate) fn move_arm_cond_to_match_guard(mut ctx: AssistCtx<impl HirDatabase>)\n             edit.target(if_expr.syntax().range());\n             let then_only_expr = then_block.statements().next().is_none();\n \n-            match then_block.expr() {\n+            match &then_block.expr() {\n                 Some(then_expr) if then_only_expr => {\n                     edit.replace(if_expr.syntax().range(), then_expr.syntax().text())\n                 }"}, {"sha": "c330bc82783a11a3f329a5e755be06ef113568aa", "filename": "crates/ra_assists/src/remove_dbg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -8,7 +8,7 @@ use ra_syntax::{\n pub(crate) fn remove_dbg(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let macro_call = ctx.node_at_offset::<ast::MacroCall>()?;\n \n-    if !is_valid_macrocall(macro_call, \"dbg\")? {\n+    if !is_valid_macrocall(&macro_call, \"dbg\")? {\n         return None;\n     }\n \n@@ -35,7 +35,7 @@ pub(crate) fn remove_dbg(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist>\n     };\n \n     let macro_content = {\n-        let macro_args = macro_call.token_tree()?.syntax();\n+        let macro_args = macro_call.token_tree()?.syntax().clone();\n         let range = macro_args.range();\n         let start = range.start() + TextUnit::of_char('(');\n         let end = range.end() - TextUnit::of_char(')');\n@@ -65,7 +65,7 @@ fn is_valid_macrocall(macro_call: &ast::MacroCall, macro_name: &str) -> Option<b\n         return None;\n     }\n \n-    let node = macro_call.token_tree()?.syntax();\n+    let node = macro_call.token_tree()?.syntax().clone();\n     let first_child = node.first_child_or_token()?;\n     let last_child = node.last_child_or_token()?;\n "}, {"sha": "5de6aa2664ad291c8a7f1724082eaf6d02a6aa3e", "filename": "crates/ra_assists/src/replace_if_let_with_match.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{ast, AstNode};\n use crate::{Assist, AssistCtx, AssistId};\n \n pub(crate) fn replace_if_let_with_match(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let if_expr: &ast::IfExpr = ctx.node_at_offset()?;\n+    let if_expr: ast::IfExpr = ctx.node_at_offset()?;\n     let cond = if_expr.condition()?;\n     let pat = cond.pat()?;\n     let expr = cond.expr()?;\n@@ -25,16 +25,11 @@ pub(crate) fn replace_if_let_with_match(mut ctx: AssistCtx<impl HirDatabase>) ->\n     ctx.build()\n }\n \n-fn build_match_expr(\n-    expr: &ast::Expr,\n-    pat1: &ast::Pat,\n-    arm1: &ast::Block,\n-    arm2: &ast::Block,\n-) -> String {\n+fn build_match_expr(expr: ast::Expr, pat1: ast::Pat, arm1: ast::Block, arm2: ast::Block) -> String {\n     let mut buf = String::new();\n     buf.push_str(&format!(\"match {} {{\\n\", expr.syntax().text()));\n-    buf.push_str(&format!(\"    {} => {}\\n\", pat1.syntax().text(), format_arm(arm1)));\n-    buf.push_str(&format!(\"    _ => {}\\n\", format_arm(arm2)));\n+    buf.push_str(&format!(\"    {} => {}\\n\", pat1.syntax().text(), format_arm(&arm1)));\n+    buf.push_str(&format!(\"    _ => {}\\n\", format_arm(&arm2)));\n     buf.push_str(\"}\");\n     buf\n }"}, {"sha": "ceb603c5052f57541af17db9c74cf3cadc5e7174", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "patch": "@@ -25,7 +25,7 @@ pub use self::{\n /// conversion itself has zero runtime cost: ast and syntax nodes have exactly\n /// the same representation: a pointer to the tree root and a pointer to the\n /// node itself.\n-pub trait AstNode {\n+pub trait AstNode: Clone {\n     fn cast(syntax: SyntaxNode) -> Option<Self>\n     where\n         Self: Sized;"}]}