{"sha": "3168148cc626c26658d49f7304ff7f07194baec2", "node_id": "C_kwDOAAsO6NoAKDMxNjgxNDhjYzYyNmMyNjY1OGQ0OWY3MzA0ZmY3ZjA3MTk0YmFlYzI", "commit": {"author": {"name": "Jake Heinz", "email": "jh@discordapp.com", "date": "2022-01-14T09:11:47Z"}, "committer": {"name": "Jake Heinz", "email": "jh@discordapp.com", "date": "2022-01-14T09:16:35Z"}, "message": "ide: parallel prime caches", "tree": {"sha": "84eb2db02eaa88fb6353cdf9131efcd675a83dd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84eb2db02eaa88fb6353cdf9131efcd675a83dd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3168148cc626c26658d49f7304ff7f07194baec2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3168148cc626c26658d49f7304ff7f07194baec2", "html_url": "https://github.com/rust-lang/rust/commit/3168148cc626c26658d49f7304ff7f07194baec2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3168148cc626c26658d49f7304ff7f07194baec2/comments", "author": {"login": "jhgg", "id": 5489149, "node_id": "MDQ6VXNlcjU0ODkxNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5489149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhgg", "html_url": "https://github.com/jhgg", "followers_url": "https://api.github.com/users/jhgg/followers", "following_url": "https://api.github.com/users/jhgg/following{/other_user}", "gists_url": "https://api.github.com/users/jhgg/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhgg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhgg/subscriptions", "organizations_url": "https://api.github.com/users/jhgg/orgs", "repos_url": "https://api.github.com/users/jhgg/repos", "events_url": "https://api.github.com/users/jhgg/events{/privacy}", "received_events_url": "https://api.github.com/users/jhgg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jhgg", "id": 5489149, "node_id": "MDQ6VXNlcjU0ODkxNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5489149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhgg", "html_url": "https://github.com/jhgg", "followers_url": "https://api.github.com/users/jhgg/followers", "following_url": "https://api.github.com/users/jhgg/following{/other_user}", "gists_url": "https://api.github.com/users/jhgg/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhgg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhgg/subscriptions", "organizations_url": "https://api.github.com/users/jhgg/orgs", "repos_url": "https://api.github.com/users/jhgg/repos", "events_url": "https://api.github.com/users/jhgg/events{/privacy}", "received_events_url": "https://api.github.com/users/jhgg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4c31481a554d0132003228ba319bd9476fe85ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4c31481a554d0132003228ba319bd9476fe85ae", "html_url": "https://github.com/rust-lang/rust/commit/b4c31481a554d0132003228ba319bd9476fe85ae"}], "stats": {"total": 297, "additions": 273, "deletions": 24}, "files": [{"sha": "915da5d2837dd1523527b69af545bedebafabf4f", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3168148cc626c26658d49f7304ff7f07194baec2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3168148cc626c26658d49f7304ff7f07194baec2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3168148cc626c26658d49f7304ff7f07194baec2", "patch": "@@ -577,6 +577,8 @@ version = \"0.0.0\"\n dependencies = [\n  \"cfg\",\n  \"cov-mark\",\n+ \"crossbeam-channel\",\n+ \"crossbeam-utils\",\n  \"dot\",\n  \"either\",\n  \"expect-test\","}, {"sha": "8cddc1e8ec2e26db40edcfdb27cc50a210b45fa0", "filename": "crates/ide/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3168148cc626c26658d49f7304ff7f07194baec2/crates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3168148cc626c26658d49f7304ff7f07194baec2/crates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2FCargo.toml?ref=3168148cc626c26658d49f7304ff7f07194baec2", "patch": "@@ -11,6 +11,8 @@ doctest = false\n \n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n+crossbeam-channel = \"0.5.0\"\n+crossbeam-utils = \"0.8.5\"\n either = \"1.5.3\"\n itertools = \"0.10.0\"\n tracing = \"0.1\""}, {"sha": "5c872fe9c71cefb2050c2a83dcb242ee311fc087", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3168148cc626c26658d49f7304ff7f07194baec2/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3168148cc626c26658d49f7304ff7f07194baec2/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=3168148cc626c26658d49f7304ff7f07194baec2", "patch": "@@ -87,7 +87,7 @@ pub use crate::{\n     moniker::{MonikerKind, MonikerResult, PackageInformation},\n     move_item::Direction,\n     navigation_target::NavigationTarget,\n-    prime_caches::PrimeCachesProgress,\n+    prime_caches::{ParallelPrimeCachesProgress, PrimeCachesProgress},\n     references::ReferenceSearchResult,\n     rename::RenameError,\n     runnables::{Runnable, RunnableKind, TestId},\n@@ -251,6 +251,13 @@ impl Analysis {\n         self.with_db(move |db| prime_caches::prime_caches(db, &cb))\n     }\n \n+    pub fn parallel_prime_caches<F>(&self, num_worker_threads: u8, cb: F) -> Cancellable<()>\n+    where\n+        F: Fn(ParallelPrimeCachesProgress) + Sync + std::panic::UnwindSafe,\n+    {\n+        self.with_db(move |db| prime_caches::parallel_prime_caches(db, num_worker_threads, &cb))\n+    }\n+\n     /// Gets the text of the source file.\n     pub fn file_text(&self, file_id: FileId) -> Cancellable<Arc<String>> {\n         self.with_db(|db| db.file_text(file_id))"}, {"sha": "b873329e86127143e4f24e086f33ba20a95e82f0", "filename": "crates/ide/src/prime_caches.rs", "status": "modified", "additions": 141, "deletions": 16, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/3168148cc626c26658d49f7304ff7f07194baec2/crates%2Fide%2Fsrc%2Fprime_caches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3168148cc626c26658d49f7304ff7f07194baec2/crates%2Fide%2Fsrc%2Fprime_caches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fprime_caches.rs?ref=3168148cc626c26658d49f7304ff7f07194baec2", "patch": "@@ -2,10 +2,14 @@\n //! sometimes is counter productive when, for example, the first goto definition\n //! request takes longer to compute. This modules implemented prepopulation of\n //! various caches, it's not really advanced at the moment.\n+mod topologic_sort;\n \n use hir::db::DefDatabase;\n-use ide_db::base_db::{SourceDatabase, SourceDatabaseExt};\n-use rustc_hash::FxHashSet;\n+use ide_db::base_db::{\n+    salsa::{Database, ParallelDatabase, Snapshot},\n+    Cancelled, CrateGraph, CrateId, SourceDatabase, SourceDatabaseExt,\n+};\n+use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::RootDatabase;\n \n@@ -20,29 +24,150 @@ pub struct PrimeCachesProgress {\n pub(crate) fn prime_caches(db: &RootDatabase, cb: &(dyn Fn(PrimeCachesProgress) + Sync)) {\n     let _p = profile::span(\"prime_caches\");\n     let graph = db.crate_graph();\n+    let to_prime = compute_crates_to_prime(db, &graph);\n+\n+    let n_total = to_prime.len();\n+    for (n_done, &crate_id) in to_prime.iter().enumerate() {\n+        let crate_name = graph[crate_id].display_name.as_deref().unwrap_or_default().to_string();\n+\n+        cb(PrimeCachesProgress { on_crate: crate_name, n_done, n_total });\n+        // This also computes the DefMap\n+        db.import_map(crate_id);\n+    }\n+}\n+\n+/// We're indexing many crates.\n+#[derive(Debug)]\n+pub struct ParallelPrimeCachesProgress {\n+    /// the crates that we are currently priming.\n+    pub crates_currently_indexing: Vec<String>,\n+    /// the total number of crates we want to prime.\n+    pub crates_total: usize,\n+    /// the total number of crates that have finished priming\n+    pub crates_done: usize,\n+}\n+\n+pub(crate) fn parallel_prime_caches<F>(db: &RootDatabase, num_worker_threads: u8, cb: &F)\n+where\n+    F: Fn(ParallelPrimeCachesProgress) + Sync + std::panic::UnwindSafe,\n+{\n+    let _p = profile::span(\"prime_caches\");\n+\n+    let graph = db.crate_graph();\n+    let mut crates_to_prime = {\n+        let crate_ids = compute_crates_to_prime(db, &graph);\n+\n+        let mut builder = topologic_sort::TopologicalSortIter::builder();\n+\n+        for &crate_id in &crate_ids {\n+            let crate_data = &graph[crate_id];\n+            let dependencies = crate_data\n+                .dependencies\n+                .iter()\n+                .map(|d| d.crate_id)\n+                .filter(|i| crate_ids.contains(i));\n+\n+            builder.add(crate_id, dependencies);\n+        }\n+\n+        builder.build()\n+    };\n+\n+    crossbeam_utils::thread::scope(move |s| {\n+        let (work_sender, work_receiver) = crossbeam_channel::unbounded();\n+        let (progress_sender, progress_receiver) = crossbeam_channel::unbounded();\n+\n+        enum ParallelPrimeCacheWorkerProgress {\n+            BeginCrate { crate_id: CrateId, crate_name: String },\n+            EndCrate { crate_id: CrateId, cancelled: bool },\n+        }\n+\n+        let prime_caches_worker = move |db: Snapshot<RootDatabase>| {\n+            while let Ok((crate_id, crate_name)) = work_receiver.recv() {\n+                progress_sender\n+                    .send(ParallelPrimeCacheWorkerProgress::BeginCrate { crate_id, crate_name })?;\n+\n+                let cancelled = Cancelled::catch(|| {\n+                    // This also computes the DefMap\n+                    db.import_map(crate_id);\n+                })\n+                .is_err();\n+\n+                progress_sender\n+                    .send(ParallelPrimeCacheWorkerProgress::EndCrate { crate_id, cancelled })?;\n+\n+                if cancelled {\n+                    break;\n+                }\n+            }\n+\n+            Ok::<_, crossbeam_channel::SendError<_>>(())\n+        };\n+\n+        for _ in 0..num_worker_threads {\n+            let worker = prime_caches_worker.clone();\n+            let db = db.snapshot();\n+            s.spawn(move |_| worker(db));\n+        }\n+\n+        let crates_total = crates_to_prime.len();\n+        let mut crates_done = 0;\n+\n+        let mut is_cancelled = false;\n+        let mut crates_currently_indexing =\n+            FxHashMap::with_capacity_and_hasher(num_worker_threads as _, Default::default());\n+\n+        while !crates_to_prime.is_empty() && !is_cancelled {\n+            for crate_id in &mut crates_to_prime {\n+                work_sender\n+                    .send((\n+                        crate_id,\n+                        graph[crate_id].display_name.as_deref().unwrap_or_default().to_string(),\n+                    ))\n+                    .ok();\n+            }\n+\n+            let worker_progress = match progress_receiver.recv() {\n+                Ok(p) => p,\n+                Err(_) => break,\n+            };\n+            match worker_progress {\n+                ParallelPrimeCacheWorkerProgress::BeginCrate { crate_id, crate_name } => {\n+                    crates_currently_indexing.insert(crate_id, crate_name);\n+                }\n+                ParallelPrimeCacheWorkerProgress::EndCrate { crate_id, cancelled } => {\n+                    crates_currently_indexing.remove(&crate_id);\n+                    crates_to_prime.mark_done(crate_id);\n+                    crates_done += 1;\n+                    is_cancelled = cancelled;\n+                }\n+            };\n+\n+            let progress = ParallelPrimeCachesProgress {\n+                crates_currently_indexing: crates_currently_indexing.values().cloned().collect(),\n+                crates_done,\n+                crates_total,\n+            };\n+\n+            cb(progress);\n+            db.unwind_if_cancelled();\n+        }\n+    })\n+    .unwrap();\n+}\n+\n+fn compute_crates_to_prime(db: &RootDatabase, graph: &CrateGraph) -> FxHashSet<CrateId> {\n     // We're only interested in the workspace crates and the `ImportMap`s of their direct\n     // dependencies, though in practice the latter also compute the `DefMap`s.\n     // We don't prime transitive dependencies because they're generally not visible in\n     // the current workspace.\n-    let to_prime: FxHashSet<_> = graph\n+    graph\n         .iter()\n         .filter(|&id| {\n             let file_id = graph[id].root_file_id;\n             let root_id = db.file_source_root(file_id);\n             !db.source_root(root_id).is_library\n         })\n         .flat_map(|id| graph[id].dependencies.iter().map(|krate| krate.crate_id))\n-        .collect();\n-\n-    // FIXME: This would be easy to parallelize, since it's in the ideal ordering for that.\n-    // Unfortunately rayon prevents panics from propagation out of a `scope`, which breaks\n-    // cancellation, so we cannot use rayon.\n-    let n_total = to_prime.len();\n-    for (n_done, &crate_id) in to_prime.iter().enumerate() {\n-        let crate_name = graph[crate_id].display_name.as_deref().unwrap_or_default().to_string();\n-\n-        cb(PrimeCachesProgress { on_crate: crate_name, n_done, n_total });\n-        // This also computes the DefMap\n-        db.import_map(crate_id);\n-    }\n+        .collect()\n }"}, {"sha": "f89f84bc5b54c7356fbd1f9915e93a3e57af669c", "filename": "crates/ide/src/prime_caches/topologic_sort.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/3168148cc626c26658d49f7304ff7f07194baec2/crates%2Fide%2Fsrc%2Fprime_caches%2Ftopologic_sort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3168148cc626c26658d49f7304ff7f07194baec2/crates%2Fide%2Fsrc%2Fprime_caches%2Ftopologic_sort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fprime_caches%2Ftopologic_sort.rs?ref=3168148cc626c26658d49f7304ff7f07194baec2", "patch": "@@ -0,0 +1,101 @@\n+use std::{collections::VecDeque, hash::Hash};\n+\n+use rustc_hash::FxHashMap;\n+\n+pub struct TopologicSortIterBuilder<T> {\n+    nodes: FxHashMap<T, Entry<T>>,\n+}\n+\n+impl<T> TopologicSortIterBuilder<T>\n+where\n+    T: Copy + Eq + PartialEq + Hash,\n+{\n+    fn new() -> Self {\n+        Self { nodes: Default::default() }\n+    }\n+\n+    fn get_or_create_entry(&mut self, item: T) -> &mut Entry<T> {\n+        self.nodes.entry(item).or_default()\n+    }\n+\n+    pub fn add(&mut self, item: T, predecessors: impl IntoIterator<Item = T>) {\n+        let mut num_predecessors = 0;\n+\n+        for predecessor in predecessors.into_iter() {\n+            self.get_or_create_entry(predecessor).successors.push(item);\n+            num_predecessors += 1;\n+        }\n+\n+        let entry = self.get_or_create_entry(item);\n+        entry.num_predecessors += num_predecessors;\n+    }\n+\n+    pub fn build(self) -> TopologicalSortIter<T> {\n+        let ready = self\n+            .nodes\n+            .iter()\n+            .filter_map(\n+                |(item, entry)| if entry.num_predecessors == 0 { Some(*item) } else { None },\n+            )\n+            .collect();\n+\n+        TopologicalSortIter { nodes: self.nodes, ready }\n+    }\n+}\n+\n+pub struct TopologicalSortIter<T> {\n+    ready: VecDeque<T>,\n+    nodes: FxHashMap<T, Entry<T>>,\n+}\n+\n+impl<T> TopologicalSortIter<T>\n+where\n+    T: Copy + Eq + PartialEq + Hash,\n+{\n+    pub fn builder() -> TopologicSortIterBuilder<T> {\n+        TopologicSortIterBuilder::new()\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        self.nodes.len()\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+\n+    pub fn mark_done(&mut self, item: T) {\n+        let entry = self.nodes.remove(&item).expect(\"invariant: unknown item marked as done\");\n+\n+        for successor in entry.successors {\n+            let succ_entry = self\n+                .nodes\n+                .get_mut(&successor)\n+                .expect(\"invariant: unknown successor referenced by entry\");\n+\n+            succ_entry.num_predecessors -= 1;\n+            if succ_entry.num_predecessors == 0 {\n+                self.ready.push_back(successor);\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Iterator for TopologicalSortIter<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.ready.pop_front()\n+    }\n+}\n+\n+struct Entry<T> {\n+    successors: Vec<T>,\n+    num_predecessors: usize,\n+}\n+\n+impl<T> Default for Entry<T> {\n+    fn default() -> Self {\n+        Self { successors: Default::default(), num_predecessors: 0 }\n+    }\n+}"}, {"sha": "c0736ede09024aa41b817c868bb9cbeabb45ace6", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3168148cc626c26658d49f7304ff7f07194baec2/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3168148cc626c26658d49f7304ff7f07194baec2/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=3168148cc626c26658d49f7304ff7f07194baec2", "patch": "@@ -70,7 +70,7 @@ pub(crate) enum Task {\n #[derive(Debug)]\n pub(crate) enum PrimeCachesProgress {\n     Begin,\n-    Report(ide::PrimeCachesProgress),\n+    Report(ide::ParallelPrimeCachesProgress),\n     End { cancelled: bool },\n }\n \n@@ -291,11 +291,23 @@ impl GlobalState {\n                         }\n                         PrimeCachesProgress::Report(report) => {\n                             state = Progress::Report;\n-                            message = Some(format!(\n-                                \"{}/{} ({})\",\n-                                report.n_done, report.n_total, report.on_crate\n-                            ));\n-                            fraction = Progress::fraction(report.n_done, report.n_total);\n+\n+                            message = match &report.crates_currently_indexing[..] {\n+                                [crate_name] => Some(format!(\n+                                    \"{}/{} ({})\",\n+                                    report.crates_done, report.crates_total, crate_name\n+                                )),\n+                                [crate_name, rest @ ..] => Some(format!(\n+                                    \"{}/{} ({} + {} more)\",\n+                                    report.crates_done,\n+                                    report.crates_total,\n+                                    crate_name,\n+                                    rest.len()\n+                                )),\n+                                _ => None,\n+                            };\n+\n+                            fraction = Progress::fraction(report.crates_done, report.crates_total);\n                         }\n                         PrimeCachesProgress::End { cancelled } => {\n                             state = Progress::End;\n@@ -497,7 +509,7 @@ impl GlobalState {\n                 let analysis = self.snapshot().analysis;\n                 move |sender| {\n                     sender.send(Task::PrimeCaches(PrimeCachesProgress::Begin)).unwrap();\n-                    let res = analysis.prime_caches(|progress| {\n+                    let res = analysis.parallel_prime_caches(32, |progress| {\n                         let report = PrimeCachesProgress::Report(progress);\n                         sender.send(Task::PrimeCaches(report)).unwrap();\n                     });"}]}