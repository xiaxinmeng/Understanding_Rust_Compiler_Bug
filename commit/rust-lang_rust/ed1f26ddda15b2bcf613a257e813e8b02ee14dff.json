{"sha": "ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMWYyNmRkZGExNWIyYmNmNjEzYTI1N2U4MTNlOGIwMmVlMTRkZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-02T14:56:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-02T14:56:11Z"}, "message": "Auto merge of #41702 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 6 pull requests\n\n- Successful merges: #41661, #41662, #41673, #41688, #41692, #41693\n- Failed merges:", "tree": {"sha": "4bc9cd842d2113827d984404610e91f183dd62bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bc9cd842d2113827d984404610e91f183dd62bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "html_url": "https://github.com/rust-lang/rust/commit/ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96e2c34286099eea4f51daaadbb82a8fbe99e0f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/96e2c34286099eea4f51daaadbb82a8fbe99e0f6", "html_url": "https://github.com/rust-lang/rust/commit/96e2c34286099eea4f51daaadbb82a8fbe99e0f6"}, {"sha": "e0bfd19add662c07eb102818ce579315ddc90094", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0bfd19add662c07eb102818ce579315ddc90094", "html_url": "https://github.com/rust-lang/rust/commit/e0bfd19add662c07eb102818ce579315ddc90094"}], "stats": {"total": 2619, "additions": 1387, "deletions": 1232}, "files": [{"sha": "ad3cf31c1b921b50d41e0d256958eb22b841f241", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -414,8 +414,8 @@ def build_triple(self):\n         # The goal here is to come up with the same triple as LLVM would,\n         # at least for the subset of platforms we're willing to target.\n         if ostype == 'Linux':\n-            os = subprocess.check_output(['uname', '-o']).strip().decode(default_encoding)\n-            if os == 'Android':\n+            os_from_sp = subprocess.check_output(['uname', '-o']).strip().decode(default_encoding)\n+            if os_from_sp == 'Android':\n                 ostype = 'linux-android'\n             else:\n                 ostype = 'unknown-linux-gnu'"}, {"sha": "21c75ad3395113f6babecce7072eb8665030b326", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -276,7 +276,7 @@ pub trait Into<T>: Sized {\n pub trait From<T>: Sized {\n     /// Performs the conversion.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn from(T) -> Self;\n+    fn from(_: T) -> Self;\n }\n \n /// An attempted conversion that consumes `self`, which may or may not be"}, {"sha": "db12496b6f320aac7ea3fac44bd8b57f59a45ef1", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -403,8 +403,8 @@ impl<S: Sip> Default for Hasher<S> {\n \n #[doc(hidden)]\n trait Sip {\n-    fn c_rounds(&mut State);\n-    fn d_rounds(&mut State);\n+    fn c_rounds(_: &mut State);\n+    fn d_rounds(_: &mut State);\n }\n \n #[derive(Debug, Clone, Default)]"}, {"sha": "391b606f613f288970e7b74544d4e20e840eacb5", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -2878,10 +2878,10 @@ pub trait Carrier {\n     type Error;\n \n     /// Create a `Carrier` from a success value.\n-    fn from_success(Self::Success) -> Self;\n+    fn from_success(_: Self::Success) -> Self;\n \n     /// Create a `Carrier` from an error value.\n-    fn from_error(Self::Error) -> Self;\n+    fn from_error(_: Self::Error) -> Self;\n \n     /// Translate this `Carrier` to another implementation of `Carrier` with the\n     /// same associated types."}, {"sha": "67b9449981e0f02a4d24fa5adfb3928ec612665c", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -53,7 +53,7 @@ pub trait Sample<Support> {\n // trait called `Sample` and the other should be `DependentSample`.\n pub trait IndependentSample<Support>: Sample<Support> {\n     /// Generate a random value.\n-    fn ind_sample<R: Rng>(&self, &mut R) -> Support;\n+    fn ind_sample<R: Rng>(&self, _: &mut R) -> Support;\n }\n \n /// A wrapper for generating types that implement `Rand` via the"}, {"sha": "ca05db15ffeb9d44078b71576c0a6af56d5a57cf", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -329,7 +329,7 @@ impl<'a, R: fmt::Debug> fmt::Debug for AsciiGenerator<'a, R> {\n /// the same stream of randomness multiple times.\n pub trait SeedableRng<Seed>: Rng {\n     /// Reseed an RNG with the given seed.\n-    fn reseed(&mut self, Seed);\n+    fn reseed(&mut self, _: Seed);\n \n     /// Create a new RNG with the given seed.\n     fn from_seed(seed: Seed) -> Self;"}, {"sha": "a8ad49c6582d4f14cc56311bcec6c57716a53d87", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -15,9 +15,11 @@ use syntax::ast;\n use syntax::ptr::P;\n \n use hir::{self, PatKind};\n+use hir::def_id::DefId;\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    owner_def_id: DefId,\n     tables: &'a ty::TypeckTables<'tcx>,\n     graph: CFGGraph,\n     fn_exit: CFGIndex,\n@@ -56,6 +58,7 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let mut cfg_builder = CFGBuilder {\n         tcx: tcx,\n+        owner_def_id,\n         tables: tables,\n         graph: graph,\n         fn_exit: fn_exit,\n@@ -583,11 +586,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         scope_id: ast::NodeId,\n                         to_index: CFGIndex) {\n         let mut data = CFGEdgeData { exiting_scopes: vec![] };\n-        let mut scope = self.tcx.region_maps.node_extent(from_expr.id);\n-        let target_scope = self.tcx.region_maps.node_extent(scope_id);\n+        let mut scope = self.tcx.node_extent(from_expr.id);\n+        let target_scope = self.tcx.node_extent(scope_id);\n+        let region_maps = self.tcx.region_maps(self.owner_def_id);\n         while scope != target_scope {\n-            data.exiting_scopes.push(scope.node_id(&self.tcx.region_maps));\n-            scope = self.tcx.region_maps.encl_scope(scope);\n+            data.exiting_scopes.push(scope.node_id());\n+            scope = region_maps.encl_scope(scope);\n         }\n         self.graph.add_edge(from_index, to_index, data);\n     }"}, {"sha": "63a4e6196a2e9d8be4c14bc282c71f2631d9c37c", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -56,7 +56,7 @@ pub enum DepNode<D: Clone + Debug> {\n     WorkProduct(Arc<WorkProductId>),\n \n     // Represents different phases in the compiler.\n-    RegionResolveCrate,\n+    RegionMaps(D),\n     Coherence,\n     Resolve,\n     CoherenceCheckTrait(D),\n@@ -197,7 +197,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             BorrowCheckKrate => Some(BorrowCheckKrate),\n             MirKrate => Some(MirKrate),\n             TypeckBodiesKrate => Some(TypeckBodiesKrate),\n-            RegionResolveCrate => Some(RegionResolveCrate),\n             Coherence => Some(Coherence),\n             Resolve => Some(Resolve),\n             Variance => Some(Variance),\n@@ -223,6 +222,7 @@ impl<D: Clone + Debug> DepNode<D> {\n                 def_ids.map(MirShim)\n             }\n             BorrowCheck(ref d) => op(d).map(BorrowCheck),\n+            RegionMaps(ref d) => op(d).map(RegionMaps),\n             RvalueCheck(ref d) => op(d).map(RvalueCheck),\n             TransCrateItem(ref d) => op(d).map(TransCrateItem),\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),"}, {"sha": "3e610dd3c0d87a74eda2f237177080f37a1b9b24", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -39,7 +39,7 @@ use syntax::codemap::Spanned;\n use syntax_pos::Span;\n use hir::*;\n use hir::def::Def;\n-use hir::map::Map;\n+use hir::map::{self, Map};\n use super::itemlikevisit::DeepVisitor;\n \n use std::cmp;\n@@ -140,6 +140,23 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n pub trait Visitor<'v> : Sized {\n+    /// Invokes the suitable visitor method for the given `Node`\n+    /// extracted from the hir map.\n+    fn visit_hir_map_node(&mut self, node: map::Node<'v>) {\n+        match node {\n+            map::NodeItem(a) => self.visit_item(a),\n+            map::NodeForeignItem(a) => self.visit_foreign_item(a),\n+            map::NodeTraitItem(a) => self.visit_trait_item(a),\n+            map::NodeImplItem(a) => self.visit_impl_item(a),\n+            map::NodeExpr(a) => self.visit_expr(a),\n+            map::NodeStmt(a) => self.visit_stmt(a),\n+            map::NodeTy(a) => self.visit_ty(a),\n+            map::NodePat(a) => self.visit_pat(a),\n+            map::NodeBlock(a) => self.visit_block(a),\n+            _ => bug!(\"Visitor::visit_hir_map_node() not yet impl for node `{:?}`\", node)\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Nested items.\n "}, {"sha": "52bdb5d02406e4f79a6f8a3bce9ef39fe111cbd0", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::subst::Kind<'t\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Region {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionKind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -432,17 +432,6 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtent\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            hcx.tcx().region_maps.code_extent_data(*self).hash_stable(hcx, hasher);\n-        });\n-    }\n-}\n-\n impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtentData\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -477,7 +466,7 @@ impl_stable_hash_for!(struct ty::adjustment::CoerceUnsizedInfo {\n     custom_kind\n });\n \n-impl_stable_hash_for!(struct ty::FreeRegion {\n+impl_stable_hash_for!(struct ty::FreeRegion<'tcx> {\n     scope,\n     bound_region\n });"}, {"sha": "1bac512e20977b087d4fdd09b35e336bbf8e8e9b", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -315,7 +315,7 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n         }\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             // Never make variables for regions bound within the type itself,\n             // nor for erased regions."}, {"sha": "f0b179fa2e4205ac2d8b5f6b1818b71e3d193308", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -78,8 +78,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         }\n     }\n \n-    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n-               -> RelateResult<'tcx, &'tcx ty::Region> {\n+    fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "8f2bdd4e85c77ac725745b0724b8f6ef90a0a8fd", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -69,6 +69,7 @@ use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, Issue32330};\n use ty::error::TypeError;\n+use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n use errors::{DiagnosticBuilder, DiagnosticStyledString};\n \n@@ -78,7 +79,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n                                    err: &mut DiagnosticBuilder,\n                                    prefix: &str,\n-                                   region: &'tcx ty::Region,\n+                                   region: ty::Region<'tcx>,\n                                    suffix: &str) {\n         fn item_scope_tag(item: &hir::Item) -> &'static str {\n             match item.node {\n@@ -123,14 +124,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n                             prefix, scope, suffix)\n                 };\n-                let span = match scope.span(&self.region_maps, &self.hir) {\n+                let span = match scope.span(&self.hir) {\n                     Some(s) => s,\n                     None => {\n                         err.note(&unknown_scope());\n                         return;\n                     }\n                 };\n-                let tag = match self.hir.find(scope.node_id(&self.region_maps)) {\n+                let tag = match self.hir.find(scope.node_id()) {\n                     Some(hir_map::NodeBlock(_)) => \"block\",\n                     Some(hir_map::NodeExpr(expr)) => match expr.node {\n                         hir::ExprCall(..) => \"call\",\n@@ -150,7 +151,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         return;\n                     }\n                 };\n-                let scope_decorated_tag = match self.region_maps.code_extent_data(scope) {\n+                let scope_decorated_tag = match *scope {\n                     region::CodeExtentData::Misc(_) => tag,\n                     region::CodeExtentData::CallSiteScope { .. } => {\n                         \"scope of call-site for function\"\n@@ -183,7 +184,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 };\n \n-                let node = fr.scope.node_id(&self.region_maps);\n+                let node = fr.scope.map(|s| s.node_id())\n+                                   .unwrap_or(DUMMY_NODE_ID);\n                 let unknown;\n                 let tag = match self.hir.find(node) {\n                     Some(hir_map::NodeBlock(_)) |\n@@ -515,7 +517,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         values.1.push_normal(\"<\");\n                     }\n \n-                    fn lifetime_display(lifetime: &Region) -> String {\n+                    fn lifetime_display(lifetime: Region) -> String {\n                         let s = format!(\"{}\", lifetime);\n                         if s.is_empty() {\n                             \"'_\".to_string()\n@@ -767,7 +769,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn report_generic_bound_failure(&self,\n                                     origin: SubregionOrigin<'tcx>,\n                                     bound_kind: GenericKind<'tcx>,\n-                                    sub: &'tcx Region)\n+                                    sub: Region<'tcx>)\n     {\n         // FIXME: it would be better to report the first error message\n         // with the span of the parameter itself, rather than the span\n@@ -846,9 +848,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin<'tcx>,\n-                               sub_region: &'tcx Region,\n+                               sub_region: Region<'tcx>,\n                                sup_origin: SubregionOrigin<'tcx>,\n-                               sup_region: &'tcx Region) {\n+                               sup_region: Region<'tcx>) {\n         let mut err = self.report_inference_failure(var_origin);\n \n         self.tcx.note_and_explain_region(&mut err,"}, {"sha": "49952d81cbb0b8918bffae54a5b2769205506924", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -146,8 +146,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub(super) fn report_concrete_failure(&self,\n                                           origin: SubregionOrigin<'tcx>,\n-                                          sub: &'tcx Region,\n-                                          sup: &'tcx Region)\n+                                          sub: Region<'tcx>,\n+                                          sup: Region<'tcx>)\n                                           -> DiagnosticBuilder<'tcx> {\n         match origin {\n             infer::Subtype(trace) => {"}, {"sha": "ad67ef9a127d8fd79d6bf38be40afdc95dfe6531", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReEarlyBound(..) |\n             ty::ReLateBound(..) => {"}, {"sha": "a8bc33f772d55f2c4ffa0005f05cede611cca50d", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReVar(v) if self.region_vars.contains(&v) => {\n                 self.infcx.next_region_var(self.origin.clone())"}, {"sha": "d7afeba7dc96b430531a5697cd7ba019b4e8908f", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -59,8 +59,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         lattice::super_lattice_tys(self, a, b)\n     }\n \n-    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n-               -> RelateResult<'tcx, &'tcx ty::Region> {\n+    fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "09f909ef399d1652d130eaabc80901cb2b2f2694", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -269,9 +269,9 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n-                                             r0: &'tcx ty::Region)\n-                                             -> &'tcx ty::Region {\n+                                             a_map: &FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n+                                             r0: ty::Region<'tcx>)\n+                                             -> ty::Region<'tcx> {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // Variables created during LUB computation which are\n             // *related* to regions that pre-date the LUB computation\n             // stay as they are.\n-            if !tainted.iter().all(|r| is_var_in_set(new_vars, *r)) {\n+            if !tainted.iter().all(|&r| is_var_in_set(new_vars, r)) {\n                 debug!(\"generalize_region(r0={:?}): \\\n                         non-new-variables found in {:?}\",\n                        r0, tainted);\n@@ -365,11 +365,11 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n+                                             a_map: &FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n                                              a_vars: &[ty::RegionVid],\n                                              b_vars: &[ty::RegionVid],\n-                                             r0: &'tcx ty::Region)\n-                                             -> &'tcx ty::Region {\n+                                             r0: ty::Region<'tcx>)\n+                                             -> ty::Region<'tcx> {\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n                 return r0;\n@@ -434,8 +434,8 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn rev_lookup<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                       span: Span,\n-                                      a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n-                                      r: &'tcx ty::Region) -> &'tcx ty::Region\n+                                      a_map: &FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n+                                      r: ty::Region<'tcx>) -> ty::Region<'tcx>\n         {\n             for (a_br, a_r) in a_map {\n                 if *a_r == r {\n@@ -450,14 +450,14 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn fresh_bound_variable<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                                 debruijn: ty::DebruijnIndex)\n-                                                -> &'tcx ty::Region {\n+                                                -> ty::Region<'tcx> {\n             infcx.region_vars.new_bound(debruijn)\n         }\n     }\n }\n \n fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n-                           map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+                           map: &FxHashMap<ty::BoundRegion, ty::Region<'tcx>>)\n                            -> Vec<ty::RegionVid> {\n     map.iter()\n        .map(|(_, &r)| match *r {\n@@ -472,7 +472,7 @@ fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n        .collect()\n }\n \n-fn is_var_in_set(new_vars: &[ty::RegionVid], r: &ty::Region) -> bool {\n+fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n     match *r {\n         ty::ReVar(ref v) => new_vars.iter().any(|x| x == v),\n         _ => false\n@@ -484,7 +484,7 @@ fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                          mut fldr: F)\n                                          -> T\n     where T: TypeFoldable<'tcx>,\n-          F: FnMut(&'tcx ty::Region, ty::DebruijnIndex) -> &'tcx ty::Region,\n+          F: FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx>,\n {\n     tcx.fold_regions(unbound_value, &mut false, |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,\n@@ -502,9 +502,9 @@ fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn tainted_regions(&self,\n                        snapshot: &CombinedSnapshot,\n-                       r: &'tcx ty::Region,\n+                       r: ty::Region<'tcx>,\n                        directions: TaintDirections)\n-                       -> FxHashSet<&'tcx ty::Region> {\n+                       -> FxHashSet<ty::Region<'tcx>> {\n         self.region_vars.tainted(&snapshot.region_vars_snapshot, r, directions)\n     }\n \n@@ -731,7 +731,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // region back to the `ty::BoundRegion` that it originally\n         // represented. Because `leak_check` passed, we know that\n         // these taint sets are mutually disjoint.\n-        let inv_skol_map: FxHashMap<&'tcx ty::Region, ty::BoundRegion> =\n+        let inv_skol_map: FxHashMap<ty::Region<'tcx>, ty::BoundRegion> =\n             skol_map\n             .iter()\n             .flat_map(|(&skol_br, &skol)| {"}, {"sha": "04b470b29fc5e081b6127d850fe811c3b8ea08f2", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -59,8 +59,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         lattice::super_lattice_tys(self, a, b)\n     }\n \n-    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n-               -> RelateResult<'tcx, &'tcx ty::Region> {\n+    fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "e91af21c6db2c3d7acc6085b0aff8c13afb61a2b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -20,7 +20,8 @@ pub use self::region_inference::{GenericKind, VerifyBound};\n \n use hir::def_id::DefId;\n use hir;\n-use middle::free_region::FreeRegionMap;\n+use middle::free_region::{FreeRegionMap, RegionRelations};\n+use middle::region::RegionMaps;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::lang_items;\n@@ -205,7 +206,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n /// region that each late-bound region was replaced with.\n-pub type SkolemizationMap<'tcx> = FxHashMap<ty::BoundRegion, &'tcx ty::Region>;\n+pub type SkolemizationMap<'tcx> = FxHashMap<ty::BoundRegion, ty::Region<'tcx>>;\n \n /// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n@@ -1008,7 +1009,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn add_given(&self,\n-                     sub: ty::FreeRegion,\n+                     sub: ty::FreeRegion<'tcx>,\n                      sup: ty::RegionVid)\n     {\n         self.region_vars.add_given(sub, sup);\n@@ -1107,8 +1108,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn sub_regions(&self,\n                        origin: SubregionOrigin<'tcx>,\n-                       a: &'tcx ty::Region,\n-                       b: &'tcx ty::Region) {\n+                       a: ty::Region<'tcx>,\n+                       b: ty::Region<'tcx>) {\n         debug!(\"sub_regions({:?} <: {:?})\", a, b);\n         self.region_vars.make_subregion(origin, a, b);\n     }\n@@ -1210,7 +1211,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn next_region_var(&self, origin: RegionVariableOrigin)\n-                           -> &'tcx ty::Region {\n+                           -> ty::Region<'tcx> {\n         self.tcx.mk_region(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n@@ -1219,7 +1220,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn region_var_for_def(&self,\n                               span: Span,\n                               def: &ty::RegionParameterDef)\n-                              -> &'tcx ty::Region {\n+                              -> ty::Region<'tcx> {\n         self.next_region_var(EarlyBoundRegion(span, def.name, def.issue_32330))\n     }\n \n@@ -1270,7 +1271,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> &'tcx ty::Region {\n+    pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> ty::Region<'tcx> {\n         self.region_vars.new_bound(debruijn)\n     }\n \n@@ -1322,9 +1323,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn resolve_regions_and_report_errors(&self,\n-                                             free_regions: &FreeRegionMap,\n-                                             subject_node_id: ast::NodeId) {\n-        let errors = self.region_vars.resolve_regions(free_regions, subject_node_id);\n+                                             region_context: DefId,\n+                                             region_map: &RegionMaps<'tcx>,\n+                                             free_regions: &FreeRegionMap<'tcx>) {\n+        let region_rels = RegionRelations::new(self.tcx,\n+                                               region_context,\n+                                               region_map,\n+                                               free_regions);\n+        let errors = self.region_vars.resolve_regions(&region_rels);\n         if !self.is_tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors\n             // altogether if other errors have been reported while\n@@ -1531,7 +1537,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n         value: &ty::Binder<T>)\n-        -> (T, FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+        -> (T, FxHashMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where T : TypeFoldable<'tcx>\n     {\n         self.tcx.replace_late_bound_regions(\n@@ -1577,7 +1583,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn verify_generic_bound(&self,\n                                 origin: SubregionOrigin<'tcx>,\n                                 kind: GenericKind<'tcx>,\n-                                a: &'tcx ty::Region,\n+                                a: ty::Region<'tcx>,\n                                 bound: VerifyBound<'tcx>) {\n         debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\",\n                kind,"}, {"sha": "c48b8f610a2b735eea07a629d42b5d9e38d926d0", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -18,7 +18,9 @@\n /// For clarity, rename the graphviz crate locally to dot.\n use graphviz as dot;\n \n-use ty::{self, TyCtxt};\n+use hir::def_id::DefIndex;\n+use ty;\n+use middle::free_region::RegionRelations;\n use middle::region::CodeExtent;\n use super::Constraint;\n use infer::SubregionOrigin;\n@@ -32,7 +34,6 @@ use std::fs::File;\n use std::io;\n use std::io::prelude::*;\n use std::sync::atomic::{AtomicBool, Ordering};\n-use syntax::ast;\n \n fn print_help_message() {\n     println!(\"\\\n@@ -55,18 +56,18 @@ graphs will be printed.                                                     \\n\\\n \n pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n     region_vars: &RegionVarBindings<'a, 'gcx, 'tcx>,\n-    subject_node: ast::NodeId)\n+    region_rels: &RegionRelations<'a, 'gcx, 'tcx>)\n {\n-    let tcx = region_vars.tcx;\n+    let context = region_rels.context;\n \n     if !region_vars.tcx.sess.opts.debugging_opts.print_region_graph {\n         return;\n     }\n \n     let requested_node = env::var(\"RUST_REGION_GRAPH_NODE\")\n-        .ok().and_then(|s| s.parse().map(ast::NodeId::new).ok());\n+        .ok().and_then(|s| s.parse().map(DefIndex::new).ok());\n \n-    if requested_node.is_some() && requested_node != Some(subject_node) {\n+    if requested_node.is_some() && requested_node != Some(context.index) {\n         return;\n     }\n \n@@ -98,7 +99,7 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n             let mut new_str = String::new();\n             for c in output_template.chars() {\n                 if c == '%' {\n-                    new_str.push_str(&subject_node.to_string());\n+                    new_str.push_str(&context.index.as_usize().to_string());\n                 } else {\n                     new_str.push(c);\n                 }\n@@ -110,7 +111,7 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n     };\n \n     let constraints = &*region_vars.constraints.borrow();\n-    match dump_region_constraints_to(tcx, constraints, &output_path) {\n+    match dump_region_constraints_to(region_rels, constraints, &output_path) {\n         Ok(()) => {}\n         Err(e) => {\n             let msg = format!(\"io error dumping region constraints: {}\", e);\n@@ -120,28 +121,28 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n }\n \n struct ConstraintGraph<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     graph_name: String,\n+    region_rels: &'a RegionRelations<'a, 'gcx, 'tcx>,\n     map: &'a FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n-    node_ids: FxHashMap<Node, usize>,\n+    node_ids: FxHashMap<Node<'tcx>, usize>,\n }\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug, Copy)]\n-enum Node {\n+enum Node<'tcx> {\n     RegionVid(ty::RegionVid),\n-    Region(ty::Region),\n+    Region(ty::RegionKind<'tcx>),\n }\n \n // type Edge = Constraint;\n #[derive(Clone, PartialEq, Eq, Debug, Copy)]\n enum Edge<'tcx> {\n     Constraint(Constraint<'tcx>),\n-    EnclScope(CodeExtent, CodeExtent),\n+    EnclScope(CodeExtent<'tcx>, CodeExtent<'tcx>),\n }\n \n impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-           name: String,\n+    fn new(name: String,\n+           region_rels: &'a RegionRelations<'a, 'gcx, 'tcx>,\n            map: &'a ConstraintMap<'tcx>)\n            -> ConstraintGraph<'a, 'gcx, 'tcx> {\n         let mut i = 0;\n@@ -159,23 +160,23 @@ impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n                 add_node(n2);\n             }\n \n-            tcx.region_maps.each_encl_scope(|sub, sup| {\n-                add_node(Node::Region(ty::ReScope(*sub)));\n-                add_node(Node::Region(ty::ReScope(*sup)));\n+            region_rels.region_maps.each_encl_scope(|sub, sup| {\n+                add_node(Node::Region(ty::ReScope(sub)));\n+                add_node(Node::Region(ty::ReScope(sup)));\n             });\n         }\n \n         ConstraintGraph {\n-            tcx: tcx,\n+            map,\n+            node_ids,\n+            region_rels,\n             graph_name: name,\n-            map: map,\n-            node_ids: node_ids,\n         }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n-    type Node = Node;\n+    type Node = Node<'tcx>;\n     type Edge = Edge<'tcx>;\n     fn graph_id(&self) -> dot::Id {\n         dot::Id::new(&*self.graph_name).unwrap()\n@@ -208,7 +209,7 @@ impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n+fn constraint_to_nodes<'tcx>(c: &Constraint<'tcx>) -> (Node<'tcx>, Node<'tcx>) {\n     match *c {\n         Constraint::ConstrainVarSubVar(rv_1, rv_2) =>\n             (Node::RegionVid(rv_1), Node::RegionVid(rv_2)),\n@@ -221,7 +222,7 @@ fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n     }\n }\n \n-fn edge_to_nodes(e: &Edge) -> (Node, Node) {\n+fn edge_to_nodes<'tcx>(e: &Edge<'tcx>) -> (Node<'tcx>, Node<'tcx>) {\n     match *e {\n         Edge::Constraint(ref c) => constraint_to_nodes(c),\n         Edge::EnclScope(sub, sup) => {\n@@ -232,9 +233,9 @@ fn edge_to_nodes(e: &Edge) -> (Node, Node) {\n }\n \n impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n-    type Node = Node;\n+    type Node = Node<'tcx>;\n     type Edge = Edge<'tcx>;\n-    fn nodes(&self) -> dot::Nodes<Node> {\n+    fn nodes(&self) -> dot::Nodes<Node<'tcx>> {\n         let mut set = FxHashSet();\n         for node in self.node_ids.keys() {\n             set.insert(*node);\n@@ -245,16 +246,16 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     fn edges(&self) -> dot::Edges<Edge<'tcx>> {\n         debug!(\"constraint graph has {} edges\", self.map.len());\n         let mut v: Vec<_> = self.map.keys().map(|e| Edge::Constraint(*e)).collect();\n-        self.tcx.region_maps.each_encl_scope(|sub, sup| v.push(Edge::EnclScope(*sub, *sup)));\n+        self.region_rels.region_maps.each_encl_scope(|sub, sup| v.push(Edge::EnclScope(sub, sup)));\n         debug!(\"region graph has {} edges\", v.len());\n         Cow::Owned(v)\n     }\n-    fn source(&self, edge: &Edge<'tcx>) -> Node {\n+    fn source(&self, edge: &Edge<'tcx>) -> Node<'tcx> {\n         let (n1, _) = edge_to_nodes(edge);\n         debug!(\"edge {:?} has source {:?}\", edge, n1);\n         n1\n     }\n-    fn target(&self, edge: &Edge<'tcx>) -> Node {\n+    fn target(&self, edge: &Edge<'tcx>) -> Node<'tcx> {\n         let (_, n2) = edge_to_nodes(edge);\n         debug!(\"edge {:?} has target {:?}\", edge, n2);\n         n2\n@@ -263,14 +264,14 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n \n pub type ConstraintMap<'tcx> = FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n \n-fn dump_region_constraints_to<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn dump_region_constraints_to<'a, 'gcx, 'tcx>(region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n                                               map: &ConstraintMap<'tcx>,\n                                               path: &str)\n                                               -> io::Result<()> {\n     debug!(\"dump_region_constraints map (len: {}) path: {}\",\n            map.len(),\n            path);\n-    let g = ConstraintGraph::new(tcx, format!(\"region_constraints\"), map);\n+    let g = ConstraintGraph::new(format!(\"region_constraints\"), region_rels, map);\n     debug!(\"dump_region_constraints calling render\");\n     let mut v = Vec::new();\n     dot::render(&g, &mut v).unwrap();"}, {"sha": "39554d1fa3a3ae77cce418d08d76881bcc838c33", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 109, "deletions": 108, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -22,7 +22,7 @@ use super::unify_key;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use rustc_data_structures::unify::{self, UnificationTable};\n-use middle::free_region::FreeRegionMap;\n+use middle::free_region::RegionRelations;\n use ty::{self, Ty, TyCtxt};\n use ty::{Region, RegionVid};\n use ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound, ReErased};\n@@ -33,7 +33,6 @@ use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::fmt;\n use std::mem;\n use std::u32;\n-use syntax::ast;\n \n mod graphviz;\n \n@@ -44,17 +43,17 @@ pub enum Constraint<'tcx> {\n     ConstrainVarSubVar(RegionVid, RegionVid),\n \n     // Concrete region is subregion of region variable\n-    ConstrainRegSubVar(&'tcx Region, RegionVid),\n+    ConstrainRegSubVar(Region<'tcx>, RegionVid),\n \n     // Region variable is subregion of concrete region. This does not\n     // directly affect inference, but instead is checked after\n     // inference is complete.\n-    ConstrainVarSubReg(RegionVid, &'tcx Region),\n+    ConstrainVarSubReg(RegionVid, Region<'tcx>),\n \n     // A constraint where neither side is a variable. This does not\n     // directly affect inference, but instead is checked after\n     // inference is complete.\n-    ConstrainRegSubReg(&'tcx Region, &'tcx Region),\n+    ConstrainRegSubReg(Region<'tcx>, Region<'tcx>),\n }\n \n // VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n@@ -66,7 +65,7 @@ pub enum Constraint<'tcx> {\n pub struct Verify<'tcx> {\n     kind: GenericKind<'tcx>,\n     origin: SubregionOrigin<'tcx>,\n-    region: &'tcx Region,\n+    region: Region<'tcx>,\n     bound: VerifyBound<'tcx>,\n }\n \n@@ -86,14 +85,14 @@ pub enum VerifyBound<'tcx> {\n     // Put another way, the subject value is known to outlive all\n     // regions in {R}, so if any of those outlives 'min, then the\n     // bound is met.\n-    AnyRegion(Vec<&'tcx Region>),\n+    AnyRegion(Vec<Region<'tcx>>),\n \n     // B = forall {R} --> all 'r in {R} must outlive 'min\n     //\n     // Put another way, the subject value is known to outlive some\n     // region in {R}, so if all of those outlives 'min, then the bound\n     // is met.\n-    AllRegions(Vec<&'tcx Region>),\n+    AllRegions(Vec<Region<'tcx>>),\n \n     // B = exists {B} --> 'min must meet some bound b in {B}\n     AnyBound(Vec<VerifyBound<'tcx>>),\n@@ -104,8 +103,8 @@ pub enum VerifyBound<'tcx> {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct TwoRegions<'tcx> {\n-    a: &'tcx Region,\n-    b: &'tcx Region,\n+    a: Region<'tcx>,\n+    b: Region<'tcx>,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -128,7 +127,7 @@ pub enum UndoLogEntry<'tcx> {\n     AddVerify(usize),\n \n     /// We added the given `given`\n-    AddGiven(ty::FreeRegion, ty::RegionVid),\n+    AddGiven(ty::FreeRegion<'tcx>, ty::RegionVid),\n \n     /// We added a GLB/LUB \"combinaton variable\"\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n@@ -153,13 +152,13 @@ pub enum RegionResolutionError<'tcx> {\n     /// `ConcreteFailure(o, a, b)`:\n     ///\n     /// `o` requires that `a <= b`, but this does not hold\n-    ConcreteFailure(SubregionOrigin<'tcx>, &'tcx Region, &'tcx Region),\n+    ConcreteFailure(SubregionOrigin<'tcx>, Region<'tcx>, Region<'tcx>),\n \n     /// `GenericBoundFailure(p, s, a)\n     ///\n     /// The parameter/associated-type `p` must be known to outlive the lifetime\n     /// `a` (but none of the known bounds are sufficient).\n-    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, &'tcx Region),\n+    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region<'tcx>),\n \n     /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n     ///\n@@ -168,14 +167,14 @@ pub enum RegionResolutionError<'tcx> {\n     /// `sub_r <= sup_r` does not hold.\n     SubSupConflict(RegionVariableOrigin,\n                    SubregionOrigin<'tcx>,\n-                   &'tcx Region,\n+                   Region<'tcx>,\n                    SubregionOrigin<'tcx>,\n-                   &'tcx Region),\n+                   Region<'tcx>),\n }\n \n #[derive(Clone, Debug)]\n pub enum ProcessedErrorOrigin<'tcx> {\n-    ConcreteFailure(SubregionOrigin<'tcx>, &'tcx Region, &'tcx Region),\n+    ConcreteFailure(SubregionOrigin<'tcx>, Region<'tcx>, Region<'tcx>),\n     VariableFailure(RegionVariableOrigin),\n }\n \n@@ -214,7 +213,7 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // record the fact that `'a <= 'b` is implied by the fn signature,\n     // and then ignore the constraint when solving equations. This is\n     // a bit of a hack but seems to work.\n-    givens: RefCell<FxHashSet<(ty::FreeRegion, ty::RegionVid)>>,\n+    givens: RefCell<FxHashSet<(ty::FreeRegion<'tcx>, ty::RegionVid)>>,\n \n     lubs: RefCell<CombineMap<'tcx>>,\n     glbs: RefCell<CombineMap<'tcx>>,\n@@ -271,12 +270,12 @@ impl TaintDirections {\n \n struct TaintSet<'tcx> {\n     directions: TaintDirections,\n-    regions: FxHashSet<&'tcx ty::Region>\n+    regions: FxHashSet<ty::Region<'tcx>>\n }\n \n impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n     fn new(directions: TaintDirections,\n-           initial_region: &'tcx ty::Region)\n+           initial_region: ty::Region<'tcx>)\n            -> Self {\n         let mut regions = FxHashSet();\n         regions.insert(initial_region);\n@@ -328,7 +327,7 @@ impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n         }\n     }\n \n-    fn into_set(self) -> FxHashSet<&'tcx ty::Region> {\n+    fn into_set(self) -> FxHashSet<ty::Region<'tcx>> {\n         self.regions\n     }\n \n@@ -337,8 +336,8 @@ impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n     }\n \n     fn add_edge(&mut self,\n-                source: &'tcx ty::Region,\n-                target: &'tcx ty::Region) {\n+                source: ty::Region<'tcx>,\n+                target: ty::Region<'tcx>) {\n         if self.directions.incoming {\n             if self.regions.contains(&target) {\n                 self.regions.insert(source);\n@@ -499,7 +498,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// it's just there to make it explicit which snapshot bounds the\n     /// skolemized region that results. It should always be the top-most snapshot.\n     pub fn push_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot)\n-                           -> &'tcx Region {\n+                           -> Region<'tcx> {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n \n@@ -513,7 +512,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// completes to remove all trace of the skolemized regions\n     /// created in that time.\n     pub fn pop_skolemized(&self,\n-                          skols: &FxHashSet<&'tcx ty::Region>,\n+                          skols: &FxHashSet<ty::Region<'tcx>>,\n                           snapshot: &RegionSnapshot) {\n         debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n \n@@ -567,7 +566,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         self.skolemization_count.set(snapshot.skolemization_count);\n         return;\n \n-        fn kill_constraint<'tcx>(skols: &FxHashSet<&'tcx ty::Region>,\n+        fn kill_constraint<'tcx>(skols: &FxHashSet<ty::Region<'tcx>>,\n                                  undo_entry: &UndoLogEntry<'tcx>)\n                                  -> bool {\n             match undo_entry {\n@@ -596,7 +595,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     }\n \n-    pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> &'tcx Region {\n+    pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> Region<'tcx> {\n         // Creates a fresh bound variable for use in GLB computations.\n         // See discussion of GLB computation in the large comment at\n         // the top of this file for more details.\n@@ -662,7 +661,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn add_given(&self, sub: ty::FreeRegion, sup: ty::RegionVid) {\n+    pub fn add_given(&self, sub: ty::FreeRegion<'tcx>, sup: ty::RegionVid) {\n         // cannot add givens once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -676,8 +675,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     pub fn make_eqregion(&self,\n                          origin: SubregionOrigin<'tcx>,\n-                         sub: &'tcx Region,\n-                         sup: &'tcx Region) {\n+                         sub: Region<'tcx>,\n+                         sup: Region<'tcx>) {\n         if sub != sup {\n             // Eventually, it would be nice to add direct support for\n             // equating regions.\n@@ -692,8 +691,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     pub fn make_subregion(&self,\n                           origin: SubregionOrigin<'tcx>,\n-                          sub: &'tcx Region,\n-                          sup: &'tcx Region) {\n+                          sub: Region<'tcx>,\n+                          sup: Region<'tcx>) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -734,7 +733,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     pub fn verify_generic_bound(&self,\n                                 origin: SubregionOrigin<'tcx>,\n                                 kind: GenericKind<'tcx>,\n-                                sub: &'tcx Region,\n+                                sub: Region<'tcx>,\n                                 bound: VerifyBound<'tcx>) {\n         self.add_verify(Verify {\n             kind: kind,\n@@ -746,9 +745,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     pub fn lub_regions(&self,\n                        origin: SubregionOrigin<'tcx>,\n-                       a: &'tcx Region,\n-                       b: &'tcx Region)\n-                       -> &'tcx Region {\n+                       a: Region<'tcx>,\n+                       b: Region<'tcx>)\n+                       -> Region<'tcx> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -772,9 +771,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     pub fn glb_regions(&self,\n                        origin: SubregionOrigin<'tcx>,\n-                       a: &'tcx Region,\n-                       b: &'tcx Region)\n-                       -> &'tcx Region {\n+                       a: Region<'tcx>,\n+                       b: Region<'tcx>)\n+                       -> Region<'tcx> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -796,7 +795,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_var(&self, rid: RegionVid) -> &'tcx ty::Region {\n+    pub fn resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n         match *self.values.borrow() {\n             None => {\n                 span_bug!((*self.var_origins.borrow())[rid.index as usize].span(),\n@@ -811,7 +810,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn opportunistic_resolve_var(&self, rid: RegionVid) -> &'tcx ty::Region {\n+    pub fn opportunistic_resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n         let vid = self.unification_table.borrow_mut().find_value(rid).min_vid;\n         self.tcx.mk_region(ty::ReVar(vid))\n     }\n@@ -825,12 +824,12 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     pub fn combine_vars<F>(&self,\n                            t: CombineMapType,\n-                           a: &'tcx Region,\n-                           b: &'tcx Region,\n+                           a: Region<'tcx>,\n+                           b: Region<'tcx>,\n                            origin: SubregionOrigin<'tcx>,\n                            mut relate: F)\n-                           -> &'tcx Region\n-        where F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, &'tcx Region, &'tcx Region)\n+                           -> Region<'tcx>\n+        where F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, Region<'tcx>, Region<'tcx>)\n     {\n         let vars = TwoRegions { a: a, b: b };\n         if let Some(&c) = self.combine_map(t).borrow().get(&vars) {\n@@ -869,9 +868,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// related to other regions.\n     pub fn tainted(&self,\n                    mark: &RegionSnapshot,\n-                   r0: &'tcx Region,\n+                   r0: Region<'tcx>,\n                    directions: TaintDirections)\n-                   -> FxHashSet<&'tcx ty::Region> {\n+                   -> FxHashSet<ty::Region<'tcx>> {\n         debug!(\"tainted(mark={:?}, r0={:?}, directions={:?})\",\n                mark, r0, directions);\n \n@@ -892,21 +891,20 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// constraints, assuming such values can be found; if they cannot,\n     /// errors are reported.\n     pub fn resolve_regions(&self,\n-                           free_regions: &FreeRegionMap,\n-                           subject_node: ast::NodeId)\n+                           region_rels: &RegionRelations<'a, 'gcx, 'tcx>)\n                            -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = vec![];\n-        let v = self.infer_variable_values(free_regions, &mut errors, subject_node);\n+        let v = self.infer_variable_values(region_rels, &mut errors);\n         *self.values.borrow_mut() = Some(v);\n         errors\n     }\n \n     fn lub_concrete_regions(&self,\n-                            free_regions: &FreeRegionMap,\n-                            a: &'tcx Region,\n-                            b: &'tcx Region)\n-                            -> &'tcx Region {\n+                            region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+                            a: Region<'tcx>,\n+                            b: Region<'tcx>)\n+                            -> Region<'tcx> {\n         match (a, b) {\n             (&ReLateBound(..), _) |\n             (_, &ReLateBound(..)) |\n@@ -938,30 +936,31 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 // A \"free\" region can be interpreted as \"some region\n                 // at least as big as the block fr.scope_id\".  So, we can\n                 // reasonably compare free regions and scopes:\n-                let r_id = self.tcx.region_maps.nearest_common_ancestor(fr.scope, s_id);\n-\n-                if r_id == fr.scope {\n-                    // if the free region's scope `fr.scope_id` is bigger than\n-                    // the scope region `s_id`, then the LUB is the free\n-                    // region itself:\n-                    self.tcx.mk_region(ReFree(fr))\n-                } else {\n-                    // otherwise, we don't know what the free region is,\n-                    // so we must conservatively say the LUB is static:\n-                    self.tcx.types.re_static\n+                if let Some(fr_scope) = fr.scope {\n+                    let r_id = region_rels.region_maps.nearest_common_ancestor(fr_scope, s_id);\n+                    if r_id == fr_scope {\n+                        // if the free region's scope `fr.scope_id` is bigger than\n+                        // the scope region `s_id`, then the LUB is the free\n+                        // region itself:\n+                        return self.tcx.mk_region(ReFree(fr));\n+                    }\n                 }\n+\n+                // otherwise, we don't know what the free region is,\n+                // so we must conservatively say the LUB is static:\n+                self.tcx.types.re_static\n             }\n \n             (&ReScope(a_id), &ReScope(b_id)) => {\n                 // The region corresponding to an outer block is a\n                 // subtype of the region corresponding to an inner\n                 // block.\n-                self.tcx.mk_region(ReScope(\n-                    self.tcx.region_maps.nearest_common_ancestor(a_id, b_id)))\n+                let lub = region_rels.region_maps.nearest_common_ancestor(a_id, b_id);\n+                self.tcx.mk_region(ReScope(lub))\n             }\n \n-            (&ReFree(a_fr), &ReFree(b_fr)) => {\n-                self.tcx.mk_region(free_regions.lub_free_regions(a_fr, b_fr))\n+            (&ReFree(_), &ReFree(_)) => {\n+                region_rels.lub_free_regions(a, b)\n             }\n \n             // For these types, we cannot define any additional\n@@ -982,37 +981,36 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n #[derive(Copy, Clone, Debug)]\n pub enum VarValue<'tcx> {\n-    Value(&'tcx Region),\n+    Value(Region<'tcx>),\n     ErrorValue,\n }\n \n struct RegionAndOrigin<'tcx> {\n-    region: &'tcx Region,\n+    region: Region<'tcx>,\n     origin: SubregionOrigin<'tcx>,\n }\n \n type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     fn infer_variable_values(&self,\n-                             free_regions: &FreeRegionMap,\n-                             errors: &mut Vec<RegionResolutionError<'tcx>>,\n-                             subject: ast::NodeId)\n+                             region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+                             errors: &mut Vec<RegionResolutionError<'tcx>>)\n                              -> Vec<VarValue<'tcx>> {\n         let mut var_data = self.construct_var_data();\n \n         // Dorky hack to cause `dump_constraints` to only get called\n         // if debug mode is enabled:\n-        debug!(\"----() End constraint listing (subject={}) {:?}---\",\n-               subject,\n-               self.dump_constraints(subject));\n-        graphviz::maybe_print_constraints_for(self, subject);\n+        debug!(\"----() End constraint listing (context={:?}) {:?}---\",\n+               region_rels.context,\n+               self.dump_constraints(region_rels));\n+        graphviz::maybe_print_constraints_for(self, region_rels);\n \n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n-        self.expansion(free_regions, &mut var_data);\n-        self.collect_errors(free_regions, &mut var_data, errors);\n-        self.collect_var_errors(free_regions, &var_data, &graph, errors);\n+        self.expansion(region_rels, &mut var_data);\n+        self.collect_errors(region_rels, &mut var_data, errors);\n+        self.collect_var_errors(region_rels, &var_data, &graph, errors);\n         var_data\n     }\n \n@@ -1022,9 +1020,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             .collect()\n     }\n \n-    fn dump_constraints(&self, subject: ast::NodeId) {\n-        debug!(\"----() Start constraint listing (subject={}) ()----\",\n-               subject);\n+    fn dump_constraints(&self, free_regions: &RegionRelations<'a, 'gcx, 'tcx>) {\n+        debug!(\"----() Start constraint listing (context={:?}) ()----\",\n+               free_regions.context);\n         for (idx, (constraint, _)) in self.constraints.borrow().iter().enumerate() {\n             debug!(\"Constraint {} => {:?}\", idx, constraint);\n         }\n@@ -1055,21 +1053,23 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn expansion(&self, free_regions: &FreeRegionMap, var_values: &mut [VarValue<'tcx>]) {\n+    fn expansion(&self,\n+                 region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+                 var_values: &mut [VarValue<'tcx>]) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n             debug!(\"expansion: constraint={:?} origin={:?}\",\n                    constraint, origin);\n             match *constraint {\n                 ConstrainRegSubVar(a_region, b_vid) => {\n                     let b_data = &mut var_values[b_vid.index as usize];\n-                    self.expand_node(free_regions, a_region, b_vid, b_data)\n+                    self.expand_node(region_rels, a_region, b_vid, b_data)\n                 }\n                 ConstrainVarSubVar(a_vid, b_vid) => {\n                     match var_values[a_vid.index as usize] {\n                         ErrorValue => false,\n                         Value(a_region) => {\n                             let b_node = &mut var_values[b_vid.index as usize];\n-                            self.expand_node(free_regions, a_region, b_vid, b_node)\n+                            self.expand_node(region_rels, a_region, b_vid, b_node)\n                         }\n                     }\n                 }\n@@ -1084,8 +1084,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     }\n \n     fn expand_node(&self,\n-                   free_regions: &FreeRegionMap,\n-                   a_region: &'tcx Region,\n+                   region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+                   a_region: Region<'tcx>,\n                    b_vid: RegionVid,\n                    b_data: &mut VarValue<'tcx>)\n                    -> bool {\n@@ -1107,7 +1107,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         match *b_data {\n             Value(cur_region) => {\n-                let lub = self.lub_concrete_regions(free_regions, a_region, cur_region);\n+                let lub = self.lub_concrete_regions(region_rels, a_region, cur_region);\n                 if lub == cur_region {\n                     return false;\n                 }\n@@ -1131,7 +1131,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// cases where the region cannot grow larger than a fixed point)\n     /// and check that they are satisfied.\n     fn collect_errors(&self,\n-                      free_regions: &FreeRegionMap,\n+                      region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n                       var_data: &mut Vec<VarValue<'tcx>>,\n                       errors: &mut Vec<RegionResolutionError<'tcx>>) {\n         let constraints = self.constraints.borrow();\n@@ -1145,7 +1145,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 }\n \n                 ConstrainRegSubReg(sub, sup) => {\n-                    if free_regions.is_subregion_of(self.tcx, sub, sup) {\n+                    if region_rels.is_subregion_of(sub, sup) {\n                         continue;\n                     }\n \n@@ -1173,7 +1173,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                     // Do not report these errors immediately:\n                     // instead, set the variable value to error and\n                     // collect them later.\n-                    if !free_regions.is_subregion_of(self.tcx, a_region, b_region) {\n+                    if !region_rels.is_subregion_of(a_region, b_region) {\n                         debug!(\"collect_errors: region error at {:?}: \\\n                                 cannot verify that {:?}={:?} <= {:?}\",\n                                origin,\n@@ -1189,7 +1189,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         for verify in self.verifys.borrow().iter() {\n             debug!(\"collect_errors: verify={:?}\", verify);\n             let sub = normalize(self.tcx, var_data, verify.region);\n-            if verify.bound.is_met(self.tcx, free_regions, var_data, sub) {\n+            if verify.bound.is_met(region_rels, var_data, sub) {\n                 continue;\n             }\n \n@@ -1208,7 +1208,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// Go over the variables that were declared to be error variables\n     /// and create a `RegionResolutionError` for each of them.\n     fn collect_var_errors(&self,\n-                          free_regions: &FreeRegionMap,\n+                          region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n                           var_data: &[VarValue<'tcx>],\n                           graph: &RegionGraph<'tcx>,\n                           errors: &mut Vec<RegionResolutionError<'tcx>>) {\n@@ -1257,7 +1257,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                        this portion of the code and think hard about it. =) */\n \n                     let node_vid = RegionVid { index: idx as u32 };\n-                    self.collect_error_for_expanding_node(free_regions,\n+                    self.collect_error_for_expanding_node(region_rels,\n                                                           graph,\n                                                           &mut dup_vec,\n                                                           node_vid,\n@@ -1310,7 +1310,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     }\n \n     fn collect_error_for_expanding_node(&self,\n-                                        free_regions: &FreeRegionMap,\n+                                        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n                                         graph: &RegionGraph<'tcx>,\n                                         dup_vec: &mut [u32],\n                                         node_idx: RegionVid,\n@@ -1346,7 +1346,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         for lower_bound in &lower_bounds {\n             for upper_bound in &upper_bounds {\n-                if !free_regions.is_subregion_of(self.tcx, lower_bound.region, upper_bound.region) {\n+                if !region_rels.is_subregion_of(lower_bound.region, upper_bound.region) {\n                     let origin = (*self.var_origins.borrow())[node_idx.index as usize].clone();\n                     debug!(\"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n                             sup: {:?}\",\n@@ -1479,8 +1479,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n fn normalize<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                              values: &Vec<VarValue<'tcx>>,\n-                             r: &'tcx ty::Region)\n-                             -> &'tcx ty::Region {\n+                             r: ty::Region<'tcx>)\n+                             -> ty::Region<'tcx> {\n     match *r {\n         ty::ReVar(rid) => lookup(tcx, values, rid),\n         _ => r,\n@@ -1490,7 +1490,7 @@ fn normalize<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n fn lookup<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                           values: &Vec<VarValue<'tcx>>,\n                           rid: ty::RegionVid)\n-                          -> &'tcx ty::Region {\n+                          -> ty::Region<'tcx> {\n     match values[rid.index as usize] {\n         Value(r) => r,\n         ErrorValue => tcx.types.re_static, // Previously reported error.\n@@ -1538,7 +1538,7 @@ impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n-    fn for_each_region(&self, f: &mut FnMut(&'tcx ty::Region)) {\n+    fn for_each_region(&self, f: &mut FnMut(ty::Region<'tcx>)) {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) |\n             &VerifyBound::AllRegions(ref rs) => for &r in rs {\n@@ -1590,29 +1590,30 @@ impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n         }\n     }\n \n-    fn is_met(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-              free_regions: &FreeRegionMap,\n+    fn is_met(&self,\n+              region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n               var_values: &Vec<VarValue<'tcx>>,\n-              min: &'tcx ty::Region)\n+              min: ty::Region<'tcx>)\n               -> bool {\n+        let tcx = region_rels.tcx;\n         match self {\n             &VerifyBound::AnyRegion(ref rs) =>\n                 rs.iter()\n                   .map(|&r| normalize(tcx, var_values, r))\n-                  .any(|r| free_regions.is_subregion_of(tcx, min, r)),\n+                  .any(|r| region_rels.is_subregion_of(min, r)),\n \n             &VerifyBound::AllRegions(ref rs) =>\n                 rs.iter()\n                   .map(|&r| normalize(tcx, var_values, r))\n-                  .all(|r| free_regions.is_subregion_of(tcx, min, r)),\n+                  .all(|r| region_rels.is_subregion_of(min, r)),\n \n             &VerifyBound::AnyBound(ref bs) =>\n                 bs.iter()\n-                  .any(|b| b.is_met(tcx, free_regions, var_values, min)),\n+                  .any(|b| b.is_met(region_rels, var_values, min)),\n \n             &VerifyBound::AllBounds(ref bs) =>\n                 bs.iter()\n-                  .all(|b| b.is_met(tcx, free_regions, var_values, min)),\n+                  .all(|b| b.is_met(region_rels, var_values, min)),\n         }\n     }\n }"}, {"sha": "2e8b843d07b30e99e4dce0c3d754279b921118f3", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n         }\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReVar(rid) => self.infcx.region_vars.opportunistic_resolve_var(rid),\n             _ => r,\n@@ -138,7 +138,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n         }\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReVar(rid) => self.infcx.region_vars.resolve_var(rid),\n             _ => r,"}, {"sha": "487195fdfae9f833bff88a645ab6691bbab8c6de", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -127,8 +127,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         }\n     }\n \n-    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n-               -> RelateResult<'tcx, &'tcx ty::Region> {\n+    fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"{}.regions({:?}, {:?}) self.cause={:?}\",\n                self.tag(), a, b, self.fields.cause);\n "}, {"sha": "41f9311dd809bf5bf09c5b9590763776c5a2cd09", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -23,6 +23,7 @@ use hir::def::Def;\n use hir::def_id::{DefId};\n use infer::InferCtxt;\n use middle::mem_categorization as mc;\n+use middle::region::RegionMaps;\n use ty::{self, TyCtxt, adjustment};\n \n use hir::{self, PatKind};\n@@ -75,7 +76,7 @@ pub trait Delegate<'tcx> {\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              loan_region: &'tcx ty::Region,\n+              loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: LoanCause);\n \n@@ -270,19 +271,24 @@ enum PassArgs {\n \n impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n+               region_maps: &'a RegionMaps<'tcx>,\n                infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n                -> Self\n     {\n-        ExprUseVisitor::with_options(delegate, infcx, mc::MemCategorizationOptions::default())\n+        ExprUseVisitor::with_options(delegate,\n+                                     infcx,\n+                                     region_maps,\n+                                     mc::MemCategorizationOptions::default())\n     }\n \n     pub fn with_options(delegate: &'a mut (Delegate<'tcx>+'a),\n                         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                        region_maps: &'a RegionMaps<'tcx>,\n                         options: mc::MemCategorizationOptions)\n                -> Self\n     {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::with_options(infcx, options),\n+            mc: mc::MemCategorizationContext::with_options(infcx, region_maps, options),\n             delegate: delegate\n         }\n     }\n@@ -347,7 +353,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n     fn borrow_expr(&mut self,\n                    expr: &hir::Expr,\n-                   r: &'tcx ty::Region,\n+                   r: ty::Region<'tcx>,\n                    bk: ty::BorrowKind,\n                    cause: LoanCause) {\n         debug!(\"borrow_expr(expr={:?}, r={:?}, bk={:?})\","}, {"sha": "2dc7aac04aede4bc53413f5fefd0d65cb9b6ec13", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 141, "deletions": 99, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -15,34 +15,136 @@\n //! `TransitiveRelation` type and use that to decide when one free\n //! region outlives another and so forth.\n \n-use ty::{self, TyCtxt, FreeRegion, Region};\n+use hir::def_id::DefId;\n+use middle::region::RegionMaps;\n+use ty::{self, Lift, TyCtxt, Region};\n use ty::wf::ImpliedBound;\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n+/// Combines a `RegionMaps` (which governs relationships between\n+/// scopes) and a `FreeRegionMap` (which governs relationships between\n+/// free regions) to yield a complete relation between concrete\n+/// regions.\n+///\n+/// This stuff is a bit convoluted and should be refactored, but as we\n+/// move to NLL it'll all go away anyhow.\n+pub struct RegionRelations<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+\n+    /// context used to fetch the region maps\n+    pub context: DefId,\n+\n+    /// region maps for the given context\n+    pub region_maps: &'a RegionMaps<'tcx>,\n+\n+    /// free-region relationships\n+    pub free_regions: &'a FreeRegionMap<'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        context: DefId,\n+        region_maps: &'a RegionMaps<'tcx>,\n+        free_regions: &'a FreeRegionMap<'tcx>,\n+    ) -> Self {\n+        Self {\n+            tcx,\n+            context,\n+            region_maps,\n+            free_regions,\n+        }\n+    }\n+\n+    /// Determines whether one region is a subregion of another.  This is intended to run *after\n+    /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n+    pub fn is_subregion_of(&self,\n+                           sub_region: ty::Region<'tcx>,\n+                           super_region: ty::Region<'tcx>)\n+                           -> bool {\n+        let result = sub_region == super_region || {\n+            match (sub_region, super_region) {\n+                (&ty::ReEmpty, _) |\n+                (_, &ty::ReStatic) =>\n+                    true,\n+\n+                (&ty::ReScope(sub_scope), &ty::ReScope(super_scope)) =>\n+                    self.region_maps.is_subscope_of(sub_scope, super_scope),\n+\n+                (&ty::ReScope(sub_scope), &ty::ReFree(fr)) => {\n+                    // 1. It is safe to unwrap `fr.scope` because we\n+                    // should only ever wind up comparing against\n+                    // `ReScope` in the context of a method or\n+                    // body, where `fr.scope` should be `Some`.\n+                    self.region_maps.is_subscope_of(sub_scope, fr.scope.unwrap() /*1*/) ||\n+                        self.is_static(super_region)\n+                }\n+\n+                (&ty::ReFree(_), &ty::ReFree(_)) =>\n+                    self.free_regions.relation.contains(&sub_region, &super_region) ||\n+                        self.is_static(super_region),\n+\n+                (&ty::ReStatic, &ty::ReFree(_)) =>\n+                    self.is_static(super_region),\n+\n+                _ =>\n+                    false,\n+            }\n+        };\n+        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?}) = {:?}\",\n+               sub_region, super_region, result);\n+        result\n+    }\n+\n+    /// Determines whether this free-region is required to be 'static\n+    fn is_static(&self, super_region: ty::Region<'tcx>) -> bool {\n+        debug!(\"is_static(super_region={:?})\", super_region);\n+        match *super_region {\n+            ty::ReStatic => true,\n+            ty::ReFree(_) => {\n+                let re_static = self.tcx.mk_region(ty::ReStatic);\n+                self.free_regions.relation.contains(&re_static, &super_region)\n+            }\n+            _ => bug!(\"only free regions should be given to `is_static`\")\n+        }\n+    }\n+\n+    pub fn lub_free_regions(&self,\n+                            r_a: Region<'tcx>,\n+                            r_b: Region<'tcx>)\n+                            -> Region<'tcx> {\n+        self.free_regions.lub_free_regions(self.tcx, r_a, r_b)\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub struct FreeRegionMap {\n+pub struct FreeRegionMap<'tcx> {\n     // Stores the relation `a < b`, where `a` and `b` are regions.\n-    relation: TransitiveRelation<Region>\n+    //\n+    // Invariant: only free regions like `'x` or `'static` are stored\n+    // in this relation, not scopes.\n+    relation: TransitiveRelation<Region<'tcx>>\n }\n \n-impl FreeRegionMap {\n-    pub fn new() -> FreeRegionMap {\n+impl<'tcx> FreeRegionMap<'tcx> {\n+    pub fn new() -> Self {\n         FreeRegionMap { relation: TransitiveRelation::new() }\n     }\n \n     pub fn is_empty(&self) -> bool {\n         self.relation.is_empty()\n     }\n \n-    pub fn relate_free_regions_from_implied_bounds<'tcx>(&mut self,\n-                                                        implied_bounds: &[ImpliedBound<'tcx>])\n+    pub fn relate_free_regions_from_implied_bounds(&mut self,\n+                                                   implied_bounds: &[ImpliedBound<'tcx>])\n     {\n         debug!(\"relate_free_regions_from_implied_bounds()\");\n         for implied_bound in implied_bounds {\n             debug!(\"implied bound: {:?}\", implied_bound);\n             match *implied_bound {\n-                ImpliedBound::RegionSubRegion(&ty::ReFree(free_a), &ty::ReFree(free_b)) => {\n-                    self.relate_free_regions(free_a, free_b);\n+                ImpliedBound::RegionSubRegion(a @ &ty::ReFree(_), b @ &ty::ReFree(_)) |\n+                ImpliedBound::RegionSubRegion(a @ &ty::ReStatic, b @ &ty::ReFree(_)) => {\n+                    self.relate_regions(a, b);\n                 }\n                 ImpliedBound::RegionSubRegion(..) |\n                 ImpliedBound::RegionSubParam(..) |\n@@ -53,7 +155,7 @@ impl FreeRegionMap {\n     }\n \n     pub fn relate_free_regions_from_predicates(&mut self,\n-                                               predicates: &[ty::Predicate]) {\n+                                               predicates: &[ty::Predicate<'tcx>]) {\n         debug!(\"relate_free_regions_from_predicates(predicates={:?})\", predicates);\n         for predicate in predicates {\n             match *predicate {\n@@ -69,12 +171,15 @@ impl FreeRegionMap {\n                 }\n                 ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n                     match (r_a, r_b) {\n+                        // `'static: 'x` is not notable\n                         (&ty::ReStatic, &ty::ReFree(_)) => {},\n-                        (&ty::ReFree(fr_a), &ty::ReStatic) => self.relate_to_static(fr_a),\n-                        (&ty::ReFree(fr_a), &ty::ReFree(fr_b)) => {\n+\n+                        (&ty::ReFree(_), &ty::ReStatic) |\n+                        (&ty::ReFree(_), &ty::ReFree(_)) => {\n                             // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n-                            self.relate_free_regions(fr_b, fr_a);\n+                            self.relate_regions(r_b, r_a);\n                         }\n+\n                         _ => {\n                             // All named regions are instantiated with free regions.\n                             bug!(\"record_region_bounds: non free region: {:?} / {:?}\",\n@@ -87,101 +192,38 @@ impl FreeRegionMap {\n         }\n     }\n \n-    fn relate_to_static(&mut self, sup: FreeRegion) {\n-        self.relation.add(ty::ReStatic, ty::ReFree(sup));\n-    }\n-\n-    fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n-        self.relation.add(ty::ReFree(sub), ty::ReFree(sup))\n+    fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n+        assert!(match *sub { ty::ReFree(_) | ty::ReStatic => true, _ => false });\n+        assert!(match *sup { ty::ReFree(_) | ty::ReStatic => true, _ => false });\n+        self.relation.add(sub, sup)\n     }\n \n-    /// Determines whether two free regions have a subregion relationship\n-    /// by walking the graph encoded in `map`.  Note that\n-    /// it is possible that `sub != sup` and `sub <= sup` and `sup <= sub`\n-    /// (that is, the user can give two different names to the same lifetime).\n-    pub fn sub_free_region(&self, sub: FreeRegion, sup: FreeRegion) -> bool {\n-        let result = sub == sup || {\n-            let sub = ty::ReFree(sub);\n-            let sup = ty::ReFree(sup);\n-            self.relation.contains(&sub, &sup) || self.relation.contains(&ty::ReStatic, &sup)\n-        };\n-        debug!(\"sub_free_region(sub={:?}, sup={:?}) = {:?}\", sub, sup, result);\n-        result\n-    }\n-\n-    pub fn lub_free_regions(&self, fr_a: FreeRegion, fr_b: FreeRegion) -> Region {\n-        let r_a = ty::ReFree(fr_a);\n-        let r_b = ty::ReFree(fr_b);\n-        let result = if fr_a == fr_b { r_a } else {\n+    pub fn lub_free_regions<'a, 'gcx>(&self,\n+                                      tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                      r_a: Region<'tcx>,\n+                                      r_b: Region<'tcx>)\n+                                      -> Region<'tcx> {\n+        assert!(match *r_a { ty::ReFree(_) => true, _ => false });\n+        assert!(match *r_b { ty::ReFree(_) => true, _ => false });\n+        let result = if r_a == r_b { r_a } else {\n             match self.relation.postdom_upper_bound(&r_a, &r_b) {\n-                None => ty::ReStatic,\n+                None => tcx.mk_region(ty::ReStatic),\n                 Some(r) => *r,\n             }\n         };\n-        debug!(\"lub_free_regions(fr_a={:?}, fr_b={:?}) = {:?}\", fr_a, fr_b, result);\n-        result\n-    }\n-\n-    /// Determines whether one region is a subregion of another.  This is intended to run *after\n-    /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n-    pub fn is_subregion_of(&self,\n-                           tcx: TyCtxt,\n-                           sub_region: &ty::Region,\n-                           super_region: &ty::Region)\n-                           -> bool {\n-        let result = sub_region == super_region || {\n-            match (sub_region, super_region) {\n-                (&ty::ReEmpty, _) |\n-                (_, &ty::ReStatic) =>\n-                    true,\n-\n-                (&ty::ReScope(sub_scope), &ty::ReScope(super_scope)) =>\n-                    tcx.region_maps.is_subscope_of(sub_scope, super_scope),\n-\n-                (&ty::ReScope(sub_scope), &ty::ReFree(fr)) =>\n-                    tcx.region_maps.is_subscope_of(sub_scope, fr.scope) ||\n-                    self.is_static(fr),\n-\n-                (&ty::ReFree(sub_fr), &ty::ReFree(super_fr)) =>\n-                    self.sub_free_region(sub_fr, super_fr),\n-\n-                (&ty::ReStatic, &ty::ReFree(sup_fr)) =>\n-                    self.is_static(sup_fr),\n-\n-                _ =>\n-                    false,\n-            }\n-        };\n-        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?}) = {:?}\",\n-               sub_region, super_region, result);\n+        debug!(\"lub_free_regions(r_a={:?}, r_b={:?}) = {:?}\", r_a, r_b, result);\n         result\n     }\n-\n-    /// Determines whether this free-region is required to be 'static\n-    pub fn is_static(&self, super_region: ty::FreeRegion) -> bool {\n-        debug!(\"is_static(super_region={:?})\", super_region);\n-        self.relation.contains(&ty::ReStatic, &ty::ReFree(super_region))\n-    }\n-}\n-\n-#[cfg(test)]\n-fn free_region(index: u32) -> FreeRegion {\n-    use middle::region::DUMMY_CODE_EXTENT;\n-    FreeRegion { scope: DUMMY_CODE_EXTENT,\n-                 bound_region: ty::BoundRegion::BrAnon(index) }\n }\n \n-#[test]\n-fn lub() {\n-    // a very VERY basic test, but see the tests in\n-    // TransitiveRelation, which are much more thorough.\n-    let frs: Vec<_> = (0..3).map(|i| free_region(i)).collect();\n-    let mut map = FreeRegionMap::new();\n-    map.relate_free_regions(frs[0], frs[2]);\n-    map.relate_free_regions(frs[1], frs[2]);\n-    assert_eq!(map.lub_free_regions(frs[0], frs[1]), ty::ReFree(frs[2]));\n-}\n-\n-impl_stable_hash_for!(struct FreeRegionMap {\n+impl_stable_hash_for!(struct FreeRegionMap<'tcx> {\n     relation\n });\n+\n+impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n+    type Lifted = FreeRegionMap<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<FreeRegionMap<'tcx>> {\n+        self.relation.maybe_map(|&fr| fr.lift_to_tcx(tcx))\n+                     .map(|relation| FreeRegionMap { relation })\n+    }\n+}"}, {"sha": "1ea87cc0a4568347e15d1c11dc266c845f1a7c73", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -1441,7 +1441,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // and must outlive the *call-site* of the function.\n         let fn_ret =\n             self.ir.tcx.liberate_late_bound_regions(\n-                self.ir.tcx.region_maps.call_site_extent(id, body.value.id),\n+                Some(self.ir.tcx.call_site_extent(id, body.value.id)),\n                 &fn_ret);\n \n         if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {"}, {"sha": "11a364f92c316858538f83518a1aaef00d171bf2", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -70,6 +70,7 @@ pub use self::Note::*;\n \n use self::Aliasability::*;\n \n+use middle::region::RegionMaps;\n use hir::def_id::DefId;\n use hir::map as hir_map;\n use infer::InferCtxt;\n@@ -89,7 +90,7 @@ use std::rc::Rc;\n #[derive(Clone, PartialEq)]\n pub enum Categorization<'tcx> {\n     // temporary val, argument is its scope\n-    Rvalue(&'tcx ty::Region, &'tcx ty::Region),\n+    Rvalue(ty::Region<'tcx>, ty::Region<'tcx>),\n     StaticItem,\n     Upvar(Upvar),                          // upvar referenced by closure env\n     Local(ast::NodeId),                    // local variable\n@@ -114,13 +115,13 @@ pub enum PointerKind<'tcx> {\n     Unique,\n \n     /// `&T`\n-    BorrowedPtr(ty::BorrowKind, &'tcx ty::Region),\n+    BorrowedPtr(ty::BorrowKind, ty::Region<'tcx>),\n \n     /// `*T`\n     UnsafePtr(hir::Mutability),\n \n     /// Implicit deref of the `&T` that results from an overloaded index `[]`.\n-    Implicit(ty::BorrowKind, &'tcx ty::Region),\n+    Implicit(ty::BorrowKind, ty::Region<'tcx>),\n }\n \n // We use the term \"interior\" to mean \"something reachable from the\n@@ -286,9 +287,10 @@ impl ast_node for hir::Pat {\n     fn span(&self) -> Span { self.span }\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Clone)]\n pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    pub region_maps: &'a RegionMaps<'tcx>,\n     options: MemCategorizationOptions,\n }\n \n@@ -402,16 +404,22 @@ impl MutabilityCategory {\n }\n \n impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n+    /// Context should be the `DefId` we use to fetch region-maps.\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+               region_maps: &'a RegionMaps<'tcx>)\n                -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n-        MemCategorizationContext::with_options(infcx, MemCategorizationOptions::default())\n+        MemCategorizationContext::with_options(infcx,\n+                                               region_maps,\n+                                               MemCategorizationOptions::default())\n     }\n \n     pub fn with_options(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                        region_maps: &'a RegionMaps<'tcx>,\n                         options: MemCategorizationOptions)\n                         -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         MemCategorizationContext {\n             infcx: infcx,\n+            region_maps: region_maps,\n             options: options,\n         }\n     }\n@@ -786,7 +794,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             };\n \n             match fn_expr.node {\n-                hir::ExprClosure(.., body_id, _) => body_id.node_id,\n+                hir::ExprClosure(.., body_id, _) => body_id,\n                 _ => bug!()\n             }\n         };\n@@ -796,7 +804,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n-            scope: self.tcx().region_maps.item_extent(fn_body_id),\n+            scope: Some(self.tcx().item_extent(fn_body_id.node_id)),\n             bound_region: ty::BrEnv\n         }));\n \n@@ -842,10 +850,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n     /// Returns the lifetime of a temporary created by expr with id `id`.\n     /// This could be `'static` if `id` is part of a constant expression.\n-    pub fn temporary_scope(&self, id: ast::NodeId) -> (&'tcx ty::Region, &'tcx ty::Region)\n+    pub fn temporary_scope(&self, id: ast::NodeId) -> (ty::Region<'tcx>, ty::Region<'tcx>)\n     {\n         let (scope, old_scope) =\n-            self.tcx().region_maps.old_and_new_temporary_scope(id);\n+            self.region_maps.old_and_new_temporary_scope(self.tcx(), id);\n         (self.tcx().mk_region(match scope {\n             Some(scope) => ty::ReScope(scope),\n             None => ty::ReStatic\n@@ -887,8 +895,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn cat_rvalue(&self,\n                       cmt_id: ast::NodeId,\n                       span: Span,\n-                      temp_scope: &'tcx ty::Region,\n-                      old_temp_scope: &'tcx ty::Region,\n+                      temp_scope: ty::Region<'tcx>,\n+                      old_temp_scope: ty::Region<'tcx>,\n                       expr_ty: Ty<'tcx>) -> cmt<'tcx> {\n         let ret = Rc::new(cmt_ {\n             id:cmt_id,"}, {"sha": "d1d5e9d6cb18f78b52fea08b19b6a6dbc17afda8", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 238, "deletions": 299, "changes": 537, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -16,50 +16,27 @@\n //! Most of the documentation on regions can be found in\n //! `middle/infer/region_inference/README.md`\n \n-use dep_graph::DepNode;\n use hir::map as hir_map;\n-use session::Session;\n use util::nodemap::{FxHashMap, NodeMap, NodeSet};\n use ty;\n \n-use std::cell::RefCell;\n-use std::collections::hash_map::Entry;\n-use std::fmt;\n use std::mem;\n+use std::rc::Rc;\n+use serialize;\n use syntax::codemap;\n use syntax::ast::{self, NodeId};\n use syntax_pos::Span;\n+use ty::TyCtxt;\n+use ty::maps::Providers;\n \n-use hir;\n+use hir; use hir::def_id::DefId;\n use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n use hir::{Block, Item, FnDecl, Arm, Pat, PatKind, Stmt, Expr, Local};\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n-           RustcDecodable, Copy)]\n-pub struct CodeExtent(u32);\n-\n-impl fmt::Debug for CodeExtent {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"CodeExtent({:?}\", self.0)?;\n-\n-        ty::tls::with_opt(|opt_tcx| {\n-            if let Some(tcx) = opt_tcx {\n-                if let Some(data) = tcx.region_maps.code_extents.borrow().get(self.0 as usize) {\n-                    write!(f, \"/{:?}\", data)?;\n-                }\n-            }\n-            Ok(())\n-        })?;\n-\n-        write!(f, \")\")\n-    }\n-}\n+pub type CodeExtent<'tcx> = &'tcx CodeExtentData;\n \n-/// The root of everything. I should be using NonZero or profiling\n-/// instead of this (probably).\n-pub const ROOT_CODE_EXTENT : CodeExtent = CodeExtent(0);\n-/// A placeholder used in trans to stand for real code extents\n-pub const DUMMY_CODE_EXTENT : CodeExtent = CodeExtent(1);\n+impl<'tcx> serialize::UseSpecializedEncodable for CodeExtent<'tcx> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for CodeExtent<'tcx> {}\n \n /// CodeExtent represents a statically-describable extent that can be\n /// used to bound the lifetime/region for values.\n@@ -122,7 +99,7 @@ pub const DUMMY_CODE_EXTENT : CodeExtent = CodeExtent(1);\n /// placate the same deriving in `ty::FreeRegion`, but we may want to\n /// actually attach a more meaningful ordering to scopes than the one\n /// generated via deriving here.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n pub enum CodeExtentData {\n     Misc(ast::NodeId),\n \n@@ -149,8 +126,8 @@ pub struct CallSiteScopeData {\n }\n \n impl CallSiteScopeData {\n-    pub fn to_code_extent(&self, region_maps: &RegionMaps) -> CodeExtent {\n-        region_maps.lookup_code_extent(\n+    pub fn to_code_extent<'a, 'tcx, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> CodeExtent<'tcx> {\n+        tcx.intern_code_extent(\n             match *self {\n                 CallSiteScopeData { fn_id, body_id } =>\n                     CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id },\n@@ -199,28 +176,14 @@ impl CodeExtentData {\n             CodeExtentData::ParameterScope { fn_id: _, body_id } => body_id,\n         }\n     }\n-}\n-\n-impl CodeExtent {\n-    #[inline]\n-    fn into_option(self) -> Option<CodeExtent> {\n-        if self == ROOT_CODE_EXTENT {\n-            None\n-        } else {\n-            Some(self)\n-        }\n-    }\n-    pub fn node_id(&self, region_maps: &RegionMaps) -> ast::NodeId {\n-        region_maps.code_extent_data(*self).node_id()\n-    }\n \n     /// Returns the span of this CodeExtent.  Note that in general the\n     /// returned span may not correspond to the span of any node id in\n     /// the AST.\n-    pub fn span(&self, region_maps: &RegionMaps, hir_map: &hir_map::Map) -> Option<Span> {\n-        match hir_map.find(self.node_id(region_maps)) {\n+    pub fn span(&self, hir_map: &hir_map::Map) -> Option<Span> {\n+        match hir_map.find(self.node_id()) {\n             Some(hir_map::NodeBlock(ref blk)) => {\n-                match region_maps.code_extent_data(*self) {\n+                match *self {\n                     CodeExtentData::CallSiteScope { .. } |\n                     CodeExtentData::ParameterScope { .. } |\n                     CodeExtentData::Misc(_) |\n@@ -249,35 +212,36 @@ impl CodeExtent {\n }\n \n /// The region maps encode information about region relationships.\n-pub struct RegionMaps {\n-    code_extents: RefCell<Vec<CodeExtentData>>,\n-    code_extent_interner: RefCell<FxHashMap<CodeExtentData, CodeExtent>>,\n+pub struct RegionMaps<'tcx> {\n     /// `scope_map` maps from a scope id to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n     /// conditional expression or repeating block. (Note that the\n     /// enclosing scope id for the block associated with a closure is\n     /// the closure itself.)\n-    scope_map: RefCell<Vec<CodeExtent>>,\n+    scope_map: FxHashMap<CodeExtent<'tcx>, CodeExtent<'tcx>>,\n \n     /// `var_map` maps from a variable or binding id to the block in\n     /// which that variable is declared.\n-    var_map: RefCell<NodeMap<CodeExtent>>,\n+    var_map: NodeMap<CodeExtent<'tcx>>,\n+\n+    /// maps from a node-id to the associated destruction scope (if any)\n+    destruction_scopes: NodeMap<CodeExtent<'tcx>>,\n \n     /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n     /// larger than the default. The map goes from the expression id\n     /// to the cleanup scope id. For rvalues not present in this\n     /// table, the appropriate cleanup scope is the innermost\n     /// enclosing statement, conditional expression, or repeating\n     /// block (see `terminating_scopes`).\n-    rvalue_scopes: RefCell<NodeMap<CodeExtent>>,\n+    rvalue_scopes: NodeMap<CodeExtent<'tcx>>,\n \n     /// Records the value of rvalue scopes before they were shrunk by\n     /// #36082, for error reporting.\n     ///\n     /// FIXME: this should be temporary. Remove this by 1.18.0 or\n     /// so.\n-    shrunk_rvalue_scopes: RefCell<NodeMap<CodeExtent>>,\n+    shrunk_rvalue_scopes: NodeMap<CodeExtent<'tcx>>,\n \n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n@@ -289,11 +253,11 @@ pub struct RegionMaps {\n     /// closure defined by that fn. See the \"Modeling closures\"\n     /// section of the README in infer::region_inference for\n     /// more details.\n-    fn_tree: RefCell<NodeMap<ast::NodeId>>,\n+    fn_tree: NodeMap<ast::NodeId>,\n }\n \n #[derive(Debug, Copy, Clone)]\n-pub struct Context {\n+pub struct Context<'tcx> {\n     /// the root of the current region tree. This is typically the id\n     /// of the innermost fn body. Each fn forms its own disjoint tree\n     /// in the region hierarchy. These fn bodies are themselves\n@@ -303,21 +267,21 @@ pub struct Context {\n     root_id: Option<ast::NodeId>,\n \n     /// the scope that contains any new variables declared\n-    var_parent: CodeExtent,\n+    var_parent: Option<CodeExtent<'tcx>>,\n \n     /// region parent of expressions etc\n-    parent: CodeExtent\n+    parent: Option<CodeExtent<'tcx>>,\n }\n \n-struct RegionResolutionVisitor<'hir: 'a, 'a> {\n-    sess: &'a Session,\n+struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Generated maps:\n-    region_maps: &'a RegionMaps,\n+    region_maps: &'a mut RegionMaps<'tcx>,\n \n-    cx: Context,\n+    cx: Context<'tcx>,\n \n-    map: &'a hir_map::Map<'hir>,\n+    map: &'a hir_map::Map<'tcx>,\n \n     /// `terminating_scopes` is a set containing the ids of each\n     /// statement, or conditional/repeating expression. These scopes\n@@ -339,155 +303,117 @@ struct RegionResolutionVisitor<'hir: 'a, 'a> {\n     /// arbitrary amounts of stack space. Terminating scopes end\n     /// up being contained in a DestructionScope that contains the\n     /// destructor's execution.\n-    terminating_scopes: NodeSet\n+    terminating_scopes: NodeSet,\n }\n \n \n-impl RegionMaps {\n-    /// create a bogus code extent for the regions in astencode types. Nobody\n-    /// really cares about the contents of these.\n-    pub fn bogus_code_extent(&self, e: CodeExtentData) -> CodeExtent {\n-        self.intern_code_extent(e, DUMMY_CODE_EXTENT)\n-    }\n-    pub fn lookup_code_extent(&self, e: CodeExtentData) -> CodeExtent {\n-        match self.code_extent_interner.borrow().get(&e) {\n-            Some(&d) => d,\n-            None => bug!(\"unknown code extent {:?}\", e)\n+impl<'tcx> RegionMaps<'tcx> {\n+    pub fn new() -> Self {\n+        RegionMaps {\n+            scope_map: FxHashMap(),\n+            destruction_scopes: FxHashMap(),\n+            var_map: NodeMap(),\n+            rvalue_scopes: NodeMap(),\n+            shrunk_rvalue_scopes: NodeMap(),\n+            fn_tree: NodeMap(),\n         }\n     }\n-    pub fn node_extent(&self, n: ast::NodeId) -> CodeExtent {\n-        self.lookup_code_extent(CodeExtentData::Misc(n))\n-    }\n-    // Returns the code extent for an item - the destruction scope.\n-    pub fn item_extent(&self, n: ast::NodeId) -> CodeExtent {\n-        self.lookup_code_extent(CodeExtentData::DestructionScope(n))\n-    }\n-    pub fn call_site_extent(&self, fn_id: ast::NodeId, body_id: ast::NodeId) -> CodeExtent {\n-        assert!(fn_id != body_id);\n-        self.lookup_code_extent(CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id })\n-    }\n-    pub fn opt_destruction_extent(&self, n: ast::NodeId) -> Option<CodeExtent> {\n-        self.code_extent_interner.borrow().get(&CodeExtentData::DestructionScope(n)).cloned()\n-    }\n-    pub fn intern_code_extent(&self,\n-                              e: CodeExtentData,\n-                              parent: CodeExtent) -> CodeExtent {\n-        match self.code_extent_interner.borrow_mut().entry(e) {\n-            Entry::Occupied(o) => {\n-                // this can happen when the bogus code extents from tydecode\n-                // have (bogus) NodeId-s that overlap items created during\n-                // inlining.\n-                // We probably shouldn't be creating bogus code extents\n-                // though.\n-                let idx = *o.get();\n-                if parent == DUMMY_CODE_EXTENT {\n-                    info!(\"CodeExtent({}) = {:?} [parent={}] BOGUS!\",\n-                          idx.0, e, parent.0);\n-                } else {\n-                    assert_eq!(self.scope_map.borrow()[idx.0 as usize],\n-                               DUMMY_CODE_EXTENT);\n-                    info!(\"CodeExtent({}) = {:?} [parent={}] RECLAIMED!\",\n-                          idx.0, e, parent.0);\n-                    self.scope_map.borrow_mut()[idx.0 as usize] = parent;\n-                }\n-                idx\n-            }\n-            Entry::Vacant(v) => {\n-                if self.code_extents.borrow().len() > 0xffffffffusize {\n-                    bug!() // should pass a sess,\n-                           // but this isn't the only place\n-                }\n-                let idx = CodeExtent(self.code_extents.borrow().len() as u32);\n-                debug!(\"CodeExtent({}) = {:?} [parent={}]\", idx.0, e, parent.0);\n-                self.code_extents.borrow_mut().push(e);\n-                self.scope_map.borrow_mut().push(parent);\n-                *v.insert(idx)\n-            }\n+\n+    pub fn record_code_extent(&mut self,\n+                              child: CodeExtent<'tcx>,\n+                              parent: Option<CodeExtent<'tcx>>) {\n+        debug!(\"{:?}.parent = {:?}\", child, parent);\n+\n+        if let Some(p) = parent {\n+            let prev = self.scope_map.insert(child, p);\n+            assert!(prev.is_none());\n+        }\n+\n+        // record the destruction scopes for later so we can query them\n+        if let &CodeExtentData::DestructionScope(n) = child {\n+            self.destruction_scopes.insert(n, child);\n         }\n     }\n-    pub fn intern_node(&self,\n-                       n: ast::NodeId,\n-                       parent: CodeExtent) -> CodeExtent {\n-        self.intern_code_extent(CodeExtentData::Misc(n), parent)\n-    }\n-    pub fn code_extent_data(&self, e: CodeExtent) -> CodeExtentData {\n-        self.code_extents.borrow()[e.0 as usize]\n-    }\n-    pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(&CodeExtent, &CodeExtent) {\n-        for child_id in 1..self.code_extents.borrow().len() {\n-            let child = CodeExtent(child_id as u32);\n-            if let Some(parent) = self.opt_encl_scope(child) {\n-                e(&child, &parent)\n-            }\n+\n+    pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(CodeExtent<'tcx>, CodeExtent<'tcx>) {\n+        for (&child, &parent) in &self.scope_map {\n+            e(child, parent)\n         }\n     }\n-    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, &CodeExtent) {\n-        for (child, parent) in self.var_map.borrow().iter() {\n+\n+    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, CodeExtent<'tcx>) {\n+        for (child, parent) in self.var_map.iter() {\n             e(child, parent)\n         }\n     }\n \n+    pub fn opt_destruction_extent(&self, n: ast::NodeId) -> Option<CodeExtent<'tcx>> {\n+        self.destruction_scopes.get(&n).cloned()\n+    }\n+\n     /// Records that `sub_fn` is defined within `sup_fn`. These ids\n     /// should be the id of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n-    fn record_fn_parent(&self, sub_fn: ast::NodeId, sup_fn: ast::NodeId) {\n+    fn record_fn_parent(&mut self, sub_fn: ast::NodeId, sup_fn: ast::NodeId) {\n         debug!(\"record_fn_parent(sub_fn={:?}, sup_fn={:?})\", sub_fn, sup_fn);\n         assert!(sub_fn != sup_fn);\n-        let previous = self.fn_tree.borrow_mut().insert(sub_fn, sup_fn);\n+        let previous = self.fn_tree.insert(sub_fn, sup_fn);\n         assert!(previous.is_none());\n     }\n \n     fn fn_is_enclosed_by(&self, mut sub_fn: ast::NodeId, sup_fn: ast::NodeId) -> bool {\n-        let fn_tree = self.fn_tree.borrow();\n         loop {\n             if sub_fn == sup_fn { return true; }\n-            match fn_tree.get(&sub_fn) {\n+            match self.fn_tree.get(&sub_fn) {\n                 Some(&s) => { sub_fn = s; }\n                 None => { return false; }\n             }\n         }\n     }\n \n-    fn record_var_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_var_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent<'tcx>) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id(self));\n-        self.var_map.borrow_mut().insert(var, lifetime);\n+        assert!(var != lifetime.node_id());\n+        self.var_map.insert(var, lifetime);\n     }\n \n-    fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent<'tcx>) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id(self));\n-        self.rvalue_scopes.borrow_mut().insert(var, lifetime);\n+        assert!(var != lifetime.node_id());\n+        self.rvalue_scopes.insert(var, lifetime);\n     }\n \n-    fn record_shrunk_rvalue_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_shrunk_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent<'tcx>) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id(self));\n-        self.shrunk_rvalue_scopes.borrow_mut().insert(var, lifetime);\n+        assert!(var != lifetime.node_id());\n+        self.shrunk_rvalue_scopes.insert(var, lifetime);\n     }\n \n-    pub fn opt_encl_scope(&self, id: CodeExtent) -> Option<CodeExtent> {\n+    pub fn opt_encl_scope(&self, id: CodeExtent<'tcx>) -> Option<CodeExtent<'tcx>> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        self.scope_map.borrow()[id.0 as usize].into_option()\n+        self.scope_map.get(&id).cloned()\n     }\n \n     #[allow(dead_code)] // used in cfg\n-    pub fn encl_scope(&self, id: CodeExtent) -> CodeExtent {\n+    pub fn encl_scope(&self, id: CodeExtent<'tcx>) -> CodeExtent<'tcx> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n         self.opt_encl_scope(id).unwrap()\n     }\n \n     /// Returns the lifetime of the local variable `var_id`\n-    pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent {\n-        match self.var_map.borrow().get(&var_id) {\n+    pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent<'tcx> {\n+        match self.var_map.get(&var_id) {\n             Some(&r) => r,\n             None => { bug!(\"no enclosing scope for id {:?}\", var_id); }\n         }\n     }\n \n-    pub fn temporary_scope2(&self, expr_id: ast::NodeId) -> (Option<CodeExtent>, bool) {\n-        let temporary_scope = self.temporary_scope(expr_id);\n-        let was_shrunk = match self.shrunk_rvalue_scopes.borrow().get(&expr_id) {\n+    pub fn temporary_scope2<'a, 'gcx: 'tcx>(&self,\n+                                            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                            expr_id: ast::NodeId)\n+                                            -> (Option<CodeExtent<'tcx>>, bool) {\n+        let temporary_scope = self.temporary_scope(tcx, expr_id);\n+        let was_shrunk = match self.shrunk_rvalue_scopes.get(&expr_id) {\n             Some(&s) => {\n                 info!(\"temporary_scope2({:?}, scope={:?}, shrunk={:?})\",\n                       expr_id, temporary_scope, s);\n@@ -499,36 +425,39 @@ impl RegionMaps {\n         (temporary_scope, was_shrunk)\n     }\n \n-    pub fn old_and_new_temporary_scope(&self, expr_id: ast::NodeId) ->\n-        (Option<CodeExtent>, Option<CodeExtent>)\n+    pub fn old_and_new_temporary_scope<'a, 'gcx: 'tcx>(&self,\n+                                                       tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                       expr_id: ast::NodeId)\n+                                                       -> (Option<CodeExtent<'tcx>>,\n+                                                           Option<CodeExtent<'tcx>>)\n     {\n-        let temporary_scope = self.temporary_scope(expr_id);\n+        let temporary_scope = self.temporary_scope(tcx, expr_id);\n         (temporary_scope,\n          self.shrunk_rvalue_scopes\n-             .borrow().get(&expr_id).cloned()\n+             .get(&expr_id).cloned()\n              .or(temporary_scope))\n     }\n \n-    pub fn temporary_scope(&self, expr_id: ast::NodeId) -> Option<CodeExtent> {\n+    pub fn temporary_scope<'a, 'gcx: 'tcx>(&self,\n+                                           tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                           expr_id: ast::NodeId)\n+                                           -> Option<CodeExtent<'tcx>> {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n-        if let Some(&s) = self.rvalue_scopes.borrow().get(&expr_id) {\n+        if let Some(&s) = self.rvalue_scopes.get(&expr_id) {\n             debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n             return Some(s);\n         }\n \n-        let scope_map : &[CodeExtent] = &self.scope_map.borrow();\n-        let code_extents: &[CodeExtentData] = &self.code_extents.borrow();\n-\n         // else, locate the innermost terminating scope\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n-        let mut id = self.node_extent(expr_id);\n+        let mut id = tcx.node_extent(expr_id);\n \n-        while let Some(p) = scope_map[id.0 as usize].into_option() {\n-            match code_extents[p.0 as usize] {\n+        while let Some(&p) = self.scope_map.get(id) {\n+            match *p {\n                 CodeExtentData::DestructionScope(..) => {\n                     debug!(\"temporary_scope({:?}) = {:?} [enclosing]\",\n                            expr_id, id);\n@@ -542,7 +471,7 @@ impl RegionMaps {\n         return None;\n     }\n \n-    pub fn var_region(&self, id: ast::NodeId) -> ty::Region {\n+    pub fn var_region(&self, id: ast::NodeId) -> ty::RegionKind<'tcx> {\n         //! Returns the lifetime of the variable `id`.\n \n         let scope = ty::ReScope(self.var_scope(id));\n@@ -584,20 +513,22 @@ impl RegionMaps {\n     /// Finds the nearest common ancestor (if any) of two scopes.  That is, finds the smallest\n     /// scope which is greater than or equal to both `scope_a` and `scope_b`.\n     pub fn nearest_common_ancestor(&self,\n-                                   scope_a: CodeExtent,\n-                                   scope_b: CodeExtent)\n-                                   -> CodeExtent {\n+                                   scope_a: CodeExtent<'tcx>,\n+                                   scope_b: CodeExtent<'tcx>)\n+                                   -> CodeExtent<'tcx> {\n         if scope_a == scope_b { return scope_a; }\n \n-        let mut a_buf: [CodeExtent; 32] = [ROOT_CODE_EXTENT; 32];\n-        let mut a_vec: Vec<CodeExtent> = vec![];\n-        let mut b_buf: [CodeExtent; 32] = [ROOT_CODE_EXTENT; 32];\n-        let mut b_vec: Vec<CodeExtent> = vec![];\n-        let scope_map : &[CodeExtent] = &self.scope_map.borrow();\n-        let a_ancestors = ancestors_of(scope_map,\n-                                       scope_a, &mut a_buf, &mut a_vec);\n-        let b_ancestors = ancestors_of(scope_map,\n-                                       scope_b, &mut b_buf, &mut b_vec);\n+        /// [1] The initial values for `a_buf` and `b_buf` are not used.\n+        /// The `ancestors_of` function will return some prefix that\n+        /// is re-initialized with new values (or else fallback to a\n+        /// heap-allocated vector).\n+        let mut a_buf: [CodeExtent; 32] = [scope_a /* [1] */; 32];\n+        let mut a_vec: Vec<CodeExtent<'tcx>> = vec![];\n+        let mut b_buf: [CodeExtent; 32] = [scope_b /* [1] */; 32];\n+        let mut b_vec: Vec<CodeExtent<'tcx>> = vec![];\n+        let scope_map = &self.scope_map;\n+        let a_ancestors = ancestors_of(scope_map, scope_a, &mut a_buf, &mut a_vec);\n+        let b_ancestors = ancestors_of(scope_map, scope_b, &mut b_buf, &mut b_vec);\n         let mut a_index = a_ancestors.len() - 1;\n         let mut b_index = b_ancestors.len() - 1;\n \n@@ -615,11 +546,11 @@ impl RegionMaps {\n             // nesting. The reasoning behind this is subtle.  See the\n             // \"Modeling closures\" section of the README in\n             // infer::region_inference for more details.\n-            let a_root_scope = self.code_extent_data(a_ancestors[a_index]);\n-            let b_root_scope = self.code_extent_data(a_ancestors[a_index]);\n+            let a_root_scope = a_ancestors[a_index];\n+            let b_root_scope = a_ancestors[a_index];\n             return match (a_root_scope, b_root_scope) {\n-                (CodeExtentData::DestructionScope(a_root_id),\n-                 CodeExtentData::DestructionScope(b_root_id)) => {\n+                (&CodeExtentData::DestructionScope(a_root_id),\n+                 &CodeExtentData::DestructionScope(b_root_id)) => {\n                     if self.fn_is_enclosed_by(a_root_id, b_root_id) {\n                         // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n                         scope_b\n@@ -650,17 +581,18 @@ impl RegionMaps {\n             }\n         }\n \n-        fn ancestors_of<'a>(scope_map: &[CodeExtent],\n-                            scope: CodeExtent,\n-                            buf: &'a mut [CodeExtent; 32],\n-                            vec: &'a mut Vec<CodeExtent>) -> &'a [CodeExtent] {\n+        fn ancestors_of<'a, 'tcx>(scope_map: &FxHashMap<CodeExtent<'tcx>, CodeExtent<'tcx>>,\n+                                  scope: CodeExtent<'tcx>,\n+                                  buf: &'a mut [CodeExtent<'tcx>; 32],\n+                                  vec: &'a mut Vec<CodeExtent<'tcx>>)\n+                                  -> &'a [CodeExtent<'tcx>] {\n             // debug!(\"ancestors_of(scope={:?})\", scope);\n             let mut scope = scope;\n \n             let mut i = 0;\n             while i < 32 {\n                 buf[i] = scope;\n-                match scope_map[scope.0 as usize].into_option() {\n+                match scope_map.get(&scope) {\n                     Some(superscope) => scope = superscope,\n                     _ => return &buf[..i+1]\n                 }\n@@ -671,7 +603,7 @@ impl RegionMaps {\n             vec.extend_from_slice(buf);\n             loop {\n                 vec.push(scope);\n-                match scope_map[scope.0 as usize].into_option() {\n+                match scope_map.get(&scope) {\n                     Some(superscope) => scope = superscope,\n                     _ => return &*vec\n                 }\n@@ -685,17 +617,17 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n                        var_id: ast::NodeId,\n                        _sp: Span) {\n     match visitor.cx.var_parent {\n-        ROOT_CODE_EXTENT => {\n+        None => {\n             // this can happen in extern fn declarations like\n             //\n             // extern fn isalnum(c: c_int) -> c_int\n         }\n-        parent_scope =>\n+        Some(parent_scope) =>\n             visitor.region_maps.record_var_scope(var_id, parent_scope),\n     }\n }\n \n-fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, blk: &'tcx hir::Block) {\n+fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk: &'tcx hir::Block) {\n     debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n     let prev_cx = visitor.cx;\n@@ -728,8 +660,8 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, blk:\n \n     visitor.cx = Context {\n         root_id: prev_cx.root_id,\n-        var_parent: block_extent,\n-        parent: block_extent,\n+        var_parent: Some(block_extent),\n+        parent: Some(block_extent),\n     };\n \n     {\n@@ -754,8 +686,8 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, blk:\n                 );\n                 visitor.cx = Context {\n                     root_id: prev_cx.root_id,\n-                    var_parent: stmt_extent,\n-                    parent: stmt_extent,\n+                    var_parent: Some(stmt_extent),\n+                    parent: Some(stmt_extent),\n                 };\n             }\n             visitor.visit_stmt(statement)\n@@ -766,7 +698,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, blk:\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, arm: &'tcx hir::Arm) {\n+fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &'tcx hir::Arm) {\n     visitor.terminating_scopes.insert(arm.body.id);\n \n     if let Some(ref expr) = arm.guard {\n@@ -776,7 +708,7 @@ fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, arm: &\n     intravisit::walk_arm(visitor, arm);\n }\n \n-fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, pat: &'tcx hir::Pat) {\n+fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &'tcx hir::Pat) {\n     visitor.new_node_extent(pat.id);\n \n     // If this is a binding then record the lifetime of that binding.\n@@ -787,7 +719,7 @@ fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, pat: &\n     intravisit::walk_pat(visitor, pat);\n }\n \n-fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, stmt: &'tcx hir::Stmt) {\n+fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n     let stmt_id = stmt.node.id();\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n@@ -800,17 +732,17 @@ fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, stmt:\n     let stmt_extent = visitor.new_node_extent_with_dtor(stmt_id);\n \n     let prev_parent = visitor.cx.parent;\n-    visitor.cx.parent = stmt_extent;\n+    visitor.cx.parent = Some(stmt_extent);\n     intravisit::walk_stmt(visitor, stmt);\n     visitor.cx.parent = prev_parent;\n }\n \n-fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, expr: &'tcx hir::Expr) {\n+fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr: &'tcx hir::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n     let expr_extent = visitor.new_node_extent_with_dtor(expr.id);\n     let prev_cx = visitor.cx;\n-    visitor.cx.parent = expr_extent;\n+    visitor.cx.parent = Some(expr_extent);\n \n     {\n         let terminating_scopes = &mut visitor.terminating_scopes;\n@@ -850,7 +782,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, expr:\n             }\n \n             hir::ExprMatch(..) => {\n-                visitor.cx.var_parent = expr_extent;\n+                visitor.cx.var_parent = Some(expr_extent);\n             }\n \n             hir::ExprAssignOp(..) | hir::ExprIndex(..) |\n@@ -883,7 +815,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, expr:\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n+fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                            local: &'tcx hir::Local) {\n     debug!(\"resolve_local(local.id={:?},local.init={:?})\",\n            local.id,local.init.is_some());\n@@ -892,7 +824,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     // scope that will be used for any bindings declared in this\n     // pattern.\n     let blk_scope = visitor.cx.var_parent;\n-    assert!(blk_scope != ROOT_CODE_EXTENT); // locals must be within a block\n+    let blk_scope = blk_scope.expect(\"locals must be within a block\");\n     visitor.region_maps.record_var_scope(local.id, blk_scope);\n \n     // As an exception to the normal rules governing temporary\n@@ -1024,9 +956,11 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     ///        | box E&\n     ///        | E& as ...\n     ///        | ( E& )\n-    fn record_rvalue_scope_if_borrow_expr(visitor: &mut RegionResolutionVisitor,\n-                                          expr: &hir::Expr,\n-                                          blk_id: CodeExtent) {\n+    fn record_rvalue_scope_if_borrow_expr<'a, 'tcx>(\n+        visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n+        expr: &hir::Expr,\n+        blk_id: CodeExtent<'tcx>)\n+    {\n         match expr.node {\n             hir::ExprAddrOf(_, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n@@ -1073,10 +1007,10 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     ///        | <rvalue>\n     ///\n     /// Note: ET is intended to match \"rvalues or lvalues based on rvalues\".\n-    fn record_rvalue_scope<'a>(visitor: &mut RegionResolutionVisitor,\n-                               expr: &'a hir::Expr,\n-                               blk_scope: CodeExtent,\n-                               is_shrunk: bool) {\n+    fn record_rvalue_scope<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n+                                     expr: &hir::Expr,\n+                                     blk_scope: CodeExtent<'tcx>,\n+                                     is_shrunk: bool) {\n         let mut expr = expr;\n         loop {\n             // Note: give all the expressions matching `ET` with the\n@@ -1107,43 +1041,40 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     }\n }\n \n-fn resolve_item_like<'a, 'tcx, F>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n-                                  id: ast::NodeId,\n-                                  walk: F)\n-    where F: FnOnce(&mut RegionResolutionVisitor<'tcx, 'a>)\n+fn resolve_item_like<'a, 'tcx, F>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, walk: F)\n+    where F: FnOnce(&mut RegionResolutionVisitor<'a, 'tcx>)\n {\n     // Items create a new outer block scope as far as we're concerned.\n     let prev_cx = visitor.cx;\n     let prev_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n     visitor.cx = Context {\n         root_id: None,\n-        var_parent: ROOT_CODE_EXTENT,\n-        parent: ROOT_CODE_EXTENT\n+        var_parent: None,\n+        parent: None,\n     };\n     walk(visitor);\n-    visitor.create_item_scope_if_needed(id);\n     visitor.cx = prev_cx;\n     visitor.terminating_scopes = prev_ts;\n }\n \n-fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n+fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                         kind: FnKind<'tcx>,\n                         decl: &'tcx hir::FnDecl,\n                         body_id: hir::BodyId,\n                         sp: Span,\n                         id: ast::NodeId) {\n+    visitor.cx.parent = Some(visitor.new_code_extent(\n+        CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id }));\n+\n     debug!(\"region::resolve_fn(id={:?}, \\\n-                               span={:?}, \\\n-                               body.id={:?}, \\\n-                               cx.parent={:?})\",\n+            span={:?}, \\\n+            body.id={:?}, \\\n+            cx.parent={:?})\",\n            id,\n-           visitor.sess.codemap().span_to_string(sp),\n+           visitor.tcx.sess.codemap().span_to_string(sp),\n            body_id,\n            visitor.cx.parent);\n \n-    visitor.cx.parent = visitor.new_code_extent(\n-        CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id });\n-\n     let fn_decl_scope = visitor.new_code_extent(\n         CodeExtentData::ParameterScope { fn_id: id, body_id: body_id.node_id });\n \n@@ -1158,8 +1089,8 @@ fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     // The arguments and `self` are parented to the fn.\n     visitor.cx = Context {\n         root_id: Some(body_id.node_id),\n-        parent: ROOT_CODE_EXTENT,\n-        var_parent: fn_decl_scope,\n+        parent: None,\n+        var_parent: Some(fn_decl_scope),\n     };\n \n     intravisit::walk_fn_decl(visitor, decl);\n@@ -1168,8 +1099,8 @@ fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     // The body of the every fn is a root scope.\n     visitor.cx = Context {\n         root_id: Some(body_id.node_id),\n-        parent: fn_decl_scope,\n-        var_parent: fn_decl_scope\n+        parent: Some(fn_decl_scope),\n+        var_parent: Some(fn_decl_scope),\n     };\n     visitor.visit_nested_body(body_id);\n \n@@ -1178,116 +1109,124 @@ fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     visitor.terminating_scopes = outer_ts;\n }\n \n-impl<'hir, 'a> RegionResolutionVisitor<'hir, 'a> {\n+impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n+    pub fn intern_code_extent(&mut self,\n+                              data: CodeExtentData,\n+                              parent: Option<CodeExtent<'tcx>>)\n+                              -> CodeExtent<'tcx> {\n+        let code_extent = self.tcx.intern_code_extent(data);\n+        self.region_maps.record_code_extent(code_extent, parent);\n+        code_extent\n+    }\n+\n+    pub fn intern_node(&mut self,\n+                       n: ast::NodeId,\n+                       parent: Option<CodeExtent<'tcx>>) -> CodeExtent<'tcx> {\n+        self.intern_code_extent(CodeExtentData::Misc(n), parent)\n+    }\n+\n     /// Records the current parent (if any) as the parent of `child_scope`.\n-    fn new_code_extent(&mut self, child_scope: CodeExtentData) -> CodeExtent {\n-        self.region_maps.intern_code_extent(child_scope, self.cx.parent)\n+    fn new_code_extent(&mut self, child_scope: CodeExtentData) -> CodeExtent<'tcx> {\n+        let parent = self.cx.parent;\n+        self.intern_code_extent(child_scope, parent)\n     }\n \n-    fn new_node_extent(&mut self, child_scope: ast::NodeId) -> CodeExtent {\n+    fn new_node_extent(&mut self, child_scope: ast::NodeId) -> CodeExtent<'tcx> {\n         self.new_code_extent(CodeExtentData::Misc(child_scope))\n     }\n \n-    fn new_node_extent_with_dtor(&mut self, id: ast::NodeId) -> CodeExtent {\n+    fn new_node_extent_with_dtor(&mut self, id: ast::NodeId) -> CodeExtent<'tcx> {\n         // If node was previously marked as a terminating scope during the\n         // recursive visit of its parent node in the AST, then we need to\n         // account for the destruction scope representing the extent of\n         // the destructors that run immediately after it completes.\n         if self.terminating_scopes.contains(&id) {\n             let ds = self.new_code_extent(\n                 CodeExtentData::DestructionScope(id));\n-            self.region_maps.intern_node(id, ds)\n+            self.intern_node(id, Some(ds))\n         } else {\n             self.new_node_extent(id)\n         }\n     }\n-\n-    fn create_item_scope_if_needed(&mut self, id: ast::NodeId) {\n-        // create a region for the destruction scope - this is needed\n-        // for constructing parameter environments based on the item.\n-        // functions put their destruction scopes *inside* their parameter\n-        // scopes.\n-        let scope = CodeExtentData::DestructionScope(id);\n-        if !self.region_maps.code_extent_interner.borrow().contains_key(&scope) {\n-            self.region_maps.intern_code_extent(scope, ROOT_CODE_EXTENT);\n-        }\n-    }\n }\n \n-impl<'hir, 'a> Visitor<'hir> for RegionResolutionVisitor<'hir, 'a> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n+impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.map)\n     }\n \n-    fn visit_block(&mut self, b: &'hir Block) {\n+    fn visit_block(&mut self, b: &'tcx Block) {\n         resolve_block(self, b);\n     }\n \n-    fn visit_item(&mut self, i: &'hir Item) {\n-        resolve_item_like(self, i.id, |this| intravisit::walk_item(this, i));\n+    fn visit_item(&mut self, i: &'tcx Item) {\n+        resolve_item_like(self, |this| intravisit::walk_item(this, i));\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'hir hir::ImplItem) {\n-        resolve_item_like(self, ii.id, |this| intravisit::walk_impl_item(this, ii));\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n+        resolve_item_like(self, |this| intravisit::walk_impl_item(this, ii));\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'hir hir::TraitItem) {\n-        resolve_item_like(self, ti.id, |this| intravisit::walk_trait_item(this, ti));\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n+        resolve_item_like(self, |this| intravisit::walk_trait_item(this, ti));\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'hir>, fd: &'hir FnDecl,\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx FnDecl,\n                 b: hir::BodyId, s: Span, n: NodeId) {\n         resolve_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_arm(&mut self, a: &'hir Arm) {\n+    fn visit_arm(&mut self, a: &'tcx Arm) {\n         resolve_arm(self, a);\n     }\n-    fn visit_pat(&mut self, p: &'hir Pat) {\n+    fn visit_pat(&mut self, p: &'tcx Pat) {\n         resolve_pat(self, p);\n     }\n-    fn visit_stmt(&mut self, s: &'hir Stmt) {\n+    fn visit_stmt(&mut self, s: &'tcx Stmt) {\n         resolve_stmt(self, s);\n     }\n-    fn visit_expr(&mut self, ex: &'hir Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n         resolve_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l: &'hir Local) {\n+    fn visit_local(&mut self, l: &'tcx Local) {\n         resolve_local(self, l);\n     }\n }\n \n-pub fn resolve_crate(sess: &Session, map: &hir_map::Map) -> RegionMaps {\n-    let _task = map.dep_graph.in_task(DepNode::RegionResolveCrate);\n-    let krate = map.krate();\n-\n-    let maps = RegionMaps {\n-        code_extents: RefCell::new(vec![]),\n-        code_extent_interner: RefCell::new(FxHashMap()),\n-        scope_map: RefCell::new(vec![]),\n-        var_map: RefCell::new(NodeMap()),\n-        rvalue_scopes: RefCell::new(NodeMap()),\n-        shrunk_rvalue_scopes: RefCell::new(NodeMap()),\n-        fn_tree: RefCell::new(NodeMap()),\n-    };\n-    let root_extent = maps.bogus_code_extent(\n-        CodeExtentData::DestructionScope(ast::DUMMY_NODE_ID));\n-    assert_eq!(root_extent, ROOT_CODE_EXTENT);\n-    let bogus_extent = maps.bogus_code_extent(\n-        CodeExtentData::Misc(ast::DUMMY_NODE_ID));\n-    assert_eq!(bogus_extent, DUMMY_CODE_EXTENT);\n+fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, fn_id: DefId)\n+    -> Rc<RegionMaps<'tcx>>\n+{\n+    let closure_base_def_id = tcx.closure_base_def_id(fn_id);\n+    if closure_base_def_id != fn_id {\n+        return tcx.region_maps(closure_base_def_id);\n+    }\n+\n+    let mut maps = RegionMaps::new();\n+\n+    let fn_node_id = tcx.hir.as_local_node_id(fn_id)\n+                            .expect(\"fn DefId should be for LOCAL_CRATE\");\n+    let node = tcx.hir.get(fn_node_id);\n+\n     {\n         let mut visitor = RegionResolutionVisitor {\n-            sess: sess,\n-            region_maps: &maps,\n-            map: map,\n+            tcx: tcx,\n+            region_maps: &mut maps,\n+            map: &tcx.hir,\n             cx: Context {\n                 root_id: None,\n-                parent: ROOT_CODE_EXTENT,\n-                var_parent: ROOT_CODE_EXTENT\n+                parent: None,\n+                var_parent: None,\n             },\n-            terminating_scopes: NodeSet()\n+            terminating_scopes: NodeSet(),\n         };\n-        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n+        visitor.visit_hir_map_node(node);\n     }\n-    return maps;\n+\n+    Rc::new(maps)\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        region_maps,\n+        ..*providers\n+    };\n }"}, {"sha": "8f8af8b10366e4748c9cb0018bd14b5877e0939a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -1034,7 +1034,7 @@ pub enum Rvalue<'tcx> {\n     Repeat(Operand<'tcx>, ConstUsize),\n \n     /// &x or &mut x\n-    Ref(&'tcx Region, BorrowKind, Lvalue<'tcx>),\n+    Ref(Region<'tcx>, BorrowKind, Lvalue<'tcx>),\n \n     /// length of a [X] or [X;n] value\n     Len(Lvalue<'tcx>),"}, {"sha": "31bdd99ef32210abb0e85e91221396ab14d2e355", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -747,7 +747,7 @@ pub enum LvalueContext<'tcx> {\n     Inspect,\n \n     // Being borrowed\n-    Borrow { region: &'tcx Region, kind: BorrowKind },\n+    Borrow { region: Region<'tcx>, kind: BorrowKind },\n \n     // Used as base for another lvalue, e.g. `x` in `x.y`.\n     //"}, {"sha": "d107e9a84856fbc95050f78bf9bf17cae3131d18", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -1804,7 +1804,7 @@ mod dep_tracking {\n     use rustc_back::PanicStrategy;\n \n     pub trait DepTrackingHash {\n-        fn hash(&self, &mut DefaultHasher, ErrorOutputType);\n+        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType);\n     }\n \n     macro_rules! impl_dep_tracking_hash_via_hash {"}, {"sha": "e8baaa7ffb26d01a59f705e28d7bc2ece9df2707", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -84,7 +84,7 @@ pub struct FulfillmentContext<'tcx> {\n \n #[derive(Clone)]\n pub struct RegionObligation<'tcx> {\n-    pub sub_region: &'tcx ty::Region,\n+    pub sub_region: ty::Region<'tcx>,\n     pub sup_type: Ty<'tcx>,\n     pub cause: ObligationCause<'tcx>,\n }\n@@ -155,7 +155,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n     pub fn register_region_obligation(&mut self,\n                                       t_a: Ty<'tcx>,\n-                                      r_b: &'tcx ty::Region,\n+                                      r_b: ty::Region<'tcx>,\n                                       cause: ObligationCause<'tcx>)\n     {\n         register_region_obligation(t_a, r_b, cause, &mut self.region_obligations);\n@@ -566,7 +566,7 @@ fn coinductive_obligation<'a,'gcx,'tcx>(selcx: &SelectionContext<'a,'gcx,'tcx>,\n }\n \n fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n-                                    r_b: &'tcx ty::Region,\n+                                    r_b: ty::Region<'tcx>,\n                                     cause: ObligationCause<'tcx>,\n                                     region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n {"}, {"sha": "4f7cb2b12a7caa505060bb9a1882114391155cc3", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -17,6 +17,7 @@ pub use self::ObligationCauseCode::*;\n \n use hir;\n use hir::def_id::DefId;\n+use middle::region::RegionMaps;\n use middle::free_region::FreeRegionMap;\n use ty::subst::Substs;\n use ty::{self, Ty, TyCtxt, TypeFoldable, ToPredicate};\n@@ -112,7 +113,7 @@ pub enum ObligationCauseCode<'tcx> {\n     ReferenceOutlivesReferent(Ty<'tcx>),\n \n     /// A type like `Box<Foo<'a> + 'b>` is WF only if `'b: 'a`.\n-    ObjectTypeBound(Ty<'tcx>, &'tcx ty::Region),\n+    ObjectTypeBound(Ty<'tcx>, ty::Region<'tcx>),\n \n     /// Obligation incurred due to an object cast.\n     ObjectCastObligation(/* Object type */ Ty<'tcx>),\n@@ -435,9 +436,10 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n // FIXME: this is gonna need to be removed ...\n /// Normalizes the parameter environment, reporting errors if they occur.\n pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    unnormalized_env: ty::ParameterEnvironment<'tcx>,\n-    cause: ObligationCause<'tcx>)\n-    -> ty::ParameterEnvironment<'tcx>\n+                                              region_context: DefId,\n+                                              unnormalized_env: ty::ParameterEnvironment<'tcx>,\n+                                              cause: ObligationCause<'tcx>)\n+                                              -> ty::ParameterEnvironment<'tcx>\n {\n     // I'm not wild about reporting errors here; I'd prefer to\n     // have the errors get reported at a defined place (e.g.,\n@@ -455,7 +457,6 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // can be sure that no errors should occur.\n \n     let span = cause.span;\n-    let body_id = cause.body_id;\n \n     debug!(\"normalize_param_env_or_error(unnormalized_env={:?})\",\n            unnormalized_env);\n@@ -492,8 +493,9 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"normalize_param_env_or_error: normalized predicates={:?}\",\n             predicates);\n \n+        let region_maps = RegionMaps::new();\n         let free_regions = FreeRegionMap::new();\n-        infcx.resolve_regions_and_report_errors(&free_regions, body_id);\n+        infcx.resolve_regions_and_report_errors(region_context, &region_maps, &free_regions);\n         let predicates = match infcx.fully_resolve(&predicates) {\n             Ok(predicates) => predicates,\n             Err(fixup_err) => {"}, {"sha": "ea1a2f9a982c93d51322d2bb361b4f44faa9b533", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -206,8 +206,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-        let free_substs = self.construct_free_substs(def_id,\n-            self.region_maps.node_extent(ast::DUMMY_NODE_ID));\n+        let free_substs = self.construct_free_substs(def_id, None);\n         let predicates = self.predicates_of(def_id);\n         let predicates = predicates.instantiate(self, free_substs).predicates;\n         elaborate_predicates(self, predicates)"}, {"sha": "d5d17e3c81214901b8f3a6b7cbb9fabced4d7f54", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -23,7 +23,6 @@ use super::util::impl_trait_ref_and_oblig;\n use rustc_data_structures::fx::FxHashMap;\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n-use middle::region;\n use ty::subst::{Subst, Substs};\n use traits::{self, Reveal, ObligationCause};\n use ty::{self, TyCtxt, TypeFoldable};\n@@ -182,7 +181,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n     let penv = tcx.construct_parameter_environment(DUMMY_SP,\n                                                    impl1_def_id,\n-                                                   region::DUMMY_CODE_EXTENT);\n+                                                   None);\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id)\n                              .unwrap()\n                              .subst(tcx, &penv.free_substs);"}, {"sha": "f86c1cf0dd6aba156797dbee12c82d45786ac2a1", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -52,8 +52,8 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n         self.relate(a, b)\n     }\n \n-    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n-               -> RelateResult<'tcx, &'tcx ty::Region> {\n+    fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "385591e10f744c9052d3cfa8b37a178cd6c3a7b7", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -133,7 +133,7 @@ impl<'tcx> Adjustment<'tcx> {\n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum AutoBorrow<'tcx> {\n     /// Convert from T to &T.\n-    Ref(&'tcx ty::Region, hir::Mutability),\n+    Ref(ty::Region<'tcx>, hir::Mutability),\n \n     /// Convert from T to *T.\n     RawPtr(hir::Mutability),"}, {"sha": "6de61013dfdd3b8583ac0c9a733b53563f5c3c22", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 60, "deletions": 25, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -21,7 +21,7 @@ use hir::map as hir_map;\n use hir::map::DisambiguatedDefPathData;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n-use middle::region::RegionMaps;\n+use middle::region::{CodeExtent, CodeExtentData};\n use middle::resolve_lifetime;\n use middle::stability;\n use mir::Mir;\n@@ -33,6 +33,7 @@ use ty::{TyS, TypeVariants, Slice};\n use ty::{AdtKind, AdtDef, ClosureSubsts, Region};\n use hir::FreevarMap;\n use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n+use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n@@ -93,7 +94,7 @@ pub struct CtxtInterners<'tcx> {\n     type_: RefCell<FxHashSet<Interned<'tcx, TyS<'tcx>>>>,\n     type_list: RefCell<FxHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n     substs: RefCell<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n-    region: RefCell<FxHashSet<Interned<'tcx, Region>>>,\n+    region: RefCell<FxHashSet<Interned<'tcx, RegionKind<'tcx>>>>,\n     existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n }\n \n@@ -191,9 +192,9 @@ pub struct CommonTypes<'tcx> {\n     pub never: Ty<'tcx>,\n     pub err: Ty<'tcx>,\n \n-    pub re_empty: &'tcx Region,\n-    pub re_static: &'tcx Region,\n-    pub re_erased: &'tcx Region,\n+    pub re_empty: Region<'tcx>,\n+    pub re_static: Region<'tcx>,\n+    pub re_erased: Region<'tcx>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -256,7 +257,7 @@ pub struct TypeckTables<'tcx> {\n     /// Stores the free-region relationships that were deduced from\n     /// its where clauses and parameter types. These are then\n     /// read-again by borrowck.\n-    pub free_region_map: FreeRegionMap,\n+    pub free_region_map: FreeRegionMap<'tcx>,\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n@@ -392,9 +393,9 @@ impl<'tcx> CommonTypes<'tcx> {\n             f32: mk(TyFloat(ast::FloatTy::F32)),\n             f64: mk(TyFloat(ast::FloatTy::F64)),\n \n-            re_empty: mk_region(Region::ReEmpty),\n-            re_static: mk_region(Region::ReStatic),\n-            re_erased: mk_region(Region::ReErased),\n+            re_empty: mk_region(RegionKind::ReEmpty),\n+            re_static: mk_region(RegionKind::ReStatic),\n+            re_erased: mk_region(RegionKind::ReErased),\n         }\n     }\n }\n@@ -439,8 +440,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub named_region_map: resolve_lifetime::NamedRegionMap,\n \n-    pub region_maps: RegionMaps,\n-\n     pub hir: hir_map::Map<'tcx>,\n     pub maps: maps::Maps<'tcx>,\n \n@@ -550,6 +549,8 @@ pub struct GlobalCtxt<'tcx> {\n \n     layout_interner: RefCell<FxHashSet<&'tcx Layout>>,\n \n+    code_extent_interner: RefCell<FxHashSet<CodeExtent<'tcx>>>,\n+\n     /// A vector of every trait accessible in the whole crate\n     /// (i.e. including those from subcrates). This is used only for\n     /// error reporting, and so is lazily initialised and generally\n@@ -650,6 +651,32 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         interned\n     }\n \n+    pub fn node_extent(self, n: ast::NodeId) -> CodeExtent<'gcx> {\n+        self.intern_code_extent(CodeExtentData::Misc(n))\n+    }\n+\n+    // Returns the code extent for an item - the destruction scope.\n+    pub fn item_extent(self, n: ast::NodeId) -> CodeExtent<'gcx> {\n+        self.intern_code_extent(CodeExtentData::DestructionScope(n))\n+    }\n+\n+    pub fn call_site_extent(self, fn_id: ast::NodeId, body_id: ast::NodeId) -> CodeExtent<'gcx> {\n+        assert!(fn_id != body_id);\n+        self.intern_code_extent(CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id })\n+    }\n+\n+    pub fn intern_code_extent(self, data: CodeExtentData) -> CodeExtent<'gcx> {\n+        if let Some(st) = self.code_extent_interner.borrow().get(&data) {\n+            return st;\n+        }\n+\n+        let interned = self.global_interners.arena.alloc(data);\n+        if let Some(prev) = self.code_extent_interner.borrow_mut().replace(interned) {\n+            bug!(\"Tried to overwrite interned code-extent: {:?}\", prev)\n+        }\n+        interned\n+    }\n+\n     pub fn intern_layout(self, layout: Layout) -> &'gcx Layout {\n         if let Some(layout) = self.layout_interner.borrow().get(&layout) {\n             return layout;\n@@ -690,7 +717,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   resolutions: ty::Resolutions,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n                                   hir: hir_map::Map<'tcx>,\n-                                  region_maps: RegionMaps,\n                                   lang_items: middle::lang_items::LanguageItems,\n                                   stability: stability::Index<'tcx>,\n                                   crate_name: &str,\n@@ -714,7 +740,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             dep_graph: dep_graph.clone(),\n             types: common_types,\n             named_region_map: named_region_map,\n-            region_maps: region_maps,\n             variance_computed: Cell::new(false),\n             trait_map: resolutions.trait_map,\n             export_map: resolutions.export_map,\n@@ -740,6 +765,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FxHashMap()),\n             layout_interner: RefCell::new(FxHashSet()),\n+            code_extent_interner: RefCell::new(FxHashSet()),\n             layout_depth: Cell::new(0),\n             derive_macros: RefCell::new(NodeMap()),\n             stability_interner: RefCell::new(FxHashSet()),\n@@ -819,9 +845,18 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Region {\n-    type Lifted = &'tcx Region;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Region> {\n+impl<'a, 'tcx> Lift<'tcx> for ty::FreeRegion<'a> {\n+    type Lifted = ty::FreeRegion<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        let scope = self.scope.map(|code_extent| tcx.intern_code_extent(*code_extent));\n+        let bound_region = self.bound_region;\n+        Some(ty::FreeRegion { scope, bound_region })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n+    type Lifted = Region<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Region<'tcx>> {\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n         }\n@@ -1082,9 +1117,9 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, Substs<'tcx>> {\n     }\n }\n \n-impl<'tcx> Borrow<Region> for Interned<'tcx, Region> {\n-    fn borrow<'a>(&'a self) -> &'a Region {\n-        self.0\n+impl<'tcx> Borrow<RegionKind<'tcx>> for Interned<'tcx, RegionKind<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a RegionKind<'tcx> {\n+        &self.0\n     }\n }\n \n@@ -1175,7 +1210,7 @@ direct_interners!('tcx,\n             &ty::ReVar(_) | &ty::ReSkolemized(..) => true,\n             _ => false\n         }\n-    }) -> Region\n+    }) -> RegionKind<'tcx>\n );\n \n macro_rules! slice_interners {\n@@ -1267,15 +1302,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyRawPtr(tm))\n     }\n \n-    pub fn mk_ref(self, r: &'tcx Region, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_ref(self, r: Region<'tcx>, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyRef(r, tm))\n     }\n \n-    pub fn mk_mut_ref(self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_mut_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n     }\n \n-    pub fn mk_imm_ref(self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_imm_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n     }\n \n@@ -1337,7 +1372,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn mk_dynamic(\n         self,\n         obj: ty::Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>,\n-        reg: &'tcx ty::Region\n+        reg: ty::Region<'tcx>\n     ) -> Ty<'tcx> {\n         self.mk_ty(TyDynamic(obj, reg))\n     }\n@@ -1467,7 +1502,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n pub trait InternAs<T: ?Sized, R> {\n     type Output;\n-    fn intern_with<F>(self, F) -> Self::Output\n+    fn intern_with<F>(self, f: F) -> Self::Output\n         where F: FnOnce(&T) -> R;\n }\n "}, {"sha": "d6804976e84c540298976c5aac4578b362ab9f95", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -36,11 +36,11 @@ pub enum TypeError<'tcx> {\n     TupleSize(ExpectedFound<usize>),\n     FixedArraySize(ExpectedFound<usize>),\n     ArgCount,\n-    RegionsDoesNotOutlive(&'tcx Region, &'tcx Region),\n-    RegionsNotSame(&'tcx Region, &'tcx Region),\n-    RegionsNoOverlap(&'tcx Region, &'tcx Region),\n-    RegionsInsufficientlyPolymorphic(BoundRegion, &'tcx Region, Option<Box<ty::Issue32330>>),\n-    RegionsOverlyPolymorphic(BoundRegion, &'tcx Region, Option<Box<ty::Issue32330>>),\n+    RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n+    RegionsNotSame(Region<'tcx>, Region<'tcx>),\n+    RegionsNoOverlap(Region<'tcx>, Region<'tcx>),\n+    RegionsInsufficientlyPolymorphic(BoundRegion, Region<'tcx>, Option<Box<ty::Issue32330>>),\n+    RegionsOverlyPolymorphic(BoundRegion, Region<'tcx>, Option<Box<ty::Issue32330>>),\n     Sorts(ExpectedFound<Ty<'tcx>>),\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n     FloatMismatch(ExpectedFound<ast::FloatTy>),"}, {"sha": "686b99ba680942eb734f8c1578b7ca648d849eac", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -186,7 +186,7 @@ impl FlagComputation {\n         self.add_bound_computation(&computation);\n     }\n \n-    fn add_region(&mut self, r: &ty::Region) {\n+    fn add_region(&mut self, r: ty::Region) {\n         self.add_flags(r.type_flags());\n         if let ty::ReLateBound(debruijn, _) = *r {\n             self.add_depth(debruijn.depth);"}, {"sha": "21ccf6f987b8952307460ee07a4db31d310e9785", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -159,7 +159,7 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         sig.super_fold_with(self)\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         r.super_fold_with(self)\n     }\n \n@@ -182,7 +182,7 @@ pub trait TypeVisitor<'tcx> : Sized {\n         trait_ref.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         r.super_visit_with(self)\n     }\n }\n@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// whether any late-bound regions were skipped\n     pub fn collect_regions<T>(self,\n         value: &T,\n-        region_set: &mut FxHashSet<&'tcx ty::Region>)\n+        region_set: &mut FxHashSet<ty::Region<'tcx>>)\n         -> bool\n         where T : TypeFoldable<'tcx>\n     {\n@@ -236,7 +236,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         skipped_regions: &mut bool,\n         mut f: F)\n         -> T\n-        where F : FnMut(&'tcx ty::Region, u32) -> &'tcx ty::Region,\n+        where F : FnMut(ty::Region<'tcx>, u32) -> ty::Region<'tcx>,\n               T : TypeFoldable<'tcx>,\n     {\n         value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f))\n@@ -256,14 +256,14 @@ pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     skipped_regions: &'a mut bool,\n     current_depth: u32,\n-    fld_r: &'a mut (FnMut(&'tcx ty::Region, u32) -> &'tcx ty::Region + 'a),\n+    fld_r: &'a mut (FnMut(ty::Region<'tcx>, u32) -> ty::Region<'tcx> + 'a),\n }\n \n impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n     pub fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                   skipped_regions: &'a mut bool,\n                   fld_r: &'a mut F) -> RegionFolder<'a, 'gcx, 'tcx>\n-        where F : FnMut(&'tcx ty::Region, u32) -> &'tcx ty::Region\n+        where F : FnMut(ty::Region<'tcx>, u32) -> ty::Region<'tcx>\n     {\n         RegionFolder {\n             tcx: tcx,\n@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, _) if debruijn.depth < self.current_depth => {\n                 debug!(\"RegionFolder.fold_region({:?}) skipped bound region (current depth={})\",\n@@ -309,16 +309,16 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     current_depth: u32,\n-    fld_r: &'a mut (FnMut(ty::BoundRegion) -> &'tcx ty::Region + 'a),\n-    map: FxHashMap<ty::BoundRegion, &'tcx ty::Region>\n+    fld_r: &'a mut (FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n+    map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n-        -> (T, FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n-        where F : FnMut(ty::BoundRegion) -> &'tcx ty::Region,\n+        -> (T, FxHashMap<ty::BoundRegion, ty::Region<'tcx>>)\n+        where F : FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               T : TypeFoldable<'tcx>,\n     {\n         let mut replacer = RegionReplacer::new(self, &mut f);\n@@ -330,7 +330,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Replace any late-bound regions bound in `value` with free variants attached to scope-id\n     /// `scope_id`.\n     pub fn liberate_late_bound_regions<T>(self,\n-        all_outlive_scope: region::CodeExtent,\n+        all_outlive_scope: Option<region::CodeExtent<'tcx>>,\n         value: &Binder<T>)\n         -> T\n         where T : TypeFoldable<'tcx>\n@@ -435,7 +435,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n     fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>, fld_r: &'a mut F)\n               -> RegionReplacer<'a, 'gcx, 'tcx>\n-        where F : FnMut(ty::BoundRegion) -> &'tcx ty::Region\n+        where F : FnMut(ty::BoundRegion) -> ty::Region<'tcx>\n     {\n         RegionReplacer {\n             tcx: tcx,\n@@ -464,7 +464,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n         t.super_fold_with(self)\n     }\n \n-    fn fold_region(&mut self, r:&'tcx  ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n                 let fld_r = &mut self.fld_r;\n@@ -527,7 +527,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 u.super_fold_with(self)\n             }\n \n-            fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+            fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n                 // because late-bound regions affect subtyping, we can't\n                 // erase the bound/free distinction, but we can replace\n                 // all free regions with 'erased.\n@@ -554,7 +554,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n // regions. See comment on `shift_regions_through_binders` method in\n // `subst.rs` for more details.\n \n-pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n+pub fn shift_region<'tcx>(region: ty::RegionKind<'tcx>, amount: u32) -> ty::RegionKind<'tcx> {\n     match region {\n         ty::ReLateBound(debruijn, br) => {\n             ty::ReLateBound(debruijn.shifted(amount), br)\n@@ -567,9 +567,9 @@ pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n \n pub fn shift_region_ref<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    region: &'tcx ty::Region,\n+    region: ty::Region<'tcx>,\n     amount: u32)\n-    -> &'tcx ty::Region\n+    -> ty::Region<'tcx>\n {\n     match region {\n         &ty::ReLateBound(debruijn, br) if amount > 0 => {\n@@ -582,7 +582,8 @@ pub fn shift_region_ref<'a, 'gcx, 'tcx>(\n }\n \n pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                        amount: u32, value: &T) -> T\n+                                        amount: u32,\n+                                        value: &T) -> T\n     where T: TypeFoldable<'tcx>\n {\n     debug!(\"shift_regions(value={:?}, amount={})\",\n@@ -631,7 +632,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingRegionsVisitor {\n         t.region_depth > self.depth\n     }\n \n-    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         r.escapes_depth(self.depth)\n     }\n }\n@@ -647,7 +648,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         flags.intersects(self.flags)\n     }\n \n-    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         let flags = r.type_flags();\n         debug!(\"HasTypeFlagsVisitor: r={:?} r.flags={:?} self.flags={:?}\", r, flags, self.flags);\n         flags.intersects(self.flags)\n@@ -693,7 +694,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         match *r {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n                 self.regions.insert(br);"}, {"sha": "480b8967a79e9e907ac44964f5cfbfbdc01933b2", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -1268,9 +1268,8 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     let kind = if def.is_enum() || def.variants[0].fields.len() == 0{\n                         StructKind::AlwaysSizedUnivariant\n                     } else {\n-                        use middle::region::ROOT_CODE_EXTENT;\n                         let param_env = tcx.construct_parameter_environment(DUMMY_SP,\n-                          def.did, ROOT_CODE_EXTENT);\n+                          def.did, None);\n                         let fields = &def.variants[0].fields;\n                         let last_field = &fields[fields.len()-1];\n                         let always_sized = last_field.ty(tcx, param_env.free_substs)"}, {"sha": "ef5dfab779ccfa91d3a33f02b2eb007807a697c8", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -14,6 +14,7 @@ use hir::def::Def;\n use hir;\n use middle::const_val;\n use middle::privacy::AccessLevels;\n+use middle::region::RegionMaps;\n use mir;\n use session::CompileResult;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n@@ -592,6 +593,11 @@ define_maps! { <'tcx>\n \n     [] reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n+    /// Per-function `RegionMaps`. The `DefId` should be the owner-def-id for the fn body;\n+    /// in the case of closures or \"inline\" expressions, this will be redirected to the enclosing\n+    /// fn item.\n+    [] region_maps: RegionMaps(DefId) -> Rc<RegionMaps<'tcx>>,\n+\n     [] mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>,\n \n     [] def_symbol_name: SymbolName(DefId) -> ty::SymbolName,"}, {"sha": "c07f41fb223130ded97c6f963d2556e070c6548e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -23,7 +23,7 @@ use ich::StableHashingContext;\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n-use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n+use middle::region::CodeExtent;\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n use mir::Mir;\n use traits;\n@@ -46,7 +46,7 @@ use std::rc::Rc;\n use std::slice;\n use std::vec::IntoIter;\n use std::mem;\n-use syntax::ast::{self, Name, NodeId};\n+use syntax::ast::{self, DUMMY_NODE_ID, Name, NodeId};\n use syntax::attr;\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n@@ -67,11 +67,12 @@ pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n+pub use self::sty::RegionKind;\n pub use self::sty::Issue32330;\n pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n-pub use self::sty::Region::*;\n+pub use self::sty::RegionKind::*;\n pub use self::sty::TypeVariants::*;\n \n pub use self::context::{TyCtxt, GlobalArenas, tls};\n@@ -601,7 +602,7 @@ pub struct UpvarBorrow<'tcx> {\n     pub kind: BorrowKind,\n \n     /// Region of the resulting reference.\n-    pub region: &'tcx ty::Region,\n+    pub region: ty::Region<'tcx>,\n }\n \n pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n@@ -934,9 +935,9 @@ pub type PolyEquatePredicate<'tcx> = ty::Binder<EquatePredicate<'tcx>>;\n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n-pub type PolyRegionOutlivesPredicate<'tcx> = PolyOutlivesPredicate<&'tcx ty::Region,\n-                                                                   &'tcx ty::Region>;\n-pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, &'tcx ty::Region>;\n+pub type PolyRegionOutlivesPredicate<'tcx> = PolyOutlivesPredicate<ty::Region<'tcx>,\n+                                                                   ty::Region<'tcx>>;\n+pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct SubtypePredicate<'tcx> {\n@@ -1164,22 +1165,24 @@ pub struct ParameterEnvironment<'tcx> {\n     /// Each type parameter has an implicit region bound that\n     /// indicates it must outlive at least the function body (the user\n     /// may specify stronger requirements). This field indicates the\n-    /// region of the callee.\n-    pub implicit_region_bound: &'tcx ty::Region,\n+    /// region of the callee. If it is `None`, then the parameter\n+    /// environment is for an item or something where the \"callee\" is\n+    /// not clear.\n+    pub implicit_region_bound: Option<ty::Region<'tcx>>,\n \n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n     /// into Obligations, and elaborated and normalized.\n     pub caller_bounds: Vec<ty::Predicate<'tcx>>,\n \n-    /// Scope that is attached to free regions for this scope. This\n-    /// is usually the id of the fn body, but for more abstract scopes\n-    /// like structs we often use the node-id of the struct.\n+    /// Scope that is attached to free regions for this scope. This is\n+    /// usually the id of the fn body, but for more abstract scopes\n+    /// like structs we use None or the item extent.\n     ///\n     /// FIXME(#3696). It would be nice to refactor so that free\n     /// regions don't have this implicit scope and instead introduce\n     /// relationships in the environment.\n-    pub free_id_outlive: CodeExtent,\n+    pub free_id_outlive: Option<CodeExtent<'tcx>>,\n \n     /// A cache for `moves_by_default`.\n     pub is_copy_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n@@ -1220,13 +1223,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         let impl_def_id = tcx.hir.local_def_id(impl_id);\n                         tcx.construct_parameter_environment(impl_item.span,\n                                                             impl_def_id,\n-                                                            tcx.region_maps.item_extent(id))\n+                                                            Some(tcx.item_extent(id)))\n                     }\n                     hir::ImplItemKind::Method(_, ref body) => {\n                         tcx.construct_parameter_environment(\n                             impl_item.span,\n                             tcx.hir.local_def_id(id),\n-                            tcx.region_maps.call_site_extent(id, body.node_id))\n+                            Some(tcx.call_site_extent(id, body.node_id)))\n                     }\n                 }\n             }\n@@ -1239,23 +1242,23 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         let trait_def_id = tcx.hir.local_def_id(trait_id);\n                         tcx.construct_parameter_environment(trait_item.span,\n                                                             trait_def_id,\n-                                                            tcx.region_maps.item_extent(id))\n+                                                            Some(tcx.item_extent(id)))\n                     }\n                     hir::TraitItemKind::Method(_, ref body) => {\n                         // Use call-site for extent (unless this is a\n                         // trait method with no default; then fallback\n                         // to the method id).\n                         let extent = if let hir::TraitMethod::Provided(body_id) = *body {\n                             // default impl: use call_site extent as free_id_outlive bound.\n-                            tcx.region_maps.call_site_extent(id, body_id.node_id)\n+                            tcx.call_site_extent(id, body_id.node_id)\n                         } else {\n                             // no default impl: use item extent as free_id_outlive bound.\n-                            tcx.region_maps.item_extent(id)\n+                            tcx.item_extent(id)\n                         };\n                         tcx.construct_parameter_environment(\n                             trait_item.span,\n                             tcx.hir.local_def_id(id),\n-                            extent)\n+                            Some(extent))\n                     }\n                 }\n             }\n@@ -1268,7 +1271,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         tcx.construct_parameter_environment(\n                             item.span,\n                             fn_def_id,\n-                            tcx.region_maps.call_site_extent(id, body_id.node_id))\n+                            Some(tcx.call_site_extent(id, body_id.node_id)))\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n@@ -1280,13 +1283,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         let def_id = tcx.hir.local_def_id(id);\n                         tcx.construct_parameter_environment(item.span,\n                                                             def_id,\n-                                                            tcx.region_maps.item_extent(id))\n+                                                            Some(tcx.item_extent(id)))\n                     }\n                     hir::ItemTrait(..) => {\n                         let def_id = tcx.hir.local_def_id(id);\n                         tcx.construct_parameter_environment(item.span,\n                                                             def_id,\n-                                                            tcx.region_maps.item_extent(id))\n+                                                            Some(tcx.item_extent(id)))\n                     }\n                     _ => {\n                         span_bug!(item.span,\n@@ -1304,7 +1307,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     tcx.construct_parameter_environment(\n                         expr.span,\n                         base_def_id,\n-                        tcx.region_maps.call_site_extent(id, body.node_id))\n+                        Some(tcx.call_site_extent(id, body.node_id)))\n                 } else {\n                     tcx.empty_parameter_environment()\n                 }\n@@ -1313,14 +1316,14 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                 let def_id = tcx.hir.local_def_id(id);\n                 tcx.construct_parameter_environment(item.span,\n                                                     def_id,\n-                                                    ROOT_CODE_EXTENT)\n+                                                    None)\n             }\n             Some(hir_map::NodeStructCtor(..)) |\n             Some(hir_map::NodeVariant(..)) => {\n                 let def_id = tcx.hir.local_def_id(id);\n                 tcx.construct_parameter_environment(tcx.hir.span(id),\n                                                     def_id,\n-                                                    ROOT_CODE_EXTENT)\n+                                                    None)\n             }\n             it => {\n                 bug!(\"ParameterEnvironment::from_item(): \\\n@@ -2439,10 +2442,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         ty::ParameterEnvironment {\n             free_substs: self.intern_substs(&[]),\n             caller_bounds: Vec::new(),\n-            implicit_region_bound: self.types.re_empty,\n-            // for an empty parameter environment, there ARE no free\n-            // regions, so it shouldn't matter what we use for the free id\n-            free_id_outlive: ROOT_CODE_EXTENT,\n+            implicit_region_bound: None,\n+            free_id_outlive: None,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n             is_freeze_cache: RefCell::new(FxHashMap()),\n@@ -2454,8 +2455,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// In general, this means converting from bound parameters to\n     /// free parameters. Since we currently represent bound/free type\n     /// parameters in the same way, this only has an effect on regions.\n-    pub fn construct_free_substs(self, def_id: DefId,\n-                                 free_id_outlive: CodeExtent)\n+    pub fn construct_free_substs(self,\n+                                 def_id: DefId,\n+                                 free_id_outlive: Option<CodeExtent<'gcx>>)\n                                  -> &'gcx Substs<'gcx> {\n \n         let substs = Substs::for_item(self.global_tcx(), def_id, |def, _| {\n@@ -2474,12 +2476,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// See `ParameterEnvironment` struct def'n for details.\n-    /// If you were using `free_id: NodeId`, you might try `self.region_maps.item_extent(free_id)`\n+    /// If you were using `free_id: NodeId`, you might try `self.region_maps().item_extent(free_id)`\n     /// for the `free_id_outlive` parameter. (But note that this is not always quite right.)\n     pub fn construct_parameter_environment(self,\n                                            span: Span,\n                                            def_id: DefId,\n-                                           free_id_outlive: CodeExtent)\n+                                           free_id_outlive: Option<CodeExtent<'gcx>>)\n                                            -> ParameterEnvironment<'gcx>\n     {\n         //\n@@ -2513,20 +2515,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let unnormalized_env = ty::ParameterEnvironment {\n             free_substs: free_substs,\n-            implicit_region_bound: tcx.mk_region(ty::ReScope(free_id_outlive)),\n+            implicit_region_bound: free_id_outlive.map(|f| tcx.mk_region(ty::ReScope(f))),\n             caller_bounds: predicates,\n             free_id_outlive: free_id_outlive,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n             is_freeze_cache: RefCell::new(FxHashMap()),\n         };\n \n-        let cause = traits::ObligationCause::misc(span, free_id_outlive.node_id(&self.region_maps));\n-        traits::normalize_param_env_or_error(tcx, unnormalized_env, cause)\n+        let body_id = free_id_outlive.map(|f| f.node_id())\n+                                     .unwrap_or(DUMMY_NODE_ID);\n+        let cause = traits::ObligationCause::misc(span, body_id);\n+        traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n     }\n \n-    pub fn node_scope_region(self, id: NodeId) -> &'tcx Region {\n-        self.mk_region(ty::ReScope(self.region_maps.node_extent(id)))\n+    pub fn node_scope_region(self, id: NodeId) -> Region<'tcx> {\n+        self.mk_region(ty::ReScope(self.node_extent(id)))\n     }\n \n     pub fn visit_all_item_likes_in_krate<V,F>(self,"}, {"sha": "a544b2dd3991bf1e95a6faa13ab24281f09024bb", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -16,7 +16,7 @@ use ty::{self, Ty, TyCtxt, TypeFoldable};\n \n #[derive(Debug)]\n pub enum Component<'tcx> {\n-    Region(&'tcx ty::Region),\n+    Region(ty::Region<'tcx>),\n     Param(ty::ParamTy),\n     UnresolvedInferenceVariable(ty::InferTy),\n \n@@ -202,7 +202,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<&'tcx ty::Region>) {\n+fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<ty::Region<'tcx>>) {\n     for r in regions {\n         if !r.is_bound() {\n             out.push(Component::Region(r));"}, {"sha": "ac434c01c6a88ee41f054786f7468a12eb8269af", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -67,8 +67,8 @@ pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>)\n            -> RelateResult<'tcx, Ty<'tcx>>;\n \n-    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n-               -> RelateResult<'tcx, &'tcx ty::Region>;\n+    fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>>;\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n@@ -529,11 +529,11 @@ impl<'tcx> Relate<'tcx> for &'tcx Substs<'tcx> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for &'tcx ty::Region {\n+impl<'tcx> Relate<'tcx> for ty::Region<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &&'tcx ty::Region,\n-                           b: &&'tcx ty::Region)\n-                           -> RelateResult<'tcx, &'tcx ty::Region>\n+                           a: &ty::Region<'tcx>,\n+                           b: &ty::Region<'tcx>)\n+                           -> RelateResult<'tcx, ty::Region<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.regions(*a, *b)"}, {"sha": "53d516e581b2a153b05b94e0fb6078c774fc2eb6", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -624,7 +624,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Region {\n+impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n         *self\n     }"}, {"sha": "630e4a239cc65d953d0395b0421567094196f758", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -43,8 +43,12 @@ pub struct TypeAndMut<'tcx> {\n          RustcEncodable, RustcDecodable, Copy)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n-pub struct FreeRegion {\n-    pub scope: region::CodeExtent,\n+///\n+/// If `fr.scope` is None, then this is in some context (e.g., an\n+/// impl) where lifetimes are more abstract and the notion of the\n+/// caller/callee stack frames are not applicable.\n+pub struct FreeRegion<'tcx> {\n+    pub scope: Option<region::CodeExtent<'tcx>>,\n     pub bound_region: BoundRegion,\n }\n \n@@ -133,7 +137,7 @@ pub enum TypeVariants<'tcx> {\n \n     /// A reference; a pointer with an associated lifetime. Written as\n     /// `&'a mut T` or `&'a T`.\n-    TyRef(&'tcx Region, TypeAndMut<'tcx>),\n+    TyRef(Region<'tcx>, TypeAndMut<'tcx>),\n \n     /// The anonymous type of a function declaration/definition. Each\n     /// function has a unique type.\n@@ -145,7 +149,7 @@ pub enum TypeVariants<'tcx> {\n     TyFnPtr(PolyFnSig<'tcx>),\n \n     /// A trait, defined with `trait`.\n-    TyDynamic(Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>, &'tcx ty::Region),\n+    TyDynamic(Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n@@ -684,6 +688,8 @@ pub struct DebruijnIndex {\n     pub depth: u32,\n }\n \n+pub type Region<'tcx> = &'tcx RegionKind<'tcx>;\n+\n /// Representation of regions.\n ///\n /// Unlike types, most region variants are \"fictitious\", not concrete,\n@@ -741,7 +747,7 @@ pub struct DebruijnIndex {\n /// [1] http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n /// [2] http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n #[derive(Clone, PartialEq, Eq, Hash, Copy, RustcEncodable, RustcDecodable)]\n-pub enum Region {\n+pub enum RegionKind<'tcx> {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n     // parameters are substituted.\n@@ -754,12 +760,12 @@ pub enum Region {\n     /// When checking a function body, the types of all arguments and so forth\n     /// that refer to bound region parameters are modified to refer to free\n     /// region parameters.\n-    ReFree(FreeRegion),\n+    ReFree(FreeRegion<'tcx>),\n \n     /// A concrete region naming some statically determined extent\n     /// (e.g. an expression or sequence of statements) within the\n     /// current function.\n-    ReScope(region::CodeExtent),\n+    ReScope(region::CodeExtent<'tcx>),\n \n     /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n     ReStatic,\n@@ -784,7 +790,7 @@ pub enum Region {\n     ReErased,\n }\n \n-impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Region {}\n+impl<'tcx> serialize::UseSpecializedDecodable for Region<'tcx> {}\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n@@ -903,7 +909,7 @@ impl DebruijnIndex {\n }\n \n // Region utilities\n-impl Region {\n+impl<'tcx> RegionKind<'tcx> {\n     pub fn is_bound(&self) -> bool {\n         match *self {\n             ty::ReEarlyBound(..) => true,\n@@ -927,7 +933,7 @@ impl Region {\n     }\n \n     /// Returns the depth of `self` from the (1-based) binding level `depth`\n-    pub fn from_depth(&self, depth: u32) -> Region {\n+    pub fn from_depth(&self, depth: u32) -> RegionKind<'tcx> {\n         match *self {\n             ty::ReLateBound(debruijn, r) => ty::ReLateBound(DebruijnIndex {\n                 depth: debruijn.depth - (depth - 1)\n@@ -1346,7 +1352,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Returns the regions directly referenced from this type (but\n     /// not types reachable from this type via `walk_tys`). This\n     /// ignores late-bound regions binders.\n-    pub fn regions(&self) -> Vec<&'tcx ty::Region> {\n+    pub fn regions(&self) -> Vec<ty::Region<'tcx>> {\n         match self.sty {\n             TyRef(region, _) => {\n                 vec![region]"}, {"sha": "c591845dd63b17fdd1443c1880d9fc1bd461fd00", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -11,7 +11,7 @@\n // Type substitutions.\n \n use hir::def_id::DefId;\n-use ty::{self, Slice, Ty, TyCtxt};\n+use ty::{self, Slice, Region, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n@@ -32,7 +32,7 @@ use std::mem;\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Kind<'tcx> {\n     ptr: NonZero<usize>,\n-    marker: PhantomData<(Ty<'tcx>, &'tcx ty::Region)>\n+    marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>)>\n }\n \n const TAG_MASK: usize = 0b11;\n@@ -54,8 +54,8 @@ impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n     }\n }\n \n-impl<'tcx> From<&'tcx ty::Region> for Kind<'tcx> {\n-    fn from(r: &'tcx ty::Region) -> Kind<'tcx> {\n+impl<'tcx> From<ty::Region<'tcx>> for Kind<'tcx> {\n+    fn from(r: ty::Region<'tcx>) -> Kind<'tcx> {\n         // Ensure we can use the tag bits.\n         assert_eq!(mem::align_of_val(r) & TAG_MASK, 0);\n \n@@ -88,7 +88,7 @@ impl<'tcx> Kind<'tcx> {\n     }\n \n     #[inline]\n-    pub fn as_region(self) -> Option<&'tcx ty::Region> {\n+    pub fn as_region(self) -> Option<ty::Region<'tcx>> {\n         unsafe {\n             self.downcast(REGION_TAG)\n         }\n@@ -153,7 +153,7 @@ impl<'tcx> Decodable for Kind<'tcx> {\n             d.read_enum_variant(&[\"Ty\", \"Region\"], |d, tag| {\n                 match tag {\n                     TYPE_TAG => Ty::decode(d).map(Kind::from),\n-                    REGION_TAG => <&ty::Region>::decode(d).map(Kind::from),\n+                    REGION_TAG => Region::decode(d).map(Kind::from),\n                     _ => Err(d.error(\"invalid Kind tag\"))\n                 }\n             })\n@@ -183,7 +183,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                             mut mk_region: FR,\n                             mut mk_type: FT)\n                             -> &'tcx Substs<'tcx>\n-    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n           FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n         let defs = tcx.generics_of(def_id);\n         let mut substs = Vec::with_capacity(defs.count());\n@@ -197,7 +197,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                              mut mk_region: FR,\n                              mut mk_type: FT)\n                              -> &'tcx Substs<'tcx>\n-    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n           FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx>\n     {\n         let defs = tcx.generics_of(def_id);\n@@ -212,7 +212,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                          defs: &ty::Generics,\n                          mk_region: &mut FR,\n                          mk_type: &mut FT)\n-    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n           FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n \n         if let Some(def_id) = defs.parent {\n@@ -226,7 +226,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                            defs: &ty::Generics,\n                            mk_region: &mut FR,\n                            mk_type: &mut FT)\n-    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n           FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n         // Handle Self first, before all regions.\n         let mut types = defs.types.iter();\n@@ -260,7 +260,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn regions(&'a self) -> impl DoubleEndedIterator<Item=&'tcx ty::Region> + 'a {\n+    pub fn regions(&'a self) -> impl DoubleEndedIterator<Item=ty::Region<'tcx>> + 'a {\n         self.iter().filter_map(|k| k.as_region())\n     }\n \n@@ -272,7 +272,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn region_at(&self, i: usize) -> &'tcx ty::Region {\n+    pub fn region_at(&self, i: usize) -> ty::Region<'tcx> {\n         self[i].as_region().unwrap_or_else(|| {\n             bug!(\"expected region for param #{} in {:?}\", i, self);\n         })\n@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn region_for_def(&self, def: &ty::RegionParameterDef) -> &'tcx ty::Region {\n+    pub fn region_for_def(&self, def: &ty::RegionParameterDef) -> ty::Region<'tcx> {\n         self.region_at(def.index as usize)\n     }\n \n@@ -396,7 +396,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         // Note: This routine only handles regions that are bound on\n         // type declarations and other outer declarations, not those\n         // bound in *fn types*. Region substitution of the bound\n@@ -538,7 +538,7 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    fn shift_region_through_binders(&self, region: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn shift_region_through_binders(&self, region: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         if self.region_binders_passed == 0 || !region.has_escaping_regions() {\n             return region;\n         }"}, {"sha": "befc4e6c5fdd1400152e911042e130f2ba021607", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -316,7 +316,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn required_region_bounds(self,\n                                   erased_self_ty: Ty<'tcx>,\n                                   predicates: Vec<ty::Predicate<'tcx>>)\n-                                  -> Vec<&'tcx ty::Region>    {\n+                                  -> Vec<ty::Region<'tcx>>    {\n         debug!(\"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n                erased_self_ty,\n                predicates);\n@@ -457,7 +457,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let result = item_substs.iter().zip(impl_substs.iter())\n             .filter(|&(_, &k)| {\n-                if let Some(&ty::Region::ReEarlyBound(ref ebr)) = k.as_region() {\n+                if let Some(&ty::RegionKind::ReEarlyBound(ref ebr)) = k.as_region() {\n                     !impl_generics.region_param(ebr).pure_wrt_drop\n                 } else if let Some(&ty::TyS {\n                     sty: ty::TypeVariants::TyParam(ref pt), ..\n@@ -673,7 +673,7 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n         ty.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         self.hash_discriminant_u8(r);\n         match *r {\n             ty::ReErased |"}, {"sha": "d0cbbaf2c10bf391b803f0a7ff6b4cbdd74c6c54", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -116,9 +116,9 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n /// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n #[derive(Debug)]\n pub enum ImpliedBound<'tcx> {\n-    RegionSubRegion(&'tcx ty::Region, &'tcx ty::Region),\n-    RegionSubParam(&'tcx ty::Region, ty::ParamTy),\n-    RegionSubProjection(&'tcx ty::Region, ty::ProjectionTy<'tcx>),\n+    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n+    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n+    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n }\n \n /// Compute the implied bounds that a callee/impl can assume based on\n@@ -198,7 +198,7 @@ pub fn implied_bounds<'a, 'gcx, 'tcx>(\n /// this down to determine what relationships would have to hold for\n /// `T: 'a` to hold. We get to assume that the caller has validated\n /// those relationships.\n-fn implied_bounds_from_components<'tcx>(sub_region: &'tcx ty::Region,\n+fn implied_bounds_from_components<'tcx>(sub_region: ty::Region<'tcx>,\n                                         sup_components: Vec<Component<'tcx>>)\n                                         -> Vec<ImpliedBound<'tcx>>\n {\n@@ -455,7 +455,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n     fn from_object_ty(&mut self, ty: Ty<'tcx>,\n                       data: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>,\n-                      region: &'tcx ty::Region) {\n+                      region: ty::Region<'tcx>) {\n         // Imagine a type like this:\n         //\n         //     trait Foo { }\n@@ -512,7 +512,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n-    -> Vec<&'tcx ty::Region>\n+    -> Vec<ty::Region<'tcx>>\n {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically"}, {"sha": "d773bb2da0898b6b30d0cdd07698bfa8395a90b1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -177,12 +177,12 @@ pub fn parameterized(f: &mut fmt::Formatter,\n     let print_regions = |f: &mut fmt::Formatter, start: &str, skip, count| {\n         // Don't print any regions if they're all erased.\n         let regions = || substs.regions().skip(skip).take(count);\n-        if regions().all(|r: &ty::Region| *r == ty::ReErased) {\n+        if regions().all(|r: ty::Region| *r == ty::ReErased) {\n             return Ok(());\n         }\n \n         for region in regions() {\n-            let region: &ty::Region = region;\n+            let region: ty::Region = region;\n             start_or_continue(f, start, \", \")?;\n             if verbose {\n                 write!(f, \"{:?}\", region)?;\n@@ -458,7 +458,7 @@ impl fmt::Debug for ty::BoundRegion {\n     }\n }\n \n-impl fmt::Debug for ty::Region {\n+impl<'tcx> fmt::Debug for ty::RegionKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::ReEarlyBound(ref data) => {\n@@ -516,7 +516,7 @@ impl<'tcx> fmt::Debug for ty::ParameterEnvironment<'tcx> {\n     }\n }\n \n-impl fmt::Display for ty::Region {\n+impl<'tcx> fmt::Display for ty::RegionKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {\n             return write!(f, \"{:?}\", *self);\n@@ -544,7 +544,7 @@ impl fmt::Display for ty::Region {\n     }\n }\n \n-impl fmt::Debug for ty::FreeRegion {\n+impl<'tcx> fmt::Debug for ty::FreeRegion<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ReFree({:?}, {:?})\",\n                self.scope, self.bound_region)\n@@ -689,14 +689,14 @@ impl<'tcx> fmt::Display for ty::Binder<ty::ProjectionPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, &'tcx ty::Region>> {\n+impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<&'tcx ty::Region,\n-                                                             &'tcx ty::Region>> {\n+impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>,\n+                                                             ty::Region<'tcx>>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }"}, {"sha": "1c5a6c3985cfc43f92b1b06b9f33c0b6813317b2", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              loan_region: &'tcx ty::Region,\n+              loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {\n@@ -199,7 +199,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         all_loans: all_loans,\n         param_env: &infcx.parameter_environment\n     };\n-    euv::ExprUseVisitor::new(&mut clcx, &infcx).consume_body(body);\n+    euv::ExprUseVisitor::new(&mut clcx, &bccx.region_maps, &infcx).consume_body(body);\n }\n \n #[derive(PartialEq)]\n@@ -232,15 +232,14 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub fn each_in_scope_loan<F>(&self, scope: region::CodeExtent, mut op: F) -> bool where\n+    pub fn each_in_scope_loan<F>(&self, scope: region::CodeExtent<'tcx>, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,\n     {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n \n-        let tcx = self.tcx();\n-        self.each_issued_loan(scope.node_id(&tcx.region_maps), |loan| {\n-            if tcx.region_maps.is_subscope_of(scope, loan.kill_scope) {\n+        self.each_issued_loan(scope.node_id(), |loan| {\n+            if self.bccx.region_maps.is_subscope_of(scope, loan.kill_scope) {\n                 op(loan)\n             } else {\n                 true\n@@ -249,7 +248,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn each_in_scope_loan_affecting_path<F>(&self,\n-                                            scope: region::CodeExtent,\n+                                            scope: region::CodeExtent<'tcx>,\n                                             loan_path: &LoanPath<'tcx>,\n                                             mut op: F)\n                                             -> bool where\n@@ -379,8 +378,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                new_loan);\n \n         // Should only be called for loans that are in scope at the same time.\n-        assert!(self.tcx().region_maps.scopes_intersect(old_loan.kill_scope,\n-                                                        new_loan.kill_scope));\n+        assert!(self.bccx.region_maps.scopes_intersect(old_loan.kill_scope,\n+                                                       new_loan.kill_scope));\n \n         self.report_error_if_loan_conflicts_with_restriction(\n             old_loan, new_loan, old_loan, new_loan) &&\n@@ -460,8 +459,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             // 3. Where does old loan expire.\n \n             let previous_end_span =\n-                self.tcx().hir.span(old_loan.kill_scope.node_id(&self.tcx().region_maps))\n-                              .end_point();\n+                self.tcx().hir.span(old_loan.kill_scope.node_id()).end_point();\n \n             let mut err = match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n@@ -710,7 +708,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         let mut ret = UseOk;\n \n         self.each_in_scope_loan_affecting_path(\n-            self.tcx().region_maps.node_extent(expr_id), use_path, |loan| {\n+            self.tcx().node_extent(expr_id), use_path, |loan| {\n             if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n                 ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n                 false\n@@ -824,7 +822,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         // Check that we don't invalidate any outstanding loans\n         if let Some(loan_path) = opt_loan_path(&assignee_cmt) {\n-            let scope = self.tcx().region_maps.node_extent(assignment_id);\n+            let scope = self.tcx().node_extent(assignment_id);\n             self.each_in_scope_loan_affecting_path(scope, &loan_path, |loan| {\n                 self.report_illegal_mutation(assignment_span, &loan_path, loan);\n                 false"}, {"sha": "12854d3c9792251d54f4a3ff040c2a64c827285b", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -24,11 +24,11 @@ use syntax_pos::Span;\n type R = Result<(),()>;\n \n pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                    item_scope: region::CodeExtent,\n+                                    item_scope: region::CodeExtent<'tcx>,\n                                     span: Span,\n                                     cause: euv::LoanCause,\n                                     cmt: mc::cmt<'tcx>,\n-                                    loan_region: &'tcx ty::Region,\n+                                    loan_region: ty::Region<'tcx>,\n                                     _: ty::BorrowKind)\n                                     -> Result<(),()> {\n     //! Reports error if `loan_region` is larger than S\n@@ -52,11 +52,11 @@ struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n \n     // the scope of the function body for the enclosing item\n-    item_scope: region::CodeExtent,\n+    item_scope: region::CodeExtent<'tcx>,\n \n     span: Span,\n     cause: euv::LoanCause,\n-    loan_region: &'tcx ty::Region,\n+    loan_region: ty::Region<'tcx>,\n     cmt_original: mc::cmt<'tcx>\n }\n \n@@ -92,7 +92,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn check_scope(&self, max_scope: &'tcx ty::Region) -> R {\n+    fn check_scope(&self, max_scope: ty::Region<'tcx>) -> R {\n         //! Reports an error if `loan_region` is larger than `max_scope`\n \n         if !self.bccx.is_subregion_of(self.loan_region, max_scope) {\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn scope(&self, cmt: &mc::cmt<'tcx>) -> &'tcx ty::Region {\n+    fn scope(&self, cmt: &mc::cmt<'tcx>) -> ty::Region<'tcx> {\n         //! Returns the maximal region scope for the which the\n         //! lvalue `cmt` is guaranteed to be valid without any\n         //! rooting etc, and presuming `cmt` is not mutated.\n@@ -116,7 +116,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             }\n             Categorization::Local(local_id) => {\n                 self.bccx.tcx.mk_region(ty::ReScope(\n-                    self.bccx.tcx.region_maps.var_scope(local_id)))\n+                    self.bccx.region_maps.var_scope(local_id)))\n             }\n             Categorization::StaticItem |\n             Categorization::Deref(.., mc::UnsafePtr(..)) => {"}, {"sha": "8c1bcdc1fe2b0f4cdefcfcdcedcf4ae2bc7da21b", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -45,13 +45,13 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         bccx: bccx,\n         infcx: &infcx,\n         all_loans: Vec::new(),\n-        item_ub: bccx.tcx.region_maps.node_extent(body.node_id),\n+        item_ub: bccx.tcx.node_extent(body.node_id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n     let body = glcx.bccx.tcx.hir.body(body);\n-    euv::ExprUseVisitor::new(&mut glcx, &infcx).consume_body(body);\n+    euv::ExprUseVisitor::new(&mut glcx, &bccx.region_maps, &infcx).consume_body(body);\n \n     glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;\n@@ -66,7 +66,7 @@ struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     all_loans: Vec<Loan<'tcx>>,\n     /// `item_ub` is used as an upper-bound on the lifetime whenever we\n     /// ask for the scope of an expression categorized as an upvar.\n-    item_ub: region::CodeExtent,\n+    item_ub: region::CodeExtent<'tcx>,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n@@ -127,7 +127,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              loan_region: &'tcx ty::Region,\n+              loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {\n@@ -299,7 +299,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                        borrow_span: Span,\n                        cmt: mc::cmt<'tcx>,\n                        req_kind: ty::BorrowKind,\n-                       loan_region: &'tcx ty::Region,\n+                       loan_region: ty::Region<'tcx>,\n                        cause: euv::LoanCause) {\n         debug!(\"guarantee_valid(borrow_id={}, cmt={:?}, \\\n                 req_mutbl={:?}, loan_region={:?})\",\n@@ -353,7 +353,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 let loan_scope = match *loan_region {\n                     ty::ReScope(scope) => scope,\n \n-                    ty::ReFree(ref fr) => fr.scope,\n+                    ty::ReFree(ref fr) => fr.scope.unwrap_or(self.item_ub),\n \n                     ty::ReStatic => self.item_ub,\n \n@@ -371,7 +371,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 };\n                 debug!(\"loan_scope = {:?}\", loan_scope);\n \n-                let borrow_scope = self.tcx().region_maps.node_extent(borrow_id);\n+                let borrow_scope = self.tcx().node_extent(borrow_id);\n                 let gen_scope = self.compute_gen_scope(borrow_scope, loan_scope);\n                 debug!(\"gen_scope = {:?}\", gen_scope);\n \n@@ -450,23 +450,23 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn compute_gen_scope(&self,\n-                             borrow_scope: region::CodeExtent,\n-                             loan_scope: region::CodeExtent)\n-                             -> region::CodeExtent {\n+                             borrow_scope: region::CodeExtent<'tcx>,\n+                             loan_scope: region::CodeExtent<'tcx>)\n+                             -> region::CodeExtent<'tcx> {\n         //! Determine when to introduce the loan. Typically the loan\n         //! is introduced at the point of the borrow, but in some cases,\n         //! notably method arguments, the loan may be introduced only\n         //! later, once it comes into scope.\n \n-        if self.bccx.tcx.region_maps.is_subscope_of(borrow_scope, loan_scope) {\n+        if self.bccx.region_maps.is_subscope_of(borrow_scope, loan_scope) {\n             borrow_scope\n         } else {\n             loan_scope\n         }\n     }\n \n-    pub fn compute_kill_scope(&self, loan_scope: region::CodeExtent, lp: &LoanPath<'tcx>)\n-                              -> region::CodeExtent {\n+    pub fn compute_kill_scope(&self, loan_scope: region::CodeExtent<'tcx>, lp: &LoanPath<'tcx>)\n+                              -> region::CodeExtent<'tcx> {\n         //! Determine when the loan restrictions go out of scope.\n         //! This is either when the lifetime expires or when the\n         //! local variable which roots the loan-path goes out of scope,\n@@ -488,12 +488,11 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         //! with immutable `&` pointers, because borrows of such pointers\n         //! do not require restrictions and hence do not cause a loan.\n \n-        let lexical_scope = lp.kill_scope(self.bccx.tcx);\n-        let rm = &self.bccx.tcx.region_maps;\n-        if rm.is_subscope_of(lexical_scope, loan_scope) {\n+        let lexical_scope = lp.kill_scope(self.bccx);\n+        if self.bccx.region_maps.is_subscope_of(lexical_scope, loan_scope) {\n             lexical_scope\n         } else {\n-            assert!(self.bccx.tcx.region_maps.is_subscope_of(loan_scope, lexical_scope));\n+            assert!(self.bccx.region_maps.is_subscope_of(loan_scope, lexical_scope));\n             loan_scope\n         }\n     }"}, {"sha": "7f90a8b19d4a1250794f360233134db585111fb5", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -31,7 +31,7 @@ pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       span: Span,\n                                       cause: euv::LoanCause,\n                                       cmt: mc::cmt<'tcx>,\n-                                      loan_region: &'tcx ty::Region)\n+                                      loan_region: ty::Region<'tcx>)\n                                       -> RestrictionResult<'tcx> {\n     let ctxt = RestrictionsContext {\n         bccx: bccx,\n@@ -49,7 +49,7 @@ pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n struct RestrictionsContext<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     span: Span,\n-    loan_region: &'tcx ty::Region,\n+    loan_region: ty::Region<'tcx>,\n     cause: euv::LoanCause,\n }\n "}, {"sha": "e5e5045bc29f9a228c8db961f8232100f693f8b8", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -34,7 +34,8 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::mem_categorization::ImmutabilityBlame;\n-use rustc::middle::region;\n+use rustc::middle::region::{self, RegionMaps};\n+use rustc::middle::free_region::RegionRelations;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n \n@@ -88,11 +89,8 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n     let body_id = tcx.hir.body_owned_by(owner_id);\n     let attributes = tcx.get_attrs(owner_def_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n-\n-    let mut bccx = &mut BorrowckCtxt {\n-        tcx: tcx,\n-        tables: tables,\n-    };\n+    let region_maps = tcx.region_maps(owner_def_id);\n+    let mut bccx = &mut BorrowckCtxt { tcx, tables, region_maps, owner_def_id };\n \n     let body = bccx.tcx.hir.body(body_id);\n \n@@ -141,15 +139,15 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                              id_range,\n                              all_loans.len());\n     for (loan_idx, loan) in all_loans.iter().enumerate() {\n-        loan_dfcx.add_gen(loan.gen_scope.node_id(&tcx.region_maps), loan_idx);\n+        loan_dfcx.add_gen(loan.gen_scope.node_id(), loan_idx);\n         loan_dfcx.add_kill(KillFrom::ScopeEnd,\n-                           loan.kill_scope.node_id(&tcx.region_maps), loan_idx);\n+                           loan.kill_scope.node_id(), loan_idx);\n     }\n     loan_dfcx.add_kills_from_flow_exits(cfg);\n     loan_dfcx.propagate(cfg, body);\n \n     let flowed_moves = move_data::FlowedMoveData::new(move_data,\n-                                                      this.tcx,\n+                                                      this,\n                                                       cfg,\n                                                       id_range,\n                                                       body);\n@@ -170,11 +168,8 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     let owner_id = tcx.hir.body_owner(body_id);\n     let owner_def_id = tcx.hir.local_def_id(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n-\n-    let mut bccx = BorrowckCtxt {\n-        tcx: tcx,\n-        tables: tables,\n-    };\n+    let region_maps = tcx.region_maps(owner_def_id);\n+    let mut bccx = BorrowckCtxt { tcx, tables, region_maps, owner_def_id };\n \n     let dataflow_data = build_borrowck_dataflow_data(&mut bccx, cfg, body_id);\n     (bccx, dataflow_data)\n@@ -189,6 +184,10 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     // tables for the current thing we are checking; set to\n     // Some in `borrowck_fn` and cleared later\n     tables: &'a ty::TypeckTables<'tcx>,\n+\n+    region_maps: Rc<RegionMaps<'tcx>>,\n+\n+    owner_def_id: DefId,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -206,13 +205,13 @@ pub struct Loan<'tcx> {\n     /// cases, notably method arguments, the loan may be introduced\n     /// only later, once it comes into scope.  See also\n     /// `GatherLoanCtxt::compute_gen_scope`.\n-    gen_scope: region::CodeExtent,\n+    gen_scope: region::CodeExtent<'tcx>,\n \n     /// kill_scope indicates when the loan goes out of scope.  This is\n     /// either when the lifetime expires or when the local variable\n     /// which roots the loan-path goes out of scope, whichever happens\n     /// faster. See also `GatherLoanCtxt::compute_kill_scope`.\n-    kill_scope: region::CodeExtent,\n+    kill_scope: region::CodeExtent<'tcx>,\n     span: Span,\n     cause: euv::LoanCause,\n }\n@@ -312,15 +311,15 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n }\n \n impl<'a, 'tcx> LoanPath<'tcx> {\n-    pub fn kill_scope(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> region::CodeExtent {\n+    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::CodeExtent<'tcx> {\n         match self.kind {\n-            LpVar(local_id) => tcx.region_maps.var_scope(local_id),\n+            LpVar(local_id) => bccx.region_maps.var_scope(local_id),\n             LpUpvar(upvar_id) => {\n-                let block_id = closure_to_block(upvar_id.closure_expr_id, tcx);\n-                tcx.region_maps.node_extent(block_id)\n+                let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n+                bccx.tcx.node_extent(block_id)\n             }\n             LpDowncast(ref base, _) |\n-            LpExtend(ref base, ..) => base.kill_scope(tcx),\n+            LpExtend(ref base, ..) => base.kill_scope(bccx),\n         }\n     }\n \n@@ -444,8 +443,8 @@ pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n pub enum bckerr_code<'tcx> {\n     err_mutbl,\n     /// superscope, subscope, loan cause\n-    err_out_of_scope(&'tcx ty::Region, &'tcx ty::Region, euv::LoanCause),\n-    err_borrowed_pointer_too_short(&'tcx ty::Region, &'tcx ty::Region), // loan, ptr\n+    err_out_of_scope(ty::Region<'tcx>, ty::Region<'tcx>, euv::LoanCause),\n+    err_borrowed_pointer_too_short(ty::Region<'tcx>, ty::Region<'tcx>), // loan, ptr\n }\n \n // Combination of an error code and the categorization of the expression\n@@ -475,11 +474,15 @@ pub enum MovedValueUseKind {\n \n impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn is_subregion_of(&self,\n-                           r_sub: &'tcx ty::Region,\n-                           r_sup: &'tcx ty::Region)\n+                           r_sub: ty::Region<'tcx>,\n+                           r_sup: ty::Region<'tcx>)\n                            -> bool\n     {\n-        self.tables.free_region_map.is_subregion_of(self.tcx, r_sub, r_sup)\n+        let region_rels = RegionRelations::new(self.tcx,\n+                                               self.owner_def_id,\n+                                               &self.region_maps,\n+                                               &self.tables.free_region_map);\n+        region_rels.is_subregion_of(r_sub, r_sup)\n     }\n \n     pub fn report(&self, err: BckError<'tcx>) {\n@@ -963,10 +966,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             .emit();\n     }\n \n-    fn region_end_span(&self, region: &'tcx ty::Region) -> Option<Span> {\n+    fn region_end_span(&self, region: ty::Region<'tcx>) -> Option<Span> {\n         match *region {\n             ty::ReScope(scope) => {\n-                match scope.span(&self.tcx.region_maps, &self.tcx.hir) {\n+                match scope.span(&self.tcx.hir) {\n                     Some(s) => {\n                         Some(s.end_point())\n                     }\n@@ -1244,10 +1247,10 @@ before rustc 1.16, this temporary lived longer - see issue #39283 \\\n     }\n }\n \n-fn statement_scope_span(tcx: TyCtxt, region: &ty::Region) -> Option<Span> {\n+fn statement_scope_span(tcx: TyCtxt, region: ty::Region) -> Option<Span> {\n     match *region {\n         ty::ReScope(scope) => {\n-            match tcx.hir.find(scope.node_id(&tcx.region_maps)) {\n+            match tcx.hir.find(scope.node_id()) {\n                 Some(hir_map::NodeStmt(stmt)) => Some(stmt.span),\n                 _ => None\n             }"}, {"sha": "3e23086ec7bddc5f03591064f084347fd6df151f", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -523,7 +523,8 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     /// Moves are generated by moves and killed by assignments and\n     /// scoping. Assignments are generated by assignment to variables and\n     /// killed by scoping. See `README.md` for more details.\n-    fn add_gen_kills(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn add_gen_kills(&self,\n+                     bccx: &BorrowckCtxt<'a, 'tcx>,\n                      dfcx_moves: &mut MoveDataFlow,\n                      dfcx_assign: &mut AssignDataFlow) {\n         for (i, the_move) in self.moves.borrow().iter().enumerate() {\n@@ -546,9 +547,9 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         for path in self.paths.borrow().iter() {\n             match path.loan_path.kind {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n-                    let kill_scope = path.loan_path.kill_scope(tcx);\n+                    let kill_scope = path.loan_path.kill_scope(bccx);\n                     let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n-                    self.kill_moves(path, kill_scope.node_id(&tcx.region_maps),\n+                    self.kill_moves(path, kill_scope.node_id(),\n                                     KillFrom::ScopeEnd, dfcx_moves);\n                 }\n                 LpExtend(..) => {}\n@@ -561,9 +562,9 @@ impl<'a, 'tcx> MoveData<'tcx> {\n             let lp = self.path_loan_path(assignment.path);\n             match lp.kind {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n-                    let kill_scope = lp.kill_scope(tcx);\n+                    let kill_scope = lp.kill_scope(bccx);\n                     dfcx_assign.add_kill(KillFrom::ScopeEnd,\n-                                         kill_scope.node_id(&tcx.region_maps),\n+                                         kill_scope.node_id(),\n                                          assignment_index);\n                 }\n                 LpExtend(..) => {\n@@ -652,11 +653,13 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     pub fn new(move_data: MoveData<'tcx>,\n-               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               bccx: &BorrowckCtxt<'a, 'tcx>,\n                cfg: &cfg::CFG,\n                id_range: IdRange,\n                body: &hir::Body)\n                -> FlowedMoveData<'a, 'tcx> {\n+        let tcx = bccx.tcx;\n+\n         let mut dfcx_moves =\n             DataFlowContext::new(tcx,\n                                  \"flowed_move_data_moves\",\n@@ -676,7 +679,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n         move_data.fixup_fragment_sets(tcx);\n \n-        move_data.add_gen_kills(tcx,\n+        move_data.add_gen_kills(bccx,\n                                 &mut dfcx_moves,\n                                 &mut dfcx_assign);\n "}, {"sha": "6ec5f38aa5bb529c94ac7d9edc7ba133e68c3b35", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -18,6 +18,7 @@ use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization::{cmt};\n+use rustc::middle::region::RegionMaps;\n use rustc::session::Session;\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -45,9 +46,13 @@ impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n                 b: hir::BodyId, s: Span, id: ast::NodeId) {\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n \n+        let region_context = self.tcx.hir.local_def_id(id);\n+        let region_maps = self.tcx.region_maps(region_context);\n+\n         MatchVisitor {\n             tcx: self.tcx,\n             tables: self.tcx.body_tables(b),\n+            region_maps: &region_maps,\n             param_env: &ty::ParameterEnvironment::for_item(self.tcx, id)\n         }.visit_body(self.tcx.hir.body(b));\n     }\n@@ -65,7 +70,8 @@ fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> Diagn\n struct MatchVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n-    param_env: &'a ty::ParameterEnvironment<'tcx>\n+    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+    region_maps: &'a RegionMaps<'tcx>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n@@ -517,7 +523,7 @@ fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n         let mut checker = MutationChecker {\n             cx: cx,\n         };\n-        ExprUseVisitor::new(&mut checker, &infcx).walk_expr(guard);\n+        ExprUseVisitor::new(&mut checker, cx.region_maps, &infcx).walk_expr(guard);\n     });\n }\n \n@@ -533,7 +539,7 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n               _: ast::NodeId,\n               span: Span,\n               _: cmt,\n-              _: &'tcx ty::Region,\n+              _: ty::Region<'tcx>,\n               kind:ty:: BorrowKind,\n               _: LoanCause) {\n         match kind {"}, {"sha": "e15d63a63c25850bdb1f9881faacd2106abe778d", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -35,7 +35,7 @@ pub enum PatternError<'tcx> {\n #[derive(Copy, Clone, Debug)]\n pub enum BindingMode<'tcx> {\n     ByValue,\n-    ByRef(&'tcx Region, BorrowKind),\n+    ByRef(Region<'tcx>, BorrowKind),\n }\n \n #[derive(Clone, Debug)]\n@@ -811,7 +811,7 @@ macro_rules! CloneImpls {\n }\n \n CloneImpls!{ <'tcx>\n-    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal<'tcx>, Region,\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal<'tcx>, Region<'tcx>,\n     Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n     &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n }"}, {"sha": "0642ddc71622b1abe8cfae41c72a6266b51b3d12", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -24,7 +24,7 @@ use rustc_serialize as serialize;\n ///\n /// (purpose: avoid mixing indexes for different bitvector domains.)\n pub trait Idx: Copy + 'static + Eq + Debug {\n-    fn new(usize) -> Self;\n+    fn new(idx: usize) -> Self;\n     fn index(self) -> usize;\n }\n "}, {"sha": "b0fca5c0ff377f079840781c2d708c06587a98e8", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -80,6 +80,27 @@ impl<T: Debug + PartialEq> TransitiveRelation<T> {\n         }\n     }\n \n+    /// Applies the (partial) function to each edge and returns a new\n+    /// relation.  If `f` returns `None` for any end-point, returns\n+    /// `None`.\n+    pub fn maybe_map<F, U>(&self, mut f: F) -> Option<TransitiveRelation<U>>\n+        where F: FnMut(&T) -> Option<U>,\n+              U: Debug + PartialEq,\n+    {\n+        let mut result = TransitiveRelation::new();\n+        for edge in &self.edges {\n+            let r = f(&self.elements[edge.source.0]).and_then(|source| {\n+                f(&self.elements[edge.target.0]).and_then(|target| {\n+                    Some(result.add(source, target))\n+                })\n+            });\n+            if r.is_none() {\n+                return None;\n+            }\n+        }\n+        Some(result)\n+    }\n+\n     /// Indicate that `a < b` (where `<` is this relation)\n     pub fn add(&mut self, a: T, b: T) {\n         let a = self.add_index(a);"}, {"sha": "aa33d4b55399818240221378260859c068dfdc1f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -874,10 +874,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     }));\n     sess.derive_registrar_fn.set(derive_registrar::find(&hir_map));\n \n-    let region_map = time(time_passes,\n-                          \"region resolution\",\n-                          || middle::region::resolve_crate(sess, &hir_map));\n-\n     time(time_passes,\n          \"loop checking\",\n          || loops::check_crate(sess, &hir_map));\n@@ -898,6 +894,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     ty::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_const_eval::provide(&mut local_providers);\n+    middle::region::provide(&mut local_providers);\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n@@ -914,7 +911,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                              resolutions,\n                              named_region_map,\n                              hir_map,\n-                             region_map,\n                              lang_items,\n                              index,\n                              name,\n@@ -923,6 +919,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n             time(time_passes,\n                  \"compute_incremental_hashes_map\",\n                  || rustc_incremental::compute_incremental_hashes_map(tcx));\n+\n         time(time_passes,\n              \"load_dep_graph\",\n              || rustc_incremental::load_dep_graph(tcx, &incremental_hashes_map));"}, {"sha": "889f4dd4b9aac9d3c526ffff8863a0f84e4b0a30", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -343,7 +343,7 @@ pub trait CompilerCalls<'a> {\n \n     // Create a CompilController struct for controlling the behaviour of\n     // compilation.\n-    fn build_controller(&mut self, &Session, &getopts::Matches) -> CompileController<'a>;\n+    fn build_controller(&mut self, _: &Session, _: &getopts::Matches) -> CompileController<'a>;\n }\n \n // CompilerCalls instance for a regular rustc build."}, {"sha": "ced30fd64085c09d190e8ebd5f96837c60de3157", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -16,7 +16,7 @@ use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n use rustc::middle::lang_items;\n use rustc::middle::free_region::FreeRegionMap;\n-use rustc::middle::region::{self, CodeExtent};\n+use rustc::middle::region::{CodeExtent, RegionMaps};\n use rustc::middle::region::CodeExtentData;\n use rustc::middle::resolve_lifetime;\n use rustc::middle::stability;\n@@ -44,6 +44,7 @@ use rustc::hir;\n \n struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a infer::InferCtxt<'a, 'gcx, 'tcx>,\n+    region_maps: &'a mut RegionMaps<'tcx>,\n }\n \n struct RH<'a> {\n@@ -136,7 +137,6 @@ fn test_env<F>(source_string: &str,\n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(&sess, &hir_map);\n     let named_region_map = resolve_lifetime::krate(&sess, &hir_map);\n-    let region_map = region::resolve_crate(&sess, &hir_map);\n     let index = stability::Index::new(&hir_map);\n     TyCtxt::create_and_enter(&sess,\n                              ty::maps::Providers::default(),\n@@ -146,16 +146,16 @@ fn test_env<F>(source_string: &str,\n                              resolutions,\n                              named_region_map.unwrap(),\n                              hir_map,\n-                             region_map,\n                              lang_items,\n                              index,\n                              \"test_crate\",\n                              |tcx| {\n         tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n-\n-            body(Env { infcx: &infcx });\n+            let mut region_maps = RegionMaps::new();\n+            body(Env { infcx: &infcx, region_maps: &mut region_maps });\n             let free_regions = FreeRegionMap::new();\n-            infcx.resolve_regions_and_report_errors(&free_regions, ast::CRATE_NODE_ID);\n+            let def_id = tcx.hir.local_def_id(ast::CRATE_NODE_ID);\n+            infcx.resolve_regions_and_report_errors(def_id, &region_maps, &free_regions);\n             assert_eq!(tcx.sess.err_count(), expected_err_count);\n         });\n     });\n@@ -166,23 +166,21 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn create_region_hierarchy(&self, rh: &RH, parent: CodeExtent) {\n-        let me = self.infcx.tcx.region_maps.intern_node(rh.id, parent);\n+    pub fn create_region_hierarchy(&mut self, rh: &RH, parent: CodeExtent<'tcx>) {\n+        let me = self.tcx().intern_code_extent(CodeExtentData::Misc(rh.id));\n+        self.region_maps.record_code_extent(me, Some(parent));\n         for child_rh in rh.sub {\n             self.create_region_hierarchy(child_rh, me);\n         }\n     }\n \n-    pub fn create_simple_region_hierarchy(&self) {\n+    pub fn create_simple_region_hierarchy(&mut self) {\n         // creates a region hierarchy where 1 is root, 10 and 11 are\n         // children of 1, etc\n \n         let node = ast::NodeId::from_u32;\n-        let dscope = self.infcx\n-            .tcx\n-            .region_maps\n-            .intern_code_extent(CodeExtentData::DestructionScope(node(1)),\n-                                region::ROOT_CODE_EXTENT);\n+        let dscope = self.tcx().intern_code_extent(CodeExtentData::DestructionScope(node(1)));\n+        self.region_maps.record_code_extent(dscope, None);\n         self.create_region_hierarchy(&RH {\n                                          id: node(1),\n                                          sub: &[RH {\n@@ -293,7 +291,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_param(index, Symbol::intern(&name))\n     }\n \n-    pub fn re_early_bound(&self, index: u32, name: &'static str) -> &'tcx ty::Region {\n+    pub fn re_early_bound(&self, index: u32, name: &'static str) -> ty::Region<'tcx> {\n         let name = Symbol::intern(name);\n         self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             index: index,\n@@ -304,11 +302,11 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     pub fn re_late_bound_with_debruijn(&self,\n                                        id: u32,\n                                        debruijn: ty::DebruijnIndex)\n-                                       -> &'tcx ty::Region {\n+                                       -> ty::Region<'tcx> {\n         self.infcx.tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n     }\n \n-    pub fn t_rptr(&self, r: &'tcx ty::Region) -> Ty<'tcx> {\n+    pub fn t_rptr(&self, r: ty::Region<'tcx>) -> Ty<'tcx> {\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n@@ -326,13 +324,13 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n-        let r = ty::ReScope(self.tcx().region_maps.node_extent(ast::NodeId::from_u32(id)));\n+        let r = ty::ReScope(self.tcx().node_extent(ast::NodeId::from_u32(id)));\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n-    pub fn re_free(&self, nid: ast::NodeId, id: u32) -> &'tcx ty::Region {\n+    pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region<'tcx> {\n         self.infcx.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-            scope: self.tcx().region_maps.item_extent(nid),\n+            scope: Some(self.tcx().node_extent(nid)),\n             bound_region: ty::BrAnon(id),\n         }))\n     }\n@@ -430,7 +428,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n #[test]\n fn contravariant_region_ptr_ok() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr1 = env.t_rptr_scope(1);\n         let t_rptr10 = env.t_rptr_scope(10);\n@@ -442,7 +440,7 @@ fn contravariant_region_ptr_ok() {\n \n #[test]\n fn contravariant_region_ptr_err() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[\"mismatched types\"]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[\"mismatched types\"]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr1 = env.t_rptr_scope(1);\n         let t_rptr10 = env.t_rptr_scope(10);\n@@ -462,7 +460,7 @@ fn sub_free_bound_false() {\n     //!\n     //! does NOT hold.\n \n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr_free1 = env.t_rptr_free(1, 1);\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n@@ -479,7 +477,7 @@ fn sub_bound_free_true() {\n     //!\n     //! DOES hold.\n \n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(1, 1);\n@@ -514,7 +512,7 @@ fn lub_free_bound_infer() {\n     //! that it yields `fn(&'x isize)` for some free `'x`,\n     //! anyhow.\n \n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n@@ -538,7 +536,7 @@ fn lub_bound_bound() {\n \n #[test]\n fn lub_bound_free() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(1, 1);\n@@ -572,7 +570,7 @@ fn lub_bound_bound_inverse_order() {\n \n #[test]\n fn lub_free_free() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr_free1 = env.t_rptr_free(1, 1);\n         let t_rptr_free2 = env.t_rptr_free(1, 2);\n@@ -585,7 +583,7 @@ fn lub_free_free() {\n \n #[test]\n fn lub_returning_scope() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr_scope10 = env.t_rptr_scope(10);\n         let t_rptr_scope11 = env.t_rptr_scope(11);\n@@ -598,7 +596,7 @@ fn lub_returning_scope() {\n \n #[test]\n fn glb_free_free_with_common_scope() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr_free1 = env.t_rptr_free(1, 1);\n         let t_rptr_free2 = env.t_rptr_free(1, 2);\n@@ -622,7 +620,7 @@ fn glb_bound_bound() {\n \n #[test]\n fn glb_bound_free() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(1, 1);\n@@ -744,7 +742,7 @@ fn subst_ty_renumber_some_bounds() {\n #[test]\n fn escaping() {\n \n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         // Situation:\n         // Theta = [A -> &'a foo]\n         env.create_simple_region_hierarchy();"}, {"sha": "c9ec152841b2025a1e57e8b09344355aba06a405", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -45,6 +45,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{AttributeGate, AttributeType, Stability, deprecated_attributes};\n use syntax_pos::Span;\n+use syntax::symbol::keywords;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::FnKind;\n@@ -605,6 +606,44 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n     }\n }\n \n+declare_lint! {\n+    pub ANONYMOUS_PARAMETERS,\n+    Allow,\n+    \"detects anonymous parameters\"\n+}\n+\n+/// Checks for use of anonymous parameters (RFC 1685)\n+#[derive(Clone)]\n+pub struct AnonymousParameters;\n+\n+impl LintPass for AnonymousParameters {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(ANONYMOUS_PARAMETERS)\n+    }\n+}\n+\n+impl EarlyLintPass for AnonymousParameters {\n+    fn check_trait_item(&mut self, cx: &EarlyContext, it: &ast::TraitItem) {\n+        match it.node {\n+            ast::TraitItemKind::Method(ref sig, _) => {\n+                for arg in sig.decl.inputs.iter() {\n+                    match arg.pat.node {\n+                        ast::PatKind::Ident(_, ident, None) => {\n+                            if ident.node.name == keywords::Invalid.name() {\n+                                cx.span_lint(ANONYMOUS_PARAMETERS,\n+                                             arg.pat.span,\n+                                             \"use of deprecated anonymous parameter\");\n+                            }\n+                        }\n+                        _ => (),\n+                    }\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+}\n+\n declare_lint! {\n     DEPRECATED_ATTR,\n     Warn,"}, {"sha": "c1c14cb1fd29e3d8f3e6d6500a193d0f65fa4367", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -112,6 +112,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     add_early_builtin!(sess,\n                        UnusedParens,\n                        UnusedImportBraces,\n+                       AnonymousParameters,\n                        );\n \n     add_early_builtin_with_new!(sess,\n@@ -244,6 +245,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(MISSING_FRAGMENT_SPECIFIER),\n             reference: \"issue #40107 <https://github.com/rust-lang/rust/issues/40107>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(ANONYMOUS_PARAMETERS),\n+            reference: \"issue #41686 <https://github.com/rust-lang/rust/issues/41686>\",\n+        },\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "5d0e78da2f8fa8e654858f5f81459419be9a4b2a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -20,6 +20,7 @@ use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::middle::lang_items;\n+use rustc::middle::region;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n@@ -351,12 +352,18 @@ impl<'a, 'tcx> SpecializedDecoder<&'tcx Substs<'tcx>> for DecodeContext<'a, 'tcx\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Region> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<&'tcx ty::Region, Self::Error> {\n+impl<'a, 'tcx> SpecializedDecoder<ty::Region<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<ty::Region<'tcx>, Self::Error> {\n         Ok(self.tcx().mk_region(Decodable::decode(self)?))\n     }\n }\n \n+impl<'a, 'tcx> SpecializedDecoder<region::CodeExtent<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<region::CodeExtent<'tcx>, Self::Error> {\n+        Ok(self.tcx().intern_code_extent(Decodable::decode(self)?))\n+    }\n+}\n+\n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<Ty<'tcx>>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx ty::Slice<Ty<'tcx>>, Self::Error> {\n         Ok(self.tcx().mk_type_list((0..self.read_usize()?).map(|_| Decodable::decode(self)))?)"}, {"sha": "d81de954dbf1588876ae8b4734e5470c5f197f67", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let_extent_stack.push(remainder_scope);\n \n                     // Declare the bindings, which may create a visibility scope.\n-                    let remainder_span = remainder_scope.span(&tcx.region_maps, &tcx.hir);\n+                    let remainder_span = remainder_scope.span(&tcx.hir);\n                     let remainder_span = remainder_span.unwrap_or(span);\n                     let scope = this.declare_bindings(None, remainder_span, &pattern);\n "}, {"sha": "22a36bb21d8753f6cafc5b285007cdf6e9a69a87", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// The operand is known to be live until the end of `scope`.\n     pub fn as_operand<M>(&mut self,\n                          block: BasicBlock,\n-                         scope: Option<CodeExtent>,\n+                         scope: Option<CodeExtent<'tcx>>,\n                          expr: M) -> BlockAnd<Operand<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n@@ -49,7 +49,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_operand(&mut self,\n                        mut block: BasicBlock,\n-                       scope: Option<CodeExtent>,\n+                       scope: Option<CodeExtent<'tcx>>,\n                        expr: Expr<'tcx>)\n                        -> BlockAnd<Operand<'tcx>> {\n         debug!(\"expr_as_operand(block={:?}, expr={:?})\", block, expr);"}, {"sha": "8dc7745cd9eb998772201cfd2d519b56fdf861ec", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     /// Compile `expr`, yielding an rvalue.\n-    pub fn as_rvalue<M>(&mut self, block: BasicBlock, scope: Option<CodeExtent>, expr: M)\n+    pub fn as_rvalue<M>(&mut self, block: BasicBlock, scope: Option<CodeExtent<'tcx>>, expr: M)\n                         -> BlockAnd<Rvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n@@ -48,7 +48,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_rvalue(&mut self,\n                       mut block: BasicBlock,\n-                      scope: Option<CodeExtent>,\n+                      scope: Option<CodeExtent<'tcx>>,\n                       expr: Expr<'tcx>)\n                       -> BlockAnd<Rvalue<'tcx>> {\n         debug!(\"expr_as_rvalue(block={:?}, expr={:?})\", block, expr);"}, {"sha": "db4561af734d5627d5faae1b4497f34df825486e", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -21,7 +21,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// up rvalues so as to freeze the value that will be consumed.\n     pub fn as_temp<M>(&mut self,\n                       block: BasicBlock,\n-                      temp_lifetime: Option<CodeExtent>,\n+                      temp_lifetime: Option<CodeExtent<'tcx>>,\n                       expr: M)\n                       -> BlockAnd<Lvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n@@ -32,7 +32,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_temp(&mut self,\n                     mut block: BasicBlock,\n-                    temp_lifetime: Option<CodeExtent>,\n+                    temp_lifetime: Option<CodeExtent<'tcx>>,\n                     expr: Expr<'tcx>)\n                     -> BlockAnd<Lvalue<'tcx>> {\n         debug!(\"expr_as_temp(block={:?}, expr={:?})\", block, expr);"}, {"sha": "2505e2f8211b0c612a77a3664616aa4472e42a75", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span) {\n         let local_id = self.var_indices[&var];\n         let var_ty = self.local_decls[local_id].ty;\n-        let extent = self.hir.tcx().region_maps.var_scope(var);\n+        let extent = self.hir.region_maps.var_scope(var);\n         self.schedule_drop(span, extent, &Lvalue::Local(local_id), var_ty);\n     }\n "}, {"sha": "b8f1b754b48e82c51377f89c093dc29f092ed4d7", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -11,7 +11,7 @@\n use hair::cx::Cx;\n use hair::Pattern;\n \n-use rustc::middle::region::{CodeExtent, CodeExtentData, ROOT_CODE_EXTENT};\n+use rustc::middle::region::{CodeExtent, CodeExtentData};\n use rustc::ty::{self, Ty};\n use rustc::mir::*;\n use rustc::util::nodemap::NodeMap;\n@@ -134,13 +134,13 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n \n     let tcx = hir.tcx();\n     let span = tcx.hir.span(fn_id);\n-    let mut builder = Builder::new(hir, span, arguments.len(), return_ty);\n+    let mut builder = Builder::new(hir.clone(), span, arguments.len(), return_ty);\n \n     let call_site_extent =\n-        tcx.region_maps.lookup_code_extent(\n+        tcx.intern_code_extent(\n             CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body.value.id });\n     let arg_extent =\n-        tcx.region_maps.lookup_code_extent(\n+        tcx.intern_code_extent(\n             CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body.value.id });\n     let mut block = START_BLOCK;\n     unpack!(block = builder.in_scope(call_site_extent, block, |builder| {\n@@ -200,11 +200,12 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let tcx = hir.tcx();\n     let ast_expr = &tcx.hir.body(body_id).value;\n     let ty = hir.tables().expr_ty_adjusted(ast_expr);\n-    let span = tcx.hir.span(tcx.hir.body_owner(body_id));\n-    let mut builder = Builder::new(hir, span, 0, ty);\n+    let owner_id = tcx.hir.body_owner(body_id);\n+    let span = tcx.hir.span(owner_id);\n+    let mut builder = Builder::new(hir.clone(), span, 0, ty);\n \n-    let extent = tcx.region_maps.temporary_scope(ast_expr.id)\n-                    .unwrap_or(ROOT_CODE_EXTENT);\n+    let extent = hir.region_maps.temporary_scope(tcx, ast_expr.id)\n+                                .unwrap_or(tcx.item_extent(owner_id));\n     let mut block = START_BLOCK;\n     let _ = builder.in_scope(extent, block, |builder| {\n         let expr = builder.hir.mirror(ast_expr);\n@@ -288,7 +289,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn args_and_body(&mut self,\n                      mut block: BasicBlock,\n                      arguments: &[(Ty<'gcx>, Option<&'gcx hir::Pat>)],\n-                     argument_extent: CodeExtent,\n+                     argument_extent: CodeExtent<'tcx>,\n                      ast_body: &'gcx hir::Expr)\n                      -> BlockAnd<()>\n     {"}, {"sha": "f9c08f34eaf3f4fde47daac87c75282d3391760b", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -102,7 +102,7 @@ pub struct Scope<'tcx> {\n     visibility_scope: VisibilityScope,\n \n     /// the extent of this scope within source code.\n-    extent: CodeExtent,\n+    extent: CodeExtent<'tcx>,\n \n     /// Whether there's anything to do for the cleanup path, that is,\n     /// when unwinding through this scope. This includes destructors,\n@@ -137,7 +137,7 @@ pub struct Scope<'tcx> {\n     free: Option<FreeData<'tcx>>,\n \n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n-    cached_exits: FxHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n+    cached_exits: FxHashMap<(BasicBlock, CodeExtent<'tcx>), BasicBlock>,\n }\n \n struct DropData<'tcx> {\n@@ -180,7 +180,7 @@ struct FreeData<'tcx> {\n #[derive(Clone, Debug)]\n pub struct BreakableScope<'tcx> {\n     /// Extent of the loop\n-    pub extent: CodeExtent,\n+    pub extent: CodeExtent<'tcx>,\n     /// Where the body of the loop begins. `None` if block\n     pub continue_block: Option<BasicBlock>,\n     /// Block to branch into when the loop or block terminates (either by being `break`-en out\n@@ -248,10 +248,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     ///\n     /// Returns the might_break attribute of the BreakableScope used.\n     pub fn in_breakable_scope<F, R>(&mut self,\n-                            loop_block: Option<BasicBlock>,\n-                            break_block: BasicBlock,\n-                            break_destination: Lvalue<'tcx>,\n-                            f: F) -> R\n+                                    loop_block: Option<BasicBlock>,\n+                                    break_block: BasicBlock,\n+                                    break_destination: Lvalue<'tcx>,\n+                                    f: F) -> R\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> R\n     {\n         let extent = self.topmost_scope();\n@@ -270,7 +270,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n-    pub fn in_scope<F, R>(&mut self, extent: CodeExtent, mut block: BasicBlock, f: F) -> BlockAnd<R>\n+    pub fn in_scope<F, R>(&mut self,\n+                          extent: CodeExtent<'tcx>,\n+                          mut block: BasicBlock,\n+                          f: F)\n+                          -> BlockAnd<R>\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n@@ -285,7 +289,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, extent: CodeExtent) {\n+    pub fn push_scope(&mut self, extent: CodeExtent<'tcx>) {\n         debug!(\"push_scope({:?})\", extent);\n         let vis_scope = self.visibility_scope;\n         self.scopes.push(Scope {\n@@ -302,7 +306,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// drops onto the end of `block` that are needed.  This must\n     /// match 1-to-1 with `push_scope`.\n     pub fn pop_scope(&mut self,\n-                     extent: CodeExtent,\n+                     extent: CodeExtent<'tcx>,\n                      mut block: BasicBlock)\n                      -> BlockAnd<()> {\n         debug!(\"pop_scope({:?}, {:?})\", extent, block);\n@@ -326,7 +330,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// module comment for details.\n     pub fn exit_scope(&mut self,\n                       span: Span,\n-                      extent: CodeExtent,\n+                      extent: CodeExtent<'tcx>,\n                       mut block: BasicBlock,\n                       target: BasicBlock) {\n         debug!(\"exit_scope(extent={:?}, block={:?}, target={:?})\", extent, block, target);\n@@ -387,7 +391,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// resolving `break` and `continue`.\n     pub fn find_breakable_scope(&mut self,\n                            span: Span,\n-                           label: CodeExtent)\n+                           label: CodeExtent<'tcx>)\n                            -> &mut BreakableScope<'tcx> {\n         // find the loop-scope with the correct id\n         self.breakable_scopes.iter_mut()\n@@ -407,11 +411,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     /// Returns the extent of the scope which should be exited by a\n     /// return.\n-    pub fn extent_of_return_scope(&self) -> CodeExtent {\n+    pub fn extent_of_return_scope(&self) -> CodeExtent<'tcx> {\n         // The outermost scope (`scopes[0]`) will be the `CallSiteScope`.\n         // We want `scopes[1]`, which is the `ParameterScope`.\n         assert!(self.scopes.len() >= 2);\n-        assert!(match self.hir.tcx().region_maps.code_extent_data(self.scopes[1].extent) {\n+        assert!(match *self.scopes[1].extent {\n             CodeExtentData::ParameterScope { .. } => true,\n             _ => false,\n         });\n@@ -420,7 +424,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     /// Returns the topmost active scope, which is known to be alive until\n     /// the next scope expression.\n-    pub fn topmost_scope(&self) -> CodeExtent {\n+    pub fn topmost_scope(&self) -> CodeExtent<'tcx> {\n         self.scopes.last().expect(\"topmost_scope: no scopes present\").extent\n     }\n \n@@ -430,7 +434,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// `extent`.\n     pub fn schedule_drop(&mut self,\n                          span: Span,\n-                         extent: CodeExtent,\n+                         extent: CodeExtent<'tcx>,\n                          lvalue: &Lvalue<'tcx>,\n                          lvalue_ty: Ty<'tcx>) {\n         let needs_drop = self.hir.needs_drop(lvalue_ty);\n@@ -499,7 +503,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     scope.needs_cleanup = true;\n                 }\n                 let tcx = self.hir.tcx();\n-                let extent_span = extent.span(&tcx.region_maps, &tcx.hir).unwrap();\n+                let extent_span = extent.span(&tcx.hir).unwrap();\n                 // Attribute scope exit drops to scope's closing brace\n                 let scope_end = Span { lo: extent_span.hi, .. extent_span};\n                 scope.drops.push(DropData {\n@@ -520,7 +524,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// There may only be one \u201cfree\u201d scheduled in any given scope.\n     pub fn schedule_box_free(&mut self,\n                              span: Span,\n-                             extent: CodeExtent,\n+                             extent: CodeExtent<'tcx>,\n                              value: &Lvalue<'tcx>,\n                              item_ty: Ty<'tcx>) {\n         for scope in self.scopes.iter_mut().rev() {"}, {"sha": "2ec4a8a07df71640d0538d5effdd867a66bb2e92", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -24,7 +24,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n         let stmts = mirror_stmts(cx, self.id, &*self.stmts);\n         Block {\n             targeted_by_break: self.targeted_by_break,\n-            extent: cx.tcx.region_maps.node_extent(self.id),\n+            extent: cx.tcx.node_extent(self.id),\n             span: self.span,\n             stmts: stmts,\n             expr: self.expr.to_ref(),\n@@ -44,7 +44,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     span: stmt.span,\n                     kind: StmtKind::Expr {\n-                        scope: cx.tcx.region_maps.node_extent(id),\n+                        scope: cx.tcx.node_extent(id),\n                         expr: expr.to_ref(),\n                     },\n                 })))\n@@ -60,14 +60,14 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             first_statement_index: index as u32,\n                         });\n                         let remainder_extent =\n-                            cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n+                            cx.tcx.intern_code_extent(remainder_extent);\n \n                         let pattern = Pattern::from_hir(cx.tcx, cx.tables(), &local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             span: stmt.span,\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_extent,\n-                                init_scope: cx.tcx.region_maps.node_extent(id),\n+                                init_scope: cx.tcx.node_extent(id),\n                                 pattern: pattern,\n                                 initializer: local.init.to_ref(),\n                             },\n@@ -84,7 +84,7 @@ pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n     let block_ty = cx.tables().node_id_to_type(block.id);\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps.temporary_scope2(block.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, block.id);\n     let expr = Expr {\n         ty: block_ty,\n         temp_lifetime: temp_lifetime,"}, {"sha": "6a1817aba09835348459479f38e11b15ff15fc44", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -26,8 +26,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n-        let (temp_lifetime, was_shrunk) = cx.tcx.region_maps.temporary_scope2(self.id);\n-        let expr_extent = cx.tcx.region_maps.node_extent(self.id);\n+        let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, self.id);\n+        let expr_extent = cx.tcx.node_extent(self.id);\n \n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n@@ -216,7 +216,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         };\n \n         // Finally, create a destruction scope, if any.\n-        if let Some(extent) = cx.tcx.region_maps.opt_destruction_extent(self.id) {\n+        if let Some(extent) = cx.region_maps.opt_destruction_extent(self.id) {\n             expr = Expr {\n                 temp_lifetime: temp_lifetime,\n                 temp_lifetime_was_shrunk: was_shrunk,\n@@ -238,7 +238,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n     let expr_ty = cx.tables().expr_ty(expr);\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps.temporary_scope2(expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n \n     let kind = match expr.node {\n         // Here comes the interesting stuff:\n@@ -610,7 +610,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(target_id) |\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(target_id)) => ExprKind::Break {\n-                    label: cx.tcx.region_maps.node_extent(target_id),\n+                    label: cx.tcx.node_extent(target_id),\n                     value: value.to_ref(),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n@@ -621,7 +621,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(_) => bug!(\"cannot continue to blocks\"),\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(loop_id)) => ExprKind::Continue {\n-                    label: cx.tcx.region_maps.node_extent(loop_id),\n+                    label: cx.tcx.node_extent(loop_id),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n                     bug!(\"invalid loop id for continue: {}\", err)\n@@ -686,7 +686,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprBox(ref value) => {\n             ExprKind::Box {\n                 value: value.to_ref(),\n-                value_extents: cx.tcx.region_maps.node_extent(value.id),\n+                value_extents: cx.tcx.node_extent(value.id),\n             }\n         }\n         hir::ExprArray(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n@@ -707,7 +707,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  method_call: ty::MethodCall)\n                                  -> Expr<'tcx> {\n     let callee = cx.tables().method_map[&method_call];\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps.temporary_scope2(expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n     Expr {\n         temp_lifetime: temp_lifetime,\n         temp_lifetime_was_shrunk: was_shrunk,\n@@ -791,7 +791,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                expr: &'tcx hir::Expr,\n                                def: Def)\n                                -> ExprKind<'tcx> {\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps.temporary_scope2(expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n \n     match def {\n         Def::Local(def_id) => {\n@@ -827,8 +827,8 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n             // have a bound region with number 0\n-            let region = ty::Region::ReFree(ty::FreeRegion {\n-                scope: cx.tcx.region_maps.node_extent(body_id),\n+            let region = ty::ReFree(ty::FreeRegion {\n+                scope: Some(cx.tcx.node_extent(body_id)),\n                 bound_region: ty::BoundRegion::BrAnon(0),\n             });\n             let region = cx.tcx.mk_region(region);\n@@ -979,7 +979,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         PassArgs::ByRef => {\n             let region = cx.tcx.node_scope_region(expr.id);\n             let (temp_lifetime, was_shrunk) =\n-                cx.tcx.region_maps.temporary_scope2(expr.id);\n+                cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n             argrefs.extend(args.iter()\n                 .map(|arg| {\n                     let arg_ty = cx.tables().expr_ty_adjusted(arg);\n@@ -1031,7 +1031,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps.temporary_scope2(expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n     let ref_kind = overloaded_operator(cx, expr, method_call, pass_args, receiver, args);\n     let ref_expr = Expr {\n         temp_lifetime: temp_lifetime,\n@@ -1056,7 +1056,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         closure_expr_id: closure_expr.id,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id).unwrap();\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps.temporary_scope2(closure_expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, closure_expr.id);\n     let var_ty = cx.tables().node_id_to_type(id_var);\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,"}, {"sha": "3e9bcb3e18627939b3652bc62e493c8442c40a7f", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -22,17 +22,20 @@ use rustc_const_eval::ConstContext;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::blocks::FnLikeNode;\n+use rustc::middle::region::RegionMaps;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n use syntax::symbol::{Symbol, InternedString};\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n+use std::rc::Rc;\n \n-#[derive(Copy, Clone)]\n+#[derive(Clone)]\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    pub region_maps: Rc<RegionMaps<'tcx>>,\n     constness: hir::Constness,\n \n     /// True if this constant/function needs overflow checks.\n@@ -51,7 +54,13 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             MirSource::Promoted(..) => bug!(),\n         };\n \n-        let attrs = infcx.tcx.hir.attrs(src.item_id());\n+        let tcx = infcx.tcx;\n+        let src_id = src.item_id();\n+        let src_def_id = tcx.hir.local_def_id(src_id);\n+\n+        let region_maps = tcx.region_maps(src_def_id);\n+\n+        let attrs = tcx.hir.attrs(src_id);\n \n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n@@ -60,17 +69,12 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             .any(|item| item.check_name(\"rustc_inherit_overflow_checks\"));\n \n         // Respect -C overflow-checks.\n-        check_overflow |= infcx.tcx.sess.overflow_checks();\n+        check_overflow |= tcx.sess.overflow_checks();\n \n         // Constants and const fn's always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;\n \n-        Cx {\n-            tcx: infcx.tcx,\n-            infcx: infcx,\n-            constness: constness,\n-            check_overflow: check_overflow,\n-        }\n+        Cx { tcx, infcx, region_maps, constness, check_overflow }\n     }\n }\n "}, {"sha": "0e8992e62ea6c8968eff6420194c7e7be817736f", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -32,7 +32,7 @@ pub use rustc_const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPatt\n #[derive(Clone, Debug)]\n pub struct Block<'tcx> {\n     pub targeted_by_break: bool,\n-    pub extent: CodeExtent,\n+    pub extent: CodeExtent<'tcx>,\n     pub span: Span,\n     pub stmts: Vec<StmtRef<'tcx>>,\n     pub expr: Option<ExprRef<'tcx>>,\n@@ -53,7 +53,7 @@ pub struct Stmt<'tcx> {\n pub enum StmtKind<'tcx> {\n     Expr {\n         /// scope for this statement; may be used as lifetime of temporaries\n-        scope: CodeExtent,\n+        scope: CodeExtent<'tcx>,\n \n         /// expression being evaluated in this statement\n         expr: ExprRef<'tcx>,\n@@ -62,11 +62,11 @@ pub enum StmtKind<'tcx> {\n     Let {\n         /// scope for variables bound in this let; covers this and\n         /// remaining statements in block\n-        remainder_scope: CodeExtent,\n+        remainder_scope: CodeExtent<'tcx>,\n \n         /// scope for the initialization itself; might be used as\n         /// lifetime of temporaries\n-        init_scope: CodeExtent,\n+        init_scope: CodeExtent<'tcx>,\n \n         /// let <PAT> = ...\n         pattern: Pattern<'tcx>,\n@@ -97,7 +97,7 @@ pub struct Expr<'tcx> {\n \n     /// lifetime of this expression if it should be spilled into a\n     /// temporary; should be None only if in a constant context\n-    pub temp_lifetime: Option<CodeExtent>,\n+    pub temp_lifetime: Option<CodeExtent<'tcx>>,\n \n     /// whether this temp lifetime was shrunk by #36082.\n     pub temp_lifetime_was_shrunk: bool,\n@@ -112,12 +112,12 @@ pub struct Expr<'tcx> {\n #[derive(Clone, Debug)]\n pub enum ExprKind<'tcx> {\n     Scope {\n-        extent: CodeExtent,\n+        extent: CodeExtent<'tcx>,\n         value: ExprRef<'tcx>,\n     },\n     Box {\n         value: ExprRef<'tcx>,\n-        value_extents: CodeExtent,\n+        value_extents: CodeExtent<'tcx>,\n     },\n     Call {\n         ty: ty::Ty<'tcx>,\n@@ -205,16 +205,16 @@ pub enum ExprKind<'tcx> {\n         id: DefId,\n     },\n     Borrow {\n-        region: &'tcx Region,\n+        region: Region<'tcx>,\n         borrow_kind: BorrowKind,\n         arg: ExprRef<'tcx>,\n     },\n     Break {\n-        label: CodeExtent,\n+        label: CodeExtent<'tcx>,\n         value: Option<ExprRef<'tcx>>,\n     },\n     Continue {\n-        label: CodeExtent,\n+        label: CodeExtent<'tcx>,\n     },\n     Return {\n         value: Option<ExprRef<'tcx>>,"}, {"sha": "1abae515ae68374ee32c9a6672226f8a7dfdb862", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -252,8 +252,8 @@ fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> Ty<'tcx> {\n     let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n \n-    let region = ty::Region::ReFree(ty::FreeRegion {\n-        scope: tcx.region_maps.item_extent(body_id.node_id),\n+    let region = ty::ReFree(ty::FreeRegion {\n+        scope: Some(tcx.item_extent(body_id.node_id)),\n         bound_region: ty::BoundRegion::BrEnv,\n     });\n     let region = tcx.mk_region(region);"}, {"sha": "f2a550ec23a8e2abb04cea2d2dd1a7c433bed7e0", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -11,7 +11,6 @@\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer;\n-use rustc::middle::region::ROOT_CODE_EXTENT;\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n@@ -45,8 +44,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"make_shim({:?})\", instance);\n     let did = instance.def_id();\n     let span = tcx.def_span(did);\n-    let param_env =\n-        tcx.construct_parameter_environment(span, did, ROOT_CODE_EXTENT);\n+    let param_env = tcx.construct_parameter_environment(span, did, None);\n \n     let mut result = match instance {\n         ty::InstanceDef::Item(..) =>"}, {"sha": "608238dfe3735d6f46ea5b71648f0a1d7424e308", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -130,7 +130,8 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         };\n \n         let outer_tables = self.tables;\n-        self.tables = self.tcx.typeck_tables_of(self.tcx.hir.local_def_id(item_id));\n+        let item_def_id = self.tcx.hir.local_def_id(item_id);\n+        self.tables = self.tcx.typeck_tables_of(item_def_id);\n \n         let body = self.tcx.hir.body(body_id);\n         if !self.in_fn {\n@@ -140,7 +141,8 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         let outer_penv = self.tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n             let param_env = infcx.parameter_environment.clone();\n             let outer_penv = mem::replace(&mut self.param_env, param_env);\n-            euv::ExprUseVisitor::new(self, &infcx).consume_body(body);\n+            let region_maps = &self.tcx.region_maps(item_def_id);;\n+            euv::ExprUseVisitor::new(self, region_maps, &infcx).consume_body(body);\n             outer_penv\n         });\n \n@@ -480,7 +482,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n               borrow_id: ast::NodeId,\n               _borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              _loan_region: &'tcx ty::Region,\n+              _loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause) {\n         // Kind of hacky, but we allow Unsafe coercions in constants."}, {"sha": "795ff58e20607a1f663740afc31eaa86e717d315", "filename": "src/librustc_save_analysis/dump.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_save_analysis%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_save_analysis%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -13,28 +13,28 @@ use super::external_data::*;\n use rls_data::CratePreludeData;\n \n pub trait Dump {\n-    fn crate_prelude(&mut self, CratePreludeData) {}\n-    fn enum_data(&mut self, EnumData) {}\n-    fn extern_crate(&mut self, ExternCrateData) {}\n-    fn impl_data(&mut self, ImplData) {}\n-    fn inheritance(&mut self, InheritanceData) {}\n-    fn function(&mut self, FunctionData) {}\n-    fn function_ref(&mut self, FunctionRefData) {}\n-    fn function_call(&mut self, FunctionCallData) {}\n-    fn method(&mut self, MethodData) {}\n-    fn method_call(&mut self, MethodCallData) {}\n-    fn macro_data(&mut self, MacroData) {}\n-    fn macro_use(&mut self, MacroUseData) {}\n-    fn mod_data(&mut self, ModData) {}\n-    fn mod_ref(&mut self, ModRefData) {}\n-    fn struct_data(&mut self, StructData) {}\n-    fn struct_variant(&mut self, StructVariantData) {}\n-    fn trait_data(&mut self, TraitData) {}\n-    fn tuple_variant(&mut self, TupleVariantData) {}\n-    fn type_ref(&mut self, TypeRefData) {}\n-    fn typedef(&mut self, TypeDefData) {}\n-    fn use_data(&mut self, UseData) {}\n-    fn use_glob(&mut self, UseGlobData) {}\n-    fn variable(&mut self, VariableData) {}\n-    fn variable_ref(&mut self, VariableRefData) {}\n+    fn crate_prelude(&mut self, _: CratePreludeData) {}\n+    fn enum_data(&mut self, _: EnumData) {}\n+    fn extern_crate(&mut self, _: ExternCrateData) {}\n+    fn impl_data(&mut self, _: ImplData) {}\n+    fn inheritance(&mut self, _: InheritanceData) {}\n+    fn function(&mut self, _: FunctionData) {}\n+    fn function_ref(&mut self, _: FunctionRefData) {}\n+    fn function_call(&mut self, _: FunctionCallData) {}\n+    fn method(&mut self, _: MethodData) {}\n+    fn method_call(&mut self, _: MethodCallData) {}\n+    fn macro_data(&mut self, _: MacroData) {}\n+    fn macro_use(&mut self, _: MacroUseData) {}\n+    fn mod_data(&mut self, _: ModData) {}\n+    fn mod_ref(&mut self, _: ModRefData) {}\n+    fn struct_data(&mut self, _: StructData) {}\n+    fn struct_variant(&mut self, _: StructVariantData) {}\n+    fn trait_data(&mut self, _: TraitData) {}\n+    fn tuple_variant(&mut self, _: TupleVariantData) {}\n+    fn type_ref(&mut self, _: TypeRefData) {}\n+    fn typedef(&mut self, _: TypeDefData) {}\n+    fn use_data(&mut self, _: UseData) {}\n+    fn use_glob(&mut self, _: UseGlobData) {}\n+    fn variable(&mut self, _: VariableData) {}\n+    fn variable_ref(&mut self, _: VariableRefData) {}\n }"}, {"sha": "c89e3ca8b68c9266e7a7526ea85df14faf93ed13", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -53,7 +53,7 @@ pub trait AstConv<'gcx, 'tcx> {\n \n     /// What lifetime should we use when a lifetime is omitted (and not elided)?\n     fn re_infer(&self, span: Span, _def: Option<&ty::RegionParameterDef>)\n-                -> Option<&'tcx ty::Region>;\n+                -> Option<ty::Region<'tcx>>;\n \n     /// What type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n@@ -104,7 +104,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn ast_region_to_region(&self,\n         lifetime: &hir::Lifetime,\n         def: Option<&ty::RegionParameterDef>)\n-        -> &'tcx ty::Region\n+        -> ty::Region<'tcx>\n     {\n         let tcx = self.tcx();\n         let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n@@ -133,7 +133,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Some(&rl::Region::Free(scope, id)) => {\n                 let name = tcx.hir.name(id);\n                 tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                    scope: scope.to_code_extent(&tcx.region_maps),\n+                    scope: Some(scope.to_code_extent(tcx)),\n                     bound_region: ty::BrNamed(tcx.hir.local_def_id(id), name)\n                 }))\n \n@@ -1342,7 +1342,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn compute_object_lifetime_bound(&self,\n         span: Span,\n         existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n-        -> Option<&'tcx ty::Region> // if None, use the default\n+        -> Option<ty::Region<'tcx>> // if None, use the default\n     {\n         let tcx = self.tcx();\n \n@@ -1489,7 +1489,7 @@ fn report_lifetime_number_error(tcx: TyCtxt, span: Span, number: usize, expected\n // and return from functions in multiple places.\n #[derive(PartialEq, Eq, Clone, Debug)]\n pub struct Bounds<'tcx> {\n-    pub region_bounds: Vec<&'tcx ty::Region>,\n+    pub region_bounds: Vec<ty::Region<'tcx>>,\n     pub implicitly_sized: bool,\n     pub trait_bounds: Vec<ty::PolyTraitRef<'tcx>>,\n     pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n@@ -1533,7 +1533,7 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n \n pub enum ExplicitSelf<'tcx> {\n     ByValue,\n-    ByReference(&'tcx ty::Region, hir::Mutability),\n+    ByReference(ty::Region<'tcx>, hir::Mutability),\n     ByBox\n }\n "}, {"sha": "45b0a571bd08afd7b7e5827e57bb1078c5174a47", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -73,8 +73,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n \n-        let extent = self.tcx.region_maps.call_site_extent(expr.id, body.value.id);\n-        let fn_sig = self.tcx.liberate_late_bound_regions(extent, &sig);\n+        let extent = self.tcx.call_site_extent(expr.id, body.value.id);\n+        let fn_sig = self.tcx.liberate_late_bound_regions(Some(extent), &sig);\n         let fn_sig = self.inh.normalize_associated_types_in(body.value.span,\n                                                             body.value.id, &fn_sig);\n "}, {"sha": "61d04876bfeb51cfd59fc7967c3bd6df2b528039", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -250,7 +250,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                   exprs: &[E],\n                                   a: Ty<'tcx>,\n                                   b: Ty<'tcx>,\n-                                  r_b: &'tcx ty::Region,\n+                                  r_b: ty::Region<'tcx>,\n                                   mt_b: TypeAndMut<'tcx>)\n                                   -> CoerceResult<'tcx>\n         where E: AsCoercionSite"}, {"sha": "80330afaad841b0b1736641b18a3092508650948", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -11,13 +11,13 @@\n use rustc::hir::{self, ImplItemKind, TraitItemKind};\n use rustc::infer::{self, InferOk};\n use rustc::middle::free_region::FreeRegionMap;\n+use rustc::middle::region::RegionMaps;\n use rustc::ty::{self, TyCtxt};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::util::common::ErrorReported;\n \n-use syntax::ast;\n use syntax_pos::Span;\n \n use super::{Inherited, FnCtxt};\n@@ -30,14 +30,12 @@ use astconv::ExplicitSelf;\n ///\n /// - impl_m: type of the method we are checking\n /// - impl_m_span: span to use for reporting errors\n-/// - impl_m_body_id: id of the method body\n /// - trait_m: the method in the trait\n /// - impl_trait_ref: the TraitRef corresponding to the trait implementation\n \n pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_m: &ty::AssociatedItem,\n                                      impl_m_span: Span,\n-                                     impl_m_body_id: ast::NodeId,\n                                      trait_m: &ty::AssociatedItem,\n                                      impl_trait_ref: ty::TraitRef<'tcx>,\n                                      trait_item_span: Option<Span>,\n@@ -72,7 +70,6 @@ pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if let Err(ErrorReported) = compare_predicate_entailment(tcx,\n                                                              impl_m,\n                                                              impl_m_span,\n-                                                             impl_m_body_id,\n                                                              trait_m,\n                                                              impl_trait_ref,\n                                                              old_broken_mode) {\n@@ -83,21 +80,25 @@ pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           impl_m: &ty::AssociatedItem,\n                                           impl_m_span: Span,\n-                                          impl_m_body_id: ast::NodeId,\n                                           trait_m: &ty::AssociatedItem,\n                                           impl_trait_ref: ty::TraitRef<'tcx>,\n                                           old_broken_mode: bool)\n                                           -> Result<(), ErrorReported> {\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n+    // This node-id should be used for the `body_id` field on each\n+    // `ObligationCause` (and the `FnCtxt`). This is what\n+    // `regionck_item` expects.\n+    let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n+\n     let cause = ObligationCause {\n         span: impl_m_span,\n-        body_id: impl_m_body_id,\n+        body_id: impl_m_node_id,\n         code: ObligationCauseCode::CompareImplMethodObligation {\n             item_name: impl_m.name,\n             impl_item_def_id: impl_m.def_id,\n             trait_item_def_id: trait_m.def_id,\n-            lint_id: if !old_broken_mode { Some(impl_m_body_id) } else { None },\n+            lint_id: if !old_broken_mode { Some(impl_m_node_id) } else { None },\n         },\n     };\n \n@@ -166,7 +167,6 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Create a parameter environment that represents the implementation's\n     // method.\n-    let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, impl_m_node_id);\n \n     // Create mapping from impl to skolemized.\n@@ -217,9 +217,10 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n-    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n+    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_node_id);\n     let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.predicates);\n     let trait_param_env = traits::normalize_param_env_or_error(tcx,\n+                                                               impl_m.def_id,\n                                                                trait_param_env,\n                                                                normalize_cause.clone());\n \n@@ -275,7 +276,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             impl_sig.subst(tcx, impl_to_skol_substs);\n         let impl_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n-                                              impl_m_body_id,\n+                                              impl_m_node_id,\n                                               &impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(ty::Binder(impl_sig));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n@@ -287,7 +288,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             trait_sig.subst(tcx, trait_to_skol_substs);\n         let trait_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n-                                              impl_m_body_id,\n+                                              impl_m_node_id,\n                                               &trait_sig);\n         let trait_fty = tcx.mk_fn_ptr(ty::Binder(trait_sig));\n \n@@ -349,13 +350,14 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // region obligations that get overlooked.  The right\n             // thing to do is the code below. But we keep this old\n             // pass around temporarily.\n+            let region_maps = RegionMaps::new();\n             let mut free_regions = FreeRegionMap::new();\n             free_regions.relate_free_regions_from_predicates(\n                 &infcx.parameter_environment.caller_bounds);\n-            infcx.resolve_regions_and_report_errors(&free_regions, impl_m_body_id);\n+            infcx.resolve_regions_and_report_errors(impl_m.def_id, &region_maps, &free_regions);\n         } else {\n-            let fcx = FnCtxt::new(&inh, impl_m_body_id);\n-            fcx.regionck_item(impl_m_body_id, impl_m_span, &[]);\n+            let fcx = FnCtxt::new(&inh, impl_m_node_id);\n+            fcx.regionck_item(impl_m_node_id, impl_m_span, &[]);\n         }\n \n         Ok(())"}, {"sha": "c20777a403aac7a2b36f97e54b88da7826ede900", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -13,7 +13,7 @@ use check::regionck::RegionCtxt;\n use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferOk};\n-use middle::region;\n+use rustc::middle::region::{self, RegionMaps};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, ObligationCause, Reveal};\n@@ -116,8 +116,9 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n             return Err(ErrorReported);\n         }\n \n+        let region_maps = RegionMaps::new();\n         let free_regions = FreeRegionMap::new();\n-        infcx.resolve_regions_and_report_errors(&free_regions, drop_impl_node_id);\n+        infcx.resolve_regions_and_report_errors(drop_impl_did, &region_maps, &free_regions);\n         Ok(())\n     })\n }\n@@ -271,14 +272,14 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'gcx, 'tcx>,\n     ty: ty::Ty<'tcx>,\n     span: Span,\n-    scope: region::CodeExtent)\n+    scope: region::CodeExtent<'tcx>)\n     -> Result<(), ErrorReported>\n {\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n            ty, scope);\n \n \n-    let parent_scope = match rcx.tcx.region_maps.opt_encl_scope(scope) {\n+    let parent_scope = match rcx.region_maps.opt_encl_scope(scope) {\n         Some(parent_scope) => parent_scope,\n         // If no enclosing scope, then it must be the root scope\n         // which cannot be outlived."}, {"sha": "c401ed428e4f19d3a0b1df3326f2da652fba338a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -781,11 +781,11 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             check_abi(tcx, span, fn_sig.abi());\n \n             // Compute the fty from point of view of inside fn.\n-            let fn_scope = inh.tcx.region_maps.call_site_extent(id, body_id.node_id);\n+            let fn_scope = inh.tcx.call_site_extent(id, body_id.node_id);\n             let fn_sig =\n                 fn_sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n             let fn_sig =\n-                inh.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n+                inh.tcx.liberate_late_bound_regions(Some(fn_scope), &fn_sig);\n             let fn_sig =\n                 inh.normalize_associated_types_in(body.value.span, body_id.node_id, &fn_sig);\n \n@@ -1237,14 +1237,13 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          err.emit()\n                     }\n                 }\n-                hir::ImplItemKind::Method(_, body_id) => {\n+                hir::ImplItemKind::Method(..) => {\n                     let trait_span = tcx.hir.span_if_local(ty_trait_item.def_id);\n                     if ty_trait_item.kind == ty::AssociatedKind::Method {\n                         let err_count = tcx.sess.err_count();\n                         compare_impl_method(tcx,\n                                             &ty_impl_item,\n                                             impl_item.span,\n-                                            body_id.node_id,\n                                             &ty_trait_item,\n                                             impl_trait_ref,\n                                             trait_span,\n@@ -1254,7 +1253,6 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             compare_impl_method(tcx,\n                                                 &ty_impl_item,\n                                                 impl_item.span,\n-                                                body_id.node_id,\n                                                 &ty_trait_item,\n                                                 impl_trait_ref,\n                                                 trait_span,\n@@ -1549,7 +1547,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn re_infer(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n-                -> Option<&'tcx ty::Region> {\n+                -> Option<ty::Region<'tcx>> {\n         let v = match def {\n             Some(def) => infer::EarlyBoundRegion(span, def.name, def.issue_32330),\n             None => infer::MiscVariable(span)\n@@ -1963,7 +1961,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// outlive the region `r`.\n     pub fn register_region_obligation(&self,\n                                       ty: Ty<'tcx>,\n-                                      region: &'tcx ty::Region,\n+                                      region: ty::Region<'tcx>,\n                                       cause: traits::ObligationCause<'tcx>)\n     {\n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();"}, {"sha": "8a63d501da8c36d5abec986429a810b40b626206", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 58, "deletions": 50, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -87,7 +87,8 @@ use check::FnCtxt;\n use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n-use middle::region::{self, CodeExtent};\n+use middle::region::{self, CodeExtent, RegionMaps};\n+use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, MethodCall, TypeFoldable};\n@@ -97,6 +98,7 @@ use rustc::ty::wf::ImpliedBound;\n \n use std::mem;\n use std::ops::Deref;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -112,8 +114,9 @@ macro_rules! ignore_err {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_expr(&self, body: &'gcx hir::Body) {\n+        let subject = self.tcx.hir.body_owner_def_id(body.id());\n         let id = body.value.id;\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(id), id, Subject(id));\n+        let mut rcx = RegionCtxt::new(self, RepeatingScope(id), id, Subject(subject));\n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n             rcx.visit_body(body);\n@@ -132,7 +135,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          span: Span,\n                          wf_tys: &[Ty<'tcx>]) {\n         debug!(\"regionck_item(item.id={:?}, wf_tys={:?}\", item_id, wf_tys);\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(item_id), item_id, Subject(item_id));\n+        let subject = self.tcx.hir.local_def_id(item_id);\n+        let mut rcx = RegionCtxt::new(self, RepeatingScope(item_id), item_id, Subject(subject));\n         rcx.free_region_map.relate_free_regions_from_predicates(\n             &self.parameter_environment.caller_bounds);\n         rcx.relate_free_regions(wf_tys, item_id, span);\n@@ -144,8 +148,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        fn_id: ast::NodeId,\n                        body: &'gcx hir::Body) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n+        let subject = self.tcx.hir.body_owner_def_id(body.id());\n         let node_id = body.value.id;\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(node_id), node_id, Subject(fn_id));\n+        let mut rcx = RegionCtxt::new(self, RepeatingScope(node_id), node_id, Subject(subject));\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n@@ -171,21 +176,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n \n-    region_bound_pairs: Vec<(&'tcx ty::Region, GenericKind<'tcx>)>,\n+    region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n \n-    free_region_map: FreeRegionMap,\n+    pub region_maps: Rc<RegionMaps<'tcx>>,\n+\n+    free_region_map: FreeRegionMap<'tcx>,\n \n     // id of innermost fn body id\n     body_id: ast::NodeId,\n \n     // call_site scope of innermost fn\n-    call_site_scope: Option<CodeExtent>,\n+    call_site_scope: Option<CodeExtent<'tcx>>,\n \n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n \n     // id of AST node being analyzed (the subject of the analysis).\n-    subject: ast::NodeId,\n+    subject_def_id: DefId,\n \n }\n \n@@ -197,25 +204,28 @@ impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n }\n \n pub struct RepeatingScope(ast::NodeId);\n-pub struct Subject(ast::NodeId);\n+pub struct Subject(DefId);\n \n impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n                RepeatingScope(initial_repeating_scope): RepeatingScope,\n                initial_body_id: ast::NodeId,\n                Subject(subject): Subject) -> RegionCtxt<'a, 'gcx, 'tcx> {\n+        let region_maps = fcx.tcx.region_maps(subject);\n         RegionCtxt {\n             fcx: fcx,\n+            region_maps: region_maps,\n             repeating_scope: initial_repeating_scope,\n             body_id: initial_body_id,\n             call_site_scope: None,\n-            subject: subject,\n+            subject_def_id: subject,\n             region_bound_pairs: Vec::new(),\n             free_region_map: FreeRegionMap::new(),\n         }\n     }\n \n-    fn set_call_site_scope(&mut self, call_site_scope: Option<CodeExtent>) -> Option<CodeExtent> {\n+    fn set_call_site_scope(&mut self, call_site_scope: Option<CodeExtent<'tcx>>)\n+                           -> Option<CodeExtent<'tcx>> {\n         mem::replace(&mut self.call_site_scope, call_site_scope)\n     }\n \n@@ -276,7 +286,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let body_id = body.id();\n \n-        let call_site = self.tcx.region_maps.lookup_code_extent(\n+        let call_site = self.tcx.intern_code_extent(\n             region::CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id });\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n@@ -302,7 +312,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let old_body_id = self.set_body_id(body_id.node_id);\n         self.relate_free_regions(&fn_sig_tys[..], body_id.node_id, span);\n-        self.link_fn_args(self.tcx.region_maps.node_extent(body_id.node_id), &body.arguments);\n+        self.link_fn_args(self.tcx.node_extent(body_id.node_id), &body.arguments);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n \n@@ -417,14 +427,12 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn resolve_regions_and_report_errors(&self) {\n-        let subject_node_id = self.subject;\n-\n-        self.fcx.resolve_regions_and_report_errors(&self.free_region_map,\n-                                                   subject_node_id);\n+        self.fcx.resolve_regions_and_report_errors(self.subject_def_id,\n+                                                   &self.region_maps,\n+                                                   &self.free_region_map);\n     }\n \n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n-        let tcx = self.tcx;\n         debug!(\"regionck::visit_pat(pat={:?})\", pat);\n         pat.each_binding(|_, id, span, _| {\n             // If we have a variable that contains region'd data, that\n@@ -450,7 +458,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             // that the lifetime of any regions that appear in a\n             // variable's type enclose at least the variable's scope.\n \n-            let var_scope = tcx.region_maps.var_scope(id);\n+            let var_scope = self.region_maps.var_scope(id);\n             let var_region = self.tcx.mk_region(ty::ReScope(var_scope));\n \n             let origin = infer::BindingTypeIsNotValidAtDecl(span);\n@@ -569,7 +577,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n             // If necessary, constrain destructors in the unadjusted form of this\n             // expression.\n             let cmt_result = {\n-                let mc = mc::MemCategorizationContext::new(self);\n+                let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n                 mc.cat_expr_unadjusted(expr)\n             };\n             match cmt_result {\n@@ -586,7 +594,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // If necessary, constrain destructors in this expression. This will be\n         // the adjusted form if there is an adjustment.\n         let cmt_result = {\n-            let mc = mc::MemCategorizationContext::new(self);\n+            let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n             mc.cat_expr(expr)\n         };\n         match cmt_result {\n@@ -868,7 +876,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // call occurs.\n         //\n         // FIXME(#6268) to support nested method calls, should be callee_id\n-        let callee_scope = self.tcx.region_maps.node_extent(call_expr.id);\n+        let callee_scope = self.tcx.node_extent(call_expr.id);\n         let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n \n         debug!(\"callee_region={:?}\", callee_region);\n@@ -948,7 +956,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                            r, m);\n \n                     {\n-                        let mc = mc::MemCategorizationContext::new(self);\n+                        let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n                         let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                         debug!(\"constrain_autoderefs: self_cmt={:?}\",\n                                self_cmt);\n@@ -982,8 +990,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_subregion_due_to_dereference(&mut self,\n                                            deref_span: Span,\n-                                           minimum_lifetime: &'tcx ty::Region,\n-                                           maximum_lifetime: &'tcx ty::Region) {\n+                                           minimum_lifetime: ty::Region<'tcx>,\n+                                           maximum_lifetime: ty::Region<'tcx>) {\n         self.sub_regions(infer::DerefPointer(deref_span),\n                          minimum_lifetime, maximum_lifetime)\n     }\n@@ -1021,7 +1029,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n                self.ty_to_string(indexed_ty));\n \n-        let r_index_expr = ty::ReScope(self.tcx.region_maps.node_extent(index_expr.id));\n+        let r_index_expr = ty::ReScope(self.tcx.node_extent(index_expr.id));\n         if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n             match mt.ty.sty {\n                 ty::TySlice(_) | ty::TyStr => {\n@@ -1038,7 +1046,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn type_of_node_must_outlive(&mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         id: ast::NodeId,\n-        minimum_lifetime: &'tcx ty::Region)\n+        minimum_lifetime: ty::Region<'tcx>)\n     {\n         // Try to resolve the type.  If we encounter an error, then typeck\n         // is going to fail anyway, so just stop here and let typeck\n@@ -1060,7 +1068,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n         let cmt = {\n-            let mc = mc::MemCategorizationContext::new(self);\n+            let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n             ignore_err!(mc.cat_expr(base))\n         };\n \n@@ -1078,7 +1086,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             None => { return; }\n             Some(ref expr) => &**expr,\n         };\n-        let mc = mc::MemCategorizationContext::new(self);\n+        let mc = &mc::MemCategorizationContext::new(self, &self.region_maps);\n         let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n         self.link_pattern(mc, discr_cmt, &local.pat);\n     }\n@@ -1088,7 +1096,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// linked to the lifetime of its guarantor (if any).\n     fn link_match(&self, discr: &hir::Expr, arms: &[hir::Arm]) {\n         debug!(\"regionck::for_match()\");\n-        let mc = mc::MemCategorizationContext::new(self);\n+        let mc = &mc::MemCategorizationContext::new(self, &self.region_maps);\n         let discr_cmt = ignore_err!(mc.cat_expr(discr));\n         debug!(\"discr_cmt={:?}\", discr_cmt);\n         for arm in arms {\n@@ -1101,9 +1109,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n-    fn link_fn_args(&self, body_scope: CodeExtent, args: &[hir::Arg]) {\n+    fn link_fn_args(&self, body_scope: CodeExtent<'tcx>, args: &[hir::Arg]) {\n         debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n-        let mc = mc::MemCategorizationContext::new(self);\n+        let mc = &mc::MemCategorizationContext::new(self, &self.region_maps);\n         for arg in args {\n             let arg_ty = self.node_ty(arg.id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n@@ -1120,13 +1128,13 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n     fn link_pattern<'t>(&self,\n-                        mc: mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n+                        mc: &mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n                         discr_cmt: mc::cmt<'tcx>,\n                         root_pat: &hir::Pat) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n                discr_cmt,\n                root_pat);\n-    let _ = mc.cat_pattern(discr_cmt, root_pat, |_, sub_cmt, sub_pat| {\n+        let _ = mc.cat_pattern(discr_cmt, root_pat, |_, sub_cmt, sub_pat| {\n                 match sub_pat.node {\n                     // `ref x` pattern\n                     PatKind::Binding(hir::BindByRef(mutbl), ..) => {\n@@ -1146,7 +1154,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     autoref: &adjustment::AutoBorrow<'tcx>)\n     {\n         debug!(\"link_autoref(autoderefs={}, autoref={:?})\", autoderefs, autoref);\n-        let mc = mc::MemCategorizationContext::new(self);\n+        let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n         let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n         debug!(\"expr_cmt={:?}\", expr_cmt);\n \n@@ -1167,10 +1175,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// must outlive `callee_scope`.\n     fn link_by_ref(&self,\n                    expr: &hir::Expr,\n-                   callee_scope: CodeExtent) {\n+                   callee_scope: CodeExtent<'tcx>) {\n         debug!(\"link_by_ref(expr={:?}, callee_scope={:?})\",\n                expr, callee_scope);\n-        let mc = mc::MemCategorizationContext::new(self);\n+        let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n         let expr_cmt = ignore_err!(mc.cat_expr(expr));\n         let borrow_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n         self.link_region(expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n@@ -1200,7 +1208,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// between regions, as explained in `link_reborrowed_region()`.\n     fn link_region(&self,\n                    span: Span,\n-                   borrow_region: &'tcx ty::Region,\n+                   borrow_region: ty::Region<'tcx>,\n                    borrow_kind: ty::BorrowKind,\n                    borrow_cmt: mc::cmt<'tcx>) {\n         let mut borrow_cmt = borrow_cmt;\n@@ -1297,10 +1305,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// recurse and process `ref_cmt` (see case 2 above).\n     fn link_reborrowed_region(&self,\n                               span: Span,\n-                              borrow_region: &'tcx ty::Region,\n+                              borrow_region: ty::Region<'tcx>,\n                               borrow_kind: ty::BorrowKind,\n                               ref_cmt: mc::cmt<'tcx>,\n-                              ref_region: &'tcx ty::Region,\n+                              ref_region: ty::Region<'tcx>,\n                               mut ref_kind: ty::BorrowKind,\n                               note: mc::Note)\n                               -> Option<(mc::cmt<'tcx>, ty::BorrowKind)>\n@@ -1411,7 +1419,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                           origin: infer::ParameterOrigin,\n                           substs: &Substs<'tcx>,\n                           expr_span: Span,\n-                          expr_region: &'tcx ty::Region) {\n+                          expr_region: ty::Region<'tcx>) {\n         debug!(\"substs_wf_in_scope(substs={:?}, \\\n                 expr_region={:?}, \\\n                 origin={:?}, \\\n@@ -1436,7 +1444,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     pub fn type_must_outlive(&self,\n                              origin: infer::SubregionOrigin<'tcx>,\n                              ty: Ty<'tcx>,\n-                             region: &'tcx ty::Region)\n+                             region: ty::Region<'tcx>)\n     {\n         let ty = self.resolve_type(ty);\n \n@@ -1454,7 +1462,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn components_must_outlive(&self,\n                                origin: infer::SubregionOrigin<'tcx>,\n                                components: Vec<ty::outlives::Component<'tcx>>,\n-                               region: &'tcx ty::Region)\n+                               region: ty::Region<'tcx>)\n     {\n         for component in components {\n             let origin = origin.clone();\n@@ -1485,7 +1493,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn param_ty_must_outlive(&self,\n                              origin: infer::SubregionOrigin<'tcx>,\n-                             region: &'tcx ty::Region,\n+                             region: ty::Region<'tcx>,\n                              param_ty: ty::ParamTy) {\n         debug!(\"param_ty_must_outlive(region={:?}, param_ty={:?}, origin={:?})\",\n                region, param_ty, origin);\n@@ -1497,7 +1505,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn projection_must_outlive(&self,\n                                origin: infer::SubregionOrigin<'tcx>,\n-                               region: &'tcx ty::Region,\n+                               region: ty::Region<'tcx>,\n                                projection_ty: ty::ProjectionTy<'tcx>)\n     {\n         debug!(\"projection_must_outlive(region={:?}, projection_ty={:?}, origin={:?})\",\n@@ -1614,15 +1622,15 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         // Add in the default bound of fn body that applies to all in\n         // scope type parameters:\n-        param_bounds.push(param_env.implicit_region_bound);\n+        param_bounds.extend(param_env.implicit_region_bound);\n \n         VerifyBound::AnyRegion(param_bounds)\n     }\n \n     fn projection_declared_bounds(&self,\n                                   span: Span,\n                                   projection_ty: ty::ProjectionTy<'tcx>)\n-                                  -> Vec<&'tcx ty::Region>\n+                                  -> Vec<ty::Region<'tcx>>\n     {\n         // First assemble bounds from where clauses and traits.\n \n@@ -1637,7 +1645,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn projection_bound(&self,\n                         span: Span,\n-                        declared_bounds: Vec<&'tcx ty::Region>,\n+                        declared_bounds: Vec<ty::Region<'tcx>>,\n                         projection_ty: ty::ProjectionTy<'tcx>)\n                         -> VerifyBound<'tcx> {\n         debug!(\"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n@@ -1673,7 +1681,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn declared_generic_bounds_from_env(&self, generic: GenericKind<'tcx>)\n-                                        -> Vec<&'tcx ty::Region>\n+                                        -> Vec<ty::Region<'tcx>>\n     {\n         let param_env = &self.parameter_environment;\n \n@@ -1707,7 +1715,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn declared_projection_bounds_from_trait(&self,\n                                              span: Span,\n                                              projection_ty: ty::ProjectionTy<'tcx>)\n-                                             -> Vec<&'tcx ty::Region>\n+                                             -> Vec<ty::Region<'tcx>>\n     {\n         debug!(\"projection_bounds(projection_ty={:?})\",\n                projection_ty);"}, {"sha": "9bfc5f3f0ea54124091d529c92f4238cb4df3fbb", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -164,9 +164,12 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id());\n \n         {\n+            let body_owner_def_id = self.fcx.tcx.hir.body_owner_def_id(body.id());\n+            let region_maps = &self.fcx.tcx.region_maps(body_owner_def_id);\n             let mut euv =\n                 euv::ExprUseVisitor::with_options(self,\n                                                   self.fcx,\n+                                                  region_maps,\n                                                   mc::MemCategorizationOptions {\n                                                       during_closure_kind_inference: true\n                                                   });\n@@ -536,7 +539,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n               borrow_id: ast::NodeId,\n               _borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              _loan_region: &'tcx ty::Region,\n+              _loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               _loan_cause: euv::LoanCause)\n     {"}, {"sha": "1887eaef3604438340db63a690356cce992eec59", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -341,9 +341,9 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n \n             let mut implied_bounds = vec![];\n-            let free_id_outlive = fcx.tcx.region_maps.call_site_extent(item.id, body_id.node_id);\n+            let free_id_outlive = fcx.tcx.call_site_extent(item.id, body_id.node_id);\n             this.check_fn_or_method(fcx, item.span, sig, &predicates,\n-                                    free_id_outlive, &mut implied_bounds);\n+                                    Some(free_id_outlive), &mut implied_bounds);\n             implied_bounds\n         })\n     }\n@@ -429,7 +429,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                       span: Span,\n                                       sig: ty::PolyFnSig<'tcx>,\n                                       predicates: &ty::InstantiatedPredicates<'tcx>,\n-                                      free_id_outlive: CodeExtent,\n+                                      free_id_outlive: Option<CodeExtent<'tcx>>,\n                                       implied_bounds: &mut Vec<Ty<'tcx>>)\n     {\n         let free_substs = &fcx.parameter_environment.free_substs;\n@@ -453,7 +453,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                          fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                          method_sig: &hir::MethodSig,\n                                          method: &ty::AssociatedItem,\n-                                         free_id_outlive: CodeExtent,\n+                                         free_id_outlive: Option<CodeExtent<'tcx>>,\n                                          self_ty: ty::Ty<'tcx>)\n     {\n         // check that the type of the method's receiver matches the"}, {"sha": "ab2151544fc6e539d677349807a80e41e510731d", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -76,7 +76,7 @@ struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     // early-bound versions of them, visible from the\n     // outside of the function. This is needed by, and\n     // only populated if there are any `impl Trait`.\n-    free_to_bound_regions: DefIdMap<&'gcx ty::Region>,\n+    free_to_bound_regions: DefIdMap<ty::Region<'gcx>>,\n \n     body: &'gcx hir::Body,\n }\n@@ -275,7 +275,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_free_region_map(&mut self) {\n-        self.tables.free_region_map = self.fcx.tables.borrow().free_region_map.clone();\n+        let free_region_map = self.tcx().lift_to_global(&self.fcx.tables.borrow().free_region_map);\n+        let free_region_map = free_region_map.expect(\"all regions in free-region-map are global\");\n+        self.tables.free_region_map = free_region_map;\n     }\n \n     fn visit_anon_types(&mut self) {\n@@ -522,7 +524,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n \n     // FIXME This should be carefully checked\n     // We could use `self.report_error` but it doesn't accept a ty::Region, right now.\n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match self.infcx.fully_resolve(&r) {\n             Ok(r) => r,\n             Err(_) => {"}, {"sha": "49785d8850f4de72595df5d4eb08904edef7e1d9", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -12,6 +12,7 @@\n //! up data structures required by type-checking/translation.\n \n use rustc::middle::free_region::FreeRegionMap;\n+use rustc::middle::region::RegionMaps;\n use rustc::middle::lang_items::UnsizeTraitLangItem;\n \n use rustc::traits::{self, ObligationCause, Reveal};\n@@ -342,10 +343,11 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // Finally, resolve all regions.\n+        let region_maps = RegionMaps::new();\n         let mut free_regions = FreeRegionMap::new();\n         free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n             .caller_bounds);\n-        infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n+        infcx.resolve_regions_and_report_errors(impl_did, &region_maps, &free_regions);\n \n         CoerceUnsizedInfo {\n             custom_kind: kind"}, {"sha": "0d75a1ecf3d8f30c31ca61195df08f05c0db6f7e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -215,7 +215,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n \n     fn re_infer(&self, _span: Span, _def: Option<&ty::RegionParameterDef>)\n-                -> Option<&'tcx ty::Region> {\n+                -> Option<ty::Region<'tcx>> {\n         None\n     }\n "}, {"sha": "ee11b774cf26102c523c62f0a78dbcab3c69770b", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -75,7 +75,7 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         match *r {\n             ty::ReEarlyBound(data) => {\n                 self.parameters.push(Parameter::from(data));"}, {"sha": "529b2700679d57626363cda4407c8e27e234d73b", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -479,7 +479,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// context with ambient variance `variance`\n     fn add_constraints_from_region(&mut self,\n                                    generics: &ty::Generics,\n-                                   region: &'tcx ty::Region,\n+                                   region: ty::Region<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n         match *region {\n             ty::ReEarlyBound(ref data) => {"}, {"sha": "0a748487244321711d19156f46cc76d7aac13211", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -503,7 +503,7 @@ impl<'a> Iterator for ListAttributesIter<'a> {\n \n pub trait AttributesExt {\n     /// Finds an attribute as List and returns the list of attributes nested inside.\n-    fn lists<'a>(&'a self, &'a str) -> ListAttributesIter<'a>;\n+    fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a>;\n }\n \n impl AttributesExt for [ast::Attribute] {\n@@ -518,7 +518,7 @@ impl AttributesExt for [ast::Attribute] {\n \n pub trait NestedAttributesExt {\n     /// Returns whether the attribute list contains a specific `Word`\n-    fn has_word(self, &str) -> bool;\n+    fn has_word(self, word: &str) -> bool;\n }\n \n impl<I: IntoIterator<Item=ast::NestedMetaItem>> NestedAttributesExt for I {\n@@ -726,7 +726,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n             if let ty::TyTuple(ts, _) = ty_s.sty {\n                 for &ty_s in ts {\n                     if let ty::TyRef(ref reg, _) = ty_s.sty {\n-                        if let &ty::Region::ReLateBound(..) = *reg {\n+                        if let &ty::RegionKind::ReLateBound(..) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(lt) = reg.clean(cx) {\n                                 late_bounds.push(lt);\n@@ -819,7 +819,7 @@ impl Clean<Lifetime> for ty::RegionParameterDef {\n     }\n }\n \n-impl Clean<Option<Lifetime>> for ty::Region {\n+impl<'tcx> Clean<Option<Lifetime>> for ty::RegionKind<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n@@ -915,7 +915,7 @@ impl<'tcx> Clean<WherePredicate> for ty::SubtypePredicate<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<&'tcx ty::Region, &'tcx ty::Region> {\n+impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>> {\n     fn clean(&self, cx: &DocContext) -> WherePredicate {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         WherePredicate::RegionPredicate {\n@@ -925,7 +925,7 @@ impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<&'tcx ty::Region, &'t\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Ty<'tcx>, &'tcx ty::Region> {\n+impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Ty<'tcx>, ty::Region<'tcx>> {\n     fn clean(&self, cx: &DocContext) -> WherePredicate {\n         let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n "}, {"sha": "5879be08881fb9bb923960f665cec2b1c9210b1f", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -89,7 +89,7 @@ impl<'a, 'tcx> DocContext<'a, 'tcx> {\n }\n \n pub trait DocAccessLevels {\n-    fn is_doc_reachable(&self, DefId) -> bool;\n+    fn is_doc_reachable(&self, did: DefId) -> bool;\n }\n \n impl DocAccessLevels for AccessLevels<DefId> {"}, {"sha": "a40d1e6bdc91760c5062f5defbf6b2bf42c7b1e3", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -114,7 +114,7 @@ pub enum Class {\n pub trait Writer {\n     /// Called when we start processing a span of text that should be highlighted.\n     /// The `Class` argument specifies how it should be highlighted.\n-    fn enter_span(&mut self, Class) -> io::Result<()>;\n+    fn enter_span(&mut self, _: Class) -> io::Result<()>;\n \n     /// Called at the end of a span of highlighted text.\n     fn exit_span(&mut self) -> io::Result<()>;\n@@ -131,7 +131,11 @@ pub trait Writer {\n     /// ```\n     /// The latter can be thought of as a shorthand for the former, which is\n     /// more flexible.\n-    fn string<T: Display>(&mut self, T, Class, Option<&TokenAndSpan>) -> io::Result<()>;\n+    fn string<T: Display>(&mut self,\n+                          text: T,\n+                          klass: Class,\n+                          tok: Option<&TokenAndSpan>)\n+                          -> io::Result<()>;\n }\n \n // Implement `Writer` for anthing that can be written to, this just implements"}, {"sha": "23ebeb4b8e3fc17c10300a44271f80fc295e6e7d", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -1035,7 +1035,7 @@ impl Child {\n /// ```no_run\n /// use std::process;\n ///\n-/// process::exit(0x0f00);\n+/// process::exit(0x0100);\n /// ```\n ///\n /// [platform-specific behavior]: #platform-specific-behavior"}, {"sha": "09f22e8691e4ca481d89e82d03683f44b67cba22", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -52,7 +52,7 @@ pub trait AstBuilder {\n     fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy;\n \n     fn ty(&self, span: Span, ty: ast::TyKind) -> P<ast::Ty>;\n-    fn ty_path(&self, ast::Path) -> P<ast::Ty>;\n+    fn ty_path(&self, path: ast::Path) -> P<ast::Ty>;\n     fn ty_ident(&self, span: Span, idents: ast::Ident) -> P<ast::Ty>;\n \n     fn ty_rptr(&self, span: Span,"}, {"sha": "d4828be037a493d6ae46dc545a567aeb4c399275", "filename": "src/test/codegen/align-struct.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Ftest%2Fcodegen%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Ftest%2Fcodegen%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falign-struct.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+#![crate_type = \"lib\"]\n+\n+#![feature(attr_literals)]\n+#![feature(repr_align)]\n+\n+#[repr(align(64))]\n+pub struct Align64(i32);\n+\n+pub struct Nested64 {\n+    a: Align64,\n+    b: i32,\n+    c: i32,\n+    d: i8,\n+}\n+\n+pub enum Enum64 {\n+    A(Align64),\n+    B(i32),\n+}\n+\n+// CHECK-LABEL: @align64\n+#[no_mangle]\n+pub fn align64(i : i32) -> Align64 {\n+// CHECK: %a64 = alloca %Align64, align 64\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{.*}}, i8* %{{.*}}, i{{[0-9]+}} 64, i32 64, i1 false)\n+    let a64 = Align64(i);\n+    a64\n+}\n+\n+// CHECK-LABEL: @nested64\n+#[no_mangle]\n+pub fn nested64(a: Align64, b: i32, c: i32, d: i8) -> Nested64 {\n+// CHECK: %n64 = alloca %Nested64, align 64\n+// CHECK: %a = alloca %Align64, align 64\n+    let n64 = Nested64 { a, b, c, d };\n+    n64\n+}\n+\n+// CHECK-LABEL: @enum64\n+#[no_mangle]\n+pub fn enum64(a: Align64) -> Enum64 {\n+// CHECK: %e64 = alloca %Enum64, align 64\n+// CHECK: %a = alloca %Align64, align 64\n+    let e64 = Enum64::A(a);\n+    e64\n+}"}, {"sha": "76edae17dc104cd3b0336f47b2ae32f1a07dc3ea", "filename": "src/test/compile-fail/anon-params-deprecated.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Ftest%2Fcompile-fail%2Fanon-params-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/src%2Ftest%2Fcompile-fail%2Fanon-params-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fanon-params-deprecated.rs?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![forbid(anonymous_parameters)]\n+// Test for the anonymous_parameters deprecation lint (RFC 1685)\n+\n+trait T {\n+    fn foo(i32); //~ ERROR use of deprecated anonymous parameter\n+                 //~| WARNING hard error\n+\n+    fn bar_with_default_impl(String, String) {}\n+    //~^ ERROR use of deprecated anonymous parameter\n+    //~| WARNING hard error\n+    //~| ERROR use of deprecated anonymous parameter\n+    //~| WARNING hard error\n+}\n+\n+fn main() {}"}, {"sha": "778c49d144c020da249b21ad45d479ed4a754b58", "filename": "src/test/run-pass-fulldeps/issue-37290/auxiliary/lint.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/96e2c34286099eea4f51daaadbb82a8fbe99e0f6/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e2c34286099eea4f51daaadbb82a8fbe99e0f6/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs?ref=96e2c34286099eea4f51daaadbb82a8fbe99e0f6", "patch": "@@ -1,68 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This flag is needed for plugins to work:\n-// compile-flags: -C prefer-dynamic\n-\n-#![feature(plugin_registrar, rustc_private)]\n-#![crate_type = \"dylib\"]\n-#![deny(region_hierarchy)]\n-\n-extern crate syntax;\n-#[macro_use]\n-extern crate rustc;\n-extern crate rustc_plugin;\n-\n-use rustc::lint::{LateContext, LintPass, LateLintPass, LintArray, LintContext};\n-use rustc::hir;\n-use rustc::hir::intravisit::FnKind;\n-use rustc::middle::region::CodeExtent;\n-use rustc::util::nodemap::FxHashMap;\n-\n-use syntax::ast::{self, NodeId};\n-use syntax::codemap::Span;\n-\n-declare_lint!(REGION_HIERARCHY, Warn, \"warn about bogus region hierarchy\");\n-\n-struct Pass {\n-    map: FxHashMap<CodeExtent, NodeId>\n-}\n-\n-impl LintPass for Pass {\n-    fn get_lints(&self) -> LintArray { lint_array!(REGION_HIERARCHY) }\n-}\n-\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_fn(&mut self, cx: &LateContext,\n-                              fk: FnKind, _: &hir::FnDecl, body: &hir::Body,\n-                              span: Span, node: ast::NodeId)\n-    {\n-        if let FnKind::Closure(..) = fk { return }\n-\n-        let mut extent = cx.tcx.region_maps.node_extent(body.value.id);\n-        while let Some(parent) = cx.tcx.region_maps.opt_encl_scope(extent) {\n-            extent = parent;\n-        }\n-        if let Some(other) = self.map.insert(extent, node) {\n-            cx.span_lint(REGION_HIERARCHY, span, &format!(\n-                \"different fns {:?}, {:?} with the same root extent {:?}\",\n-                cx.tcx.hir.local_def_id(other),\n-                cx.tcx.hir.local_def_id(node),\n-                extent));\n-        }\n-    }\n-}\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut ::rustc_plugin::Registry) {\n-    reg.register_late_lint_pass(Box::new(\n-        Pass { map: FxHashMap() }\n-    ));\n-}"}, {"sha": "394ad92b1d8c0af38ded8f136b32f1a92441f113", "filename": "src/test/run-pass-fulldeps/issue-37290/main.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/96e2c34286099eea4f51daaadbb82a8fbe99e0f6/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e2c34286099eea4f51daaadbb82a8fbe99e0f6/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fmain.rs?ref=96e2c34286099eea4f51daaadbb82a8fbe99e0f6", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// aux-build:lint.rs\n-\n-#![feature(plugin)]\n-#![plugin(lint)]\n-\n-struct Foo {\n-}\n-\n-impl Foo {\n-    fn bar(&self) -> usize {\n-    22\n-    }\n-\n-    fn baz(&self) -> usize {\n-    22\n-    }\n-}\n-\n-fn main() { }\n-"}, {"sha": "e277ab98be10f30f945dad3570daeadf8e9c62d5", "filename": "x.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/x.py", "raw_url": "https://github.com/rust-lang/rust/raw/ed1f26ddda15b2bcf613a257e813e8b02ee14dff/x.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/x.py?ref=ed1f26ddda15b2bcf613a257e813e8b02ee14dff", "patch": "@@ -9,7 +9,7 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-# This file is only a \"symlink\" to boostrap.py, all logic should go there.\n+# This file is only a \"symlink\" to bootstrap.py, all logic should go there.\n \n import os\n import sys"}]}