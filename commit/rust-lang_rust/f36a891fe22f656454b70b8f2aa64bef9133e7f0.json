{"sha": "f36a891fe22f656454b70b8f2aa64bef9133e7f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNmE4OTFmZTIyZjY1NjQ1NGI3MGI4ZjJhYTY0YmVmOTEzM2U3ZjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-08T20:52:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-09T00:47:57Z"}, "message": "Address comments from @pnkfelix (thanks for the detailed review)", "tree": {"sha": "4482bfb8253edccb0595238adf01c57d0e6bd7d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4482bfb8253edccb0595238adf01c57d0e6bd7d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f36a891fe22f656454b70b8f2aa64bef9133e7f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f36a891fe22f656454b70b8f2aa64bef9133e7f0", "html_url": "https://github.com/rust-lang/rust/commit/f36a891fe22f656454b70b8f2aa64bef9133e7f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f36a891fe22f656454b70b8f2aa64bef9133e7f0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc3e84250868dff44ce0ea0919d9db8549dddf32", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc3e84250868dff44ce0ea0919d9db8549dddf32", "html_url": "https://github.com/rust-lang/rust/commit/bc3e84250868dff44ce0ea0919d9db8549dddf32"}], "stats": {"total": 362, "additions": 282, "deletions": 80}, "files": [{"sha": "ecb178e2c97c893530fbba35ee400711a15d1763", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f36a891fe22f656454b70b8f2aa64bef9133e7f0", "patch": "@@ -218,10 +218,10 @@ pub struct ItemVariances {\n \n #[deriving(Clone, Eq, Decodable, Encodable)]\n pub enum Variance {\n-    Covariant,\n-    Invariant,\n-    Contravariant,\n-    Bivariant,\n+    Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n+    Invariant,      // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n+    Contravariant,  // T<A> <: T<B> iff B <: A -- e.g., function param type\n+    Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n #[deriving(Decodable, Encodable)]"}, {"sha": "57581306b5d5d24d152f92c8cd17eca87ed35b6c", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=f36a891fe22f656454b70b8f2aa64bef9133e7f0", "patch": "@@ -116,7 +116,7 @@ pub fn ast_region_to_region(\n     r\n }\n \n-pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n+fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     default_span: Span,\n@@ -129,14 +129,14 @@ pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n \n         None => {\n             match rscope.anon_regions(default_span, 1) {\n-                None => {\n+                Err(()) => {\n                     debug!(\"optional region in illegal location\");\n                     this.tcx().sess.span_err(\n                         default_span, \"missing lifetime specifier\");\n                     ty::ReStatic\n                 }\n \n-                Some(rs) => {\n+                Ok(rs) => {\n                     rs[0]\n                 }\n             }\n@@ -178,7 +178,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n         let anon_regions =\n             rscope.anon_regions(path.span, expected_num_region_params);\n \n-        if supplied_num_region_params != 0 || anon_regions.is_none() {\n+        if supplied_num_region_params != 0 || anon_regions.is_err() {\n             tcx.sess.span_err(\n                 path.span,\n                 format!(\"wrong number of lifetime parameters: \\\n@@ -188,9 +188,9 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n         }\n \n         match anon_regions {\n-            Some(v) => opt_vec::from(v),\n-            None => opt_vec::from(vec::from_fn(expected_num_region_params,\n-                                               |_| ty::ReStatic)) // hokey\n+            Ok(v) => opt_vec::from(v),\n+            Err(()) => opt_vec::from(vec::from_fn(expected_num_region_params,\n+                                                  |_| ty::ReStatic)) // hokey\n         }\n     };\n \n@@ -277,8 +277,7 @@ pub static NO_REGIONS: uint = 1;\n pub static NO_TPS: uint = 2;\n \n // Parses the programmer's textual representation of a type into our\n-// internal notion of a type. `getter` is a function that returns the type\n-// corresponding to a definition ID:\n+// internal notion of a type.\n pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n     this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n "}, {"sha": "98d154a8d73b684da2a096fedf3a552cbe387a92", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f36a891fe22f656454b70b8f2aa64bef9133e7f0", "patch": "@@ -800,7 +800,6 @@ fn check_impl_methods_against_trait(ccx: @mut CrateCtxt,\n  * - impl_m_body_id: id of the method body\n  * - trait_m: the method in the trait\n  * - trait_substs: the substitutions used on the type of the trait\n- * - self_ty: the self type of the impl\n  */\n pub fn compare_impl_method(tcx: ty::ctxt,\n                            impl_generics: &ty::Generics,\n@@ -1062,8 +1061,8 @@ impl FnCtxt {\n impl RegionScope for @mut infer::InferCtxt {\n     fn anon_regions(&self,\n                     span: Span,\n-                    count: uint) -> Option<~[ty::Region]> {\n-        Some(vec::from_fn(\n+                    count: uint) -> Result<~[ty::Region], ()> {\n+        Ok(vec::from_fn(\n                 count,\n                 |_| self.next_region_var(infer::MiscVariable(span))))\n     }"}, {"sha": "36ed9f94fb71a25caadbb13987578b7881dfced8", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=f36a891fe22f656454b70b8f2aa64bef9133e7f0", "patch": "@@ -517,17 +517,17 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", tcx.sess.str_of(it.ident), it.id);\n     match it.node {\n-        // These don't define types.\n-        ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n-        ast::item_enum(ref enum_definition, ref generics) => {\n-            ensure_no_ty_param_bounds(ccx, it.span, generics, \"enumeration\");\n-            let tpt = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, tpt.ty);\n-            get_enum_variant_types(ccx,\n-                                   tpt.ty,\n-                                   enum_definition.variants,\n-                                   generics);\n-        }\n+      // These don't define types.\n+      ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n+      ast::item_enum(ref enum_definition, ref generics) => {\n+          ensure_no_ty_param_bounds(ccx, it.span, generics, \"enumeration\");\n+          let tpt = ty_of_item(ccx, it);\n+          write_ty_to_tcx(tcx, it.id, tpt.ty);\n+          get_enum_variant_types(ccx,\n+                                 tpt.ty,\n+                                 enum_definition.variants,\n+                                 generics);\n+      }\n       ast::item_impl(ref generics, ref opt_trait_ref, ref selfty, ref ms) => {\n         let i_ty_generics = ty_generics(ccx, generics, 0);\n         let selfty = ccx.to_ty(&ExplicitRscope, selfty);"}, {"sha": "9a32eafa8e4de2a0510084ed1cbed9d2db3ebbc0", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=f36a891fe22f656454b70b8f2aa64bef9133e7f0", "patch": "@@ -16,11 +16,21 @@ use syntax::ast;\n use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n \n+/// Defines strategies for handling regions that are omitted.  For\n+/// example, if one writes the type `&Foo`, then the lifetime of of\n+/// this borrowed pointer has been omitted. When converting this\n+/// type, the generic functions in astconv will invoke `anon_regions`\n+/// on the provided region-scope to decide how to translate this\n+/// omitted region.\n+///\n+/// It is not always legal to omit regions, therefore `anon_regions`\n+/// can return `Err(())` to indicate that this is not a scope in which\n+/// regions can legally be omitted.\n pub trait RegionScope {\n     fn anon_regions(&self,\n                     span: Span,\n                     count: uint)\n-                    -> Option<~[ty::Region]>;\n+                    -> Result<~[ty::Region], ()>;\n }\n \n // A scope in which all regions must be explicitly named\n@@ -30,11 +40,13 @@ impl RegionScope for ExplicitRscope {\n     fn anon_regions(&self,\n                     _span: Span,\n                     _count: uint)\n-                    -> Option<~[ty::Region]> {\n-        None\n+                    -> Result<~[ty::Region], ()> {\n+        Err(())\n     }\n }\n \n+/// A scope in which we generate anonymous, late-bound regions for\n+/// omitted regions. This occurs in function signatures.\n pub struct BindingRscope {\n     binder_id: ast::NodeId,\n     anon_bindings: @mut uint\n@@ -53,11 +65,11 @@ impl RegionScope for BindingRscope {\n     fn anon_regions(&self,\n                     _: Span,\n                     count: uint)\n-                    -> Option<~[ty::Region]> {\n+                    -> Result<~[ty::Region], ()> {\n         let idx = *self.anon_bindings;\n         *self.anon_bindings += count;\n-        Some(vec::from_fn(count, |i| ty::ReLateBound(self.binder_id,\n-                                                     ty::BrAnon(idx + i))))\n+        Ok(vec::from_fn(count, |i| ty::ReLateBound(self.binder_id,\n+                                                   ty::BrAnon(idx + i))))\n     }\n }\n "}, {"sha": "1b435d11404b1542d524317f0f50e2aebb1bd7c7", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 176, "deletions": 17, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=f36a891fe22f656454b70b8f2aa64bef9133e7f0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -15,13 +15,137 @@ algorithm is taken from Section 4 of the paper \"Taming the Wildcards:\n Combining Definition- and Use-Site Variance\" published in PLDI'11 and\n written by Altidor et al., and hereafter referred to as The Paper.\n \n+This inference is explicitly designed *not* to consider the uses of\n+types within code. To determine the variance of type parameters\n+defined on type `X`, we only consider the definition of the type `X`\n+and the definitions of any types it references.\n+\n+We only infer variance for type parameters found on *types*: structs,\n+enums, and traits. We do not infer variance for type parameters found\n+on fns or impls. This is because those things are not type definitions\n+and variance doesn't really make sense in that context.\n+\n+It is worth covering what variance means in each case. For structs and\n+enums, I think it is fairly straightforward. The variance of the type\n+or lifetime parameters defines whether `T<A>` is a subtype of `T<B>`\n+(resp. `T<'a>` and `T<'b>`) based on the relationship of `A` and `B`\n+(resp. `'a` and `'b`). (FIXME #3598 -- we do not currently make use of\n+the variances we compute for type parameters.)\n+\n+### Variance on traits\n+\n+The meaning of variance for trait parameters is more subtle and worth\n+expanding upon. There are in fact two uses of the variance values we\n+compute.\n+\n+#### Trait variance and object types\n+\n+The first is for object types. Just as with structs and enums, we can\n+decide the subtyping relationship between two object types `&Trait<A>`\n+and `&Trait<B>` based on the relationship of `A` and `B`. Note that\n+for object types we ignore the `Self` type parameter -- it is unknown,\n+and the nature of dynamic dispatch ensures that we will always call a\n+function that is expected the appropriate `Self` type. However, we\n+must be careful with the other type parameters, or else we could end\n+up calling a function that is expecting one type but provided another.\n+\n+To see what I mean, consider a trait like so:\n+\n+    trait ConvertTo<A> {\n+        fn convertTo(&self) -> A;\n+    }\n+\n+Intuitively, If we had one object `O=&ConvertTo<Object>` and another\n+`S=&ConvertTo<String>`, then `S <: O` because `String <: Object`\n+(presuming Java-like \"string\" and \"object\" types, my go to examples\n+for subtyping). The actual algorithm would be to compare the\n+(explicit) type parameters pairwise respecting their variance: here,\n+the type parameter A is covariant (it appears only in a return\n+position), and hence we require that `String <: Object`.\n+\n+You'll note though that we did not consider the binding for the\n+(implicit) `Self` type parameter: in fact, it is unknown, so that's\n+good. The reason we can ignore that parameter is precisely because we\n+don't need to know its value until a call occurs, and at that time (as\n+you said) the dynamic nature of virtual dispatch means the code we run\n+will be correct for whatever value `Self` happens to be bound to for\n+the particular object whose method we called. `Self` is thus different\n+from `A`, because the caller requires that `A` be known in order to\n+know the return type of the method `convertTo()`. (As an aside, we\n+have rules preventing methods where `Self` appears outside of the\n+receiver position from being called via an object.)\n+\n+#### Trait variance and vtable resolution\n+\n+But traits aren't only used with objects. They're also used when\n+deciding whether a given impl satisfies a given trait bound (or should\n+be -- FIXME #5781). To set the scene here, imagine I had a function:\n+\n+    fn convertAll<A,T:ConvertTo<A>>(v: &[T]) {\n+        ...\n+    }\n+\n+Now imagine that I have an implementation of `ConvertTo` for `Object`:\n+\n+    impl ConvertTo<int> for Object { ... }\n+\n+And I want to call `convertAll` on an array of strings. Suppose\n+further that for whatever reason I specifically supply the value of\n+`String` for the type parameter `T`:\n+\n+    let mut vector = ~[\"string\", ...];\n+    convertAll::<int, String>(v);\n+\n+Is this legal? To put another way, can we apply the `impl` for\n+`Object` to the type `String`? The answer is yes, but to see why\n+we have to expand out what will happen:\n+\n+- `convertAll` will create a pointer to one of the entries in the\n+  vector, which will have type `&String`\n+- It will then call the impl of `convertTo()` that is intended\n+  for use with objects. This has the type:\n+\n+      fn(self: &Object) -> int\n+\n+  It is ok to provide a value for `self` of type `&String` because\n+  `&String <: &Object`.\n+\n+OK, so intuitively we want this to be legal, so let's bring this back\n+to variance and see whether we are computing the correct result. We\n+must first figure out how to phrase the question \"is an impl for\n+`Object,int` usable where an impl for `String,int` is expected?\"\n+\n+Maybe it's helpful to think of a dictionary-passing implementation of\n+type classes. In that case, `convertAll()` takes an implicit parameter\n+representing the impl. In short, we *have* an impl of type:\n+\n+    V_O = ConvertTo<int> for Object\n+\n+and the function prototype expects an impl of type:\n+\n+    V_S = ConvertTo<int> for String\n+\n+As with any argument, this is legal if the type of the value given\n+(`V_O`) is a subtype of the type expected (`V_S`). So is `V_O <: V_S`?\n+The answer will depend on the variance of the various parameters. In\n+this case, because the `Self` parameter is contravariant and `A` is\n+covariant, it means that:\n+\n+    V_O <: V_S iff\n+        int <: int\n+        String <: Object\n+\n+These conditions are satisfied and so we are happy.\n+\n+### The algorithm\n+\n The basic idea is quite straightforward. We iterate over the types\n defined and, for each use of a type parameter X, accumulate a\n constraint indicating that the variance of X must be valid for the\n variance of that use site. We then iteratively refine the variance of\n X until all constraints are met. There is *always* a sol'n, because at\n the limit we can declare all type parameters to be invariant and all\n-constriants will be satisfied.\n+constraints will be satisfied.\n \n As a simple example, consider:\n \n@@ -46,8 +170,8 @@ results are based on a variance lattice defined as follows:\n       o      Bottom (invariant)\n \n Based on this lattice, the solution V(A)=+, V(B)=-, V(C)=o is the\n-minimal solution (which is what we are looking for; the maximal\n-solution is just that all variables are invariant. Not so exciting.).\n+optimal solution. Note that there is always a naive solution which\n+just declares all variables to be invariant.\n \n You may be wondering why fixed-point iteration is required. The reason\n is that the variance of a use site may itself be a function of the\n@@ -59,9 +183,12 @@ take the form:\n \n Here the notation V(X) indicates the variance of a type/region\n parameter `X` with respect to its defining class. `Term x Term`\n-represents the \"variance transform\" as defined in the paper -- `V1 x\n-V2` is the resulting variance when a use site with variance V2 appears\n-inside a use site with variance V1.\n+represents the \"variance transform\" as defined in the paper:\n+\n+  If the variance of a type variable `X` in type expression `E` is `V2`\n+  and the definition-site variance of the [corresponding] type parameter\n+  of a class `C` is `V1`, then the variance of `X` in the type expression\n+  `C<E>` is `V3 = V1.xform(V2)`.\n \n */\n \n@@ -128,9 +255,13 @@ struct TermsContext<'self> {\n     tcx: ty::ctxt,\n     arena: &'self Arena,\n \n+    empty_variances: @ty::ItemVariances,\n+\n     // Maps from the node id of a type/generic parameter to the\n     // corresponding inferred index.\n     inferred_map: HashMap<ast::NodeId, InferredIndex>,\n+\n+    // Maps from an InferredIndex to the info for that variable.\n     inferred_infos: ~[InferredInfo<'self>],\n }\n \n@@ -153,6 +284,12 @@ fn determine_parameters_to_be_inferred<'a>(tcx: ty::ctxt,\n         arena: arena,\n         inferred_map: HashMap::new(),\n         inferred_infos: ~[],\n+\n+        // cache and share the variance struct used for items with\n+        // no type/region parameters\n+        empty_variances: @ty::ItemVariances { self_param: None,\n+                                              type_params: opt_vec::Empty,\n+                                              region_params: opt_vec::Empty }\n     };\n \n     visit::walk_crate(&mut terms_cx, crate, ());\n@@ -228,11 +365,7 @@ impl<'self> Visitor<()> for TermsContext<'self> {\n                 if self.num_inferred() == inferreds_on_entry {\n                     let newly_added = self.tcx.item_variance_map.insert(\n                         ast_util::local_def(item.id),\n-                        @ty::ItemVariances {\n-                            self_param: None,\n-                            type_params: opt_vec::Empty,\n-                            region_params: opt_vec::Empty\n-                        });\n+                        self.empty_variances);\n                     assert!(newly_added);\n                 }\n \n@@ -262,6 +395,7 @@ impl<'self> Visitor<()> for TermsContext<'self> {\n struct ConstraintContext<'self> {\n     terms_cx: TermsContext<'self>,\n \n+    // These are pointers to common `ConstantTerm` instances\n     covariant: VarianceTermPtr<'self>,\n     contravariant: VarianceTermPtr<'self>,\n     invariant: VarianceTermPtr<'self>,\n@@ -309,7 +443,7 @@ impl<'self> Visitor<()> for ConstraintContext<'self> {\n                 // annoyingly takes it upon itself to run off and\n                 // evaluate the discriminants eagerly (*grumpy* that's\n                 // not the typical pattern). This results in double\n-                // error messagees because typeck goes off and does\n+                // error messages because typeck goes off and does\n                 // this at a later time. All we really care about is\n                 // the types of the variant arguments, so we just call\n                 // `ty::VariantInfo::from_ast_variant()` ourselves\n@@ -340,8 +474,14 @@ impl<'self> Visitor<()> for ConstraintContext<'self> {\n                 for method in methods.iter() {\n                     match method.transformed_self_ty {\n                         Some(self_ty) => {\n-                            // The self type is a parameter, so its type\n-                            // should be considered contravariant:\n+                            // The implicit self parameter is basically\n+                            // equivalent to a normal parameter declared\n+                            // like:\n+                            //\n+                            //     self : self_ty\n+                            //\n+                            // where self_ty is `&Self` or `&mut Self`\n+                            // or whatever.\n                             self.add_constraints_from_ty(\n                                 self_ty, self.contravariant);\n                         }\n@@ -465,6 +605,8 @@ impl<'self> ConstraintContext<'self> {\n         }\n     }\n \n+    /// Adds constraints appropriate for an instance of `ty` appearing\n+    /// in a context with ambient variance `variance`\n     fn add_constraints_from_ty(&mut self,\n                                ty: ty::t,\n                                variance: VarianceTermPtr<'self>) {\n@@ -558,6 +700,8 @@ impl<'self> ConstraintContext<'self> {\n         }\n     }\n \n+    /// Adds constraints appropriate for a vector with vstore `vstore`\n+    /// appearing in a context with ambient variance `variance`\n     fn add_constraints_from_vstore(&mut self,\n                                    vstore: ty::vstore,\n                                    variance: VarianceTermPtr<'self>) {\n@@ -572,6 +716,8 @@ impl<'self> ConstraintContext<'self> {\n         }\n     }\n \n+    /// Adds constraints appropriate for a nominal type (enum, struct,\n+    /// object, etc) appearing in a context with ambient variance `variance`\n     fn add_constraints_from_substs(&mut self,\n                                    def_id: ast::DefId,\n                                    generics: &ty::Generics,\n@@ -599,6 +745,8 @@ impl<'self> ConstraintContext<'self> {\n         }\n     }\n \n+    /// Adds constraints appropriate for a function with signature\n+    /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n                                 sig: &ty::FnSig,\n                                 variance: VarianceTermPtr<'self>) {\n@@ -609,6 +757,8 @@ impl<'self> ConstraintContext<'self> {\n         self.add_constraints_from_ty(sig.output, variance);\n     }\n \n+    /// Adds constraints appropriate for a region appearing in a\n+    /// context with ambient variance `variance`\n     fn add_constraints_from_region(&mut self,\n                                    region: ty::Region,\n                                    variance: VarianceTermPtr<'self>) {\n@@ -636,6 +786,8 @@ impl<'self> ConstraintContext<'self> {\n         }\n     }\n \n+    /// Adds constraints appropriate for a mutability-type pair\n+    /// appearing in a context with ambient variance `variance`\n     fn add_constraints_from_mt(&mut self,\n                                mt: &ty::mt,\n                                variance: VarianceTermPtr<'self>) {\n@@ -657,13 +809,15 @@ impl<'self> ConstraintContext<'self> {\n  *\n  * The final phase iterates over the constraints, refining the variance\n  * for each inferred until a fixed point is reached. This will be the\n- * maximal solution to the constraints. The final variance for each\n+ * optimal solution to the constraints. The final variance for each\n  * inferred is then written into the `variance_map` in the tcx.\n  */\n \n struct SolveContext<'self> {\n     terms_cx: TermsContext<'self>,\n     constraints: ~[Constraint<'self>],\n+\n+    // Maps from an InferredIndex to the inferred value for that variable.\n     solutions: ~[ty::Variance]\n }\n \n@@ -715,7 +869,12 @@ impl<'self> SolveContext<'self> {\n         // Collect all the variances for a particular item and stick\n         // them into the variance map. We rely on the fact that we\n         // generate all the inferreds for a particular item\n-        // consecutively.\n+        // consecutively (that is, we collect solutions for an item\n+        // until we see a new item id, and we assume (1) the solutions\n+        // are in the same order as the type parameters were declared\n+        // and (2) all solutions or a given item appear before a new\n+        // item id).\n+\n         let tcx = self.terms_cx.tcx;\n         let item_variance_map = tcx.item_variance_map;\n         let solutions = &self.solutions;"}, {"sha": "88a8bbf7cf28f104fecda06bdb0e76c1796cf51a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f36a891fe22f656454b70b8f2aa64bef9133e7f0", "patch": "@@ -259,12 +259,6 @@ pub enum DefRegion {\n     DefFreeRegion(/* block scope */ NodeId, /* lifetime decl */ NodeId),\n }\n \n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n-pub struct DefNamedRegion {\n-    node_id: NodeId,\n-    depth: uint,\n-}\n-\n // The set of MetaItems that define the compilation environment of the crate,\n // used to drive conditional compilation\n pub type CrateConfig = ~[@MetaItem];"}, {"sha": "5ac4afb6bfce1c3594928c404f414d6e2954d06f", "filename": "src/test/compile-fail/regions-variance-contravariant-use-covariant.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs?ref=f36a891fe22f656454b70b8f2aa64bef9133e7f0", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type which is covariant with respect to its region\n+// parameter yields an error when used in a contravariant way.\n+//\n+// Note: see variance-regions-*.rs for the tests that check that the\n+// variance inference works in the first place.\n+\n+// This is covariant with respect to 'a, meaning that\n+// Covariant<'foo> <: Covariant<'static> because\n+// 'foo <= 'static\n+struct Contravariant<'a> {\n+    f: &'a int\n+}\n+\n+fn use_<'short,'long>(c: Contravariant<'short>,\n+                      s: &'short int,\n+                      l: &'long int,\n+                      _where:Option<&'short &'long ()>) {\n+\n+    // Test whether Contravariant<'short> <: Contravariant<'long>.  Since\n+    // 'short <= 'long, this would be true if the Contravariant type were\n+    // covariant with respect to its parameter 'a.\n+\n+    let _: Contravariant<'long> = c; //~ ERROR mismatched types\n+    //~^ ERROR  cannot infer an appropriate lifetime\n+}\n+\n+fn main() {}"}, {"sha": "5cc3f1bdc3780e7066c372bfeb9615ba5efcd891", "filename": "src/test/compile-fail/regions-variance-covariant-use-contravariant.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs?ref=f36a891fe22f656454b70b8f2aa64bef9133e7f0", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that a type which is contravariant with respect to its region\n-// parameter yields an error when used in a covariant way.\n+// Test that a type which is covariant with respect to its region\n+// parameter yields an error when used in a contravariant way.\n //\n // Note: see variance-regions-*.rs for the tests that check that the\n // variance inference works in the first place.\n@@ -21,18 +21,17 @@ struct Covariant<'a> {\n     f: extern \"Rust\" fn(&'a int)\n }\n \n-fn use_<'a>(c: Covariant<'a>) {\n-    let x = 3;\n+fn use_<'short,'long>(c: Covariant<'long>,\n+                      s: &'short int,\n+                      l: &'long int,\n+                      _where:Option<&'short &'long ()>) {\n \n-    // 'b winds up being inferred to 'a because\n-    // Covariant<'a> <: Covariant<'b> => 'a <= 'b\n-    //\n-    // Borrow checker then reports an error because `x` does not\n-    // have the lifetime 'a.\n-    collapse(&x, c); //~ ERROR borrowed value does not live long enough\n+    // Test whether Covariant<'long> <: Covariant<'short>.  Since\n+    // 'short <= 'long, this would be true if the Covariant type were\n+    // contravariant with respect to its parameter 'a.\n \n-\n-    fn collapse<'b>(x: &'b int, c: Covariant<'b>) { }\n+    let _: Covariant<'short> = c; //~ ERROR mismatched types\n+    //~^ ERROR  cannot infer an appropriate lifetime\n }\n \n fn main() {}"}, {"sha": "2180964083250076de1ee65a21f20a61fabd65f7", "filename": "src/test/compile-fail/regions-variance-invariant-use-contravariant.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs?ref=f36a891fe22f656454b70b8f2aa64bef9133e7f0", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that a covariant region parameter used in a covariant position\n+// Test that an invariant region parameter used in a contravariant way\n // yields an error.\n //\n // Note: see variance-regions-*.rs for the tests that check that the\n@@ -18,16 +18,16 @@ struct Invariant<'a> {\n     f: &'static mut &'a int\n }\n \n-fn use_<'a>(c: Invariant<'a>) {\n-    let x = 3;\n+fn use_<'short,'long>(c: Invariant<'long>,\n+                      s: &'short int,\n+                      l: &'long int,\n+                      _where:Option<&'short &'long ()>) {\n \n-    // 'b winds up being inferred to 'a, because that is the\n-    // only way that Invariant<'a> <: Invariant<'b>, and hence\n-    // we get an error in the borrow checker because &x cannot\n-    // live that long\n-    collapse(&x, c); //~ ERROR borrowed value does not live long enough\n+    // Test whether Invariant<'long> <: Invariant<'short>.  Since\n+    // 'short <= 'long, this would be true if the Invariant type were\n+    // contravariant with respect to its parameter 'a.\n \n-    fn collapse<'b>(x: &'b int, c: Invariant<'b>) { }\n+    let _: Invariant<'short> = c; //~ ERROR lifetime mistach\n }\n \n fn main() { }"}, {"sha": "9cdd05f8ebe1853752b468644bd39d8c5d3e8212", "filename": "src/test/compile-fail/regions-variance-invariant-use-covariant.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f36a891fe22f656454b70b8f2aa64bef9133e7f0/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-covariant.rs?ref=f36a891fe22f656454b70b8f2aa64bef9133e7f0", "patch": "@@ -18,9 +18,12 @@ struct Invariant<'a> {\n     f: &'static mut &'a int\n }\n \n-fn use_<'a>(c: Invariant<'a>) {\n-    // For this assignment to be legal, Invariant<'a> <: Invariant<'static>,\n-    // which (if Invariant were covariant) would require 'a <= 'static.\n+fn use_<'b>(c: Invariant<'b>) {\n+\n+    // For this assignment to be legal, Invariant<'b> <: Invariant<'static>.\n+    // Since 'b <= 'static, this would be true if Invariant were covariant\n+    // with respect to its parameter 'a.\n+\n     let _: Invariant<'static> = c; //~ ERROR mismatched types\n }\n "}]}