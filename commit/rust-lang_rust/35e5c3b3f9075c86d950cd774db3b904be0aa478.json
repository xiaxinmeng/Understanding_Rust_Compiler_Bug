{"sha": "35e5c3b3f9075c86d950cd774db3b904be0aa478", "node_id": "C_kwDOAAsO6NoAKDM1ZTVjM2IzZjkwNzVjODZkOTUwY2Q3NzRkYjNiOTA0YmUwYWE0Nzg", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-01-26T17:31:07Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-01-26T17:31:07Z"}, "message": "Fix resolution of eager macro contents", "tree": {"sha": "d602351e47f3d436dca5447ed87139677c13ab39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d602351e47f3d436dca5447ed87139677c13ab39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35e5c3b3f9075c86d950cd774db3b904be0aa478", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35e5c3b3f9075c86d950cd774db3b904be0aa478", "html_url": "https://github.com/rust-lang/rust/commit/35e5c3b3f9075c86d950cd774db3b904be0aa478", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35e5c3b3f9075c86d950cd774db3b904be0aa478/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f0c20e8ba6e48a14f50e77ce1a472a6543182b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f0c20e8ba6e48a14f50e77ce1a472a6543182b7", "html_url": "https://github.com/rust-lang/rust/commit/1f0c20e8ba6e48a14f50e77ce1a472a6543182b7"}], "stats": {"total": 680, "additions": 375, "deletions": 305}, "files": [{"sha": "4aeb714189a59b0eb710f634920ad82fedc76d63", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=35e5c3b3f9075c86d950cd774db3b904be0aa478", "patch": "@@ -713,7 +713,7 @@ impl Attr {\n         hygiene: &Hygiene,\n         id: AttrId,\n     ) -> Option<Attr> {\n-        let path = Interned::new(ModPath::from_src(db, ast.path()?, hygiene)?);\n+        let path = Interned::new(ModPath::from_src(db.upcast(), ast.path()?, hygiene)?);\n         let input = if let Some(ast::Expr::Literal(lit)) = ast.expr() {\n             let value = match lit.kind() {\n                 ast::LiteralKind::String(string) => string.value()?.into(),"}, {"sha": "22d593a7d97b46411c31d78f62a4037de5998293", "filename": "crates/hir_def/src/find_path.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ffind_path.rs?ref=35e5c3b3f9075c86d950cd774db3b904be0aa478", "patch": "@@ -35,7 +35,12 @@ pub fn find_path_prefixed(\n \n const MAX_PATH_LEN: usize = 15;\n \n-impl ModPath {\n+trait ModPathExt {\n+    fn starts_with_std(&self) -> bool;\n+    fn can_start_with_std(&self) -> bool;\n+}\n+\n+impl ModPathExt for ModPath {\n     fn starts_with_std(&self) -> bool {\n         self.segments().first() == Some(&known::std)\n     }"}, {"sha": "4547bfc55e6c061cae9d52d19152c20ad1c39ee3", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=35e5c3b3f9075c86d950cd774db3b904be0aa478", "patch": "@@ -502,7 +502,7 @@ impl<'a> Ctx<'a> {\n     }\n \n     fn lower_macro_call(&mut self, m: &ast::MacroCall) -> Option<FileItemTreeId<MacroCall>> {\n-        let path = Interned::new(ModPath::from_src(self.db, m.path()?, self.hygiene())?);\n+        let path = Interned::new(ModPath::from_src(self.db.upcast(), m.path()?, self.hygiene())?);\n         let ast_id = self.source_ast_id_map.ast_id(m);\n         let expand_to = hir_expand::ExpandTo::from_call_site(m);\n         let res = MacroCall { path, ast_id, expand_to };\n@@ -769,7 +769,7 @@ impl UseTreeLowering<'_> {\n                 // E.g. `use something::{inner}` (prefix is `None`, path is `something`)\n                 // or `use something::{path::{inner::{innerer}}}` (prefix is `something::path`, path is `inner`)\n                 Some(path) => {\n-                    match ModPath::from_src(self.db, path, self.hygiene) {\n+                    match ModPath::from_src(self.db.upcast(), path, self.hygiene) {\n                         Some(it) => Some(it),\n                         None => return None, // FIXME: report errors somewhere\n                     }\n@@ -788,7 +788,7 @@ impl UseTreeLowering<'_> {\n         } else {\n             let is_glob = tree.star_token().is_some();\n             let path = match tree.path() {\n-                Some(path) => Some(ModPath::from_src(self.db, path, self.hygiene)?),\n+                Some(path) => Some(ModPath::from_src(self.db.upcast(), path, self.hygiene)?),\n                 None => None,\n             };\n             let alias = tree.rename().map(|a| {"}, {"sha": "db1e65d080e03848a947f93152dd9ab651ebcaa5", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=35e5c3b3f9075c86d950cd774db3b904be0aa478", "patch": "@@ -64,11 +64,11 @@ use hir_expand::{\n     eager::{expand_eager_macro, ErrorEmitted, ErrorSink},\n     hygiene::Hygiene,\n     AstId, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+    UnresolvedMacro,\n };\n use item_tree::ExternBlock;\n use la_arena::Idx;\n use nameres::DefMap;\n-use path::ModPath;\n use stdx::impl_from;\n use syntax::ast;\n \n@@ -677,7 +677,8 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n         let expands_to = hir_expand::ExpandTo::from_call_site(self.value);\n         let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(self.value));\n         let h = Hygiene::new(db.upcast(), self.file_id);\n-        let path = self.value.path().and_then(|path| path::ModPath::from_src(db, path, &h));\n+        let path =\n+            self.value.path().and_then(|path| path::ModPath::from_src(db.upcast(), path, &h));\n \n         let path = match error_sink\n             .option(path, || mbe::ExpandError::Other(\"malformed macro invocation\".into()))\n@@ -712,11 +713,6 @@ impl<T: ast::AstNode> AstIdWithPath<T> {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct UnresolvedMacro {\n-    pub path: ModPath,\n-}\n-\n fn macro_call_as_call_id(\n     call: &AstIdWithPath<ast::MacroCall>,\n     expand_to: ExpandTo,\n@@ -730,16 +726,8 @@ fn macro_call_as_call_id(\n \n     let res = if let MacroDefKind::BuiltInEager(..) = def.kind {\n         let macro_call = InFile::new(call.ast_id.file_id, call.ast_id.to_node(db.upcast()));\n-        let hygiene = Hygiene::new(db.upcast(), call.ast_id.file_id);\n \n-        expand_eager_macro(\n-            db.upcast(),\n-            krate,\n-            macro_call,\n-            def,\n-            &|path: ast::Path| resolver(path::ModPath::from_src(db, path, &hygiene)?),\n-            error_sink,\n-        )\n+        expand_eager_macro(db.upcast(), krate, macro_call, def, &resolver, error_sink)?\n     } else {\n         Ok(def.as_lazy_macro(\n             db.upcast(),"}, {"sha": "5d770ecab0ec65489ec238113bfa95a8f71e0ae8", "filename": "crates/hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=35e5c3b3f9075c86d950cd774db3b904be0aa478", "patch": "@@ -1046,3 +1046,71 @@ m!(\n         \"#]],\n     )\n }\n+\n+#[test]\n+fn eager_macro_correctly_resolves_contents() {\n+    // Eager macros resolve any contained macros when expanded. This should work correctly with the\n+    // usual name resolution rules, so both of these `include!`s should include the right file.\n+\n+    check(\n+        r#\"\n+//- /lib.rs\n+#[rustc_builtin_macro]\n+macro_rules! include { () => {} }\n+\n+include!(inner_a!());\n+include!(crate::inner_b!());\n+\n+#[macro_export]\n+macro_rules! inner_a {\n+    () => { \"inc_a.rs\" };\n+}\n+#[macro_export]\n+macro_rules! inner_b {\n+    () => { \"inc_b.rs\" };\n+}\n+//- /inc_a.rs\n+struct A;\n+//- /inc_b.rs\n+struct B;\n+\"#,\n+        expect![[r#\"\n+        crate\n+        A: t v\n+        B: t v\n+        inner_a: m\n+        inner_b: m\n+    \"#]],\n+    );\n+}\n+\n+#[test]\n+fn eager_macro_correctly_resolves_dollar_crate() {\n+    check(\n+        r#\"\n+//- /lib.rs\n+#[rustc_builtin_macro]\n+macro_rules! include { () => {} }\n+\n+#[macro_export]\n+macro_rules! inner {\n+    () => { \"inc.rs\" };\n+}\n+\n+macro_rules! m {\n+    () => { include!($crate::inner!()); };\n+}\n+\n+m!();\n+\n+//- /inc.rs\n+struct A;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            inner: m\n+        \"#]],\n+    );\n+\n+    // FIXME: This currently fails. The result should contain `A: t v`.\n+}"}, {"sha": "fc81b88db3f1c58639be629248fa3be859b1f102", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 5, "deletions": 162, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=35e5c3b3f9075c86d950cd774db3b904be0aa478", "patch": "@@ -6,33 +6,13 @@ use std::{\n     iter,\n };\n \n-use crate::{body::LowerCtx, db::DefDatabase, intern::Interned, type_ref::LifetimeRef};\n-use base_db::CrateId;\n-use hir_expand::{\n-    hygiene::Hygiene,\n-    name::{name, Name},\n-};\n+use crate::{body::LowerCtx, intern::Interned, type_ref::LifetimeRef};\n+use hir_expand::name::{name, Name};\n use syntax::ast;\n \n use crate::type_ref::{TypeBound, TypeRef};\n \n-#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct ModPath {\n-    pub kind: PathKind,\n-    segments: Vec<Name>,\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub enum PathKind {\n-    Plain,\n-    /// `self::` is `Super(0)`\n-    Super(u8),\n-    Crate,\n-    /// Absolute path (::foo)\n-    Abs,\n-    /// `$crate` from macro expansion\n-    DollarCrate(CrateId),\n-}\n+pub use hir_expand::mod_path::{path, ModPath, PathKind};\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ImportAlias {\n@@ -51,67 +31,6 @@ impl Display for ImportAlias {\n     }\n }\n \n-impl ModPath {\n-    pub fn from_src(db: &dyn DefDatabase, path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n-        lower::convert_path(db, None, path, hygiene)\n-    }\n-\n-    pub fn from_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> ModPath {\n-        let segments = segments.into_iter().collect::<Vec<_>>();\n-        ModPath { kind, segments }\n-    }\n-\n-    /// Creates a `ModPath` from a `PathKind`, with no extra path segments.\n-    pub const fn from_kind(kind: PathKind) -> ModPath {\n-        ModPath { kind, segments: Vec::new() }\n-    }\n-\n-    pub fn segments(&self) -> &[Name] {\n-        &self.segments\n-    }\n-\n-    pub fn push_segment(&mut self, segment: Name) {\n-        self.segments.push(segment);\n-    }\n-\n-    pub fn pop_segment(&mut self) -> Option<Name> {\n-        self.segments.pop()\n-    }\n-\n-    /// Returns the number of segments in the path (counting special segments like `$crate` and\n-    /// `super`).\n-    pub fn len(&self) -> usize {\n-        self.segments.len()\n-            + match self.kind {\n-                PathKind::Plain => 0,\n-                PathKind::Super(i) => i as usize,\n-                PathKind::Crate => 1,\n-                PathKind::Abs => 0,\n-                PathKind::DollarCrate(_) => 1,\n-            }\n-    }\n-\n-    pub fn is_ident(&self) -> bool {\n-        self.as_ident().is_some()\n-    }\n-\n-    pub fn is_self(&self) -> bool {\n-        self.kind == PathKind::Super(0) && self.segments.is_empty()\n-    }\n-\n-    /// If this path is a single identifier, like `foo`, return its name.\n-    pub fn as_ident(&self) -> Option<&Name> {\n-        if self.kind != PathKind::Plain {\n-            return None;\n-        }\n-\n-        match &*self.segments {\n-            [name] => Some(name),\n-            _ => None,\n-        }\n-    }\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     /// Type based path like `<T>::foo`.\n@@ -185,10 +104,7 @@ impl Path {\n     }\n \n     pub fn segments(&self) -> PathSegments<'_> {\n-        PathSegments {\n-            segments: self.mod_path.segments.as_slice(),\n-            generic_args: &self.generic_args,\n-        }\n+        PathSegments { segments: self.mod_path.segments(), generic_args: &self.generic_args }\n     }\n \n     pub fn mod_path(&self) -> &ModPath {\n@@ -203,7 +119,7 @@ impl Path {\n             type_anchor: self.type_anchor.clone(),\n             mod_path: Interned::new(ModPath::from_segments(\n                 self.mod_path.kind.clone(),\n-                self.mod_path.segments[..self.mod_path.segments.len() - 1].iter().cloned(),\n+                self.mod_path.segments()[..self.mod_path.segments().len() - 1].iter().cloned(),\n             )),\n             generic_args: self.generic_args[..self.generic_args.len() - 1].to_vec().into(),\n         };\n@@ -296,76 +212,3 @@ impl From<Name> for Box<Path> {\n         Box::new(Path::from(name))\n     }\n }\n-\n-impl From<Name> for ModPath {\n-    fn from(name: Name) -> ModPath {\n-        ModPath::from_segments(PathKind::Plain, iter::once(name))\n-    }\n-}\n-\n-impl Display for ModPath {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut first_segment = true;\n-        let mut add_segment = |s| -> fmt::Result {\n-            if !first_segment {\n-                f.write_str(\"::\")?;\n-            }\n-            first_segment = false;\n-            f.write_str(s)?;\n-            Ok(())\n-        };\n-        match self.kind {\n-            PathKind::Plain => {}\n-            PathKind::Super(0) => add_segment(\"self\")?,\n-            PathKind::Super(n) => {\n-                for _ in 0..n {\n-                    add_segment(\"super\")?;\n-                }\n-            }\n-            PathKind::Crate => add_segment(\"crate\")?,\n-            PathKind::Abs => add_segment(\"\")?,\n-            PathKind::DollarCrate(_) => add_segment(\"$crate\")?,\n-        }\n-        for segment in &self.segments {\n-            if !first_segment {\n-                f.write_str(\"::\")?;\n-            }\n-            first_segment = false;\n-            write!(f, \"{}\", segment)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-pub use hir_expand::name as __name;\n-\n-#[macro_export]\n-macro_rules! __known_path {\n-    (core::iter::IntoIterator) => {};\n-    (core::iter::Iterator) => {};\n-    (core::result::Result) => {};\n-    (core::option::Option) => {};\n-    (core::ops::Range) => {};\n-    (core::ops::RangeFrom) => {};\n-    (core::ops::RangeFull) => {};\n-    (core::ops::RangeTo) => {};\n-    (core::ops::RangeToInclusive) => {};\n-    (core::ops::RangeInclusive) => {};\n-    (core::future::Future) => {};\n-    (core::ops::Try) => {};\n-    ($path:path) => {\n-        compile_error!(\"Please register your known path in the path module\")\n-    };\n-}\n-\n-#[macro_export]\n-macro_rules! __path {\n-    ($start:ident $(:: $seg:ident)*) => ({\n-        $crate::__known_path!($start $(:: $seg)*);\n-        $crate::path::ModPath::from_segments($crate::path::PathKind::Abs, vec![\n-            $crate::path::__name![$start], $($crate::path::__name![$seg],)*\n-        ])\n-    });\n-}\n-\n-pub use crate::__path as path;"}, {"sha": "49e55e03d117337b5025e3395ad0145c47e61b20", "filename": "crates/hir_def/src/path/lower.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs?ref=35e5c3b3f9075c86d950cd774db3b904be0aa478", "patch": "@@ -1,7 +1,5 @@\n //! Transforms syntax into `Path` objects, ideally with accounting for hygiene\n \n-mod lower_use;\n-\n use crate::intern::Interned;\n \n use either::Either;\n@@ -15,8 +13,6 @@ use crate::{\n     type_ref::{LifetimeRef, TypeBound, TypeRef},\n };\n \n-pub(super) use lower_use::convert_path;\n-\n /// Converts an `ast::Path` to `Path`. Works with use trees.\n /// It correctly handles `$crate` based path from macro call.\n pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx) -> Option<Path> {\n@@ -72,10 +68,10 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx) -> Option<Path> {\n                     Some(trait_ref) => {\n                         let Path { mod_path, generic_args: path_generic_args, .. } =\n                             Path::from_src(trait_ref.path()?, ctx)?;\n-                        let num_segments = mod_path.segments.len();\n+                        let num_segments = mod_path.segments().len();\n                         kind = mod_path.kind;\n \n-                        segments.extend(mod_path.segments.iter().cloned().rev());\n+                        segments.extend(mod_path.segments().iter().cloned().rev());\n                         generic_args.extend(Vec::from(path_generic_args).into_iter().rev());\n \n                         // Insert the type reference (T in the above example) as Self parameter for the trait"}, {"sha": "6b777cfeff4ec4e6787b7b08f170ecdaf9cb8828", "filename": "crates/hir_def/src/path/lower/lower_use.rs", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1f0c20e8ba6e48a14f50e77ce1a472a6543182b7/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0c20e8ba6e48a14f50e77ce1a472a6543182b7/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=1f0c20e8ba6e48a14f50e77ce1a472a6543182b7", "patch": "@@ -1,88 +0,0 @@\n-//! Lowers a single complex use like `use foo::{bar, baz};` into a list of paths like\n-//! `foo::bar`, `foo::baz`;\n-\n-use std::iter;\n-\n-use either::Either;\n-use hir_expand::hygiene::Hygiene;\n-use syntax::{ast, AstNode};\n-\n-use crate::{\n-    db::DefDatabase,\n-    path::{ModPath, PathKind},\n-};\n-\n-pub(crate) fn convert_path(\n-    db: &dyn DefDatabase,\n-    prefix: Option<ModPath>,\n-    path: ast::Path,\n-    hygiene: &Hygiene,\n-) -> Option<ModPath> {\n-    let prefix = match path.qualifier() {\n-        Some(qual) => Some(convert_path(db, prefix, qual, hygiene)?),\n-        None => prefix,\n-    };\n-\n-    let segment = path.segment()?;\n-    let mut mod_path = match segment.kind()? {\n-        ast::PathSegmentKind::Name(name_ref) => {\n-            match hygiene.name_ref_to_name(db.upcast(), name_ref) {\n-                Either::Left(name) => {\n-                    // no type args in use\n-                    let mut res = prefix.unwrap_or_else(|| {\n-                        ModPath::from_kind(\n-                            segment.coloncolon_token().map_or(PathKind::Plain, |_| PathKind::Abs),\n-                        )\n-                    });\n-                    res.segments.push(name);\n-                    res\n-                }\n-                Either::Right(crate_id) => {\n-                    return Some(ModPath::from_segments(\n-                        PathKind::DollarCrate(crate_id),\n-                        iter::empty(),\n-                    ))\n-                }\n-            }\n-        }\n-        ast::PathSegmentKind::CrateKw => {\n-            if prefix.is_some() {\n-                return None;\n-            }\n-            ModPath::from_segments(PathKind::Crate, iter::empty())\n-        }\n-        ast::PathSegmentKind::SelfKw => {\n-            if prefix.is_some() {\n-                return None;\n-            }\n-            ModPath::from_segments(PathKind::Super(0), iter::empty())\n-        }\n-        ast::PathSegmentKind::SuperKw => {\n-            let nested_super_count = match prefix.map(|p| p.kind) {\n-                Some(PathKind::Super(n)) => n,\n-                Some(_) => return None,\n-                None => 0,\n-            };\n-\n-            ModPath::from_segments(PathKind::Super(nested_super_count + 1), iter::empty())\n-        }\n-        ast::PathSegmentKind::Type { .. } => {\n-            // not allowed in imports\n-            return None;\n-        }\n-    };\n-\n-    // handle local_inner_macros :\n-    // Basically, even in rustc it is quite hacky:\n-    // https://github.com/rust-lang/rust/blob/614f273e9388ddd7804d5cbc80b8865068a3744e/src/librustc_resolve/macros.rs#L456\n-    // We follow what it did anyway :)\n-    if mod_path.segments.len() == 1 && mod_path.kind == PathKind::Plain {\n-        if let Some(_macro_call) = path.syntax().parent().and_then(ast::MacroCall::cast) {\n-            if let Some(crate_id) = hygiene.local_inner_macros(db.upcast(), path) {\n-                mod_path.kind = PathKind::DollarCrate(crate_id);\n-            }\n-        }\n-    }\n-\n-    Some(mod_path)\n-}"}, {"sha": "80009010c52187ddf6f4a533708b8cbacf468024", "filename": "crates/hir_def/src/visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fvisibility.rs?ref=35e5c3b3f9075c86d950cd774db3b904be0aa478", "patch": "@@ -56,7 +56,7 @@ impl RawVisibility {\n         };\n         match node.kind() {\n             ast::VisibilityKind::In(path) => {\n-                let path = ModPath::from_src(db, path, hygiene);\n+                let path = ModPath::from_src(db.upcast(), path, hygiene);\n                 let path = match path {\n                     None => return RawVisibility::private(),\n                     Some(path) => path,"}, {"sha": "faeb6bebabbe31323710e2496d019eb5ca993603", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=35e5c3b3f9075c86d950cd774db3b904be0aa478", "patch": "@@ -27,8 +27,10 @@ use syntax::{ted, SyntaxNode};\n use crate::{\n     ast::{self, AstNode},\n     db::AstDatabase,\n+    hygiene::Hygiene,\n+    mod_path::ModPath,\n     EagerCallInfo, ExpandTo, InFile, MacroCallId, MacroCallKind, MacroCallLoc, MacroDefId,\n-    MacroDefKind,\n+    MacroDefKind, UnresolvedMacro,\n };\n \n #[derive(Debug)]\n@@ -94,18 +96,14 @@ impl ErrorSink for &'_ mut dyn FnMut(mbe::ExpandError) {\n     }\n }\n \n-fn err(msg: impl Into<String>) -> mbe::ExpandError {\n-    mbe::ExpandError::Other(msg.into())\n-}\n-\n pub fn expand_eager_macro(\n     db: &dyn AstDatabase,\n     krate: CrateId,\n     macro_call: InFile<ast::MacroCall>,\n     def: MacroDefId,\n-    resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n+    resolver: &dyn Fn(ModPath) -> Option<MacroDefId>,\n     diagnostic_sink: &mut dyn FnMut(mbe::ExpandError),\n-) -> Result<MacroCallId, ErrorEmitted> {\n+) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n     let parsed_args = macro_call\n         .value\n         .token_tree()\n@@ -129,16 +127,19 @@ pub fn expand_eager_macro(\n         }),\n         kind: MacroCallKind::FnLike { ast_id: call_id, expand_to: ExpandTo::Expr },\n     });\n-    let arg_file_id = arg_id;\n \n     let parsed_args = mbe::token_tree_to_syntax_node(&parsed_args, mbe::TopEntryPoint::Expr).0;\n-    let result = eager_macro_recur(\n+    let result = match eager_macro_recur(\n         db,\n-        InFile::new(arg_file_id.as_file(), parsed_args.syntax_node()),\n+        InFile::new(arg_id.as_file(), parsed_args.syntax_node()),\n         krate,\n         resolver,\n         diagnostic_sink,\n-    )?;\n+    ) {\n+        Ok(Ok(it)) => it,\n+        Ok(Err(err)) => return Ok(Err(err)),\n+        Err(err) => return Err(err),\n+    };\n     let subtree = to_subtree(&result);\n \n     if let MacroDefKind::BuiltInEager(eager, _) = def.kind {\n@@ -157,7 +158,7 @@ pub fn expand_eager_macro(\n             kind: MacroCallKind::FnLike { ast_id: call_id, expand_to },\n         };\n \n-        Ok(db.intern_macro_call(loc))\n+        Ok(Ok(db.intern_macro_call(loc)))\n     } else {\n         panic!(\"called `expand_eager_macro` on non-eager macro def {:?}\", def);\n     }\n@@ -194,33 +195,38 @@ fn eager_macro_recur(\n     db: &dyn AstDatabase,\n     curr: InFile<SyntaxNode>,\n     krate: CrateId,\n-    macro_resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n+    macro_resolver: &dyn Fn(ModPath) -> Option<MacroDefId>,\n     mut diagnostic_sink: &mut dyn FnMut(mbe::ExpandError),\n-) -> Result<SyntaxNode, ErrorEmitted> {\n+) -> Result<Result<SyntaxNode, ErrorEmitted>, UnresolvedMacro> {\n+    let hygiene = Hygiene::new(db, curr.file_id);\n     let original = curr.value.clone_for_update();\n \n     let children = original.descendants().filter_map(ast::MacroCall::cast);\n     let mut replacements = Vec::new();\n \n     // Collect replacement\n     for child in children {\n-        let def = diagnostic_sink.option_with(\n-            || macro_resolver(child.path()?),\n-            || {\n-                let path = child.path().map(|path| format!(\" `{}!`\", path)).unwrap_or_default();\n-                err(format!(\"failed to resolve macro{}\", path))\n-            },\n-        )?;\n+        let def = match child.path().and_then(|path| ModPath::from_src(db, path, &hygiene)) {\n+            Some(path) => macro_resolver(path.clone()).ok_or_else(|| UnresolvedMacro { path })?,\n+            None => {\n+                diagnostic_sink(mbe::ExpandError::Other(\"malformed macro invocation\".into()));\n+                continue;\n+            }\n+        };\n         let insert = match def.kind {\n             MacroDefKind::BuiltInEager(..) => {\n-                let id = expand_eager_macro(\n+                let id = match expand_eager_macro(\n                     db,\n                     krate,\n                     curr.with_value(child.clone()),\n                     def,\n                     macro_resolver,\n                     diagnostic_sink,\n-                )?;\n+                ) {\n+                    Ok(Ok(it)) => it,\n+                    Ok(Err(err)) => return Ok(Err(err)),\n+                    Err(err) => return Err(err),\n+                };\n                 db.parse_or_expand(id.as_file())\n                     .expect(\"successful macro expansion should be parseable\")\n                     .clone_for_update()\n@@ -231,21 +237,28 @@ fn eager_macro_recur(\n             | MacroDefKind::BuiltInDerive(..)\n             | MacroDefKind::ProcMacro(..) => {\n                 let res = lazy_expand(db, &def, curr.with_value(child.clone()), krate);\n-                let val = diagnostic_sink.expand_result_option(res)?;\n+                let val = match diagnostic_sink.expand_result_option(res) {\n+                    Ok(it) => it,\n+                    Err(err) => return Ok(Err(err)),\n+                };\n \n                 // replace macro inside\n-                eager_macro_recur(db, val, krate, macro_resolver, diagnostic_sink)?\n+                match eager_macro_recur(db, val, krate, macro_resolver, diagnostic_sink) {\n+                    Ok(Ok(it)) => it,\n+                    Ok(Err(err)) => return Ok(Err(err)),\n+                    Err(err) => return Err(err),\n+                }\n             }\n         };\n \n         // check if the whole original syntax is replaced\n         if child.syntax() == &original {\n-            return Ok(insert);\n+            return Ok(Ok(insert));\n         }\n \n         replacements.push((child, insert));\n     }\n \n     replacements.into_iter().rev().for_each(|(old, new)| ted::replace(old.syntax(), new));\n-    Ok(original)\n+    Ok(Ok(original))\n }"}, {"sha": "a1b1e943f12d3a16ffe0d76d6dcc87425f01058b", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=35e5c3b3f9075c86d950cd774db3b904be0aa478", "patch": "@@ -14,11 +14,13 @@ pub mod builtin_fn_macro;\n pub mod proc_macro;\n pub mod quote;\n pub mod eager;\n+pub mod mod_path;\n \n use base_db::ProcMacroKind;\n use either::Either;\n \n pub use mbe::{ExpandError, ExpandResult, Origin};\n+use mod_path::ModPath;\n \n use std::{hash::Hash, iter, sync::Arc};\n \n@@ -835,3 +837,8 @@ impl ExpandTo {\n         }\n     }\n }\n+\n+#[derive(Debug)]\n+pub struct UnresolvedMacro {\n+    pub path: ModPath,\n+}"}, {"sha": "9c06a3f892ae0f571793ddf376e1e95974d95d2c", "filename": "crates/hir_expand/src/mod_path.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_expand%2Fsrc%2Fmod_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5c3b3f9075c86d950cd774db3b904be0aa478/crates%2Fhir_expand%2Fsrc%2Fmod_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fmod_path.rs?ref=35e5c3b3f9075c86d950cd774db3b904be0aa478", "patch": "@@ -0,0 +1,238 @@\n+//! A lowering for `use`-paths (more generally, paths without angle-bracketed segments).\n+\n+use std::{\n+    fmt::{self, Display},\n+    iter,\n+};\n+\n+use crate::{db::AstDatabase, hygiene::Hygiene, name::Name};\n+use base_db::CrateId;\n+use either::Either;\n+use syntax::{ast, AstNode};\n+\n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ModPath {\n+    pub kind: PathKind,\n+    segments: Vec<Name>,\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum PathKind {\n+    Plain,\n+    /// `self::` is `Super(0)`\n+    Super(u8),\n+    Crate,\n+    /// Absolute path (::foo)\n+    Abs,\n+    /// `$crate` from macro expansion\n+    DollarCrate(CrateId),\n+}\n+\n+impl ModPath {\n+    pub fn from_src(db: &dyn AstDatabase, path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n+        convert_path(db, None, path, hygiene)\n+    }\n+\n+    pub fn from_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> ModPath {\n+        let segments = segments.into_iter().collect::<Vec<_>>();\n+        ModPath { kind, segments }\n+    }\n+\n+    /// Creates a `ModPath` from a `PathKind`, with no extra path segments.\n+    pub const fn from_kind(kind: PathKind) -> ModPath {\n+        ModPath { kind, segments: Vec::new() }\n+    }\n+\n+    pub fn segments(&self) -> &[Name] {\n+        &self.segments\n+    }\n+\n+    pub fn push_segment(&mut self, segment: Name) {\n+        self.segments.push(segment);\n+    }\n+\n+    pub fn pop_segment(&mut self) -> Option<Name> {\n+        self.segments.pop()\n+    }\n+\n+    /// Returns the number of segments in the path (counting special segments like `$crate` and\n+    /// `super`).\n+    pub fn len(&self) -> usize {\n+        self.segments.len()\n+            + match self.kind {\n+                PathKind::Plain => 0,\n+                PathKind::Super(i) => i as usize,\n+                PathKind::Crate => 1,\n+                PathKind::Abs => 0,\n+                PathKind::DollarCrate(_) => 1,\n+            }\n+    }\n+\n+    pub fn is_ident(&self) -> bool {\n+        self.as_ident().is_some()\n+    }\n+\n+    pub fn is_self(&self) -> bool {\n+        self.kind == PathKind::Super(0) && self.segments.is_empty()\n+    }\n+\n+    /// If this path is a single identifier, like `foo`, return its name.\n+    pub fn as_ident(&self) -> Option<&Name> {\n+        if self.kind != PathKind::Plain {\n+            return None;\n+        }\n+\n+        match &*self.segments {\n+            [name] => Some(name),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl Display for ModPath {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut first_segment = true;\n+        let mut add_segment = |s| -> fmt::Result {\n+            if !first_segment {\n+                f.write_str(\"::\")?;\n+            }\n+            first_segment = false;\n+            f.write_str(s)?;\n+            Ok(())\n+        };\n+        match self.kind {\n+            PathKind::Plain => {}\n+            PathKind::Super(0) => add_segment(\"self\")?,\n+            PathKind::Super(n) => {\n+                for _ in 0..n {\n+                    add_segment(\"super\")?;\n+                }\n+            }\n+            PathKind::Crate => add_segment(\"crate\")?,\n+            PathKind::Abs => add_segment(\"\")?,\n+            PathKind::DollarCrate(_) => add_segment(\"$crate\")?,\n+        }\n+        for segment in &self.segments {\n+            if !first_segment {\n+                f.write_str(\"::\")?;\n+            }\n+            first_segment = false;\n+            write!(f, \"{}\", segment)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl From<Name> for ModPath {\n+    fn from(name: Name) -> ModPath {\n+        ModPath::from_segments(PathKind::Plain, iter::once(name))\n+    }\n+}\n+\n+fn convert_path(\n+    db: &dyn AstDatabase,\n+    prefix: Option<ModPath>,\n+    path: ast::Path,\n+    hygiene: &Hygiene,\n+) -> Option<ModPath> {\n+    let prefix = match path.qualifier() {\n+        Some(qual) => Some(convert_path(db, prefix, qual, hygiene)?),\n+        None => prefix,\n+    };\n+\n+    let segment = path.segment()?;\n+    let mut mod_path = match segment.kind()? {\n+        ast::PathSegmentKind::Name(name_ref) => {\n+            match hygiene.name_ref_to_name(db, name_ref) {\n+                Either::Left(name) => {\n+                    // no type args in use\n+                    let mut res = prefix.unwrap_or_else(|| {\n+                        ModPath::from_kind(\n+                            segment.coloncolon_token().map_or(PathKind::Plain, |_| PathKind::Abs),\n+                        )\n+                    });\n+                    res.segments.push(name);\n+                    res\n+                }\n+                Either::Right(crate_id) => {\n+                    return Some(ModPath::from_segments(\n+                        PathKind::DollarCrate(crate_id),\n+                        iter::empty(),\n+                    ))\n+                }\n+            }\n+        }\n+        ast::PathSegmentKind::CrateKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            ModPath::from_segments(PathKind::Crate, iter::empty())\n+        }\n+        ast::PathSegmentKind::SelfKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            ModPath::from_segments(PathKind::Super(0), iter::empty())\n+        }\n+        ast::PathSegmentKind::SuperKw => {\n+            let nested_super_count = match prefix.map(|p| p.kind) {\n+                Some(PathKind::Super(n)) => n,\n+                Some(_) => return None,\n+                None => 0,\n+            };\n+\n+            ModPath::from_segments(PathKind::Super(nested_super_count + 1), iter::empty())\n+        }\n+        ast::PathSegmentKind::Type { .. } => {\n+            // not allowed in imports\n+            return None;\n+        }\n+    };\n+\n+    // handle local_inner_macros :\n+    // Basically, even in rustc it is quite hacky:\n+    // https://github.com/rust-lang/rust/blob/614f273e9388ddd7804d5cbc80b8865068a3744e/src/librustc_resolve/macros.rs#L456\n+    // We follow what it did anyway :)\n+    if mod_path.segments.len() == 1 && mod_path.kind == PathKind::Plain {\n+        if let Some(_macro_call) = path.syntax().parent().and_then(ast::MacroCall::cast) {\n+            if let Some(crate_id) = hygiene.local_inner_macros(db, path) {\n+                mod_path.kind = PathKind::DollarCrate(crate_id);\n+            }\n+        }\n+    }\n+\n+    Some(mod_path)\n+}\n+\n+pub use crate::name as __name;\n+\n+#[macro_export]\n+macro_rules! __known_path {\n+    (core::iter::IntoIterator) => {};\n+    (core::iter::Iterator) => {};\n+    (core::result::Result) => {};\n+    (core::option::Option) => {};\n+    (core::ops::Range) => {};\n+    (core::ops::RangeFrom) => {};\n+    (core::ops::RangeFull) => {};\n+    (core::ops::RangeTo) => {};\n+    (core::ops::RangeToInclusive) => {};\n+    (core::ops::RangeInclusive) => {};\n+    (core::future::Future) => {};\n+    (core::ops::Try) => {};\n+    ($path:path) => {\n+        compile_error!(\"Please register your known path in the path module\")\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! __path {\n+    ($start:ident $(:: $seg:ident)*) => ({\n+        $crate::__known_path!($start $(:: $seg)*);\n+        $crate::mod_path::ModPath::from_segments($crate::mod_path::PathKind::Abs, vec![\n+            $crate::mod_path::__name![$start], $($crate::mod_path::__name![$seg],)*\n+        ])\n+    });\n+}\n+\n+pub use crate::__path as path;"}]}