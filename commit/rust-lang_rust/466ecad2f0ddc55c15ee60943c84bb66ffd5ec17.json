{"sha": "466ecad2f0ddc55c15ee60943c84bb66ffd5ec17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2NmVjYWQyZjBkZGM1NWMxNWVlNjA5NDNjODRiYjY2ZmZkNWVjMTc=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-06-11T13:43:22Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-06-11T13:43:22Z"}, "message": "Move CValue and CPlace to separate file and remove duplicate scalar_to_clif_type", "tree": {"sha": "91ed5973f9967e77f0c9f79259c7f9d67d569c1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91ed5973f9967e77f0c9f79259c7f9d67d569c1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/466ecad2f0ddc55c15ee60943c84bb66ffd5ec17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/466ecad2f0ddc55c15ee60943c84bb66ffd5ec17", "html_url": "https://github.com/rust-lang/rust/commit/466ecad2f0ddc55c15ee60943c84bb66ffd5ec17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/466ecad2f0ddc55c15ee60943c84bb66ffd5ec17/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6e07cfcc8e6a735c60814e44143591e0c2911ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6e07cfcc8e6a735c60814e44143591e0c2911ae", "html_url": "https://github.com/rust-lang/rust/commit/d6e07cfcc8e6a735c60814e44143591e0c2911ae"}], "stats": {"total": 983, "additions": 488, "deletions": 495}, "files": [{"sha": "00135d2c0330539759702809596876a060fd8f08", "filename": "src/common.rs", "status": "modified", "additions": 0, "deletions": 495, "changes": 495, "blob_url": "https://github.com/rust-lang/rust/blob/466ecad2f0ddc55c15ee60943c84bb66ffd5ec17/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466ecad2f0ddc55c15ee60943c84bb66ffd5ec17/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=466ecad2f0ddc55c15ee60943c84bb66ffd5ec17", "patch": "@@ -17,16 +17,6 @@ pub fn pointer_ty(tcx: TyCtxt) -> types::Type {\n     }\n }\n \n-fn scalar_to_clif_type(tcx: TyCtxt, scalar: &Scalar) -> Type {\n-    match scalar.value.size(&tcx).bits() {\n-        8 => types::I8,\n-        16 => types::I16,\n-        32 => types::I32,\n-        64 => types::I64,\n-        size => bug!(\"Unsupported scalar size {}\", size),\n-    }\n-}\n-\n pub fn clif_type_from_ty<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: Ty<'tcx>,\n@@ -82,491 +72,6 @@ pub fn codegen_select(bcx: &mut FunctionBuilder, cond: Value, lhs: Value, rhs: V\n     }\n }\n \n-fn codegen_field<'a, 'tcx: 'a>(\n-    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-    base: Value,\n-    layout: TyLayout<'tcx>,\n-    field: mir::Field,\n-) -> (Value, TyLayout<'tcx>) {\n-    let field_offset = layout.fields.offset(field.index());\n-    let field_ty = layout.field(&*fx, field.index());\n-    if field_offset.bytes() > 0 {\n-        (\n-            fx.bcx.ins().iadd_imm(base, field_offset.bytes() as i64),\n-            field_ty,\n-        )\n-    } else {\n-        (base, field_ty)\n-    }\n-}\n-\n-/// A read-only value\n-#[derive(Debug, Copy, Clone)]\n-pub enum CValue<'tcx> {\n-    ByRef(Value, TyLayout<'tcx>),\n-    ByVal(Value, TyLayout<'tcx>),\n-    ByValPair(Value, Value, TyLayout<'tcx>),\n-}\n-\n-impl<'tcx> CValue<'tcx> {\n-    pub fn by_ref(value: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n-        CValue::ByRef(value, layout)\n-    }\n-\n-    pub fn by_val(value: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n-        CValue::ByVal(value, layout)\n-    }\n-\n-    pub fn by_val_pair(value: Value, extra: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n-        CValue::ByValPair(value, extra, layout)\n-    }\n-\n-    pub fn layout(&self) -> TyLayout<'tcx> {\n-        match *self {\n-            CValue::ByRef(_, layout)\n-            | CValue::ByVal(_, layout)\n-            | CValue::ByValPair(_, _, layout) => layout,\n-        }\n-    }\n-\n-    pub fn force_stack<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> Value\n-    where\n-        'tcx: 'a,\n-    {\n-        match self {\n-            CValue::ByRef(value, _layout) => value,\n-            CValue::ByVal(value, layout) => {\n-                let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n-                    kind: StackSlotKind::ExplicitSlot,\n-                    size: layout.size.bytes() as u32,\n-                    offset: None,\n-                });\n-                let addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n-                fx.bcx.ins().store(MemFlags::new(), value, addr, 0);\n-                addr\n-            }\n-            CValue::ByValPair(value, extra, layout) => {\n-                let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n-                    kind: StackSlotKind::ExplicitSlot,\n-                    size: layout.size.bytes() as u32,\n-                    offset: None,\n-                });\n-                let base = fx.bcx.ins().stack_addr(types::I64, stack_slot, 0);\n-                let a_addr = codegen_field(fx, base, layout, mir::Field::new(0)).0;\n-                let b_addr = codegen_field(fx, base, layout, mir::Field::new(1)).0;\n-                fx.bcx.ins().store(MemFlags::new(), value, a_addr, 0);\n-                fx.bcx.ins().store(MemFlags::new(), extra, b_addr, 0);\n-                base\n-            }\n-        }\n-    }\n-\n-    /// Load a value with layout.abi of scalar\n-    pub fn load_scalar<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> Value\n-    where\n-        'tcx: 'a,\n-    {\n-        match self {\n-            CValue::ByRef(addr, layout) => {\n-                let scalar = match layout.abi {\n-                    layout::Abi::Scalar(ref scalar) => scalar.clone(),\n-                    _ => unreachable!(),\n-                };\n-                let clif_ty = crate::abi::scalar_to_clif_type(fx.tcx, scalar);\n-                fx.bcx.ins().load(clif_ty, MemFlags::new(), addr, 0)\n-            }\n-            CValue::ByVal(value, _layout) => value,\n-            CValue::ByValPair(_, _, _layout) => bug!(\"Please use load_scalar_pair for ByValPair\"),\n-        }\n-    }\n-\n-    /// Load a value pair with layout.abi of scalar pair\n-    pub fn load_scalar_pair<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> (Value, Value)\n-    where\n-        'tcx: 'a,\n-    {\n-        match self {\n-            CValue::ByRef(addr, layout) => {\n-                let (a, b) = match &layout.abi {\n-                    layout::Abi::ScalarPair(a, b) => (a.clone(), b.clone()),\n-                    _ => unreachable!(),\n-                };\n-                let clif_ty1 = crate::abi::scalar_to_clif_type(fx.tcx, a.clone());\n-                let clif_ty2 = crate::abi::scalar_to_clif_type(fx.tcx, b);\n-                let val1 = fx.bcx.ins().load(clif_ty1, MemFlags::new(), addr, 0);\n-                let val2 = fx.bcx.ins().load(\n-                    clif_ty2,\n-                    MemFlags::new(),\n-                    addr,\n-                    a.value.size(&fx.tcx).bytes() as i32,\n-                );\n-                (val1, val2)\n-            }\n-            CValue::ByVal(_, _layout) => bug!(\"Please use load_scalar for ByVal\"),\n-            CValue::ByValPair(val1, val2, _layout) => (val1, val2),\n-        }\n-    }\n-\n-    pub fn value_field<'a>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-        field: mir::Field,\n-    ) -> CValue<'tcx>\n-    where\n-        'tcx: 'a,\n-    {\n-        let (base, layout) = match self {\n-            CValue::ByRef(addr, layout) => (addr, layout),\n-            _ => bug!(\"place_field for {:?}\", self),\n-        };\n-\n-        let (field_ptr, field_layout) = codegen_field(fx, base, layout, field);\n-        CValue::ByRef(field_ptr, field_layout)\n-    }\n-\n-    pub fn unsize_value<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n-        crate::unsize::coerce_unsized_into(fx, self, dest);\n-    }\n-\n-    pub fn const_val<'a>(\n-        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-        ty: Ty<'tcx>,\n-        const_val: i64,\n-    ) -> CValue<'tcx>\n-    where\n-        'tcx: 'a,\n-    {\n-        let clif_ty = fx.clif_type(ty).unwrap();\n-        let layout = fx.layout_of(ty);\n-        CValue::ByVal(fx.bcx.ins().iconst(clif_ty, const_val), layout)\n-    }\n-\n-    pub fn unchecked_cast_to(self, layout: TyLayout<'tcx>) -> Self {\n-        match self {\n-            CValue::ByRef(addr, _) => CValue::ByRef(addr, layout),\n-            CValue::ByVal(val, _) => CValue::ByVal(val, layout),\n-            CValue::ByValPair(val, extra, _) => CValue::ByValPair(val, extra, layout),\n-        }\n-    }\n-}\n-\n-/// A place where you can write a value to or read a value from\n-#[derive(Debug, Copy, Clone)]\n-pub enum CPlace<'tcx> {\n-    Var(Local, TyLayout<'tcx>),\n-    Addr(Value, Option<Value>, TyLayout<'tcx>),\n-    Stack(StackSlot, TyLayout<'tcx>),\n-    NoPlace(TyLayout<'tcx>),\n-}\n-\n-impl<'a, 'tcx: 'a> CPlace<'tcx> {\n-    pub fn layout(&self) -> TyLayout<'tcx> {\n-        match *self {\n-            CPlace::Var(_, layout)\n-            | CPlace::Addr(_, _, layout)\n-            | CPlace::Stack(_, layout)\n-            | CPlace::NoPlace(layout) => layout,\n-        }\n-    }\n-\n-    pub fn no_place(layout: TyLayout<'tcx>) -> CPlace<'tcx> {\n-        CPlace::NoPlace(layout)\n-    }\n-\n-    pub fn new_stack_slot(\n-        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-        ty: Ty<'tcx>,\n-    ) -> CPlace<'tcx> {\n-        let layout = fx.layout_of(ty);\n-        assert!(!layout.is_unsized());\n-        if layout.size.bytes() == 0 {\n-            return CPlace::NoPlace(layout);\n-        }\n-\n-        let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n-            kind: StackSlotKind::ExplicitSlot,\n-            size: layout.size.bytes() as u32,\n-            offset: None,\n-        });\n-        CPlace::Stack(stack_slot, layout)\n-    }\n-\n-    pub fn new_var(\n-        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-        local: Local,\n-        layout: TyLayout<'tcx>,\n-    ) -> CPlace<'tcx> {\n-        fx.bcx\n-            .declare_var(mir_var(local), fx.clif_type(layout.ty).unwrap());\n-        CPlace::Var(local, layout)\n-    }\n-\n-    pub fn to_cvalue(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> CValue<'tcx> {\n-        match self {\n-            CPlace::Var(var, layout) => CValue::ByVal(fx.bcx.use_var(mir_var(var)), layout),\n-            CPlace::Addr(addr, extra, layout) => {\n-                assert!(extra.is_none(), \"unsized values are not yet supported\");\n-                CValue::ByRef(addr, layout)\n-            }\n-            CPlace::Stack(stack_slot, layout) => CValue::ByRef(\n-                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n-                layout,\n-            ),\n-            CPlace::NoPlace(layout) => CValue::ByRef(\n-                fx.bcx\n-                    .ins()\n-                    .iconst(fx.pointer_type, fx.pointer_type.bytes() as i64),\n-                layout,\n-            ),\n-        }\n-    }\n-\n-    pub fn to_addr(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> Value {\n-        match self.to_addr_maybe_unsized(fx) {\n-            (addr, None) => addr,\n-            (_, Some(_)) => bug!(\"Expected sized cplace, found {:?}\", self),\n-        }\n-    }\n-\n-    pub fn to_addr_maybe_unsized(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-    ) -> (Value, Option<Value>) {\n-        match self {\n-            CPlace::Addr(addr, extra, _layout) => (addr, extra),\n-            CPlace::Stack(stack_slot, _layout) => (\n-                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n-                None,\n-            ),\n-            CPlace::NoPlace(_) => (fx.bcx.ins().iconst(fx.pointer_type, 45), None),\n-            CPlace::Var(_, _) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n-        }\n-    }\n-\n-    pub fn write_cvalue(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, from: CValue<'tcx>) {\n-        use rustc::hir::Mutability::*;\n-\n-        let from_ty = from.layout().ty;\n-        let to_ty = self.layout().ty;\n-\n-        fn assert_assignable<'a, 'tcx: 'a>(fx: &FunctionCx<'a, 'tcx, impl Backend>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) {\n-            match (&from_ty.sty, &to_ty.sty) {\n-                (ty::Ref(_, t, MutImmutable), ty::Ref(_, u, MutImmutable))\n-                | (ty::Ref(_, t, MutMutable), ty::Ref(_, u, MutImmutable))\n-                | (ty::Ref(_, t, MutMutable), ty::Ref(_, u, MutMutable)) => {\n-                    assert_assignable(fx, t, u);\n-                    // &mut T -> &T is allowed\n-                    // &'a T -> &'b T is allowed\n-                }\n-                (ty::Ref(_, _, MutImmutable), ty::Ref(_, _, MutMutable)) => {\n-                    panic!(\"Cant assign value of type {} to place of type {}\", from_ty, to_ty)\n-                }\n-                (ty::FnPtr(_), ty::FnPtr(_)) => {\n-                    let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        &from_ty.fn_sig(fx.tcx),\n-                    );\n-                    let to_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        &to_ty.fn_sig(fx.tcx),\n-                    );\n-                    assert_eq!(\n-                        from_sig, to_sig,\n-                        \"Can't write fn ptr with incompatible sig {:?} to place with sig {:?}\\n\\n{:#?}\",\n-                        from_sig, to_sig, fx,\n-                    );\n-                    // fn(&T) -> for<'l> fn(&'l T) is allowed\n-                }\n-                (ty::Dynamic(from_traits, _), ty::Dynamic(to_traits, _)) => {\n-                    let from_traits = fx.tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        from_traits,\n-                    );\n-                    let to_traits = fx.tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        to_traits,\n-                    );\n-                    assert_eq!(\n-                        from_traits, to_traits,\n-                        \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n-                        from_traits, to_traits, fx,\n-                    );\n-                    // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n-                }\n-                _ => {\n-                    assert_eq!(\n-                        from_ty,\n-                        to_ty,\n-                        \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n-                        from_ty,\n-                        to_ty,\n-                        fx,\n-                    );\n-                }\n-            }\n-        }\n-\n-        assert_assignable(fx, from_ty, to_ty);\n-\n-        let (addr, dst_layout) = match self {\n-            CPlace::Var(var, _) => {\n-                let data = from.load_scalar(fx);\n-                fx.bcx.def_var(mir_var(var), data);\n-                return;\n-            }\n-            CPlace::Addr(addr, None, dst_layout) => (addr, dst_layout),\n-            CPlace::Stack(stack_slot, dst_layout) => (\n-                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n-                dst_layout,\n-            ),\n-            CPlace::NoPlace(layout) => {\n-                assert_eq!(layout.size.bytes(), 0);\n-                assert_eq!(from.layout().size.bytes(), 0);\n-                return;\n-            }\n-            CPlace::Addr(_, _, _) => bug!(\"Can't write value to unsized place {:?}\", self),\n-        };\n-\n-        match from {\n-            CValue::ByVal(val, _src_layout) => {\n-                fx.bcx.ins().store(MemFlags::new(), val, addr, 0);\n-            }\n-            CValue::ByValPair(val1, val2, _src_layout) => {\n-                let val1_offset = dst_layout.fields.offset(0).bytes() as i32;\n-                let val2_offset = dst_layout.fields.offset(1).bytes() as i32;\n-                fx.bcx.ins().store(MemFlags::new(), val1, addr, val1_offset);\n-                fx.bcx.ins().store(MemFlags::new(), val2, addr, val2_offset);\n-            }\n-            CValue::ByRef(from, src_layout) => {\n-                let size = dst_layout.size.bytes();\n-                let src_align = src_layout.align.abi.bytes() as u8;\n-                let dst_align = dst_layout.align.abi.bytes() as u8;\n-                fx.bcx.emit_small_memcpy(\n-                    fx.module.target_config(),\n-                    addr,\n-                    from,\n-                    size,\n-                    dst_align,\n-                    src_align,\n-                );\n-            }\n-        }\n-    }\n-\n-    pub fn place_field(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-        field: mir::Field,\n-    ) -> CPlace<'tcx> {\n-        let layout = self.layout();\n-        let (base, extra) = self.to_addr_maybe_unsized(fx);\n-\n-        let (field_ptr, field_layout) = codegen_field(fx, base, layout, field);\n-        let extra = if field_layout.is_unsized() {\n-            assert!(extra.is_some());\n-            extra\n-        } else {\n-            None\n-        };\n-        CPlace::Addr(field_ptr, extra, field_layout)\n-    }\n-\n-    pub fn place_index(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-        index: Value,\n-    ) -> CPlace<'tcx> {\n-        let (elem_layout, addr) = match self.layout().ty.sty {\n-            ty::Array(elem_ty, _) => (fx.layout_of(elem_ty), self.to_addr(fx)),\n-            ty::Slice(elem_ty) => (fx.layout_of(elem_ty), self.to_addr_maybe_unsized(fx).0),\n-            _ => bug!(\"place_index({:?})\", self.layout().ty),\n-        };\n-\n-        let offset = fx\n-            .bcx\n-            .ins()\n-            .imul_imm(index, elem_layout.size.bytes() as i64);\n-\n-        CPlace::Addr(fx.bcx.ins().iadd(addr, offset), None, elem_layout)\n-    }\n-\n-    pub fn place_deref(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> CPlace<'tcx> {\n-        let inner_layout = fx.layout_of(self.layout().ty.builtin_deref(true).unwrap().ty);\n-        if !inner_layout.is_unsized() {\n-            CPlace::Addr(self.to_cvalue(fx).load_scalar(fx), None, inner_layout)\n-        } else {\n-            match self.layout().abi {\n-                Abi::ScalarPair(ref a, ref b) => {\n-                    let addr = self.to_addr(fx);\n-                    let ptr =\n-                        fx.bcx\n-                            .ins()\n-                            .load(scalar_to_clif_type(fx.tcx, a), MemFlags::new(), addr, 0);\n-                    let extra = fx.bcx.ins().load(\n-                        scalar_to_clif_type(fx.tcx, b),\n-                        MemFlags::new(),\n-                        addr,\n-                        a.value.size(&fx.tcx).bytes() as u32 as i32,\n-                    );\n-                    CPlace::Addr(ptr, Some(extra), inner_layout)\n-                }\n-                _ => bug!(\n-                    \"Fat ptr doesn't have abi ScalarPair, but it has {:?}\",\n-                    self.layout().abi\n-                ),\n-            }\n-        }\n-    }\n-\n-    pub fn write_place_ref(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n-        if !self.layout().is_unsized() {\n-            let ptr = CValue::ByVal(self.to_addr(fx), dest.layout());\n-            dest.write_cvalue(fx, ptr);\n-        } else {\n-            let (value, extra) = self.to_addr_maybe_unsized(fx);\n-\n-            match dest.layout().abi {\n-                Abi::ScalarPair(ref a, _) => {\n-                    let dest_addr = dest.to_addr(fx);\n-                    fx.bcx.ins().store(MemFlags::new(), value, dest_addr, 0);\n-                    fx.bcx.ins().store(\n-                        MemFlags::new(),\n-                        extra.expect(\"unsized type without metadata\"),\n-                        dest_addr,\n-                        a.value.size(&fx.tcx).bytes() as u32 as i32,\n-                    );\n-                }\n-                _ => bug!(\n-                    \"Non ScalarPair abi {:?} in write_place_ref dest\",\n-                    dest.layout().abi\n-                ),\n-            }\n-        }\n-    }\n-\n-    pub fn unchecked_cast_to(self, layout: TyLayout<'tcx>) -> Self {\n-        assert!(!self.layout().is_unsized());\n-        match self {\n-            CPlace::Var(var, _) => CPlace::Var(var, layout),\n-            CPlace::Addr(addr, extra, _) => CPlace::Addr(addr, extra, layout),\n-            CPlace::Stack(stack_slot, _) => CPlace::Stack(stack_slot, layout),\n-            CPlace::NoPlace(_) => {\n-                assert!(layout.size.bytes() == 0);\n-                CPlace::NoPlace(layout)\n-            }\n-        }\n-    }\n-\n-    pub fn downcast_variant(\n-        self,\n-        fx: &FunctionCx<'a, 'tcx, impl Backend>,\n-        variant: VariantIdx,\n-    ) -> Self {\n-        let layout = self.layout().for_variant(fx, variant);\n-        self.unchecked_cast_to(layout)\n-    }\n-}\n-\n pub fn clif_intcast<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     val: Value,"}, {"sha": "a2435312fe1c88a1be7268bfdabd84fff556ac2c", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/466ecad2f0ddc55c15ee60943c84bb66ffd5ec17/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466ecad2f0ddc55c15ee60943c84bb66ffd5ec17/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=466ecad2f0ddc55c15ee60943c84bb66ffd5ec17", "patch": "@@ -44,6 +44,7 @@ mod pretty_clif;\n mod trap;\n mod unimpl;\n mod unsize;\n+mod value_and_place;\n mod vtable;\n \n mod prelude {\n@@ -93,6 +94,7 @@ mod prelude {\n     pub use crate::debuginfo::{DebugContext, FunctionDebugContext};\n     pub use crate::trap::*;\n     pub use crate::unimpl::{unimpl, with_unimpl_span};\n+    pub use crate::value_and_place::{CValue, CPlace};\n     pub use crate::{Caches, CodegenCx};\n \n     pub struct PrintOnPanic<F: Fn() -> String>(pub F);"}, {"sha": "29b370baf8cf78d8ec59fbb6ee8442ebfe17bd06", "filename": "src/value_and_place.rs", "status": "added", "additions": 486, "deletions": 0, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/466ecad2f0ddc55c15ee60943c84bb66ffd5ec17/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466ecad2f0ddc55c15ee60943c84bb66ffd5ec17/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=466ecad2f0ddc55c15ee60943c84bb66ffd5ec17", "patch": "@@ -0,0 +1,486 @@\n+use crate::prelude::*;\n+\n+fn codegen_field<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    base: Value,\n+    layout: TyLayout<'tcx>,\n+    field: mir::Field,\n+) -> (Value, TyLayout<'tcx>) {\n+    let field_offset = layout.fields.offset(field.index());\n+    let field_ty = layout.field(&*fx, field.index());\n+    if field_offset.bytes() > 0 {\n+        (\n+            fx.bcx.ins().iadd_imm(base, field_offset.bytes() as i64),\n+            field_ty,\n+        )\n+    } else {\n+        (base, field_ty)\n+    }\n+}\n+\n+/// A read-only value\n+#[derive(Debug, Copy, Clone)]\n+pub enum CValue<'tcx> {\n+    ByRef(Value, TyLayout<'tcx>),\n+    ByVal(Value, TyLayout<'tcx>),\n+    ByValPair(Value, Value, TyLayout<'tcx>),\n+}\n+\n+impl<'tcx> CValue<'tcx> {\n+    pub fn by_ref(value: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n+        CValue::ByRef(value, layout)\n+    }\n+\n+    pub fn by_val(value: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n+        CValue::ByVal(value, layout)\n+    }\n+\n+    pub fn by_val_pair(value: Value, extra: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n+        CValue::ByValPair(value, extra, layout)\n+    }\n+\n+    pub fn layout(&self) -> TyLayout<'tcx> {\n+        match *self {\n+            CValue::ByRef(_, layout)\n+            | CValue::ByVal(_, layout)\n+            | CValue::ByValPair(_, _, layout) => layout,\n+        }\n+    }\n+\n+    pub fn force_stack<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> Value\n+    where\n+        'tcx: 'a,\n+    {\n+        match self {\n+            CValue::ByRef(value, _layout) => value,\n+            CValue::ByVal(value, layout) => {\n+                let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+                    kind: StackSlotKind::ExplicitSlot,\n+                    size: layout.size.bytes() as u32,\n+                    offset: None,\n+                });\n+                let addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n+                fx.bcx.ins().store(MemFlags::new(), value, addr, 0);\n+                addr\n+            }\n+            CValue::ByValPair(value, extra, layout) => {\n+                let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+                    kind: StackSlotKind::ExplicitSlot,\n+                    size: layout.size.bytes() as u32,\n+                    offset: None,\n+                });\n+                let base = fx.bcx.ins().stack_addr(types::I64, stack_slot, 0);\n+                let a_addr = codegen_field(fx, base, layout, mir::Field::new(0)).0;\n+                let b_addr = codegen_field(fx, base, layout, mir::Field::new(1)).0;\n+                fx.bcx.ins().store(MemFlags::new(), value, a_addr, 0);\n+                fx.bcx.ins().store(MemFlags::new(), extra, b_addr, 0);\n+                base\n+            }\n+        }\n+    }\n+\n+    /// Load a value with layout.abi of scalar\n+    pub fn load_scalar<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> Value\n+    where\n+        'tcx: 'a,\n+    {\n+        match self {\n+            CValue::ByRef(addr, layout) => {\n+                let scalar = match layout.abi {\n+                    layout::Abi::Scalar(ref scalar) => scalar.clone(),\n+                    _ => unreachable!(),\n+                };\n+                let clif_ty = scalar_to_clif_type(fx.tcx, scalar);\n+                fx.bcx.ins().load(clif_ty, MemFlags::new(), addr, 0)\n+            }\n+            CValue::ByVal(value, _layout) => value,\n+            CValue::ByValPair(_, _, _layout) => bug!(\"Please use load_scalar_pair for ByValPair\"),\n+        }\n+    }\n+\n+    /// Load a value pair with layout.abi of scalar pair\n+    pub fn load_scalar_pair<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> (Value, Value)\n+    where\n+        'tcx: 'a,\n+    {\n+        match self {\n+            CValue::ByRef(addr, layout) => {\n+                let (a, b) = match &layout.abi {\n+                    layout::Abi::ScalarPair(a, b) => (a.clone(), b.clone()),\n+                    _ => unreachable!(),\n+                };\n+                let clif_ty1 = scalar_to_clif_type(fx.tcx, a.clone());\n+                let clif_ty2 = scalar_to_clif_type(fx.tcx, b);\n+                let val1 = fx.bcx.ins().load(clif_ty1, MemFlags::new(), addr, 0);\n+                let val2 = fx.bcx.ins().load(\n+                    clif_ty2,\n+                    MemFlags::new(),\n+                    addr,\n+                    a.value.size(&fx.tcx).bytes() as i32,\n+                );\n+                (val1, val2)\n+            }\n+            CValue::ByVal(_, _layout) => bug!(\"Please use load_scalar for ByVal\"),\n+            CValue::ByValPair(val1, val2, _layout) => (val1, val2),\n+        }\n+    }\n+\n+    pub fn value_field<'a>(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+        field: mir::Field,\n+    ) -> CValue<'tcx>\n+    where\n+        'tcx: 'a,\n+    {\n+        let (base, layout) = match self {\n+            CValue::ByRef(addr, layout) => (addr, layout),\n+            _ => bug!(\"place_field for {:?}\", self),\n+        };\n+\n+        let (field_ptr, field_layout) = codegen_field(fx, base, layout, field);\n+        CValue::ByRef(field_ptr, field_layout)\n+    }\n+\n+    pub fn unsize_value<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n+        crate::unsize::coerce_unsized_into(fx, self, dest);\n+    }\n+\n+    pub fn const_val<'a>(\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+        ty: Ty<'tcx>,\n+        const_val: i64,\n+    ) -> CValue<'tcx>\n+    where\n+        'tcx: 'a,\n+    {\n+        let clif_ty = fx.clif_type(ty).unwrap();\n+        let layout = fx.layout_of(ty);\n+        CValue::ByVal(fx.bcx.ins().iconst(clif_ty, const_val), layout)\n+    }\n+\n+    pub fn unchecked_cast_to(self, layout: TyLayout<'tcx>) -> Self {\n+        match self {\n+            CValue::ByRef(addr, _) => CValue::ByRef(addr, layout),\n+            CValue::ByVal(val, _) => CValue::ByVal(val, layout),\n+            CValue::ByValPair(val, extra, _) => CValue::ByValPair(val, extra, layout),\n+        }\n+    }\n+}\n+\n+/// A place where you can write a value to or read a value from\n+#[derive(Debug, Copy, Clone)]\n+pub enum CPlace<'tcx> {\n+    Var(Local, TyLayout<'tcx>),\n+    Addr(Value, Option<Value>, TyLayout<'tcx>),\n+    Stack(StackSlot, TyLayout<'tcx>),\n+    NoPlace(TyLayout<'tcx>),\n+}\n+\n+impl<'a, 'tcx: 'a> CPlace<'tcx> {\n+    pub fn layout(&self) -> TyLayout<'tcx> {\n+        match *self {\n+            CPlace::Var(_, layout)\n+            | CPlace::Addr(_, _, layout)\n+            | CPlace::Stack(_, layout)\n+            | CPlace::NoPlace(layout) => layout,\n+        }\n+    }\n+\n+    pub fn no_place(layout: TyLayout<'tcx>) -> CPlace<'tcx> {\n+        CPlace::NoPlace(layout)\n+    }\n+\n+    pub fn new_stack_slot(\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+        ty: Ty<'tcx>,\n+    ) -> CPlace<'tcx> {\n+        let layout = fx.layout_of(ty);\n+        assert!(!layout.is_unsized());\n+        if layout.size.bytes() == 0 {\n+            return CPlace::NoPlace(layout);\n+        }\n+\n+        let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+            kind: StackSlotKind::ExplicitSlot,\n+            size: layout.size.bytes() as u32,\n+            offset: None,\n+        });\n+        CPlace::Stack(stack_slot, layout)\n+    }\n+\n+    pub fn new_var(\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+        local: Local,\n+        layout: TyLayout<'tcx>,\n+    ) -> CPlace<'tcx> {\n+        fx.bcx\n+            .declare_var(mir_var(local), fx.clif_type(layout.ty).unwrap());\n+        CPlace::Var(local, layout)\n+    }\n+\n+    pub fn to_cvalue(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> CValue<'tcx> {\n+        match self {\n+            CPlace::Var(var, layout) => CValue::ByVal(fx.bcx.use_var(mir_var(var)), layout),\n+            CPlace::Addr(addr, extra, layout) => {\n+                assert!(extra.is_none(), \"unsized values are not yet supported\");\n+                CValue::ByRef(addr, layout)\n+            }\n+            CPlace::Stack(stack_slot, layout) => CValue::ByRef(\n+                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n+                layout,\n+            ),\n+            CPlace::NoPlace(layout) => CValue::ByRef(\n+                fx.bcx\n+                    .ins()\n+                    .iconst(fx.pointer_type, fx.pointer_type.bytes() as i64),\n+                layout,\n+            ),\n+        }\n+    }\n+\n+    pub fn to_addr(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> Value {\n+        match self.to_addr_maybe_unsized(fx) {\n+            (addr, None) => addr,\n+            (_, Some(_)) => bug!(\"Expected sized cplace, found {:?}\", self),\n+        }\n+    }\n+\n+    pub fn to_addr_maybe_unsized(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    ) -> (Value, Option<Value>) {\n+        match self {\n+            CPlace::Addr(addr, extra, _layout) => (addr, extra),\n+            CPlace::Stack(stack_slot, _layout) => (\n+                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n+                None,\n+            ),\n+            CPlace::NoPlace(_) => (fx.bcx.ins().iconst(fx.pointer_type, 45), None),\n+            CPlace::Var(_, _) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n+        }\n+    }\n+\n+    pub fn write_cvalue(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, from: CValue<'tcx>) {\n+        use rustc::hir::Mutability::*;\n+\n+        let from_ty = from.layout().ty;\n+        let to_ty = self.layout().ty;\n+\n+        fn assert_assignable<'a, 'tcx: 'a>(fx: &FunctionCx<'a, 'tcx, impl Backend>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) {\n+            match (&from_ty.sty, &to_ty.sty) {\n+                (ty::Ref(_, t, MutImmutable), ty::Ref(_, u, MutImmutable))\n+                | (ty::Ref(_, t, MutMutable), ty::Ref(_, u, MutImmutable))\n+                | (ty::Ref(_, t, MutMutable), ty::Ref(_, u, MutMutable)) => {\n+                    assert_assignable(fx, t, u);\n+                    // &mut T -> &T is allowed\n+                    // &'a T -> &'b T is allowed\n+                }\n+                (ty::Ref(_, _, MutImmutable), ty::Ref(_, _, MutMutable)) => {\n+                    panic!(\"Cant assign value of type {} to place of type {}\", from_ty, to_ty)\n+                }\n+                (ty::FnPtr(_), ty::FnPtr(_)) => {\n+                    let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n+                        ParamEnv::reveal_all(),\n+                        &from_ty.fn_sig(fx.tcx),\n+                    );\n+                    let to_sig = fx.tcx.normalize_erasing_late_bound_regions(\n+                        ParamEnv::reveal_all(),\n+                        &to_ty.fn_sig(fx.tcx),\n+                    );\n+                    assert_eq!(\n+                        from_sig, to_sig,\n+                        \"Can't write fn ptr with incompatible sig {:?} to place with sig {:?}\\n\\n{:#?}\",\n+                        from_sig, to_sig, fx,\n+                    );\n+                    // fn(&T) -> for<'l> fn(&'l T) is allowed\n+                }\n+                (ty::Dynamic(from_traits, _), ty::Dynamic(to_traits, _)) => {\n+                    let from_traits = fx.tcx.normalize_erasing_late_bound_regions(\n+                        ParamEnv::reveal_all(),\n+                        from_traits,\n+                    );\n+                    let to_traits = fx.tcx.normalize_erasing_late_bound_regions(\n+                        ParamEnv::reveal_all(),\n+                        to_traits,\n+                    );\n+                    assert_eq!(\n+                        from_traits, to_traits,\n+                        \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n+                        from_traits, to_traits, fx,\n+                    );\n+                    // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n+                }\n+                _ => {\n+                    assert_eq!(\n+                        from_ty,\n+                        to_ty,\n+                        \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n+                        from_ty,\n+                        to_ty,\n+                        fx,\n+                    );\n+                }\n+            }\n+        }\n+\n+        assert_assignable(fx, from_ty, to_ty);\n+\n+        let (addr, dst_layout) = match self {\n+            CPlace::Var(var, _) => {\n+                let data = from.load_scalar(fx);\n+                fx.bcx.def_var(mir_var(var), data);\n+                return;\n+            }\n+            CPlace::Addr(addr, None, dst_layout) => (addr, dst_layout),\n+            CPlace::Stack(stack_slot, dst_layout) => (\n+                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n+                dst_layout,\n+            ),\n+            CPlace::NoPlace(layout) => {\n+                assert_eq!(layout.size.bytes(), 0);\n+                assert_eq!(from.layout().size.bytes(), 0);\n+                return;\n+            }\n+            CPlace::Addr(_, _, _) => bug!(\"Can't write value to unsized place {:?}\", self),\n+        };\n+\n+        match from {\n+            CValue::ByVal(val, _src_layout) => {\n+                fx.bcx.ins().store(MemFlags::new(), val, addr, 0);\n+            }\n+            CValue::ByValPair(val1, val2, _src_layout) => {\n+                let val1_offset = dst_layout.fields.offset(0).bytes() as i32;\n+                let val2_offset = dst_layout.fields.offset(1).bytes() as i32;\n+                fx.bcx.ins().store(MemFlags::new(), val1, addr, val1_offset);\n+                fx.bcx.ins().store(MemFlags::new(), val2, addr, val2_offset);\n+            }\n+            CValue::ByRef(from, src_layout) => {\n+                let size = dst_layout.size.bytes();\n+                let src_align = src_layout.align.abi.bytes() as u8;\n+                let dst_align = dst_layout.align.abi.bytes() as u8;\n+                fx.bcx.emit_small_memcpy(\n+                    fx.module.target_config(),\n+                    addr,\n+                    from,\n+                    size,\n+                    dst_align,\n+                    src_align,\n+                );\n+            }\n+        }\n+    }\n+\n+    pub fn place_field(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+        field: mir::Field,\n+    ) -> CPlace<'tcx> {\n+        let layout = self.layout();\n+        let (base, extra) = self.to_addr_maybe_unsized(fx);\n+\n+        let (field_ptr, field_layout) = codegen_field(fx, base, layout, field);\n+        let extra = if field_layout.is_unsized() {\n+            assert!(extra.is_some());\n+            extra\n+        } else {\n+            None\n+        };\n+        CPlace::Addr(field_ptr, extra, field_layout)\n+    }\n+\n+    pub fn place_index(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+        index: Value,\n+    ) -> CPlace<'tcx> {\n+        let (elem_layout, addr) = match self.layout().ty.sty {\n+            ty::Array(elem_ty, _) => (fx.layout_of(elem_ty), self.to_addr(fx)),\n+            ty::Slice(elem_ty) => (fx.layout_of(elem_ty), self.to_addr_maybe_unsized(fx).0),\n+            _ => bug!(\"place_index({:?})\", self.layout().ty),\n+        };\n+\n+        let offset = fx\n+            .bcx\n+            .ins()\n+            .imul_imm(index, elem_layout.size.bytes() as i64);\n+\n+        CPlace::Addr(fx.bcx.ins().iadd(addr, offset), None, elem_layout)\n+    }\n+\n+    pub fn place_deref(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> CPlace<'tcx> {\n+        let inner_layout = fx.layout_of(self.layout().ty.builtin_deref(true).unwrap().ty);\n+        if !inner_layout.is_unsized() {\n+            CPlace::Addr(self.to_cvalue(fx).load_scalar(fx), None, inner_layout)\n+        } else {\n+            match self.layout().abi {\n+                Abi::ScalarPair(ref a, ref b) => {\n+                    let addr = self.to_addr(fx);\n+                    let ptr =\n+                        fx.bcx\n+                            .ins()\n+                            .load(scalar_to_clif_type(fx.tcx, a.clone()), MemFlags::new(), addr, 0);\n+                    let extra = fx.bcx.ins().load(\n+                        scalar_to_clif_type(fx.tcx, b.clone()),\n+                        MemFlags::new(),\n+                        addr,\n+                        a.value.size(&fx.tcx).bytes() as u32 as i32,\n+                    );\n+                    CPlace::Addr(ptr, Some(extra), inner_layout)\n+                }\n+                _ => bug!(\n+                    \"Fat ptr doesn't have abi ScalarPair, but it has {:?}\",\n+                    self.layout().abi\n+                ),\n+            }\n+        }\n+    }\n+\n+    pub fn write_place_ref(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n+        if !self.layout().is_unsized() {\n+            let ptr = CValue::ByVal(self.to_addr(fx), dest.layout());\n+            dest.write_cvalue(fx, ptr);\n+        } else {\n+            let (value, extra) = self.to_addr_maybe_unsized(fx);\n+\n+            match dest.layout().abi {\n+                Abi::ScalarPair(ref a, _) => {\n+                    let dest_addr = dest.to_addr(fx);\n+                    fx.bcx.ins().store(MemFlags::new(), value, dest_addr, 0);\n+                    fx.bcx.ins().store(\n+                        MemFlags::new(),\n+                        extra.expect(\"unsized type without metadata\"),\n+                        dest_addr,\n+                        a.value.size(&fx.tcx).bytes() as u32 as i32,\n+                    );\n+                }\n+                _ => bug!(\n+                    \"Non ScalarPair abi {:?} in write_place_ref dest\",\n+                    dest.layout().abi\n+                ),\n+            }\n+        }\n+    }\n+\n+    pub fn unchecked_cast_to(self, layout: TyLayout<'tcx>) -> Self {\n+        assert!(!self.layout().is_unsized());\n+        match self {\n+            CPlace::Var(var, _) => CPlace::Var(var, layout),\n+            CPlace::Addr(addr, extra, _) => CPlace::Addr(addr, extra, layout),\n+            CPlace::Stack(stack_slot, _) => CPlace::Stack(stack_slot, layout),\n+            CPlace::NoPlace(_) => {\n+                assert!(layout.size.bytes() == 0);\n+                CPlace::NoPlace(layout)\n+            }\n+        }\n+    }\n+\n+    pub fn downcast_variant(\n+        self,\n+        fx: &FunctionCx<'a, 'tcx, impl Backend>,\n+        variant: VariantIdx,\n+    ) -> Self {\n+        let layout = self.layout().for_variant(fx, variant);\n+        self.unchecked_cast_to(layout)\n+    }\n+}"}]}