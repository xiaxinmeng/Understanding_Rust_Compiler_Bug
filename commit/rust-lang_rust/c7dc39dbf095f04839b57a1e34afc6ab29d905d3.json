{"sha": "c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZGMzOWRiZjA5NWYwNDgzOWI1N2ExZTM0YWZjNmFiMjlkOTA1ZDM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-20T08:45:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-30T21:02:59Z"}, "message": "intern CodeExtents\n\nMake a `CodeExtent<'tcx>` be something allocated in an arena\ninstead of an index into the `RegionMaps`.", "tree": {"sha": "af402b44cd3acabe29fce966c7ff781d203eede8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af402b44cd3acabe29fce966c7ff781d203eede8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "html_url": "https://github.com/rust-lang/rust/commit/c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55d6066c05fea0e0787ac5add67e26283468116c", "url": "https://api.github.com/repos/rust-lang/rust/commits/55d6066c05fea0e0787ac5add67e26283468116c", "html_url": "https://github.com/rust-lang/rust/commit/55d6066c05fea0e0787ac5add67e26283468116c"}], "stats": {"total": 1472, "additions": 729, "deletions": 743}, "files": [{"sha": "7b7c204a0ee77124a0fa8f16a64605ecdef42607", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -583,10 +583,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         scope_id: ast::NodeId,\n                         to_index: CFGIndex) {\n         let mut data = CFGEdgeData { exiting_scopes: vec![] };\n-        let mut scope = self.tcx.region_maps().node_extent(from_expr.id);\n-        let target_scope = self.tcx.region_maps().node_extent(scope_id);\n+        let mut scope = self.tcx.node_extent(from_expr.id);\n+        let target_scope = self.tcx.node_extent(scope_id);\n         while scope != target_scope {\n-            data.exiting_scopes.push(scope.node_id(&self.tcx.region_maps()));\n+            data.exiting_scopes.push(scope.node_id());\n             scope = self.tcx.region_maps().encl_scope(scope);\n         }\n         self.graph.add_edge(from_index, to_index, data);"}, {"sha": "52bdb5d02406e4f79a6f8a3bce9ef39fe111cbd0", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::subst::Kind<'t\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Region {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionKind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -432,17 +432,6 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtent\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            hcx.tcx().region_maps().code_extent_data(*self).hash_stable(hcx, hasher);\n-        });\n-    }\n-}\n-\n impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtentData\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -477,7 +466,7 @@ impl_stable_hash_for!(struct ty::adjustment::CoerceUnsizedInfo {\n     custom_kind\n });\n \n-impl_stable_hash_for!(struct ty::FreeRegion {\n+impl_stable_hash_for!(struct ty::FreeRegion<'tcx> {\n     scope,\n     bound_region\n });"}, {"sha": "1bac512e20977b087d4fdd09b35e336bbf8e8e9b", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -315,7 +315,7 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n         }\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             // Never make variables for regions bound within the type itself,\n             // nor for erased regions."}, {"sha": "f0b179fa2e4205ac2d8b5f6b1818b71e3d193308", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -78,8 +78,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         }\n     }\n \n-    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n-               -> RelateResult<'tcx, &'tcx ty::Region> {\n+    fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "8f2bdd4e85c77ac725745b0724b8f6ef90a0a8fd", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n                                    err: &mut DiagnosticBuilder,\n                                    prefix: &str,\n-                                   region: &'tcx ty::Region,\n+                                   region: ty::Region<'tcx>,\n                                    suffix: &str) {\n         fn item_scope_tag(item: &hir::Item) -> &'static str {\n             match item.node {\n@@ -124,14 +124,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n                             prefix, scope, suffix)\n                 };\n-                let span = match scope.span(&self.region_maps(), &self.hir) {\n+                let span = match scope.span(&self.hir) {\n                     Some(s) => s,\n                     None => {\n                         err.note(&unknown_scope());\n                         return;\n                     }\n                 };\n-                let tag = match self.hir.find(scope.node_id(&self.region_maps())) {\n+                let tag = match self.hir.find(scope.node_id()) {\n                     Some(hir_map::NodeBlock(_)) => \"block\",\n                     Some(hir_map::NodeExpr(expr)) => match expr.node {\n                         hir::ExprCall(..) => \"call\",\n@@ -151,7 +151,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         return;\n                     }\n                 };\n-                let scope_decorated_tag = match self.region_maps().code_extent_data(scope) {\n+                let scope_decorated_tag = match *scope {\n                     region::CodeExtentData::Misc(_) => tag,\n                     region::CodeExtentData::CallSiteScope { .. } => {\n                         \"scope of call-site for function\"\n@@ -184,7 +184,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 };\n \n-                let node = fr.scope.map(|s| s.node_id(&self.region_maps()))\n+                let node = fr.scope.map(|s| s.node_id())\n                                    .unwrap_or(DUMMY_NODE_ID);\n                 let unknown;\n                 let tag = match self.hir.find(node) {\n@@ -517,7 +517,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         values.1.push_normal(\"<\");\n                     }\n \n-                    fn lifetime_display(lifetime: &Region) -> String {\n+                    fn lifetime_display(lifetime: Region) -> String {\n                         let s = format!(\"{}\", lifetime);\n                         if s.is_empty() {\n                             \"'_\".to_string()\n@@ -769,7 +769,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn report_generic_bound_failure(&self,\n                                     origin: SubregionOrigin<'tcx>,\n                                     bound_kind: GenericKind<'tcx>,\n-                                    sub: &'tcx Region)\n+                                    sub: Region<'tcx>)\n     {\n         // FIXME: it would be better to report the first error message\n         // with the span of the parameter itself, rather than the span\n@@ -848,9 +848,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin<'tcx>,\n-                               sub_region: &'tcx Region,\n+                               sub_region: Region<'tcx>,\n                                sup_origin: SubregionOrigin<'tcx>,\n-                               sup_region: &'tcx Region) {\n+                               sup_region: Region<'tcx>) {\n         let mut err = self.report_inference_failure(var_origin);\n \n         self.tcx.note_and_explain_region(&mut err,"}, {"sha": "49952d81cbb0b8918bffae54a5b2769205506924", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -146,8 +146,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub(super) fn report_concrete_failure(&self,\n                                           origin: SubregionOrigin<'tcx>,\n-                                          sub: &'tcx Region,\n-                                          sup: &'tcx Region)\n+                                          sub: Region<'tcx>,\n+                                          sup: Region<'tcx>)\n                                           -> DiagnosticBuilder<'tcx> {\n         match origin {\n             infer::Subtype(trace) => {"}, {"sha": "ad67ef9a127d8fd79d6bf38be40afdc95dfe6531", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReEarlyBound(..) |\n             ty::ReLateBound(..) => {"}, {"sha": "a8bc33f772d55f2c4ffa0005f05cede611cca50d", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReVar(v) if self.region_vars.contains(&v) => {\n                 self.infcx.next_region_var(self.origin.clone())"}, {"sha": "d7afeba7dc96b430531a5697cd7ba019b4e8908f", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -59,8 +59,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         lattice::super_lattice_tys(self, a, b)\n     }\n \n-    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n-               -> RelateResult<'tcx, &'tcx ty::Region> {\n+    fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "09f909ef399d1652d130eaabc80901cb2b2f2694", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -269,9 +269,9 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n-                                             r0: &'tcx ty::Region)\n-                                             -> &'tcx ty::Region {\n+                                             a_map: &FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n+                                             r0: ty::Region<'tcx>)\n+                                             -> ty::Region<'tcx> {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // Variables created during LUB computation which are\n             // *related* to regions that pre-date the LUB computation\n             // stay as they are.\n-            if !tainted.iter().all(|r| is_var_in_set(new_vars, *r)) {\n+            if !tainted.iter().all(|&r| is_var_in_set(new_vars, r)) {\n                 debug!(\"generalize_region(r0={:?}): \\\n                         non-new-variables found in {:?}\",\n                        r0, tainted);\n@@ -365,11 +365,11 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n+                                             a_map: &FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n                                              a_vars: &[ty::RegionVid],\n                                              b_vars: &[ty::RegionVid],\n-                                             r0: &'tcx ty::Region)\n-                                             -> &'tcx ty::Region {\n+                                             r0: ty::Region<'tcx>)\n+                                             -> ty::Region<'tcx> {\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n                 return r0;\n@@ -434,8 +434,8 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn rev_lookup<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                       span: Span,\n-                                      a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n-                                      r: &'tcx ty::Region) -> &'tcx ty::Region\n+                                      a_map: &FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n+                                      r: ty::Region<'tcx>) -> ty::Region<'tcx>\n         {\n             for (a_br, a_r) in a_map {\n                 if *a_r == r {\n@@ -450,14 +450,14 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn fresh_bound_variable<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                                 debruijn: ty::DebruijnIndex)\n-                                                -> &'tcx ty::Region {\n+                                                -> ty::Region<'tcx> {\n             infcx.region_vars.new_bound(debruijn)\n         }\n     }\n }\n \n fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n-                           map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+                           map: &FxHashMap<ty::BoundRegion, ty::Region<'tcx>>)\n                            -> Vec<ty::RegionVid> {\n     map.iter()\n        .map(|(_, &r)| match *r {\n@@ -472,7 +472,7 @@ fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n        .collect()\n }\n \n-fn is_var_in_set(new_vars: &[ty::RegionVid], r: &ty::Region) -> bool {\n+fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n     match *r {\n         ty::ReVar(ref v) => new_vars.iter().any(|x| x == v),\n         _ => false\n@@ -484,7 +484,7 @@ fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                          mut fldr: F)\n                                          -> T\n     where T: TypeFoldable<'tcx>,\n-          F: FnMut(&'tcx ty::Region, ty::DebruijnIndex) -> &'tcx ty::Region,\n+          F: FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx>,\n {\n     tcx.fold_regions(unbound_value, &mut false, |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,\n@@ -502,9 +502,9 @@ fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn tainted_regions(&self,\n                        snapshot: &CombinedSnapshot,\n-                       r: &'tcx ty::Region,\n+                       r: ty::Region<'tcx>,\n                        directions: TaintDirections)\n-                       -> FxHashSet<&'tcx ty::Region> {\n+                       -> FxHashSet<ty::Region<'tcx>> {\n         self.region_vars.tainted(&snapshot.region_vars_snapshot, r, directions)\n     }\n \n@@ -731,7 +731,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // region back to the `ty::BoundRegion` that it originally\n         // represented. Because `leak_check` passed, we know that\n         // these taint sets are mutually disjoint.\n-        let inv_skol_map: FxHashMap<&'tcx ty::Region, ty::BoundRegion> =\n+        let inv_skol_map: FxHashMap<ty::Region<'tcx>, ty::BoundRegion> =\n             skol_map\n             .iter()\n             .flat_map(|(&skol_br, &skol)| {"}, {"sha": "04b470b29fc5e081b6127d850fe811c3b8ea08f2", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -59,8 +59,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         lattice::super_lattice_tys(self, a, b)\n     }\n \n-    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n-               -> RelateResult<'tcx, &'tcx ty::Region> {\n+    fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "a0451c5fe0b4df2b54927dc8d86de7dcf20992fe", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -205,7 +205,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n /// region that each late-bound region was replaced with.\n-pub type SkolemizationMap<'tcx> = FxHashMap<ty::BoundRegion, &'tcx ty::Region>;\n+pub type SkolemizationMap<'tcx> = FxHashMap<ty::BoundRegion, ty::Region<'tcx>>;\n \n /// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n@@ -1008,7 +1008,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn add_given(&self,\n-                     sub: ty::FreeRegion,\n+                     sub: ty::FreeRegion<'tcx>,\n                      sup: ty::RegionVid)\n     {\n         self.region_vars.add_given(sub, sup);\n@@ -1107,8 +1107,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn sub_regions(&self,\n                        origin: SubregionOrigin<'tcx>,\n-                       a: &'tcx ty::Region,\n-                       b: &'tcx ty::Region) {\n+                       a: ty::Region<'tcx>,\n+                       b: ty::Region<'tcx>) {\n         debug!(\"sub_regions({:?} <: {:?})\", a, b);\n         self.region_vars.make_subregion(origin, a, b);\n     }\n@@ -1210,7 +1210,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn next_region_var(&self, origin: RegionVariableOrigin)\n-                           -> &'tcx ty::Region {\n+                           -> ty::Region<'tcx> {\n         self.tcx.mk_region(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n@@ -1219,7 +1219,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn region_var_for_def(&self,\n                               span: Span,\n                               def: &ty::RegionParameterDef)\n-                              -> &'tcx ty::Region {\n+                              -> ty::Region<'tcx> {\n         self.next_region_var(EarlyBoundRegion(span, def.name, def.issue_32330))\n     }\n \n@@ -1270,7 +1270,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> &'tcx ty::Region {\n+    pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> ty::Region<'tcx> {\n         self.region_vars.new_bound(debruijn)\n     }\n \n@@ -1322,7 +1322,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn resolve_regions_and_report_errors(&self,\n-                                             free_regions: &FreeRegionMap,\n+                                             free_regions: &FreeRegionMap<'tcx>,\n                                              subject_node_id: ast::NodeId) {\n         let errors = self.region_vars.resolve_regions(free_regions, subject_node_id);\n         if !self.is_tainted_by_errors() {\n@@ -1531,7 +1531,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n         value: &ty::Binder<T>)\n-        -> (T, FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+        -> (T, FxHashMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where T : TypeFoldable<'tcx>\n     {\n         self.tcx.replace_late_bound_regions(\n@@ -1577,7 +1577,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn verify_generic_bound(&self,\n                                 origin: SubregionOrigin<'tcx>,\n                                 kind: GenericKind<'tcx>,\n-                                a: &'tcx ty::Region,\n+                                a: ty::Region<'tcx>,\n                                 bound: VerifyBound<'tcx>) {\n         debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\",\n                kind,"}, {"sha": "7de81e14d7754f66efa6ccf8aeb689b038e335f9", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -123,20 +123,20 @@ struct ConstraintGraph<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     graph_name: String,\n     map: &'a FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n-    node_ids: FxHashMap<Node, usize>,\n+    node_ids: FxHashMap<Node<'tcx>, usize>,\n }\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug, Copy)]\n-enum Node {\n+enum Node<'tcx> {\n     RegionVid(ty::RegionVid),\n-    Region(ty::Region),\n+    Region(ty::RegionKind<'tcx>),\n }\n \n // type Edge = Constraint;\n #[derive(Clone, PartialEq, Eq, Debug, Copy)]\n enum Edge<'tcx> {\n     Constraint(Constraint<'tcx>),\n-    EnclScope(CodeExtent, CodeExtent),\n+    EnclScope(CodeExtent<'tcx>, CodeExtent<'tcx>),\n }\n \n impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n@@ -160,8 +160,8 @@ impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n             }\n \n             tcx.region_maps().each_encl_scope(|sub, sup| {\n-                add_node(Node::Region(ty::ReScope(*sub)));\n-                add_node(Node::Region(ty::ReScope(*sup)));\n+                add_node(Node::Region(ty::ReScope(sub)));\n+                add_node(Node::Region(ty::ReScope(sup)));\n             });\n         }\n \n@@ -175,7 +175,7 @@ impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n-    type Node = Node;\n+    type Node = Node<'tcx>;\n     type Edge = Edge<'tcx>;\n     fn graph_id(&self) -> dot::Id {\n         dot::Id::new(&*self.graph_name).unwrap()\n@@ -208,7 +208,7 @@ impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n+fn constraint_to_nodes<'tcx>(c: &Constraint<'tcx>) -> (Node<'tcx>, Node<'tcx>) {\n     match *c {\n         Constraint::ConstrainVarSubVar(rv_1, rv_2) =>\n             (Node::RegionVid(rv_1), Node::RegionVid(rv_2)),\n@@ -221,7 +221,7 @@ fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n     }\n }\n \n-fn edge_to_nodes(e: &Edge) -> (Node, Node) {\n+fn edge_to_nodes<'tcx>(e: &Edge<'tcx>) -> (Node<'tcx>, Node<'tcx>) {\n     match *e {\n         Edge::Constraint(ref c) => constraint_to_nodes(c),\n         Edge::EnclScope(sub, sup) => {\n@@ -232,9 +232,9 @@ fn edge_to_nodes(e: &Edge) -> (Node, Node) {\n }\n \n impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n-    type Node = Node;\n+    type Node = Node<'tcx>;\n     type Edge = Edge<'tcx>;\n-    fn nodes(&self) -> dot::Nodes<Node> {\n+    fn nodes(&self) -> dot::Nodes<Node<'tcx>> {\n         let mut set = FxHashSet();\n         for node in self.node_ids.keys() {\n             set.insert(*node);\n@@ -245,16 +245,16 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     fn edges(&self) -> dot::Edges<Edge<'tcx>> {\n         debug!(\"constraint graph has {} edges\", self.map.len());\n         let mut v: Vec<_> = self.map.keys().map(|e| Edge::Constraint(*e)).collect();\n-        self.tcx.region_maps().each_encl_scope(|sub, sup| v.push(Edge::EnclScope(*sub, *sup)));\n+        self.tcx.region_maps().each_encl_scope(|sub, sup| v.push(Edge::EnclScope(sub, sup)));\n         debug!(\"region graph has {} edges\", v.len());\n         Cow::Owned(v)\n     }\n-    fn source(&self, edge: &Edge<'tcx>) -> Node {\n+    fn source(&self, edge: &Edge<'tcx>) -> Node<'tcx> {\n         let (n1, _) = edge_to_nodes(edge);\n         debug!(\"edge {:?} has source {:?}\", edge, n1);\n         n1\n     }\n-    fn target(&self, edge: &Edge<'tcx>) -> Node {\n+    fn target(&self, edge: &Edge<'tcx>) -> Node<'tcx> {\n         let (_, n2) = edge_to_nodes(edge);\n         debug!(\"edge {:?} has target {:?}\", edge, n2);\n         n2"}, {"sha": "33754b738a09134d366fbb16f6c962562b884bbd", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -44,17 +44,17 @@ pub enum Constraint<'tcx> {\n     ConstrainVarSubVar(RegionVid, RegionVid),\n \n     // Concrete region is subregion of region variable\n-    ConstrainRegSubVar(&'tcx Region, RegionVid),\n+    ConstrainRegSubVar(Region<'tcx>, RegionVid),\n \n     // Region variable is subregion of concrete region. This does not\n     // directly affect inference, but instead is checked after\n     // inference is complete.\n-    ConstrainVarSubReg(RegionVid, &'tcx Region),\n+    ConstrainVarSubReg(RegionVid, Region<'tcx>),\n \n     // A constraint where neither side is a variable. This does not\n     // directly affect inference, but instead is checked after\n     // inference is complete.\n-    ConstrainRegSubReg(&'tcx Region, &'tcx Region),\n+    ConstrainRegSubReg(Region<'tcx>, Region<'tcx>),\n }\n \n // VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n@@ -66,7 +66,7 @@ pub enum Constraint<'tcx> {\n pub struct Verify<'tcx> {\n     kind: GenericKind<'tcx>,\n     origin: SubregionOrigin<'tcx>,\n-    region: &'tcx Region,\n+    region: Region<'tcx>,\n     bound: VerifyBound<'tcx>,\n }\n \n@@ -86,14 +86,14 @@ pub enum VerifyBound<'tcx> {\n     // Put another way, the subject value is known to outlive all\n     // regions in {R}, so if any of those outlives 'min, then the\n     // bound is met.\n-    AnyRegion(Vec<&'tcx Region>),\n+    AnyRegion(Vec<Region<'tcx>>),\n \n     // B = forall {R} --> all 'r in {R} must outlive 'min\n     //\n     // Put another way, the subject value is known to outlive some\n     // region in {R}, so if all of those outlives 'min, then the bound\n     // is met.\n-    AllRegions(Vec<&'tcx Region>),\n+    AllRegions(Vec<Region<'tcx>>),\n \n     // B = exists {B} --> 'min must meet some bound b in {B}\n     AnyBound(Vec<VerifyBound<'tcx>>),\n@@ -104,8 +104,8 @@ pub enum VerifyBound<'tcx> {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct TwoRegions<'tcx> {\n-    a: &'tcx Region,\n-    b: &'tcx Region,\n+    a: Region<'tcx>,\n+    b: Region<'tcx>,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -128,7 +128,7 @@ pub enum UndoLogEntry<'tcx> {\n     AddVerify(usize),\n \n     /// We added the given `given`\n-    AddGiven(ty::FreeRegion, ty::RegionVid),\n+    AddGiven(ty::FreeRegion<'tcx>, ty::RegionVid),\n \n     /// We added a GLB/LUB \"combinaton variable\"\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n@@ -153,13 +153,13 @@ pub enum RegionResolutionError<'tcx> {\n     /// `ConcreteFailure(o, a, b)`:\n     ///\n     /// `o` requires that `a <= b`, but this does not hold\n-    ConcreteFailure(SubregionOrigin<'tcx>, &'tcx Region, &'tcx Region),\n+    ConcreteFailure(SubregionOrigin<'tcx>, Region<'tcx>, Region<'tcx>),\n \n     /// `GenericBoundFailure(p, s, a)\n     ///\n     /// The parameter/associated-type `p` must be known to outlive the lifetime\n     /// `a` (but none of the known bounds are sufficient).\n-    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, &'tcx Region),\n+    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region<'tcx>),\n \n     /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n     ///\n@@ -168,14 +168,14 @@ pub enum RegionResolutionError<'tcx> {\n     /// `sub_r <= sup_r` does not hold.\n     SubSupConflict(RegionVariableOrigin,\n                    SubregionOrigin<'tcx>,\n-                   &'tcx Region,\n+                   Region<'tcx>,\n                    SubregionOrigin<'tcx>,\n-                   &'tcx Region),\n+                   Region<'tcx>),\n }\n \n #[derive(Clone, Debug)]\n pub enum ProcessedErrorOrigin<'tcx> {\n-    ConcreteFailure(SubregionOrigin<'tcx>, &'tcx Region, &'tcx Region),\n+    ConcreteFailure(SubregionOrigin<'tcx>, Region<'tcx>, Region<'tcx>),\n     VariableFailure(RegionVariableOrigin),\n }\n \n@@ -214,7 +214,7 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // record the fact that `'a <= 'b` is implied by the fn signature,\n     // and then ignore the constraint when solving equations. This is\n     // a bit of a hack but seems to work.\n-    givens: RefCell<FxHashSet<(ty::FreeRegion, ty::RegionVid)>>,\n+    givens: RefCell<FxHashSet<(ty::FreeRegion<'tcx>, ty::RegionVid)>>,\n \n     lubs: RefCell<CombineMap<'tcx>>,\n     glbs: RefCell<CombineMap<'tcx>>,\n@@ -271,12 +271,12 @@ impl TaintDirections {\n \n struct TaintSet<'tcx> {\n     directions: TaintDirections,\n-    regions: FxHashSet<&'tcx ty::Region>\n+    regions: FxHashSet<ty::Region<'tcx>>\n }\n \n impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n     fn new(directions: TaintDirections,\n-           initial_region: &'tcx ty::Region)\n+           initial_region: ty::Region<'tcx>)\n            -> Self {\n         let mut regions = FxHashSet();\n         regions.insert(initial_region);\n@@ -328,7 +328,7 @@ impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n         }\n     }\n \n-    fn into_set(self) -> FxHashSet<&'tcx ty::Region> {\n+    fn into_set(self) -> FxHashSet<ty::Region<'tcx>> {\n         self.regions\n     }\n \n@@ -337,8 +337,8 @@ impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n     }\n \n     fn add_edge(&mut self,\n-                source: &'tcx ty::Region,\n-                target: &'tcx ty::Region) {\n+                source: ty::Region<'tcx>,\n+                target: ty::Region<'tcx>) {\n         if self.directions.incoming {\n             if self.regions.contains(&target) {\n                 self.regions.insert(source);\n@@ -499,7 +499,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// it's just there to make it explicit which snapshot bounds the\n     /// skolemized region that results. It should always be the top-most snapshot.\n     pub fn push_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot)\n-                           -> &'tcx Region {\n+                           -> Region<'tcx> {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n \n@@ -513,7 +513,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// completes to remove all trace of the skolemized regions\n     /// created in that time.\n     pub fn pop_skolemized(&self,\n-                          skols: &FxHashSet<&'tcx ty::Region>,\n+                          skols: &FxHashSet<ty::Region<'tcx>>,\n                           snapshot: &RegionSnapshot) {\n         debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n \n@@ -567,7 +567,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         self.skolemization_count.set(snapshot.skolemization_count);\n         return;\n \n-        fn kill_constraint<'tcx>(skols: &FxHashSet<&'tcx ty::Region>,\n+        fn kill_constraint<'tcx>(skols: &FxHashSet<ty::Region<'tcx>>,\n                                  undo_entry: &UndoLogEntry<'tcx>)\n                                  -> bool {\n             match undo_entry {\n@@ -596,7 +596,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     }\n \n-    pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> &'tcx Region {\n+    pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> Region<'tcx> {\n         // Creates a fresh bound variable for use in GLB computations.\n         // See discussion of GLB computation in the large comment at\n         // the top of this file for more details.\n@@ -662,7 +662,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn add_given(&self, sub: ty::FreeRegion, sup: ty::RegionVid) {\n+    pub fn add_given(&self, sub: ty::FreeRegion<'tcx>, sup: ty::RegionVid) {\n         // cannot add givens once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -676,8 +676,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     pub fn make_eqregion(&self,\n                          origin: SubregionOrigin<'tcx>,\n-                         sub: &'tcx Region,\n-                         sup: &'tcx Region) {\n+                         sub: Region<'tcx>,\n+                         sup: Region<'tcx>) {\n         if sub != sup {\n             // Eventually, it would be nice to add direct support for\n             // equating regions.\n@@ -692,8 +692,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     pub fn make_subregion(&self,\n                           origin: SubregionOrigin<'tcx>,\n-                          sub: &'tcx Region,\n-                          sup: &'tcx Region) {\n+                          sub: Region<'tcx>,\n+                          sup: Region<'tcx>) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -734,7 +734,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     pub fn verify_generic_bound(&self,\n                                 origin: SubregionOrigin<'tcx>,\n                                 kind: GenericKind<'tcx>,\n-                                sub: &'tcx Region,\n+                                sub: Region<'tcx>,\n                                 bound: VerifyBound<'tcx>) {\n         self.add_verify(Verify {\n             kind: kind,\n@@ -746,9 +746,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     pub fn lub_regions(&self,\n                        origin: SubregionOrigin<'tcx>,\n-                       a: &'tcx Region,\n-                       b: &'tcx Region)\n-                       -> &'tcx Region {\n+                       a: Region<'tcx>,\n+                       b: Region<'tcx>)\n+                       -> Region<'tcx> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -772,9 +772,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     pub fn glb_regions(&self,\n                        origin: SubregionOrigin<'tcx>,\n-                       a: &'tcx Region,\n-                       b: &'tcx Region)\n-                       -> &'tcx Region {\n+                       a: Region<'tcx>,\n+                       b: Region<'tcx>)\n+                       -> Region<'tcx> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -796,7 +796,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_var(&self, rid: RegionVid) -> &'tcx ty::Region {\n+    pub fn resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n         match *self.values.borrow() {\n             None => {\n                 span_bug!((*self.var_origins.borrow())[rid.index as usize].span(),\n@@ -811,7 +811,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn opportunistic_resolve_var(&self, rid: RegionVid) -> &'tcx ty::Region {\n+    pub fn opportunistic_resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n         let vid = self.unification_table.borrow_mut().find_value(rid).min_vid;\n         self.tcx.mk_region(ty::ReVar(vid))\n     }\n@@ -825,12 +825,12 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     pub fn combine_vars<F>(&self,\n                            t: CombineMapType,\n-                           a: &'tcx Region,\n-                           b: &'tcx Region,\n+                           a: Region<'tcx>,\n+                           b: Region<'tcx>,\n                            origin: SubregionOrigin<'tcx>,\n                            mut relate: F)\n-                           -> &'tcx Region\n-        where F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, &'tcx Region, &'tcx Region)\n+                           -> Region<'tcx>\n+        where F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, Region<'tcx>, Region<'tcx>)\n     {\n         let vars = TwoRegions { a: a, b: b };\n         if let Some(&c) = self.combine_map(t).borrow().get(&vars) {\n@@ -869,9 +869,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// related to other regions.\n     pub fn tainted(&self,\n                    mark: &RegionSnapshot,\n-                   r0: &'tcx Region,\n+                   r0: Region<'tcx>,\n                    directions: TaintDirections)\n-                   -> FxHashSet<&'tcx ty::Region> {\n+                   -> FxHashSet<ty::Region<'tcx>> {\n         debug!(\"tainted(mark={:?}, r0={:?}, directions={:?})\",\n                mark, r0, directions);\n \n@@ -892,7 +892,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// constraints, assuming such values can be found; if they cannot,\n     /// errors are reported.\n     pub fn resolve_regions(&self,\n-                           free_regions: &FreeRegionMap,\n+                           free_regions: &FreeRegionMap<'tcx>,\n                            subject_node: ast::NodeId)\n                            -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n@@ -903,10 +903,10 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     }\n \n     fn lub_concrete_regions(&self,\n-                            free_regions: &FreeRegionMap,\n-                            a: &'tcx Region,\n-                            b: &'tcx Region)\n-                            -> &'tcx Region {\n+                            free_regions: &FreeRegionMap<'tcx>,\n+                            a: Region<'tcx>,\n+                            b: Region<'tcx>)\n+                            -> Region<'tcx> {\n         match (a, b) {\n             (&ReLateBound(..), _) |\n             (_, &ReLateBound(..)) |\n@@ -961,8 +961,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                     self.tcx.region_maps().nearest_common_ancestor(a_id, b_id)))\n             }\n \n-            (&ReFree(a_fr), &ReFree(b_fr)) => {\n-                self.tcx.mk_region(free_regions.lub_free_regions(a_fr, b_fr))\n+            (&ReFree(_), &ReFree(_)) => {\n+                free_regions.lub_free_regions(self.tcx, a, b)\n             }\n \n             // For these types, we cannot define any additional\n@@ -983,20 +983,20 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n #[derive(Copy, Clone, Debug)]\n pub enum VarValue<'tcx> {\n-    Value(&'tcx Region),\n+    Value(Region<'tcx>),\n     ErrorValue,\n }\n \n struct RegionAndOrigin<'tcx> {\n-    region: &'tcx Region,\n+    region: Region<'tcx>,\n     origin: SubregionOrigin<'tcx>,\n }\n \n type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     fn infer_variable_values(&self,\n-                             free_regions: &FreeRegionMap,\n+                             free_regions: &FreeRegionMap<'tcx>,\n                              errors: &mut Vec<RegionResolutionError<'tcx>>,\n                              subject: ast::NodeId)\n                              -> Vec<VarValue<'tcx>> {\n@@ -1056,7 +1056,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn expansion(&self, free_regions: &FreeRegionMap, var_values: &mut [VarValue<'tcx>]) {\n+    fn expansion(&self, free_regions: &FreeRegionMap<'tcx>, var_values: &mut [VarValue<'tcx>]) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n             debug!(\"expansion: constraint={:?} origin={:?}\",\n                    constraint, origin);\n@@ -1085,8 +1085,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     }\n \n     fn expand_node(&self,\n-                   free_regions: &FreeRegionMap,\n-                   a_region: &'tcx Region,\n+                   free_regions: &FreeRegionMap<'tcx>,\n+                   a_region: Region<'tcx>,\n                    b_vid: RegionVid,\n                    b_data: &mut VarValue<'tcx>)\n                    -> bool {\n@@ -1132,7 +1132,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// cases where the region cannot grow larger than a fixed point)\n     /// and check that they are satisfied.\n     fn collect_errors(&self,\n-                      free_regions: &FreeRegionMap,\n+                      free_regions: &FreeRegionMap<'tcx>,\n                       var_data: &mut Vec<VarValue<'tcx>>,\n                       errors: &mut Vec<RegionResolutionError<'tcx>>) {\n         let constraints = self.constraints.borrow();\n@@ -1209,7 +1209,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// Go over the variables that were declared to be error variables\n     /// and create a `RegionResolutionError` for each of them.\n     fn collect_var_errors(&self,\n-                          free_regions: &FreeRegionMap,\n+                          free_regions: &FreeRegionMap<'tcx>,\n                           var_data: &[VarValue<'tcx>],\n                           graph: &RegionGraph<'tcx>,\n                           errors: &mut Vec<RegionResolutionError<'tcx>>) {\n@@ -1311,7 +1311,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     }\n \n     fn collect_error_for_expanding_node(&self,\n-                                        free_regions: &FreeRegionMap,\n+                                        free_regions: &FreeRegionMap<'tcx>,\n                                         graph: &RegionGraph<'tcx>,\n                                         dup_vec: &mut [u32],\n                                         node_idx: RegionVid,\n@@ -1480,8 +1480,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n fn normalize<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                              values: &Vec<VarValue<'tcx>>,\n-                             r: &'tcx ty::Region)\n-                             -> &'tcx ty::Region {\n+                             r: ty::Region<'tcx>)\n+                             -> ty::Region<'tcx> {\n     match *r {\n         ty::ReVar(rid) => lookup(tcx, values, rid),\n         _ => r,\n@@ -1491,7 +1491,7 @@ fn normalize<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n fn lookup<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                           values: &Vec<VarValue<'tcx>>,\n                           rid: ty::RegionVid)\n-                          -> &'tcx ty::Region {\n+                          -> ty::Region<'tcx> {\n     match values[rid.index as usize] {\n         Value(r) => r,\n         ErrorValue => tcx.types.re_static, // Previously reported error.\n@@ -1539,7 +1539,7 @@ impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n-    fn for_each_region(&self, f: &mut FnMut(&'tcx ty::Region)) {\n+    fn for_each_region(&self, f: &mut FnMut(ty::Region<'tcx>)) {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) |\n             &VerifyBound::AllRegions(ref rs) => for &r in rs {\n@@ -1592,9 +1592,9 @@ impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n     }\n \n     fn is_met(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-              free_regions: &FreeRegionMap,\n+              free_regions: &FreeRegionMap<'tcx>,\n               var_values: &Vec<VarValue<'tcx>>,\n-              min: &'tcx ty::Region)\n+              min: ty::Region<'tcx>)\n               -> bool {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) =>"}, {"sha": "2e8b843d07b30e99e4dce0c3d754279b921118f3", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n         }\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReVar(rid) => self.infcx.region_vars.opportunistic_resolve_var(rid),\n             _ => r,\n@@ -138,7 +138,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n         }\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReVar(rid) => self.infcx.region_vars.resolve_var(rid),\n             _ => r,"}, {"sha": "487195fdfae9f833bff88a645ab6691bbab8c6de", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -127,8 +127,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         }\n     }\n \n-    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n-               -> RelateResult<'tcx, &'tcx ty::Region> {\n+    fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"{}.regions({:?}, {:?}) self.cause={:?}\",\n                self.tag(), a, b, self.fields.cause);\n "}, {"sha": "9be05313439fd1648db0dccbf6191d7ea85462a4", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -75,7 +75,7 @@ pub trait Delegate<'tcx> {\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              loan_region: &'tcx ty::Region,\n+              loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: LoanCause);\n \n@@ -347,7 +347,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n     fn borrow_expr(&mut self,\n                    expr: &hir::Expr,\n-                   r: &'tcx ty::Region,\n+                   r: ty::Region<'tcx>,\n                    bk: ty::BorrowKind,\n                    cause: LoanCause) {\n         debug!(\"borrow_expr(expr={:?}, r={:?}, bk={:?})\","}, {"sha": "1dc633c6d0040b060bbe7e59596c84ecd8f3b00f", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 65, "deletions": 69, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -15,34 +15,38 @@\n //! `TransitiveRelation` type and use that to decide when one free\n //! region outlives another and so forth.\n \n-use ty::{self, TyCtxt, FreeRegion, Region};\n+use ty::{self, Lift, TyCtxt, Region};\n use ty::wf::ImpliedBound;\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub struct FreeRegionMap {\n+pub struct FreeRegionMap<'tcx> {\n     // Stores the relation `a < b`, where `a` and `b` are regions.\n-    relation: TransitiveRelation<Region>\n+    //\n+    // Invariant: only free regions like `'x` or `'static` are stored\n+    // in this relation, not scopes.\n+    relation: TransitiveRelation<Region<'tcx>>\n }\n \n-impl FreeRegionMap {\n-    pub fn new() -> FreeRegionMap {\n+impl<'tcx> FreeRegionMap<'tcx> {\n+    pub fn new() -> Self {\n         FreeRegionMap { relation: TransitiveRelation::new() }\n     }\n \n     pub fn is_empty(&self) -> bool {\n         self.relation.is_empty()\n     }\n \n-    pub fn relate_free_regions_from_implied_bounds<'tcx>(&mut self,\n-                                                        implied_bounds: &[ImpliedBound<'tcx>])\n+    pub fn relate_free_regions_from_implied_bounds(&mut self,\n+                                                   implied_bounds: &[ImpliedBound<'tcx>])\n     {\n         debug!(\"relate_free_regions_from_implied_bounds()\");\n         for implied_bound in implied_bounds {\n             debug!(\"implied bound: {:?}\", implied_bound);\n             match *implied_bound {\n-                ImpliedBound::RegionSubRegion(&ty::ReFree(free_a), &ty::ReFree(free_b)) => {\n-                    self.relate_free_regions(free_a, free_b);\n+                ImpliedBound::RegionSubRegion(a @ &ty::ReFree(_), b @ &ty::ReFree(_)) |\n+                ImpliedBound::RegionSubRegion(a @ &ty::ReStatic, b @ &ty::ReFree(_)) => {\n+                    self.relate_regions(a, b);\n                 }\n                 ImpliedBound::RegionSubRegion(..) |\n                 ImpliedBound::RegionSubParam(..) |\n@@ -53,7 +57,7 @@ impl FreeRegionMap {\n     }\n \n     pub fn relate_free_regions_from_predicates(&mut self,\n-                                               predicates: &[ty::Predicate]) {\n+                                               predicates: &[ty::Predicate<'tcx>]) {\n         debug!(\"relate_free_regions_from_predicates(predicates={:?})\", predicates);\n         for predicate in predicates {\n             match *predicate {\n@@ -69,12 +73,15 @@ impl FreeRegionMap {\n                 }\n                 ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n                     match (r_a, r_b) {\n+                        // `'static: 'x` is not notable\n                         (&ty::ReStatic, &ty::ReFree(_)) => {},\n-                        (&ty::ReFree(fr_a), &ty::ReStatic) => self.relate_to_static(fr_a),\n-                        (&ty::ReFree(fr_a), &ty::ReFree(fr_b)) => {\n+\n+                        (&ty::ReFree(_), &ty::ReStatic) |\n+                        (&ty::ReFree(_), &ty::ReFree(_)) => {\n                             // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n-                            self.relate_free_regions(fr_b, fr_a);\n+                            self.relate_regions(r_b, r_a);\n                         }\n+\n                         _ => {\n                             // All named regions are instantiated with free regions.\n                             bug!(\"record_region_bounds: non free region: {:?} / {:?}\",\n@@ -87,48 +94,36 @@ impl FreeRegionMap {\n         }\n     }\n \n-    fn relate_to_static(&mut self, sup: FreeRegion) {\n-        self.relation.add(ty::ReStatic, ty::ReFree(sup));\n-    }\n-\n-    fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n-        self.relation.add(ty::ReFree(sub), ty::ReFree(sup))\n-    }\n-\n-    /// Determines whether two free regions have a subregion relationship\n-    /// by walking the graph encoded in `map`.  Note that\n-    /// it is possible that `sub != sup` and `sub <= sup` and `sup <= sub`\n-    /// (that is, the user can give two different names to the same lifetime).\n-    pub fn sub_free_region(&self, sub: FreeRegion, sup: FreeRegion) -> bool {\n-        let result = sub == sup || {\n-            let sub = ty::ReFree(sub);\n-            let sup = ty::ReFree(sup);\n-            self.relation.contains(&sub, &sup) || self.relation.contains(&ty::ReStatic, &sup)\n-        };\n-        debug!(\"sub_free_region(sub={:?}, sup={:?}) = {:?}\", sub, sup, result);\n-        result\n+    fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n+        assert!(match *sub { ty::ReFree(_) | ty::ReStatic => true, _ => false });\n+        assert!(match *sup { ty::ReFree(_) | ty::ReStatic => true, _ => false });\n+        self.relation.add(sub, sup)\n     }\n \n-    pub fn lub_free_regions(&self, fr_a: FreeRegion, fr_b: FreeRegion) -> Region {\n-        let r_a = ty::ReFree(fr_a);\n-        let r_b = ty::ReFree(fr_b);\n-        let result = if fr_a == fr_b { r_a } else {\n+    pub fn lub_free_regions<'a, 'gcx>(&self,\n+                                      tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                      r_a: Region<'tcx>,\n+                                      r_b: Region<'tcx>)\n+                                      -> Region<'tcx> {\n+        assert!(match *r_a { ty::ReFree(_) => true, _ => false });\n+        assert!(match *r_b { ty::ReFree(_) => true, _ => false });\n+        let result = if r_a == r_b { r_a } else {\n             match self.relation.postdom_upper_bound(&r_a, &r_b) {\n-                None => ty::ReStatic,\n+                None => tcx.mk_region(ty::ReStatic),\n                 Some(r) => *r,\n             }\n         };\n-        debug!(\"lub_free_regions(fr_a={:?}, fr_b={:?}) = {:?}\", fr_a, fr_b, result);\n+        debug!(\"lub_free_regions(r_a={:?}, r_b={:?}) = {:?}\", r_a, r_b, result);\n         result\n     }\n \n     /// Determines whether one region is a subregion of another.  This is intended to run *after\n     /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n-    pub fn is_subregion_of(&self,\n-                           tcx: TyCtxt,\n-                           sub_region: &ty::Region,\n-                           super_region: &ty::Region)\n-                           -> bool {\n+    pub fn is_subregion_of<'a, 'gcx>(&self,\n+                                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                     sub_region: ty::Region<'tcx>,\n+                                     super_region: ty::Region<'tcx>)\n+                                     -> bool {\n         let result = sub_region == super_region || {\n             match (sub_region, super_region) {\n                 (&ty::ReEmpty, _) |\n@@ -141,17 +136,18 @@ impl FreeRegionMap {\n                 (&ty::ReScope(sub_scope), &ty::ReFree(fr)) => {\n                     // 1. It is safe to unwrap `fr.scope` because we\n                     // should only ever wind up comparing against\n-                    // `ReScope` in the context of a method or fn\n+                    // `ReScope` in the context of a method or\n                     // body, where `fr.scope` should be `Some`.\n                     tcx.region_maps().is_subscope_of(sub_scope, fr.scope.unwrap() /*1*/) ||\n-                        self.is_static(fr)\n+                        self.is_static(tcx, super_region)\n                 }\n \n-                (&ty::ReFree(sub_fr), &ty::ReFree(super_fr)) =>\n-                    self.sub_free_region(sub_fr, super_fr),\n+                (&ty::ReFree(_), &ty::ReFree(_)) =>\n+                    self.relation.contains(&sub_region, &super_region) ||\n+                        self.is_static(tcx, super_region),\n \n-                (&ty::ReStatic, &ty::ReFree(sup_fr)) =>\n-                    self.is_static(sup_fr),\n+                (&ty::ReStatic, &ty::ReFree(_)) =>\n+                    self.is_static(tcx, super_region),\n \n                 _ =>\n                     false,\n@@ -163,28 +159,28 @@ impl FreeRegionMap {\n     }\n \n     /// Determines whether this free-region is required to be 'static\n-    pub fn is_static(&self, super_region: ty::FreeRegion) -> bool {\n+    fn is_static<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, super_region: ty::Region<'tcx>)\n+                           -> bool {\n         debug!(\"is_static(super_region={:?})\", super_region);\n-        self.relation.contains(&ty::ReStatic, &ty::ReFree(super_region))\n+        match *super_region {\n+            ty::ReStatic => true,\n+            ty::ReFree(_) => {\n+                let re_static = tcx.mk_region(ty::ReStatic);\n+                self.relation.contains(&re_static, &super_region)\n+            }\n+            _ => bug!(\"only free regions should be given to `is_static`\")\n+        }\n     }\n }\n \n-#[cfg(test)]\n-fn free_region(index: u32) -> FreeRegion {\n-    FreeRegion { scope: None, bound_region: ty::BoundRegion::BrAnon(index) }\n-}\n-\n-#[test]\n-fn lub() {\n-    // a very VERY basic test, but see the tests in\n-    // TransitiveRelation, which are much more thorough.\n-    let frs: Vec<_> = (0..3).map(|i| free_region(i)).collect();\n-    let mut map = FreeRegionMap::new();\n-    map.relate_free_regions(frs[0], frs[2]);\n-    map.relate_free_regions(frs[1], frs[2]);\n-    assert_eq!(map.lub_free_regions(frs[0], frs[1]), ty::ReFree(frs[2]));\n-}\n-\n-impl_stable_hash_for!(struct FreeRegionMap {\n+impl_stable_hash_for!(struct FreeRegionMap<'tcx> {\n     relation\n });\n+\n+impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n+    type Lifted = FreeRegionMap<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<FreeRegionMap<'tcx>> {\n+        self.relation.maybe_map(|&fr| fr.lift_to_tcx(tcx))\n+                     .map(|relation| FreeRegionMap { relation })\n+    }\n+}"}, {"sha": "1ea87cc0a4568347e15d1c11dc266c845f1a7c73", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -1441,7 +1441,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // and must outlive the *call-site* of the function.\n         let fn_ret =\n             self.ir.tcx.liberate_late_bound_regions(\n-                Some(self.ir.tcx.region_maps().call_site_extent(id, body.value.id)),\n+                Some(self.ir.tcx.call_site_extent(id, body.value.id)),\n                 &fn_ret);\n \n         if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {"}, {"sha": "3b1a9552ece26b5429842a10b4b28647b2698363", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -89,7 +89,7 @@ use std::rc::Rc;\n #[derive(Clone, PartialEq)]\n pub enum Categorization<'tcx> {\n     // temporary val, argument is its scope\n-    Rvalue(&'tcx ty::Region, &'tcx ty::Region),\n+    Rvalue(ty::Region<'tcx>, ty::Region<'tcx>),\n     StaticItem,\n     Upvar(Upvar),                          // upvar referenced by closure env\n     Local(ast::NodeId),                    // local variable\n@@ -114,13 +114,13 @@ pub enum PointerKind<'tcx> {\n     Unique,\n \n     /// `&T`\n-    BorrowedPtr(ty::BorrowKind, &'tcx ty::Region),\n+    BorrowedPtr(ty::BorrowKind, ty::Region<'tcx>),\n \n     /// `*T`\n     UnsafePtr(hir::Mutability),\n \n     /// Implicit deref of the `&T` that results from an overloaded index `[]`.\n-    Implicit(ty::BorrowKind, &'tcx ty::Region),\n+    Implicit(ty::BorrowKind, ty::Region<'tcx>),\n }\n \n // We use the term \"interior\" to mean \"something reachable from the\n@@ -796,7 +796,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n-            scope: Some(self.tcx().region_maps().item_extent(fn_body_id)),\n+            scope: Some(self.tcx().item_extent(fn_body_id)),\n             bound_region: ty::BrEnv\n         }));\n \n@@ -842,10 +842,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n     /// Returns the lifetime of a temporary created by expr with id `id`.\n     /// This could be `'static` if `id` is part of a constant expression.\n-    pub fn temporary_scope(&self, id: ast::NodeId) -> (&'tcx ty::Region, &'tcx ty::Region)\n+    pub fn temporary_scope(&self, id: ast::NodeId) -> (ty::Region<'tcx>, ty::Region<'tcx>)\n     {\n         let (scope, old_scope) =\n-            self.tcx().region_maps().old_and_new_temporary_scope(id);\n+            self.tcx().region_maps().old_and_new_temporary_scope(self.tcx(), id);\n         (self.tcx().mk_region(match scope {\n             Some(scope) => ty::ReScope(scope),\n             None => ty::ReStatic\n@@ -887,8 +887,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn cat_rvalue(&self,\n                       cmt_id: ast::NodeId,\n                       span: Span,\n-                      temp_scope: &'tcx ty::Region,\n-                      old_temp_scope: &'tcx ty::Region,\n+                      temp_scope: ty::Region<'tcx>,\n+                      old_temp_scope: ty::Region<'tcx>,\n                       expr_ty: Ty<'tcx>) -> cmt<'tcx> {\n         let ret = Rc::new(cmt_ {\n             id:cmt_id,"}, {"sha": "062432e27e549d67c37618ac424edf6964f3e9eb", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 140, "deletions": 219, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -17,14 +17,12 @@\n //! `middle/infer/region_inference/README.md`\n \n use hir::map as hir_map;\n-use session::Session;\n use util::nodemap::{FxHashMap, NodeMap, NodeSet};\n use ty;\n \n-use std::collections::hash_map::Entry;\n-use std::fmt;\n use std::mem;\n use std::rc::Rc;\n+use serialize;\n use syntax::codemap;\n use syntax::ast::{self, NodeId};\n use syntax_pos::Span;\n@@ -34,33 +32,12 @@ use ty::maps::Providers;\n use hir;\n use hir::def_id::{CrateNum, LOCAL_CRATE};\n use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n-use hir::{Body, Block, Item, FnDecl, Arm, Pat, PatKind, Stmt, Expr, Local};\n+use hir::{Block, Item, FnDecl, Arm, Pat, PatKind, Stmt, Expr, Local};\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n-           RustcDecodable, Copy)]\n-pub struct CodeExtent(u32);\n-\n-impl fmt::Debug for CodeExtent {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"CodeExtent({:?}\", self.0)?;\n-\n-        ty::tls::with_opt(|opt_tcx| {\n-            if let Some(tcx) = opt_tcx {\n-                let region_maps = tcx.region_maps();\n-                {\n-                    let code_extents = &region_maps.code_extents;\n-                    if let Some(data) = code_extents.get(self.0 as usize) {\n-                        write!(f, \"/{:?}\", data)?;\n-                    }\n-                    mem::drop(code_extents); // FIXME why is this necessary?\n-                }\n-            }\n-            Ok(())\n-        })?;\n+pub type CodeExtent<'tcx> = &'tcx CodeExtentData;\n \n-        write!(f, \")\")\n-    }\n-}\n+impl<'tcx> serialize::UseSpecializedEncodable for CodeExtent<'tcx> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for CodeExtent<'tcx> {}\n \n /// CodeExtent represents a statically-describable extent that can be\n /// used to bound the lifetime/region for values.\n@@ -123,7 +100,7 @@ impl fmt::Debug for CodeExtent {\n /// placate the same deriving in `ty::FreeRegion`, but we may want to\n /// actually attach a more meaningful ordering to scopes than the one\n /// generated via deriving here.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n pub enum CodeExtentData {\n     Misc(ast::NodeId),\n \n@@ -150,8 +127,8 @@ pub struct CallSiteScopeData {\n }\n \n impl CallSiteScopeData {\n-    pub fn to_code_extent(&self, region_maps: &RegionMaps) -> CodeExtent {\n-        region_maps.lookup_code_extent(\n+    pub fn to_code_extent<'a, 'tcx, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> CodeExtent<'tcx> {\n+        tcx.intern_code_extent(\n             match *self {\n                 CallSiteScopeData { fn_id, body_id } =>\n                     CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id },\n@@ -200,20 +177,14 @@ impl CodeExtentData {\n             CodeExtentData::ParameterScope { fn_id: _, body_id } => body_id,\n         }\n     }\n-}\n-\n-impl CodeExtent {\n-    pub fn node_id(&self, region_maps: &RegionMaps) -> ast::NodeId {\n-        region_maps.code_extent_data(*self).node_id()\n-    }\n \n     /// Returns the span of this CodeExtent.  Note that in general the\n     /// returned span may not correspond to the span of any node id in\n     /// the AST.\n-    pub fn span(&self, region_maps: &RegionMaps, hir_map: &hir_map::Map) -> Option<Span> {\n-        match hir_map.find(self.node_id(region_maps)) {\n+    pub fn span(&self, hir_map: &hir_map::Map) -> Option<Span> {\n+        match hir_map.find(self.node_id()) {\n             Some(hir_map::NodeBlock(ref blk)) => {\n-                match region_maps.code_extent_data(*self) {\n+                match *self {\n                     CodeExtentData::CallSiteScope { .. } |\n                     CodeExtentData::ParameterScope { .. } |\n                     CodeExtentData::Misc(_) |\n@@ -242,35 +213,33 @@ impl CodeExtent {\n }\n \n /// The region maps encode information about region relationships.\n-pub struct RegionMaps {\n-    code_extents: Vec<CodeExtentData>,\n-    code_extent_interner: FxHashMap<CodeExtentData, CodeExtent>,\n+pub struct RegionMaps<'tcx> {\n     /// `scope_map` maps from a scope id to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n     /// conditional expression or repeating block. (Note that the\n     /// enclosing scope id for the block associated with a closure is\n     /// the closure itself.)\n-    scope_map: Vec<Option<CodeExtent>>,\n+    scope_map: FxHashMap<CodeExtent<'tcx>, CodeExtent<'tcx>>,\n \n     /// `var_map` maps from a variable or binding id to the block in\n     /// which that variable is declared.\n-    var_map: NodeMap<CodeExtent>,\n+    var_map: NodeMap<CodeExtent<'tcx>>,\n \n     /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n     /// larger than the default. The map goes from the expression id\n     /// to the cleanup scope id. For rvalues not present in this\n     /// table, the appropriate cleanup scope is the innermost\n     /// enclosing statement, conditional expression, or repeating\n     /// block (see `terminating_scopes`).\n-    rvalue_scopes: NodeMap<CodeExtent>,\n+    rvalue_scopes: NodeMap<CodeExtent<'tcx>>,\n \n     /// Records the value of rvalue scopes before they were shrunk by\n     /// #36082, for error reporting.\n     ///\n     /// FIXME: this should be temporary. Remove this by 1.18.0 or\n     /// so.\n-    shrunk_rvalue_scopes: NodeMap<CodeExtent>,\n+    shrunk_rvalue_scopes: NodeMap<CodeExtent<'tcx>>,\n \n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n@@ -286,7 +255,7 @@ pub struct RegionMaps {\n }\n \n #[derive(Debug, Copy, Clone)]\n-pub struct Context {\n+pub struct Context<'tcx> {\n     /// the root of the current region tree. This is typically the id\n     /// of the innermost fn body. Each fn forms its own disjoint tree\n     /// in the region hierarchy. These fn bodies are themselves\n@@ -296,21 +265,21 @@ pub struct Context {\n     root_id: Option<ast::NodeId>,\n \n     /// the scope that contains any new variables declared\n-    var_parent: Option<CodeExtent>,\n+    var_parent: Option<CodeExtent<'tcx>>,\n \n     /// region parent of expressions etc\n-    parent: Option<CodeExtent>,\n+    parent: Option<CodeExtent<'tcx>>,\n }\n \n-struct RegionResolutionVisitor<'hir: 'a, 'a> {\n-    sess: &'a Session,\n+struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Generated maps:\n-    region_maps: &'a mut RegionMaps,\n+    region_maps: &'a mut RegionMaps<'tcx>,\n \n-    cx: Context,\n+    cx: Context<'tcx>,\n \n-    map: &'a hir_map::Map<'hir>,\n+    map: &'a hir_map::Map<'tcx>,\n \n     /// `terminating_scopes` is a set containing the ids of each\n     /// statement, or conditional/repeating expression. These scopes\n@@ -336,64 +305,13 @@ struct RegionResolutionVisitor<'hir: 'a, 'a> {\n }\n \n \n-impl RegionMaps {\n-    pub fn lookup_code_extent(&self, e: CodeExtentData) -> CodeExtent {\n-        match self.code_extent_interner.get(&e) {\n-            Some(&d) => d,\n-            None => bug!(\"unknown code extent {:?}\", e)\n-        }\n-    }\n-    pub fn node_extent(&self, n: ast::NodeId) -> CodeExtent {\n-        self.lookup_code_extent(CodeExtentData::Misc(n))\n-    }\n-    // Returns the code extent for an item - the destruction scope.\n-    pub fn item_extent(&self, n: ast::NodeId) -> CodeExtent {\n-        self.lookup_code_extent(CodeExtentData::DestructionScope(n))\n-    }\n-    pub fn call_site_extent(&self, fn_id: ast::NodeId, body_id: ast::NodeId) -> CodeExtent {\n-        assert!(fn_id != body_id);\n-        self.lookup_code_extent(CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id })\n-    }\n-    pub fn opt_destruction_extent(&self, n: ast::NodeId) -> Option<CodeExtent> {\n-        self.code_extent_interner.get(&CodeExtentData::DestructionScope(n)).cloned()\n-    }\n-    pub fn intern_code_extent(&mut self,\n-                              e: CodeExtentData,\n-                              parent: Option<CodeExtent>) -> CodeExtent {\n-        match self.code_extent_interner.entry(e) {\n-            Entry::Occupied(_) => {\n-                bug!(\"intern_code_extent: already exists\")\n-            }\n-            Entry::Vacant(v) => {\n-                if self.code_extents.len() > 0xffffffffusize {\n-                    bug!() // should pass a sess,\n-                           // but this isn't the only place\n-                }\n-                let idx = CodeExtent(self.code_extents.len() as u32);\n-                debug!(\"CodeExtent({:?}) = {:?} [parent={:?}]\", idx, e, parent);\n-                self.code_extents.push(e);\n-                self.scope_map.push(parent);\n-                *v.insert(idx)\n-            }\n-        }\n-    }\n-    pub fn intern_node(&mut self,\n-                       n: ast::NodeId,\n-                       parent: Option<CodeExtent>) -> CodeExtent {\n-        self.intern_code_extent(CodeExtentData::Misc(n), parent)\n-    }\n-    pub fn code_extent_data(&self, e: CodeExtent) -> CodeExtentData {\n-        self.code_extents[e.0 as usize]\n-    }\n-    pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(&CodeExtent, &CodeExtent) {\n-        for child_id in 1..self.code_extents.len() {\n-            let child = CodeExtent(child_id as u32);\n-            if let Some(parent) = self.opt_encl_scope(child) {\n-                e(&child, &parent)\n-            }\n+impl<'tcx> RegionMaps<'tcx> {\n+    pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(CodeExtent<'tcx>, CodeExtent<'tcx>) {\n+        for (&child, &parent) in &self.scope_map {\n+            e(child, parent)\n         }\n     }\n-    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, &CodeExtent) {\n+    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, CodeExtent<'tcx>) {\n         for (child, parent) in self.var_map.iter() {\n             e(child, parent)\n         }\n@@ -419,45 +337,48 @@ impl RegionMaps {\n         }\n     }\n \n-    fn record_var_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_var_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent<'tcx>) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id(self));\n+        assert!(var != lifetime.node_id());\n         self.var_map.insert(var, lifetime);\n     }\n \n-    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent<'tcx>) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id(self));\n+        assert!(var != lifetime.node_id());\n         self.rvalue_scopes.insert(var, lifetime);\n     }\n \n-    fn record_shrunk_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_shrunk_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent<'tcx>) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id(self));\n+        assert!(var != lifetime.node_id());\n         self.shrunk_rvalue_scopes.insert(var, lifetime);\n     }\n \n-    pub fn opt_encl_scope(&self, id: CodeExtent) -> Option<CodeExtent> {\n+    pub fn opt_encl_scope(&self, id: CodeExtent<'tcx>) -> Option<CodeExtent<'tcx>> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        self.scope_map[id.0 as usize]\n+        self.scope_map.get(&id).cloned()\n     }\n \n     #[allow(dead_code)] // used in cfg\n-    pub fn encl_scope(&self, id: CodeExtent) -> CodeExtent {\n+    pub fn encl_scope(&self, id: CodeExtent<'tcx>) -> CodeExtent<'tcx> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n         self.opt_encl_scope(id).unwrap()\n     }\n \n     /// Returns the lifetime of the local variable `var_id`\n-    pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent {\n+    pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent<'tcx> {\n         match self.var_map.get(&var_id) {\n             Some(&r) => r,\n             None => { bug!(\"no enclosing scope for id {:?}\", var_id); }\n         }\n     }\n \n-    pub fn temporary_scope2(&self, expr_id: ast::NodeId) -> (Option<CodeExtent>, bool) {\n-        let temporary_scope = self.temporary_scope(expr_id);\n+    pub fn temporary_scope2<'a, 'gcx: 'tcx>(&self,\n+                                            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                            expr_id: ast::NodeId)\n+                                            -> (Option<CodeExtent<'tcx>>, bool) {\n+        let temporary_scope = self.temporary_scope(tcx, expr_id);\n         let was_shrunk = match self.shrunk_rvalue_scopes.get(&expr_id) {\n             Some(&s) => {\n                 info!(\"temporary_scope2({:?}, scope={:?}, shrunk={:?})\",\n@@ -470,17 +391,23 @@ impl RegionMaps {\n         (temporary_scope, was_shrunk)\n     }\n \n-    pub fn old_and_new_temporary_scope(&self, expr_id: ast::NodeId) ->\n-        (Option<CodeExtent>, Option<CodeExtent>)\n+    pub fn old_and_new_temporary_scope<'a, 'gcx: 'tcx>(&self,\n+                                                       tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                       expr_id: ast::NodeId)\n+                                                       -> (Option<CodeExtent<'tcx>>,\n+                                                           Option<CodeExtent<'tcx>>)\n     {\n-        let temporary_scope = self.temporary_scope(expr_id);\n+        let temporary_scope = self.temporary_scope(tcx, expr_id);\n         (temporary_scope,\n          self.shrunk_rvalue_scopes\n              .get(&expr_id).cloned()\n              .or(temporary_scope))\n     }\n \n-    pub fn temporary_scope(&self, expr_id: ast::NodeId) -> Option<CodeExtent> {\n+    pub fn temporary_scope<'a, 'gcx: 'tcx>(&self,\n+                                           tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                           expr_id: ast::NodeId)\n+                                           -> Option<CodeExtent<'tcx>> {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n@@ -489,17 +416,14 @@ impl RegionMaps {\n             return Some(s);\n         }\n \n-        let scope_map : &[Option<CodeExtent>] = &self.scope_map;\n-        let code_extents: &[CodeExtentData] = &self.code_extents;\n-\n         // else, locate the innermost terminating scope\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n-        let mut id = self.node_extent(expr_id);\n+        let mut id = tcx.node_extent(expr_id);\n \n-        while let Some(p) = scope_map[id.0 as usize] {\n-            match code_extents[p.0 as usize] {\n+        while let Some(&p) = self.scope_map.get(id) {\n+            match *p {\n                 CodeExtentData::DestructionScope(..) => {\n                     debug!(\"temporary_scope({:?}) = {:?} [enclosing]\",\n                            expr_id, id);\n@@ -513,7 +437,7 @@ impl RegionMaps {\n         return None;\n     }\n \n-    pub fn var_region(&self, id: ast::NodeId) -> ty::Region {\n+    pub fn var_region(&self, id: ast::NodeId) -> ty::RegionKind<'tcx> {\n         //! Returns the lifetime of the variable `id`.\n \n         let scope = ty::ReScope(self.var_scope(id));\n@@ -555,20 +479,20 @@ impl RegionMaps {\n     /// Finds the nearest common ancestor (if any) of two scopes.  That is, finds the smallest\n     /// scope which is greater than or equal to both `scope_a` and `scope_b`.\n     pub fn nearest_common_ancestor(&self,\n-                                   scope_a: CodeExtent,\n-                                   scope_b: CodeExtent)\n-                                   -> CodeExtent {\n+                                   scope_a: CodeExtent<'tcx>,\n+                                   scope_b: CodeExtent<'tcx>)\n+                                   -> CodeExtent<'tcx> {\n         if scope_a == scope_b { return scope_a; }\n \n         /// [1] The initial values for `a_buf` and `b_buf` are not used.\n         /// The `ancestors_of` function will return some prefix that\n         /// is re-initialized with new values (or else fallback to a\n         /// heap-allocated vector).\n         let mut a_buf: [CodeExtent; 32] = [scope_a /* [1] */; 32];\n-        let mut a_vec: Vec<CodeExtent> = vec![];\n+        let mut a_vec: Vec<CodeExtent<'tcx>> = vec![];\n         let mut b_buf: [CodeExtent; 32] = [scope_b /* [1] */; 32];\n-        let mut b_vec: Vec<CodeExtent> = vec![];\n-        let scope_map : &[Option<CodeExtent>] = &self.scope_map;\n+        let mut b_vec: Vec<CodeExtent<'tcx>> = vec![];\n+        let scope_map = &self.scope_map;\n         let a_ancestors = ancestors_of(scope_map, scope_a, &mut a_buf, &mut a_vec);\n         let b_ancestors = ancestors_of(scope_map, scope_b, &mut b_buf, &mut b_vec);\n         let mut a_index = a_ancestors.len() - 1;\n@@ -588,11 +512,11 @@ impl RegionMaps {\n             // nesting. The reasoning behind this is subtle.  See the\n             // \"Modeling closures\" section of the README in\n             // infer::region_inference for more details.\n-            let a_root_scope = self.code_extent_data(a_ancestors[a_index]);\n-            let b_root_scope = self.code_extent_data(a_ancestors[a_index]);\n+            let a_root_scope = a_ancestors[a_index];\n+            let b_root_scope = a_ancestors[a_index];\n             return match (a_root_scope, b_root_scope) {\n-                (CodeExtentData::DestructionScope(a_root_id),\n-                 CodeExtentData::DestructionScope(b_root_id)) => {\n+                (&CodeExtentData::DestructionScope(a_root_id),\n+                 &CodeExtentData::DestructionScope(b_root_id)) => {\n                     if self.fn_is_enclosed_by(a_root_id, b_root_id) {\n                         // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n                         scope_b\n@@ -623,18 +547,18 @@ impl RegionMaps {\n             }\n         }\n \n-        fn ancestors_of<'a>(scope_map: &[Option<CodeExtent>],\n-                            scope: CodeExtent,\n-                            buf: &'a mut [CodeExtent; 32],\n-                            vec: &'a mut Vec<CodeExtent>)\n-                            -> &'a [CodeExtent] {\n+        fn ancestors_of<'a, 'tcx>(scope_map: &FxHashMap<CodeExtent<'tcx>, CodeExtent<'tcx>>,\n+                                  scope: CodeExtent<'tcx>,\n+                                  buf: &'a mut [CodeExtent<'tcx>; 32],\n+                                  vec: &'a mut Vec<CodeExtent<'tcx>>)\n+                                  -> &'a [CodeExtent<'tcx>] {\n             // debug!(\"ancestors_of(scope={:?})\", scope);\n             let mut scope = scope;\n \n             let mut i = 0;\n             while i < 32 {\n                 buf[i] = scope;\n-                match scope_map[scope.0 as usize] {\n+                match scope_map.get(&scope) {\n                     Some(superscope) => scope = superscope,\n                     _ => return &buf[..i+1]\n                 }\n@@ -645,7 +569,7 @@ impl RegionMaps {\n             vec.extend_from_slice(buf);\n             loop {\n                 vec.push(scope);\n-                match scope_map[scope.0 as usize] {\n+                match scope_map.get(&scope) {\n                     Some(superscope) => scope = superscope,\n                     _ => return &*vec\n                 }\n@@ -669,7 +593,7 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n     }\n }\n \n-fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, blk: &'tcx hir::Block) {\n+fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk: &'tcx hir::Block) {\n     debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n     let prev_cx = visitor.cx;\n@@ -740,7 +664,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, blk:\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, arm: &'tcx hir::Arm) {\n+fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &'tcx hir::Arm) {\n     visitor.terminating_scopes.insert(arm.body.id);\n \n     if let Some(ref expr) = arm.guard {\n@@ -750,7 +674,7 @@ fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, arm: &\n     intravisit::walk_arm(visitor, arm);\n }\n \n-fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, pat: &'tcx hir::Pat) {\n+fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &'tcx hir::Pat) {\n     visitor.new_node_extent(pat.id);\n \n     // If this is a binding then record the lifetime of that binding.\n@@ -761,7 +685,7 @@ fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, pat: &\n     intravisit::walk_pat(visitor, pat);\n }\n \n-fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, stmt: &'tcx hir::Stmt) {\n+fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n     let stmt_id = stmt.node.id();\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n@@ -779,7 +703,7 @@ fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, stmt:\n     visitor.cx.parent = prev_parent;\n }\n \n-fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, expr: &'tcx hir::Expr) {\n+fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr: &'tcx hir::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n     let expr_extent = visitor.new_node_extent_with_dtor(expr.id);\n@@ -857,7 +781,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, expr:\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n+fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                            local: &'tcx hir::Local) {\n     debug!(\"resolve_local(local.id={:?},local.init={:?})\",\n            local.id,local.init.is_some());\n@@ -998,9 +922,11 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     ///        | box E&\n     ///        | E& as ...\n     ///        | ( E& )\n-    fn record_rvalue_scope_if_borrow_expr(visitor: &mut RegionResolutionVisitor,\n-                                          expr: &hir::Expr,\n-                                          blk_id: CodeExtent) {\n+    fn record_rvalue_scope_if_borrow_expr<'a, 'tcx>(\n+        visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n+        expr: &hir::Expr,\n+        blk_id: CodeExtent<'tcx>)\n+    {\n         match expr.node {\n             hir::ExprAddrOf(_, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n@@ -1047,10 +973,10 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     ///        | <rvalue>\n     ///\n     /// Note: ET is intended to match \"rvalues or lvalues based on rvalues\".\n-    fn record_rvalue_scope<'a>(visitor: &mut RegionResolutionVisitor,\n-                               expr: &'a hir::Expr,\n-                               blk_scope: CodeExtent,\n-                               is_shrunk: bool) {\n+    fn record_rvalue_scope<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n+                                     expr: &hir::Expr,\n+                                     blk_scope: CodeExtent<'tcx>,\n+                                     is_shrunk: bool) {\n         let mut expr = expr;\n         loop {\n             // Note: give all the expressions matching `ET` with the\n@@ -1081,10 +1007,8 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     }\n }\n \n-fn resolve_item_like<'a, 'tcx, F>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n-                                  id: ast::NodeId,\n-                                  walk: F)\n-    where F: FnOnce(&mut RegionResolutionVisitor<'tcx, 'a>)\n+fn resolve_item_like<'a, 'tcx, F>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, walk: F)\n+    where F: FnOnce(&mut RegionResolutionVisitor<'a, 'tcx>)\n {\n     // Items create a new outer block scope as far as we're concerned.\n     let prev_cx = visitor.cx;\n@@ -1095,12 +1019,11 @@ fn resolve_item_like<'a, 'tcx, F>(visitor: &mut RegionResolutionVisitor<'tcx, 'a\n         parent: None,\n     };\n     walk(visitor);\n-    visitor.create_item_scope_if_needed(id);\n     visitor.cx = prev_cx;\n     visitor.terminating_scopes = prev_ts;\n }\n \n-fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n+fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                         kind: FnKind<'tcx>,\n                         decl: &'tcx hir::FnDecl,\n                         body_id: hir::BodyId,\n@@ -1111,7 +1034,7 @@ fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n                                body.id={:?}, \\\n                                cx.parent={:?})\",\n            id,\n-           visitor.sess.codemap().span_to_string(sp),\n+           visitor.tcx.sess.codemap().span_to_string(sp),\n            body_id,\n            visitor.cx.parent);\n \n@@ -1152,119 +1075,117 @@ fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     visitor.terminating_scopes = outer_ts;\n }\n \n-impl<'hir, 'a> RegionResolutionVisitor<'hir, 'a> {\n+impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n+    pub fn intern_code_extent(&mut self,\n+                              data: CodeExtentData,\n+                              parent: Option<CodeExtent<'tcx>>)\n+                              -> CodeExtent<'tcx> {\n+        let code_extent = self.tcx.intern_code_extent(data);\n+        debug!(\"{:?}.parent = {:?}\", code_extent, parent);\n+        if let Some(p) = parent {\n+            let prev = self.region_maps.scope_map.insert(code_extent, p);\n+            assert!(prev.is_none());\n+        }\n+        code_extent\n+    }\n+\n+    pub fn intern_node(&mut self,\n+                       n: ast::NodeId,\n+                       parent: Option<CodeExtent<'tcx>>) -> CodeExtent<'tcx> {\n+        self.intern_code_extent(CodeExtentData::Misc(n), parent)\n+    }\n+\n     /// Records the current parent (if any) as the parent of `child_scope`.\n-    fn new_code_extent(&mut self, child_scope: CodeExtentData) -> CodeExtent {\n-        self.region_maps.intern_code_extent(child_scope, self.cx.parent)\n+    fn new_code_extent(&mut self, child_scope: CodeExtentData) -> CodeExtent<'tcx> {\n+        let parent = self.cx.parent;\n+        self.intern_code_extent(child_scope, parent)\n     }\n \n-    fn new_node_extent(&mut self, child_scope: ast::NodeId) -> CodeExtent {\n+    fn new_node_extent(&mut self, child_scope: ast::NodeId) -> CodeExtent<'tcx> {\n         self.new_code_extent(CodeExtentData::Misc(child_scope))\n     }\n \n-    fn new_node_extent_with_dtor(&mut self, id: ast::NodeId) -> CodeExtent {\n+    fn new_node_extent_with_dtor(&mut self, id: ast::NodeId) -> CodeExtent<'tcx> {\n         // If node was previously marked as a terminating scope during the\n         // recursive visit of its parent node in the AST, then we need to\n         // account for the destruction scope representing the extent of\n         // the destructors that run immediately after it completes.\n         if self.terminating_scopes.contains(&id) {\n             let ds = self.new_code_extent(\n                 CodeExtentData::DestructionScope(id));\n-            self.region_maps.intern_node(id, Some(ds))\n+            self.intern_node(id, Some(ds))\n         } else {\n             self.new_node_extent(id)\n         }\n     }\n-\n-    fn create_item_scope_if_needed(&mut self, id: ast::NodeId) {\n-        // create a region for the destruction scope - this is needed\n-        // for constructing parameter environments based on the item.\n-        // functions put their destruction scopes *inside* their parameter\n-        // scopes.\n-        let scope = CodeExtentData::DestructionScope(id);\n-        if !self.region_maps.code_extent_interner.contains_key(&scope) {\n-            self.region_maps.intern_code_extent(scope, None);\n-        }\n-    }\n }\n \n-impl<'hir, 'a> Visitor<'hir> for RegionResolutionVisitor<'hir, 'a> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n+impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.map)\n     }\n \n-    fn visit_body(&mut self, b: &'hir Body) {\n-        // make sure that every body owner has an item scope, since\n-        // MIR construction wants that\n-        let owner = self.map.body_owner(b.id());\n-        self.create_item_scope_if_needed(owner);\n-\n-        intravisit::walk_body(self, b);\n-    }\n-\n-    fn visit_block(&mut self, b: &'hir Block) {\n+    fn visit_block(&mut self, b: &'tcx Block) {\n         resolve_block(self, b);\n     }\n \n-    fn visit_item(&mut self, i: &'hir Item) {\n-        resolve_item_like(self, i.id, |this| intravisit::walk_item(this, i));\n+    fn visit_item(&mut self, i: &'tcx Item) {\n+        resolve_item_like(self, |this| intravisit::walk_item(this, i));\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'hir hir::ImplItem) {\n-        resolve_item_like(self, ii.id, |this| intravisit::walk_impl_item(this, ii));\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n+        resolve_item_like(self, |this| intravisit::walk_impl_item(this, ii));\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'hir hir::TraitItem) {\n-        resolve_item_like(self, ti.id, |this| intravisit::walk_trait_item(this, ti));\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n+        resolve_item_like(self, |this| intravisit::walk_trait_item(this, ti));\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'hir>, fd: &'hir FnDecl,\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx FnDecl,\n                 b: hir::BodyId, s: Span, n: NodeId) {\n         resolve_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_arm(&mut self, a: &'hir Arm) {\n+    fn visit_arm(&mut self, a: &'tcx Arm) {\n         resolve_arm(self, a);\n     }\n-    fn visit_pat(&mut self, p: &'hir Pat) {\n+    fn visit_pat(&mut self, p: &'tcx Pat) {\n         resolve_pat(self, p);\n     }\n-    fn visit_stmt(&mut self, s: &'hir Stmt) {\n+    fn visit_stmt(&mut self, s: &'tcx Stmt) {\n         resolve_stmt(self, s);\n     }\n-    fn visit_expr(&mut self, ex: &'hir Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n         resolve_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l: &'hir Local) {\n+    fn visit_local(&mut self, l: &'tcx Local) {\n         resolve_local(self, l);\n     }\n }\n \n-pub fn resolve_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Rc<RegionMaps> {\n+pub fn resolve_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Rc<RegionMaps<'tcx>> {\n     tcx.region_resolve_crate(LOCAL_CRATE)\n }\n \n fn region_resolve_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n-    -> Rc<RegionMaps>\n+    -> Rc<RegionMaps<'tcx>>\n {\n     debug_assert!(crate_num == LOCAL_CRATE);\n \n-    let sess = &tcx.sess;\n     let hir_map = &tcx.hir;\n \n     let krate = hir_map.krate();\n \n     let mut maps = RegionMaps {\n-        code_extents: vec![],\n-        code_extent_interner: FxHashMap(),\n-        scope_map: vec![],\n+        scope_map: FxHashMap(),\n         var_map: NodeMap(),\n         rvalue_scopes: NodeMap(),\n         shrunk_rvalue_scopes: NodeMap(),\n         fn_tree: NodeMap(),\n     };\n+\n     {\n         let mut visitor = RegionResolutionVisitor {\n-            sess: sess,\n+            tcx: tcx,\n             region_maps: &mut maps,\n             map: hir_map,\n             cx: Context {"}, {"sha": "8f8af8b10366e4748c9cb0018bd14b5877e0939a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -1034,7 +1034,7 @@ pub enum Rvalue<'tcx> {\n     Repeat(Operand<'tcx>, ConstUsize),\n \n     /// &x or &mut x\n-    Ref(&'tcx Region, BorrowKind, Lvalue<'tcx>),\n+    Ref(Region<'tcx>, BorrowKind, Lvalue<'tcx>),\n \n     /// length of a [X] or [X;n] value\n     Len(Lvalue<'tcx>),"}, {"sha": "31bdd99ef32210abb0e85e91221396ab14d2e355", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -747,7 +747,7 @@ pub enum LvalueContext<'tcx> {\n     Inspect,\n \n     // Being borrowed\n-    Borrow { region: &'tcx Region, kind: BorrowKind },\n+    Borrow { region: Region<'tcx>, kind: BorrowKind },\n \n     // Used as base for another lvalue, e.g. `x` in `x.y`.\n     //"}, {"sha": "e8baaa7ffb26d01a59f705e28d7bc2ece9df2707", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -84,7 +84,7 @@ pub struct FulfillmentContext<'tcx> {\n \n #[derive(Clone)]\n pub struct RegionObligation<'tcx> {\n-    pub sub_region: &'tcx ty::Region,\n+    pub sub_region: ty::Region<'tcx>,\n     pub sup_type: Ty<'tcx>,\n     pub cause: ObligationCause<'tcx>,\n }\n@@ -155,7 +155,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n     pub fn register_region_obligation(&mut self,\n                                       t_a: Ty<'tcx>,\n-                                      r_b: &'tcx ty::Region,\n+                                      r_b: ty::Region<'tcx>,\n                                       cause: ObligationCause<'tcx>)\n     {\n         register_region_obligation(t_a, r_b, cause, &mut self.region_obligations);\n@@ -566,7 +566,7 @@ fn coinductive_obligation<'a,'gcx,'tcx>(selcx: &SelectionContext<'a,'gcx,'tcx>,\n }\n \n fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n-                                    r_b: &'tcx ty::Region,\n+                                    r_b: ty::Region<'tcx>,\n                                     cause: ObligationCause<'tcx>,\n                                     region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n {"}, {"sha": "5ac79a8e72a50e09ee62041ef98a8e129bf9485f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -112,7 +112,7 @@ pub enum ObligationCauseCode<'tcx> {\n     ReferenceOutlivesReferent(Ty<'tcx>),\n \n     /// A type like `Box<Foo<'a> + 'b>` is WF only if `'b: 'a`.\n-    ObjectTypeBound(Ty<'tcx>, &'tcx ty::Region),\n+    ObjectTypeBound(Ty<'tcx>, ty::Region<'tcx>),\n \n     /// Obligation incurred due to an object cast.\n     ObjectCastObligation(/* Object type */ Ty<'tcx>),"}, {"sha": "f86c1cf0dd6aba156797dbee12c82d45786ac2a1", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -52,8 +52,8 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n         self.relate(a, b)\n     }\n \n-    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n-               -> RelateResult<'tcx, &'tcx ty::Region> {\n+    fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "385591e10f744c9052d3cfa8b37a178cd6c3a7b7", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -133,7 +133,7 @@ impl<'tcx> Adjustment<'tcx> {\n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum AutoBorrow<'tcx> {\n     /// Convert from T to &T.\n-    Ref(&'tcx ty::Region, hir::Mutability),\n+    Ref(ty::Region<'tcx>, hir::Mutability),\n \n     /// Convert from T to *T.\n     RawPtr(hir::Mutability),"}, {"sha": "3c6f833c4ef45f78cf38b40a985d6d49acb0e4a2", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 66, "deletions": 21, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -21,7 +21,7 @@ use hir::map as hir_map;\n use hir::map::DisambiguatedDefPathData;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n-use middle::region::RegionMaps;\n+use middle::region::{CodeExtent, CodeExtentData, RegionMaps};\n use middle::resolve_lifetime;\n use middle::stability;\n use mir::Mir;\n@@ -33,6 +33,7 @@ use ty::{TyS, TypeVariants, Slice};\n use ty::{AdtKind, AdtDef, ClosureSubsts, Region};\n use hir::FreevarMap;\n use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n+use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n@@ -94,7 +95,7 @@ pub struct CtxtInterners<'tcx> {\n     type_: RefCell<FxHashSet<Interned<'tcx, TyS<'tcx>>>>,\n     type_list: RefCell<FxHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n     substs: RefCell<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n-    region: RefCell<FxHashSet<Interned<'tcx, Region>>>,\n+    region: RefCell<FxHashSet<Interned<'tcx, RegionKind<'tcx>>>>,\n     existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n }\n \n@@ -192,9 +193,9 @@ pub struct CommonTypes<'tcx> {\n     pub never: Ty<'tcx>,\n     pub err: Ty<'tcx>,\n \n-    pub re_empty: &'tcx Region,\n-    pub re_static: &'tcx Region,\n-    pub re_erased: &'tcx Region,\n+    pub re_empty: Region<'tcx>,\n+    pub re_static: Region<'tcx>,\n+    pub re_erased: Region<'tcx>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -257,7 +258,7 @@ pub struct TypeckTables<'tcx> {\n     /// Stores the free-region relationships that were deduced from\n     /// its where clauses and parameter types. These are then\n     /// read-again by borrowck.\n-    pub free_region_map: FreeRegionMap,\n+    pub free_region_map: FreeRegionMap<'tcx>,\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n@@ -393,9 +394,9 @@ impl<'tcx> CommonTypes<'tcx> {\n             f32: mk(TyFloat(ast::FloatTy::F32)),\n             f64: mk(TyFloat(ast::FloatTy::F64)),\n \n-            re_empty: mk_region(Region::ReEmpty),\n-            re_static: mk_region(Region::ReStatic),\n-            re_erased: mk_region(Region::ReErased),\n+            re_empty: mk_region(RegionKind::ReEmpty),\n+            re_static: mk_region(RegionKind::ReStatic),\n+            re_erased: mk_region(RegionKind::ReErased),\n         }\n     }\n }\n@@ -549,6 +550,8 @@ pub struct GlobalCtxt<'tcx> {\n \n     layout_interner: RefCell<FxHashSet<&'tcx Layout>>,\n \n+    code_extent_interner: RefCell<FxHashSet<CodeExtent<'tcx>>>,\n+\n     /// A vector of every trait accessible in the whole crate\n     /// (i.e. including those from subcrates). This is used only for\n     /// error reporting, and so is lazily initialised and generally\n@@ -649,6 +652,38 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         interned\n     }\n \n+    pub fn node_extent(self, n: ast::NodeId) -> CodeExtent<'gcx> {\n+        self.intern_code_extent(CodeExtentData::Misc(n))\n+    }\n+\n+    // TODO this is revealing side-effects of query, bad\n+    pub fn opt_destruction_extent(self, n: ast::NodeId) -> Option<CodeExtent<'gcx>> {\n+        let s = CodeExtentData::DestructionScope(n);\n+        self.code_extent_interner.borrow().get(&s).cloned()\n+    }\n+\n+    // Returns the code extent for an item - the destruction scope.\n+    pub fn item_extent(self, n: ast::NodeId) -> CodeExtent<'gcx> {\n+        self.intern_code_extent(CodeExtentData::DestructionScope(n))\n+    }\n+\n+    pub fn call_site_extent(self, fn_id: ast::NodeId, body_id: ast::NodeId) -> CodeExtent<'gcx> {\n+        assert!(fn_id != body_id);\n+        self.intern_code_extent(CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id })\n+    }\n+\n+    pub fn intern_code_extent(self, data: CodeExtentData) -> CodeExtent<'gcx> {\n+        if let Some(st) = self.code_extent_interner.borrow().get(&data) {\n+            return st;\n+        }\n+\n+        let interned = self.global_interners.arena.alloc(data);\n+        if let Some(prev) = self.code_extent_interner.borrow_mut().replace(interned) {\n+            bug!(\"Tried to overwrite interned code-extent: {:?}\", prev)\n+        }\n+        interned\n+    }\n+\n     pub fn intern_layout(self, layout: Layout) -> &'gcx Layout {\n         if let Some(layout) = self.layout_interner.borrow().get(&layout) {\n             return layout;\n@@ -677,7 +712,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         local as usize == global as usize\n     }\n \n-    pub fn region_maps(self) -> Rc<RegionMaps> {\n+    pub fn region_maps(self) -> Rc<RegionMaps<'tcx>> {\n         self.region_resolve_crate(LOCAL_CRATE)\n     }\n \n@@ -741,6 +776,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FxHashMap()),\n             layout_interner: RefCell::new(FxHashSet()),\n+            code_extent_interner: RefCell::new(FxHashSet()),\n             layout_depth: Cell::new(0),\n             derive_macros: RefCell::new(NodeMap()),\n             stability_interner: RefCell::new(FxHashSet()),\n@@ -820,9 +856,18 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Region {\n-    type Lifted = &'tcx Region;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Region> {\n+impl<'a, 'tcx> Lift<'tcx> for ty::FreeRegion<'a> {\n+    type Lifted = ty::FreeRegion<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        let scope = self.scope.map(|code_extent| tcx.intern_code_extent(*code_extent));\n+        let bound_region = self.bound_region;\n+        Some(ty::FreeRegion { scope, bound_region })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n+    type Lifted = Region<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Region<'tcx>> {\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n         }\n@@ -1083,9 +1128,9 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, Substs<'tcx>> {\n     }\n }\n \n-impl<'tcx> Borrow<Region> for Interned<'tcx, Region> {\n-    fn borrow<'a>(&'a self) -> &'a Region {\n-        self.0\n+impl<'tcx> Borrow<RegionKind<'tcx>> for Interned<'tcx, RegionKind<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a RegionKind<'tcx> {\n+        &self.0\n     }\n }\n \n@@ -1176,7 +1221,7 @@ direct_interners!('tcx,\n             &ty::ReVar(_) | &ty::ReSkolemized(..) => true,\n             _ => false\n         }\n-    }) -> Region\n+    }) -> RegionKind<'tcx>\n );\n \n macro_rules! slice_interners {\n@@ -1268,15 +1313,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyRawPtr(tm))\n     }\n \n-    pub fn mk_ref(self, r: &'tcx Region, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_ref(self, r: Region<'tcx>, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyRef(r, tm))\n     }\n \n-    pub fn mk_mut_ref(self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_mut_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n     }\n \n-    pub fn mk_imm_ref(self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_imm_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n     }\n \n@@ -1338,7 +1383,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn mk_dynamic(\n         self,\n         obj: ty::Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>,\n-        reg: &'tcx ty::Region\n+        reg: ty::Region<'tcx>\n     ) -> Ty<'tcx> {\n         self.mk_ty(TyDynamic(obj, reg))\n     }"}, {"sha": "cec52b10736e43e8bf7d28128cb5ed399c62bf87", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -36,11 +36,11 @@ pub enum TypeError<'tcx> {\n     TupleSize(ExpectedFound<usize>),\n     FixedArraySize(ExpectedFound<usize>),\n     ArgCount,\n-    RegionsDoesNotOutlive(&'tcx Region, &'tcx Region),\n-    RegionsNotSame(&'tcx Region, &'tcx Region),\n-    RegionsNoOverlap(&'tcx Region, &'tcx Region),\n-    RegionsInsufficientlyPolymorphic(BoundRegion, &'tcx Region, Option<Box<ty::Issue32330>>),\n-    RegionsOverlyPolymorphic(BoundRegion, &'tcx Region, Option<Box<ty::Issue32330>>),\n+    RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n+    RegionsNotSame(Region<'tcx>, Region<'tcx>),\n+    RegionsNoOverlap(Region<'tcx>, Region<'tcx>),\n+    RegionsInsufficientlyPolymorphic(BoundRegion, Region<'tcx>, Option<Box<ty::Issue32330>>),\n+    RegionsOverlyPolymorphic(BoundRegion, Region<'tcx>, Option<Box<ty::Issue32330>>),\n     Sorts(ExpectedFound<Ty<'tcx>>),\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n     FloatMismatch(ExpectedFound<ast::FloatTy>),"}, {"sha": "686b99ba680942eb734f8c1578b7ca648d849eac", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -186,7 +186,7 @@ impl FlagComputation {\n         self.add_bound_computation(&computation);\n     }\n \n-    fn add_region(&mut self, r: &ty::Region) {\n+    fn add_region(&mut self, r: ty::Region) {\n         self.add_flags(r.type_flags());\n         if let ty::ReLateBound(debruijn, _) = *r {\n             self.add_depth(debruijn.depth);"}, {"sha": "21ccf6f987b8952307460ee07a4db31d310e9785", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -159,7 +159,7 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         sig.super_fold_with(self)\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         r.super_fold_with(self)\n     }\n \n@@ -182,7 +182,7 @@ pub trait TypeVisitor<'tcx> : Sized {\n         trait_ref.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         r.super_visit_with(self)\n     }\n }\n@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// whether any late-bound regions were skipped\n     pub fn collect_regions<T>(self,\n         value: &T,\n-        region_set: &mut FxHashSet<&'tcx ty::Region>)\n+        region_set: &mut FxHashSet<ty::Region<'tcx>>)\n         -> bool\n         where T : TypeFoldable<'tcx>\n     {\n@@ -236,7 +236,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         skipped_regions: &mut bool,\n         mut f: F)\n         -> T\n-        where F : FnMut(&'tcx ty::Region, u32) -> &'tcx ty::Region,\n+        where F : FnMut(ty::Region<'tcx>, u32) -> ty::Region<'tcx>,\n               T : TypeFoldable<'tcx>,\n     {\n         value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f))\n@@ -256,14 +256,14 @@ pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     skipped_regions: &'a mut bool,\n     current_depth: u32,\n-    fld_r: &'a mut (FnMut(&'tcx ty::Region, u32) -> &'tcx ty::Region + 'a),\n+    fld_r: &'a mut (FnMut(ty::Region<'tcx>, u32) -> ty::Region<'tcx> + 'a),\n }\n \n impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n     pub fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                   skipped_regions: &'a mut bool,\n                   fld_r: &'a mut F) -> RegionFolder<'a, 'gcx, 'tcx>\n-        where F : FnMut(&'tcx ty::Region, u32) -> &'tcx ty::Region\n+        where F : FnMut(ty::Region<'tcx>, u32) -> ty::Region<'tcx>\n     {\n         RegionFolder {\n             tcx: tcx,\n@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, _) if debruijn.depth < self.current_depth => {\n                 debug!(\"RegionFolder.fold_region({:?}) skipped bound region (current depth={})\",\n@@ -309,16 +309,16 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     current_depth: u32,\n-    fld_r: &'a mut (FnMut(ty::BoundRegion) -> &'tcx ty::Region + 'a),\n-    map: FxHashMap<ty::BoundRegion, &'tcx ty::Region>\n+    fld_r: &'a mut (FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n+    map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n-        -> (T, FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n-        where F : FnMut(ty::BoundRegion) -> &'tcx ty::Region,\n+        -> (T, FxHashMap<ty::BoundRegion, ty::Region<'tcx>>)\n+        where F : FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               T : TypeFoldable<'tcx>,\n     {\n         let mut replacer = RegionReplacer::new(self, &mut f);\n@@ -330,7 +330,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Replace any late-bound regions bound in `value` with free variants attached to scope-id\n     /// `scope_id`.\n     pub fn liberate_late_bound_regions<T>(self,\n-        all_outlive_scope: Option<region::CodeExtent>,\n+        all_outlive_scope: Option<region::CodeExtent<'tcx>>,\n         value: &Binder<T>)\n         -> T\n         where T : TypeFoldable<'tcx>\n@@ -435,7 +435,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n     fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>, fld_r: &'a mut F)\n               -> RegionReplacer<'a, 'gcx, 'tcx>\n-        where F : FnMut(ty::BoundRegion) -> &'tcx ty::Region\n+        where F : FnMut(ty::BoundRegion) -> ty::Region<'tcx>\n     {\n         RegionReplacer {\n             tcx: tcx,\n@@ -464,7 +464,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n         t.super_fold_with(self)\n     }\n \n-    fn fold_region(&mut self, r:&'tcx  ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n                 let fld_r = &mut self.fld_r;\n@@ -527,7 +527,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 u.super_fold_with(self)\n             }\n \n-            fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+            fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n                 // because late-bound regions affect subtyping, we can't\n                 // erase the bound/free distinction, but we can replace\n                 // all free regions with 'erased.\n@@ -554,7 +554,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n // regions. See comment on `shift_regions_through_binders` method in\n // `subst.rs` for more details.\n \n-pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n+pub fn shift_region<'tcx>(region: ty::RegionKind<'tcx>, amount: u32) -> ty::RegionKind<'tcx> {\n     match region {\n         ty::ReLateBound(debruijn, br) => {\n             ty::ReLateBound(debruijn.shifted(amount), br)\n@@ -567,9 +567,9 @@ pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n \n pub fn shift_region_ref<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    region: &'tcx ty::Region,\n+    region: ty::Region<'tcx>,\n     amount: u32)\n-    -> &'tcx ty::Region\n+    -> ty::Region<'tcx>\n {\n     match region {\n         &ty::ReLateBound(debruijn, br) if amount > 0 => {\n@@ -582,7 +582,8 @@ pub fn shift_region_ref<'a, 'gcx, 'tcx>(\n }\n \n pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                        amount: u32, value: &T) -> T\n+                                        amount: u32,\n+                                        value: &T) -> T\n     where T: TypeFoldable<'tcx>\n {\n     debug!(\"shift_regions(value={:?}, amount={})\",\n@@ -631,7 +632,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingRegionsVisitor {\n         t.region_depth > self.depth\n     }\n \n-    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         r.escapes_depth(self.depth)\n     }\n }\n@@ -647,7 +648,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         flags.intersects(self.flags)\n     }\n \n-    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         let flags = r.type_flags();\n         debug!(\"HasTypeFlagsVisitor: r={:?} r.flags={:?} self.flags={:?}\", r, flags, self.flags);\n         flags.intersects(self.flags)\n@@ -693,7 +694,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         match *r {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n                 self.regions.insert(br);"}, {"sha": "4a780b9178ecc0a718f77a93362c5a772abcd478", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -578,7 +578,7 @@ define_maps! { <'tcx>\n \n     [] reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n-    [] region_resolve_crate: region_resolve_crate_dep_node(CrateNum) -> Rc<RegionMaps>,\n+    [] region_resolve_crate: region_resolve_crate_dep_node(CrateNum) -> Rc<RegionMaps<'tcx>>,\n \n     [] mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>,\n "}, {"sha": "e6a8459e001791a6fae28cfc8eca48f5bbc6cf73", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -67,11 +67,12 @@ pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n+pub use self::sty::RegionKind;\n pub use self::sty::Issue32330;\n pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n-pub use self::sty::Region::*;\n+pub use self::sty::RegionKind::*;\n pub use self::sty::TypeVariants::*;\n \n pub use self::context::{TyCtxt, GlobalArenas, tls};\n@@ -601,7 +602,7 @@ pub struct UpvarBorrow<'tcx> {\n     pub kind: BorrowKind,\n \n     /// Region of the resulting reference.\n-    pub region: &'tcx ty::Region,\n+    pub region: ty::Region<'tcx>,\n }\n \n pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n@@ -934,9 +935,9 @@ pub type PolyEquatePredicate<'tcx> = ty::Binder<EquatePredicate<'tcx>>;\n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n-pub type PolyRegionOutlivesPredicate<'tcx> = PolyOutlivesPredicate<&'tcx ty::Region,\n-                                                                   &'tcx ty::Region>;\n-pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, &'tcx ty::Region>;\n+pub type PolyRegionOutlivesPredicate<'tcx> = PolyOutlivesPredicate<ty::Region<'tcx>,\n+                                                                   ty::Region<'tcx>>;\n+pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct SubtypePredicate<'tcx> {\n@@ -1167,7 +1168,7 @@ pub struct ParameterEnvironment<'tcx> {\n     /// region of the callee. If it is `None`, then the parameter\n     /// environment is for an item or something where the \"callee\" is\n     /// not clear.\n-    pub implicit_region_bound: Option<&'tcx ty::Region>,\n+    pub implicit_region_bound: Option<ty::Region<'tcx>>,\n \n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n@@ -1181,7 +1182,7 @@ pub struct ParameterEnvironment<'tcx> {\n     /// FIXME(#3696). It would be nice to refactor so that free\n     /// regions don't have this implicit scope and instead introduce\n     /// relationships in the environment.\n-    pub free_id_outlive: Option<CodeExtent>,\n+    pub free_id_outlive: Option<CodeExtent<'tcx>>,\n \n     /// A cache for `moves_by_default`.\n     pub is_copy_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n@@ -1222,13 +1223,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         let impl_def_id = tcx.hir.local_def_id(impl_id);\n                         tcx.construct_parameter_environment(impl_item.span,\n                                                             impl_def_id,\n-                                                            Some(tcx.region_maps().item_extent(id)))\n+                                                            Some(tcx.item_extent(id)))\n                     }\n                     hir::ImplItemKind::Method(_, ref body) => {\n                         tcx.construct_parameter_environment(\n                             impl_item.span,\n                             tcx.hir.local_def_id(id),\n-                            Some(tcx.region_maps().call_site_extent(id, body.node_id)))\n+                            Some(tcx.call_site_extent(id, body.node_id)))\n                     }\n                 }\n             }\n@@ -1241,18 +1242,18 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         let trait_def_id = tcx.hir.local_def_id(trait_id);\n                         tcx.construct_parameter_environment(trait_item.span,\n                                                             trait_def_id,\n-                                                            Some(tcx.region_maps().item_extent(id)))\n+                                                            Some(tcx.item_extent(id)))\n                     }\n                     hir::TraitItemKind::Method(_, ref body) => {\n                         // Use call-site for extent (unless this is a\n                         // trait method with no default; then fallback\n                         // to the method id).\n                         let extent = if let hir::TraitMethod::Provided(body_id) = *body {\n                             // default impl: use call_site extent as free_id_outlive bound.\n-                            tcx.region_maps().call_site_extent(id, body_id.node_id)\n+                            tcx.call_site_extent(id, body_id.node_id)\n                         } else {\n                             // no default impl: use item extent as free_id_outlive bound.\n-                            tcx.region_maps().item_extent(id)\n+                            tcx.item_extent(id)\n                         };\n                         tcx.construct_parameter_environment(\n                             trait_item.span,\n@@ -1270,7 +1271,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         tcx.construct_parameter_environment(\n                             item.span,\n                             fn_def_id,\n-                            Some(tcx.region_maps().call_site_extent(id, body_id.node_id)))\n+                            Some(tcx.call_site_extent(id, body_id.node_id)))\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n@@ -1282,13 +1283,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         let def_id = tcx.hir.local_def_id(id);\n                         tcx.construct_parameter_environment(item.span,\n                                                             def_id,\n-                                                            Some(tcx.region_maps().item_extent(id)))\n+                                                            Some(tcx.item_extent(id)))\n                     }\n                     hir::ItemTrait(..) => {\n                         let def_id = tcx.hir.local_def_id(id);\n                         tcx.construct_parameter_environment(item.span,\n                                                             def_id,\n-                                                            Some(tcx.region_maps().item_extent(id)))\n+                                                            Some(tcx.item_extent(id)))\n                     }\n                     _ => {\n                         span_bug!(item.span,\n@@ -1306,7 +1307,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     tcx.construct_parameter_environment(\n                         expr.span,\n                         base_def_id,\n-                        Some(tcx.region_maps().call_site_extent(id, body.node_id)))\n+                        Some(tcx.call_site_extent(id, body.node_id)))\n                 } else {\n                     tcx.empty_parameter_environment()\n                 }\n@@ -2454,8 +2455,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// In general, this means converting from bound parameters to\n     /// free parameters. Since we currently represent bound/free type\n     /// parameters in the same way, this only has an effect on regions.\n-    pub fn construct_free_substs(self, def_id: DefId,\n-                                 free_id_outlive: Option<CodeExtent>)\n+    pub fn construct_free_substs(self,\n+                                 def_id: DefId,\n+                                 free_id_outlive: Option<CodeExtent<'gcx>>)\n                                  -> &'gcx Substs<'gcx> {\n \n         let substs = Substs::for_item(self.global_tcx(), def_id, |def, _| {\n@@ -2479,7 +2481,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn construct_parameter_environment(self,\n                                            span: Span,\n                                            def_id: DefId,\n-                                           free_id_outlive: Option<CodeExtent>)\n+                                           free_id_outlive: Option<CodeExtent<'gcx>>)\n                                            -> ParameterEnvironment<'gcx>\n     {\n         //\n@@ -2521,14 +2523,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             is_freeze_cache: RefCell::new(FxHashMap()),\n         };\n \n-        let body_id = free_id_outlive.map(|f| f.node_id(&self.region_maps()))\n+        let body_id = free_id_outlive.map(|f| f.node_id())\n                                      .unwrap_or(DUMMY_NODE_ID);\n         let cause = traits::ObligationCause::misc(span, body_id);\n         traits::normalize_param_env_or_error(tcx, unnormalized_env, cause)\n     }\n \n-    pub fn node_scope_region(self, id: NodeId) -> &'tcx Region {\n-        self.mk_region(ty::ReScope(self.region_maps().node_extent(id)))\n+    pub fn node_scope_region(self, id: NodeId) -> Region<'tcx> {\n+        self.mk_region(ty::ReScope(self.node_extent(id)))\n     }\n \n     pub fn visit_all_item_likes_in_krate<V,F>(self,"}, {"sha": "a544b2dd3991bf1e95a6faa13ab24281f09024bb", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -16,7 +16,7 @@ use ty::{self, Ty, TyCtxt, TypeFoldable};\n \n #[derive(Debug)]\n pub enum Component<'tcx> {\n-    Region(&'tcx ty::Region),\n+    Region(ty::Region<'tcx>),\n     Param(ty::ParamTy),\n     UnresolvedInferenceVariable(ty::InferTy),\n \n@@ -202,7 +202,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<&'tcx ty::Region>) {\n+fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<ty::Region<'tcx>>) {\n     for r in regions {\n         if !r.is_bound() {\n             out.push(Component::Region(r));"}, {"sha": "ac434c01c6a88ee41f054786f7468a12eb8269af", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -67,8 +67,8 @@ pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>)\n            -> RelateResult<'tcx, Ty<'tcx>>;\n \n-    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n-               -> RelateResult<'tcx, &'tcx ty::Region>;\n+    fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>>;\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n@@ -529,11 +529,11 @@ impl<'tcx> Relate<'tcx> for &'tcx Substs<'tcx> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for &'tcx ty::Region {\n+impl<'tcx> Relate<'tcx> for ty::Region<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &&'tcx ty::Region,\n-                           b: &&'tcx ty::Region)\n-                           -> RelateResult<'tcx, &'tcx ty::Region>\n+                           a: &ty::Region<'tcx>,\n+                           b: &ty::Region<'tcx>)\n+                           -> RelateResult<'tcx, ty::Region<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.regions(*a, *b)"}, {"sha": "53d516e581b2a153b05b94e0fb6078c774fc2eb6", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -624,7 +624,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Region {\n+impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n         *self\n     }"}, {"sha": "1ec8fd572a4ceb14d4e7a8f482ca41239590c87a", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -47,8 +47,8 @@ pub struct TypeAndMut<'tcx> {\n /// If `fr.scope` is None, then this is in some context (e.g., an\n /// impl) where lifetimes are more abstract and the notion of the\n /// caller/callee stack frames are not applicable.\n-pub struct FreeRegion {\n-    pub scope: Option<region::CodeExtent>,\n+pub struct FreeRegion<'tcx> {\n+    pub scope: Option<region::CodeExtent<'tcx>>,\n     pub bound_region: BoundRegion,\n }\n \n@@ -128,7 +128,7 @@ pub enum TypeVariants<'tcx> {\n \n     /// A reference; a pointer with an associated lifetime. Written as\n     /// `&'a mut T` or `&'a T`.\n-    TyRef(&'tcx Region, TypeAndMut<'tcx>),\n+    TyRef(Region<'tcx>, TypeAndMut<'tcx>),\n \n     /// The anonymous type of a function declaration/definition. Each\n     /// function has a unique type.\n@@ -140,7 +140,7 @@ pub enum TypeVariants<'tcx> {\n     TyFnPtr(PolyFnSig<'tcx>),\n \n     /// A trait, defined with `trait`.\n-    TyDynamic(Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>, &'tcx ty::Region),\n+    TyDynamic(Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n@@ -679,6 +679,8 @@ pub struct DebruijnIndex {\n     pub depth: u32,\n }\n \n+pub type Region<'tcx> = &'tcx RegionKind<'tcx>;\n+\n /// Representation of regions.\n ///\n /// Unlike types, most region variants are \"fictitious\", not concrete,\n@@ -736,7 +738,7 @@ pub struct DebruijnIndex {\n /// [1] http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n /// [2] http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n #[derive(Clone, PartialEq, Eq, Hash, Copy, RustcEncodable, RustcDecodable)]\n-pub enum Region {\n+pub enum RegionKind<'tcx> {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n     // parameters are substituted.\n@@ -749,12 +751,12 @@ pub enum Region {\n     /// When checking a function body, the types of all arguments and so forth\n     /// that refer to bound region parameters are modified to refer to free\n     /// region parameters.\n-    ReFree(FreeRegion),\n+    ReFree(FreeRegion<'tcx>),\n \n     /// A concrete region naming some statically determined extent\n     /// (e.g. an expression or sequence of statements) within the\n     /// current function.\n-    ReScope(region::CodeExtent),\n+    ReScope(region::CodeExtent<'tcx>),\n \n     /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n     ReStatic,\n@@ -779,7 +781,7 @@ pub enum Region {\n     ReErased,\n }\n \n-impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Region {}\n+impl<'tcx> serialize::UseSpecializedDecodable for Region<'tcx> {}\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n@@ -898,7 +900,7 @@ impl DebruijnIndex {\n }\n \n // Region utilities\n-impl Region {\n+impl<'tcx> RegionKind<'tcx> {\n     pub fn is_bound(&self) -> bool {\n         match *self {\n             ty::ReEarlyBound(..) => true,\n@@ -922,7 +924,7 @@ impl Region {\n     }\n \n     /// Returns the depth of `self` from the (1-based) binding level `depth`\n-    pub fn from_depth(&self, depth: u32) -> Region {\n+    pub fn from_depth(&self, depth: u32) -> RegionKind<'tcx> {\n         match *self {\n             ty::ReLateBound(debruijn, r) => ty::ReLateBound(DebruijnIndex {\n                 depth: debruijn.depth - (depth - 1)\n@@ -1334,7 +1336,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Returns the regions directly referenced from this type (but\n     /// not types reachable from this type via `walk_tys`). This\n     /// ignores late-bound regions binders.\n-    pub fn regions(&self) -> Vec<&'tcx ty::Region> {\n+    pub fn regions(&self) -> Vec<ty::Region<'tcx>> {\n         match self.sty {\n             TyRef(region, _) => {\n                 vec![region]"}, {"sha": "c591845dd63b17fdd1443c1880d9fc1bd461fd00", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -11,7 +11,7 @@\n // Type substitutions.\n \n use hir::def_id::DefId;\n-use ty::{self, Slice, Ty, TyCtxt};\n+use ty::{self, Slice, Region, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n@@ -32,7 +32,7 @@ use std::mem;\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Kind<'tcx> {\n     ptr: NonZero<usize>,\n-    marker: PhantomData<(Ty<'tcx>, &'tcx ty::Region)>\n+    marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>)>\n }\n \n const TAG_MASK: usize = 0b11;\n@@ -54,8 +54,8 @@ impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n     }\n }\n \n-impl<'tcx> From<&'tcx ty::Region> for Kind<'tcx> {\n-    fn from(r: &'tcx ty::Region) -> Kind<'tcx> {\n+impl<'tcx> From<ty::Region<'tcx>> for Kind<'tcx> {\n+    fn from(r: ty::Region<'tcx>) -> Kind<'tcx> {\n         // Ensure we can use the tag bits.\n         assert_eq!(mem::align_of_val(r) & TAG_MASK, 0);\n \n@@ -88,7 +88,7 @@ impl<'tcx> Kind<'tcx> {\n     }\n \n     #[inline]\n-    pub fn as_region(self) -> Option<&'tcx ty::Region> {\n+    pub fn as_region(self) -> Option<ty::Region<'tcx>> {\n         unsafe {\n             self.downcast(REGION_TAG)\n         }\n@@ -153,7 +153,7 @@ impl<'tcx> Decodable for Kind<'tcx> {\n             d.read_enum_variant(&[\"Ty\", \"Region\"], |d, tag| {\n                 match tag {\n                     TYPE_TAG => Ty::decode(d).map(Kind::from),\n-                    REGION_TAG => <&ty::Region>::decode(d).map(Kind::from),\n+                    REGION_TAG => Region::decode(d).map(Kind::from),\n                     _ => Err(d.error(\"invalid Kind tag\"))\n                 }\n             })\n@@ -183,7 +183,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                             mut mk_region: FR,\n                             mut mk_type: FT)\n                             -> &'tcx Substs<'tcx>\n-    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n           FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n         let defs = tcx.generics_of(def_id);\n         let mut substs = Vec::with_capacity(defs.count());\n@@ -197,7 +197,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                              mut mk_region: FR,\n                              mut mk_type: FT)\n                              -> &'tcx Substs<'tcx>\n-    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n           FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx>\n     {\n         let defs = tcx.generics_of(def_id);\n@@ -212,7 +212,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                          defs: &ty::Generics,\n                          mk_region: &mut FR,\n                          mk_type: &mut FT)\n-    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n           FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n \n         if let Some(def_id) = defs.parent {\n@@ -226,7 +226,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                            defs: &ty::Generics,\n                            mk_region: &mut FR,\n                            mk_type: &mut FT)\n-    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n           FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n         // Handle Self first, before all regions.\n         let mut types = defs.types.iter();\n@@ -260,7 +260,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn regions(&'a self) -> impl DoubleEndedIterator<Item=&'tcx ty::Region> + 'a {\n+    pub fn regions(&'a self) -> impl DoubleEndedIterator<Item=ty::Region<'tcx>> + 'a {\n         self.iter().filter_map(|k| k.as_region())\n     }\n \n@@ -272,7 +272,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn region_at(&self, i: usize) -> &'tcx ty::Region {\n+    pub fn region_at(&self, i: usize) -> ty::Region<'tcx> {\n         self[i].as_region().unwrap_or_else(|| {\n             bug!(\"expected region for param #{} in {:?}\", i, self);\n         })\n@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn region_for_def(&self, def: &ty::RegionParameterDef) -> &'tcx ty::Region {\n+    pub fn region_for_def(&self, def: &ty::RegionParameterDef) -> ty::Region<'tcx> {\n         self.region_at(def.index as usize)\n     }\n \n@@ -396,7 +396,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         // Note: This routine only handles regions that are bound on\n         // type declarations and other outer declarations, not those\n         // bound in *fn types*. Region substitution of the bound\n@@ -538,7 +538,7 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    fn shift_region_through_binders(&self, region: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn shift_region_through_binders(&self, region: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         if self.region_binders_passed == 0 || !region.has_escaping_regions() {\n             return region;\n         }"}, {"sha": "befc4e6c5fdd1400152e911042e130f2ba021607", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -316,7 +316,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn required_region_bounds(self,\n                                   erased_self_ty: Ty<'tcx>,\n                                   predicates: Vec<ty::Predicate<'tcx>>)\n-                                  -> Vec<&'tcx ty::Region>    {\n+                                  -> Vec<ty::Region<'tcx>>    {\n         debug!(\"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n                erased_self_ty,\n                predicates);\n@@ -457,7 +457,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let result = item_substs.iter().zip(impl_substs.iter())\n             .filter(|&(_, &k)| {\n-                if let Some(&ty::Region::ReEarlyBound(ref ebr)) = k.as_region() {\n+                if let Some(&ty::RegionKind::ReEarlyBound(ref ebr)) = k.as_region() {\n                     !impl_generics.region_param(ebr).pure_wrt_drop\n                 } else if let Some(&ty::TyS {\n                     sty: ty::TypeVariants::TyParam(ref pt), ..\n@@ -673,7 +673,7 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n         ty.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         self.hash_discriminant_u8(r);\n         match *r {\n             ty::ReErased |"}, {"sha": "d0cbbaf2c10bf391b803f0a7ff6b4cbdd74c6c54", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -116,9 +116,9 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n /// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n #[derive(Debug)]\n pub enum ImpliedBound<'tcx> {\n-    RegionSubRegion(&'tcx ty::Region, &'tcx ty::Region),\n-    RegionSubParam(&'tcx ty::Region, ty::ParamTy),\n-    RegionSubProjection(&'tcx ty::Region, ty::ProjectionTy<'tcx>),\n+    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n+    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n+    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n }\n \n /// Compute the implied bounds that a callee/impl can assume based on\n@@ -198,7 +198,7 @@ pub fn implied_bounds<'a, 'gcx, 'tcx>(\n /// this down to determine what relationships would have to hold for\n /// `T: 'a` to hold. We get to assume that the caller has validated\n /// those relationships.\n-fn implied_bounds_from_components<'tcx>(sub_region: &'tcx ty::Region,\n+fn implied_bounds_from_components<'tcx>(sub_region: ty::Region<'tcx>,\n                                         sup_components: Vec<Component<'tcx>>)\n                                         -> Vec<ImpliedBound<'tcx>>\n {\n@@ -455,7 +455,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n     fn from_object_ty(&mut self, ty: Ty<'tcx>,\n                       data: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>,\n-                      region: &'tcx ty::Region) {\n+                      region: ty::Region<'tcx>) {\n         // Imagine a type like this:\n         //\n         //     trait Foo { }\n@@ -512,7 +512,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n-    -> Vec<&'tcx ty::Region>\n+    -> Vec<ty::Region<'tcx>>\n {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically"}, {"sha": "d773bb2da0898b6b30d0cdd07698bfa8395a90b1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -177,12 +177,12 @@ pub fn parameterized(f: &mut fmt::Formatter,\n     let print_regions = |f: &mut fmt::Formatter, start: &str, skip, count| {\n         // Don't print any regions if they're all erased.\n         let regions = || substs.regions().skip(skip).take(count);\n-        if regions().all(|r: &ty::Region| *r == ty::ReErased) {\n+        if regions().all(|r: ty::Region| *r == ty::ReErased) {\n             return Ok(());\n         }\n \n         for region in regions() {\n-            let region: &ty::Region = region;\n+            let region: ty::Region = region;\n             start_or_continue(f, start, \", \")?;\n             if verbose {\n                 write!(f, \"{:?}\", region)?;\n@@ -458,7 +458,7 @@ impl fmt::Debug for ty::BoundRegion {\n     }\n }\n \n-impl fmt::Debug for ty::Region {\n+impl<'tcx> fmt::Debug for ty::RegionKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::ReEarlyBound(ref data) => {\n@@ -516,7 +516,7 @@ impl<'tcx> fmt::Debug for ty::ParameterEnvironment<'tcx> {\n     }\n }\n \n-impl fmt::Display for ty::Region {\n+impl<'tcx> fmt::Display for ty::RegionKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {\n             return write!(f, \"{:?}\", *self);\n@@ -544,7 +544,7 @@ impl fmt::Display for ty::Region {\n     }\n }\n \n-impl fmt::Debug for ty::FreeRegion {\n+impl<'tcx> fmt::Debug for ty::FreeRegion<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ReFree({:?}, {:?})\",\n                self.scope, self.bound_region)\n@@ -689,14 +689,14 @@ impl<'tcx> fmt::Display for ty::Binder<ty::ProjectionPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, &'tcx ty::Region>> {\n+impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<&'tcx ty::Region,\n-                                                             &'tcx ty::Region>> {\n+impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>,\n+                                                             ty::Region<'tcx>>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }"}, {"sha": "96753d63af2031f3f2736a5b51172e84f907a675", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              loan_region: &'tcx ty::Region,\n+              loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {\n@@ -232,14 +232,14 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub fn each_in_scope_loan<F>(&self, scope: region::CodeExtent, mut op: F) -> bool where\n+    pub fn each_in_scope_loan<F>(&self, scope: region::CodeExtent<'tcx>, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,\n     {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n \n         let tcx = self.tcx();\n-        self.each_issued_loan(scope.node_id(&tcx.region_maps()), |loan| {\n+        self.each_issued_loan(scope.node_id(), |loan| {\n             if tcx.region_maps().is_subscope_of(scope, loan.kill_scope) {\n                 op(loan)\n             } else {\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn each_in_scope_loan_affecting_path<F>(&self,\n-                                            scope: region::CodeExtent,\n+                                            scope: region::CodeExtent<'tcx>,\n                                             loan_path: &LoanPath<'tcx>,\n                                             mut op: F)\n                                             -> bool where\n@@ -460,8 +460,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             // 3. Where does old loan expire.\n \n             let previous_end_span =\n-                self.tcx().hir.span(old_loan.kill_scope.node_id(&self.tcx().region_maps()))\n-                              .end_point();\n+                self.tcx().hir.span(old_loan.kill_scope.node_id()).end_point();\n \n             let mut err = match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n@@ -710,7 +709,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         let mut ret = UseOk;\n \n         self.each_in_scope_loan_affecting_path(\n-            self.tcx().region_maps().node_extent(expr_id), use_path, |loan| {\n+            self.tcx().node_extent(expr_id), use_path, |loan| {\n             if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n                 ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n                 false\n@@ -824,7 +823,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         // Check that we don't invalidate any outstanding loans\n         if let Some(loan_path) = opt_loan_path(&assignee_cmt) {\n-            let scope = self.tcx().region_maps().node_extent(assignment_id);\n+            let scope = self.tcx().node_extent(assignment_id);\n             self.each_in_scope_loan_affecting_path(scope, &loan_path, |loan| {\n                 self.report_illegal_mutation(assignment_span, &loan_path, loan);\n                 false"}, {"sha": "9f8ffd86f5414cc7b0c7aedda517ff121a7e1e9b", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -24,11 +24,11 @@ use syntax_pos::Span;\n type R = Result<(),()>;\n \n pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                    item_scope: region::CodeExtent,\n+                                    item_scope: region::CodeExtent<'tcx>,\n                                     span: Span,\n                                     cause: euv::LoanCause,\n                                     cmt: mc::cmt<'tcx>,\n-                                    loan_region: &'tcx ty::Region,\n+                                    loan_region: ty::Region<'tcx>,\n                                     _: ty::BorrowKind)\n                                     -> Result<(),()> {\n     //! Reports error if `loan_region` is larger than S\n@@ -52,11 +52,11 @@ struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n \n     // the scope of the function body for the enclosing item\n-    item_scope: region::CodeExtent,\n+    item_scope: region::CodeExtent<'tcx>,\n \n     span: Span,\n     cause: euv::LoanCause,\n-    loan_region: &'tcx ty::Region,\n+    loan_region: ty::Region<'tcx>,\n     cmt_original: mc::cmt<'tcx>\n }\n \n@@ -92,7 +92,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn check_scope(&self, max_scope: &'tcx ty::Region) -> R {\n+    fn check_scope(&self, max_scope: ty::Region<'tcx>) -> R {\n         //! Reports an error if `loan_region` is larger than `max_scope`\n \n         if !self.bccx.is_subregion_of(self.loan_region, max_scope) {\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn scope(&self, cmt: &mc::cmt<'tcx>) -> &'tcx ty::Region {\n+    fn scope(&self, cmt: &mc::cmt<'tcx>) -> ty::Region<'tcx> {\n         //! Returns the maximal region scope for the which the\n         //! lvalue `cmt` is guaranteed to be valid without any\n         //! rooting etc, and presuming `cmt` is not mutated."}, {"sha": "09ed515939de646eb17ca6c282a025fd59b3b3c5", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -45,7 +45,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         bccx: bccx,\n         infcx: &infcx,\n         all_loans: Vec::new(),\n-        item_ub: bccx.tcx.region_maps().node_extent(body.node_id),\n+        item_ub: bccx.tcx.node_extent(body.node_id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n@@ -66,7 +66,7 @@ struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     all_loans: Vec<Loan<'tcx>>,\n     /// `item_ub` is used as an upper-bound on the lifetime whenever we\n     /// ask for the scope of an expression categorized as an upvar.\n-    item_ub: region::CodeExtent,\n+    item_ub: region::CodeExtent<'tcx>,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n@@ -127,7 +127,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              loan_region: &'tcx ty::Region,\n+              loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {\n@@ -299,7 +299,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                        borrow_span: Span,\n                        cmt: mc::cmt<'tcx>,\n                        req_kind: ty::BorrowKind,\n-                       loan_region: &'tcx ty::Region,\n+                       loan_region: ty::Region<'tcx>,\n                        cause: euv::LoanCause) {\n         debug!(\"guarantee_valid(borrow_id={}, cmt={:?}, \\\n                 req_mutbl={:?}, loan_region={:?})\",\n@@ -371,7 +371,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 };\n                 debug!(\"loan_scope = {:?}\", loan_scope);\n \n-                let borrow_scope = self.tcx().region_maps().node_extent(borrow_id);\n+                let borrow_scope = self.tcx().node_extent(borrow_id);\n                 let gen_scope = self.compute_gen_scope(borrow_scope, loan_scope);\n                 debug!(\"gen_scope = {:?}\", gen_scope);\n \n@@ -450,9 +450,9 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn compute_gen_scope(&self,\n-                             borrow_scope: region::CodeExtent,\n-                             loan_scope: region::CodeExtent)\n-                             -> region::CodeExtent {\n+                             borrow_scope: region::CodeExtent<'tcx>,\n+                             loan_scope: region::CodeExtent<'tcx>)\n+                             -> region::CodeExtent<'tcx> {\n         //! Determine when to introduce the loan. Typically the loan\n         //! is introduced at the point of the borrow, but in some cases,\n         //! notably method arguments, the loan may be introduced only\n@@ -465,8 +465,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn compute_kill_scope(&self, loan_scope: region::CodeExtent, lp: &LoanPath<'tcx>)\n-                              -> region::CodeExtent {\n+    pub fn compute_kill_scope(&self, loan_scope: region::CodeExtent<'tcx>, lp: &LoanPath<'tcx>)\n+                              -> region::CodeExtent<'tcx> {\n         //! Determine when the loan restrictions go out of scope.\n         //! This is either when the lifetime expires or when the\n         //! local variable which roots the loan-path goes out of scope,"}, {"sha": "7f90a8b19d4a1250794f360233134db585111fb5", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -31,7 +31,7 @@ pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       span: Span,\n                                       cause: euv::LoanCause,\n                                       cmt: mc::cmt<'tcx>,\n-                                      loan_region: &'tcx ty::Region)\n+                                      loan_region: ty::Region<'tcx>)\n                                       -> RestrictionResult<'tcx> {\n     let ctxt = RestrictionsContext {\n         bccx: bccx,\n@@ -49,7 +49,7 @@ pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n struct RestrictionsContext<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     span: Span,\n-    loan_region: &'tcx ty::Region,\n+    loan_region: ty::Region<'tcx>,\n     cause: euv::LoanCause,\n }\n "}, {"sha": "1a7c700e23955e4cc1cf6ed29ab036b93e32fcab", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -141,9 +141,9 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                              id_range,\n                              all_loans.len());\n     for (loan_idx, loan) in all_loans.iter().enumerate() {\n-        loan_dfcx.add_gen(loan.gen_scope.node_id(&tcx.region_maps()), loan_idx);\n+        loan_dfcx.add_gen(loan.gen_scope.node_id(), loan_idx);\n         loan_dfcx.add_kill(KillFrom::ScopeEnd,\n-                           loan.kill_scope.node_id(&tcx.region_maps()), loan_idx);\n+                           loan.kill_scope.node_id(), loan_idx);\n     }\n     loan_dfcx.add_kills_from_flow_exits(cfg);\n     loan_dfcx.propagate(cfg, body);\n@@ -206,13 +206,13 @@ pub struct Loan<'tcx> {\n     /// cases, notably method arguments, the loan may be introduced\n     /// only later, once it comes into scope.  See also\n     /// `GatherLoanCtxt::compute_gen_scope`.\n-    gen_scope: region::CodeExtent,\n+    gen_scope: region::CodeExtent<'tcx>,\n \n     /// kill_scope indicates when the loan goes out of scope.  This is\n     /// either when the lifetime expires or when the local variable\n     /// which roots the loan-path goes out of scope, whichever happens\n     /// faster. See also `GatherLoanCtxt::compute_kill_scope`.\n-    kill_scope: region::CodeExtent,\n+    kill_scope: region::CodeExtent<'tcx>,\n     span: Span,\n     cause: euv::LoanCause,\n }\n@@ -312,12 +312,12 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n }\n \n impl<'a, 'tcx> LoanPath<'tcx> {\n-    pub fn kill_scope(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> region::CodeExtent {\n+    pub fn kill_scope(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> region::CodeExtent<'tcx> {\n         match self.kind {\n             LpVar(local_id) => tcx.region_maps().var_scope(local_id),\n             LpUpvar(upvar_id) => {\n                 let block_id = closure_to_block(upvar_id.closure_expr_id, tcx);\n-                tcx.region_maps().node_extent(block_id)\n+                tcx.node_extent(block_id)\n             }\n             LpDowncast(ref base, _) |\n             LpExtend(ref base, ..) => base.kill_scope(tcx),\n@@ -444,8 +444,8 @@ pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n pub enum bckerr_code<'tcx> {\n     err_mutbl,\n     /// superscope, subscope, loan cause\n-    err_out_of_scope(&'tcx ty::Region, &'tcx ty::Region, euv::LoanCause),\n-    err_borrowed_pointer_too_short(&'tcx ty::Region, &'tcx ty::Region), // loan, ptr\n+    err_out_of_scope(ty::Region<'tcx>, ty::Region<'tcx>, euv::LoanCause),\n+    err_borrowed_pointer_too_short(ty::Region<'tcx>, ty::Region<'tcx>), // loan, ptr\n }\n \n // Combination of an error code and the categorization of the expression\n@@ -475,8 +475,8 @@ pub enum MovedValueUseKind {\n \n impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn is_subregion_of(&self,\n-                           r_sub: &'tcx ty::Region,\n-                           r_sup: &'tcx ty::Region)\n+                           r_sub: ty::Region<'tcx>,\n+                           r_sup: ty::Region<'tcx>)\n                            -> bool\n     {\n         self.tables.free_region_map.is_subregion_of(self.tcx, r_sub, r_sup)\n@@ -963,10 +963,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             .emit();\n     }\n \n-    fn region_end_span(&self, region: &'tcx ty::Region) -> Option<Span> {\n+    fn region_end_span(&self, region: ty::Region<'tcx>) -> Option<Span> {\n         match *region {\n             ty::ReScope(scope) => {\n-                match scope.span(&self.tcx.region_maps(), &self.tcx.hir) {\n+                match scope.span(&self.tcx.hir) {\n                     Some(s) => {\n                         Some(s.end_point())\n                     }\n@@ -1244,10 +1244,10 @@ before rustc 1.16, this temporary lived longer - see issue #39283 \\\n     }\n }\n \n-fn statement_scope_span(tcx: TyCtxt, region: &ty::Region) -> Option<Span> {\n+fn statement_scope_span(tcx: TyCtxt, region: ty::Region) -> Option<Span> {\n     match *region {\n         ty::ReScope(scope) => {\n-            match tcx.hir.find(scope.node_id(&tcx.region_maps())) {\n+            match tcx.hir.find(scope.node_id()) {\n                 Some(hir_map::NodeStmt(stmt)) => Some(stmt.span),\n                 _ => None\n             }"}, {"sha": "3d7df7f0372131b7532157023edbcdd99ec6f308", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -548,7 +548,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = path.loan_path.kill_scope(tcx);\n                     let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n-                    self.kill_moves(path, kill_scope.node_id(&tcx.region_maps()),\n+                    self.kill_moves(path, kill_scope.node_id(),\n                                     KillFrom::ScopeEnd, dfcx_moves);\n                 }\n                 LpExtend(..) => {}\n@@ -563,7 +563,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = lp.kill_scope(tcx);\n                     dfcx_assign.add_kill(KillFrom::ScopeEnd,\n-                                         kill_scope.node_id(&tcx.region_maps()),\n+                                         kill_scope.node_id(),\n                                          assignment_index);\n                 }\n                 LpExtend(..) => {"}, {"sha": "5a2fc9adc2f0250821c21b6cf29054c17d1972bf", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -533,7 +533,7 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n               _: ast::NodeId,\n               span: Span,\n               _: cmt,\n-              _: &'tcx ty::Region,\n+              _: ty::Region<'tcx>,\n               kind:ty:: BorrowKind,\n               _: LoanCause) {\n         match kind {"}, {"sha": "e15d63a63c25850bdb1f9881faacd2106abe778d", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -35,7 +35,7 @@ pub enum PatternError<'tcx> {\n #[derive(Copy, Clone, Debug)]\n pub enum BindingMode<'tcx> {\n     ByValue,\n-    ByRef(&'tcx Region, BorrowKind),\n+    ByRef(Region<'tcx>, BorrowKind),\n }\n \n #[derive(Clone, Debug)]\n@@ -811,7 +811,7 @@ macro_rules! CloneImpls {\n }\n \n CloneImpls!{ <'tcx>\n-    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal<'tcx>, Region,\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal<'tcx>, Region<'tcx>,\n     Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n     &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n }"}, {"sha": "b0fca5c0ff377f079840781c2d708c06587a98e8", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -80,6 +80,27 @@ impl<T: Debug + PartialEq> TransitiveRelation<T> {\n         }\n     }\n \n+    /// Applies the (partial) function to each edge and returns a new\n+    /// relation.  If `f` returns `None` for any end-point, returns\n+    /// `None`.\n+    pub fn maybe_map<F, U>(&self, mut f: F) -> Option<TransitiveRelation<U>>\n+        where F: FnMut(&T) -> Option<U>,\n+              U: Debug + PartialEq,\n+    {\n+        let mut result = TransitiveRelation::new();\n+        for edge in &self.edges {\n+            let r = f(&self.elements[edge.source.0]).and_then(|source| {\n+                f(&self.elements[edge.target.0]).and_then(|target| {\n+                    Some(result.add(source, target))\n+                })\n+            });\n+            if r.is_none() {\n+                return None;\n+            }\n+        }\n+        Some(result)\n+    }\n+\n     /// Indicate that `a < b` (where `<` is this relation)\n     pub fn add(&mut self, a: T, b: T) {\n         let a = self.add_index(a);"}, {"sha": "38f9854857115191dbf4b66630653960f7441c79", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_param(index, Symbol::intern(&name))\n     }\n \n-    pub fn re_early_bound(&self, index: u32, name: &'static str) -> &'tcx ty::Region {\n+    pub fn re_early_bound(&self, index: u32, name: &'static str) -> ty::Region<'tcx> {\n         let name = Symbol::intern(name);\n         self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             index: index,\n@@ -304,11 +304,11 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     pub fn re_late_bound_with_debruijn(&self,\n                                        id: u32,\n                                        debruijn: ty::DebruijnIndex)\n-                                       -> &'tcx ty::Region {\n+                                       -> ty::Region<'tcx> {\n         self.infcx.tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n     }\n \n-    pub fn t_rptr(&self, r: &'tcx ty::Region) -> Ty<'tcx> {\n+    pub fn t_rptr(&self, r: ty::Region<'tcx>) -> Ty<'tcx> {\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n@@ -330,7 +330,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n-    pub fn re_free(&self, nid: ast::NodeId, id: u32) -> &'tcx ty::Region {\n+    pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region<'tcx> {\n         self.infcx.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n             scope: self.tcx().region_maps.item_extent(nid),\n             bound_region: ty::BrAnon(id),"}, {"sha": "9f4625c2ce3057974bb34dd6a3c9225917288610", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -20,6 +20,7 @@ use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::middle::lang_items;\n+use rustc::middle::region;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n@@ -352,12 +353,18 @@ impl<'a, 'tcx> SpecializedDecoder<&'tcx Substs<'tcx>> for DecodeContext<'a, 'tcx\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Region> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<&'tcx ty::Region, Self::Error> {\n+impl<'a, 'tcx> SpecializedDecoder<ty::Region<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<ty::Region<'tcx>, Self::Error> {\n         Ok(self.tcx().mk_region(Decodable::decode(self)?))\n     }\n }\n \n+impl<'a, 'tcx> SpecializedDecoder<region::CodeExtent<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<region::CodeExtent<'tcx>, Self::Error> {\n+        Ok(self.tcx().intern_code_extent(Decodable::decode(self)?))\n+    }\n+}\n+\n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<Ty<'tcx>>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx ty::Slice<Ty<'tcx>>, Self::Error> {\n         Ok(self.tcx().mk_type_list((0..self.read_usize()?).map(|_| Decodable::decode(self)))?)"}, {"sha": "d81de954dbf1588876ae8b4734e5470c5f197f67", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let_extent_stack.push(remainder_scope);\n \n                     // Declare the bindings, which may create a visibility scope.\n-                    let remainder_span = remainder_scope.span(&tcx.region_maps(), &tcx.hir);\n+                    let remainder_span = remainder_scope.span(&tcx.hir);\n                     let remainder_span = remainder_span.unwrap_or(span);\n                     let scope = this.declare_bindings(None, remainder_span, &pattern);\n "}, {"sha": "22a36bb21d8753f6cafc5b285007cdf6e9a69a87", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// The operand is known to be live until the end of `scope`.\n     pub fn as_operand<M>(&mut self,\n                          block: BasicBlock,\n-                         scope: Option<CodeExtent>,\n+                         scope: Option<CodeExtent<'tcx>>,\n                          expr: M) -> BlockAnd<Operand<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n@@ -49,7 +49,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_operand(&mut self,\n                        mut block: BasicBlock,\n-                       scope: Option<CodeExtent>,\n+                       scope: Option<CodeExtent<'tcx>>,\n                        expr: Expr<'tcx>)\n                        -> BlockAnd<Operand<'tcx>> {\n         debug!(\"expr_as_operand(block={:?}, expr={:?})\", block, expr);"}, {"sha": "8dc7745cd9eb998772201cfd2d519b56fdf861ec", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     /// Compile `expr`, yielding an rvalue.\n-    pub fn as_rvalue<M>(&mut self, block: BasicBlock, scope: Option<CodeExtent>, expr: M)\n+    pub fn as_rvalue<M>(&mut self, block: BasicBlock, scope: Option<CodeExtent<'tcx>>, expr: M)\n                         -> BlockAnd<Rvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n@@ -48,7 +48,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_rvalue(&mut self,\n                       mut block: BasicBlock,\n-                      scope: Option<CodeExtent>,\n+                      scope: Option<CodeExtent<'tcx>>,\n                       expr: Expr<'tcx>)\n                       -> BlockAnd<Rvalue<'tcx>> {\n         debug!(\"expr_as_rvalue(block={:?}, expr={:?})\", block, expr);"}, {"sha": "db4561af734d5627d5faae1b4497f34df825486e", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -21,7 +21,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// up rvalues so as to freeze the value that will be consumed.\n     pub fn as_temp<M>(&mut self,\n                       block: BasicBlock,\n-                      temp_lifetime: Option<CodeExtent>,\n+                      temp_lifetime: Option<CodeExtent<'tcx>>,\n                       expr: M)\n                       -> BlockAnd<Lvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n@@ -32,7 +32,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_temp(&mut self,\n                     mut block: BasicBlock,\n-                    temp_lifetime: Option<CodeExtent>,\n+                    temp_lifetime: Option<CodeExtent<'tcx>>,\n                     expr: Expr<'tcx>)\n                     -> BlockAnd<Lvalue<'tcx>> {\n         debug!(\"expr_as_temp(block={:?}, expr={:?})\", block, expr);"}, {"sha": "6c01e4315f3e9a5eda20c9830cc5cd24f0679527", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -137,10 +137,10 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let mut builder = Builder::new(hir, span, arguments.len(), return_ty);\n \n     let call_site_extent =\n-        tcx.region_maps().lookup_code_extent(\n+        tcx.intern_code_extent(\n             CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body.value.id });\n     let arg_extent =\n-        tcx.region_maps().lookup_code_extent(\n+        tcx.intern_code_extent(\n             CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body.value.id });\n     let mut block = START_BLOCK;\n     unpack!(block = builder.in_scope(call_site_extent, block, |builder| {\n@@ -205,8 +205,8 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let mut builder = Builder::new(hir, span, 0, ty);\n \n     let region_maps = tcx.region_maps();\n-    let extent = region_maps.temporary_scope(ast_expr.id)\n-                            .unwrap_or(region_maps.item_extent(owner_id));\n+    let extent = region_maps.temporary_scope(tcx, ast_expr.id)\n+                            .unwrap_or(tcx.item_extent(owner_id));\n     let mut block = START_BLOCK;\n     let _ = builder.in_scope(extent, block, |builder| {\n         let expr = builder.hir.mirror(ast_expr);\n@@ -290,7 +290,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn args_and_body(&mut self,\n                      mut block: BasicBlock,\n                      arguments: &[(Ty<'gcx>, Option<&'gcx hir::Pat>)],\n-                     argument_extent: CodeExtent,\n+                     argument_extent: CodeExtent<'tcx>,\n                      ast_body: &'gcx hir::Expr)\n                      -> BlockAnd<()>\n     {"}, {"sha": "fcd06835d98699d5606906c1063e74fd4d38d968", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -102,7 +102,7 @@ pub struct Scope<'tcx> {\n     visibility_scope: VisibilityScope,\n \n     /// the extent of this scope within source code.\n-    extent: CodeExtent,\n+    extent: CodeExtent<'tcx>,\n \n     /// Whether there's anything to do for the cleanup path, that is,\n     /// when unwinding through this scope. This includes destructors,\n@@ -137,7 +137,7 @@ pub struct Scope<'tcx> {\n     free: Option<FreeData<'tcx>>,\n \n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n-    cached_exits: FxHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n+    cached_exits: FxHashMap<(BasicBlock, CodeExtent<'tcx>), BasicBlock>,\n }\n \n struct DropData<'tcx> {\n@@ -180,7 +180,7 @@ struct FreeData<'tcx> {\n #[derive(Clone, Debug)]\n pub struct BreakableScope<'tcx> {\n     /// Extent of the loop\n-    pub extent: CodeExtent,\n+    pub extent: CodeExtent<'tcx>,\n     /// Where the body of the loop begins. `None` if block\n     pub continue_block: Option<BasicBlock>,\n     /// Block to branch into when the loop or block terminates (either by being `break`-en out\n@@ -248,10 +248,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     ///\n     /// Returns the might_break attribute of the BreakableScope used.\n     pub fn in_breakable_scope<F, R>(&mut self,\n-                            loop_block: Option<BasicBlock>,\n-                            break_block: BasicBlock,\n-                            break_destination: Lvalue<'tcx>,\n-                            f: F) -> R\n+                                    loop_block: Option<BasicBlock>,\n+                                    break_block: BasicBlock,\n+                                    break_destination: Lvalue<'tcx>,\n+                                    f: F) -> R\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> R\n     {\n         let extent = self.topmost_scope();\n@@ -270,7 +270,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n-    pub fn in_scope<F, R>(&mut self, extent: CodeExtent, mut block: BasicBlock, f: F) -> BlockAnd<R>\n+    pub fn in_scope<F, R>(&mut self, extent: CodeExtent<'tcx>, mut block: BasicBlock, f: F) -> BlockAnd<R>\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n@@ -285,7 +285,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, extent: CodeExtent) {\n+    pub fn push_scope(&mut self, extent: CodeExtent<'tcx>) {\n         debug!(\"push_scope({:?})\", extent);\n         let vis_scope = self.visibility_scope;\n         self.scopes.push(Scope {\n@@ -302,7 +302,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// drops onto the end of `block` that are needed.  This must\n     /// match 1-to-1 with `push_scope`.\n     pub fn pop_scope(&mut self,\n-                     extent: CodeExtent,\n+                     extent: CodeExtent<'tcx>,\n                      mut block: BasicBlock)\n                      -> BlockAnd<()> {\n         debug!(\"pop_scope({:?}, {:?})\", extent, block);\n@@ -326,7 +326,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// module comment for details.\n     pub fn exit_scope(&mut self,\n                       span: Span,\n-                      extent: CodeExtent,\n+                      extent: CodeExtent<'tcx>,\n                       mut block: BasicBlock,\n                       target: BasicBlock) {\n         debug!(\"exit_scope(extent={:?}, block={:?}, target={:?})\", extent, block, target);\n@@ -387,7 +387,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// resolving `break` and `continue`.\n     pub fn find_breakable_scope(&mut self,\n                            span: Span,\n-                           label: CodeExtent)\n+                           label: CodeExtent<'tcx>)\n                            -> &mut BreakableScope<'tcx> {\n         // find the loop-scope with the correct id\n         self.breakable_scopes.iter_mut()\n@@ -407,11 +407,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     /// Returns the extent of the scope which should be exited by a\n     /// return.\n-    pub fn extent_of_return_scope(&self) -> CodeExtent {\n+    pub fn extent_of_return_scope(&self) -> CodeExtent<'tcx> {\n         // The outermost scope (`scopes[0]`) will be the `CallSiteScope`.\n         // We want `scopes[1]`, which is the `ParameterScope`.\n         assert!(self.scopes.len() >= 2);\n-        assert!(match self.hir.tcx().region_maps().code_extent_data(self.scopes[1].extent) {\n+        assert!(match *self.scopes[1].extent {\n             CodeExtentData::ParameterScope { .. } => true,\n             _ => false,\n         });\n@@ -420,7 +420,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     /// Returns the topmost active scope, which is known to be alive until\n     /// the next scope expression.\n-    pub fn topmost_scope(&self) -> CodeExtent {\n+    pub fn topmost_scope(&self) -> CodeExtent<'tcx> {\n         self.scopes.last().expect(\"topmost_scope: no scopes present\").extent\n     }\n \n@@ -430,7 +430,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// `extent`.\n     pub fn schedule_drop(&mut self,\n                          span: Span,\n-                         extent: CodeExtent,\n+                         extent: CodeExtent<'tcx>,\n                          lvalue: &Lvalue<'tcx>,\n                          lvalue_ty: Ty<'tcx>) {\n         let needs_drop = self.hir.needs_drop(lvalue_ty);\n@@ -499,7 +499,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     scope.needs_cleanup = true;\n                 }\n                 let tcx = self.hir.tcx();\n-                let extent_span = extent.span(&tcx.region_maps(), &tcx.hir).unwrap();\n+                let extent_span = extent.span(&tcx.hir).unwrap();\n                 // Attribute scope exit drops to scope's closing brace\n                 let scope_end = Span { lo: extent_span.hi, .. extent_span};\n                 scope.drops.push(DropData {\n@@ -520,7 +520,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// There may only be one \u201cfree\u201d scheduled in any given scope.\n     pub fn schedule_box_free(&mut self,\n                              span: Span,\n-                             extent: CodeExtent,\n+                             extent: CodeExtent<'tcx>,\n                              value: &Lvalue<'tcx>,\n                              item_ty: Ty<'tcx>) {\n         for scope in self.scopes.iter_mut().rev() {"}, {"sha": "15c2df55cf3c8e745a8c7d428ed0e87aafa2aa93", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -24,7 +24,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n         let stmts = mirror_stmts(cx, self.id, &*self.stmts);\n         Block {\n             targeted_by_break: self.targeted_by_break,\n-            extent: cx.tcx.region_maps().node_extent(self.id),\n+            extent: cx.tcx.node_extent(self.id),\n             span: self.span,\n             stmts: stmts,\n             expr: self.expr.to_ref(),\n@@ -44,7 +44,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     span: stmt.span,\n                     kind: StmtKind::Expr {\n-                        scope: cx.tcx.region_maps().node_extent(id),\n+                        scope: cx.tcx.node_extent(id),\n                         expr: expr.to_ref(),\n                     },\n                 })))\n@@ -60,14 +60,14 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             first_statement_index: index as u32,\n                         });\n                         let remainder_extent =\n-                            cx.tcx.region_maps().lookup_code_extent(remainder_extent);\n+                            cx.tcx.intern_code_extent(remainder_extent);\n \n                         let pattern = Pattern::from_hir(cx.tcx, cx.tables(), &local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             span: stmt.span,\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_extent,\n-                                init_scope: cx.tcx.region_maps().node_extent(id),\n+                                init_scope: cx.tcx.node_extent(id),\n                                 pattern: pattern,\n                                 initializer: local.init.to_ref(),\n                             },\n@@ -84,7 +84,7 @@ pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n     let block_ty = cx.tables().node_id_to_type(block.id);\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(block.id);\n+    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(cx.tcx, block.id);\n     let expr = Expr {\n         ty: block_ty,\n         temp_lifetime: temp_lifetime,"}, {"sha": "e37df8822c89253f3873423260f0b5a60be0cb2a", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -26,8 +26,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n-        let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(self.id);\n-        let expr_extent = cx.tcx.region_maps().node_extent(self.id);\n+        let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(cx.tcx, self.id);\n+        let expr_extent = cx.tcx.node_extent(self.id);\n \n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n@@ -216,7 +216,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         };\n \n         // Finally, create a destruction scope, if any.\n-        if let Some(extent) = cx.tcx.region_maps().opt_destruction_extent(self.id) {\n+        if let Some(extent) = cx.tcx.opt_destruction_extent(self.id) {\n             expr = Expr {\n                 temp_lifetime: temp_lifetime,\n                 temp_lifetime_was_shrunk: was_shrunk,\n@@ -238,7 +238,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n     let expr_ty = cx.tables().expr_ty(expr);\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(cx.tcx, expr.id);\n \n     let kind = match expr.node {\n         // Here comes the interesting stuff:\n@@ -610,7 +610,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(target_id) |\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(target_id)) => ExprKind::Break {\n-                    label: cx.tcx.region_maps().node_extent(target_id),\n+                    label: cx.tcx.node_extent(target_id),\n                     value: value.to_ref(),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n@@ -621,7 +621,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(_) => bug!(\"cannot continue to blocks\"),\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(loop_id)) => ExprKind::Continue {\n-                    label: cx.tcx.region_maps().node_extent(loop_id),\n+                    label: cx.tcx.node_extent(loop_id),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n                     bug!(\"invalid loop id for continue: {}\", err)\n@@ -686,7 +686,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprBox(ref value) => {\n             ExprKind::Box {\n                 value: value.to_ref(),\n-                value_extents: cx.tcx.region_maps().node_extent(value.id),\n+                value_extents: cx.tcx.node_extent(value.id),\n             }\n         }\n         hir::ExprArray(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n@@ -707,7 +707,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  method_call: ty::MethodCall)\n                                  -> Expr<'tcx> {\n     let callee = cx.tables().method_map[&method_call];\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(cx.tcx, expr.id);\n     Expr {\n         temp_lifetime: temp_lifetime,\n         temp_lifetime_was_shrunk: was_shrunk,\n@@ -791,7 +791,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                expr: &'tcx hir::Expr,\n                                def: Def)\n                                -> ExprKind<'tcx> {\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(cx.tcx, expr.id);\n \n     match def {\n         Def::Local(def_id) => {\n@@ -827,8 +827,8 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n             // have a bound region with number 0\n-            let region = ty::Region::ReFree(ty::FreeRegion {\n-                scope: Some(cx.tcx.region_maps().node_extent(body_id)),\n+            let region = ty::ReFree(ty::FreeRegion {\n+                scope: Some(cx.tcx.node_extent(body_id)),\n                 bound_region: ty::BoundRegion::BrAnon(0),\n             });\n             let region = cx.tcx.mk_region(region);\n@@ -979,7 +979,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         PassArgs::ByRef => {\n             let region = cx.tcx.node_scope_region(expr.id);\n             let (temp_lifetime, was_shrunk) =\n-                cx.tcx.region_maps().temporary_scope2(expr.id);\n+                cx.tcx.region_maps().temporary_scope2(cx.tcx, expr.id);\n             argrefs.extend(args.iter()\n                 .map(|arg| {\n                     let arg_ty = cx.tables().expr_ty_adjusted(arg);\n@@ -1031,7 +1031,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(cx.tcx, expr.id);\n     let ref_kind = overloaded_operator(cx, expr, method_call, pass_args, receiver, args);\n     let ref_expr = Expr {\n         temp_lifetime: temp_lifetime,\n@@ -1056,7 +1056,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         closure_expr_id: closure_expr.id,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id).unwrap();\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(closure_expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(cx.tcx, closure_expr.id);\n     let var_ty = cx.tables().node_id_to_type(id_var);\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,"}, {"sha": "0e8992e62ea6c8968eff6420194c7e7be817736f", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -32,7 +32,7 @@ pub use rustc_const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPatt\n #[derive(Clone, Debug)]\n pub struct Block<'tcx> {\n     pub targeted_by_break: bool,\n-    pub extent: CodeExtent,\n+    pub extent: CodeExtent<'tcx>,\n     pub span: Span,\n     pub stmts: Vec<StmtRef<'tcx>>,\n     pub expr: Option<ExprRef<'tcx>>,\n@@ -53,7 +53,7 @@ pub struct Stmt<'tcx> {\n pub enum StmtKind<'tcx> {\n     Expr {\n         /// scope for this statement; may be used as lifetime of temporaries\n-        scope: CodeExtent,\n+        scope: CodeExtent<'tcx>,\n \n         /// expression being evaluated in this statement\n         expr: ExprRef<'tcx>,\n@@ -62,11 +62,11 @@ pub enum StmtKind<'tcx> {\n     Let {\n         /// scope for variables bound in this let; covers this and\n         /// remaining statements in block\n-        remainder_scope: CodeExtent,\n+        remainder_scope: CodeExtent<'tcx>,\n \n         /// scope for the initialization itself; might be used as\n         /// lifetime of temporaries\n-        init_scope: CodeExtent,\n+        init_scope: CodeExtent<'tcx>,\n \n         /// let <PAT> = ...\n         pattern: Pattern<'tcx>,\n@@ -97,7 +97,7 @@ pub struct Expr<'tcx> {\n \n     /// lifetime of this expression if it should be spilled into a\n     /// temporary; should be None only if in a constant context\n-    pub temp_lifetime: Option<CodeExtent>,\n+    pub temp_lifetime: Option<CodeExtent<'tcx>>,\n \n     /// whether this temp lifetime was shrunk by #36082.\n     pub temp_lifetime_was_shrunk: bool,\n@@ -112,12 +112,12 @@ pub struct Expr<'tcx> {\n #[derive(Clone, Debug)]\n pub enum ExprKind<'tcx> {\n     Scope {\n-        extent: CodeExtent,\n+        extent: CodeExtent<'tcx>,\n         value: ExprRef<'tcx>,\n     },\n     Box {\n         value: ExprRef<'tcx>,\n-        value_extents: CodeExtent,\n+        value_extents: CodeExtent<'tcx>,\n     },\n     Call {\n         ty: ty::Ty<'tcx>,\n@@ -205,16 +205,16 @@ pub enum ExprKind<'tcx> {\n         id: DefId,\n     },\n     Borrow {\n-        region: &'tcx Region,\n+        region: Region<'tcx>,\n         borrow_kind: BorrowKind,\n         arg: ExprRef<'tcx>,\n     },\n     Break {\n-        label: CodeExtent,\n+        label: CodeExtent<'tcx>,\n         value: Option<ExprRef<'tcx>>,\n     },\n     Continue {\n-        label: CodeExtent,\n+        label: CodeExtent<'tcx>,\n     },\n     Return {\n         value: Option<ExprRef<'tcx>>,"}, {"sha": "1abae515ae68374ee32c9a6672226f8a7dfdb862", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -252,8 +252,8 @@ fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> Ty<'tcx> {\n     let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n \n-    let region = ty::Region::ReFree(ty::FreeRegion {\n-        scope: Some(tcx.region_maps().item_extent(body_id.node_id)),\n+    let region = ty::ReFree(ty::FreeRegion {\n+        scope: Some(tcx.item_extent(body_id.node_id)),\n         bound_region: ty::BoundRegion::BrEnv,\n     });\n     let region = tcx.mk_region(region);"}, {"sha": "cb0625ceccfcb836c6552c267d33de86002050ad", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -480,7 +480,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n               borrow_id: ast::NodeId,\n               _borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              _loan_region: &'tcx ty::Region,\n+              _loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause) {\n         // Kind of hacky, but we allow Unsafe coercions in constants."}, {"sha": "c89e3ca8b68c9266e7a7526ea85df14faf93ed13", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -53,7 +53,7 @@ pub trait AstConv<'gcx, 'tcx> {\n \n     /// What lifetime should we use when a lifetime is omitted (and not elided)?\n     fn re_infer(&self, span: Span, _def: Option<&ty::RegionParameterDef>)\n-                -> Option<&'tcx ty::Region>;\n+                -> Option<ty::Region<'tcx>>;\n \n     /// What type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n@@ -104,7 +104,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn ast_region_to_region(&self,\n         lifetime: &hir::Lifetime,\n         def: Option<&ty::RegionParameterDef>)\n-        -> &'tcx ty::Region\n+        -> ty::Region<'tcx>\n     {\n         let tcx = self.tcx();\n         let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n@@ -133,7 +133,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Some(&rl::Region::Free(scope, id)) => {\n                 let name = tcx.hir.name(id);\n                 tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                    scope: Some(scope.to_code_extent(&tcx.region_maps())),\n+                    scope: Some(scope.to_code_extent(tcx)),\n                     bound_region: ty::BrNamed(tcx.hir.local_def_id(id), name)\n                 }))\n \n@@ -1342,7 +1342,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn compute_object_lifetime_bound(&self,\n         span: Span,\n         existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n-        -> Option<&'tcx ty::Region> // if None, use the default\n+        -> Option<ty::Region<'tcx>> // if None, use the default\n     {\n         let tcx = self.tcx();\n \n@@ -1489,7 +1489,7 @@ fn report_lifetime_number_error(tcx: TyCtxt, span: Span, number: usize, expected\n // and return from functions in multiple places.\n #[derive(PartialEq, Eq, Clone, Debug)]\n pub struct Bounds<'tcx> {\n-    pub region_bounds: Vec<&'tcx ty::Region>,\n+    pub region_bounds: Vec<ty::Region<'tcx>>,\n     pub implicitly_sized: bool,\n     pub trait_bounds: Vec<ty::PolyTraitRef<'tcx>>,\n     pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n@@ -1533,7 +1533,7 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n \n pub enum ExplicitSelf<'tcx> {\n     ByValue,\n-    ByReference(&'tcx ty::Region, hir::Mutability),\n+    ByReference(ty::Region<'tcx>, hir::Mutability),\n     ByBox\n }\n "}, {"sha": "45b0a571bd08afd7b7e5827e57bb1078c5174a47", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n \n-        let extent = self.tcx.region_maps().call_site_extent(expr.id, body.value.id);\n+        let extent = self.tcx.call_site_extent(expr.id, body.value.id);\n         let fn_sig = self.tcx.liberate_late_bound_regions(Some(extent), &sig);\n         let fn_sig = self.inh.normalize_associated_types_in(body.value.span,\n                                                             body.value.id, &fn_sig);"}, {"sha": "d42532a714e2e2d642c176705ae254146b278ca0", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -250,7 +250,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                   exprs: &[E],\n                                   a: Ty<'tcx>,\n                                   b: Ty<'tcx>,\n-                                  r_b: &'tcx ty::Region,\n+                                  r_b: ty::Region<'tcx>,\n                                   mt_b: TypeAndMut<'tcx>)\n                                   -> CoerceResult<'tcx>\n         where E: AsCoercionSite"}, {"sha": "e4408413ee6c59dd751b2c0f7dcc616a83d3bd83", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -271,7 +271,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'gcx, 'tcx>,\n     ty: ty::Ty<'tcx>,\n     span: Span,\n-    scope: region::CodeExtent)\n+    scope: region::CodeExtent<'tcx>)\n     -> Result<(), ErrorReported>\n {\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\","}, {"sha": "729d25aaef541c60b52be3bc32ecd4ea1f87cd0e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -781,7 +781,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             check_abi(tcx, span, fn_sig.abi());\n \n             // Compute the fty from point of view of inside fn.\n-            let fn_scope = inh.tcx.region_maps().call_site_extent(id, body_id.node_id);\n+            let fn_scope = inh.tcx.call_site_extent(id, body_id.node_id);\n             let fn_sig =\n                 fn_sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n             let fn_sig =\n@@ -1549,7 +1549,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn re_infer(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n-                -> Option<&'tcx ty::Region> {\n+                -> Option<ty::Region<'tcx>> {\n         let v = match def {\n             Some(def) => infer::EarlyBoundRegion(span, def.name, def.issue_32330),\n             None => infer::MiscVariable(span)\n@@ -1963,7 +1963,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// outlive the region `r`.\n     pub fn register_region_obligation(&self,\n                                       ty: Ty<'tcx>,\n-                                      region: &'tcx ty::Region,\n+                                      region: ty::Region<'tcx>,\n                                       cause: traits::ObligationCause<'tcx>)\n     {\n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();"}, {"sha": "9a978934dda4220de3fee04b576ffd723ad0b60e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -171,15 +171,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n \n-    region_bound_pairs: Vec<(&'tcx ty::Region, GenericKind<'tcx>)>,\n+    region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n \n-    free_region_map: FreeRegionMap,\n+    free_region_map: FreeRegionMap<'tcx>,\n \n     // id of innermost fn body id\n     body_id: ast::NodeId,\n \n     // call_site scope of innermost fn\n-    call_site_scope: Option<CodeExtent>,\n+    call_site_scope: Option<CodeExtent<'tcx>>,\n \n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n@@ -215,7 +215,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn set_call_site_scope(&mut self, call_site_scope: Option<CodeExtent>) -> Option<CodeExtent> {\n+    fn set_call_site_scope(&mut self, call_site_scope: Option<CodeExtent<'tcx>>)\n+                           -> Option<CodeExtent<'tcx>> {\n         mem::replace(&mut self.call_site_scope, call_site_scope)\n     }\n \n@@ -276,7 +277,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let body_id = body.id();\n \n-        let call_site = self.tcx.region_maps().lookup_code_extent(\n+        let call_site = self.tcx.intern_code_extent(\n             region::CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id });\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n@@ -302,7 +303,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let old_body_id = self.set_body_id(body_id.node_id);\n         self.relate_free_regions(&fn_sig_tys[..], body_id.node_id, span);\n-        self.link_fn_args(self.tcx.region_maps().node_extent(body_id.node_id), &body.arguments);\n+        self.link_fn_args(self.tcx.node_extent(body_id.node_id), &body.arguments);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n \n@@ -868,7 +869,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // call occurs.\n         //\n         // FIXME(#6268) to support nested method calls, should be callee_id\n-        let callee_scope = self.tcx.region_maps().node_extent(call_expr.id);\n+        let callee_scope = self.tcx.node_extent(call_expr.id);\n         let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n \n         debug!(\"callee_region={:?}\", callee_region);\n@@ -982,8 +983,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_subregion_due_to_dereference(&mut self,\n                                            deref_span: Span,\n-                                           minimum_lifetime: &'tcx ty::Region,\n-                                           maximum_lifetime: &'tcx ty::Region) {\n+                                           minimum_lifetime: ty::Region<'tcx>,\n+                                           maximum_lifetime: ty::Region<'tcx>) {\n         self.sub_regions(infer::DerefPointer(deref_span),\n                          minimum_lifetime, maximum_lifetime)\n     }\n@@ -1021,7 +1022,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n                self.ty_to_string(indexed_ty));\n \n-        let r_index_expr = ty::ReScope(self.tcx.region_maps().node_extent(index_expr.id));\n+        let r_index_expr = ty::ReScope(self.tcx.node_extent(index_expr.id));\n         if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n             match mt.ty.sty {\n                 ty::TySlice(_) | ty::TyStr => {\n@@ -1038,7 +1039,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn type_of_node_must_outlive(&mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         id: ast::NodeId,\n-        minimum_lifetime: &'tcx ty::Region)\n+        minimum_lifetime: ty::Region<'tcx>)\n     {\n         // Try to resolve the type.  If we encounter an error, then typeck\n         // is going to fail anyway, so just stop here and let typeck\n@@ -1101,7 +1102,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n-    fn link_fn_args(&self, body_scope: CodeExtent, args: &[hir::Arg]) {\n+    fn link_fn_args(&self, body_scope: CodeExtent<'tcx>, args: &[hir::Arg]) {\n         debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n         let mc = mc::MemCategorizationContext::new(self);\n         for arg in args {\n@@ -1167,7 +1168,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// must outlive `callee_scope`.\n     fn link_by_ref(&self,\n                    expr: &hir::Expr,\n-                   callee_scope: CodeExtent) {\n+                   callee_scope: CodeExtent<'tcx>) {\n         debug!(\"link_by_ref(expr={:?}, callee_scope={:?})\",\n                expr, callee_scope);\n         let mc = mc::MemCategorizationContext::new(self);\n@@ -1200,7 +1201,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// between regions, as explained in `link_reborrowed_region()`.\n     fn link_region(&self,\n                    span: Span,\n-                   borrow_region: &'tcx ty::Region,\n+                   borrow_region: ty::Region<'tcx>,\n                    borrow_kind: ty::BorrowKind,\n                    borrow_cmt: mc::cmt<'tcx>) {\n         let mut borrow_cmt = borrow_cmt;\n@@ -1297,10 +1298,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// recurse and process `ref_cmt` (see case 2 above).\n     fn link_reborrowed_region(&self,\n                               span: Span,\n-                              borrow_region: &'tcx ty::Region,\n+                              borrow_region: ty::Region<'tcx>,\n                               borrow_kind: ty::BorrowKind,\n                               ref_cmt: mc::cmt<'tcx>,\n-                              ref_region: &'tcx ty::Region,\n+                              ref_region: ty::Region<'tcx>,\n                               mut ref_kind: ty::BorrowKind,\n                               note: mc::Note)\n                               -> Option<(mc::cmt<'tcx>, ty::BorrowKind)>\n@@ -1411,7 +1412,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                           origin: infer::ParameterOrigin,\n                           substs: &Substs<'tcx>,\n                           expr_span: Span,\n-                          expr_region: &'tcx ty::Region) {\n+                          expr_region: ty::Region<'tcx>) {\n         debug!(\"substs_wf_in_scope(substs={:?}, \\\n                 expr_region={:?}, \\\n                 origin={:?}, \\\n@@ -1436,7 +1437,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     pub fn type_must_outlive(&self,\n                              origin: infer::SubregionOrigin<'tcx>,\n                              ty: Ty<'tcx>,\n-                             region: &'tcx ty::Region)\n+                             region: ty::Region<'tcx>)\n     {\n         let ty = self.resolve_type(ty);\n \n@@ -1454,7 +1455,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn components_must_outlive(&self,\n                                origin: infer::SubregionOrigin<'tcx>,\n                                components: Vec<ty::outlives::Component<'tcx>>,\n-                               region: &'tcx ty::Region)\n+                               region: ty::Region<'tcx>)\n     {\n         for component in components {\n             let origin = origin.clone();\n@@ -1485,7 +1486,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn param_ty_must_outlive(&self,\n                              origin: infer::SubregionOrigin<'tcx>,\n-                             region: &'tcx ty::Region,\n+                             region: ty::Region<'tcx>,\n                              param_ty: ty::ParamTy) {\n         debug!(\"param_ty_must_outlive(region={:?}, param_ty={:?}, origin={:?})\",\n                region, param_ty, origin);\n@@ -1497,7 +1498,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn projection_must_outlive(&self,\n                                origin: infer::SubregionOrigin<'tcx>,\n-                               region: &'tcx ty::Region,\n+                               region: ty::Region<'tcx>,\n                                projection_ty: ty::ProjectionTy<'tcx>)\n     {\n         debug!(\"projection_must_outlive(region={:?}, projection_ty={:?}, origin={:?})\",\n@@ -1622,7 +1623,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn projection_declared_bounds(&self,\n                                   span: Span,\n                                   projection_ty: ty::ProjectionTy<'tcx>)\n-                                  -> Vec<&'tcx ty::Region>\n+                                  -> Vec<ty::Region<'tcx>>\n     {\n         // First assemble bounds from where clauses and traits.\n \n@@ -1637,7 +1638,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn projection_bound(&self,\n                         span: Span,\n-                        declared_bounds: Vec<&'tcx ty::Region>,\n+                        declared_bounds: Vec<ty::Region<'tcx>>,\n                         projection_ty: ty::ProjectionTy<'tcx>)\n                         -> VerifyBound<'tcx> {\n         debug!(\"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n@@ -1673,7 +1674,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn declared_generic_bounds_from_env(&self, generic: GenericKind<'tcx>)\n-                                        -> Vec<&'tcx ty::Region>\n+                                        -> Vec<ty::Region<'tcx>>\n     {\n         let param_env = &self.parameter_environment;\n \n@@ -1707,7 +1708,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn declared_projection_bounds_from_trait(&self,\n                                              span: Span,\n                                              projection_ty: ty::ProjectionTy<'tcx>)\n-                                             -> Vec<&'tcx ty::Region>\n+                                             -> Vec<ty::Region<'tcx>>\n     {\n         debug!(\"projection_bounds(projection_ty={:?})\",\n                projection_ty);"}, {"sha": "a2c9b7876aafadf43a5e01aae436e1bbda7b222d", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -536,7 +536,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n               borrow_id: ast::NodeId,\n               _borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              _loan_region: &'tcx ty::Region,\n+              _loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               _loan_cause: euv::LoanCause)\n     {"}, {"sha": "1887eaef3604438340db63a690356cce992eec59", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -341,7 +341,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n \n             let mut implied_bounds = vec![];\n-            let free_id_outlive = fcx.tcx.region_maps().call_site_extent(item.id, body_id.node_id);\n+            let free_id_outlive = fcx.tcx.call_site_extent(item.id, body_id.node_id);\n             this.check_fn_or_method(fcx, item.span, sig, &predicates,\n                                     Some(free_id_outlive), &mut implied_bounds);\n             implied_bounds\n@@ -429,7 +429,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                       span: Span,\n                                       sig: ty::PolyFnSig<'tcx>,\n                                       predicates: &ty::InstantiatedPredicates<'tcx>,\n-                                      free_id_outlive: Option<CodeExtent>,\n+                                      free_id_outlive: Option<CodeExtent<'tcx>>,\n                                       implied_bounds: &mut Vec<Ty<'tcx>>)\n     {\n         let free_substs = &fcx.parameter_environment.free_substs;\n@@ -453,7 +453,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                          fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                          method_sig: &hir::MethodSig,\n                                          method: &ty::AssociatedItem,\n-                                         free_id_outlive: Option<CodeExtent>,\n+                                         free_id_outlive: Option<CodeExtent<'tcx>>,\n                                          self_ty: ty::Ty<'tcx>)\n     {\n         // check that the type of the method's receiver matches the"}, {"sha": "ab2151544fc6e539d677349807a80e41e510731d", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -76,7 +76,7 @@ struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     // early-bound versions of them, visible from the\n     // outside of the function. This is needed by, and\n     // only populated if there are any `impl Trait`.\n-    free_to_bound_regions: DefIdMap<&'gcx ty::Region>,\n+    free_to_bound_regions: DefIdMap<ty::Region<'gcx>>,\n \n     body: &'gcx hir::Body,\n }\n@@ -275,7 +275,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_free_region_map(&mut self) {\n-        self.tables.free_region_map = self.fcx.tables.borrow().free_region_map.clone();\n+        let free_region_map = self.tcx().lift_to_global(&self.fcx.tables.borrow().free_region_map);\n+        let free_region_map = free_region_map.expect(\"all regions in free-region-map are global\");\n+        self.tables.free_region_map = free_region_map;\n     }\n \n     fn visit_anon_types(&mut self) {\n@@ -522,7 +524,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n \n     // FIXME This should be carefully checked\n     // We could use `self.report_error` but it doesn't accept a ty::Region, right now.\n-    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match self.infcx.fully_resolve(&r) {\n             Ok(r) => r,\n             Err(_) => {"}, {"sha": "0d75a1ecf3d8f30c31ca61195df08f05c0db6f7e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -215,7 +215,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n \n     fn re_infer(&self, _span: Span, _def: Option<&ty::RegionParameterDef>)\n-                -> Option<&'tcx ty::Region> {\n+                -> Option<ty::Region<'tcx>> {\n         None\n     }\n "}, {"sha": "ee11b774cf26102c523c62f0a78dbcab3c69770b", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -75,7 +75,7 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         match *r {\n             ty::ReEarlyBound(data) => {\n                 self.parameters.push(Parameter::from(data));"}, {"sha": "529b2700679d57626363cda4407c8e27e234d73b", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -479,7 +479,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// context with ambient variance `variance`\n     fn add_constraints_from_region(&mut self,\n                                    generics: &ty::Generics,\n-                                   region: &'tcx ty::Region,\n+                                   region: ty::Region<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n         match *region {\n             ty::ReEarlyBound(ref data) => {"}, {"sha": "5899ce9061166222d0eaae0ffd9d86130f08cbc6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -726,7 +726,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n             if let ty::TyTuple(ts, _) = ty_s.sty {\n                 for &ty_s in ts {\n                     if let ty::TyRef(ref reg, _) = ty_s.sty {\n-                        if let &ty::Region::ReLateBound(..) = *reg {\n+                        if let &ty::RegionKind::ReLateBound(..) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(lt) = reg.clean(cx) {\n                                 late_bounds.push(lt);\n@@ -819,7 +819,7 @@ impl Clean<Lifetime> for ty::RegionParameterDef {\n     }\n }\n \n-impl Clean<Option<Lifetime>> for ty::Region {\n+impl<'tcx> Clean<Option<Lifetime>> for ty::RegionKind<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n@@ -915,7 +915,7 @@ impl<'tcx> Clean<WherePredicate> for ty::SubtypePredicate<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<&'tcx ty::Region, &'tcx ty::Region> {\n+impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>> {\n     fn clean(&self, cx: &DocContext) -> WherePredicate {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         WherePredicate::RegionPredicate {\n@@ -925,7 +925,7 @@ impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<&'tcx ty::Region, &'t\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Ty<'tcx>, &'tcx ty::Region> {\n+impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Ty<'tcx>, ty::Region<'tcx>> {\n     fn clean(&self, cx: &DocContext) -> WherePredicate {\n         let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n "}, {"sha": "d1f957bf6b955370b946932f6e8cb8ede36b98d8", "filename": "src/test/run-pass/kindck-implicit-close-over-mut-var.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dc39dbf095f04839b57a1e34afc6ab29d905d3/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs?ref=c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+s// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //"}]}