{"sha": "168a0209002fef203e83989ff641c1b3e1a51859", "node_id": "C_kwDOAAsO6NoAKDE2OGEwMjA5MDAyZmVmMjAzZTgzOTg5ZmY2NDFjMWIzZTFhNTE4NTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-03T16:04:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-03T16:04:47Z"}, "message": "Auto merge of #92686 - saethlin:unsafe-debug-asserts, r=Amanieu\n\nAdd debug assertions to some unsafe functions\n\nAs suggested by https://github.com/rust-lang/rust/issues/51713\n\n~~Some similar code calls `abort()` instead of `panic!()` but aborting doesn't work in a `const fn`, and the intrinsic for doing dispatch based on whether execution is in a const is unstable.~~\n\nThis picked up some invalid uses of `get_unchecked` in the compiler, and fixes them.\n\nI can confirm that they do in fact pick up invalid uses of `get_unchecked` in the wild, though the user experience is less-than-awesome:\n```\n     Running unittests (target/x86_64-unknown-linux-gnu/debug/deps/rle_decode_fast-04b7918da2001b50)\n\nrunning 6 tests\nerror: test failed, to rerun pass '--lib'\n\nCaused by:\n  process didn't exit successfully: `/home/ben/rle-decode-helper/target/x86_64-unknown-linux-gnu/debug/deps/rle_decode_fast-04b7918da2001b50` (signal: 4, SIGILL: illegal instruction)\n```\n\n~~As best I can tell these changes produce a 6% regression in the runtime of `./x.py test` when `[rust] debug = true` is set.~~\nLatest commit (https://github.com/rust-lang/rust/pull/92686/commits/6894d559bdb4365243b3f4bf73f18e4b1bed04d1) brings the additional overhead from this PR down to 0.5%, while also adding a few more assertions. I think this actually covers all the places in `core` that it is reasonable to check for safety requirements at runtime.\n\nThoughts?", "tree": {"sha": "3677c86e0de2975e8ce62c9336288a6001aea489", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3677c86e0de2975e8ce62c9336288a6001aea489"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/168a0209002fef203e83989ff641c1b3e1a51859", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/168a0209002fef203e83989ff641c1b3e1a51859", "html_url": "https://github.com/rust-lang/rust/commit/168a0209002fef203e83989ff641c1b3e1a51859", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/168a0209002fef203e83989ff641c1b3e1a51859/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15a242a432c9c40a60def102209a5d40900b7b9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/15a242a432c9c40a60def102209a5d40900b7b9d", "html_url": "https://github.com/rust-lang/rust/commit/15a242a432c9c40a60def102209a5d40900b7b9d"}, {"sha": "6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72", "html_url": "https://github.com/rust-lang/rust/commit/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72"}], "stats": {"total": 251, "additions": 123, "deletions": 128}, "files": [{"sha": "874de03d37ac6295f8398e22acd0e3ac677bc38c", "filename": "compiler/rustc_data_structures/src/map_in_place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/168a0209002fef203e83989ff641c1b3e1a51859/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168a0209002fef203e83989ff641c1b3e1a51859/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs?ref=168a0209002fef203e83989ff641c1b3e1a51859", "patch": "@@ -30,13 +30,13 @@ impl<T> MapInPlace<T> for Vec<T> {\n             while read_i < old_len {\n                 // move the read_i'th item out of the vector and map it\n                 // to an iterator\n-                let e = ptr::read(self.get_unchecked(read_i));\n+                let e = ptr::read(self.as_ptr().add(read_i));\n                 let iter = f(e).into_iter();\n                 read_i += 1;\n \n                 for e in iter {\n                     if write_i < read_i {\n-                        ptr::write(self.get_unchecked_mut(write_i), e);\n+                        ptr::write(self.as_mut_ptr().add(write_i), e);\n                         write_i += 1;\n                     } else {\n                         // If this is reached we ran out of space\n@@ -76,13 +76,13 @@ impl<T, A: Array<Item = T>> MapInPlace<T> for SmallVec<A> {\n             while read_i < old_len {\n                 // move the read_i'th item out of the vector and map it\n                 // to an iterator\n-                let e = ptr::read(self.get_unchecked(read_i));\n+                let e = ptr::read(self.as_ptr().add(read_i));\n                 let iter = f(e).into_iter();\n                 read_i += 1;\n \n                 for e in iter {\n                     if write_i < read_i {\n-                        ptr::write(self.get_unchecked_mut(write_i), e);\n+                        ptr::write(self.as_mut_ptr().add(write_i), e);\n                         write_i += 1;\n                     } else {\n                         // If this is reached we ran out of space"}, {"sha": "333b3c20d1d399493bde20aae853091ca5e23c8e", "filename": "library/alloc/benches/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/168a0209002fef203e83989ff641c1b3e1a51859/library%2Falloc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168a0209002fef203e83989ff641c1b3e1a51859/library%2Falloc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec.rs?ref=168a0209002fef203e83989ff641c1b3e1a51859", "patch": "@@ -627,10 +627,10 @@ fn bench_map_regular(b: &mut Bencher) {\n fn bench_map_fast(b: &mut Bencher) {\n     let data = black_box([(0, 0); LEN]);\n     b.iter(|| {\n-        let mut result = Vec::with_capacity(data.len());\n+        let mut result: Vec<u32> = Vec::with_capacity(data.len());\n         for i in 0..data.len() {\n             unsafe {\n-                *result.get_unchecked_mut(i) = data[i].0;\n+                *result.as_mut_ptr().add(i) = data[i].0;\n                 result.set_len(i);\n             }\n         }"}, {"sha": "0744e9cf4269110b8e58e5fda98056a1a1b0ff17", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 48, "deletions": 53, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/168a0209002fef203e83989ff641c1b3e1a51859/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168a0209002fef203e83989ff641c1b3e1a51859/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=168a0209002fef203e83989ff641c1b3e1a51859", "patch": "@@ -1969,6 +1969,40 @@ extern \"rust-intrinsic\" {\n // (`transmute` also falls into this category, but it cannot be wrapped due to the\n // check that `T` and `U` have the same size.)\n \n+/// Check that the preconditions of an unsafe function are followed, if debug_assertions are on,\n+/// and only at runtime.\n+///\n+/// # Safety\n+///\n+/// Invoking this macro is only sound if the following code is already UB when the passed\n+/// expression evaluates to false.\n+///\n+/// This macro expands to a check at runtime if debug_assertions is set. It has no effect at\n+/// compile time, but the semantics of the contained `const_eval_select` must be the same at\n+/// runtime and at compile time. Thus if the expression evaluates to false, this macro produces\n+/// different behavior at compile time and at runtime, and invoking it is incorrect.\n+///\n+/// So in a sense it is UB if this macro is useful, but we expect callers of `unsafe fn` to make\n+/// the occasional mistake, and this check should help them figure things out.\n+#[allow_internal_unstable(const_eval_select)] // permit this to be called in stably-const fn\n+macro_rules! assert_unsafe_precondition {\n+    ($e:expr) => {\n+        if cfg!(debug_assertions) {\n+            // Use a closure so that we can capture arbitrary expressions from the invocation\n+            let runtime = || {\n+                if !$e {\n+                    // abort instead of panicking to reduce impact on code size\n+                    ::core::intrinsics::abort();\n+                }\n+            };\n+            const fn comptime() {}\n+\n+            ::core::intrinsics::const_eval_select((), comptime, runtime);\n+        }\n+    };\n+}\n+pub(crate) use assert_unsafe_precondition;\n+\n /// Checks whether `ptr` is properly aligned with respect to\n /// `align_of::<T>()`.\n pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n@@ -1977,7 +2011,6 @@ pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n \n /// Checks whether the regions of memory starting at `src` and `dst` of size\n /// `count * size_of::<T>()` do *not* overlap.\n-#[cfg(debug_assertions)]\n pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -> bool {\n     let src_usize = src.addr();\n     let dst_usize = dst.addr();\n@@ -2079,28 +2112,16 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n         pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n-    #[cfg(debug_assertions)]\n-    fn runtime_check<T>(src: *const T, dst: *mut T, count: usize) {\n-        if !is_aligned_and_not_null(src)\n-            || !is_aligned_and_not_null(dst)\n-            || !is_nonoverlapping(src, dst, count)\n-        {\n-            // Not panicking to keep codegen impact smaller.\n-            abort();\n-        }\n-    }\n-    #[cfg(debug_assertions)]\n-    const fn compiletime_check<T>(_src: *const T, _dst: *mut T, _count: usize) {}\n-    #[cfg(debug_assertions)]\n-    // SAFETY: As per our safety precondition, we may assume that the `abort` above is never reached.\n-    // Therefore, compiletime_check and runtime_check are observably equivalent.\n-    unsafe {\n-        const_eval_select((src, dst, count), compiletime_check, runtime_check);\n-    }\n-\n     // SAFETY: the safety contract for `copy_nonoverlapping` must be\n     // upheld by the caller.\n-    unsafe { copy_nonoverlapping(src, dst, count) }\n+    unsafe {\n+        assert_unsafe_precondition!(\n+            is_aligned_and_not_null(src)\n+                && is_aligned_and_not_null(dst)\n+                && is_nonoverlapping(src, dst, count)\n+        );\n+        copy_nonoverlapping(src, dst, count)\n+    }\n }\n \n /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n@@ -2173,24 +2194,11 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n         fn copy<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n-    #[cfg(debug_assertions)]\n-    fn runtime_check<T>(src: *const T, dst: *mut T) {\n-        if !is_aligned_and_not_null(src) || !is_aligned_and_not_null(dst) {\n-            // Not panicking to keep codegen impact smaller.\n-            abort();\n-        }\n-    }\n-    #[cfg(debug_assertions)]\n-    const fn compiletime_check<T>(_src: *const T, _dst: *mut T) {}\n-    #[cfg(debug_assertions)]\n-    // SAFETY: As per our safety precondition, we may assume that the `abort` above is never reached.\n-    // Therefore, compiletime_check and runtime_check are observably equivalent.\n+    // SAFETY: the safety contract for `copy` must be upheld by the caller.\n     unsafe {\n-        const_eval_select((src, dst), compiletime_check, runtime_check);\n+        assert_unsafe_precondition!(is_aligned_and_not_null(src) && is_aligned_and_not_null(dst));\n+        copy(src, dst, count)\n     }\n-\n-    // SAFETY: the safety contract for `copy` must be upheld by the caller.\n-    unsafe { copy(src, dst, count) }\n }\n \n /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n@@ -2274,24 +2282,11 @@ pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n         fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n     }\n \n-    #[cfg(debug_assertions)]\n-    fn runtime_check<T>(ptr: *mut T) {\n-        debug_assert!(\n-            is_aligned_and_not_null(ptr),\n-            \"attempt to write to unaligned or null pointer\"\n-        );\n-    }\n-    #[cfg(debug_assertions)]\n-    const fn compiletime_check<T>(_ptr: *mut T) {}\n-    #[cfg(debug_assertions)]\n-    // SAFETY: runtime debug-assertions are a best-effort basis; it's fine to\n-    // not do them during compile time\n+    // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n     unsafe {\n-        const_eval_select((dst,), compiletime_check, runtime_check);\n+        assert_unsafe_precondition!(is_aligned_and_not_null(dst));\n+        write_bytes(dst, val, count)\n     }\n-\n-    // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n-    unsafe { write_bytes(dst, val, count) }\n }\n \n /// Selects which function to call depending on the context."}, {"sha": "a98b5d787f10ac3372b9540b9af136dd9bd6d2db", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/168a0209002fef203e83989ff641c1b3e1a51859/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168a0209002fef203e83989ff641c1b3e1a51859/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=168a0209002fef203e83989ff641c1b3e1a51859", "patch": "@@ -52,9 +52,13 @@ macro_rules! nonzero_integers {\n                 #[$const_new_unchecked_stability]\n                 #[must_use]\n                 #[inline]\n+                #[rustc_allow_const_fn_unstable(const_fn_fn_ptr_basics)] // required by assert_unsafe_precondition\n                 pub const unsafe fn new_unchecked(n: $Int) -> Self {\n                     // SAFETY: this is guaranteed to be safe by the caller.\n-                    unsafe { Self(n) }\n+                    unsafe {\n+                        core::intrinsics::assert_unsafe_precondition!(n != 0);\n+                        Self(n)\n+                    }\n                 }\n \n                 /// Creates a non-zero if the given value is not zero."}, {"sha": "42e55ce10462cd4efb3221779817ff1e7e0ae3ab", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/168a0209002fef203e83989ff641c1b3e1a51859/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168a0209002fef203e83989ff641c1b3e1a51859/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=168a0209002fef203e83989ff641c1b3e1a51859", "patch": "@@ -332,7 +332,10 @@\n use crate::cmp::Ordering;\n use crate::fmt;\n use crate::hash;\n-use crate::intrinsics::{self, abort, is_aligned_and_not_null};\n+use crate::intrinsics::{\n+    self, assert_unsafe_precondition, is_aligned_and_not_null, is_nonoverlapping,\n+};\n+\n use crate::mem::{self, MaybeUninit};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -749,6 +752,16 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n         };\n     }\n \n+    // SAFETY: the caller must guarantee that `x` and `y` are\n+    // valid for writes and properly aligned.\n+    unsafe {\n+        assert_unsafe_precondition!(\n+            is_aligned_and_not_null(x)\n+                && is_aligned_and_not_null(y)\n+                && is_nonoverlapping(x, y, count)\n+        );\n+    }\n+\n     // NOTE(scottmcm) MIRI is disabled here as reading in smaller units is a\n     // pessimization for it.  Also, if the type contains any unaligned pointers,\n     // copying those over multiple reads is difficult to support.\n@@ -839,6 +852,7 @@ pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n     // and cannot overlap `src` since `dst` must point to a distinct\n     // allocated object.\n     unsafe {\n+        assert_unsafe_precondition!(is_aligned_and_not_null(dst));\n         mem::swap(&mut *dst, &mut src); // cannot overlap\n     }\n     src\n@@ -1318,12 +1332,11 @@ pub const unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n #[inline]\n #[stable(feature = \"volatile\", since = \"1.9.0\")]\n pub unsafe fn read_volatile<T>(src: *const T) -> T {\n-    if cfg!(debug_assertions) && !is_aligned_and_not_null(src) {\n-        // Not panicking to keep codegen impact smaller.\n-        abort();\n-    }\n     // SAFETY: the caller must uphold the safety contract for `volatile_load`.\n-    unsafe { intrinsics::volatile_load(src) }\n+    unsafe {\n+        assert_unsafe_precondition!(is_aligned_and_not_null(src));\n+        intrinsics::volatile_load(src)\n+    }\n }\n \n /// Performs a volatile write of a memory location with the given value without\n@@ -1389,12 +1402,9 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"volatile\", since = \"1.9.0\")]\n pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n-    if cfg!(debug_assertions) && !is_aligned_and_not_null(dst) {\n-        // Not panicking to keep codegen impact smaller.\n-        abort();\n-    }\n     // SAFETY: the caller must uphold the safety contract for `volatile_store`.\n     unsafe {\n+        assert_unsafe_precondition!(is_aligned_and_not_null(dst));\n         intrinsics::volatile_store(dst, src);\n     }\n }"}, {"sha": "880d0f80cc8a05ec4a4211fb88723cd3bf526253", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/168a0209002fef203e83989ff641c1b3e1a51859/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168a0209002fef203e83989ff641c1b3e1a51859/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=168a0209002fef203e83989ff641c1b3e1a51859", "patch": "@@ -1,5 +1,6 @@\n //! Indexing implementations for `[T]`.\n \n+use crate::intrinsics::assert_unsafe_precondition;\n use crate::intrinsics::const_eval_select;\n use crate::ops;\n use crate::ptr;\n@@ -219,13 +220,19 @@ unsafe impl<T> const SliceIndex<[T]> for usize {\n         // cannot be longer than `isize::MAX`. They also guarantee that\n         // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n         // so the call to `add` is safe.\n-        unsafe { slice.as_ptr().add(self) }\n+        unsafe {\n+            assert_unsafe_precondition!(self < slice.len());\n+            slice.as_ptr().add(self)\n+        }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut T {\n         // SAFETY: see comments for `get_unchecked` above.\n-        unsafe { slice.as_mut_ptr().add(self) }\n+        unsafe {\n+            assert_unsafe_precondition!(self < slice.len());\n+            slice.as_mut_ptr().add(self)\n+        }\n     }\n \n     #[inline]\n@@ -272,13 +279,18 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n         // cannot be longer than `isize::MAX`. They also guarantee that\n         // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n         // so the call to `add` is safe.\n-        unsafe { ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }\n+\n+        unsafe {\n+            assert_unsafe_precondition!(self.end >= self.start && self.end <= slice.len());\n+            ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start)\n+        }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n+            assert_unsafe_precondition!(self.end >= self.start && self.end <= slice.len());\n             ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n         }\n     }"}, {"sha": "17f6373ecbf8624613bd0e32bad293cd4d8bef2c", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/168a0209002fef203e83989ff641c1b3e1a51859/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168a0209002fef203e83989ff641c1b3e1a51859/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=168a0209002fef203e83989ff641c1b3e1a51859", "patch": "@@ -7,6 +7,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cmp::Ordering::{self, Greater, Less};\n+use crate::intrinsics::{assert_unsafe_precondition, exact_div};\n use crate::marker::Copy;\n use crate::mem;\n use crate::num::NonZeroUsize;\n@@ -656,15 +657,10 @@ impl<T> [T] {\n     #[unstable(feature = \"slice_swap_unchecked\", issue = \"88539\")]\n     #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n     pub const unsafe fn swap_unchecked(&mut self, a: usize, b: usize) {\n-        #[cfg(debug_assertions)]\n-        {\n-            let _ = &self[a];\n-            let _ = &self[b];\n-        }\n-\n         let ptr = self.as_mut_ptr();\n         // SAFETY: caller has to guarantee that `a < self.len()` and `b < self.len()`\n         unsafe {\n+            assert_unsafe_precondition!(a < self.len() && b < self.len());\n             ptr::swap(ptr.add(a), ptr.add(b));\n         }\n     }\n@@ -970,11 +966,11 @@ impl<T> [T] {\n     #[inline]\n     #[must_use]\n     pub unsafe fn as_chunks_unchecked<const N: usize>(&self) -> &[[T; N]] {\n-        debug_assert_ne!(N, 0);\n-        debug_assert_eq!(self.len() % N, 0);\n-        let new_len =\n-            // SAFETY: Our precondition is exactly what's needed to call this\n-            unsafe { crate::intrinsics::exact_div(self.len(), N) };\n+        // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n+        let new_len = unsafe {\n+            assert_unsafe_precondition!(N != 0 && self.len() % N == 0);\n+            exact_div(self.len(), N)\n+        };\n         // SAFETY: We cast a slice of `new_len * N` elements into\n         // a slice of `new_len` many `N` elements chunks.\n         unsafe { from_raw_parts(self.as_ptr().cast(), new_len) }\n@@ -1109,11 +1105,11 @@ impl<T> [T] {\n     #[inline]\n     #[must_use]\n     pub unsafe fn as_chunks_unchecked_mut<const N: usize>(&mut self) -> &mut [[T; N]] {\n-        debug_assert_ne!(N, 0);\n-        debug_assert_eq!(self.len() % N, 0);\n-        let new_len =\n-            // SAFETY: Our precondition is exactly what's needed to call this\n-            unsafe { crate::intrinsics::exact_div(self.len(), N) };\n+        // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n+        let new_len = unsafe {\n+            assert_unsafe_precondition!(N != 0 && self.len() % N == 0);\n+            exact_div(self.len(), N)\n+        };\n         // SAFETY: We cast a slice of `new_len * N` elements into\n         // a slice of `new_len` many `N` elements chunks.\n         unsafe { from_raw_parts_mut(self.as_mut_ptr().cast(), new_len) }\n@@ -1675,7 +1671,10 @@ impl<T> [T] {\n         //\n         // `[ptr; mid]` and `[mid; len]` are not overlapping, so returning a mutable reference\n         // is fine.\n-        unsafe { (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid)) }\n+        unsafe {\n+            assert_unsafe_precondition!(mid <= len);\n+            (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid))\n+        }\n     }\n \n     /// Divides one slice into an array and a remainder slice at an index."}, {"sha": "1b88573035d22f1b0bf7551fc418d1f6b98b2456", "filename": "library/core/src/slice/raw.rs", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/168a0209002fef203e83989ff641c1b3e1a51859/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168a0209002fef203e83989ff641c1b3e1a51859/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs?ref=168a0209002fef203e83989ff641c1b3e1a51859", "patch": "@@ -1,6 +1,7 @@\n //! Free functions to create `&[T]` and `&mut [T]`.\n \n use crate::array;\n+use crate::intrinsics::{assert_unsafe_precondition, is_aligned_and_not_null};\n use crate::ops::Range;\n use crate::ptr;\n \n@@ -87,10 +88,14 @@ use crate::ptr;\n #[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n #[must_use]\n pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n-    debug_check_data_len(data, len);\n-\n     // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n-    unsafe { &*ptr::slice_from_raw_parts(data, len) }\n+    unsafe {\n+        assert_unsafe_precondition!(\n+            is_aligned_and_not_null(data)\n+                && crate::mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize\n+        );\n+        &*ptr::slice_from_raw_parts(data, len)\n+    }\n }\n \n /// Performs the same functionality as [`from_raw_parts`], except that a\n@@ -127,46 +132,16 @@ pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T]\n #[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n #[must_use]\n pub const unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n-    debug_check_data_len(data as _, len);\n-\n     // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n-    unsafe { &mut *ptr::slice_from_raw_parts_mut(data, len) }\n-}\n-\n-// In debug builds checks that `data` pointer is aligned and non-null and that slice with given `len` would cover less than half the address space\n-#[cfg(debug_assertions)]\n-#[unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n-#[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n-const fn debug_check_data_len<T>(data: *const T, len: usize) {\n-    fn rt_check<T>(data: *const T) {\n-        use crate::intrinsics::is_aligned_and_not_null;\n-\n-        assert!(is_aligned_and_not_null(data), \"attempt to create unaligned or null slice\");\n-    }\n-\n-    const fn noop<T>(_: *const T) {}\n-\n-    // SAFETY:\n-    //\n-    // `rt_check` is just a debug assert to hint users that they are causing UB,\n-    // it is not required for safety (the safety must be guatanteed by\n-    // the `from_raw_parts[_mut]` caller).\n-    //\n-    // As per our safety precondition, we may assume that assertion above never fails.\n-    // Therefore, noop and rt_check are observably equivalent.\n     unsafe {\n-        crate::intrinsics::const_eval_select((data,), noop, rt_check);\n+        assert_unsafe_precondition!(\n+            is_aligned_and_not_null(data)\n+                && crate::mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize\n+        );\n+        &mut *ptr::slice_from_raw_parts_mut(data, len)\n     }\n-\n-    assert!(\n-        crate::mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n-        \"attempt to create slice covering at least half the address space\"\n-    );\n }\n \n-#[cfg(not(debug_assertions))]\n-const fn debug_check_data_len<T>(_data: *const T, _len: usize) {}\n-\n /// Converts a reference to T into a slice of length 1 (without copying).\n #[stable(feature = \"from_ref\", since = \"1.28.0\")]\n #[rustc_const_unstable(feature = \"const_slice_from_ref\", issue = \"90206\")]"}]}