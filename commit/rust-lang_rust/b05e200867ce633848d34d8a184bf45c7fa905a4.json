{"sha": "b05e200867ce633848d34d8a184bf45c7fa905a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNWUyMDA4NjdjZTYzMzg0OGQzNGQ4YTE4NGJmNDVjN2ZhOTA1YTQ=", "commit": {"author": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-11-09T11:46:17Z"}, "committer": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-11-09T11:46:17Z"}, "message": "Run rustfmt on libstd/sync/once.rs", "tree": {"sha": "d5be8a77e77063c4210de13fb745451c79d7cd29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5be8a77e77063c4210de13fb745451c79d7cd29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b05e200867ce633848d34d8a184bf45c7fa905a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b05e200867ce633848d34d8a184bf45c7fa905a4", "html_url": "https://github.com/rust-lang/rust/commit/b05e200867ce633848d34d8a184bf45c7fa905a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b05e200867ce633848d34d8a184bf45c7fa905a4/comments", "author": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c66658f2c51df8d7d97c975395cc161b8df2f98", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c66658f2c51df8d7d97c975395cc161b8df2f98", "html_url": "https://github.com/rust-lang/rust/commit/4c66658f2c51df8d7d97c975395cc161b8df2f98"}], "stats": {"total": 61, "additions": 29, "deletions": 32}, "files": [{"sha": "e8e395247f9c199dc5d2ca4e0e00c7a66c91a639", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b05e200867ce633848d34d8a184bf45c7fa905a4/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05e200867ce633848d34d8a184bf45c7fa905a4/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=b05e200867ce633848d34d8a184bf45c7fa905a4", "patch": "@@ -87,7 +87,7 @@\n use crate::cell::Cell;\n use crate::fmt;\n use crate::marker;\n-use crate::sync::atomic::{AtomicUsize, AtomicBool, Ordering};\n+use crate::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n use crate::thread::{self, Thread};\n \n /// A synchronization primitive which can be used to run a one-time global\n@@ -149,7 +149,7 @@ pub struct OnceState {\n #[rustc_deprecated(\n     since = \"1.38.0\",\n     reason = \"the `new` function is now preferred\",\n-    suggestion = \"Once::new()\",\n+    suggestion = \"Once::new()\"\n )]\n pub const ONCE_INIT: Once = Once::new();\n \n@@ -185,15 +185,11 @@ struct WaiterQueue<'a> {\n     set_state_on_drop_to: usize,\n }\n \n-\n impl Once {\n     /// Creates a new `Once` value.\n     #[stable(feature = \"once_new\", since = \"1.2.0\")]\n     pub const fn new() -> Once {\n-        Once {\n-            state_and_queue: AtomicUsize::new(INCOMPLETE),\n-            _marker: marker::PhantomData,\n-        }\n+        Once { state_and_queue: AtomicUsize::new(INCOMPLETE), _marker: marker::PhantomData }\n     }\n \n     /// Performs an initialization routine once and only once. The given closure\n@@ -254,7 +250,10 @@ impl Once {\n     ///\n     /// [poison]: struct.Mutex.html#poisoning\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn call_once<F>(&self, f: F) where F: FnOnce() {\n+    pub fn call_once<F>(&self, f: F)\n+    where\n+        F: FnOnce(),\n+    {\n         // Fast path check\n         if self.is_completed() {\n             return;\n@@ -311,16 +310,17 @@ impl Once {\n     /// INIT.call_once(|| {});\n     /// ```\n     #[unstable(feature = \"once_poison\", issue = \"33577\")]\n-    pub fn call_once_force<F>(&self, f: F) where F: FnOnce(&OnceState) {\n+    pub fn call_once_force<F>(&self, f: F)\n+    where\n+        F: FnOnce(&OnceState),\n+    {\n         // Fast path check\n         if self.is_completed() {\n             return;\n         }\n \n         let mut f = Some(f);\n-        self.call_inner(true, &mut |p| {\n-            f.take().unwrap()(&OnceState { poisoned: p })\n-        });\n+        self.call_inner(true, &mut |p| f.take().unwrap()(&OnceState { poisoned: p }));\n     }\n \n     /// Returns `true` if some `call_once` call has completed\n@@ -385,10 +385,7 @@ impl Once {\n     // currently no way to take an `FnOnce` and call it via virtual dispatch\n     // without some allocation overhead.\n     #[cold]\n-    fn call_inner(&self,\n-                  ignore_poisoning: bool,\n-                  init: &mut dyn FnMut(bool))\n-    {\n+    fn call_inner(&self, ignore_poisoning: bool, init: &mut dyn FnMut(bool)) {\n         let mut state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n         loop {\n             match state_and_queue {\n@@ -397,15 +394,16 @@ impl Once {\n                     // Panic to propagate the poison.\n                     panic!(\"Once instance has previously been poisoned\");\n                 }\n-                POISONED |\n-                INCOMPLETE => {\n+                POISONED | INCOMPLETE => {\n                     // Try to register this thread as the one RUNNING.\n-                    let old = self.state_and_queue.compare_and_swap(state_and_queue,\n-                                                                    RUNNING,\n-                                                                    Ordering::Acquire);\n+                    let old = self.state_and_queue.compare_and_swap(\n+                        state_and_queue,\n+                        RUNNING,\n+                        Ordering::Acquire,\n+                    );\n                     if old != state_and_queue {\n                         state_and_queue = old;\n-                        continue\n+                        continue;\n                     }\n                     // `waiter_queue` will manage other waiting threads, and\n                     // wake them up on drop.\n@@ -417,7 +415,7 @@ impl Once {\n                     // poisoned or not.\n                     init(state_and_queue == POISONED);\n                     waiter_queue.set_state_on_drop_to = COMPLETE;\n-                    break\n+                    break;\n                 }\n                 _ => {\n                     // All other values must be RUNNING with possibly a\n@@ -451,9 +449,7 @@ fn wait(state_and_queue: &AtomicUsize, mut current_state: usize) {\n \n         // Try to slide in the node at the head of the linked list, making sure\n         // that another thread didn't just replace the head of the linked list.\n-        let old = state_and_queue.compare_and_swap(current_state,\n-                                                   me | RUNNING,\n-                                                   Ordering::Release);\n+        let old = state_and_queue.compare_and_swap(current_state, me | RUNNING, Ordering::Release);\n         if old != current_state {\n             current_state = old;\n             continue;\n@@ -485,8 +481,8 @@ impl fmt::Debug for Once {\n impl Drop for WaiterQueue<'_> {\n     fn drop(&mut self) {\n         // Swap out our state with however we finished.\n-        let state_and_queue = self.state_and_queue.swap(self.set_state_on_drop_to,\n-                                                        Ordering::AcqRel);\n+        let state_and_queue =\n+            self.state_and_queue.swap(self.set_state_on_drop_to, Ordering::AcqRel);\n \n         // We should only ever see an old state which was RUNNING.\n         assert_eq!(state_and_queue & STATE_MASK, RUNNING);\n@@ -562,10 +558,10 @@ impl OnceState {\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n+    use super::Once;\n     use crate::panic;\n     use crate::sync::mpsc::channel;\n     use crate::thread;\n-    use super::Once;\n \n     #[test]\n     fn smoke_once() {\n@@ -585,8 +581,10 @@ mod tests {\n         let (tx, rx) = channel();\n         for _ in 0..10 {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n-                for _ in 0..4 { thread::yield_now() }\n+            thread::spawn(move || {\n+                for _ in 0..4 {\n+                    thread::yield_now()\n+                }\n                 unsafe {\n                     O.call_once(|| {\n                         assert!(!RUN);\n@@ -675,6 +673,5 @@ mod tests {\n \n         assert!(t1.join().is_ok());\n         assert!(t2.join().is_ok());\n-\n     }\n }"}]}