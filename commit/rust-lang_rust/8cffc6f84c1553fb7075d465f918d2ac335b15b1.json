{"sha": "8cffc6f84c1553fb7075d465f918d2ac335b15b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZmZjNmY4NGMxNTUzZmI3MDc1ZDQ2NWY5MThkMmFjMzM1YjE1YjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-27T22:05:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-28T14:31:28Z"}, "message": "add debugging mode which emits more verbose info", "tree": {"sha": "45af81cb1ed0306415b39c9346db340fca434124", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45af81cb1ed0306415b39c9346db340fca434124"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cffc6f84c1553fb7075d465f918d2ac335b15b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cffc6f84c1553fb7075d465f918d2ac335b15b1", "html_url": "https://github.com/rust-lang/rust/commit/8cffc6f84c1553fb7075d465f918d2ac335b15b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cffc6f84c1553fb7075d465f918d2ac335b15b1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "324ecb58a7cf6230662d5a20b4abab17d1631957", "url": "https://api.github.com/repos/rust-lang/rust/commits/324ecb58a7cf6230662d5a20b4abab17d1631957", "html_url": "https://github.com/rust-lang/rust/commit/324ecb58a7cf6230662d5a20b4abab17d1631957"}], "stats": {"total": 72, "additions": 59, "deletions": 13}, "files": [{"sha": "8130492cff9958525f948948ab0ee11e8a091f81", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8cffc6f84c1553fb7075d465f918d2ac335b15b1/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cffc6f84c1553fb7075d465f918d2ac335b15b1/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=8cffc6f84c1553fb7075d465f918d2ac335b15b1", "patch": "@@ -7,6 +7,10 @@ Support code for serialization.\n import list::list;\n import ebml::writer;\n \n+// Set to true to generate more debugging in EBML serialization.\n+// Totally lame approach.\n+const debug: bool = true;\n+\n iface serializer {\n     // Primitive types:\n     fn emit_nil();\n@@ -86,7 +90,9 @@ enum ebml_serializer_tag {\n     es_str,\n     es_f64, es_f32, es_float,\n     es_enum, es_enum_vid, es_enum_body,\n-    es_vec, es_vec_len, es_vec_elt\n+    es_vec, es_vec_len, es_vec_elt,\n+\n+    es_label // Used only when debugging\n }\n \n impl of serializer for ebml::writer {\n@@ -98,6 +104,16 @@ impl of serializer for ebml::writer {\n         self.wr_tagged_u32(t as uint, v as u32);\n     }\n \n+    fn _emit_label(label: str) {\n+        // There are various strings that we have access to, such as\n+        // the name of a record field, which do not actually appear in\n+        // the serialized EBML (normally).  This is just for\n+        // efficiency.  When debugging, though, we can emit such\n+        // labels and then they will be checked by deserializer to\n+        // try and check failures more quickly.\n+        if debug { self.wr_tagged_str(es_label as uint, label) }\n+    }\n+\n     fn emit_uint(v: uint) { self.wr_tagged_u64(es_uint as uint, v as u64); }\n     fn emit_u64(v: u64) { self.wr_tagged_u64(es_u64 as uint, v); }\n     fn emit_u32(v: u32) { self.wr_tagged_u32(es_u32 as uint, v); }\n@@ -118,7 +134,8 @@ impl of serializer for ebml::writer {\n \n     fn emit_str(v: str) { self.wr_tagged_str(es_str as uint, v) }\n \n-    fn emit_enum(_name: str, f: fn()) {\n+    fn emit_enum(name: str, f: fn()) {\n+        self._emit_label(name);\n         self.wr_tag(es_enum as uint, f)\n     }\n     fn emit_enum_variant(_v_name: str, v_id: uint, _cnt: uint, f: fn()) {\n@@ -138,14 +155,13 @@ impl of serializer for ebml::writer {\n         self.wr_tag(es_vec_elt as uint, f)\n     }\n \n-    fn emit_vec_elt(_idx: uint, f: fn()) {\n-        self.wr_tag(es_vec_elt as uint, f)\n-    }\n-\n     fn emit_box(f: fn()) { f() }\n     fn emit_uniq(f: fn()) { f() }\n     fn emit_rec(f: fn()) { f() }\n-    fn emit_rec_field(_f_name: str, _f_idx: uint, f: fn()) { f() }\n+    fn emit_rec_field(f_name: str, _f_idx: uint, f: fn()) {\n+        self._emit_label(f_name);\n+        f()\n+    }\n     fn emit_tup(_sz: uint, f: fn()) { f() }\n     fn emit_tup_elt(_idx: uint, f: fn()) { f() }\n }\n@@ -158,7 +174,22 @@ fn mk_ebml_deserializer(d: ebml::doc) -> ebml_deserializer {\n }\n \n impl of deserializer for ebml_deserializer {\n+    fn _check_label(lbl: str) {\n+        if self.pos < self.parent.end {\n+            let {tag: r_tag, doc: r_doc} =\n+                ebml::doc_at(self.parent.data, self.pos);\n+            if r_tag == (es_label as uint) {\n+                self.pos = r_doc.end;\n+                let str = ebml::doc_as_str(r_doc);\n+                if lbl != str {\n+                    fail #fmt[\"Expected label %s but found %s\", lbl, str];\n+                }\n+            }\n+        }\n+    }\n+\n     fn next_doc(exp_tag: ebml_serializer_tag) -> ebml::doc {\n+        #debug[\". next_doc(exp_tag=%?)\", exp_tag];\n         if self.pos >= self.parent.end {\n             fail \"no more documents in current node!\";\n         }\n@@ -231,53 +262,68 @@ impl of deserializer for ebml_deserializer {\n     fn read_str() -> str { ebml::doc_as_str(self.next_doc(es_str)) }\n \n     // Compound types:\n-    fn read_enum<T:copy>(_name: str, f: fn() -> T) -> T {\n+    fn read_enum<T:copy>(name: str, f: fn() -> T) -> T {\n+        #debug[\"read_enum(%s)\", name];\n+        self._check_label(name);\n         self.push_doc(self.next_doc(es_enum), f)\n     }\n \n     fn read_enum_variant<T:copy>(f: fn(uint) -> T) -> T {\n+        #debug[\"read_enum_variant()\"];\n         let idx = self._next_uint(es_enum_vid);\n+        #debug[\"  idx=%u\", idx];\n         self.push_doc(self.next_doc(es_enum_body)) {||\n             f(idx)\n         }\n     }\n \n-    fn read_enum_variant_arg<T:copy>(_idx: uint, f: fn() -> T) -> T {\n+    fn read_enum_variant_arg<T:copy>(idx: uint, f: fn() -> T) -> T {\n+        #debug[\"read_enum_variant_arg(idx=%u)\", idx];\n         f()\n     }\n \n     fn read_vec<T:copy>(f: fn(uint) -> T) -> T {\n+        #debug[\"read_vec()\"];\n         self.push_doc(self.next_doc(es_vec)) {||\n             let len = self._next_uint(es_vec_len);\n+            #debug[\"  len=%u\", len];\n             f(len)\n         }\n     }\n \n-    fn read_vec_elt<T:copy>(_idx: uint, f: fn() -> T) -> T {\n+    fn read_vec_elt<T:copy>(idx: uint, f: fn() -> T) -> T {\n+        #debug[\"read_vec_elt(idx=%u)\", idx];\n         self.push_doc(self.next_doc(es_vec_elt), f)\n     }\n \n     fn read_box<T:copy>(f: fn() -> T) -> T {\n+        #debug[\"read_box()\"];\n         f()\n     }\n \n     fn read_uniq<T:copy>(f: fn() -> T) -> T {\n+        #debug[\"read_uniq()\"];\n         f()\n     }\n \n     fn read_rec<T:copy>(f: fn() -> T) -> T {\n+        #debug[\"read_rec()\"];\n         f()\n     }\n \n-    fn read_rec_field<T:copy>(_f_name: str, _f_idx: uint, f: fn() -> T) -> T {\n+    fn read_rec_field<T:copy>(f_name: str, f_idx: uint, f: fn() -> T) -> T {\n+        #debug[\"read_rec_field(%s, idx=%u)\", f_name, f_idx];\n+        self._check_label(f_name);\n         f()\n     }\n \n-    fn read_tup<T:copy>(_sz: uint, f: fn() -> T) -> T {\n+    fn read_tup<T:copy>(sz: uint, f: fn() -> T) -> T {\n+        #debug[\"read_tup(sz=%u)\", sz];\n         f()\n     }\n \n-    fn read_tup_elt<T:copy>(_idx: uint, f: fn() -> T) -> T {\n+    fn read_tup_elt<T:copy>(idx: uint, f: fn() -> T) -> T {\n+        #debug[\"read_tup_elt(idx=%u)\", idx];\n         f()\n     }\n }"}]}