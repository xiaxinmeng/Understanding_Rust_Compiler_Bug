{"sha": "f2c37a55a4456c4af8b3b3b53cdd4f703a910b29", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYzM3YTU1YTQ0NTZjNGFmOGIzYjNiNTNjZGQ0ZjcwM2E5MTBiMjk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-06-07T18:30:11Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-06-11T13:56:30Z"}, "message": "ci: Collect CPU usage statistics on Azure\n\nThis commit adds a script which we'll execute on Azure Pipelines which\nis intended to run in the background and passively collect CPU usage\nstatistics for our builders. The intention here is that we can use this\ninformation over time to diagnose issues with builders, see where we can\noptimize our build, fix parallelism issues, etc. This might not end up\nbeing too useful in the long run but it's data we've wanted to collect\nfor quite some time now, so here's a stab at it!\n\nComments about how this is intended to work can be found in the python\nscript used here to collect CPU usage statistics.\n\nCloses #48828", "tree": {"sha": "9adad606baf917719fdeed4fa8542bd7d1aa98d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9adad606baf917719fdeed4fa8542bd7d1aa98d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2c37a55a4456c4af8b3b3b53cdd4f703a910b29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2c37a55a4456c4af8b3b3b53cdd4f703a910b29", "html_url": "https://github.com/rust-lang/rust/commit/f2c37a55a4456c4af8b3b3b53cdd4f703a910b29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2c37a55a4456c4af8b3b3b53cdd4f703a910b29/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "817d2feb13dd1faad47ec699cd473b8be2093ec9", "url": "https://api.github.com/repos/rust-lang/rust/commits/817d2feb13dd1faad47ec699cd473b8be2093ec9", "html_url": "https://github.com/rust-lang/rust/commit/817d2feb13dd1faad47ec699cd473b8be2093ec9"}], "stats": {"total": 191, "additions": 191, "deletions": 0}, "files": [{"sha": "38aa022b624db4afce43f649bd05da189b8e7e94", "filename": ".azure-pipelines/steps/run.yml", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f2c37a55a4456c4af8b3b3b53cdd4f703a910b29/.azure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f2c37a55a4456c4af8b3b3b53cdd4f703a910b29/.azure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.azure-pipelines%2Fsteps%2Frun.yml?ref=f2c37a55a4456c4af8b3b3b53cdd4f703a910b29", "patch": "@@ -11,6 +11,12 @@ steps:\n - checkout: self\n   fetchDepth: 2\n \n+# Spawn a background process to collect CPU usage statistics which we'll upload\n+# at the end of the build. See the comments in the script here for more\n+# information.\n+- bash: python src/ci/cpu-usage-over-time.py &> cpu-usage.csv &\n+  displayName: \"Collect CPU-usage statistics in the background\"\n+\n - bash: printenv | sort\n   displayName: Show environment variables\n \n@@ -136,3 +142,13 @@ steps:\n     AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n   condition: and(succeeded(), or(eq(variables.DEPLOY, '1'), eq(variables.DEPLOY_ALT, '1')))\n   displayName: Upload artifacts\n+\n+# Upload CPU usage statistics that we've been gathering this whole time. Always\n+# execute this step in case we want to inspect failed builds, but don't let\n+# errors here ever fail the build since this is just informational.\n+- bash: aws s3 cp --acl public-read cpu-usage.csv s3://$DEPLOY_BUCKET/rustc-builds/$BUILD_SOURCEVERSION/cpu-$SYSTEM_JOBNAME.csv\n+  env:\n+    AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n+  condition: contains(variables, 'AWS_SECRET_ACCESS_KEY')\n+  continueOnError: true\n+  displayName: Upload CPU usage statistics"}, {"sha": "78427a6360a9f7c6546745a4f1b0a646799b6fbb", "filename": "src/ci/cpu-usage-over-time.py", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/f2c37a55a4456c4af8b3b3b53cdd4f703a910b29/src%2Fci%2Fcpu-usage-over-time.py", "raw_url": "https://github.com/rust-lang/rust/raw/f2c37a55a4456c4af8b3b3b53cdd4f703a910b29/src%2Fci%2Fcpu-usage-over-time.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fcpu-usage-over-time.py?ref=f2c37a55a4456c4af8b3b3b53cdd4f703a910b29", "patch": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python\n+# ignore-tidy-linelength\n+\n+# This is a small script that we use on CI to collect CPU usage statistics of\n+# our builders. By seeing graphs of CPU usage over time we hope to correlate\n+# that with possible improvements to Rust's own build system, ideally diagnosing\n+# that either builders are always fully using their CPU resources or they're\n+# idle for long stretches of time.\n+#\n+# This script is relatively simple, but it's platform specific. Each platform\n+# (OSX/Windows/Linux) has a different way of calculating the current state of\n+# CPU at a point in time. We then compare two captured states to determine the\n+# percentage of time spent in one state versus another. The state capturing is\n+# all platform-specific but the loop at the bottom is the cross platform part\n+# that executes everywhere.\n+#\n+# # Viewing statistics\n+#\n+# All builders will upload their CPU statistics as CSV files to our S3 buckets.\n+# These URLS look like:\n+#\n+#   https://$bucket.s3.amazonaws.com/rustc-builds/$commit/cpu-$builder.csv\n+#\n+# for example\n+#\n+#   https://rust-lang-ci2.s3.amazonaws.com/rustc-builds/68baada19cd5340f05f0db15a3e16d6671609bcc/cpu-x86_64-apple.csv\n+#\n+# Each CSV file has two columns. The first is the timestamp of the measurement\n+# and the second column is the % of idle cpu time in that time slice. Ideally\n+# the second column is always zero.\n+#\n+# Once you've downloaded a file there's various ways to plot it and visualize\n+# it. For command line usage you can use a script like so:\n+#\n+#      set timefmt '%Y-%m-%dT%H:%M:%S'\n+#      set xdata time\n+#      set ylabel \"Idle CPU %\"\n+#      set xlabel \"Time\"\n+#      set datafile sep ','\n+#      set term png\n+#      set output \"printme.png\"\n+#      set grid\n+#      builder = \"i686-apple\"\n+#      plot \"cpu-\".builder.\".csv\" using 1:2 with lines title builder\n+#\n+# Executed as `gnuplot < ./foo.plot` it will generate a graph called\n+# `printme.png` which you can then open up. If you know how to improve this\n+# script or the viewing process that would be much appreciated :) (or even if\n+# you know how to automate it!)\n+\n+import datetime\n+import sys\n+import time\n+\n+if sys.platform == 'linux2':\n+    class State:\n+        def __init__(self):\n+            with open('/proc/stat', 'r') as file:\n+                data = file.readline().split()\n+            if data[0] != 'cpu':\n+                raise Exception('did not start with \"cpu\"')\n+            self.user = int(data[1])\n+            self.nice = int(data[2])\n+            self.system = int(data[3])\n+            self.idle = int(data[4])\n+            self.iowait = int(data[5])\n+            self.irq = int(data[6])\n+            self.softirq = int(data[7])\n+            self.steal = int(data[8])\n+            self.guest = int(data[9])\n+            self.guest_nice = int(data[10])\n+\n+        def idle_since(self, prev):\n+            user = self.user - prev.user\n+            nice = self.nice - prev.nice\n+            system = self.system - prev.system\n+            idle = self.idle - prev.idle\n+            iowait = self.iowait - prev.iowait\n+            irq = self.irq - prev.irq\n+            softirq = self.softirq - prev.softirq\n+            steal = self.steal - prev.steal\n+            guest = self.guest - prev.guest\n+            guest_nice = self.guest_nice - prev.guest_nice\n+            total = user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice\n+            return float(idle) / float(total) * 100\n+\n+elif sys.platform == 'win32':\n+    from ctypes.wintypes import DWORD\n+    from ctypes import Structure, windll, WinError, GetLastError, byref\n+\n+    class FILETIME(Structure):\n+        _fields_ = [\n+            (\"dwLowDateTime\", DWORD),\n+            (\"dwHighDateTime\", DWORD),\n+        ]\n+\n+    class State:\n+        def __init__(self):\n+            idle, kernel, user = FILETIME(), FILETIME(), FILETIME()\n+\n+            success = windll.kernel32.GetSystemTimes(\n+                byref(idle),\n+                byref(kernel),\n+                byref(user),\n+            )\n+\n+            assert success, WinError(GetLastError())[1]\n+\n+            self.idle = (idle.dwHighDateTime << 32) | idle.dwLowDateTime\n+            self.kernel = (kernel.dwHighDateTime << 32) | kernel.dwLowDateTime\n+            self.user = (user.dwHighDateTime << 32) | user.dwLowDateTime\n+\n+        def idle_since(self, prev):\n+            idle = self.idle - prev.idle\n+            user = self.user - prev.user\n+            kernel = self.kernel - prev.kernel\n+            return float(idle) / float(user + kernel) * 100\n+\n+elif sys.platform == 'darwin':\n+    from ctypes import *\n+    libc = cdll.LoadLibrary('/usr/lib/libc.dylib')\n+\n+    PROESSOR_CPU_LOAD_INFO = c_int(2)\n+    CPU_STATE_USER = 0\n+    CPU_STATE_SYSTEM = 1\n+    CPU_STATE_IDLE = 2\n+    CPU_STATE_NICE = 3\n+    c_int_p = POINTER(c_int)\n+\n+    class State:\n+        def __init__(self):\n+            num_cpus_u = c_uint(0)\n+            cpu_info = c_int_p()\n+            cpu_info_cnt = c_int(0)\n+            err = libc.host_processor_info(\n+                libc.mach_host_self(),\n+                PROESSOR_CPU_LOAD_INFO,\n+                byref(num_cpus_u),\n+                byref(cpu_info),\n+                byref(cpu_info_cnt),\n+            )\n+            assert err == 0\n+            self.user = 0\n+            self.system = 0\n+            self.idle = 0\n+            self.nice = 0\n+            cur = 0\n+            while cur < cpu_info_cnt.value:\n+                self.user += cpu_info[cur + CPU_STATE_USER]\n+                self.system += cpu_info[cur + CPU_STATE_SYSTEM]\n+                self.idle += cpu_info[cur + CPU_STATE_IDLE]\n+                self.nice += cpu_info[cur + CPU_STATE_NICE]\n+                cur += num_cpus_u.value\n+\n+        def idle_since(self, prev):\n+            user = self.user - prev.user\n+            system = self.system - prev.system\n+            idle = self.idle - prev.idle\n+            nice = self.nice - prev.nice\n+            return float(idle) / float(user + system + idle + nice) * 100.0\n+\n+else:\n+    print('unknown platform', sys.platform)\n+    sys.exit(1)\n+\n+cur_state = State();\n+print(\"Time,Idle\")\n+while True:\n+    time.sleep(1);\n+    next_state = State();\n+    now = datetime.datetime.utcnow().isoformat()\n+    idle = next_state.idle_since(cur_state)\n+    print(\"%s,%s\" % (now, idle))\n+    sys.stdout.flush()\n+    cur_state = next_state"}]}