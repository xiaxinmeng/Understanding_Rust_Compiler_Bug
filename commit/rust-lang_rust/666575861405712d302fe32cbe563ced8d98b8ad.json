{"sha": "666575861405712d302fe32cbe563ced8d98b8ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NjU3NTg2MTQwNTcxMmQzMDJmZTMyY2JlNTYzY2VkOGQ5OGI4YWQ=", "commit": {"author": {"name": "Sean Patrick Santos", "email": "SeanPatrickSantos@gmail.com", "date": "2015-05-04T07:55:16Z"}, "committer": {"name": "Sean Patrick Santos", "email": "SeanPatrickSantos@gmail.com", "date": "2015-05-17T21:30:32Z"}, "message": "Fix issue where trait-associated consts could cause ICEs in match patterns.\n\nThis allows some lookup of trait-associated consts during type-checking,\nwhich may be helpful for future fixes as well.", "tree": {"sha": "662e4be3e70bbead344af67a22d85cdb310ebdd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/662e4be3e70bbead344af67a22d85cdb310ebdd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/666575861405712d302fe32cbe563ced8d98b8ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/666575861405712d302fe32cbe563ced8d98b8ad", "html_url": "https://github.com/rust-lang/rust/commit/666575861405712d302fe32cbe563ced8d98b8ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/666575861405712d302fe32cbe563ced8d98b8ad/comments", "author": {"login": "quantheory", "id": 1740206, "node_id": "MDQ6VXNlcjE3NDAyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1740206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/quantheory", "html_url": "https://github.com/quantheory", "followers_url": "https://api.github.com/users/quantheory/followers", "following_url": "https://api.github.com/users/quantheory/following{/other_user}", "gists_url": "https://api.github.com/users/quantheory/gists{/gist_id}", "starred_url": "https://api.github.com/users/quantheory/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/quantheory/subscriptions", "organizations_url": "https://api.github.com/users/quantheory/orgs", "repos_url": "https://api.github.com/users/quantheory/repos", "events_url": "https://api.github.com/users/quantheory/events{/privacy}", "received_events_url": "https://api.github.com/users/quantheory/received_events", "type": "User", "site_admin": false}, "committer": {"login": "quantheory", "id": 1740206, "node_id": "MDQ6VXNlcjE3NDAyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1740206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/quantheory", "html_url": "https://github.com/quantheory", "followers_url": "https://api.github.com/users/quantheory/followers", "following_url": "https://api.github.com/users/quantheory/following{/other_user}", "gists_url": "https://api.github.com/users/quantheory/gists{/gist_id}", "starred_url": "https://api.github.com/users/quantheory/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/quantheory/subscriptions", "organizations_url": "https://api.github.com/users/quantheory/orgs", "repos_url": "https://api.github.com/users/quantheory/repos", "events_url": "https://api.github.com/users/quantheory/events{/privacy}", "received_events_url": "https://api.github.com/users/quantheory/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbe8066ac39546073b4d76bcb9928cf83886e8b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbe8066ac39546073b4d76bcb9928cf83886e8b2", "html_url": "https://github.com/rust-lang/rust/commit/fbe8066ac39546073b4d76bcb9928cf83886e8b2"}], "stats": {"total": 90, "additions": 75, "deletions": 15}, "files": [{"sha": "4faf46921d8e67fabd95b7ac3258ad93302fc4d3", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/666575861405712d302fe32cbe563ced8d98b8ad/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666575861405712d302fe32cbe563ced8d98b8ad/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=666575861405712d302fe32cbe563ced8d98b8ad", "patch": "@@ -126,8 +126,10 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                         Some(ref_id) => {\n                             let trait_id = ty::trait_of_item(tcx, def_id)\n                                               .unwrap();\n+                            let substs = ty::node_id_item_substs(tcx, ref_id)\n+                                            .substs;\n                             resolve_trait_associated_const(tcx, ti, trait_id,\n-                                                           ref_id)\n+                                                           substs)\n                         }\n                         // Technically, without knowing anything about the\n                         // expression that generates the obligation, we could\n@@ -172,8 +174,10 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                         // a trait-associated const if the caller gives us\n                         // the expression that refers to it.\n                         Some(ref_id) => {\n+                            let substs = ty::node_id_item_substs(tcx, ref_id)\n+                                            .substs;\n                             resolve_trait_associated_const(tcx, ti, trait_id,\n-                                                           ref_id).map(|e| e.id)\n+                                                           substs).map(|e| e.id)\n                         }\n                         None => None\n                     }\n@@ -633,9 +637,23 @@ pub_fn_checked_op!{ const_uint_checked_shr_via_int(a: u64, b: i64,.. UintTy) {\n            uint_shift_body overflowing_shr const_uint ShiftRightWithOverflow\n }}\n \n+// After type checking, `eval_const_expr_partial` should always suffice. The\n+// reason for providing `eval_const_expr_with_substs` is to allow\n+// trait-associated consts to be evaluated *during* type checking, when the\n+// substs for each expression have not been written into `tcx` yet.\n pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      e: &Expr,\n                                      ty_hint: Option<Ty<'tcx>>) -> EvalResult {\n+    eval_const_expr_with_substs(tcx, e, ty_hint, |id| {\n+        ty::node_id_item_substs(tcx, id).substs\n+    })\n+}\n+\n+pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n+                                            e: &Expr,\n+                                            ty_hint: Option<Ty<'tcx>>,\n+                                            get_substs: S) -> EvalResult\n+        where S: Fn(ast::NodeId) -> subst::Substs<'tcx> {\n     fn fromb(b: bool) -> const_val { const_int(b as i64) }\n \n     let ety = ty_hint.or_else(|| ty::expr_ty_opt(tcx, e));\n@@ -826,8 +844,11 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           def::FromTrait(trait_id) => match tcx.map.find(def_id.node) {\n                               Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n                                   ast::ConstTraitItem(ref ty, _) => {\n-                                      (resolve_trait_associated_const(tcx, ti,\n-                                                                      trait_id, e.id),\n+                                      let substs = get_substs(e.id);\n+                                      (resolve_trait_associated_const(tcx,\n+                                                                      ti,\n+                                                                      trait_id,\n+                                                                      substs),\n                                        Some(&**ty))\n                                   }\n                                   _ => (None, None)\n@@ -926,10 +947,9 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                                 ti: &'tcx ast::TraitItem,\n                                                 trait_id: ast::DefId,\n-                                                ref_id: ast::NodeId)\n+                                                rcvr_substs: subst::Substs<'tcx>)\n                                                 -> Option<&'tcx Expr>\n {\n-    let rcvr_substs = ty::node_id_item_substs(tcx, ref_id).substs;\n     let subst::SeparateVecsPerParamSpace {\n         types: rcvr_type,\n         selfs: rcvr_self,\n@@ -1081,19 +1101,21 @@ pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<Ordering> {\n     })\n }\n \n-pub fn compare_lit_exprs<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                               a: &Expr,\n-                               b: &Expr,\n-                               ty_hint: Option<Ty<'tcx>>)\n-                               -> Option<Ordering> {\n-    let a = match eval_const_expr_partial(tcx, a, ty_hint) {\n+pub fn compare_lit_exprs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n+                                  a: &Expr,\n+                                  b: &Expr,\n+                                  ty_hint: Option<Ty<'tcx>>,\n+                                  get_substs: S) -> Option<Ordering>\n+        where S: Fn(ast::NodeId) -> subst::Substs<'tcx> {\n+    let a = match eval_const_expr_with_substs(tcx, a, ty_hint,\n+                                              |id| {get_substs(id)}) {\n         Ok(a) => a,\n         Err(e) => {\n             tcx.sess.span_err(a.span, &e.description());\n             return None;\n         }\n     };\n-    let b = match eval_const_expr_partial(tcx, b, ty_hint) {\n+    let b = match eval_const_expr_with_substs(tcx, b, ty_hint, get_substs) {\n         Ok(b) => b,\n         Err(e) => {\n             tcx.sess.span_err(b.span, &e.description());"}, {"sha": "dd1e9494780e5a853fb23ca2c4696d2f65bf9605", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/666575861405712d302fe32cbe563ced8d98b8ad/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666575861405712d302fe32cbe563ced8d98b8ad/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=666575861405712d302fe32cbe563ced8d98b8ad", "patch": "@@ -233,7 +233,8 @@ struct ConstantExpr<'a>(&'a ast::Expr);\n \n impl<'a> ConstantExpr<'a> {\n     fn eq(self, other: ConstantExpr<'a>, tcx: &ty::ctxt) -> bool {\n-        match const_eval::compare_lit_exprs(tcx, self.0, other.0, None) {\n+        match const_eval::compare_lit_exprs(tcx, self.0, other.0, None,\n+                                            |id| {ty::node_id_item_substs(tcx, id).substs}) {\n             Some(result) => result == Ordering::Equal,\n             None => panic!(\"compare_list_exprs: type mismatch\"),\n         }"}, {"sha": "63470604084f81a912d35bc69ed03c5ea5e18e1e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/666575861405712d302fe32cbe563ced8d98b8ad/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666575861405712d302fe32cbe563ced8d98b8ad/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=666575861405712d302fe32cbe563ced8d98b8ad", "patch": "@@ -98,7 +98,9 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 lhs_eq_rhs && (ty::type_is_numeric(lhs_ty) || ty::type_is_char(lhs_ty));\n \n             if numeric_or_char {\n-                match const_eval::compare_lit_exprs(tcx, &**begin, &**end, Some(lhs_ty)) {\n+                match const_eval::compare_lit_exprs(tcx, &**begin, &**end, Some(lhs_ty),\n+                                                    |id| {fcx.item_substs()[&id].substs\n+                                                             .clone()}) {\n                     Some(Ordering::Less) |\n                     Some(Ordering::Equal) => {}\n                     Some(Ordering::Greater) => {"}, {"sha": "d38ccca689141e3a24f13ee8d4b2ba0f1708a24c", "filename": "src/test/run-pass/associated-const-range-match-patterns.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/666575861405712d302fe32cbe563ced8d98b8ad/src%2Ftest%2Frun-pass%2Fassociated-const-range-match-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666575861405712d302fe32cbe563ced8d98b8ad/src%2Ftest%2Frun-pass%2Fassociated-const-range-match-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-range-match-patterns.rs?ref=666575861405712d302fe32cbe563ced8d98b8ad", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+struct Foo;\n+\n+trait HasNum {\n+    const NUM: isize;\n+}\n+impl HasNum for Foo {\n+    const NUM: isize = 1;\n+}\n+\n+fn main() {\n+    assert!(match 2 {\n+        Foo::NUM ... 3 => true,\n+        _ => false,\n+    });\n+    assert!(match 0 {\n+        -1 ... <Foo as HasNum>::NUM => true,\n+        _ => false,\n+    });\n+    assert!(match 1 {\n+        <Foo as HasNum>::NUM ... <Foo>::NUM => true,\n+        _ => false,\n+    });\n+}"}]}