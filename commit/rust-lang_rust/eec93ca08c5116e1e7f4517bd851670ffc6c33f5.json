{"sha": "eec93ca08c5116e1e7f4517bd851670ffc6c33f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYzkzY2EwOGM1MTE2ZTFlN2Y0NTE3YmQ4NTE2NzBmZmM2YzMzZjU=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-17T23:25:32Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-28T14:06:51Z"}, "message": "Copy `Qualif` to start work on new const validator\n\nThis is an exact copy of the `Qualif` trait from `qualify_consts.rs` and\nits first two implementers, `HasMutInterior` and `NeedsDrop`.", "tree": {"sha": "9f3e0c30b3e55b139925b909b816fbca52a8bb43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f3e0c30b3e55b139925b909b816fbca52a8bb43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eec93ca08c5116e1e7f4517bd851670ffc6c33f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eec93ca08c5116e1e7f4517bd851670ffc6c33f5", "html_url": "https://github.com/rust-lang/rust/commit/eec93ca08c5116e1e7f4517bd851670ffc6c33f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eec93ca08c5116e1e7f4517bd851670ffc6c33f5/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83a3e04ed0ba59a1cdff333d4017019817cbf911", "url": "https://api.github.com/repos/rust-lang/rust/commits/83a3e04ed0ba59a1cdff333d4017019817cbf911", "html_url": "https://github.com/rust-lang/rust/commit/83a3e04ed0ba59a1cdff333d4017019817cbf911"}], "stats": {"total": 271, "additions": 271, "deletions": 0}, "files": [{"sha": "0050a56624bbdc295803247c0f73ac5342c6674b", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/eec93ca08c5116e1e7f4517bd851670ffc6c33f5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec93ca08c5116e1e7f4517bd851670ffc6c33f5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=eec93ca08c5116e1e7f4517bd851670ffc6c33f5", "patch": "@@ -0,0 +1,271 @@\n+/// A \"qualif\"(-ication) is a way to look for something \"bad\" in the MIR that would disqualify some\n+/// code for promotion or prevent it from evaluating at compile time. So `return true` means\n+/// \"I found something bad, no reason to go on searching\". `false` is only returned if we\n+/// definitely cannot find anything bad anywhere.\n+///\n+/// The default implementations proceed structurally.\n+trait Qualif {\n+    const IDX: usize;\n+\n+    /// Return the qualification that is (conservatively) correct for any value\n+    /// of the type, or `None` if the qualification is not value/type-based.\n+    fn in_any_value_of_ty(_cx: &ConstCx<'_, 'tcx>, _ty: Ty<'tcx>) -> Option<bool> {\n+        None\n+    }\n+\n+    /// Return a mask for the qualification, given a type. This is `false` iff\n+    /// no value of that type can have the qualification.\n+    fn mask_for_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+        Self::in_any_value_of_ty(cx, ty).unwrap_or(true)\n+    }\n+\n+    fn in_local(cx: &ConstCx<'_, '_>, local: Local) -> bool {\n+        cx.per_local.0[Self::IDX].contains(local)\n+    }\n+\n+    fn in_static(_cx: &ConstCx<'_, 'tcx>, _static: &Static<'tcx>) -> bool {\n+        // FIXME(eddyb) should we do anything here for value properties?\n+        false\n+    }\n+\n+    fn in_projection_structurally(\n+        cx: &ConstCx<'_, 'tcx>,\n+        place: PlaceRef<'_, 'tcx>,\n+    ) -> bool {\n+        if let [proj_base @ .., elem] = place.projection {\n+            let base_qualif = Self::in_place(cx, PlaceRef {\n+                base: place.base,\n+                projection: proj_base,\n+            });\n+            let qualif = base_qualif && Self::mask_for_ty(\n+                cx,\n+                Place::ty_from(place.base, proj_base, cx.body, cx.tcx)\n+                    .projection_ty(cx.tcx, elem)\n+                    .ty,\n+            );\n+            match elem {\n+                ProjectionElem::Deref |\n+                ProjectionElem::Subslice { .. } |\n+                ProjectionElem::Field(..) |\n+                ProjectionElem::ConstantIndex { .. } |\n+                ProjectionElem::Downcast(..) => qualif,\n+\n+                ProjectionElem::Index(local) => qualif || Self::in_local(cx, *local),\n+            }\n+        } else {\n+            bug!(\"This should be called if projection is not empty\");\n+        }\n+    }\n+\n+    fn in_projection(\n+        cx: &ConstCx<'_, 'tcx>,\n+        place: PlaceRef<'_, 'tcx>,\n+    ) -> bool {\n+        Self::in_projection_structurally(cx, place)\n+    }\n+\n+    fn in_place(cx: &ConstCx<'_, 'tcx>, place: PlaceRef<'_, 'tcx>) -> bool {\n+        match place {\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: [],\n+            } => Self::in_local(cx, *local),\n+            PlaceRef {\n+                base: PlaceBase::Static(box Static {\n+                    kind: StaticKind::Promoted(..),\n+                    ..\n+                }),\n+                projection: [],\n+            } => bug!(\"qualifying already promoted MIR\"),\n+            PlaceRef {\n+                base: PlaceBase::Static(static_),\n+                projection: [],\n+            } => {\n+                Self::in_static(cx, static_)\n+            },\n+            PlaceRef {\n+                base: _,\n+                projection: [.., _],\n+            } => Self::in_projection(cx, place),\n+        }\n+    }\n+\n+    fn in_operand(cx: &ConstCx<'_, 'tcx>, operand: &Operand<'tcx>) -> bool {\n+        match *operand {\n+            Operand::Copy(ref place) |\n+            Operand::Move(ref place) => Self::in_place(cx, place.as_ref()),\n+\n+            Operand::Constant(ref constant) => {\n+                if let ConstValue::Unevaluated(def_id, _) = constant.literal.val {\n+                    // Don't peek inside trait associated constants.\n+                    if cx.tcx.trait_of_item(def_id).is_some() {\n+                        Self::in_any_value_of_ty(cx, constant.literal.ty).unwrap_or(false)\n+                    } else {\n+                        let (bits, _) = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n+\n+                        let qualif = PerQualif::decode_from_bits(bits).0[Self::IDX];\n+\n+                        // Just in case the type is more specific than\n+                        // the definition, e.g., impl associated const\n+                        // with type parameters, take it into account.\n+                        qualif && Self::mask_for_ty(cx, constant.literal.ty)\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+        }\n+    }\n+\n+    fn in_rvalue_structurally(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+        match *rvalue {\n+            Rvalue::NullaryOp(..) => false,\n+\n+            Rvalue::Discriminant(ref place) |\n+            Rvalue::Len(ref place) => Self::in_place(cx, place.as_ref()),\n+\n+            Rvalue::Use(ref operand) |\n+            Rvalue::Repeat(ref operand, _) |\n+            Rvalue::UnaryOp(_, ref operand) |\n+            Rvalue::Cast(_, ref operand, _) => Self::in_operand(cx, operand),\n+\n+            Rvalue::BinaryOp(_, ref lhs, ref rhs) |\n+            Rvalue::CheckedBinaryOp(_, ref lhs, ref rhs) => {\n+                Self::in_operand(cx, lhs) || Self::in_operand(cx, rhs)\n+            }\n+\n+            Rvalue::Ref(_, _, ref place) => {\n+                // Special-case reborrows to be more like a copy of the reference.\n+                if let box [proj_base @ .., elem] = &place.projection {\n+                    if ProjectionElem::Deref == *elem {\n+                        let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n+                        if let ty::Ref(..) = base_ty.sty {\n+                            return Self::in_place(cx, PlaceRef {\n+                                base: &place.base,\n+                                projection: proj_base,\n+                            });\n+                        }\n+                    }\n+                }\n+\n+                Self::in_place(cx, place.as_ref())\n+            }\n+\n+            Rvalue::Aggregate(_, ref operands) => {\n+                operands.iter().any(|o| Self::in_operand(cx, o))\n+            }\n+        }\n+    }\n+\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+        Self::in_rvalue_structurally(cx, rvalue)\n+    }\n+\n+    fn in_call(\n+        cx: &ConstCx<'_, 'tcx>,\n+        _callee: &Operand<'tcx>,\n+        _args: &[Operand<'tcx>],\n+        return_ty: Ty<'tcx>,\n+    ) -> bool {\n+        // Be conservative about the returned value of a const fn.\n+        Self::in_any_value_of_ty(cx, return_ty).unwrap_or(false)\n+    }\n+\n+    fn in_value(cx: &ConstCx<'_, 'tcx>, source: ValueSource<'_, 'tcx>) -> bool {\n+        match source {\n+            ValueSource::Rvalue(rvalue) => Self::in_rvalue(cx, rvalue),\n+            ValueSource::DropAndReplace(source) => Self::in_operand(cx, source),\n+            ValueSource::Call { callee, args, return_ty } => {\n+                Self::in_call(cx, callee, args, return_ty)\n+            }\n+        }\n+    }\n+}\n+\n+/// Constant containing interior mutability (`UnsafeCell<T>`).\n+/// This must be ruled out to make sure that evaluating the constant at compile-time\n+/// and at *any point* during the run-time would produce the same result. In particular,\n+/// promotion of temporaries must not change program behavior; if the promoted could be\n+/// written to, that would be a problem.\n+struct HasMutInterior;\n+\n+impl Qualif for HasMutInterior {\n+    const IDX: usize = 0;\n+\n+    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> Option<bool> {\n+        Some(!ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP))\n+    }\n+\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+        match *rvalue {\n+            // Returning `true` for `Rvalue::Ref` indicates the borrow isn't\n+            // allowed in constants (and the `Checker` will error), and/or it\n+            // won't be promoted, due to `&mut ...` or interior mutability.\n+            Rvalue::Ref(_, kind, ref place) => {\n+                let ty = place.ty(cx.body, cx.tcx).ty;\n+\n+                if let BorrowKind::Mut { .. } = kind {\n+                    // In theory, any zero-sized value could be borrowed\n+                    // mutably without consequences. However, only &mut []\n+                    // is allowed right now, and only in functions.\n+                    if cx.mode == Mode::StaticMut {\n+                        // Inside a `static mut`, &mut [...] is also allowed.\n+                        match ty.sty {\n+                            ty::Array(..) | ty::Slice(_) => {}\n+                            _ => return true,\n+                        }\n+                    } else if let ty::Array(_, len) = ty.sty {\n+                        // FIXME(eddyb) the `cx.mode == Mode::NonConstFn` condition\n+                        // seems unnecessary, given that this is merely a ZST.\n+                        match len.try_eval_usize(cx.tcx, cx.param_env) {\n+                            Some(0) if cx.mode == Mode::NonConstFn => {},\n+                            _ => return true,\n+                        }\n+                    } else {\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            Rvalue::Aggregate(ref kind, _) => {\n+                if let AggregateKind::Adt(def, ..) = **kind {\n+                    if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {\n+                        let ty = rvalue.ty(cx.body, cx.tcx);\n+                        assert_eq!(Self::in_any_value_of_ty(cx, ty), Some(true));\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+\n+        Self::in_rvalue_structurally(cx, rvalue)\n+    }\n+}\n+\n+/// Constant containing an ADT that implements `Drop`.\n+/// This must be ruled out (a) because we cannot run `Drop` during compile-time\n+/// as that might not be a `const fn`, and (b) because implicit promotion would\n+/// remove side-effects that occur as part of dropping that value.\n+struct NeedsDrop;\n+\n+impl Qualif for NeedsDrop {\n+    const IDX: usize = 1;\n+\n+    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> Option<bool> {\n+        Some(ty.needs_drop(cx.tcx, cx.param_env))\n+    }\n+\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+        if let Rvalue::Aggregate(ref kind, _) = *rvalue {\n+            if let AggregateKind::Adt(def, ..) = **kind {\n+                if def.has_dtor(cx.tcx) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        Self::in_rvalue_structurally(cx, rvalue)\n+    }\n+}"}]}