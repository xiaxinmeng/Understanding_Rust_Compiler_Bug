{"sha": "e7cc021189f1d18974057d60223bdbb5abd4dc15", "node_id": "C_kwDOAAsO6NoAKGU3Y2MwMjExODlmMWQxODk3NDA1N2Q2MDIyM2JkYmI1YWJkNGRjMTU", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-06-25T04:00:20Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-10-29T15:55:01Z"}, "message": "Fix casts", "tree": {"sha": "a5b8829715b9fd88ac2e75cad9834ac032baeab9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5b8829715b9fd88ac2e75cad9834ac032baeab9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7cc021189f1d18974057d60223bdbb5abd4dc15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7cc021189f1d18974057d60223bdbb5abd4dc15", "html_url": "https://github.com/rust-lang/rust/commit/e7cc021189f1d18974057d60223bdbb5abd4dc15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7cc021189f1d18974057d60223bdbb5abd4dc15/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da25087f790e9c15fcf633a39e5de307608c9251", "url": "https://api.github.com/repos/rust-lang/rust/commits/da25087f790e9c15fcf633a39e5de307608c9251", "html_url": "https://github.com/rust-lang/rust/commit/da25087f790e9c15fcf633a39e5de307608c9251"}], "stats": {"total": 226, "additions": 115, "deletions": 111}, "files": [{"sha": "ddcc786afa445b3b437f97fc1b22a1aab416c565", "filename": "crates/core_simd/src/cast.rs", "status": "modified", "additions": 54, "deletions": 104, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc021189f1d18974057d60223bdbb5abd4dc15/crates%2Fcore_simd%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc021189f1d18974057d60223bdbb5abd4dc15/crates%2Fcore_simd%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcast.rs?ref=e7cc021189f1d18974057d60223bdbb5abd4dc15", "patch": "@@ -1,129 +1,79 @@\n use crate::simd::{intrinsics, LaneCount, Simd, SimdElement, SupportedLaneCount};\n \n /// Supporting trait for `Simd::cast`.  Typically doesn't need to be used directly.\n-pub trait SimdCast<Target: SimdElement>: SimdElement {\n+pub unsafe trait SimdCast<Target: SimdElement>: SimdElement {\n     #[doc(hidden)]\n     fn cast<const LANES: usize>(x: Simd<Self, LANES>) -> Simd<Target, LANES>\n     where\n-        LaneCount<LANES>: SupportedLaneCount;\n+        LaneCount<LANES>: SupportedLaneCount,\n+    {\n+        // Safety: implementing this trait indicates that the types are supported by `simd_as`\n+        unsafe { intrinsics::simd_as(x) }\n+    }\n+\n+    #[doc(hidden)]\n+    unsafe fn cast_unchecked<const LANES: usize>(x: Simd<Self, LANES>) -> Simd<Target, LANES>\n+    where\n+        LaneCount<LANES>: SupportedLaneCount,\n+    {\n+        // Safety: implementing this trait indicates that the types are supported by `simd_cast`\n+        // The caller is responsible for the conversion invariants.\n+        unsafe { intrinsics::simd_cast(x) }\n+    }\n }\n \n macro_rules! into_number {\n-    { $from:ty, $to:ty } => {\n-        impl SimdCast<$to> for $from {\n-            fn cast<const LANES: usize>(x: Simd<Self, LANES>) -> Simd<$to, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                // Safety: simd_as can handle numeric conversions\n-                unsafe { intrinsics::simd_as(x) }\n-            }\n-        }\n+    { unsafe $from:ty as $to:ty } => {\n+        // Safety: casting between numbers is supported by `simd_cast` and `simd_as`\n+        unsafe impl SimdCast<$to> for $from {}\n     };\n-    { $($type:ty),* } => {\n+    { unsafe $($type:ty),* } => {\n         $(\n-        into_number! { $type, i8 }\n-        into_number! { $type, i16 }\n-        into_number! { $type, i32 }\n-        into_number! { $type, i64 }\n-        into_number! { $type, isize }\n+        into_number! { unsafe $type as i8 }\n+        into_number! { unsafe $type as i16 }\n+        into_number! { unsafe $type as i32 }\n+        into_number! { unsafe $type as i64 }\n+        into_number! { unsafe $type as isize }\n \n-        into_number! { $type, u8 }\n-        into_number! { $type, u16 }\n-        into_number! { $type, u32 }\n-        into_number! { $type, u64 }\n-        into_number! { $type, usize }\n+        into_number! { unsafe $type as u8 }\n+        into_number! { unsafe $type as u16 }\n+        into_number! { unsafe $type as u32 }\n+        into_number! { unsafe $type as u64 }\n+        into_number! { unsafe $type as usize }\n \n-        into_number! { $type, f32 }\n-        into_number! { $type, f64 }\n+        into_number! { unsafe $type as f32 }\n+        into_number! { unsafe $type as f64 }\n         )*\n     }\n }\n \n-into_number! { i8, i16, i32, i64, isize, u8, u16, u32, u64, usize, f32, f64 }\n+into_number! { unsafe i8, i16, i32, i64, isize, u8, u16, u32, u64, usize, f32, f64 }\n \n+// TODO uncomment pending PR to rustc\n+/*\n macro_rules! into_pointer {\n-    { $($type:ty),* } => {\n+    { unsafe $($type:ty),* } => {\n         $(\n-        impl<T> SimdCast<$type> for *const T {\n-            fn cast<const LANES: usize>(x: Simd<Self, LANES>) -> Simd<$type, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                // Safety: transmuting isize to pointers is safe\n-                let x: Simd<isize, LANES> = unsafe { core::mem::transmute_copy(&x) };\n-                x.cast()\n-            }\n-        }\n-        impl<T> SimdCast<$type> for *mut T {\n-            fn cast<const LANES: usize>(x: Simd<Self, LANES>) -> Simd<$type, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                // Safety: transmuting isize to pointers is safe\n-                let x: Simd<isize, LANES> = unsafe { core::mem::transmute_copy(&x) };\n-                x.cast()\n-            }\n-        }\n-        impl<T> SimdCast<*const T> for $type {\n-            fn cast<const LANES: usize>(x: Simd<$type, LANES>) -> Simd<*const T, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                let x: Simd<isize, LANES> = x.cast();\n-                // Safety: transmuting isize to pointers is safe\n-                unsafe { core::mem::transmute_copy(&x) }\n-            }\n-        }\n-        impl<T> SimdCast<*mut T> for $type {\n-            fn cast<const LANES: usize>(x: Simd<$type, LANES>) -> Simd<*mut T, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                let x: Simd<isize, LANES> = x.cast();\n-                // Safety: transmuting isize to pointers is safe\n-                unsafe { core::mem::transmute_copy(&x) }\n-            }\n-        }\n+        // Safety: casting between numbers and pointers is supported by `simd_cast` and `simd_as`\n+        unsafe impl<T> SimdCast<$type> for *const T {}\n+        // Safety: casting between numbers and pointers is supported by `simd_cast` and `simd_as`\n+        unsafe impl<T> SimdCast<$type> for *mut T {}\n+        // Safety: casting between numbers and pointers is supported by `simd_cast` and `simd_as`\n+        unsafe impl<T> SimdCast<*const T> for $type {}\n+        // Safety: casting between numbers and pointers is supported by `simd_cast` and `simd_as`\n+        unsafe impl<T> SimdCast<*mut T> for $type {}\n         )*\n     }\n }\n \n-into_pointer! { i8, i16, i32, i64, isize, u8, u16, u32, u64, usize }\n+into_pointer! { unsafe i8, i16, i32, i64, isize, u8, u16, u32, u64, usize }\n \n-impl<T, U> SimdCast<*const T> for *const U {\n-    fn cast<const LANES: usize>(x: Simd<*const U, LANES>) -> Simd<*const T, LANES>\n-    where\n-        LaneCount<LANES>: SupportedLaneCount,\n-    {\n-        // Safety: transmuting pointers is safe\n-        unsafe { core::mem::transmute_copy(&x) }\n-    }\n-}\n-impl<T, U> SimdCast<*const T> for *mut U {\n-    fn cast<const LANES: usize>(x: Simd<*mut U, LANES>) -> Simd<*const T, LANES>\n-    where\n-        LaneCount<LANES>: SupportedLaneCount,\n-    {\n-        // Safety: transmuting pointers is safe\n-        unsafe { core::mem::transmute_copy(&x) }\n-    }\n-}\n-impl<T, U> SimdCast<*mut T> for *const U {\n-    fn cast<const LANES: usize>(x: Simd<*const U, LANES>) -> Simd<*mut T, LANES>\n-    where\n-        LaneCount<LANES>: SupportedLaneCount,\n-    {\n-        // Safety: transmuting pointers is safe\n-        unsafe { core::mem::transmute_copy(&x) }\n-    }\n-}\n-impl<T, U> SimdCast<*mut T> for *mut U {\n-    fn cast<const LANES: usize>(x: Simd<*mut U, LANES>) -> Simd<*mut T, LANES>\n-    where\n-        LaneCount<LANES>: SupportedLaneCount,\n-    {\n-        // Safety: transmuting pointers is safe\n-        unsafe { core::mem::transmute_copy(&x) }\n-    }\n-}\n+// Safety: casting between pointers is supported by `simd_cast` and `simd_as`\n+unsafe impl<T, U> SimdCast<*const T> for *const U {}\n+// Safety: casting between pointers is supported by `simd_cast` and `simd_as`\n+unsafe impl<T, U> SimdCast<*const T> for *mut U {}\n+// Safety: casting between pointers is supported by `simd_cast` and `simd_as`\n+unsafe impl<T, U> SimdCast<*mut T> for *const U {}\n+// Safety: casting between pointers is supported by `simd_cast` and `simd_as`\n+unsafe impl<T, U> SimdCast<*mut T> for *mut U {}\n+*/"}, {"sha": "5a5faad23c81d0fc0741e974628ca107145d1ffd", "filename": "crates/core_simd/src/elements/const_ptr.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc021189f1d18974057d60223bdbb5abd4dc15/crates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc021189f1d18974057d60223bdbb5abd4dc15/crates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs?ref=e7cc021189f1d18974057d60223bdbb5abd4dc15", "patch": "@@ -23,9 +23,23 @@ pub trait SimdConstPtr: Copy + Sealed {\n \n     /// Gets the \"address\" portion of the pointer.\n     ///\n+    /// This method discards pointer semantic metadata, so the result cannot be\n+    /// directly cast into a valid pointer.\n+    ///\n+    /// This method semantically discards *provenance* and\n+    /// *address-space* information. To properly restore that information, use [`with_addr`].\n+    ///\n     /// Equivalent to calling [`pointer::addr`] on each lane.\n     fn addr(self) -> Self::Usize;\n \n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This performs the same operation as a cast, but copies the *address-space* and\n+    /// *provenance* of `self` to the new pointer.\n+    ///\n+    /// Equivalent to calling [`pointer::with_addr`] on each lane.\n+    fn with_addr(self, addr: Self::Usize) -> Self;\n+\n     /// Calculates the offset from a pointer using wrapping arithmetic.\n     ///\n     /// Equivalent to calling [`pointer::wrapping_offset`] on each lane.\n@@ -63,12 +77,27 @@ where\n \n     #[inline]\n     fn as_mut(self) -> Self::MutPtr {\n-        self.cast()\n+        unimplemented!()\n+        //self.cast()\n     }\n \n     #[inline]\n     fn addr(self) -> Self::Usize {\n-        self.cast()\n+        // Safety: Since `addr` discards provenance, this is safe.\n+        unsafe { core::mem::transmute_copy(&self) }\n+\n+        //TODO switch to casts when available\n+        //self.cast()\n+    }\n+\n+    #[inline]\n+    fn with_addr(self, addr: Self::Usize) -> Self {\n+        unimplemented!()\n+        /*\n+        self.cast::<*const u8>()\n+            .wrapping_offset(addr.cast::<isize>() - self.addr().cast::<isize>())\n+            .cast()\n+        */\n     }\n \n     #[inline]"}, {"sha": "d7b05af0eac5db4328fd6623c435cc52ff63727f", "filename": "crates/core_simd/src/elements/mut_ptr.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc021189f1d18974057d60223bdbb5abd4dc15/crates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc021189f1d18974057d60223bdbb5abd4dc15/crates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs?ref=e7cc021189f1d18974057d60223bdbb5abd4dc15", "patch": "@@ -23,9 +23,20 @@ pub trait SimdMutPtr: Copy + Sealed {\n \n     /// Gets the \"address\" portion of the pointer.\n     ///\n+    /// This method discards pointer semantic metadata, so the result cannot be\n+    /// directly cast into a valid pointer.\n+    ///\n     /// Equivalent to calling [`pointer::addr`] on each lane.\n     fn addr(self) -> Self::Usize;\n \n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This performs the same operation as a cast, but copies the *address-space* and\n+    /// *provenance* of `self` to the new pointer.\n+    ///\n+    /// Equivalent to calling [`pointer::with_addr`] on each lane.\n+    fn with_addr(self, addr: Self::Usize) -> Self;\n+\n     /// Calculates the offset from a pointer using wrapping arithmetic.\n     ///\n     /// Equivalent to calling [`pointer::wrapping_offset`] on each lane.\n@@ -61,12 +72,27 @@ where\n \n     #[inline]\n     fn as_const(self) -> Self::ConstPtr {\n-        self.cast()\n+        unimplemented!()\n+        //self.cast()\n     }\n \n     #[inline]\n     fn addr(self) -> Self::Usize {\n-        self.cast()\n+        // Safety: Since `addr` discards provenance, this is safe.\n+        unsafe { core::mem::transmute_copy(&self) }\n+\n+        //TODO switch to casts when available\n+        //self.cast()\n+    }\n+\n+    #[inline]\n+    fn with_addr(self, addr: Self::Usize) -> Self {\n+        unimplemented!()\n+        /*\n+        self.cast::<*mut u8>()\n+            .wrapping_offset(addr.cast::<isize>() - self.addr().cast::<isize>())\n+            .cast()\n+        */\n     }\n \n     #[inline]"}, {"sha": "3987b7a747b65783675a36285f55a78f17aaa5c7", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7cc021189f1d18974057d60223bdbb5abd4dc15/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7cc021189f1d18974057d60223bdbb5abd4dc15/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=e7cc021189f1d18974057d60223bdbb5abd4dc15", "patch": "@@ -237,9 +237,8 @@ where\n         T: core::convert::FloatToInt<I> + SimdCast<I>,\n         I: SimdElement,\n     {\n-        // Safety: `self` is a vector, and `FloatToInt` ensures the type can be casted to\n-        // an integer.\n-        unsafe { intrinsics::simd_cast(self) }\n+        // Safety: the caller is responsible for the invariants\n+        unsafe { SimdCast::cast_unchecked(self) }\n     }\n \n     /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector."}]}