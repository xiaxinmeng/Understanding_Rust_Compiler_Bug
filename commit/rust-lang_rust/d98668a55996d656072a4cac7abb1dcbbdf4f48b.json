{"sha": "d98668a55996d656072a4cac7abb1dcbbdf4f48b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ODY2OGE1NTk5NmQ2NTYwNzJhNGNhYzdhYmIxZGNiYmRmNGY0OGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-15T23:21:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-15T23:21:28Z"}, "message": "auto merge of #12235 : huonw/rust/raii-lock, r=alexcrichton\n\n- adds a `LockGuard` type returned by `.lock` and `.trylock` that unlocks the mutex in the destructor\r\n- renames `mutex::Mutex` to `StaticNativeMutex` \r\n- adds a `NativeMutex` type with a destructor\r\n- removes `LittleLock`\r\n- adds `#[must_use]` to `sync::mutex::Guard` to remind people to use it", "tree": {"sha": "9480a773995df199411254f148e321b64cd24556", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9480a773995df199411254f148e321b64cd24556"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d98668a55996d656072a4cac7abb1dcbbdf4f48b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d98668a55996d656072a4cac7abb1dcbbdf4f48b", "html_url": "https://github.com/rust-lang/rust/commit/d98668a55996d656072a4cac7abb1dcbbdf4f48b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d98668a55996d656072a4cac7abb1dcbbdf4f48b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b025c803c72d610c2ad4c950151b0d23782d114", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b025c803c72d610c2ad4c950151b0d23782d114", "html_url": "https://github.com/rust-lang/rust/commit/6b025c803c72d610c2ad4c950151b0d23782d114"}, {"sha": "4668cdf3c4788e4a67f1b7dea0eb2d661ac05a49", "url": "https://api.github.com/repos/rust-lang/rust/commits/4668cdf3c4788e4a67f1b7dea0eb2d661ac05a49", "html_url": "https://github.com/rust-lang/rust/commit/4668cdf3c4788e4a67f1b7dea0eb2d661ac05a49"}], "stats": {"total": 557, "additions": 334, "deletions": 223}, "files": [{"sha": "ad32ba7ba6d1c8ff5dda82bef37ab754a4da3d7b", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -15,7 +15,7 @@ use std::rt::rtio::{RemoteCallback, PausableIdleCallback, Callback, EventLoop};\n use std::rt::task::BlockedTask;\n use std::rt::task::Task;\n use std::sync::deque;\n-use std::unstable::mutex::Mutex;\n+use std::unstable::mutex::NativeMutex;\n use std::unstable::raw;\n \n use TaskState;\n@@ -669,8 +669,7 @@ impl Scheduler {\n         // is acquired here. This is the resumption points and the \"bounce\"\n         // that it is referring to.\n         unsafe {\n-            current_task.nasty_deschedule_lock.lock();\n-            current_task.nasty_deschedule_lock.unlock();\n+            let _guard = current_task.nasty_deschedule_lock.lock();\n         }\n         return current_task;\n     }\n@@ -765,10 +764,11 @@ impl Scheduler {\n         // to it, but we're guaranteed that the task won't exit until we've\n         // unlocked the lock so there's no worry of this memory going away.\n         let cur = self.change_task_context(cur, next, |sched, mut task| {\n-            let lock: *mut Mutex = &mut task.nasty_deschedule_lock;\n-            unsafe { (*lock).lock() }\n-            f(sched, BlockedTask::block(task.swap()));\n-            unsafe { (*lock).unlock() }\n+            let lock: *mut NativeMutex = &mut task.nasty_deschedule_lock;\n+            unsafe {\n+                let _guard = (*lock).lock();\n+                f(sched, BlockedTask::block(task.swap()));\n+            }\n         });\n         cur.put();\n     }\n@@ -1453,8 +1453,8 @@ mod test {\n \n     #[test]\n     fn test_spawn_sched_blocking() {\n-        use std::unstable::mutex::{Mutex, MUTEX_INIT};\n-        static mut LOCK: Mutex = MUTEX_INIT;\n+        use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n         // Testing that a task in one scheduler can block in foreign code\n         // without affecting other schedulers\n@@ -1466,12 +1466,11 @@ mod test {\n             let mut handle = pool.spawn_sched();\n             handle.send(PinnedTask(pool.task(TaskOpts::new(), proc() {\n                 unsafe {\n-                    LOCK.lock();\n+                    let mut guard = LOCK.lock();\n \n                     start_ch.send(());\n-                    LOCK.wait();   // block the scheduler thread\n-                    LOCK.signal(); // let them know we have the lock\n-                    LOCK.unlock();\n+                    guard.wait();   // block the scheduler thread\n+                    guard.signal(); // let them know we have the lock\n                 }\n \n                 fin_ch.send(());\n@@ -1503,10 +1502,9 @@ mod test {\n                 child_ch.send(20);\n                 pingpong(&parent_po, &child_ch);\n                 unsafe {\n-                    LOCK.lock();\n-                    LOCK.signal();   // wakeup waiting scheduler\n-                    LOCK.wait();     // wait for them to grab the lock\n-                    LOCK.unlock();\n+                    let mut guard = LOCK.lock();\n+                    guard.signal();   // wakeup waiting scheduler\n+                    guard.wait();     // wait for them to grab the lock\n                 }\n             })));\n             drop(handle);"}, {"sha": "297c22e2cd6ced672f32ad3b602f95e2dca48387", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -17,10 +17,10 @@ use std::rt::local::Local;\n use std::rt::rtio;\n use std::rt::task::{Task, BlockedTask};\n use std::task::TaskOpts;\n-use std::unstable::sync::LittleLock;\n+use std::unstable::mutex::NativeMutex;\n \n struct SimpleTask {\n-    lock: LittleLock,\n+    lock: NativeMutex,\n     awoken: bool,\n }\n \n@@ -59,9 +59,9 @@ impl Runtime for SimpleTask {\n         to_wake.put_runtime(self as ~Runtime);\n         unsafe {\n             cast::forget(to_wake);\n-            let _l = (*me).lock.lock();\n+            let mut guard = (*me).lock.lock();\n             (*me).awoken = true;\n-            (*me).lock.signal();\n+            guard.signal();\n         }\n     }\n \n@@ -83,7 +83,7 @@ impl Runtime for SimpleTask {\n pub fn task() -> ~Task {\n     let mut task = ~Task::new();\n     task.put_runtime(~SimpleTask {\n-        lock: LittleLock::new(),\n+        lock: unsafe {NativeMutex::new()},\n         awoken: false,\n     } as ~Runtime);\n     return task;"}, {"sha": "74d93b4b2db9aadafb90f903f814eff381cc8263", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -25,7 +25,7 @@ use std::rt::local::Local;\n use std::rt::rtio;\n use std::rt::task::{Task, BlockedTask, SendMessage};\n use std::task::TaskOpts;\n-use std::unstable::mutex::Mutex;\n+use std::unstable::mutex::NativeMutex;\n use std::unstable::raw;\n \n use context::Context;\n@@ -65,7 +65,7 @@ pub struct GreenTask {\n     pool_id: uint,\n \n     // See the comments in the scheduler about why this is necessary\n-    nasty_deschedule_lock: Mutex,\n+    nasty_deschedule_lock: NativeMutex,\n }\n \n pub enum TaskType {\n@@ -163,7 +163,7 @@ impl GreenTask {\n             task_type: task_type,\n             sched: None,\n             handle: None,\n-            nasty_deschedule_lock: unsafe { Mutex::new() },\n+            nasty_deschedule_lock: unsafe { NativeMutex::new() },\n             task: Some(~Task::new()),\n         }\n     }\n@@ -322,11 +322,10 @@ impl GreenTask {\n     // uncontended except for when the task is rescheduled).\n     fn reawaken_remotely(mut ~self) {\n         unsafe {\n-            let mtx = &mut self.nasty_deschedule_lock as *mut Mutex;\n+            let mtx = &mut self.nasty_deschedule_lock as *mut NativeMutex;\n             let handle = self.handle.get_mut_ref() as *mut SchedHandle;\n-            (*mtx).lock();\n+            let _guard = (*mtx).lock();\n             (*handle).send(RunOnce(self));\n-            (*mtx).unlock();\n         }\n     }\n }\n@@ -479,12 +478,6 @@ impl Runtime for GreenTask {\n     fn wrap(~self) -> ~Any { self as ~Any }\n }\n \n-impl Drop for GreenTask {\n-    fn drop(&mut self) {\n-        unsafe { self.nasty_deschedule_lock.destroy(); }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use std::rt::Runtime;"}, {"sha": "b1addc5cda53136f516e35719cb49fd53fe9e170", "filename": "src/libnative/bookkeeping.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibnative%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibnative%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fbookkeeping.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -17,10 +17,10 @@\n //! The green counterpart for this is bookkeeping on sched pools.\n \n use std::sync::atomics;\n-use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n static mut TASK_COUNT: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n-static mut TASK_LOCK: Mutex = MUTEX_INIT;\n+static mut TASK_LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n pub fn increment() {\n     let _ = unsafe { TASK_COUNT.fetch_add(1, atomics::SeqCst) };\n@@ -29,9 +29,8 @@ pub fn increment() {\n pub fn decrement() {\n     unsafe {\n         if TASK_COUNT.fetch_sub(1, atomics::SeqCst) == 1 {\n-            TASK_LOCK.lock();\n-            TASK_LOCK.signal();\n-            TASK_LOCK.unlock();\n+            let mut guard = TASK_LOCK.lock();\n+            guard.signal();\n         }\n     }\n }\n@@ -40,11 +39,12 @@ pub fn decrement() {\n /// the entry points of native programs\n pub fn wait_for_other_tasks() {\n     unsafe {\n-        TASK_LOCK.lock();\n-        while TASK_COUNT.load(atomics::SeqCst) > 0 {\n-            TASK_LOCK.wait();\n+        {\n+            let mut guard = TASK_LOCK.lock();\n+            while TASK_COUNT.load(atomics::SeqCst) > 0 {\n+                guard.wait();\n+            }\n         }\n-        TASK_LOCK.unlock();\n         TASK_LOCK.destroy();\n     }\n }"}, {"sha": "b33b54862dc2bcb0679da957246f536882850010", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -218,19 +218,18 @@ pub fn init() {\n     }\n \n     unsafe {\n-        use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+        use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n         static mut INITIALIZED: bool = false;\n-        static mut LOCK: Mutex = MUTEX_INIT;\n+        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n-        LOCK.lock();\n+        let _guard = LOCK.lock();\n         if !INITIALIZED {\n             let mut data: WSADATA = mem::init();\n             let ret = WSAStartup(0x202,      // version 2.2\n                                  &mut data);\n             assert_eq!(ret, 0);\n             INITIALIZED = true;\n         }\n-        LOCK.unlock();\n     }\n }\n "}, {"sha": "004cd6f311452dfde95e61b9225997295b979e6f", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -22,7 +22,7 @@\n \n use std::cast;\n use std::rt;\n-use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n use bookkeeping;\n use io::timer::{Req, Shutdown};\n@@ -37,11 +37,11 @@ static mut HELPER_CHAN: *mut Chan<Req> = 0 as *mut Chan<Req>;\n static mut HELPER_SIGNAL: imp::signal = 0 as imp::signal;\n \n pub fn boot(helper: fn(imp::signal, Port<Req>)) {\n-    static mut LOCK: Mutex = MUTEX_INIT;\n+    static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n     static mut INITIALIZED: bool = false;\n \n     unsafe {\n-        LOCK.lock();\n+        let mut _guard = LOCK.lock();\n         if !INITIALIZED {\n             let (msgp, msgc) = Chan::new();\n             // promote this to a shared channel\n@@ -58,7 +58,6 @@ pub fn boot(helper: fn(imp::signal, Port<Req>)) {\n             rt::at_exit(proc() { shutdown() });\n             INITIALIZED = true;\n         }\n-        LOCK.unlock();\n     }\n }\n "}, {"sha": "d8f410834f252c3b99d7b15086e2b91fc6692a5c", "filename": "src/libnative/task.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -22,7 +22,7 @@ use std::rt::task::{Task, BlockedTask, SendMessage};\n use std::rt::thread::Thread;\n use std::rt;\n use std::task::TaskOpts;\n-use std::unstable::mutex::Mutex;\n+use std::unstable::mutex::NativeMutex;\n use std::unstable::stack;\n \n use io;\n@@ -40,7 +40,7 @@ pub fn new(stack_bounds: (uint, uint)) -> ~Task {\n \n fn ops() -> ~Ops {\n     ~Ops {\n-        lock: unsafe { Mutex::new() },\n+        lock: unsafe { NativeMutex::new() },\n         awoken: false,\n         io: io::IoFactory::new(),\n         // these *should* get overwritten\n@@ -109,7 +109,7 @@ pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n // This structure is the glue between channels and the 1:1 scheduling mode. This\n // structure is allocated once per task.\n struct Ops {\n-    lock: Mutex,       // native synchronization\n+    lock: NativeMutex,       // native synchronization\n     awoken: bool,      // used to prevent spurious wakeups\n     io: io::IoFactory, // local I/O factory\n \n@@ -191,20 +191,19 @@ impl rt::Runtime for Ops {\n             let task = BlockedTask::block(cur_task);\n \n             if times == 1 {\n-                (*me).lock.lock();\n+                let mut guard = (*me).lock.lock();\n                 (*me).awoken = false;\n                 match f(task) {\n                     Ok(()) => {\n                         while !(*me).awoken {\n-                            (*me).lock.wait();\n+                            guard.wait();\n                         }\n                     }\n                     Err(task) => { cast::forget(task.wake()); }\n                 }\n-                (*me).lock.unlock();\n             } else {\n                 let mut iter = task.make_selectable(times);\n-                (*me).lock.lock();\n+                let mut guard = (*me).lock.lock();\n                 (*me).awoken = false;\n                 let success = iter.all(|task| {\n                     match f(task) {\n@@ -216,9 +215,8 @@ impl rt::Runtime for Ops {\n                     }\n                 });\n                 while success && !(*me).awoken {\n-                    (*me).lock.wait();\n+                    guard.wait();\n                 }\n-                (*me).lock.unlock();\n             }\n             // re-acquire ownership of the task\n             cur_task = cast::transmute::<uint, ~Task>(cur_task_dupe);\n@@ -235,10 +233,9 @@ impl rt::Runtime for Ops {\n             let me = &mut *self as *mut Ops;\n             to_wake.put_runtime(self as ~rt::Runtime);\n             cast::forget(to_wake);\n-            (*me).lock.lock();\n+            let mut guard = (*me).lock.lock();\n             (*me).awoken = true;\n-            (*me).lock.signal();\n-            (*me).lock.unlock();\n+            guard.signal();\n         }\n     }\n \n@@ -254,12 +251,6 @@ impl rt::Runtime for Ops {\n     }\n }\n \n-impl Drop for Ops {\n-    fn drop(&mut self) {\n-        unsafe { self.lock.destroy() }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use std::rt::Runtime;"}, {"sha": "da502ca72de57652d651acfaa5b46e549383e8a8", "filename": "src/librustuv/queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -23,7 +23,7 @@\n use std::cast;\n use std::libc::{c_void, c_int};\n use std::rt::task::BlockedTask;\n-use std::unstable::sync::LittleLock;\n+use std::unstable::mutex::NativeMutex;\n use std::sync::arc::UnsafeArc;\n use mpsc = std::sync::mpsc_queue;\n \n@@ -39,7 +39,7 @@ enum Message {\n \n struct State {\n     handle: *uvll::uv_async_t,\n-    lock: LittleLock, // see comments in async_cb for why this is needed\n+    lock: NativeMutex, // see comments in async_cb for why this is needed\n     queue: mpsc::Queue<Message>,\n }\n \n@@ -112,7 +112,7 @@ impl QueuePool {\n         let handle = UvHandle::alloc(None::<AsyncWatcher>, uvll::UV_ASYNC);\n         let state = UnsafeArc::new(State {\n             handle: handle,\n-            lock: LittleLock::new(),\n+            lock: unsafe {NativeMutex::new()},\n             queue: mpsc::Queue::new(),\n         });\n         let q = ~QueuePool {"}, {"sha": "031ce991ba47bdf1aa977696ad310c13aab1d9b8", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -28,7 +28,7 @@ use rt::local::Local;\n use rt::task::{Task, BlockedTask};\n use rt::thread::Thread;\n use sync::atomics;\n-use unstable::mutex::Mutex;\n+use unstable::mutex::NativeMutex;\n use vec::OwnedVector;\n \n use mpsc = sync::mpsc_queue;\n@@ -53,7 +53,7 @@ pub struct Packet<T> {\n \n     // this lock protects various portions of this implementation during\n     // select()\n-    select_lock: Mutex,\n+    select_lock: NativeMutex,\n }\n \n pub enum Failure {\n@@ -72,10 +72,10 @@ impl<T: Send> Packet<T> {\n             channels: atomics::AtomicInt::new(2),\n             port_dropped: atomics::AtomicBool::new(false),\n             sender_drain: atomics::AtomicInt::new(0),\n-            select_lock: unsafe { Mutex::new() },\n+            select_lock: unsafe { NativeMutex::new() },\n         };\n         // see comments in inherit_blocker about why we grab this lock\n-        unsafe { p.select_lock.lock() }\n+        unsafe { p.select_lock.lock_noguard() }\n         return p;\n     }\n \n@@ -124,7 +124,7 @@ impl<T: Send> Packet<T> {\n         // interfere with this method. After we unlock this lock, we're\n         // signifying that we're done modifying self.cnt and self.to_wake and\n         // the port is ready for the world to continue using it.\n-        unsafe { self.select_lock.unlock() }\n+        unsafe { self.select_lock.unlock_noguard() }\n     }\n \n     pub fn send(&mut self, t: T) -> bool {\n@@ -438,8 +438,7 @@ impl<T: Send> Packet<T> {\n         // about looking at and dealing with to_wake. Once we have acquired the\n         // lock, we are guaranteed that inherit_blocker is done.\n         unsafe {\n-            self.select_lock.lock();\n-            self.select_lock.unlock();\n+            let _guard = self.select_lock.lock();\n         }\n \n         // Like the stream implementation, we want to make sure that the count\n@@ -487,7 +486,6 @@ impl<T: Send> Drop for Packet<T> {\n             assert_eq!(self.cnt.load(atomics::SeqCst), DISCONNECTED);\n             assert_eq!(self.to_wake.load(atomics::SeqCst), 0);\n             assert_eq!(self.channels.load(atomics::SeqCst), 0);\n-            self.select_lock.destroy();\n         }\n     }\n }"}, {"sha": "719ed62d03d0aaa65707319c5696db53680088d4", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -44,7 +44,6 @@ use ptr;\n use str;\n use str::{Str, StrSlice};\n use fmt;\n-use unstable::finally::Finally;\n use sync::atomics::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use path::{Path, GenericPath};\n use iter::Iterator;\n@@ -145,16 +144,13 @@ Accessing environment variables is not generally threadsafe.\n Serialize access through a global lock.\n */\n fn with_env_lock<T>(f: || -> T) -> T {\n-    use unstable::mutex::{Mutex, MUTEX_INIT};\n-    use unstable::finally::Finally;\n+    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n-    static mut lock: Mutex = MUTEX_INIT;\n+    static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n     unsafe {\n-        return (|| {\n-            lock.lock();\n-            f()\n-        }).finally(|| lock.unlock());\n+        let _guard = lock.lock();\n+        f()\n     }\n }\n "}, {"sha": "6f73265978bf4ecc4faa6f428b0aa59787576e4f", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -68,12 +68,11 @@ mod imp {\n     use option::{Option, Some, None};\n     use ptr::RawPtr;\n     use iter::Iterator;\n-    use unstable::finally::Finally;\n-    use unstable::mutex::{Mutex, MUTEX_INIT};\n+    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     use mem;\n \n     static mut global_args_ptr: uint = 0;\n-    static mut lock: Mutex = MUTEX_INIT;\n+    static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n     #[cfg(not(test))]\n     pub unsafe fn init(argc: int, argv: **u8) {\n@@ -111,16 +110,10 @@ mod imp {\n     }\n \n     fn with_lock<T>(f: || -> T) -> T {\n-        (|| {\n-            unsafe {\n-                lock.lock();\n-                f()\n-            }\n-        }).finally(|| {\n-            unsafe {\n-                lock.unlock();\n-            }\n-        })\n+        unsafe {\n+            let _guard = lock.lock();\n+            f()\n+        }\n     }\n \n     fn get_global_ptr() -> *mut Option<~~[~[u8]]> {"}, {"sha": "84fa528ebf130746d92a90f7f4d3cbbecd0d295d", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -152,12 +152,12 @@ pub mod dl {\n     }\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n-        use unstable::mutex::{Mutex, MUTEX_INIT};\n-        static mut lock: Mutex = MUTEX_INIT;\n+        use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence\n-            lock.lock();\n+            let _guard = lock.lock();\n             let _old_error = dlerror();\n \n             let result = f();\n@@ -168,7 +168,7 @@ pub mod dl {\n             } else {\n                 Err(str::raw::from_c_str(last_error))\n             };\n-            lock.unlock();\n+\n             ret\n         }\n     }"}, {"sha": "34ddee46d350e1e48ef16eebb57b816d8f666764", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 249, "deletions": 54, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -8,85 +8,254 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A native mutex and condition variable type\n+//! A native mutex and condition variable type.\n //!\n //! This module contains bindings to the platform's native mutex/condition\n-//! variable primitives. It provides a single type, `Mutex`, which can be\n-//! statically initialized via the `MUTEX_INIT` value. This object serves as both a\n-//! mutex and a condition variable simultaneously.\n+//! variable primitives. It provides two types: `StaticNativeMutex`, which can\n+//! be statically initialized via the `NATIVE_MUTEX_INIT` value, and a simple\n+//! wrapper `NativeMutex` that has a destructor to clean up after itself. These\n+//! objects serve as both mutexes and condition variables simultaneously.\n //!\n-//! The lock is lazily initialized, but it can only be unsafely destroyed. A\n-//! statically initialized lock doesn't necessarily have a time at which it can\n-//! get deallocated. For this reason, there is no `Drop` implementation of the\n-//! mutex, but rather the `destroy()` method must be invoked manually if\n-//! destruction of the mutex is desired.\n+//! The static lock is lazily initialized, but it can only be unsafely\n+//! destroyed. A statically initialized lock doesn't necessarily have a time at\n+//! which it can get deallocated. For this reason, there is no `Drop`\n+//! implementation of the static mutex, but rather the `destroy()` method must\n+//! be invoked manually if destruction of the mutex is desired.\n //!\n-//! It is not recommended to use this type for idiomatic rust use. This type is\n-//! appropriate where no other options are available, but other rust concurrency\n-//! primitives should be used before this type.\n+//! The non-static `NativeMutex` type does have a destructor, but cannot be\n+//! statically initialized.\n+//!\n+//! It is not recommended to use this type for idiomatic rust use. These types\n+//! are appropriate where no other options are available, but other rust\n+//! concurrency primitives should be used before them: the `sync` crate defines\n+//! `StaticMutex` and `Mutex` types.\n //!\n //! # Example\n //!\n-//!     use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+//! ```rust\n+//! use std::unstable::mutex::{NativeMutex, StaticNativeMutex, NATIVE_MUTEX_INIT};\n+//!\n+//! // Use a statically initialized mutex\n+//! static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+//!\n+//! unsafe {\n+//!     let _guard = LOCK.lock();\n+//! } // automatically unlocked here\n //!\n-//!     // Use a statically initialized mutex\n-//!     static mut lock: Mutex = MUTEX_INIT;\n+//! // Use a normally initialized mutex\n+//! unsafe {\n+//!     let mut lock = NativeMutex::new();\n //!\n-//!     unsafe {\n-//!         lock.lock();\n-//!         lock.unlock();\n-//!     }\n+//!     {\n+//!         let _guard = lock.lock();\n+//!     } // unlocked here\n //!\n-//!     // Use a normally initialized mutex\n-//!     let mut lock = Mutex::new();\n-//!     unsafe {\n-//!         lock.lock();\n-//!         lock.unlock();\n-//!         lock.destroy();\n-//!     }\n+//!     // sometimes the RAII guard isn't appropriate\n+//!     lock.lock_noguard();\n+//!     lock.unlock_noguard();\n+//! } // `lock` is deallocated here\n+//! ```\n \n #[allow(non_camel_case_types)];\n \n-pub struct Mutex {\n+use option::{Option, None, Some};\n+use ops::Drop;\n+\n+/// A native mutex suitable for storing in statics (that is, it has\n+/// the `destroy` method rather than a destructor).\n+///\n+/// Prefer the `NativeMutex` type where possible, since that does not\n+/// require manual deallocation.\n+pub struct StaticNativeMutex {\n     priv inner: imp::Mutex,\n }\n \n-pub static MUTEX_INIT: Mutex = Mutex {\n+/// A native mutex with a destructor for clean-up.\n+///\n+/// See `StaticNativeMutex` for a version that is suitable for storing in\n+/// statics.\n+pub struct NativeMutex {\n+    priv inner: StaticNativeMutex\n+}\n+\n+/// Automatically unlocks the mutex that it was created from on\n+/// destruction.\n+///\n+/// Using this makes lock-based code resilient to unwinding/task\n+/// failure, because the lock will be automatically unlocked even\n+/// then.\n+#[must_use]\n+pub struct LockGuard<'a> {\n+    priv lock: &'a mut StaticNativeMutex\n+}\n+\n+pub static NATIVE_MUTEX_INIT: StaticNativeMutex = StaticNativeMutex {\n     inner: imp::MUTEX_INIT,\n };\n \n-impl Mutex {\n-    /// Creates a new mutex\n-    pub unsafe fn new() -> Mutex {\n-        Mutex { inner: imp::Mutex::new() }\n+impl StaticNativeMutex {\n+    /// Creates a new mutex.\n+    ///\n+    /// Note that a mutex created in this way needs to be explicit\n+    /// freed with a call to `destroy` or it will leak.\n+    pub unsafe fn new() -> StaticNativeMutex {\n+        StaticNativeMutex { inner: imp::Mutex::new() }\n     }\n \n     /// Acquires this lock. This assumes that the current thread does not\n     /// already hold the lock.\n-    pub unsafe fn lock(&mut self) { self.inner.lock() }\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    /// static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    /// unsafe {\n+    ///     let _guard = LOCK.lock();\n+    ///     // critical section...\n+    /// } // automatically unlocked in `_guard`'s destructor\n+    /// ```\n+    pub unsafe fn lock<'a>(&'a mut self) -> LockGuard<'a> {\n+        self.inner.lock();\n+\n+        LockGuard { lock: self }\n+    }\n+\n+    /// Attempts to acquire the lock. The value returned is `Some` if\n+    /// the attempt succeeded.\n+    pub unsafe fn trylock<'a>(&'a mut self) -> Option<LockGuard<'a>> {\n+        if self.inner.trylock() {\n+            Some(LockGuard { lock: self })\n+        } else {\n+            None\n+        }\n+    }\n \n-    /// Attempts to acquire the lock. The value returned is whether the lock was\n-    /// acquired or not\n-    pub unsafe fn trylock(&mut self) -> bool { self.inner.trylock() }\n+    /// Acquire the lock without creating a `LockGuard`.\n+    ///\n+    /// These needs to be paired with a call to `.unlock_noguard`. Prefer using\n+    /// `.lock`.\n+    pub unsafe fn lock_noguard(&mut self) { self.inner.lock() }\n+\n+    /// Attempts to acquire the lock without creating a\n+    /// `LockGuard`. The value returned is whether the lock was\n+    /// acquired or not.\n+    ///\n+    /// If `true` is returned, this needs to be paired with a call to\n+    /// `.unlock_noguard`. Prefer using `.trylock`.\n+    pub unsafe fn trylock_noguard(&mut self) -> bool {\n+        self.inner.trylock()\n+    }\n \n     /// Unlocks the lock. This assumes that the current thread already holds the\n     /// lock.\n-    pub unsafe fn unlock(&mut self) { self.inner.unlock() }\n+    pub unsafe fn unlock_noguard(&mut self) { self.inner.unlock() }\n \n     /// Block on the internal condition variable.\n     ///\n-    /// This function assumes that the lock is already held\n-    pub unsafe fn wait(&mut self) { self.inner.wait() }\n+    /// This function assumes that the lock is already held. Prefer\n+    /// using `LockGuard.wait` since that guarantees that the lock is\n+    /// held.\n+    pub unsafe fn wait_noguard(&mut self) { self.inner.wait() }\n \n     /// Signals a thread in `wait` to wake up\n-    pub unsafe fn signal(&mut self) { self.inner.signal() }\n+    pub unsafe fn signal_noguard(&mut self) { self.inner.signal() }\n \n     /// This function is especially unsafe because there are no guarantees made\n     /// that no other thread is currently holding the lock or waiting on the\n     /// condition variable contained inside.\n     pub unsafe fn destroy(&mut self) { self.inner.destroy() }\n }\n \n+impl NativeMutex {\n+    /// Creates a new mutex.\n+    ///\n+    /// The user must be careful to ensure the mutex is not locked when its is\n+    /// being destroyed.\n+    pub unsafe fn new() -> NativeMutex {\n+        NativeMutex { inner: StaticNativeMutex::new() }\n+    }\n+\n+    /// Acquires this lock. This assumes that the current thread does not\n+    /// already hold the lock.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// use std::unstable::mutex::NativeMutex;\n+    /// unsafe {\n+    ///     let mut lock = NativeMutex::new();\n+    ///\n+    ///     {\n+    ///         let _guard = lock.lock();\n+    ///         // critical section...\n+    ///     } // automatically unlocked in `_guard`'s destructor\n+    /// }\n+    /// ```\n+    pub unsafe fn lock<'a>(&'a mut self) -> LockGuard<'a> {\n+        self.inner.lock()\n+    }\n+\n+    /// Attempts to acquire the lock. The value returned is `Some` if\n+    /// the attempt succeeded.\n+    pub unsafe fn trylock<'a>(&'a mut self) -> Option<LockGuard<'a>> {\n+        self.inner.trylock()\n+    }\n+\n+    /// Acquire the lock without creating a `LockGuard`.\n+    ///\n+    /// These needs to be paired with a call to `.unlock_noguard`. Prefer using\n+    /// `.lock`.\n+    pub unsafe fn lock_noguard(&mut self) { self.inner.lock_noguard() }\n+\n+    /// Attempts to acquire the lock without creating a\n+    /// `LockGuard`. The value returned is whether the lock was\n+    /// acquired or not.\n+    ///\n+    /// If `true` is returned, this needs to be paired with a call to\n+    /// `.unlock_noguard`. Prefer using `.trylock`.\n+    pub unsafe fn trylock_noguard(&mut self) -> bool {\n+        self.inner.trylock_noguard()\n+    }\n+\n+    /// Unlocks the lock. This assumes that the current thread already holds the\n+    /// lock.\n+    pub unsafe fn unlock_noguard(&mut self) { self.inner.unlock_noguard() }\n+\n+    /// Block on the internal condition variable.\n+    ///\n+    /// This function assumes that the lock is already held. Prefer\n+    /// using `LockGuard.wait` since that guarantees that the lock is\n+    /// held.\n+    pub unsafe fn wait_noguard(&mut self) { self.inner.wait_noguard() }\n+\n+    /// Signals a thread in `wait` to wake up\n+    pub unsafe fn signal_noguard(&mut self) { self.inner.signal_noguard() }\n+}\n+\n+impl Drop for NativeMutex {\n+    fn drop(&mut self) {\n+        unsafe {self.inner.destroy()}\n+    }\n+}\n+\n+impl<'a> LockGuard<'a> {\n+    /// Block on the internal condition variable.\n+    pub unsafe fn wait(&mut self) {\n+        self.lock.wait_noguard()\n+    }\n+\n+    /// Signals a thread in `wait` to wake up.\n+    pub unsafe fn signal(&mut self) {\n+        self.lock.signal_noguard()\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for LockGuard<'a> {\n+    fn drop(&mut self) {\n+        unsafe {self.lock.unlock_noguard()}\n+    }\n+}\n+\n #[cfg(unix)]\n mod imp {\n     use libc;\n@@ -382,38 +551,64 @@ mod imp {\n mod test {\n     use prelude::*;\n \n-    use super::{Mutex, MUTEX_INIT};\n+    use mem::drop;\n+    use super::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     use rt::thread::Thread;\n \n     #[test]\n-    fn somke_lock() {\n-        static mut lock: Mutex = MUTEX_INIT;\n+    fn smoke_lock() {\n+        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n-            lock.lock();\n-            lock.unlock();\n+            let _guard = lock.lock();\n         }\n     }\n \n     #[test]\n-    fn somke_cond() {\n-        static mut lock: Mutex = MUTEX_INIT;\n+    fn smoke_cond() {\n+        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n-            lock.lock();\n+            let mut guard = lock.lock();\n             let t = Thread::start(proc() {\n-                lock.lock();\n-                lock.signal();\n-                lock.unlock();\n+                let mut guard = lock.lock();\n+                guard.signal();\n             });\n-            lock.wait();\n-            lock.unlock();\n+            guard.wait();\n+            drop(guard);\n+\n+            t.join();\n+        }\n+    }\n+\n+    #[test]\n+    fn smoke_lock_noguard() {\n+        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        unsafe {\n+            lock.lock_noguard();\n+            lock.unlock_noguard();\n+        }\n+    }\n+\n+    #[test]\n+    fn smoke_cond_noguard() {\n+        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        unsafe {\n+            lock.lock_noguard();\n+            let t = Thread::start(proc() {\n+                lock.lock_noguard();\n+                lock.signal_noguard();\n+                lock.unlock_noguard();\n+            });\n+            lock.wait_noguard();\n+            lock.unlock_noguard();\n+\n             t.join();\n         }\n     }\n \n     #[test]\n     fn destroy_immediately() {\n         unsafe {\n-            let mut m = Mutex::new();\n+            let mut m = StaticNativeMutex::new();\n             m.destroy();\n         }\n     }"}, {"sha": "93322977bc1215c1c80fc1c7713db46a863f358a", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 7, "deletions": 59, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -10,63 +10,11 @@\n \n use clone::Clone;\n use kinds::Send;\n-use ops::Drop;\n-use option::{Option,Some,None};\n use sync::arc::UnsafeArc;\n-use unstable::mutex::Mutex;\n-\n-pub struct LittleLock {\n-    priv l: Mutex,\n-}\n-\n-pub struct LittleGuard<'a> {\n-    priv l: &'a mut Mutex,\n-}\n-\n-impl Drop for LittleLock {\n-    fn drop(&mut self) {\n-        unsafe { self.l.destroy(); }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<'a> Drop for LittleGuard<'a> {\n-    fn drop(&mut self) {\n-        unsafe { self.l.unlock(); }\n-    }\n-}\n-\n-impl LittleLock {\n-    pub fn new() -> LittleLock {\n-        unsafe { LittleLock { l: Mutex::new() } }\n-    }\n-\n-    pub unsafe fn lock<'a>(&'a mut self) -> LittleGuard<'a> {\n-        self.l.lock();\n-        LittleGuard { l: &mut self.l }\n-    }\n-\n-    pub unsafe fn try_lock<'a>(&'a mut self) -> Option<LittleGuard<'a>> {\n-        if self.l.trylock() {\n-            Some(LittleGuard { l: &mut self.l })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub unsafe fn signal(&mut self) {\n-        self.l.signal();\n-    }\n-}\n-\n-impl<'a> LittleGuard<'a> {\n-    pub unsafe fn wait(&mut self) {\n-        self.l.wait();\n-    }\n-}\n+use unstable::mutex::NativeMutex;\n \n struct ExData<T> {\n-    lock: LittleLock,\n+    lock: NativeMutex,\n     failed: bool,\n     data: T,\n }\n@@ -95,7 +43,7 @@ impl<T:Send> Clone for Exclusive<T> {\n impl<T:Send> Exclusive<T> {\n     pub fn new(user_data: T) -> Exclusive<T> {\n         let data = ExData {\n-            lock: LittleLock::new(),\n+            lock: unsafe {NativeMutex::new()},\n             failed: false,\n             data: user_data\n         };\n@@ -104,8 +52,8 @@ impl<T:Send> Exclusive<T> {\n         }\n     }\n \n-    // Exactly like std::arc::MutexArc,access(), but with the LittleLock\n-    // instead of a proper mutex. Same reason for being unsafe.\n+    // Exactly like sync::MutexArc.access(). Same reason for being\n+    // unsafe.\n     //\n     // Currently, scheduling operations (i.e., descheduling, receiving on a pipe,\n     // accessing the provided condition variable) are prohibited while inside\n@@ -131,14 +79,14 @@ impl<T:Send> Exclusive<T> {\n     #[inline]\n     pub unsafe fn hold_and_signal(&self, f: |x: &mut T|) {\n         let rec = self.x.get();\n-        let _l = (*rec).lock.lock();\n+        let mut guard = (*rec).lock.lock();\n         if (*rec).failed {\n             fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n         }\n         (*rec).failed = true;\n         f(&mut (*rec).data);\n         (*rec).failed = false;\n-        (*rec).lock.signal();\n+        guard.signal();\n     }\n \n     #[inline]"}, {"sha": "9ca2f1fd7ffe32430756d4ea8bac5b8b0a9f39ed", "filename": "src/libsync/sync/mutex.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibsync%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98668a55996d656072a4cac7abb1dcbbdf4f48b/src%2Flibsync%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fsync%2Fmutex.rs?ref=d98668a55996d656072a4cac7abb1dcbbdf4f48b", "patch": "@@ -133,7 +133,7 @@ pub struct StaticMutex {\n     /// uint-cast of the native thread waiting for this mutex\n     priv native_blocker: uint,\n     /// an OS mutex used by native threads\n-    priv lock: mutex::Mutex,\n+    priv lock: mutex::StaticNativeMutex,\n \n     /// A concurrent mpsc queue used by green threads, along with a count used\n     /// to figure out when to dequeue and enqueue.\n@@ -143,14 +143,15 @@ pub struct StaticMutex {\n \n /// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n /// dropped (falls out of scope), the lock will be unlocked.\n+#[must_use]\n pub struct Guard<'a> {\n     priv lock: &'a mut StaticMutex,\n }\n \n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n pub static MUTEX_INIT: StaticMutex = StaticMutex {\n-    lock: mutex::MUTEX_INIT,\n+    lock: mutex::NATIVE_MUTEX_INIT,\n     state: atomics::INIT_ATOMIC_UINT,\n     flavor: Unlocked,\n     green_blocker: 0,\n@@ -288,11 +289,11 @@ impl StaticMutex {\n     // `lock()` function on an OS mutex\n     fn native_lock(&mut self, t: ~Task) {\n         Local::put(t);\n-        unsafe { self.lock.lock(); }\n+        unsafe { self.lock.lock_noguard(); }\n     }\n \n     fn native_unlock(&mut self) {\n-        unsafe { self.lock.unlock(); }\n+        unsafe { self.lock.unlock_noguard(); }\n     }\n \n     fn green_lock(&mut self, t: ~Task) {\n@@ -441,7 +442,7 @@ impl Mutex {\n                 native_blocker: 0,\n                 green_cnt: atomics::AtomicUint::new(0),\n                 q: q::Queue::new(),\n-                lock: unsafe { mutex::Mutex::new() },\n+                lock: unsafe { mutex::StaticNativeMutex::new() },\n             }\n         }\n     }"}]}