{"sha": "9eb5a96387c8a737732591c4a0076cafa7ad0869", "node_id": "C_kwDOAAsO6NoAKDllYjVhOTYzODdjOGE3Mzc3MzI1OTFjNGEwMDc2Y2FmYTdhZDA4Njk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-09T17:28:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-09T17:28:53Z"}, "message": "Merge #10974\n\n10974: minor: Simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "e17b4ae2bad76d9082aac14da8f4dfd0cf2a8701", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e17b4ae2bad76d9082aac14da8f4dfd0cf2a8701"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eb5a96387c8a737732591c4a0076cafa7ad0869", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhsjzVCRBK7hj4Ov3rIwAAZPEIAFNgFkWavxsOVQZz5HkfCcwy\nNSAyHhOF/2rMNONGGLLWZ5pfK7sljOO2i+dlBY3Hraf0H4pJ/nU5htVfkmtN32ny\ng8TVeFCEPLkk96P9xD7ZzEGTEWPLLmTwuy+pjW3dw2oVHRIllk6C01Ivt35wroRc\ngifPvEdRZotOKTuHzaKKJ2Zav6SHrSh3PDwIVKkTOdWo6wsEt769KalkVZ7gjvUV\nbnVkQ0ROvLoLzOQBdpr5TnYaldwV3AbTX/rIiV0XkyS5ZdDKYH5cUApjEJlL4zwv\nSAVCKy0nKGXr9vLxssnAn5cT9xqyVmoWy05bkcKdT2FejP9RHspn5BbRu02E+E8=\n=bRgQ\n-----END PGP SIGNATURE-----\n", "payload": "tree e17b4ae2bad76d9082aac14da8f4dfd0cf2a8701\nparent 6df9bd42f44c5f70903021f83c6ada0c6e3c6916\nparent e1a236d65e8c091e6c849865d1ddce87c4324fe3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1639070933 +0000\ncommitter GitHub <noreply@github.com> 1639070933 +0000\n\nMerge #10974\n\n10974: minor: Simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb5a96387c8a737732591c4a0076cafa7ad0869", "html_url": "https://github.com/rust-lang/rust/commit/9eb5a96387c8a737732591c4a0076cafa7ad0869", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eb5a96387c8a737732591c4a0076cafa7ad0869/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6df9bd42f44c5f70903021f83c6ada0c6e3c6916", "url": "https://api.github.com/repos/rust-lang/rust/commits/6df9bd42f44c5f70903021f83c6ada0c6e3c6916", "html_url": "https://github.com/rust-lang/rust/commit/6df9bd42f44c5f70903021f83c6ada0c6e3c6916"}, {"sha": "e1a236d65e8c091e6c849865d1ddce87c4324fe3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1a236d65e8c091e6c849865d1ddce87c4324fe3", "html_url": "https://github.com/rust-lang/rust/commit/e1a236d65e8c091e6c849865d1ddce87c4324fe3"}], "stats": {"total": 102, "additions": 56, "deletions": 46}, "files": [{"sha": "9f68b800a55ebd8571ef5654c1e3452fcb36f8e2", "filename": "crates/hir_def/src/resolver.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9eb5a96387c8a737732591c4a0076cafa7ad0869/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb5a96387c8a737732591c4a0076cafa7ad0869/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=9eb5a96387c8a737732591c4a0076cafa7ad0869", "patch": "@@ -8,7 +8,7 @@ use hir_expand::{\n };\n use indexmap::IndexMap;\n use rustc_hash::FxHashSet;\n-use smallvec::SmallVec;\n+use smallvec::{smallvec, SmallVec};\n \n use crate::{\n     body::scope::{ExprScopes, ScopeId},\n@@ -567,6 +567,8 @@ pub fn resolver_for_scope(\n     let mut r = owner.resolver(db);\n     let scopes = db.expr_scopes(owner);\n     let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n+    r.scopes.reserve(scope_chain.len());\n+\n     for scope in scope_chain.into_iter().rev() {\n         if let Some(block) = scopes.block(scope) {\n             if let Some(def_map) = db.block_def_map(block) {\n@@ -739,12 +741,13 @@ pub trait HasResolver: Copy {\n impl HasResolver for ModuleId {\n     fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         let mut def_map = self.def_map(db);\n-        let mut modules = vec![(def_map.clone(), self.local_id)];\n+        let mut modules: SmallVec<[_; 2]> = smallvec![(def_map.clone(), self.local_id)];\n         while let Some(parent) = def_map.parent() {\n             def_map = parent.def_map(db);\n             modules.push((def_map.clone(), parent.local_id));\n         }\n         let mut resolver = Resolver::default();\n+        resolver.scopes.reserve(modules.len());\n         for (def_map, module) in modules.into_iter().rev() {\n             resolver = resolver.push_module_scope(def_map, module);\n         }"}, {"sha": "23f81d3c7f5aca5d82a12b1145a6eee758ad1ad6", "filename": "crates/hir_expand/src/name.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9eb5a96387c8a737732591c4a0076cafa7ad0869/crates%2Fhir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb5a96387c8a737732591c4a0076cafa7ad0869/crates%2Fhir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fname.rs?ref=9eb5a96387c8a737732591c4a0076cafa7ad0869", "patch": "@@ -334,6 +334,13 @@ pub mod known {\n         gt,\n         le,\n         lt,\n+        // lang items\n+        not,\n+        neg,\n+        future_trait,\n+        owned_box,\n+        index,\n+        partial_ord\n     );\n \n     // self/Self cannot be used as an identifier"}, {"sha": "ce6cb815400326aa6b863e5bf3e6f33b24b0cad5", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9eb5a96387c8a737732591c4a0076cafa7ad0869/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb5a96387c8a737732591c4a0076cafa7ad0869/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=9eb5a96387c8a737732591c4a0076cafa7ad0869", "patch": "@@ -28,11 +28,10 @@ use hir_def::{\n     AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule, Lookup,\n     TraitId, TypeAliasId, VariantId,\n };\n-use hir_expand::name::name;\n+use hir_expand::name::{name, Name};\n use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n use stdx::impl_from;\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, fold_tys, infer::coerce::CoerceMany, lower::ImplTraitLoweringMode,\n@@ -719,10 +718,9 @@ impl<'a> InferenceContext<'a> {\n         self.infer_expr_coerce(self.body.body_expr, &Expectation::has_type(self.return_ty.clone()));\n     }\n \n-    fn resolve_lang_item(&self, name: &str) -> Option<LangItemTarget> {\n+    fn resolve_lang_item(&self, name: Name) -> Option<LangItemTarget> {\n         let krate = self.resolver.krate()?;\n-        let name = SmolStr::new_inline(name);\n-        self.db.lang_item(krate, name)\n+        self.db.lang_item(krate, name.to_smol_str())\n     }\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n@@ -743,22 +741,22 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_lang_item(\"neg\")?.as_trait()?;\n+        let trait_ = self.resolve_lang_item(name![neg])?.as_trait()?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_ops_not_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_lang_item(\"not\")?.as_trait()?;\n+        let trait_ = self.resolve_lang_item(name![not])?.as_trait()?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_lang_item(\"future_trait\")?.as_trait()?;\n+        let trait_ = self.resolve_lang_item(name![future_trait])?.as_trait()?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_boxed_box(&self) -> Option<AdtId> {\n-        let struct_ = self.resolve_lang_item(\"owned_box\")?.as_struct()?;\n+        let struct_ = self.resolve_lang_item(name![owned_box])?.as_struct()?;\n         Some(struct_.into())\n     }\n \n@@ -799,7 +797,7 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_ops_index(&self) -> Option<TraitId> {\n-        self.resolve_lang_item(\"index\")?.as_trait()\n+        self.resolve_lang_item(name![index])?.as_trait()\n     }\n \n     fn resolve_ops_index_output(&self) -> Option<TypeAliasId> {"}, {"sha": "2b8dc793ccbf464a45621eeb216e20a679b6b463", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9eb5a96387c8a737732591c4a0076cafa7ad0869/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb5a96387c8a737732591c4a0076cafa7ad0869/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=9eb5a96387c8a737732591c4a0076cafa7ad0869", "patch": "@@ -1276,41 +1276,43 @@ impl<'a> InferenceContext<'a> {\n         let (name, lang_item) = match op {\n             BinaryOp::LogicOp(_) => return None,\n             BinaryOp::ArithOp(aop) => match aop {\n-                ArithOp::Add => (name!(add), \"add\"),\n-                ArithOp::Mul => (name!(mul), \"mul\"),\n-                ArithOp::Sub => (name!(sub), \"sub\"),\n-                ArithOp::Div => (name!(div), \"div\"),\n-                ArithOp::Rem => (name!(rem), \"rem\"),\n-                ArithOp::Shl => (name!(shl), \"shl\"),\n-                ArithOp::Shr => (name!(shr), \"shr\"),\n-                ArithOp::BitXor => (name!(bitxor), \"bitxor\"),\n-                ArithOp::BitOr => (name!(bitor), \"bitor\"),\n-                ArithOp::BitAnd => (name!(bitand), \"bitand\"),\n+                ArithOp::Add => (name!(add), name!(add)),\n+                ArithOp::Mul => (name!(mul), name!(mul)),\n+                ArithOp::Sub => (name!(sub), name!(sub)),\n+                ArithOp::Div => (name!(div), name!(div)),\n+                ArithOp::Rem => (name!(rem), name!(rem)),\n+                ArithOp::Shl => (name!(shl), name!(shl)),\n+                ArithOp::Shr => (name!(shr), name!(shr)),\n+                ArithOp::BitXor => (name!(bitxor), name!(bitxor)),\n+                ArithOp::BitOr => (name!(bitor), name!(bitor)),\n+                ArithOp::BitAnd => (name!(bitand), name!(bitand)),\n             },\n             BinaryOp::Assignment { op: Some(aop) } => match aop {\n-                ArithOp::Add => (name!(add_assign), \"add_assign\"),\n-                ArithOp::Mul => (name!(mul_assign), \"mul_assign\"),\n-                ArithOp::Sub => (name!(sub_assign), \"sub_assign\"),\n-                ArithOp::Div => (name!(div_assign), \"div_assign\"),\n-                ArithOp::Rem => (name!(rem_assign), \"rem_assign\"),\n-                ArithOp::Shl => (name!(shl_assign), \"shl_assign\"),\n-                ArithOp::Shr => (name!(shr_assign), \"shr_assign\"),\n-                ArithOp::BitXor => (name!(bitxor_assign), \"bitxor_assign\"),\n-                ArithOp::BitOr => (name!(bitor_assign), \"bitor_assign\"),\n-                ArithOp::BitAnd => (name!(bitand_assign), \"bitand_assign\"),\n+                ArithOp::Add => (name!(add_assign), name!(add_assign)),\n+                ArithOp::Mul => (name!(mul_assign), name!(mul_assign)),\n+                ArithOp::Sub => (name!(sub_assign), name!(sub_assign)),\n+                ArithOp::Div => (name!(div_assign), name!(div_assign)),\n+                ArithOp::Rem => (name!(rem_assign), name!(rem_assign)),\n+                ArithOp::Shl => (name!(shl_assign), name!(shl_assign)),\n+                ArithOp::Shr => (name!(shr_assign), name!(shr_assign)),\n+                ArithOp::BitXor => (name!(bitxor_assign), name!(bitxor_assign)),\n+                ArithOp::BitOr => (name!(bitor_assign), name!(bitor_assign)),\n+                ArithOp::BitAnd => (name!(bitand_assign), name!(bitand_assign)),\n             },\n             BinaryOp::CmpOp(cop) => match cop {\n-                CmpOp::Eq { negated: false } => (name!(eq), \"eq\"),\n-                CmpOp::Eq { negated: true } => (name!(ne), \"eq\"),\n+                CmpOp::Eq { negated: false } => (name!(eq), name!(eq)),\n+                CmpOp::Eq { negated: true } => (name!(ne), name!(eq)),\n                 CmpOp::Ord { ordering: Ordering::Less, strict: false } => {\n-                    (name!(le), \"partial_ord\")\n+                    (name!(le), name!(partial_ord))\n+                }\n+                CmpOp::Ord { ordering: Ordering::Less, strict: true } => {\n+                    (name!(lt), name!(partial_ord))\n                 }\n-                CmpOp::Ord { ordering: Ordering::Less, strict: true } => (name!(lt), \"partial_ord\"),\n                 CmpOp::Ord { ordering: Ordering::Greater, strict: false } => {\n-                    (name!(ge), \"partial_ord\")\n+                    (name!(ge), name!(partial_ord))\n                 }\n                 CmpOp::Ord { ordering: Ordering::Greater, strict: true } => {\n-                    (name!(gt), \"partial_ord\")\n+                    (name!(gt), name!(partial_ord))\n                 }\n             },\n             BinaryOp::Assignment { op: None } => return None,"}, {"sha": "f7e2af46d29569acda9eda4970e2635e6bca2f53", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9eb5a96387c8a737732591c4a0076cafa7ad0869/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb5a96387c8a737732591c4a0076cafa7ad0869/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=9eb5a96387c8a737732591c4a0076cafa7ad0869", "patch": "@@ -96,9 +96,9 @@ impl<'a> TyLoweringContext<'a> {\n         debruijn: DebruijnIndex,\n         f: impl FnOnce(&TyLoweringContext) -> T,\n     ) -> T {\n-        let opaque_ty_data_vec = self.opaque_type_data.replace(Vec::new());\n-        let expander = self.expander.replace(None);\n-        let unsized_types = self.unsized_types.replace(Default::default());\n+        let opaque_ty_data_vec = self.opaque_type_data.take();\n+        let expander = self.expander.take();\n+        let unsized_types = self.unsized_types.take();\n         let new_ctx = Self {\n             in_binders: debruijn,\n             impl_trait_counter: Cell::new(self.impl_trait_counter.get()),\n@@ -615,7 +615,7 @@ impl<'a> TyLoweringContext<'a> {\n                 // `Option::None::<T>` are both allowed (though the former is\n                 // preferred). See also `def_ids_for_path_segments` in rustc.\n                 let len = path.segments().len();\n-                let penultimate = if len >= 2 { path.segments().get(len - 2) } else { None };\n+                let penultimate = len.checked_sub(2).and_then(|idx| path.segments().get(idx));\n                 let segment = match penultimate {\n                     Some(segment) if segment.args_and_bindings.is_some() => segment,\n                     _ => last,\n@@ -841,23 +841,23 @@ impl<'a> TyLoweringContext<'a> {\n         };\n         last_segment\n             .into_iter()\n-            .flat_map(|segment| segment.args_and_bindings.into_iter())\n-            .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n+            .filter_map(|segment| segment.args_and_bindings)\n+            .flat_map(|args_and_bindings| &args_and_bindings.bindings)\n             .flat_map(move |binding| {\n                 let found = associated_type_by_name_including_super_traits(\n                     self.db,\n                     trait_ref.clone(),\n                     &binding.name,\n                 );\n                 let (super_trait_ref, associated_ty) = match found {\n-                    None => return SmallVec::<[QuantifiedWhereClause; 1]>::new(),\n+                    None => return SmallVec::new(),\n                     Some(t) => t,\n                 };\n                 let projection_ty = ProjectionTy {\n                     associated_ty_id: to_assoc_type_id(associated_ty),\n                     substitution: super_trait_ref.substitution,\n                 };\n-                let mut preds = SmallVec::with_capacity(\n+                let mut preds: SmallVec<[_; 1]> = SmallVec::with_capacity(\n                     binding.type_ref.as_ref().map_or(0, |_| 1) + binding.bounds.len(),\n                 );\n                 if let Some(type_ref) = &binding.type_ref {"}]}