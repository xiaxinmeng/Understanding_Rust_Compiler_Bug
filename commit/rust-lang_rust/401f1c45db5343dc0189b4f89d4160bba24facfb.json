{"sha": "401f1c45db5343dc0189b4f89d4160bba24facfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMWYxYzQ1ZGI1MzQzZGMwMTg5YjRmODlkNDE2MGJiYTI0ZmFjZmI=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2016-09-26T16:28:00Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2016-10-11T12:40:05Z"}, "message": "Merge two `impl<T> Vec<T>` blocks.\n\nThe show up separately in rustdoc.\n\nThis is a separate commit to keep the previous one\u2019s diff shorter.", "tree": {"sha": "ff71de8e8f9a8f7a7cac10950d04db4762d00334", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff71de8e8f9a8f7a7cac10950d04db4762d00334"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/401f1c45db5343dc0189b4f89d4160bba24facfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/401f1c45db5343dc0189b4f89d4160bba24facfb", "html_url": "https://github.com/rust-lang/rust/commit/401f1c45db5343dc0189b4f89d4160bba24facfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/401f1c45db5343dc0189b4f89d4160bba24facfb/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be34bac1abf16f1d741c7cfe56ab04c4b9ebf48f", "url": "https://api.github.com/repos/rust-lang/rust/commits/be34bac1abf16f1d741c7cfe56ab04c4b9ebf48f", "html_url": "https://github.com/rust-lang/rust/commit/be34bac1abf16f1d741c7cfe56ab04c4b9ebf48f"}], "stats": {"total": 250, "additions": 124, "deletions": 126}, "files": [{"sha": "bf9c2ae49a0c5525f712f084a2a05fbbe7f504c5", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 124, "deletions": 126, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/401f1c45db5343dc0189b4f89d4160bba24facfb/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401f1c45db5343dc0189b4f89d4160bba24facfb/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=401f1c45db5343dc0189b4f89d4160bba24facfb", "patch": "@@ -782,6 +782,130 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Removes consecutive elements in the vector that resolve to the same key.\n+    ///\n+    /// If the vector is sorted, this removes all duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(dedup_by)]\n+    ///\n+    /// let mut vec = vec![10, 20, 21, 30, 20];\n+    ///\n+    /// vec.dedup_by_key(|i| *i / 10);\n+    ///\n+    /// assert_eq!(vec, [10, 20, 30, 20]);\n+    /// ```\n+    #[unstable(feature = \"dedup_by\", reason = \"recently added\", issue = \"37087\")]\n+    #[inline]\n+    pub fn dedup_by_key<F, K>(&mut self, mut key: F) where F: FnMut(&mut T) -> K, K: PartialEq {\n+        self.dedup_by(|a, b| key(a) == key(b))\n+    }\n+\n+    /// Removes consecutive elements in the vector that resolve to the same key.\n+    ///\n+    /// If the vector is sorted, this removes all duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(dedup_by)]\n+    /// use std::ascii::AsciiExt;\n+    ///\n+    /// let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n+    ///\n+    /// vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n+    ///\n+    /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n+    /// ```\n+    #[unstable(feature = \"dedup_by\", reason = \"recently added\", issue = \"37087\")]\n+    pub fn dedup_by<F>(&mut self, mut same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n+        unsafe {\n+            // Although we have a mutable reference to `self`, we cannot make\n+            // *arbitrary* changes. The `PartialEq` comparisons could panic, so we\n+            // must ensure that the vector is in a valid state at all time.\n+            //\n+            // The way that we handle this is by using swaps; we iterate\n+            // over all the elements, swapping as we go so that at the end\n+            // the elements we wish to keep are in the front, and those we\n+            // wish to reject are at the back. We can then truncate the\n+            // vector. This operation is still O(n).\n+            //\n+            // Example: We start in this state, where `r` represents \"next\n+            // read\" and `w` represents \"next_write`.\n+            //\n+            //           r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //           w\n+            //\n+            // Comparing self[r] against self[w-1], this is not a duplicate, so\n+            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n+            // r and w, leaving us with:\n+            //\n+            //               r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //               w\n+            //\n+            // Comparing self[r] against self[w-1], this value is a duplicate,\n+            // so we increment `r` but leave everything else unchanged:\n+            //\n+            //                   r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //               w\n+            //\n+            // Comparing self[r] against self[w-1], this is not a duplicate,\n+            // so swap self[r] and self[w] and advance r and w:\n+            //\n+            //                       r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //                   w\n+            //\n+            // Not a duplicate, repeat:\n+            //\n+            //                           r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //                       w\n+            //\n+            // Duplicate, advance r. End of vec. Truncate to w.\n+\n+            let ln = self.len();\n+            if ln <= 1 {\n+                return;\n+            }\n+\n+            // Avoid bounds checks by using raw pointers.\n+            let p = self.as_mut_ptr();\n+            let mut r: usize = 1;\n+            let mut w: usize = 1;\n+\n+            while r < ln {\n+                let p_r = p.offset(r as isize);\n+                let p_wm1 = p.offset((w - 1) as isize);\n+                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n+                    if r != w {\n+                        let p_w = p_wm1.offset(1);\n+                        mem::swap(&mut *p_r, &mut *p_w);\n+                    }\n+                    w += 1;\n+                }\n+                r += 1;\n+            }\n+\n+            self.truncate(w);\n+        }\n+    }\n+\n     /// Appends an element to the back of a collection.\n     ///\n     /// # Panics\n@@ -1162,132 +1286,6 @@ impl<T: PartialEq> Vec<T> {\n     }\n }\n \n-impl<T> Vec<T> {\n-    /// Removes consecutive elements in the vector that resolve to the same key.\n-    ///\n-    /// If the vector is sorted, this removes all duplicates.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(dedup_by)]\n-    ///\n-    /// let mut vec = vec![10, 20, 21, 30, 20];\n-    ///\n-    /// vec.dedup_by_key(|i| *i / 10);\n-    ///\n-    /// assert_eq!(vec, [10, 20, 30, 20]);\n-    /// ```\n-    #[unstable(feature = \"dedup_by\", reason = \"recently added\", issue = \"37087\")]\n-    #[inline]\n-    pub fn dedup_by_key<F, K>(&mut self, mut key: F) where F: FnMut(&mut T) -> K, K: PartialEq {\n-        self.dedup_by(|a, b| key(a) == key(b))\n-    }\n-\n-    /// Removes consecutive elements in the vector that resolve to the same key.\n-    ///\n-    /// If the vector is sorted, this removes all duplicates.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(dedup_by)]\n-    /// use std::ascii::AsciiExt;\n-    ///\n-    /// let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n-    ///\n-    /// vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n-    ///\n-    /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n-    /// ```\n-    #[unstable(feature = \"dedup_by\", reason = \"recently added\", issue = \"37087\")]\n-    pub fn dedup_by<F>(&mut self, mut same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n-        unsafe {\n-            // Although we have a mutable reference to `self`, we cannot make\n-            // *arbitrary* changes. The `PartialEq` comparisons could panic, so we\n-            // must ensure that the vector is in a valid state at all time.\n-            //\n-            // The way that we handle this is by using swaps; we iterate\n-            // over all the elements, swapping as we go so that at the end\n-            // the elements we wish to keep are in the front, and those we\n-            // wish to reject are at the back. We can then truncate the\n-            // vector. This operation is still O(n).\n-            //\n-            // Example: We start in this state, where `r` represents \"next\n-            // read\" and `w` represents \"next_write`.\n-            //\n-            //           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //           w\n-            //\n-            // Comparing self[r] against self[w-1], this is not a duplicate, so\n-            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n-            // r and w, leaving us with:\n-            //\n-            //               r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this value is a duplicate,\n-            // so we increment `r` but leave everything else unchanged:\n-            //\n-            //                   r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this is not a duplicate,\n-            // so swap self[r] and self[w] and advance r and w:\n-            //\n-            //                       r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                   w\n-            //\n-            // Not a duplicate, repeat:\n-            //\n-            //                           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                       w\n-            //\n-            // Duplicate, advance r. End of vec. Truncate to w.\n-\n-            let ln = self.len();\n-            if ln <= 1 {\n-                return;\n-            }\n-\n-            // Avoid bounds checks by using raw pointers.\n-            let p = self.as_mut_ptr();\n-            let mut r: usize = 1;\n-            let mut w: usize = 1;\n-\n-            while r < ln {\n-                let p_r = p.offset(r as isize);\n-                let p_wm1 = p.offset((w - 1) as isize);\n-                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n-                    if r != w {\n-                        let p_w = p_wm1.offset(1);\n-                        mem::swap(&mut *p_r, &mut *p_w);\n-                    }\n-                    w += 1;\n-                }\n-                r += 1;\n-            }\n-\n-            self.truncate(w);\n-        }\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Internal methods and functions\n ////////////////////////////////////////////////////////////////////////////////"}]}