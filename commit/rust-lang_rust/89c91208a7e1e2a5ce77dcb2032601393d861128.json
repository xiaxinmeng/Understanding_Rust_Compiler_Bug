{"sha": "89c91208a7e1e2a5ce77dcb2032601393d861128", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YzkxMjA4YTdlMWUyYTVjZTc3ZGNiMjAzMjYwMTM5M2Q4NjExMjg=", "commit": {"author": {"name": "Jason Toffaletti", "email": "jason@topsy.com", "date": "2013-10-07T07:43:51Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-10-26T01:27:45Z"}, "message": "clean up", "tree": {"sha": "a8b12134d258c380b94ffbd947ff0f9342ae0fa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8b12134d258c380b94ffbd947ff0f9342ae0fa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89c91208a7e1e2a5ce77dcb2032601393d861128", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89c91208a7e1e2a5ce77dcb2032601393d861128", "html_url": "https://github.com/rust-lang/rust/commit/89c91208a7e1e2a5ce77dcb2032601393d861128", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89c91208a7e1e2a5ce77dcb2032601393d861128/comments", "author": {"login": "toffaletti", "id": 145012, "node_id": "MDQ6VXNlcjE0NTAxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/145012?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toffaletti", "html_url": "https://github.com/toffaletti", "followers_url": "https://api.github.com/users/toffaletti/followers", "following_url": "https://api.github.com/users/toffaletti/following{/other_user}", "gists_url": "https://api.github.com/users/toffaletti/gists{/gist_id}", "starred_url": "https://api.github.com/users/toffaletti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toffaletti/subscriptions", "organizations_url": "https://api.github.com/users/toffaletti/orgs", "repos_url": "https://api.github.com/users/toffaletti/repos", "events_url": "https://api.github.com/users/toffaletti/events{/privacy}", "received_events_url": "https://api.github.com/users/toffaletti/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c372fa55560f1cdfdcb566f3027689ba88c46da5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c372fa55560f1cdfdcb566f3027689ba88c46da5", "html_url": "https://github.com/rust-lang/rust/commit/c372fa55560f1cdfdcb566f3027689ba88c46da5"}], "stats": {"total": 74, "additions": 38, "deletions": 36}, "files": [{"sha": "7dd050f5a0ccc0a50447d54aee4282918771ed40", "filename": "src/libstd/rt/mpsc_queue.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/89c91208a7e1e2a5ce77dcb2032601393d861128/src%2Flibstd%2Frt%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c91208a7e1e2a5ce77dcb2032601393d861128/src%2Flibstd%2Frt%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmpsc_queue.rs?ref=89c91208a7e1e2a5ce77dcb2032601393d861128", "patch": "@@ -83,24 +83,28 @@ impl<T: Send> fmt::Default for Queue<T> {\n     }\n }\n \n-impl<T: Send> Queue<T> {\n-    pub fn new() -> Queue<T> {\n-        let mut q = Queue{state: UnsafeArc::new(State {\n+impl<T: Send> State<T> {\n+    pub fn new() -> State<T> {\n+        let mut state = State {\n             pad0: [0, ..64],\n             head: AtomicPtr::new(mut_null()),\n             pad1: [0, ..64],\n             stub: Default::default(),\n             pad2: [0, ..64],\n             tail: mut_null(),\n             pad3: [0, ..64],\n-        })};\n-        let stub = q.get_stub_unsafe();\n-        q.get_head().store(stub, Relaxed);\n-        q.set_tail(stub);\n-        q\n+        };\n+        let stub = state.get_stub_unsafe();\n+        state.head.store(stub, Relaxed);\n+        state.tail = stub;\n+        state\n     }\n \n-    pub fn push(&mut self, value: T) {\n+    fn get_stub_unsafe(&mut self) -> *mut Node<T> {\n+        unsafe { to_mut_unsafe_ptr(&mut self.stub) }\n+    }\n+\n+    fn push(&mut self, value: T) {\n         unsafe {\n             let node = cast::transmute(~Node::new(value));\n             self.push_node(node);\n@@ -110,65 +114,63 @@ impl<T: Send> Queue<T> {\n     fn push_node(&mut self, node: *mut Node<T>) {\n         unsafe {\n             (*node).next.store(mut_null(), Release);\n-            let prev = self.get_head().swap(node, Relaxed);\n+            let prev = self.head.swap(node, Relaxed);\n             (*prev).next.store(node, Release);\n         }\n     }\n \n-    fn get_stub_unsafe(&mut self) -> *mut Node<T> {\n-        unsafe { to_mut_unsafe_ptr(&mut (*self.state.get()).stub) }\n-    }\n-\n-    fn get_head(&mut self) -> &mut AtomicPtr<Node<T>> {\n-        unsafe { &mut (*self.state.get()).head }\n-    }\n-\n-    fn get_tail(&mut self) -> *mut Node<T> {\n-        unsafe { (*self.state.get()).tail }\n-    }\n-\n-    fn set_tail(&mut self, tail: *mut Node<T>) {\n-        unsafe { (*self.state.get()).tail = tail }\n-    }\n-\n-    pub fn casual_pop(&mut self) -> Option<T> {\n-        self.pop()\n-    }\n-\n-    pub fn pop(&mut self) -> Option<T> {\n+    fn pop(&mut self) -> Option<T> {\n         unsafe {\n-            let mut tail = self.get_tail();\n+            let mut tail = self.tail;\n             let mut next = (*tail).next.load(Acquire);\n             let stub = self.get_stub_unsafe();\n             if tail == stub {\n                 if mut_null() == next {\n                     return None\n                 }\n-                self.set_tail(next);\n+                self.tail = next;\n                 tail = next;\n                 next = (*next).next.load(Acquire);\n             }\n             if next != mut_null() {\n                 let tail: ~Node<T> = cast::transmute(tail);\n-                self.set_tail(next);\n+                self.tail = next;\n                 return tail.value\n             }\n-            let head = self.get_head().load(Relaxed);\n+            let head = self.head.load(Relaxed);\n             if tail != head {\n                 return None\n             }\n             self.push_node(stub);\n             next = (*tail).next.load(Acquire);\n             if next != mut_null() {\n                 let tail: ~Node<T> = cast::transmute(tail);\n-                self.set_tail(next);\n+                self.tail = next;\n                 return tail.value\n             }\n         }\n         None\n     }\n }\n \n+impl<T: Send> Queue<T> {\n+    pub fn new() -> Queue<T> {\n+        Queue{state: UnsafeArc::new(State::new())}\n+    }\n+\n+    pub fn push(&mut self, value: T) {\n+        unsafe { (*self.state.get()).push(value) }\n+    }\n+\n+    pub fn casual_pop(&mut self) -> Option<T> {\n+        unsafe { (*self.state.get()).pop() }\n+    }\n+\n+    pub fn pop(&mut self) -> Option<T> {\n+        unsafe{ (*self.state.get()).pop() }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::*;"}]}