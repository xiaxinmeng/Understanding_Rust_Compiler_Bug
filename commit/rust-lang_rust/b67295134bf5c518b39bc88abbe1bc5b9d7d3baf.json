{"sha": "b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NzI5NTEzNGJmNWM1MThiMzliYzg4YWJiZTFiYzViOWQ3ZDNiYWY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-31T07:56:31Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-31T07:56:31Z"}, "message": "Move FnDescriptors to analyzer", "tree": {"sha": "a507432668deef7b216cb7c6360620619e904060", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a507432668deef7b216cb7c6360620619e904060"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "html_url": "https://github.com/rust-lang/rust/commit/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3068af79ffd23656ff2d46ac92d9192ce6c813fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3068af79ffd23656ff2d46ac92d9192ce6c813fb", "html_url": "https://github.com/rust-lang/rust/commit/3068af79ffd23656ff2d46ac92d9192ce6c813fb"}], "stats": {"total": 910, "additions": 712, "deletions": 198}, "files": [{"sha": "869ab5afbe8de840f59a92ddafbfdc6ce7225d30", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -1,14 +1,15 @@\n use ra_editor::{CompletionItem, find_node_at_offset};\n use ra_syntax::{\n     AtomEdit, File, TextUnit, AstNode,\n-    ast::{self, ModuleItemOwner, AstChildren},\n+    ast,\n };\n \n use crate::{\n     FileId, Cancelable,\n     input::FilesDatabase,\n     db::{self, SyntaxDatabase},\n-    descriptors::module::{ModulesDatabase, ModuleTree, ModuleId, scope::ModuleScope},\n+    descriptors::DescriptorDatabase,\n+    descriptors::module::{ModuleTree, ModuleId},\n };\n \n pub(crate) fn resolve_based_completion(db: &db::RootDatabase, file_id: FileId, offset: TextUnit) -> Cancelable<Option<Vec<CompletionItem>>> {"}, {"sha": "fe6587f208807150386c8dae16807a625ea5967f", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -9,7 +9,10 @@ use salsa;\n use crate::{\n     db,\n     Cancelable, Canceled,\n-    descriptors::module::{SubmodulesQuery, ModuleTreeQuery, ModulesDatabase, ModuleScopeQuery},\n+    descriptors::{\n+        DescriptorDatabase, SubmodulesQuery, ModuleTreeQuery, ModuleScopeQuery,\n+        FnSyntaxQuery, FnScopesQuery\n+    },\n     symbol_index::SymbolIndex,\n     syntax_ptr::{SyntaxPtrDatabase, ResolveSyntaxPtrQuery},\n     FileId,\n@@ -63,10 +66,12 @@ salsa::database_storage! {\n             fn file_lines() for FileLinesQuery;\n             fn file_symbols() for FileSymbolsQuery;\n         }\n-        impl ModulesDatabase {\n+        impl DescriptorDatabase {\n             fn module_tree() for ModuleTreeQuery;\n             fn module_descriptor() for SubmodulesQuery;\n             fn module_scope() for ModuleScopeQuery;\n+            fn fn_syntax() for FnSyntaxQuery;\n+            fn fn_scopes() for FnScopesQuery;\n         }\n         impl SyntaxPtrDatabase {\n             fn resolve_syntax_ptr() for ResolveSyntaxPtrQuery;"}, {"sha": "0a006f7331000df8f8607f915b19795ffb5211d4", "filename": "crates/ra_analysis/src/descriptors/function/imp.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fimp.rs?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -0,0 +1,26 @@\n+use std::sync::Arc;\n+\n+use ra_syntax::{\n+    ast::{AstNode, FnDef, FnDefNode},\n+};\n+\n+use crate::{\n+    descriptors::{\n+        DescriptorDatabase,\n+        function::{FnId, FnScopes},\n+    },\n+};\n+\n+/// Resolve `FnId` to the corresponding `SyntaxNode`\n+/// TODO: this should return something more type-safe then `SyntaxNode`\n+pub(crate) fn fn_syntax(db: &impl DescriptorDatabase, fn_id: FnId) -> FnDefNode {\n+    let syntax = db.resolve_syntax_ptr(fn_id.0);\n+    let fn_def = FnDef::cast(syntax.borrowed()).unwrap();\n+    FnDefNode::new(fn_def)\n+}\n+\n+pub(crate) fn fn_scopes(db: &impl DescriptorDatabase, fn_id: FnId) -> Arc<FnScopes> {\n+    let syntax = db.fn_syntax(fn_id);\n+    let res = FnScopes::new(syntax.ast());\n+    Arc::new(res)\n+}"}, {"sha": "687413ddcf13eb449da5ac1ae72727ae1637e6b9", "filename": "crates/ra_analysis/src/descriptors/function/mod.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fmod.rs?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -0,0 +1,83 @@\n+pub(super) mod imp;\n+mod scope;\n+\n+use ra_syntax::{\n+    ast::{self, AstNode, NameOwner}\n+};\n+\n+use crate::{\n+    FileId,\n+    syntax_ptr::SyntaxPtr\n+};\n+\n+pub(crate) use self::scope::FnScopes;\n+\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct FnId(SyntaxPtr);\n+\n+impl FnId {\n+    pub(crate) fn new(file_id: FileId, fn_def: ast::FnDef) -> FnId {\n+        let ptr = SyntaxPtr::new(file_id, fn_def.syntax());\n+        FnId(ptr)\n+    }\n+}\n+\n+\n+#[derive(Debug, Clone)]\n+pub struct FnDescriptor {\n+    pub name: String,\n+    pub label: String,\n+    pub ret_type: Option<String>,\n+    pub params: Vec<String>,\n+}\n+\n+impl FnDescriptor {\n+    pub fn new(node: ast::FnDef) -> Option<Self> {\n+        let name = node.name()?.text().to_string();\n+\n+        // Strip the body out for the label.\n+        let label: String = if let Some(body) = node.body() {\n+            let body_range = body.syntax().range();\n+            let label: String = node\n+                .syntax()\n+                .children()\n+                .filter(|child| !child.range().is_subrange(&body_range))\n+                .map(|node| node.text().to_string())\n+                .collect();\n+            label\n+        } else {\n+            node.syntax().text().to_string()\n+        };\n+\n+        let params = FnDescriptor::param_list(node);\n+        let ret_type = node.ret_type().map(|r| r.syntax().text().to_string());\n+\n+        Some(FnDescriptor {\n+            name,\n+            ret_type,\n+            params,\n+            label,\n+        })\n+    }\n+\n+    fn param_list(node: ast::FnDef) -> Vec<String> {\n+        let mut res = vec![];\n+        if let Some(param_list) = node.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                res.push(self_param.syntax().text().to_string())\n+            }\n+\n+            // Maybe use param.pat here? See if we can just extract the name?\n+            //res.extend(param_list.params().map(|p| p.syntax().text().to_string()));\n+            res.extend(\n+                param_list\n+                    .params()\n+                    .filter_map(|p| p.pat())\n+                    .map(|pat| pat.syntax().text().to_string()),\n+            );\n+        }\n+        res\n+    }\n+}\n+"}, {"sha": "5333a0a3bf8df469e9d4a74259a9cebd60cf5c30", "filename": "crates/ra_analysis/src/descriptors/function/scope.rs", "status": "added", "additions": 435, "deletions": 0, "changes": 435, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fscope.rs?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -0,0 +1,435 @@\n+use rustc_hash::FxHashMap;\n+\n+use ra_syntax::{\n+    algo::generate,\n+    ast::{self, ArgListOwner, LoopBodyOwner, NameOwner},\n+    AstNode, SmolStr, SyntaxNodeRef,\n+};\n+\n+use crate::syntax_ptr::LocalSyntaxPtr;\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub(crate) struct ScopeId(u32);\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct FnScopes {\n+    pub(crate) self_param: Option<LocalSyntaxPtr>,\n+    scopes: Vec<ScopeData>,\n+    scope_for: FxHashMap<LocalSyntaxPtr, ScopeId>,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ScopeEntry {\n+    name: SmolStr,\n+    ptr: LocalSyntaxPtr,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+struct ScopeData {\n+    parent: Option<ScopeId>,\n+    entries: Vec<ScopeEntry>,\n+}\n+\n+impl FnScopes {\n+    pub(crate) fn new(fn_def: ast::FnDef) -> FnScopes {\n+        let mut scopes = FnScopes {\n+            self_param: fn_def\n+                .param_list()\n+                .and_then(|it| it.self_param())\n+                .map(|it| LocalSyntaxPtr::new(it.syntax())),\n+            scopes: Vec::new(),\n+            scope_for: FxHashMap::default(),\n+        };\n+        let root = scopes.root_scope();\n+        scopes.add_params_bindings(root, fn_def.param_list());\n+        if let Some(body) = fn_def.body() {\n+            compute_block_scopes(body, &mut scopes, root)\n+        }\n+        scopes\n+    }\n+    pub(crate) fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n+        &self.get(scope).entries\n+    }\n+    pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item = ScopeId> + 'a {\n+        generate(self.scope_for(node), move |&scope| {\n+            self.get(scope).parent\n+        })\n+    }\n+    fn root_scope(&mut self) -> ScopeId {\n+        let res = ScopeId(self.scopes.len() as u32);\n+        self.scopes.push(ScopeData {\n+            parent: None,\n+            entries: vec![],\n+        });\n+        res\n+    }\n+    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n+        let res = ScopeId(self.scopes.len() as u32);\n+        self.scopes.push(ScopeData {\n+            parent: Some(parent),\n+            entries: vec![],\n+        });\n+        res\n+    }\n+    fn add_bindings(&mut self, scope: ScopeId, pat: ast::Pat) {\n+        let entries = pat\n+            .syntax()\n+            .descendants()\n+            .filter_map(ast::BindPat::cast)\n+            .filter_map(ScopeEntry::new);\n+        self.get_mut(scope).entries.extend(entries);\n+    }\n+    fn add_params_bindings(&mut self, scope: ScopeId, params: Option<ast::ParamList>) {\n+        params\n+            .into_iter()\n+            .flat_map(|it| it.params())\n+            .filter_map(|it| it.pat())\n+            .for_each(|it| self.add_bindings(scope, it));\n+    }\n+    fn set_scope(&mut self, node: SyntaxNodeRef, scope: ScopeId) {\n+        self.scope_for.insert(LocalSyntaxPtr::new(node), scope);\n+    }\n+    fn scope_for(&self, node: SyntaxNodeRef) -> Option<ScopeId> {\n+        node.ancestors()\n+            .map(LocalSyntaxPtr::new)\n+            .filter_map(|it| self.scope_for.get(&it).map(|&scope| scope))\n+            .next()\n+    }\n+    fn get(&self, scope: ScopeId) -> &ScopeData {\n+        &self.scopes[scope.0 as usize]\n+    }\n+    fn get_mut(&mut self, scope: ScopeId) -> &mut ScopeData {\n+        &mut self.scopes[scope.0 as usize]\n+    }\n+}\n+\n+impl ScopeEntry {\n+    fn new(pat: ast::BindPat) -> Option<ScopeEntry> {\n+        let name = pat.name()?;\n+        let res = ScopeEntry {\n+            name: name.text(),\n+            ptr: LocalSyntaxPtr::new(pat.syntax()),\n+        };\n+        Some(res)\n+    }\n+    pub(crate) fn name(&self) -> &SmolStr {\n+        &self.name\n+    }\n+    pub(crate) fn ptr(&self) -> LocalSyntaxPtr {\n+        self.ptr\n+    }\n+}\n+\n+fn compute_block_scopes(block: ast::Block, scopes: &mut FnScopes, mut scope: ScopeId) {\n+    for stmt in block.statements() {\n+        match stmt {\n+            ast::Stmt::LetStmt(stmt) => {\n+                if let Some(expr) = stmt.initializer() {\n+                    scopes.set_scope(expr.syntax(), scope);\n+                    compute_expr_scopes(expr, scopes, scope);\n+                }\n+                scope = scopes.new_scope(scope);\n+                if let Some(pat) = stmt.pat() {\n+                    scopes.add_bindings(scope, pat);\n+                }\n+            }\n+            ast::Stmt::ExprStmt(expr_stmt) => {\n+                if let Some(expr) = expr_stmt.expr() {\n+                    scopes.set_scope(expr.syntax(), scope);\n+                    compute_expr_scopes(expr, scopes, scope);\n+                }\n+            }\n+        }\n+    }\n+    if let Some(expr) = block.expr() {\n+        scopes.set_scope(expr.syntax(), scope);\n+        compute_expr_scopes(expr, scopes, scope);\n+    }\n+}\n+\n+fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n+    match expr {\n+        ast::Expr::IfExpr(e) => {\n+            let cond_scope = e\n+                .condition()\n+                .and_then(|cond| compute_cond_scopes(cond, scopes, scope));\n+            if let Some(block) = e.then_branch() {\n+                compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n+            }\n+            if let Some(block) = e.else_branch() {\n+                compute_block_scopes(block, scopes, scope);\n+            }\n+        }\n+        ast::Expr::BlockExpr(e) => {\n+            if let Some(block) = e.block() {\n+                compute_block_scopes(block, scopes, scope);\n+            }\n+        }\n+        ast::Expr::LoopExpr(e) => {\n+            if let Some(block) = e.loop_body() {\n+                compute_block_scopes(block, scopes, scope);\n+            }\n+        }\n+        ast::Expr::WhileExpr(e) => {\n+            let cond_scope = e\n+                .condition()\n+                .and_then(|cond| compute_cond_scopes(cond, scopes, scope));\n+            if let Some(block) = e.loop_body() {\n+                compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n+            }\n+        }\n+        ast::Expr::ForExpr(e) => {\n+            if let Some(expr) = e.iterable() {\n+                compute_expr_scopes(expr, scopes, scope);\n+            }\n+            let mut scope = scope;\n+            if let Some(pat) = e.pat() {\n+                scope = scopes.new_scope(scope);\n+                scopes.add_bindings(scope, pat);\n+            }\n+            if let Some(block) = e.loop_body() {\n+                compute_block_scopes(block, scopes, scope);\n+            }\n+        }\n+        ast::Expr::LambdaExpr(e) => {\n+            let scope = scopes.new_scope(scope);\n+            scopes.add_params_bindings(scope, e.param_list());\n+            if let Some(body) = e.body() {\n+                scopes.set_scope(body.syntax(), scope);\n+                compute_expr_scopes(body, scopes, scope);\n+            }\n+        }\n+        ast::Expr::CallExpr(e) => {\n+            compute_call_scopes(e.expr(), e.arg_list(), scopes, scope);\n+        }\n+        ast::Expr::MethodCallExpr(e) => {\n+            compute_call_scopes(e.expr(), e.arg_list(), scopes, scope);\n+        }\n+        ast::Expr::MatchExpr(e) => {\n+            if let Some(expr) = e.expr() {\n+                compute_expr_scopes(expr, scopes, scope);\n+            }\n+            for arm in e.match_arm_list().into_iter().flat_map(|it| it.arms()) {\n+                let scope = scopes.new_scope(scope);\n+                for pat in arm.pats() {\n+                    scopes.add_bindings(scope, pat);\n+                }\n+                if let Some(expr) = arm.expr() {\n+                    compute_expr_scopes(expr, scopes, scope);\n+                }\n+            }\n+        }\n+        _ => expr\n+            .syntax()\n+            .children()\n+            .filter_map(ast::Expr::cast)\n+            .for_each(|expr| compute_expr_scopes(expr, scopes, scope)),\n+    };\n+\n+    fn compute_call_scopes(\n+        receiver: Option<ast::Expr>,\n+        arg_list: Option<ast::ArgList>,\n+        scopes: &mut FnScopes,\n+        scope: ScopeId,\n+    ) {\n+        arg_list\n+            .into_iter()\n+            .flat_map(|it| it.args())\n+            .chain(receiver)\n+            .for_each(|expr| compute_expr_scopes(expr, scopes, scope));\n+    }\n+\n+    fn compute_cond_scopes(\n+        cond: ast::Condition,\n+        scopes: &mut FnScopes,\n+        scope: ScopeId,\n+    ) -> Option<ScopeId> {\n+        if let Some(expr) = cond.expr() {\n+            compute_expr_scopes(expr, scopes, scope);\n+        }\n+        if let Some(pat) = cond.pat() {\n+            let s = scopes.new_scope(scope);\n+            scopes.add_bindings(s, pat);\n+            Some(s)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+pub fn resolve_local_name<'a>(\n+    name_ref: ast::NameRef,\n+    scopes: &'a FnScopes,\n+) -> Option<&'a ScopeEntry> {\n+    use rustc_hash::FxHashSet;\n+\n+    let mut shadowed = FxHashSet::default();\n+    let ret = scopes\n+        .scope_chain(name_ref.syntax())\n+        .flat_map(|scope| scopes.entries(scope).iter())\n+        .filter(|entry| shadowed.insert(entry.name()))\n+        .filter(|entry| entry.name() == &name_ref.text())\n+        .nth(0);\n+    ret\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use ra_syntax::File;\n+    use test_utils::extract_offset;\n+    use ra_editor::{find_node_at_offset};\n+\n+    use super::*;\n+\n+\n+    fn do_check(code: &str, expected: &[&str]) {\n+        let (off, code) = extract_offset(code);\n+        let code = {\n+            let mut buf = String::new();\n+            let off = u32::from(off) as usize;\n+            buf.push_str(&code[..off]);\n+            buf.push_str(\"marker\");\n+            buf.push_str(&code[off..]);\n+            buf\n+        };\n+        let file = File::parse(&code);\n+        let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n+        let fn_def: ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let scopes = FnScopes::new(fn_def);\n+        let actual = scopes\n+            .scope_chain(marker.syntax())\n+            .flat_map(|scope| scopes.entries(scope))\n+            .map(|it| it.name())\n+            .collect::<Vec<_>>();\n+        assert_eq!(actual.as_slice(), expected);\n+    }\n+\n+    #[test]\n+    fn test_lambda_scope() {\n+        do_check(\n+            r\"\n+            fn quux(foo: i32) {\n+                let f = |bar, baz: i32| {\n+                    <|>\n+                };\n+            }\",\n+            &[\"bar\", \"baz\", \"foo\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_call_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                f(|x| <|> );\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_metod_call_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                z.f(|x| <|> );\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_loop_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                loop {\n+                    let x = ();\n+                    <|>\n+                };\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_match() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                match () {\n+                    Some(x) => {\n+                        <|>\n+                    }\n+                };\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_shadow_variable() {\n+        do_check(\n+            r\"\n+            fn foo(x: String) {\n+                let x : &str = &x<|>;\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    fn do_check_local_name(code: &str, expected_offset: u32) {\n+        let (off, code) = extract_offset(code);\n+        let file = File::parse(&code);\n+        let fn_def: ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n+\n+        let scopes = FnScopes::new(fn_def);\n+\n+        let local_name_entry = resolve_local_name(name_ref, &scopes).unwrap();\n+        let local_name = local_name_entry.ptr().resolve(&file);\n+        let expected_name =\n+            find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into()).unwrap();\n+        assert_eq!(local_name.range(), expected_name.syntax().range());\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name() {\n+        do_check_local_name(\n+            r#\"\n+            fn foo(x: i32, y: u32) {\n+                {\n+                    let z = x * 2;\n+                }\n+                {\n+                    let t = x<|> * 3;\n+                }\n+            }\"#,\n+            21,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name_declaration() {\n+        do_check_local_name(\n+            r#\"\n+            fn foo(x: String) {\n+                let x : &str = &x<|>;\n+            }\"#,\n+            21,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name_shadow() {\n+        do_check_local_name(\n+            r\"\n+        fn foo(x: String) {\n+            let x : &str = &x;\n+            x<|>\n+        }\",\n+            46,\n+        );\n+    }\n+}"}, {"sha": "0c4991757d28f82510f19761acbc1778eda3278b", "filename": "crates/ra_analysis/src/descriptors/mod.rs", "status": "modified", "additions": 36, "deletions": 52, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -1,62 +1,46 @@\n pub(crate) mod module;\n+pub(crate) mod function;\n+\n+use std::sync::Arc;\n \n use ra_syntax::{\n-    ast::{self, AstNode, NameOwner},\n+    SmolStr,\n+    ast::{FnDefNode},\n };\n \n-#[derive(Debug, Clone)]\n-pub struct FnDescriptor {\n-    pub name: String,\n-    pub label: String,\n-    pub ret_type: Option<String>,\n-    pub params: Vec<String>,\n-}\n-\n-impl FnDescriptor {\n-    pub fn new(node: ast::FnDef) -> Option<Self> {\n-        let name = node.name()?.text().to_string();\n-\n-        // Strip the body out for the label.\n-        let label: String = if let Some(body) = node.body() {\n-            let body_range = body.syntax().range();\n-            let label: String = node\n-                .syntax()\n-                .children()\n-                .filter(|child| !child.range().is_subrange(&body_range))\n-                .map(|node| node.text().to_string())\n-                .collect();\n-            label\n-        } else {\n-            node.syntax().text().to_string()\n-        };\n-\n-        let params = FnDescriptor::param_list(node);\n-        let ret_type = node.ret_type().map(|r| r.syntax().text().to_string());\n-\n-        Some(FnDescriptor {\n-            name,\n-            ret_type,\n-            params,\n-            label,\n-        })\n-    }\n+use crate::{\n+    FileId, Cancelable,\n+    db::SyntaxDatabase,\n+    descriptors::module::{ModuleTree, ModuleId, ModuleScope},\n+    descriptors::function::{FnId, FnScopes},\n+    input::SourceRootId,\n+    syntax_ptr::SyntaxPtrDatabase,\n+};\n \n-    fn param_list(node: ast::FnDef) -> Vec<String> {\n-        let mut res = vec![];\n-        if let Some(param_list) = node.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                res.push(self_param.syntax().text().to_string())\n-            }\n \n-            // Maybe use param.pat here? See if we can just extract the name?\n-            //res.extend(param_list.params().map(|p| p.syntax().text().to_string()));\n-            res.extend(\n-                param_list\n-                    .params()\n-                    .filter_map(|p| p.pat())\n-                    .map(|pat| pat.syntax().text().to_string()),\n-            );\n+salsa::query_group! {\n+    pub(crate) trait DescriptorDatabase: SyntaxDatabase + SyntaxPtrDatabase {\n+        fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n+            type ModuleTreeQuery;\n+            use fn module::imp::module_tree;\n+        }\n+        fn submodules(file_id: FileId) -> Cancelable<Arc<Vec<SmolStr>>> {\n+            type SubmodulesQuery;\n+            use fn module::imp::submodules;\n+        }\n+        fn module_scope(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<ModuleScope>> {\n+            type ModuleScopeQuery;\n+            use fn module::imp::module_scope;\n+        }\n+        fn fn_syntax(fn_id: FnId) -> FnDefNode {\n+            type FnSyntaxQuery;\n+            // Don't retain syntax trees in memory\n+            storage volatile;\n+            use fn function::imp::fn_syntax;\n+        }\n+        fn fn_scopes(fn_id: FnId) -> Arc<FnScopes> {\n+            type FnScopesQuery;\n+            use fn function::imp::fn_scopes;\n         }\n-        res\n     }\n }"}, {"sha": "dae3a356d4cdb972cdd61e627ff4f82d868f4794", "filename": "crates/ra_analysis/src/descriptors/module/imp.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -10,22 +10,23 @@ use ra_syntax::{\n use crate::{\n     FileId, Cancelable, FileResolverImp, db,\n     input::{SourceRoot, SourceRootId},\n+    descriptors::DescriptorDatabase,\n };\n \n use super::{\n-    ModuleData, ModuleTree, ModuleId, LinkId, LinkData, Problem, ModulesDatabase, ModuleScope\n+    ModuleData, ModuleTree, ModuleId, LinkId, LinkData, Problem, ModuleScope\n };\n \n \n-pub(super) fn submodules(db: &impl ModulesDatabase, file_id: FileId) -> Cancelable<Arc<Vec<SmolStr>>> {\n+pub(crate) fn submodules(db: &impl DescriptorDatabase, file_id: FileId) -> Cancelable<Arc<Vec<SmolStr>>> {\n     db::check_canceled(db)?;\n     let file = db.file_syntax(file_id);\n     let root = file.ast();\n     let submodules = modules(root).map(|(name, _)| name).collect();\n     Ok(Arc::new(submodules))\n }\n \n-pub(super) fn modules(root: ast::Root<'_>) -> impl Iterator<Item = (SmolStr, ast::Module<'_>)> {\n+pub(crate) fn modules(root: ast::Root<'_>) -> impl Iterator<Item = (SmolStr, ast::Module<'_>)> {\n     root.modules().filter_map(|module| {\n         let name = module.name()?.text();\n         if !module.has_semi() {\n@@ -35,8 +36,8 @@ pub(super) fn modules(root: ast::Root<'_>) -> impl Iterator<Item = (SmolStr, ast\n     })\n }\n \n-pub(super) fn module_scope(\n-    db: &impl ModulesDatabase,\n+pub(crate) fn module_scope(\n+    db: &impl DescriptorDatabase,\n     source_root_id: SourceRootId,\n     module_id: ModuleId,\n ) -> Cancelable<Arc<ModuleScope>> {\n@@ -47,8 +48,8 @@ pub(super) fn module_scope(\n     Ok(Arc::new(res))\n }\n \n-pub(super) fn module_tree(\n-    db: &impl ModulesDatabase,\n+pub(crate) fn module_tree(\n+    db: &impl DescriptorDatabase,\n     source_root: SourceRootId,\n ) -> Cancelable<Arc<ModuleTree>> {\n     db::check_canceled(db)?;\n@@ -64,7 +65,7 @@ pub struct Submodule {\n \n \n fn create_module_tree<'a>(\n-    db: &impl ModulesDatabase,\n+    db: &impl DescriptorDatabase,\n     source_root: SourceRootId,\n ) -> Cancelable<ModuleTree> {\n     let mut tree = ModuleTree {\n@@ -88,7 +89,7 @@ fn create_module_tree<'a>(\n }\n \n fn build_subtree(\n-    db: &impl ModulesDatabase,\n+    db: &impl DescriptorDatabase,\n     source_root: &SourceRoot,\n     tree: &mut ModuleTree,\n     visited: &mut FxHashSet<FileId>,"}, {"sha": "667553f74960ab73284e952a96f1bf711bab7208", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -1,37 +1,13 @@\n-mod imp;\n+pub(super) mod imp;\n pub(crate) mod scope;\n \n-use std::sync::Arc;\n-\n use relative_path::RelativePathBuf;\n use ra_syntax::{ast::{self, NameOwner, AstNode}, SmolStr, SyntaxNode};\n \n-use crate::{\n-    FileId, Cancelable,\n-    db::SyntaxDatabase,\n-    input::SourceRootId,\n-};\n+use crate::FileId;\n \n pub(crate) use self::scope::ModuleScope;\n \n-salsa::query_group! {\n-    pub(crate) trait ModulesDatabase: SyntaxDatabase {\n-        fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n-            type ModuleTreeQuery;\n-            use fn imp::module_tree;\n-        }\n-        fn submodules(file_id: FileId) -> Cancelable<Arc<Vec<SmolStr>>> {\n-            type SubmodulesQuery;\n-            use fn imp::submodules;\n-        }\n-        fn module_scope(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<ModuleScope>> {\n-            type ModuleScopeQuery;\n-            use fn imp::module_scope;\n-        }\n-    }\n-}\n-\n-\n #[derive(Debug, PartialEq, Eq, Hash)]\n pub(crate) struct ModuleTree {\n     mods: Vec<ModuleData>,"}, {"sha": "0f8f325abdeebfb96d118ad4b92a5c16afdd64f8", "filename": "crates/ra_analysis/src/descriptors/module/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -2,8 +2,8 @@\n \n \n use ra_syntax::{\n-    ast::{self, AstChildren, ModuleItemOwner},\n-    File, AstNode, SmolStr, SyntaxNode, SyntaxNodeRef,\n+    ast::{self, ModuleItemOwner},\n+    File, AstNode, SmolStr,\n };\n \n use crate::syntax_ptr::LocalSyntaxPtr;\n@@ -99,7 +99,7 @@ fn collect_imports(tree: ast::UseTree, acc: &mut Vec<Entry>) {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use ra_syntax::{ast::ModuleItemOwner, File};\n+    use ra_syntax::{File};\n \n     fn do_check(code: &str, expected: &[&str]) {\n         let file = File::parse(&code);"}, {"sha": "49b693ae8c0d9267f7ced20a51ae3b6dd3aa7218", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -21,8 +21,9 @@ use crate::{\n         self, SyntaxDatabase, FileSyntaxQuery,\n     },\n     input::{SourceRootId, FilesDatabase, SourceRoot, WORKSPACE},\n-    descriptors::module::{ModulesDatabase, ModuleTree, Problem},\n-    descriptors::{FnDescriptor},\n+    descriptors::DescriptorDatabase,\n+    descriptors::module::{ModuleTree, Problem},\n+    descriptors::function::{FnDescriptor},\n     symbol_index::SymbolIndex,\n     CrateGraph, CrateId, Diagnostic, FileId, FileResolver, FileSystemEdit, Position,\n     Query, SourceChange, SourceFileEdit, Cancelable,"}, {"sha": "a77c9a5fa15575860474bb08ae7df64038671632", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -29,7 +29,7 @@ use crate::{\n };\n \n pub use crate::{\n-    descriptors::FnDescriptor,\n+    descriptors::function::FnDescriptor,\n     input::{FileId, FileResolver, CrateGraph, CrateId}\n };\n pub use ra_editor::{"}, {"sha": "aee214318c4cb4fcce213fa51d1bee8ffa1985a2", "filename": "crates/ra_analysis/src/syntax_ptr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -12,6 +12,7 @@ salsa::query_group! {\n     pub(crate) trait SyntaxPtrDatabase: SyntaxDatabase {\n         fn resolve_syntax_ptr(ptr: SyntaxPtr) -> SyntaxNode {\n             type ResolveSyntaxPtrQuery;\n+            // Don't retain syntax trees in memory\n             storage volatile;\n         }\n     }"}, {"sha": "f5c113fd9c5c7ced2660717a3ba63e32695907d0", "filename": "crates/ra_editor/src/scope/fn_scope.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_editor%2Fsrc%2Fscope%2Ffn_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_editor%2Fsrc%2Fscope%2Ffn_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fscope%2Ffn_scope.rs?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -83,6 +83,7 @@ impl FnScopes {\n     }\n }\n \n+#[derive(PartialEq, Eq)]\n pub struct ScopeEntry {\n     syntax: SyntaxNode,\n }\n@@ -251,7 +252,7 @@ fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq)]\n struct ScopeData {\n     parent: Option<ScopeId>,\n     entries: Vec<ScopeEntry>,"}, {"sha": "d0cd060d301181d2bf012dc04030d2dbb7b72021", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 99, "deletions": 99, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -15,7 +15,7 @@ use crate::{\n pub struct ArgListNode(SyntaxNode);\n \n impl ArgListNode {\n-    pub fn new(&self, ast: ArgList) -> ArgListNode {\n+    pub fn new(ast: ArgList) -> ArgListNode {\n         let syntax = ast.syntax().owned();\n         ArgListNode(syntax)\n     }\n@@ -50,7 +50,7 @@ impl<'a> ArgList<'a> {\n pub struct ArrayExprNode(SyntaxNode);\n \n impl ArrayExprNode {\n-    pub fn new(&self, ast: ArrayExpr) -> ArrayExprNode {\n+    pub fn new(ast: ArrayExpr) -> ArrayExprNode {\n         let syntax = ast.syntax().owned();\n         ArrayExprNode(syntax)\n     }\n@@ -81,7 +81,7 @@ impl<'a> ArrayExpr<'a> {}\n pub struct ArrayTypeNode(SyntaxNode);\n \n impl ArrayTypeNode {\n-    pub fn new(&self, ast: ArrayType) -> ArrayTypeNode {\n+    pub fn new(ast: ArrayType) -> ArrayTypeNode {\n         let syntax = ast.syntax().owned();\n         ArrayTypeNode(syntax)\n     }\n@@ -112,7 +112,7 @@ impl<'a> ArrayType<'a> {}\n pub struct AttrNode(SyntaxNode);\n \n impl AttrNode {\n-    pub fn new(&self, ast: Attr) -> AttrNode {\n+    pub fn new(ast: Attr) -> AttrNode {\n         let syntax = ast.syntax().owned();\n         AttrNode(syntax)\n     }\n@@ -147,7 +147,7 @@ impl<'a> Attr<'a> {\n pub struct BinExprNode(SyntaxNode);\n \n impl BinExprNode {\n-    pub fn new(&self, ast: BinExpr) -> BinExprNode {\n+    pub fn new(ast: BinExpr) -> BinExprNode {\n         let syntax = ast.syntax().owned();\n         BinExprNode(syntax)\n     }\n@@ -178,7 +178,7 @@ impl<'a> BinExpr<'a> {}\n pub struct BindPatNode(SyntaxNode);\n \n impl BindPatNode {\n-    pub fn new(&self, ast: BindPat) -> BindPatNode {\n+    pub fn new(ast: BindPat) -> BindPatNode {\n         let syntax = ast.syntax().owned();\n         BindPatNode(syntax)\n     }\n@@ -210,7 +210,7 @@ impl<'a> BindPat<'a> {}\n pub struct BlockNode(SyntaxNode);\n \n impl BlockNode {\n-    pub fn new(&self, ast: Block) -> BlockNode {\n+    pub fn new(ast: Block) -> BlockNode {\n         let syntax = ast.syntax().owned();\n         BlockNode(syntax)\n     }\n@@ -249,7 +249,7 @@ impl<'a> Block<'a> {\n pub struct BlockExprNode(SyntaxNode);\n \n impl BlockExprNode {\n-    pub fn new(&self, ast: BlockExpr) -> BlockExprNode {\n+    pub fn new(ast: BlockExpr) -> BlockExprNode {\n         let syntax = ast.syntax().owned();\n         BlockExprNode(syntax)\n     }\n@@ -284,7 +284,7 @@ impl<'a> BlockExpr<'a> {\n pub struct BreakExprNode(SyntaxNode);\n \n impl BreakExprNode {\n-    pub fn new(&self, ast: BreakExpr) -> BreakExprNode {\n+    pub fn new(ast: BreakExpr) -> BreakExprNode {\n         let syntax = ast.syntax().owned();\n         BreakExprNode(syntax)\n     }\n@@ -315,7 +315,7 @@ impl<'a> BreakExpr<'a> {}\n pub struct CallExprNode(SyntaxNode);\n \n impl CallExprNode {\n-    pub fn new(&self, ast: CallExpr) -> CallExprNode {\n+    pub fn new(ast: CallExpr) -> CallExprNode {\n         let syntax = ast.syntax().owned();\n         CallExprNode(syntax)\n     }\n@@ -351,7 +351,7 @@ impl<'a> CallExpr<'a> {\n pub struct CastExprNode(SyntaxNode);\n \n impl CastExprNode {\n-    pub fn new(&self, ast: CastExpr) -> CastExprNode {\n+    pub fn new(ast: CastExpr) -> CastExprNode {\n         let syntax = ast.syntax().owned();\n         CastExprNode(syntax)\n     }\n@@ -382,7 +382,7 @@ impl<'a> CastExpr<'a> {}\n pub struct CommentNode(SyntaxNode);\n \n impl CommentNode {\n-    pub fn new(&self, ast: Comment) -> CommentNode {\n+    pub fn new(ast: Comment) -> CommentNode {\n         let syntax = ast.syntax().owned();\n         CommentNode(syntax)\n     }\n@@ -413,7 +413,7 @@ impl<'a> Comment<'a> {}\n pub struct ConditionNode(SyntaxNode);\n \n impl ConditionNode {\n-    pub fn new(&self, ast: Condition) -> ConditionNode {\n+    pub fn new(ast: Condition) -> ConditionNode {\n         let syntax = ast.syntax().owned();\n         ConditionNode(syntax)\n     }\n@@ -452,7 +452,7 @@ impl<'a> Condition<'a> {\n pub struct ConstDefNode(SyntaxNode);\n \n impl ConstDefNode {\n-    pub fn new(&self, ast: ConstDef) -> ConstDefNode {\n+    pub fn new(ast: ConstDef) -> ConstDefNode {\n         let syntax = ast.syntax().owned();\n         ConstDefNode(syntax)\n     }\n@@ -486,7 +486,7 @@ impl<'a> ConstDef<'a> {}\n pub struct ContinueExprNode(SyntaxNode);\n \n impl ContinueExprNode {\n-    pub fn new(&self, ast: ContinueExpr) -> ContinueExprNode {\n+    pub fn new(ast: ContinueExpr) -> ContinueExprNode {\n         let syntax = ast.syntax().owned();\n         ContinueExprNode(syntax)\n     }\n@@ -517,7 +517,7 @@ impl<'a> ContinueExpr<'a> {}\n pub struct DynTraitTypeNode(SyntaxNode);\n \n impl DynTraitTypeNode {\n-    pub fn new(&self, ast: DynTraitType) -> DynTraitTypeNode {\n+    pub fn new(ast: DynTraitType) -> DynTraitTypeNode {\n         let syntax = ast.syntax().owned();\n         DynTraitTypeNode(syntax)\n     }\n@@ -548,7 +548,7 @@ impl<'a> DynTraitType<'a> {}\n pub struct EnumDefNode(SyntaxNode);\n \n impl EnumDefNode {\n-    pub fn new(&self, ast: EnumDef) -> EnumDefNode {\n+    pub fn new(ast: EnumDef) -> EnumDefNode {\n         let syntax = ast.syntax().owned();\n         EnumDefNode(syntax)\n     }\n@@ -582,7 +582,7 @@ impl<'a> EnumDef<'a> {}\n pub struct ExprNode(SyntaxNode);\n \n impl ExprNode {\n-    pub fn new(&self, ast: Expr) -> ExprNode {\n+    pub fn new(ast: Expr) -> ExprNode {\n         let syntax = ast.syntax().owned();\n         ExprNode(syntax)\n     }\n@@ -710,7 +710,7 @@ impl<'a> Expr<'a> {}\n pub struct ExprStmtNode(SyntaxNode);\n \n impl ExprStmtNode {\n-    pub fn new(&self, ast: ExprStmt) -> ExprStmtNode {\n+    pub fn new(ast: ExprStmt) -> ExprStmtNode {\n         let syntax = ast.syntax().owned();\n         ExprStmtNode(syntax)\n     }\n@@ -745,7 +745,7 @@ impl<'a> ExprStmt<'a> {\n pub struct ExternCrateItemNode(SyntaxNode);\n \n impl ExternCrateItemNode {\n-    pub fn new(&self, ast: ExternCrateItem) -> ExternCrateItemNode {\n+    pub fn new(ast: ExternCrateItem) -> ExternCrateItemNode {\n         let syntax = ast.syntax().owned();\n         ExternCrateItemNode(syntax)\n     }\n@@ -776,7 +776,7 @@ impl<'a> ExternCrateItem<'a> {}\n pub struct FieldExprNode(SyntaxNode);\n \n impl FieldExprNode {\n-    pub fn new(&self, ast: FieldExpr) -> FieldExprNode {\n+    pub fn new(ast: FieldExpr) -> FieldExprNode {\n         let syntax = ast.syntax().owned();\n         FieldExprNode(syntax)\n     }\n@@ -807,7 +807,7 @@ impl<'a> FieldExpr<'a> {}\n pub struct FieldPatListNode(SyntaxNode);\n \n impl FieldPatListNode {\n-    pub fn new(&self, ast: FieldPatList) -> FieldPatListNode {\n+    pub fn new(ast: FieldPatList) -> FieldPatListNode {\n         let syntax = ast.syntax().owned();\n         FieldPatListNode(syntax)\n     }\n@@ -838,7 +838,7 @@ impl<'a> FieldPatList<'a> {}\n pub struct FnDefNode(SyntaxNode);\n \n impl FnDefNode {\n-    pub fn new(&self, ast: FnDef) -> FnDefNode {\n+    pub fn new(ast: FnDef) -> FnDefNode {\n         let syntax = ast.syntax().owned();\n         FnDefNode(syntax)\n     }\n@@ -884,7 +884,7 @@ impl<'a> FnDef<'a> {\n pub struct FnPointerTypeNode(SyntaxNode);\n \n impl FnPointerTypeNode {\n-    pub fn new(&self, ast: FnPointerType) -> FnPointerTypeNode {\n+    pub fn new(ast: FnPointerType) -> FnPointerTypeNode {\n         let syntax = ast.syntax().owned();\n         FnPointerTypeNode(syntax)\n     }\n@@ -915,7 +915,7 @@ impl<'a> FnPointerType<'a> {}\n pub struct ForExprNode(SyntaxNode);\n \n impl ForExprNode {\n-    pub fn new(&self, ast: ForExpr) -> ForExprNode {\n+    pub fn new(ast: ForExpr) -> ForExprNode {\n         let syntax = ast.syntax().owned();\n         ForExprNode(syntax)\n     }\n@@ -955,7 +955,7 @@ impl<'a> ForExpr<'a> {\n pub struct ForTypeNode(SyntaxNode);\n \n impl ForTypeNode {\n-    pub fn new(&self, ast: ForType) -> ForTypeNode {\n+    pub fn new(ast: ForType) -> ForTypeNode {\n         let syntax = ast.syntax().owned();\n         ForTypeNode(syntax)\n     }\n@@ -986,7 +986,7 @@ impl<'a> ForType<'a> {}\n pub struct IfExprNode(SyntaxNode);\n \n impl IfExprNode {\n-    pub fn new(&self, ast: IfExpr) -> IfExprNode {\n+    pub fn new(ast: IfExpr) -> IfExprNode {\n         let syntax = ast.syntax().owned();\n         IfExprNode(syntax)\n     }\n@@ -1021,7 +1021,7 @@ impl<'a> IfExpr<'a> {\n pub struct ImplItemNode(SyntaxNode);\n \n impl ImplItemNode {\n-    pub fn new(&self, ast: ImplItem) -> ImplItemNode {\n+    pub fn new(ast: ImplItem) -> ImplItemNode {\n         let syntax = ast.syntax().owned();\n         ImplItemNode(syntax)\n     }\n@@ -1052,7 +1052,7 @@ impl<'a> ImplItem<'a> {}\n pub struct ImplTraitTypeNode(SyntaxNode);\n \n impl ImplTraitTypeNode {\n-    pub fn new(&self, ast: ImplTraitType) -> ImplTraitTypeNode {\n+    pub fn new(ast: ImplTraitType) -> ImplTraitTypeNode {\n         let syntax = ast.syntax().owned();\n         ImplTraitTypeNode(syntax)\n     }\n@@ -1083,7 +1083,7 @@ impl<'a> ImplTraitType<'a> {}\n pub struct IndexExprNode(SyntaxNode);\n \n impl IndexExprNode {\n-    pub fn new(&self, ast: IndexExpr) -> IndexExprNode {\n+    pub fn new(ast: IndexExpr) -> IndexExprNode {\n         let syntax = ast.syntax().owned();\n         IndexExprNode(syntax)\n     }\n@@ -1114,7 +1114,7 @@ impl<'a> IndexExpr<'a> {}\n pub struct ItemListNode(SyntaxNode);\n \n impl ItemListNode {\n-    pub fn new(&self, ast: ItemList) -> ItemListNode {\n+    pub fn new(ast: ItemList) -> ItemListNode {\n         let syntax = ast.syntax().owned();\n         ItemListNode(syntax)\n     }\n@@ -1147,7 +1147,7 @@ impl<'a> ItemList<'a> {}\n pub struct LabelNode(SyntaxNode);\n \n impl LabelNode {\n-    pub fn new(&self, ast: Label) -> LabelNode {\n+    pub fn new(ast: Label) -> LabelNode {\n         let syntax = ast.syntax().owned();\n         LabelNode(syntax)\n     }\n@@ -1178,7 +1178,7 @@ impl<'a> Label<'a> {}\n pub struct LambdaExprNode(SyntaxNode);\n \n impl LambdaExprNode {\n-    pub fn new(&self, ast: LambdaExpr) -> LambdaExprNode {\n+    pub fn new(ast: LambdaExpr) -> LambdaExprNode {\n         let syntax = ast.syntax().owned();\n         LambdaExprNode(syntax)\n     }\n@@ -1217,7 +1217,7 @@ impl<'a> LambdaExpr<'a> {\n pub struct LetStmtNode(SyntaxNode);\n \n impl LetStmtNode {\n-    pub fn new(&self, ast: LetStmt) -> LetStmtNode {\n+    pub fn new(ast: LetStmt) -> LetStmtNode {\n         let syntax = ast.syntax().owned();\n         LetStmtNode(syntax)\n     }\n@@ -1256,7 +1256,7 @@ impl<'a> LetStmt<'a> {\n pub struct LifetimeNode(SyntaxNode);\n \n impl LifetimeNode {\n-    pub fn new(&self, ast: Lifetime) -> LifetimeNode {\n+    pub fn new(ast: Lifetime) -> LifetimeNode {\n         let syntax = ast.syntax().owned();\n         LifetimeNode(syntax)\n     }\n@@ -1287,7 +1287,7 @@ impl<'a> Lifetime<'a> {}\n pub struct LifetimeParamNode(SyntaxNode);\n \n impl LifetimeParamNode {\n-    pub fn new(&self, ast: LifetimeParam) -> LifetimeParamNode {\n+    pub fn new(ast: LifetimeParam) -> LifetimeParamNode {\n         let syntax = ast.syntax().owned();\n         LifetimeParamNode(syntax)\n     }\n@@ -1322,7 +1322,7 @@ impl<'a> LifetimeParam<'a> {\n pub struct LiteralNode(SyntaxNode);\n \n impl LiteralNode {\n-    pub fn new(&self, ast: Literal) -> LiteralNode {\n+    pub fn new(ast: Literal) -> LiteralNode {\n         let syntax = ast.syntax().owned();\n         LiteralNode(syntax)\n     }\n@@ -1353,7 +1353,7 @@ impl<'a> Literal<'a> {}\n pub struct LoopExprNode(SyntaxNode);\n \n impl LoopExprNode {\n-    pub fn new(&self, ast: LoopExpr) -> LoopExprNode {\n+    pub fn new(ast: LoopExpr) -> LoopExprNode {\n         let syntax = ast.syntax().owned();\n         LoopExprNode(syntax)\n     }\n@@ -1385,7 +1385,7 @@ impl<'a> LoopExpr<'a> {}\n pub struct MatchArmNode(SyntaxNode);\n \n impl MatchArmNode {\n-    pub fn new(&self, ast: MatchArm) -> MatchArmNode {\n+    pub fn new(ast: MatchArm) -> MatchArmNode {\n         let syntax = ast.syntax().owned();\n         MatchArmNode(syntax)\n     }\n@@ -1428,7 +1428,7 @@ impl<'a> MatchArm<'a> {\n pub struct MatchArmListNode(SyntaxNode);\n \n impl MatchArmListNode {\n-    pub fn new(&self, ast: MatchArmList) -> MatchArmListNode {\n+    pub fn new(ast: MatchArmList) -> MatchArmListNode {\n         let syntax = ast.syntax().owned();\n         MatchArmListNode(syntax)\n     }\n@@ -1463,7 +1463,7 @@ impl<'a> MatchArmList<'a> {\n pub struct MatchExprNode(SyntaxNode);\n \n impl MatchExprNode {\n-    pub fn new(&self, ast: MatchExpr) -> MatchExprNode {\n+    pub fn new(ast: MatchExpr) -> MatchExprNode {\n         let syntax = ast.syntax().owned();\n         MatchExprNode(syntax)\n     }\n@@ -1502,7 +1502,7 @@ impl<'a> MatchExpr<'a> {\n pub struct MatchGuardNode(SyntaxNode);\n \n impl MatchGuardNode {\n-    pub fn new(&self, ast: MatchGuard) -> MatchGuardNode {\n+    pub fn new(ast: MatchGuard) -> MatchGuardNode {\n         let syntax = ast.syntax().owned();\n         MatchGuardNode(syntax)\n     }\n@@ -1533,7 +1533,7 @@ impl<'a> MatchGuard<'a> {}\n pub struct MethodCallExprNode(SyntaxNode);\n \n impl MethodCallExprNode {\n-    pub fn new(&self, ast: MethodCallExpr) -> MethodCallExprNode {\n+    pub fn new(ast: MethodCallExpr) -> MethodCallExprNode {\n         let syntax = ast.syntax().owned();\n         MethodCallExprNode(syntax)\n     }\n@@ -1569,7 +1569,7 @@ impl<'a> MethodCallExpr<'a> {\n pub struct ModuleNode(SyntaxNode);\n \n impl ModuleNode {\n-    pub fn new(&self, ast: Module) -> ModuleNode {\n+    pub fn new(ast: Module) -> ModuleNode {\n         let syntax = ast.syntax().owned();\n         ModuleNode(syntax)\n     }\n@@ -1606,7 +1606,7 @@ impl<'a> Module<'a> {\n pub struct ModuleItemNode(SyntaxNode);\n \n impl ModuleItemNode {\n-    pub fn new(&self, ast: ModuleItem) -> ModuleItemNode {\n+    pub fn new(ast: ModuleItem) -> ModuleItemNode {\n         let syntax = ast.syntax().owned();\n         ModuleItemNode(syntax)\n     }\n@@ -1671,7 +1671,7 @@ impl<'a> ModuleItem<'a> {}\n pub struct NameNode(SyntaxNode);\n \n impl NameNode {\n-    pub fn new(&self, ast: Name) -> NameNode {\n+    pub fn new(ast: Name) -> NameNode {\n         let syntax = ast.syntax().owned();\n         NameNode(syntax)\n     }\n@@ -1702,7 +1702,7 @@ impl<'a> Name<'a> {}\n pub struct NameRefNode(SyntaxNode);\n \n impl NameRefNode {\n-    pub fn new(&self, ast: NameRef) -> NameRefNode {\n+    pub fn new(ast: NameRef) -> NameRefNode {\n         let syntax = ast.syntax().owned();\n         NameRefNode(syntax)\n     }\n@@ -1733,7 +1733,7 @@ impl<'a> NameRef<'a> {}\n pub struct NamedFieldNode(SyntaxNode);\n \n impl NamedFieldNode {\n-    pub fn new(&self, ast: NamedField) -> NamedFieldNode {\n+    pub fn new(ast: NamedField) -> NamedFieldNode {\n         let syntax = ast.syntax().owned();\n         NamedFieldNode(syntax)\n     }\n@@ -1764,7 +1764,7 @@ impl<'a> NamedField<'a> {}\n pub struct NamedFieldDefNode(SyntaxNode);\n \n impl NamedFieldDefNode {\n-    pub fn new(&self, ast: NamedFieldDef) -> NamedFieldDefNode {\n+    pub fn new(ast: NamedFieldDef) -> NamedFieldDefNode {\n         let syntax = ast.syntax().owned();\n         NamedFieldDefNode(syntax)\n     }\n@@ -1797,7 +1797,7 @@ impl<'a> NamedFieldDef<'a> {}\n pub struct NamedFieldListNode(SyntaxNode);\n \n impl NamedFieldListNode {\n-    pub fn new(&self, ast: NamedFieldList) -> NamedFieldListNode {\n+    pub fn new(ast: NamedFieldList) -> NamedFieldListNode {\n         let syntax = ast.syntax().owned();\n         NamedFieldListNode(syntax)\n     }\n@@ -1828,7 +1828,7 @@ impl<'a> NamedFieldList<'a> {}\n pub struct NeverTypeNode(SyntaxNode);\n \n impl NeverTypeNode {\n-    pub fn new(&self, ast: NeverType) -> NeverTypeNode {\n+    pub fn new(ast: NeverType) -> NeverTypeNode {\n         let syntax = ast.syntax().owned();\n         NeverTypeNode(syntax)\n     }\n@@ -1859,7 +1859,7 @@ impl<'a> NeverType<'a> {}\n pub struct NominalDefNode(SyntaxNode);\n \n impl NominalDefNode {\n-    pub fn new(&self, ast: NominalDef) -> NominalDefNode {\n+    pub fn new(ast: NominalDef) -> NominalDefNode {\n         let syntax = ast.syntax().owned();\n         NominalDefNode(syntax)\n     }\n@@ -1900,7 +1900,7 @@ impl<'a> NominalDef<'a> {}\n pub struct ParamNode(SyntaxNode);\n \n impl ParamNode {\n-    pub fn new(&self, ast: Param) -> ParamNode {\n+    pub fn new(ast: Param) -> ParamNode {\n         let syntax = ast.syntax().owned();\n         ParamNode(syntax)\n     }\n@@ -1935,7 +1935,7 @@ impl<'a> Param<'a> {\n pub struct ParamListNode(SyntaxNode);\n \n impl ParamListNode {\n-    pub fn new(&self, ast: ParamList) -> ParamListNode {\n+    pub fn new(ast: ParamList) -> ParamListNode {\n         let syntax = ast.syntax().owned();\n         ParamListNode(syntax)\n     }\n@@ -1974,7 +1974,7 @@ impl<'a> ParamList<'a> {\n pub struct ParenExprNode(SyntaxNode);\n \n impl ParenExprNode {\n-    pub fn new(&self, ast: ParenExpr) -> ParenExprNode {\n+    pub fn new(ast: ParenExpr) -> ParenExprNode {\n         let syntax = ast.syntax().owned();\n         ParenExprNode(syntax)\n     }\n@@ -2005,7 +2005,7 @@ impl<'a> ParenExpr<'a> {}\n pub struct ParenTypeNode(SyntaxNode);\n \n impl ParenTypeNode {\n-    pub fn new(&self, ast: ParenType) -> ParenTypeNode {\n+    pub fn new(ast: ParenType) -> ParenTypeNode {\n         let syntax = ast.syntax().owned();\n         ParenTypeNode(syntax)\n     }\n@@ -2036,7 +2036,7 @@ impl<'a> ParenType<'a> {}\n pub struct PatNode(SyntaxNode);\n \n impl PatNode {\n-    pub fn new(&self, ast: Pat) -> PatNode {\n+    pub fn new(ast: Pat) -> PatNode {\n         let syntax = ast.syntax().owned();\n         PatNode(syntax)\n     }\n@@ -2098,7 +2098,7 @@ impl<'a> Pat<'a> {}\n pub struct PathNode(SyntaxNode);\n \n impl PathNode {\n-    pub fn new(&self, ast: Path) -> PathNode {\n+    pub fn new(ast: Path) -> PathNode {\n         let syntax = ast.syntax().owned();\n         PathNode(syntax)\n     }\n@@ -2137,7 +2137,7 @@ impl<'a> Path<'a> {\n pub struct PathExprNode(SyntaxNode);\n \n impl PathExprNode {\n-    pub fn new(&self, ast: PathExpr) -> PathExprNode {\n+    pub fn new(ast: PathExpr) -> PathExprNode {\n         let syntax = ast.syntax().owned();\n         PathExprNode(syntax)\n     }\n@@ -2172,7 +2172,7 @@ impl<'a> PathExpr<'a> {\n pub struct PathPatNode(SyntaxNode);\n \n impl PathPatNode {\n-    pub fn new(&self, ast: PathPat) -> PathPatNode {\n+    pub fn new(ast: PathPat) -> PathPatNode {\n         let syntax = ast.syntax().owned();\n         PathPatNode(syntax)\n     }\n@@ -2203,7 +2203,7 @@ impl<'a> PathPat<'a> {}\n pub struct PathSegmentNode(SyntaxNode);\n \n impl PathSegmentNode {\n-    pub fn new(&self, ast: PathSegment) -> PathSegmentNode {\n+    pub fn new(ast: PathSegment) -> PathSegmentNode {\n         let syntax = ast.syntax().owned();\n         PathSegmentNode(syntax)\n     }\n@@ -2238,7 +2238,7 @@ impl<'a> PathSegment<'a> {\n pub struct PathTypeNode(SyntaxNode);\n \n impl PathTypeNode {\n-    pub fn new(&self, ast: PathType) -> PathTypeNode {\n+    pub fn new(ast: PathType) -> PathTypeNode {\n         let syntax = ast.syntax().owned();\n         PathTypeNode(syntax)\n     }\n@@ -2269,7 +2269,7 @@ impl<'a> PathType<'a> {}\n pub struct PlaceholderPatNode(SyntaxNode);\n \n impl PlaceholderPatNode {\n-    pub fn new(&self, ast: PlaceholderPat) -> PlaceholderPatNode {\n+    pub fn new(ast: PlaceholderPat) -> PlaceholderPatNode {\n         let syntax = ast.syntax().owned();\n         PlaceholderPatNode(syntax)\n     }\n@@ -2300,7 +2300,7 @@ impl<'a> PlaceholderPat<'a> {}\n pub struct PlaceholderTypeNode(SyntaxNode);\n \n impl PlaceholderTypeNode {\n-    pub fn new(&self, ast: PlaceholderType) -> PlaceholderTypeNode {\n+    pub fn new(ast: PlaceholderType) -> PlaceholderTypeNode {\n         let syntax = ast.syntax().owned();\n         PlaceholderTypeNode(syntax)\n     }\n@@ -2331,7 +2331,7 @@ impl<'a> PlaceholderType<'a> {}\n pub struct PointerTypeNode(SyntaxNode);\n \n impl PointerTypeNode {\n-    pub fn new(&self, ast: PointerType) -> PointerTypeNode {\n+    pub fn new(ast: PointerType) -> PointerTypeNode {\n         let syntax = ast.syntax().owned();\n         PointerTypeNode(syntax)\n     }\n@@ -2362,7 +2362,7 @@ impl<'a> PointerType<'a> {}\n pub struct PrefixExprNode(SyntaxNode);\n \n impl PrefixExprNode {\n-    pub fn new(&self, ast: PrefixExpr) -> PrefixExprNode {\n+    pub fn new(ast: PrefixExpr) -> PrefixExprNode {\n         let syntax = ast.syntax().owned();\n         PrefixExprNode(syntax)\n     }\n@@ -2393,7 +2393,7 @@ impl<'a> PrefixExpr<'a> {}\n pub struct RangeExprNode(SyntaxNode);\n \n impl RangeExprNode {\n-    pub fn new(&self, ast: RangeExpr) -> RangeExprNode {\n+    pub fn new(ast: RangeExpr) -> RangeExprNode {\n         let syntax = ast.syntax().owned();\n         RangeExprNode(syntax)\n     }\n@@ -2424,7 +2424,7 @@ impl<'a> RangeExpr<'a> {}\n pub struct RangePatNode(SyntaxNode);\n \n impl RangePatNode {\n-    pub fn new(&self, ast: RangePat) -> RangePatNode {\n+    pub fn new(ast: RangePat) -> RangePatNode {\n         let syntax = ast.syntax().owned();\n         RangePatNode(syntax)\n     }\n@@ -2455,7 +2455,7 @@ impl<'a> RangePat<'a> {}\n pub struct RefExprNode(SyntaxNode);\n \n impl RefExprNode {\n-    pub fn new(&self, ast: RefExpr) -> RefExprNode {\n+    pub fn new(ast: RefExpr) -> RefExprNode {\n         let syntax = ast.syntax().owned();\n         RefExprNode(syntax)\n     }\n@@ -2486,7 +2486,7 @@ impl<'a> RefExpr<'a> {}\n pub struct RefPatNode(SyntaxNode);\n \n impl RefPatNode {\n-    pub fn new(&self, ast: RefPat) -> RefPatNode {\n+    pub fn new(ast: RefPat) -> RefPatNode {\n         let syntax = ast.syntax().owned();\n         RefPatNode(syntax)\n     }\n@@ -2517,7 +2517,7 @@ impl<'a> RefPat<'a> {}\n pub struct ReferenceTypeNode(SyntaxNode);\n \n impl ReferenceTypeNode {\n-    pub fn new(&self, ast: ReferenceType) -> ReferenceTypeNode {\n+    pub fn new(ast: ReferenceType) -> ReferenceTypeNode {\n         let syntax = ast.syntax().owned();\n         ReferenceTypeNode(syntax)\n     }\n@@ -2548,7 +2548,7 @@ impl<'a> ReferenceType<'a> {}\n pub struct RetTypeNode(SyntaxNode);\n \n impl RetTypeNode {\n-    pub fn new(&self, ast: RetType) -> RetTypeNode {\n+    pub fn new(ast: RetType) -> RetTypeNode {\n         let syntax = ast.syntax().owned();\n         RetTypeNode(syntax)\n     }\n@@ -2579,7 +2579,7 @@ impl<'a> RetType<'a> {}\n pub struct ReturnExprNode(SyntaxNode);\n \n impl ReturnExprNode {\n-    pub fn new(&self, ast: ReturnExpr) -> ReturnExprNode {\n+    pub fn new(ast: ReturnExpr) -> ReturnExprNode {\n         let syntax = ast.syntax().owned();\n         ReturnExprNode(syntax)\n     }\n@@ -2610,7 +2610,7 @@ impl<'a> ReturnExpr<'a> {}\n pub struct RootNode(SyntaxNode);\n \n impl RootNode {\n-    pub fn new(&self, ast: Root) -> RootNode {\n+    pub fn new(ast: Root) -> RootNode {\n         let syntax = ast.syntax().owned();\n         RootNode(syntax)\n     }\n@@ -2647,7 +2647,7 @@ impl<'a> Root<'a> {\n pub struct SelfParamNode(SyntaxNode);\n \n impl SelfParamNode {\n-    pub fn new(&self, ast: SelfParam) -> SelfParamNode {\n+    pub fn new(ast: SelfParam) -> SelfParamNode {\n         let syntax = ast.syntax().owned();\n         SelfParamNode(syntax)\n     }\n@@ -2678,7 +2678,7 @@ impl<'a> SelfParam<'a> {}\n pub struct SlicePatNode(SyntaxNode);\n \n impl SlicePatNode {\n-    pub fn new(&self, ast: SlicePat) -> SlicePatNode {\n+    pub fn new(ast: SlicePat) -> SlicePatNode {\n         let syntax = ast.syntax().owned();\n         SlicePatNode(syntax)\n     }\n@@ -2709,7 +2709,7 @@ impl<'a> SlicePat<'a> {}\n pub struct SliceTypeNode(SyntaxNode);\n \n impl SliceTypeNode {\n-    pub fn new(&self, ast: SliceType) -> SliceTypeNode {\n+    pub fn new(ast: SliceType) -> SliceTypeNode {\n         let syntax = ast.syntax().owned();\n         SliceTypeNode(syntax)\n     }\n@@ -2740,7 +2740,7 @@ impl<'a> SliceType<'a> {}\n pub struct StaticDefNode(SyntaxNode);\n \n impl StaticDefNode {\n-    pub fn new(&self, ast: StaticDef) -> StaticDefNode {\n+    pub fn new(ast: StaticDef) -> StaticDefNode {\n         let syntax = ast.syntax().owned();\n         StaticDefNode(syntax)\n     }\n@@ -2774,7 +2774,7 @@ impl<'a> StaticDef<'a> {}\n pub struct StmtNode(SyntaxNode);\n \n impl StmtNode {\n-    pub fn new(&self, ast: Stmt) -> StmtNode {\n+    pub fn new(ast: Stmt) -> StmtNode {\n         let syntax = ast.syntax().owned();\n         StmtNode(syntax)\n     }\n@@ -2812,7 +2812,7 @@ impl<'a> Stmt<'a> {}\n pub struct StructDefNode(SyntaxNode);\n \n impl StructDefNode {\n-    pub fn new(&self, ast: StructDef) -> StructDefNode {\n+    pub fn new(ast: StructDef) -> StructDefNode {\n         let syntax = ast.syntax().owned();\n         StructDefNode(syntax)\n     }\n@@ -2850,7 +2850,7 @@ impl<'a> StructDef<'a> {\n pub struct StructLitNode(SyntaxNode);\n \n impl StructLitNode {\n-    pub fn new(&self, ast: StructLit) -> StructLitNode {\n+    pub fn new(ast: StructLit) -> StructLitNode {\n         let syntax = ast.syntax().owned();\n         StructLitNode(syntax)\n     }\n@@ -2881,7 +2881,7 @@ impl<'a> StructLit<'a> {}\n pub struct StructPatNode(SyntaxNode);\n \n impl StructPatNode {\n-    pub fn new(&self, ast: StructPat) -> StructPatNode {\n+    pub fn new(ast: StructPat) -> StructPatNode {\n         let syntax = ast.syntax().owned();\n         StructPatNode(syntax)\n     }\n@@ -2912,7 +2912,7 @@ impl<'a> StructPat<'a> {}\n pub struct TokenTreeNode(SyntaxNode);\n \n impl TokenTreeNode {\n-    pub fn new(&self, ast: TokenTree) -> TokenTreeNode {\n+    pub fn new(ast: TokenTree) -> TokenTreeNode {\n         let syntax = ast.syntax().owned();\n         TokenTreeNode(syntax)\n     }\n@@ -2943,7 +2943,7 @@ impl<'a> TokenTree<'a> {}\n pub struct TraitDefNode(SyntaxNode);\n \n impl TraitDefNode {\n-    pub fn new(&self, ast: TraitDef) -> TraitDefNode {\n+    pub fn new(ast: TraitDef) -> TraitDefNode {\n         let syntax = ast.syntax().owned();\n         TraitDefNode(syntax)\n     }\n@@ -2976,7 +2976,7 @@ impl<'a> TraitDef<'a> {}\n pub struct TryExprNode(SyntaxNode);\n \n impl TryExprNode {\n-    pub fn new(&self, ast: TryExpr) -> TryExprNode {\n+    pub fn new(ast: TryExpr) -> TryExprNode {\n         let syntax = ast.syntax().owned();\n         TryExprNode(syntax)\n     }\n@@ -3007,7 +3007,7 @@ impl<'a> TryExpr<'a> {}\n pub struct TupleExprNode(SyntaxNode);\n \n impl TupleExprNode {\n-    pub fn new(&self, ast: TupleExpr) -> TupleExprNode {\n+    pub fn new(ast: TupleExpr) -> TupleExprNode {\n         let syntax = ast.syntax().owned();\n         TupleExprNode(syntax)\n     }\n@@ -3038,7 +3038,7 @@ impl<'a> TupleExpr<'a> {}\n pub struct TuplePatNode(SyntaxNode);\n \n impl TuplePatNode {\n-    pub fn new(&self, ast: TuplePat) -> TuplePatNode {\n+    pub fn new(ast: TuplePat) -> TuplePatNode {\n         let syntax = ast.syntax().owned();\n         TuplePatNode(syntax)\n     }\n@@ -3069,7 +3069,7 @@ impl<'a> TuplePat<'a> {}\n pub struct TupleStructPatNode(SyntaxNode);\n \n impl TupleStructPatNode {\n-    pub fn new(&self, ast: TupleStructPat) -> TupleStructPatNode {\n+    pub fn new(ast: TupleStructPat) -> TupleStructPatNode {\n         let syntax = ast.syntax().owned();\n         TupleStructPatNode(syntax)\n     }\n@@ -3100,7 +3100,7 @@ impl<'a> TupleStructPat<'a> {}\n pub struct TupleTypeNode(SyntaxNode);\n \n impl TupleTypeNode {\n-    pub fn new(&self, ast: TupleType) -> TupleTypeNode {\n+    pub fn new(ast: TupleType) -> TupleTypeNode {\n         let syntax = ast.syntax().owned();\n         TupleTypeNode(syntax)\n     }\n@@ -3131,7 +3131,7 @@ impl<'a> TupleType<'a> {}\n pub struct TypeDefNode(SyntaxNode);\n \n impl TypeDefNode {\n-    pub fn new(&self, ast: TypeDef) -> TypeDefNode {\n+    pub fn new(ast: TypeDef) -> TypeDefNode {\n         let syntax = ast.syntax().owned();\n         TypeDefNode(syntax)\n     }\n@@ -3165,7 +3165,7 @@ impl<'a> TypeDef<'a> {}\n pub struct TypeParamNode(SyntaxNode);\n \n impl TypeParamNode {\n-    pub fn new(&self, ast: TypeParam) -> TypeParamNode {\n+    pub fn new(ast: TypeParam) -> TypeParamNode {\n         let syntax = ast.syntax().owned();\n         TypeParamNode(syntax)\n     }\n@@ -3197,7 +3197,7 @@ impl<'a> TypeParam<'a> {}\n pub struct TypeParamListNode(SyntaxNode);\n \n impl TypeParamListNode {\n-    pub fn new(&self, ast: TypeParamList) -> TypeParamListNode {\n+    pub fn new(ast: TypeParamList) -> TypeParamListNode {\n         let syntax = ast.syntax().owned();\n         TypeParamListNode(syntax)\n     }\n@@ -3236,7 +3236,7 @@ impl<'a> TypeParamList<'a> {\n pub struct TypeRefNode(SyntaxNode);\n \n impl TypeRefNode {\n-    pub fn new(&self, ast: TypeRef) -> TypeRefNode {\n+    pub fn new(ast: TypeRef) -> TypeRefNode {\n         let syntax = ast.syntax().owned();\n         TypeRefNode(syntax)\n     }\n@@ -3307,7 +3307,7 @@ impl<'a> TypeRef<'a> {}\n pub struct UseItemNode(SyntaxNode);\n \n impl UseItemNode {\n-    pub fn new(&self, ast: UseItem) -> UseItemNode {\n+    pub fn new(ast: UseItem) -> UseItemNode {\n         let syntax = ast.syntax().owned();\n         UseItemNode(syntax)\n     }\n@@ -3342,7 +3342,7 @@ impl<'a> UseItem<'a> {\n pub struct UseTreeNode(SyntaxNode);\n \n impl UseTreeNode {\n-    pub fn new(&self, ast: UseTree) -> UseTreeNode {\n+    pub fn new(ast: UseTree) -> UseTreeNode {\n         let syntax = ast.syntax().owned();\n         UseTreeNode(syntax)\n     }\n@@ -3381,7 +3381,7 @@ impl<'a> UseTree<'a> {\n pub struct UseTreeListNode(SyntaxNode);\n \n impl UseTreeListNode {\n-    pub fn new(&self, ast: UseTreeList) -> UseTreeListNode {\n+    pub fn new(ast: UseTreeList) -> UseTreeListNode {\n         let syntax = ast.syntax().owned();\n         UseTreeListNode(syntax)\n     }\n@@ -3416,7 +3416,7 @@ impl<'a> UseTreeList<'a> {\n pub struct WhereClauseNode(SyntaxNode);\n \n impl WhereClauseNode {\n-    pub fn new(&self, ast: WhereClause) -> WhereClauseNode {\n+    pub fn new(ast: WhereClause) -> WhereClauseNode {\n         let syntax = ast.syntax().owned();\n         WhereClauseNode(syntax)\n     }\n@@ -3447,7 +3447,7 @@ impl<'a> WhereClause<'a> {}\n pub struct WhileExprNode(SyntaxNode);\n \n impl WhileExprNode {\n-    pub fn new(&self, ast: WhileExpr) -> WhileExprNode {\n+    pub fn new(ast: WhileExpr) -> WhileExprNode {\n         let syntax = ast.syntax().owned();\n         WhileExprNode(syntax)\n     }\n@@ -3483,7 +3483,7 @@ impl<'a> WhileExpr<'a> {\n pub struct WhitespaceNode(SyntaxNode);\n \n impl WhitespaceNode {\n-    pub fn new(&self, ast: Whitespace) -> WhitespaceNode {\n+    pub fn new(ast: Whitespace) -> WhitespaceNode {\n         let syntax = ast.syntax().owned();\n         WhitespaceNode(syntax)\n     }"}, {"sha": "d30038cba4407e48ff7d01b1d5703a7e77e3dfd6", "filename": "crates/ra_syntax/src/ast/generated.rs.tera", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/b67295134bf5c518b39bc88abbe1bc5b9d7d3baf/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera?ref=b67295134bf5c518b39bc88abbe1bc5b9d7d3baf", "patch": "@@ -17,7 +17,7 @@ use crate::{\n pub struct {{ node }}Node(SyntaxNode);\n \n impl {{ node }}Node {\n-    pub fn new(&self, ast: {{ node }}) -> {{ node }}Node {\n+    pub fn new(ast: {{ node }}) -> {{ node }}Node {\n         let syntax = ast.syntax().owned();\n         {{ node }}Node(syntax)\n     }"}]}