{"sha": "c60b0e43c87c5f46337b3792136ebd9b2aa74417", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MGIwZTQzYzg3YzVmNDYzMzdiMzc5MjEzNmViZDliMmFhNzQ0MTc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-29T15:28:25Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-29T15:28:25Z"}, "message": "incr.comp.: Remove on-export crate metadata hashing.", "tree": {"sha": "e17df0035a61ea9c8cca1c5e048f6505e8907157", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e17df0035a61ea9c8cca1c5e048f6505e8907157"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c60b0e43c87c5f46337b3792136ebd9b2aa74417", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c60b0e43c87c5f46337b3792136ebd9b2aa74417", "html_url": "https://github.com/rust-lang/rust/commit/c60b0e43c87c5f46337b3792136ebd9b2aa74417", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c60b0e43c87c5f46337b3792136ebd9b2aa74417/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc0e227745765c198958f0298785d18bcf61d4ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc0e227745765c198958f0298785d18bcf61d4ae", "html_url": "https://github.com/rust-lang/rust/commit/dc0e227745765c198958f0298785d18bcf61d4ae"}], "stats": {"total": 642, "additions": 39, "deletions": 603}, "files": [{"sha": "cbd76ee14db388963f1b076f0460550e6b210535", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -28,8 +28,6 @@ mod impls_syntax;\n \n pub const ATTR_DIRTY: &'static str = \"rustc_dirty\";\n pub const ATTR_CLEAN: &'static str = \"rustc_clean\";\n-pub const ATTR_DIRTY_METADATA: &'static str = \"rustc_metadata_dirty\";\n-pub const ATTR_CLEAN_METADATA: &'static str = \"rustc_metadata_clean\";\n pub const ATTR_IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n pub const ATTR_THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n pub const ATTR_PARTITION_REUSED: &'static str = \"rustc_partition_reused\";\n@@ -41,8 +39,6 @@ pub const DEP_GRAPH_ASSERT_ATTRS: &'static [&'static str] = &[\n     ATTR_THEN_THIS_WOULD_NEED,\n     ATTR_DIRTY,\n     ATTR_CLEAN,\n-    ATTR_DIRTY_METADATA,\n-    ATTR_CLEAN_METADATA,\n     ATTR_PARTITION_REUSED,\n     ATTR_PARTITION_TRANSLATED,\n ];\n@@ -53,8 +49,6 @@ pub const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n     ATTR_THEN_THIS_WOULD_NEED,\n     ATTR_DIRTY,\n     ATTR_CLEAN,\n-    ATTR_DIRTY_METADATA,\n-    ATTR_CLEAN_METADATA,\n     ATTR_PARTITION_REUSED,\n     ATTR_PARTITION_TRANSLATED,\n ];"}, {"sha": "4be23fb711d77dbe49e711f5cfcd59feffe7eaad", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -175,32 +175,6 @@ impl EncodedMetadata {\n     }\n }\n \n-/// The hash for some metadata that (when saving) will be exported\n-/// from this crate, or which (when importing) was exported by an\n-/// upstream crate.\n-#[derive(Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n-pub struct EncodedMetadataHash {\n-    pub def_index: u32,\n-    pub hash: ich::Fingerprint,\n-}\n-\n-/// The hash for some metadata that (when saving) will be exported\n-/// from this crate, or which (when importing) was exported by an\n-/// upstream crate.\n-#[derive(Debug, RustcEncodable, RustcDecodable, Clone)]\n-pub struct EncodedMetadataHashes {\n-    // Stable content hashes for things in crate metadata, indexed by DefIndex.\n-    pub hashes: Vec<EncodedMetadataHash>,\n-}\n-\n-impl EncodedMetadataHashes {\n-    pub fn new() -> EncodedMetadataHashes {\n-        EncodedMetadataHashes {\n-            hashes: Vec::new(),\n-        }\n-    }\n-}\n-\n /// The backend's way to give the crate store access to the metadata in a library.\n /// Note that it returns the raw metadata bytes stored in the library file, whether\n /// it is compressed, uncompressed, some weird mix, etc.\n@@ -286,7 +260,7 @@ pub trait CrateStore {\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n                                  reachable: &NodeSet)\n-                                 -> (EncodedMetadata, EncodedMetadataHashes);\n+                                 -> EncodedMetadata;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -370,7 +344,7 @@ impl CrateStore for DummyCrateStore {\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n                                  reachable: &NodeSet)\n-                                 -> (EncodedMetadata, EncodedMetadataHashes) {\n+                                 -> EncodedMetadata {\n         bug!(\"encode_metadata\")\n     }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }"}, {"sha": "6dade7694ab607f8334f742174b06e721ec0f4a1", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -1072,8 +1072,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"attempt to recover from parse errors (experimental)\"),\n     incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"enable incremental compilation (experimental)\"),\n-    incremental_cc: bool = (false, parse_bool, [UNTRACKED],\n-          \"enable cross-crate incremental compilation (even more experimental)\"),\n     incremental_queries: bool = (true, parse_bool, [UNTRACKED],\n           \"enable incremental compilation support for queries (experimental)\"),\n     incremental_info: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "22843ebf8ce993b80a2380d8e684f7a63c7a4816", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -24,7 +24,7 @@ use hir::map::DefPathHash;\n use lint::{self, Lint};\n use ich::{StableHashingContext, NodeIdHashingMode};\n use middle::const_val::ConstVal;\n-use middle::cstore::{CrateStore, LinkMeta, EncodedMetadataHashes};\n+use middle::cstore::{CrateStore, LinkMeta};\n use middle::cstore::EncodedMetadata;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n@@ -1246,7 +1246,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn encode_metadata(self, link_meta: &LinkMeta, reachable: &NodeSet)\n-        -> (EncodedMetadata, EncodedMetadataHashes)\n+        -> EncodedMetadata\n     {\n         self.cstore.encode_metadata(self, link_meta, reachable)\n     }"}, {"sha": "d7d142aac75ccc9add21cecdb26ef3b1815d5ce0", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -11,9 +11,6 @@\n //! The data that we will serialize and deserialize.\n \n use rustc::dep_graph::{WorkProduct, WorkProductId};\n-use rustc::hir::map::DefPathHash;\n-use rustc::middle::cstore::EncodedMetadataHash;\n-use rustc_data_structures::fx::FxHashMap;\n \n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedWorkProduct {\n@@ -23,39 +20,3 @@ pub struct SerializedWorkProduct {\n     /// work-product data itself\n     pub work_product: WorkProduct,\n }\n-\n-/// Data for use when downstream crates get recompiled.\n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n-pub struct SerializedMetadataHashes {\n-    /// For each def-id defined in this crate that appears in the\n-    /// metadata, we hash all the inputs that were used when producing\n-    /// the metadata. We save this after compilation is done. Then,\n-    /// when some downstream crate is being recompiled, it can compare\n-    /// the hashes we saved against the hashes that it saw from\n-    /// before; this will tell it which of the items in this crate\n-    /// changed, which in turn implies what items in the downstream\n-    /// crate need to be recompiled.\n-    ///\n-    /// Note that we store the def-ids here. This is because we don't\n-    /// reload this file when we recompile this crate, we will just\n-    /// regenerate it completely with the current hashes and new def-ids.\n-    ///\n-    /// Then downstream creates will load up their\n-    /// `SerializedDepGraph`, which may contain `MetaData(X)` nodes\n-    /// where `X` refers to some item in this crate. That `X` will be\n-    /// a `DefPathIndex` that gets retracted to the current `DefId`\n-    /// (matching the one found in this structure).\n-    pub entry_hashes: Vec<EncodedMetadataHash>,\n-\n-    /// For each DefIndex (as it occurs in SerializedMetadataHash), this\n-    /// map stores the DefPathIndex (as it occurs in DefIdDirectory), so\n-    /// that we can find the new DefId for a SerializedMetadataHash in a\n-    /// subsequent compilation session.\n-    ///\n-    /// This map is only needed for running auto-tests using the\n-    /// #[rustc_metadata_dirty] and #[rustc_metadata_clean] attributes, and\n-    /// is only populated if -Z query-dep-graph is specified. It will be\n-    /// empty otherwise. Importing crates are perfectly happy with just having\n-    /// the DefIndex.\n-    pub index_map: FxHashMap<u32, DefPathHash>\n-}"}, {"sha": "7c3f903f22846fc7d775b6488b4fd7cf1940290e", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 170, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -23,21 +23,6 @@\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n //!\n-//! The `#[rustc_metadata_dirty]` and `#[rustc_metadata_clean]` attributes\n-//! can be used to check the incremental compilation hash (ICH) values of\n-//! metadata exported in rlibs.\n-//!\n-//! - If a node is marked with `#[rustc_metadata_clean(cfg=\"rev2\")]` we\n-//!   check that the metadata hash for that node is the same for \"rev2\"\n-//!   it was for \"rev1\".\n-//! - If a node is marked with `#[rustc_metadata_dirty(cfg=\"rev2\")]` we\n-//!   check that the metadata hash for that node is *different* for \"rev2\"\n-//!   than it was for \"rev1\".\n-//!\n-//! Note that the metadata-testing attributes must never specify the\n-//! first revision. This would lead to a crash since there is no\n-//! previous revision to compare things to.\n-//!\n \n use std::collections::HashSet;\n use std::iter::FromIterator;\n@@ -49,10 +34,9 @@ use rustc::hir::map::Node as HirNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit;\n-use rustc::ich::{Fingerprint, ATTR_DIRTY, ATTR_CLEAN, ATTR_DIRTY_METADATA,\n-                 ATTR_CLEAN_METADATA};\n+use rustc::ich::{ATTR_DIRTY, ATTR_CLEAN};\n use syntax::ast::{self, Attribute, NestedMetaItem};\n-use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use rustc_data_structures::fx::FxHashSet;\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n \n@@ -553,157 +537,6 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_dirty_clean_metadata<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    prev_metadata_hashes: &FxHashMap<DefId, Fingerprint>,\n-    current_metadata_hashes: &FxHashMap<DefId, Fingerprint>)\n-{\n-    if !tcx.sess.opts.debugging_opts.query_dep_graph {\n-        return;\n-    }\n-\n-    tcx.dep_graph.with_ignore(||{\n-        let krate = tcx.hir.krate();\n-        let mut dirty_clean_visitor = DirtyCleanMetadataVisitor {\n-            tcx,\n-            prev_metadata_hashes,\n-            current_metadata_hashes,\n-            checked_attrs: FxHashSet(),\n-        };\n-        intravisit::walk_crate(&mut dirty_clean_visitor, krate);\n-\n-        let mut all_attrs = FindAllAttrs {\n-            tcx,\n-            attr_names: vec![ATTR_DIRTY_METADATA, ATTR_CLEAN_METADATA],\n-            found_attrs: vec![],\n-        };\n-        intravisit::walk_crate(&mut all_attrs, krate);\n-\n-        // Note that we cannot use the existing \"unused attribute\"-infrastructure\n-        // here, since that is running before trans. This is also the reason why\n-        // all trans-specific attributes are `Whitelisted` in syntax::feature_gate.\n-        all_attrs.report_unchecked_attrs(&dirty_clean_visitor.checked_attrs);\n-    });\n-}\n-\n-pub struct DirtyCleanMetadataVisitor<'a, 'tcx: 'a, 'm> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    prev_metadata_hashes: &'m FxHashMap<DefId, Fingerprint>,\n-    current_metadata_hashes: &'m FxHashMap<DefId, Fingerprint>,\n-    checked_attrs: FxHashSet<ast::AttrId>,\n-}\n-\n-impl<'a, 'tcx, 'm> intravisit::Visitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n-\n-    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n-        intravisit::NestedVisitorMap::All(&self.tcx.hir)\n-    }\n-\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.check_item(item.id, item.span);\n-        intravisit::walk_item(self, item);\n-    }\n-\n-    fn visit_variant(&mut self,\n-                     variant: &'tcx hir::Variant,\n-                     generics: &'tcx hir::Generics,\n-                     parent_id: ast::NodeId) {\n-        if let Some(e) = variant.node.disr_expr {\n-            self.check_item(e.node_id, variant.span);\n-        }\n-\n-        intravisit::walk_variant(self, variant, generics, parent_id);\n-    }\n-\n-    fn visit_variant_data(&mut self,\n-                          variant_data: &'tcx hir::VariantData,\n-                          _: ast::Name,\n-                          _: &'tcx hir::Generics,\n-                          _parent_id: ast::NodeId,\n-                          span: Span) {\n-        if self.tcx.hir.find(variant_data.id()).is_some() {\n-            // VariantData that represent structs or tuples don't have a\n-            // separate entry in the HIR map and checking them would error,\n-            // so only check if this is an enum or union variant.\n-            self.check_item(variant_data.id(), span);\n-        }\n-\n-        intravisit::walk_struct_def(self, variant_data);\n-    }\n-\n-    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        self.check_item(item.id, item.span);\n-        intravisit::walk_trait_item(self, item);\n-    }\n-\n-    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        self.check_item(item.id, item.span);\n-        intravisit::walk_impl_item(self, item);\n-    }\n-\n-    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n-        self.check_item(i.id, i.span);\n-        intravisit::walk_foreign_item(self, i);\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n-        self.check_item(s.id, s.span);\n-        intravisit::walk_struct_field(self, s);\n-    }\n-}\n-\n-impl<'a, 'tcx, 'm> DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n-\n-    fn check_item(&mut self, item_id: ast::NodeId, item_span: Span) {\n-        let def_id = self.tcx.hir.local_def_id(item_id);\n-\n-        for attr in self.tcx.get_attrs(def_id).iter() {\n-            if attr.check_name(ATTR_DIRTY_METADATA) {\n-                if check_config(self.tcx, attr) {\n-                    if self.checked_attrs.insert(attr.id) {\n-                        self.assert_state(false, def_id, item_span);\n-                    }\n-                }\n-            } else if attr.check_name(ATTR_CLEAN_METADATA) {\n-                if check_config(self.tcx, attr) {\n-                    if self.checked_attrs.insert(attr.id) {\n-                        self.assert_state(true, def_id, item_span);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn assert_state(&self, should_be_clean: bool, def_id: DefId, span: Span) {\n-        let item_path = self.tcx.item_path_str(def_id);\n-        debug!(\"assert_state({})\", item_path);\n-\n-        if let Some(&prev_hash) = self.prev_metadata_hashes.get(&def_id) {\n-            let hashes_are_equal = prev_hash == self.current_metadata_hashes[&def_id];\n-\n-            if should_be_clean && !hashes_are_equal {\n-                self.tcx.sess.span_err(\n-                        span,\n-                        &format!(\"Metadata hash of `{}` is dirty, but should be clean\",\n-                                 item_path));\n-            }\n-\n-            let should_be_dirty = !should_be_clean;\n-            if should_be_dirty && hashes_are_equal {\n-                self.tcx.sess.span_err(\n-                        span,\n-                        &format!(\"Metadata hash of `{}` is clean, but should be dirty\",\n-                                 item_path));\n-            }\n-        } else {\n-            self.tcx.sess.span_err(\n-                        span,\n-                        &format!(\"Could not find previous metadata hash of `{}`\",\n-                                 item_path));\n-        }\n-    }\n-}\n-\n /// Given a `#[rustc_dirty]` or `#[rustc_clean]` attribute, scan\n /// for a `cfg=\"foo\"` attribute and check whether we have a cfg\n /// flag called `foo`.\n@@ -759,7 +592,6 @@ fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> ast::Name {\n     }\n }\n \n-\n // A visitor that collects all #[rustc_dirty]/#[rustc_clean] attributes from\n // the HIR. It is used to verfiy that we really ran checks for all annotated\n // nodes."}, {"sha": "2a8cfb7e91d71d2f41d4babbbfc24ce5bd0be8f8", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -131,7 +131,6 @@ use rand::{thread_rng, Rng};\n const LOCK_FILE_EXT: &'static str = \".lock\";\n const DEP_GRAPH_FILENAME: &'static str = \"dep-graph.bin\";\n const WORK_PRODUCTS_FILENAME: &'static str = \"work-products.bin\";\n-const METADATA_HASHES_FILENAME: &'static str = \"metadata.bin\";\n const QUERY_CACHE_FILENAME: &'static str = \"query-cache.bin\";\n \n // We encode integers using the following base, so they are shorter than decimal\n@@ -148,10 +147,6 @@ pub fn work_products_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, WORK_PRODUCTS_FILENAME)\n }\n \n-pub fn metadata_hash_export_path(sess: &Session) -> PathBuf {\n-    in_incr_comp_dir_sess(sess, METADATA_HASHES_FILENAME)\n-}\n-\n pub fn query_cache_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, QUERY_CACHE_FILENAME)\n }"}, {"sha": "5907f00e3dc483285f34a3a158012d0ea0c490c8", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -11,12 +11,9 @@\n //! Code to save/load the dep-graph from files.\n \n use rustc::dep_graph::{PreviousDepGraph, SerializedDepGraph};\n-use rustc::hir::svh::Svh;\n-use rustc::ich::Fingerprint;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc::ty::maps::OnDiskCache;\n-use rustc::util::nodemap::DefIdMap;\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n use std::path::Path;\n@@ -106,64 +103,6 @@ fn delete_dirty_work_product(tcx: TyCtxt,\n     work_product::delete_workproduct_files(tcx.sess, &swp.work_product);\n }\n \n-pub fn load_prev_metadata_hashes(tcx: TyCtxt) -> DefIdMap<Fingerprint> {\n-    let mut output = DefIdMap();\n-\n-    if !tcx.sess.opts.debugging_opts.query_dep_graph {\n-        // Previous metadata hashes are only needed for testing.\n-        return output\n-    }\n-\n-    debug!(\"load_prev_metadata_hashes() - Loading previous metadata hashes\");\n-\n-    let file_path = metadata_hash_export_path(tcx.sess);\n-\n-    if !file_path.exists() {\n-        debug!(\"load_prev_metadata_hashes() - Couldn't find file containing \\\n-                hashes at `{}`\", file_path.display());\n-        return output\n-    }\n-\n-    debug!(\"load_prev_metadata_hashes() - File: {}\", file_path.display());\n-\n-    let (data, start_pos) = match file_format::read_file(tcx.sess, &file_path) {\n-        Ok(Some(data_and_pos)) => data_and_pos,\n-        Ok(None) => {\n-            debug!(\"load_prev_metadata_hashes() - File produced by incompatible \\\n-                    compiler version: {}\", file_path.display());\n-            return output\n-        }\n-        Err(err) => {\n-            debug!(\"load_prev_metadata_hashes() - Error reading file `{}`: {}\",\n-                   file_path.display(), err);\n-            return output\n-        }\n-    };\n-\n-    debug!(\"load_prev_metadata_hashes() - Decoding hashes\");\n-    let mut decoder = Decoder::new(&data, start_pos);\n-    let _ = Svh::decode(&mut decoder).unwrap();\n-    let serialized_hashes = SerializedMetadataHashes::decode(&mut decoder).unwrap();\n-\n-    debug!(\"load_prev_metadata_hashes() - Mapping DefIds\");\n-\n-    assert_eq!(serialized_hashes.index_map.len(), serialized_hashes.entry_hashes.len());\n-    let def_path_hash_to_def_id = tcx.def_path_hash_to_def_id.as_ref().unwrap();\n-\n-    for serialized_hash in serialized_hashes.entry_hashes {\n-        let def_path_hash = serialized_hashes.index_map[&serialized_hash.def_index];\n-        if let Some(&def_id) = def_path_hash_to_def_id.get(&def_path_hash) {\n-            let old = output.insert(def_id, serialized_hash.hash);\n-            assert!(old.is_none(), \"already have hash for {:?}\", def_id);\n-        }\n-    }\n-\n-    debug!(\"load_prev_metadata_hashes() - successfully loaded {} hashes\",\n-           serialized_hashes.index_map.len());\n-\n-    output\n-}\n-\n pub fn load_dep_graph(sess: &Session) -> PreviousDepGraph {\n     let empty = PreviousDepGraph::new(SerializedDepGraph::new());\n "}, {"sha": "6eaa14a50f40f84683515cd073a8ec332a625c6f", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 71, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -9,14 +9,9 @@\n // except according to those terms.\n \n use rustc::dep_graph::{DepGraph, DepKind};\n-use rustc::hir::def_id::{DefId, DefIndex};\n-use rustc::hir::svh::Svh;\n-use rustc::ich::Fingerprint;\n-use rustc::middle::cstore::EncodedMetadataHashes;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc::util::common::time;\n-use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_serialize::opaque::Encoder;\n@@ -30,39 +25,14 @@ use super::dirty_clean;\n use super::file_format;\n use super::work_product;\n \n-use super::load::load_prev_metadata_hashes;\n-\n-pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                metadata_hashes: &EncodedMetadataHashes,\n-                                svh: Svh) {\n+pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     debug!(\"save_dep_graph()\");\n     let _ignore = tcx.dep_graph.in_ignore();\n     let sess = tcx.sess;\n     if sess.opts.incremental.is_none() {\n         return;\n     }\n \n-    // We load the previous metadata hashes now before overwriting the file\n-    // (if we need them for testing).\n-    let prev_metadata_hashes = if tcx.sess.opts.debugging_opts.query_dep_graph {\n-        load_prev_metadata_hashes(tcx)\n-    } else {\n-        DefIdMap()\n-    };\n-\n-    let mut current_metadata_hashes = FxHashMap();\n-\n-    if sess.opts.debugging_opts.incremental_cc ||\n-       sess.opts.debugging_opts.query_dep_graph {\n-        save_in(sess,\n-                metadata_hash_export_path(sess),\n-                |e| encode_metadata_hashes(tcx,\n-                                           svh,\n-                                           metadata_hashes,\n-                                           &mut current_metadata_hashes,\n-                                           e));\n-    }\n-\n     time(sess.time_passes(), \"persist query result cache\", || {\n         save_in(sess,\n                 query_cache_path(sess),\n@@ -78,9 +48,6 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     dirty_clean::check_dirty_clean_annotations(tcx);\n-    dirty_clean::check_dirty_clean_metadata(tcx,\n-                                            &prev_metadata_hashes,\n-                                            &current_metadata_hashes);\n }\n \n pub fn save_work_products(sess: &Session, dep_graph: &DepGraph) {\n@@ -258,43 +225,6 @@ fn encode_dep_graph(tcx: TyCtxt,\n     Ok(())\n }\n \n-fn encode_metadata_hashes(tcx: TyCtxt,\n-                          svh: Svh,\n-                          metadata_hashes: &EncodedMetadataHashes,\n-                          current_metadata_hashes: &mut FxHashMap<DefId, Fingerprint>,\n-                          encoder: &mut Encoder)\n-                          -> io::Result<()> {\n-    assert_eq!(metadata_hashes.hashes.len(),\n-        metadata_hashes.hashes.iter().map(|x| (x.def_index, ())).collect::<FxHashMap<_,_>>().len());\n-\n-    let mut serialized_hashes = SerializedMetadataHashes {\n-        entry_hashes: metadata_hashes.hashes.to_vec(),\n-        index_map: FxHashMap()\n-    };\n-\n-    if tcx.sess.opts.debugging_opts.query_dep_graph {\n-        for serialized_hash in &serialized_hashes.entry_hashes {\n-            let def_id = DefId::local(DefIndex::from_u32(serialized_hash.def_index));\n-\n-            // Store entry in the index_map\n-            let def_path_hash = tcx.def_path_hash(def_id);\n-            serialized_hashes.index_map.insert(def_id.index.as_u32(), def_path_hash);\n-\n-            // Record hash in current_metadata_hashes\n-            current_metadata_hashes.insert(def_id, serialized_hash.hash);\n-        }\n-\n-        debug!(\"save: stored index_map (len={}) for serialized hashes\",\n-               serialized_hashes.index_map.len());\n-    }\n-\n-    // Encode everything.\n-    svh.encode(encoder)?;\n-    serialized_hashes.encode(encoder)?;\n-\n-    Ok(())\n-}\n-\n fn encode_work_products(dep_graph: &DepGraph,\n                         encoder: &mut Encoder) -> io::Result<()> {\n     let work_products: Vec<_> = dep_graph"}, {"sha": "911b4dac4e13a69ea6068647990dece9517c57ed", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -17,8 +17,7 @@ use schema;\n use rustc::ty::maps::QueryConfig;\n use rustc::middle::cstore::{CrateStore, DepKind,\n                             MetadataLoader, LinkMeta,\n-                            LoadedMacro, EncodedMetadata,\n-                            EncodedMetadataHashes, NativeLibraryKind};\n+                            LoadedMacro, EncodedMetadata, NativeLibraryKind};\n use rustc::middle::stability::DeprecationEntry;\n use rustc::hir::def;\n use rustc::session::{CrateDisambiguator, Session};\n@@ -498,7 +497,7 @@ impl CrateStore for cstore::CStore {\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n                                  reachable: &NodeSet)\n-                                 -> (EncodedMetadata, EncodedMetadataHashes)\n+                                 -> EncodedMetadata\n     {\n         encoder::encode_metadata(tcx, link_meta, reachable)\n     }"}, {"sha": "37696842ecbaed6ef0d46b0373ae4fb650bce904", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 58, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -14,12 +14,10 @@ use isolated_encoder::IsolatedEncoder;\n use schema::*;\n \n use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary,\n-                            EncodedMetadata, EncodedMetadataHashes,\n-                            EncodedMetadataHash};\n+                            EncodedMetadata};\n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LOCAL_CRATE};\n-use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n-use rustc::ich::Fingerprint;\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::lang_items;\n use rustc::mir;\n@@ -57,9 +55,6 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n-\n-    pub metadata_hashes: EncodedMetadataHashes,\n-    pub compute_ich: bool,\n }\n \n macro_rules! encoder_methods {\n@@ -230,22 +225,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     // Encodes something that corresponds to a single DepNode::GlobalMetaData\n     // and registers the Fingerprint in the `metadata_hashes` map.\n     pub fn tracked<'x, DATA, R>(&'x mut self,\n-                                def_index: DefIndex,\n                                 op: fn(&mut IsolatedEncoder<'x, 'a, 'tcx>, DATA) -> R,\n                                 data: DATA)\n                                 -> R {\n-        let mut entry_builder = IsolatedEncoder::new(self);\n-        let ret = op(&mut entry_builder, data);\n-        let (fingerprint, this) = entry_builder.finish();\n-\n-        if let Some(fingerprint) = fingerprint {\n-            this.metadata_hashes.hashes.push(EncodedMetadataHash {\n-                def_index: def_index.as_u32(),\n-                hash: fingerprint,\n-            })\n-        }\n-\n-        ret\n+        op(&mut IsolatedEncoder::new(self), data)\n     }\n \n     fn encode_info_for_items(&mut self) -> Index {\n@@ -311,38 +294,23 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot> {\n         let mut i = self.position();\n \n-        let tcx = self.tcx;\n-        let global_metadata_def_index = move |kind: GlobalMetaDataKind| {\n-            kind.def_index(tcx.hir.definitions().def_path_table())\n-        };\n-\n-        let crate_deps = self.tracked(\n-            global_metadata_def_index(GlobalMetaDataKind::CrateDeps),\n-            IsolatedEncoder::encode_crate_deps,\n-            ());\n+        let crate_deps = self.tracked(IsolatedEncoder::encode_crate_deps, ());\n         let dylib_dependency_formats = self.tracked(\n-            global_metadata_def_index(GlobalMetaDataKind::DylibDependencyFormats),\n             IsolatedEncoder::encode_dylib_dependency_formats,\n             ());\n         let dep_bytes = self.position() - i;\n \n         // Encode the language items.\n         i = self.position();\n-        let lang_items = self.tracked(\n-            global_metadata_def_index(GlobalMetaDataKind::LangItems),\n-            IsolatedEncoder::encode_lang_items,\n-            ());\n-\n+        let lang_items = self.tracked(IsolatedEncoder::encode_lang_items, ());\n         let lang_items_missing = self.tracked(\n-            global_metadata_def_index(GlobalMetaDataKind::LangItemsMissing),\n             IsolatedEncoder::encode_lang_items_missing,\n             ());\n         let lang_item_bytes = self.position() - i;\n \n         // Encode the native libraries used\n         i = self.position();\n         let native_libraries = self.tracked(\n-            global_metadata_def_index(GlobalMetaDataKind::NativeLibraries),\n             IsolatedEncoder::encode_native_libraries,\n             ());\n         let native_lib_bytes = self.position() - i;\n@@ -359,16 +327,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         // Encode the def IDs of impls, for coherence checking.\n         i = self.position();\n-        let impls = self.tracked(\n-            global_metadata_def_index(GlobalMetaDataKind::Impls),\n-            IsolatedEncoder::encode_impls,\n-            ());\n+        let impls = self.tracked(IsolatedEncoder::encode_impls, ());\n         let impl_bytes = self.position() - i;\n \n         // Encode exported symbols info.\n         i = self.position();\n         let exported_symbols = self.tracked(\n-            global_metadata_def_index(GlobalMetaDataKind::ExportedSymbols),\n             IsolatedEncoder::encode_exported_symbols,\n             self.exported_symbols);\n         let exported_symbols_bytes = self.position() - i;\n@@ -421,11 +385,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let total_bytes = self.position();\n \n-        self.metadata_hashes.hashes.push(EncodedMetadataHash {\n-            def_index: global_metadata_def_index(GlobalMetaDataKind::Krate).as_u32(),\n-            hash: Fingerprint::from_smaller_hash(link_meta.crate_hash.as_u64())\n-        });\n-\n         if self.tcx.sess.meta_stats() {\n             let mut zero_bytes = 0;\n             for e in self.opaque.cursor.get_ref() {\n@@ -1654,19 +1613,15 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n                                  exported_symbols: &NodeSet)\n-                                 -> (EncodedMetadata, EncodedMetadataHashes)\n+                                 -> EncodedMetadata\n {\n     let mut cursor = Cursor::new(vec![]);\n     cursor.write_all(METADATA_HEADER).unwrap();\n \n     // Will be filled with the root position after encoding everything.\n     cursor.write_all(&[0, 0, 0, 0]).unwrap();\n \n-     let compute_ich = (tcx.sess.opts.debugging_opts.query_dep_graph ||\n-                        tcx.sess.opts.debugging_opts.incremental_cc) &&\n-                        tcx.sess.opts.build_dep_graph();\n-\n-    let (root, metadata_hashes) = {\n+    let root = {\n         let mut ecx = EncodeContext {\n             opaque: opaque::Encoder::new(&mut cursor),\n             tcx,\n@@ -1675,17 +1630,14 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n-            metadata_hashes: EncodedMetadataHashes::new(),\n-            compute_ich,\n         };\n \n         // Encode the rustc version string in a predictable location.\n         rustc_version().encode(&mut ecx).unwrap();\n \n         // Encode all the entries and extra information in the crate,\n         // culminating in the `CrateRoot` which points to all of it.\n-        let root = ecx.encode_crate_root();\n-        (root, ecx.metadata_hashes)\n+        ecx.encode_crate_root()\n     };\n     let mut result = cursor.into_inner();\n \n@@ -1697,7 +1649,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     result[header + 2] = (pos >> 8) as u8;\n     result[header + 3] = (pos >> 0) as u8;\n \n-    (EncodedMetadata { raw_data: result }, metadata_hashes)\n+    EncodedMetadata { raw_data: result }\n }\n \n pub fn get_repr_options<'a, 'tcx, 'gcx>(tcx: &TyCtxt<'a, 'tcx, 'gcx>, did: DefId) -> ReprOptions {"}, {"sha": "f218268914300d6e98b122b10f69e6c58f651fbe", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -62,7 +62,6 @@ use isolated_encoder::IsolatedEncoder;\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::middle::cstore::EncodedMetadataHash;\n use rustc::ty::TyCtxt;\n use syntax::ast;\n \n@@ -128,19 +127,10 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         // unclear whether that would be a win since hashing is cheap enough.\n         let _task = tcx.dep_graph.in_ignore();\n \n-        let ecx: &'x mut EncodeContext<'b, 'tcx> = &mut *self.ecx;\n-        let mut entry_builder = IsolatedEncoder::new(ecx);\n+        let mut entry_builder = IsolatedEncoder::new(self.ecx);\n         let entry = op(&mut entry_builder, data);\n         let entry = entry_builder.lazy(&entry);\n \n-        let (fingerprint, ecx) = entry_builder.finish();\n-        if let Some(hash) = fingerprint {\n-            ecx.metadata_hashes.hashes.push(EncodedMetadataHash {\n-                def_index: id.index.as_u32(),\n-                hash,\n-            });\n-        }\n-\n         self.items.record(id, entry);\n     }\n "}, {"sha": "689c190966ee8214bc4fe827f04fa55e9eabb0d0", "filename": "src/librustc_metadata/isolated_encoder.rs", "status": "modified", "additions": 7, "deletions": 113, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fisolated_encoder.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -10,161 +10,55 @@\n \n use encoder::EncodeContext;\n use schema::{Lazy, LazySeq};\n-\n-use rustc::ich::{StableHashingContext, Fingerprint};\n use rustc::ty::TyCtxt;\n-\n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n-use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_serialize::Encodable;\n \n /// The IsolatedEncoder provides facilities to write to crate metadata while\n /// making sure that anything going through it is also feed into an ICH hasher.\n pub struct IsolatedEncoder<'a, 'b: 'a, 'tcx: 'b> {\n     pub tcx: TyCtxt<'b, 'tcx, 'tcx>,\n     ecx: &'a mut EncodeContext<'b, 'tcx>,\n-    hcx: Option<(StableHashingContext<'tcx>, StableHasher<Fingerprint>)>,\n }\n \n impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n         let tcx = ecx.tcx;\n-        let compute_ich = ecx.compute_ich;\n         IsolatedEncoder {\n             tcx,\n             ecx,\n-            hcx: if compute_ich {\n-                // We are always hashing spans for things in metadata because\n-                // don't know if a downstream crate will use them or not.\n-                // Except when -Zquery-dep-graph is specified because we don't\n-                // want to mess up our tests.\n-                let hcx = if tcx.sess.opts.debugging_opts.query_dep_graph {\n-                    tcx.create_stable_hashing_context()\n-                } else {\n-                    tcx.create_stable_hashing_context().force_span_hashing()\n-                };\n-\n-                Some((hcx, StableHasher::new()))\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    pub fn finish(self) -> (Option<Fingerprint>, &'a mut EncodeContext<'b, 'tcx>) {\n-        if let Some((_, hasher)) = self.hcx {\n-            (Some(hasher.finish()), self.ecx)\n-        } else {\n-            (None, self.ecx)\n         }\n     }\n \n     pub fn lazy<T>(&mut self, value: &T) -> Lazy<T>\n-        where T: Encodable + HashStable<StableHashingContext<'tcx>>\n+        where T: Encodable\n     {\n-        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n-            value.hash_stable(hcx, hasher);\n-            debug!(\"metadata-hash: {:?}\", hasher);\n-        }\n         self.ecx.lazy(value)\n     }\n \n     pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n         where I: IntoIterator<Item = T>,\n-              T: Encodable + HashStable<StableHashingContext<'tcx>>\n+              T: Encodable\n     {\n-        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n-            let iter = iter.into_iter();\n-            let (lower_bound, upper_bound) = iter.size_hint();\n-\n-            if upper_bound == Some(lower_bound) {\n-                lower_bound.hash_stable(hcx, hasher);\n-                let mut num_items_hashed = 0;\n-                let ret = self.ecx.lazy_seq(iter.inspect(|item| {\n-                    item.hash_stable(hcx, hasher);\n-                    num_items_hashed += 1;\n-                }));\n-\n-                // Sometimes items in a sequence are filtered out without being\n-                // hashed (e.g. for &[ast::Attribute]) and this code path cannot\n-                // handle that correctly, so we want to make sure we didn't hit\n-                // it by accident.\n-                if lower_bound != num_items_hashed {\n-                    bug!(\"Hashed a different number of items ({}) than expected ({})\",\n-                         num_items_hashed,\n-                         lower_bound);\n-                }\n-                debug!(\"metadata-hash: {:?}\", hasher);\n-                ret\n-            } else {\n-                // Collect into a vec so we know the length of the sequence\n-                let items: AccumulateVec<[T; 32]> = iter.collect();\n-                items.hash_stable(hcx, hasher);\n-                debug!(\"metadata-hash: {:?}\", hasher);\n-                self.ecx.lazy_seq(items)\n-            }\n-        } else {\n-            self.ecx.lazy_seq(iter)\n-        }\n+        self.ecx.lazy_seq(iter)\n     }\n \n     pub fn lazy_seq_ref<'x, I, T>(&mut self, iter: I) -> LazySeq<T>\n         where I: IntoIterator<Item = &'x T>,\n-              T: 'x + Encodable + HashStable<StableHashingContext<'tcx>>\n+              T: 'x + Encodable\n     {\n-        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n-            let iter = iter.into_iter();\n-            let (lower_bound, upper_bound) = iter.size_hint();\n-\n-            if upper_bound == Some(lower_bound) {\n-                lower_bound.hash_stable(hcx, hasher);\n-                let mut num_items_hashed = 0;\n-                let ret = self.ecx.lazy_seq_ref(iter.inspect(|item| {\n-                    item.hash_stable(hcx, hasher);\n-                    num_items_hashed += 1;\n-                }));\n-\n-                // Sometimes items in a sequence are filtered out without being\n-                // hashed (e.g. for &[ast::Attribute]) and this code path cannot\n-                // handle that correctly, so we want to make sure we didn't hit\n-                // it by accident.\n-                if lower_bound != num_items_hashed {\n-                    bug!(\"Hashed a different number of items ({}) than expected ({})\",\n-                         num_items_hashed,\n-                         lower_bound);\n-                }\n-                debug!(\"metadata-hash: {:?}\", hasher);\n-                ret\n-            } else {\n-                // Collect into a vec so we know the length of the sequence\n-                let items: AccumulateVec<[&'x T; 32]> = iter.collect();\n-                items.hash_stable(hcx, hasher);\n-                debug!(\"metadata-hash: {:?}\", hasher);\n-                self.ecx.lazy_seq_ref(items.iter().map(|x| *x))\n-            }\n-        } else {\n-            self.ecx.lazy_seq_ref(iter)\n-        }\n+        self.ecx.lazy_seq_ref(iter)\n     }\n \n     pub fn lazy_seq_from_slice<T>(&mut self, slice: &[T]) -> LazySeq<T>\n-        where T: Encodable + HashStable<StableHashingContext<'tcx>>\n+        where T: Encodable\n     {\n-        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n-            slice.hash_stable(hcx, hasher);\n-            debug!(\"metadata-hash: {:?}\", hasher);\n-        }\n         self.ecx.lazy_seq_ref(slice.iter())\n     }\n \n     pub fn lazy_seq_ref_from_slice<T>(&mut self, slice: &[&T]) -> LazySeq<T>\n-        where T: Encodable + HashStable<StableHashingContext<'tcx>>\n+        where T: Encodable\n     {\n-        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n-            slice.hash_stable(hcx, hasher);\n-            debug!(\"metadata-hash: {:?}\", hasher);\n-        }\n         self.ecx.lazy_seq_ref(slice.iter().map(|x| *x))\n     }\n }"}, {"sha": "62738222a8c010d0f455aba10adcbecd1776bfba", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -39,7 +39,7 @@ use metadata;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::trans::{Linkage, Visibility, Stats};\n-use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n+use rustc::middle::cstore::EncodedMetadata;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf};\n use rustc::ty::maps::Providers;\n@@ -602,8 +602,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n                             llmod_id: &str,\n                             link_meta: &LinkMeta,\n                             exported_symbols: &NodeSet)\n-                            -> (ContextRef, ModuleRef,\n-                                EncodedMetadata, EncodedMetadataHashes) {\n+                            -> (ContextRef, ModuleRef, EncodedMetadata) {\n     use std::io::Write;\n     use flate2::Compression;\n     use flate2::write::DeflateEncoder;\n@@ -635,13 +634,12 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     if kind == MetadataKind::None {\n         return (metadata_llcx,\n                 metadata_llmod,\n-                EncodedMetadata::new(),\n-                EncodedMetadataHashes::new());\n+                EncodedMetadata::new());\n     }\n \n-    let (metadata, hashes) = tcx.encode_metadata(link_meta, exported_symbols);\n+    let metadata = tcx.encode_metadata(link_meta, exported_symbols);\n     if kind == MetadataKind::Uncompressed {\n-        return (metadata_llcx, metadata_llmod, metadata, hashes);\n+        return (metadata_llcx, metadata_llmod, metadata);\n     }\n \n     assert!(kind == MetadataKind::Compressed);\n@@ -669,7 +667,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n         let directive = CString::new(directive).unwrap();\n         llvm::LLVMSetModuleInlineAsm(metadata_llmod, directive.as_ptr())\n     }\n-    return (metadata_llcx, metadata_llmod, metadata, hashes);\n+    return (metadata_llcx, metadata_llmod, metadata);\n }\n \n pub struct ValueIter {\n@@ -720,7 +718,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let shared_ccx = SharedCrateContext::new(tcx);\n     // Translate the metadata.\n     let llmod_id = \"metadata\";\n-    let (metadata_llcx, metadata_llmod, metadata, metadata_incr_hashes) =\n+    let (metadata_llcx, metadata_llmod, metadata) =\n         time(tcx.sess.time_passes(), \"write metadata\", || {\n             write_metadata(tcx, llmod_id, &link_meta, &exported_symbol_node_ids)\n         });\n@@ -756,9 +754,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ongoing_translation.submit_pre_translated_module_to_llvm(tcx, metadata_module);\n         ongoing_translation.translation_finished(tcx);\n \n-        assert_and_save_dep_graph(tcx,\n-                                  metadata_incr_hashes,\n-                                  link_meta);\n+        assert_and_save_dep_graph(tcx);\n \n         ongoing_translation.check_for_errors(tcx.sess);\n \n@@ -932,24 +928,18 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     ongoing_translation.check_for_errors(tcx.sess);\n \n-    assert_and_save_dep_graph(tcx,\n-                              metadata_incr_hashes,\n-                              link_meta);\n+    assert_and_save_dep_graph(tcx);\n     ongoing_translation\n }\n \n-fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       metadata_incr_hashes: EncodedMetadataHashes,\n-                                       link_meta: LinkMeta) {\n+fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     time(tcx.sess.time_passes(),\n          \"assert dep graph\",\n          || rustc_incremental::assert_dep_graph(tcx));\n \n     time(tcx.sess.time_passes(),\n          \"serialize dep graph\",\n-         || rustc_incremental::save_dep_graph(tcx,\n-                                              &metadata_incr_hashes,\n-                                              link_meta.crate_hash));\n+         || rustc_incremental::save_dep_graph(tcx));\n }\n \n #[inline(never)] // give this a place in the profiler"}, {"sha": "645898601614b33f907dfe941b9eb60fcc96e9d7", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -201,7 +201,7 @@ impl TransCrate for MetadataOnlyTransCrate {\n                         .fingerprint_of(&DepNode::new_no_params(DepKind::Krate));\n         let link_meta = build_link_meta(crate_hash);\n         let exported_symbols = ::find_exported_symbols(tcx);\n-        let (metadata, _hashes) = tcx.encode_metadata(&link_meta, &exported_symbols);\n+        let metadata = tcx.encode_metadata(&link_meta, &exported_symbols);\n \n         OngoingCrateTranslation {\n             metadata: metadata,"}, {"sha": "80be2a85e5261473ec807f0f2164e6af80701fcc", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b0e43c87c5f46337b3792136ebd9b2aa74417/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c60b0e43c87c5f46337b3792136ebd9b2aa74417", "patch": "@@ -742,18 +742,6 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\",\n                                        cfg_fn!(rustc_attrs))),\n-    (\"rustc_metadata_dirty\", Whitelisted, Gated(Stability::Unstable,\n-                                                \"rustc_attrs\",\n-                                                \"the `#[rustc_metadata_dirty]` attribute \\\n-                                                 is just used for rustc unit tests \\\n-                                                 and will never be stable\",\n-                                                 cfg_fn!(rustc_attrs))),\n-    (\"rustc_metadata_clean\", Whitelisted, Gated(Stability::Unstable,\n-                                                \"rustc_attrs\",\n-                                                \"the `#[rustc_metadata_clean]` attribute \\\n-                                                 is just used for rustc unit tests \\\n-                                                 and will never be stable\",\n-                                                 cfg_fn!(rustc_attrs))),\n     (\"rustc_partition_reused\", Whitelisted, Gated(Stability::Unstable,\n                                                   \"rustc_attrs\",\n                                                   \"this attribute \\"}]}