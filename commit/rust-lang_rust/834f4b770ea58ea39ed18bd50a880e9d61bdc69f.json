{"sha": "834f4b770ea58ea39ed18bd50a880e9d61bdc69f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzNGY0Yjc3MGVhNThlYTM5ZWQxOGJkNTBhODgwZTlkNjFiZGM2OWY=", "commit": {"author": {"name": "Taylor Yu", "email": "tlyu@mit.edu", "date": "2021-06-12T20:10:58Z"}, "committer": {"name": "Taylor Yu", "email": "tlyu@mit.edu", "date": "2021-06-12T21:33:13Z"}, "message": "updates based on feedback\n\nMake minor wording changes in a few places. Move `filter` to the\n\"transformations\" section. Add `zip` methods to the \"transformations\"\nsection. Clarify the section about `Option` iterators, and add a section\nabout collecting into `Option`.\n\nClarify that for `Result`, `or` and `or_else` can also produce a\n`Result` having a different type.", "tree": {"sha": "2e87a55bdcf90d1c7b33c4108e93a4d0e6ce1b08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e87a55bdcf90d1c7b33c4108e93a4d0e6ce1b08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/834f4b770ea58ea39ed18bd50a880e9d61bdc69f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/834f4b770ea58ea39ed18bd50a880e9d61bdc69f", "html_url": "https://github.com/rust-lang/rust/commit/834f4b770ea58ea39ed18bd50a880e9d61bdc69f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/834f4b770ea58ea39ed18bd50a880e9d61bdc69f/comments", "author": {"login": "tlyu", "id": 431873, "node_id": "MDQ6VXNlcjQzMTg3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlyu", "html_url": "https://github.com/tlyu", "followers_url": "https://api.github.com/users/tlyu/followers", "following_url": "https://api.github.com/users/tlyu/following{/other_user}", "gists_url": "https://api.github.com/users/tlyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlyu/subscriptions", "organizations_url": "https://api.github.com/users/tlyu/orgs", "repos_url": "https://api.github.com/users/tlyu/repos", "events_url": "https://api.github.com/users/tlyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tlyu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tlyu", "id": 431873, "node_id": "MDQ6VXNlcjQzMTg3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlyu", "html_url": "https://github.com/tlyu", "followers_url": "https://api.github.com/users/tlyu/followers", "following_url": "https://api.github.com/users/tlyu/following{/other_user}", "gists_url": "https://api.github.com/users/tlyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlyu/subscriptions", "organizations_url": "https://api.github.com/users/tlyu/orgs", "repos_url": "https://api.github.com/users/tlyu/repos", "events_url": "https://api.github.com/users/tlyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tlyu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7265bef2e7d4320e809ca6694787925cd0d7b8cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7265bef2e7d4320e809ca6694787925cd0d7b8cb", "html_url": "https://github.com/rust-lang/rust/commit/7265bef2e7d4320e809ca6694787925cd0d7b8cb"}], "stats": {"total": 123, "additions": 83, "deletions": 40}, "files": [{"sha": "28ea504ec0a71af2544e6f283924fde7806890e0", "filename": "library/core/src/option.rs", "status": "modified", "additions": 75, "deletions": 35, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/834f4b770ea58ea39ed18bd50a880e9d61bdc69f/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/834f4b770ea58ea39ed18bd50a880e9d61bdc69f/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=834f4b770ea58ea39ed18bd50a880e9d61bdc69f", "patch": "@@ -132,7 +132,8 @@\n //! * [`unwrap_or`] returns the provided default value\n //! * [`unwrap_or_default`] returns the default value of the type `T`\n //!   (which must implement the [`Default`] trait)\n-//! * [`unwrap_or_else`] evaluates a provided function\n+//! * [`unwrap_or_else`] returns the result of evaluating the provided\n+//!   function\n //!\n //! [`Default`]: crate::default::Default\n //! [`expect`]: Option::expect\n@@ -143,6 +144,9 @@\n //!\n //! ## Transforming contained values\n //!\n+//! * [`filter`] calls the provided predicate function on the contained\n+//!   value `t` if the [`Option`] is [`Some(t)`], and returns [`Some(t)`]\n+//!   if the function returns `true`; otherwise, returns [`None`]\n //! * [`flatten`] removes one level of nesting from an\n //!   [`Option<Option<T>>`]\n //! * [`map`] transforms [`Some<T>`] to [`Some<U>`] using the provided\n@@ -159,17 +163,30 @@\n //!   a value of [`Err<E>`] using the provided function\n //! * [`transpose`] transposes an [`Option`] of a [`Result`] into a\n //!   [`Result`] of an [`Option`]\n+//! * [`zip`] returns [`Some((s, o))`] if `self` is [`Some(s)`] and the\n+//!   provided [`Option`] value is [`Some(o)`]; otherwise, returns [`None`]\n+//! * [`zip_with`] calls the provided function `f` and returns\n+//!   [`Some(f(s, o))`] if `self` is [`Some(s)`] and the provided\n+//!   [`Option`] value is [`Some(o)`]; otherwise, returns [`None`]\n //!\n //! [`Err(err)`]: Err\n+//! [`filter`]: Option::filter\n //! [`flatten`]: Option::flatten\n //! [`map`]: Option::map\n //! [`map_or`]: Option::map_or\n //! [`map_or_else`]: Option::map_or_else\n //! [`Ok(v)`]: Ok\n //! [`ok_or`]: Option::ok_or\n //! [`ok_or_else`]: Option::ok_or_else\n+//! [`Some(f(s, o))`]: Some\n+//! [`Some(o)`]: Some\n+//! [`Some(s)`]: Some\n+//! [`Some((s, o))`]: Some\n+//! [`Some(t)`]: Some\n //! [`Some(v)`]: Some\n //! [`transpose`]: Option::transpose\n+//! [`zip`]: Option::zip\n+//! [`zip_with`]: Option::zip_with\n //!\n //! ## Boolean operators\n //!\n@@ -196,34 +213,27 @@\n //! | [`xor`] | `Some(x)` | `None`    | `Some(x)` |\n //! | [`xor`] | `Some(x)` | `Some(y)` | `None`    |\n //!\n-//! The [`and_then`], [`filter`], and [`or_else`] methods take a function\n-//! as input, and only evaluate the function when they need to produce a\n-//! new value. [`and_then`] and [`or_else`] take a function that produces\n-//! another [`Option`] value, while [`filter`] takes a predicate that is\n-//! used to decide whether to pass the [`Some`] value through. Only the\n-//! [`and_then`] method can produce an [`Option<U>`] value having a\n+//! The [`and_then`] and [`or_else`] methods take a function as input, and\n+//! only evaluate the function when they need to produce a new value. Only\n+//! the [`and_then`] method can produce an [`Option<U>`] value having a\n //! different inner type `U` than [`Option<T>`].\n //!\n //! | method       | self      | function input | function result | output    |\n //! |--------------|-----------|----------------|-----------------|-----------|\n //! | [`and_then`] | `None`    | (not provided) | (not evaluated) | `None`    |\n //! | [`and_then`] | `Some(x)` | `x`            | `None`          | `None`    |\n //! | [`and_then`] | `Some(x)` | `x`            | `Some(y)`       | `Some(y)` |\n-//! | [`filter`]   | `None`    | (not provided) | (not evaluated) | `None`    |\n-//! | [`filter`]   | `Some(x)` | `x`            | `false`         | `None`    |\n-//! | [`filter`]   | `Some(x)` | `x`            | `true`          | `Some(x)` |\n //! | [`or_else`]  | `None`    | (not provided) | `None`          | `None`    |\n //! | [`or_else`]  | `None`    | (not provided) | `Some(y)`       | `Some(y)` |\n //! | [`or_else`]  | `Some(x)` | (not provided) | (not evaluated) | `Some(x)` |\n //!\n //! [`and`]: Option::and\n //! [`and_then`]: Option::and_then\n-//! [`filter`]: Option::filter\n //! [`or`]: Option::or\n //! [`or_else`]: Option::or_else\n //! [`xor`]: Option::xor\n //!\n-//! ## Iterators\n+//! ## Iterating over `Option`\n //!\n //! An [`Option`] can be iterated over. This can be helpful if you need an\n //! iterator that is conditionally empty. The iterator will either produce\n@@ -241,27 +251,26 @@\n //! * [`iter_mut`] produces a mutable reference of type `&mut T` to the\n //!   contained value\n //!\n-//! [`Option`] implements the [`FromIterator`] trait, which allows an\n-//! iterator over [`Option`] values to be collected into an [`Option`] of a\n-//! collection of each contained value of the original [`Option`] values,\n-//! or [`None`] if any of the elements was [`None`].\n-//!\n //! [`empty()`]: crate::iter::empty\n-//! [`FromIterator`]: Option#impl-FromIterator%3COption%3CA%3E%3E\n //! [`into_iter`]: Option::into_iter\n //! [`iter`]: Option::iter\n //! [`iter_mut`]: Option::iter_mut\n //! [`once(v)`]: crate::iter::once\n //! [`Some(v)`]: Some\n //!\n-//! An iterator over [`Option`] can be useful when chaining iterators:\n+//! An iterator over [`Option`] can be useful when chaining iterators, for\n+//! example, to conditionally insert items. (It's not always necessary to\n+//! explicitly call an iterator constructor: many [`Iterator`] methods that\n+//! accept other iterators will also accept iterable types that implement\n+//! [`IntoIterator`], which includes [`Option`].)\n //!\n //! ```\n //! let yep = Some(42);\n //! let nope = None;\n-//! let nums: Vec<i32> = (0..4).chain(yep.into_iter()).chain(4..8).collect();\n+//! // chain() already calls into_iter(), so we don't have to do so\n+//! let nums: Vec<i32> = (0..4).chain(yep).chain(4..8).collect();\n //! assert_eq!(nums, [0, 1, 2, 3, 42, 4, 5, 6, 7]);\n-//! let nums: Vec<i32> = (0..4).chain(nope.into_iter()).chain(4..8).collect();\n+//! let nums: Vec<i32> = (0..4).chain(nope).chain(4..8).collect();\n //! assert_eq!(nums, [0, 1, 2, 3, 4, 5, 6, 7]);\n //! ```\n //!\n@@ -270,32 +279,63 @@\n //! concrete type. Chaining an iterated [`Option`] can help with that.\n //!\n //! ```\n-//! let yep = Some(42);\n-//! let nope = None;\n-//!\n-//! fn make_iter(opt: Option<i32>) -> impl Iterator<Item = i32> {\n-//!     (0..4).chain(opt.into_iter()).chain(4..8)\n+//! fn make_iter(do_insert: bool) -> impl Iterator<Item = i32> {\n+//!     // Explicit returns to illustrate return types matching\n+//!     match do_insert {\n+//!         true => return (0..4).chain(Some(42)).chain(4..8),\n+//!         false => return (0..4).chain(None).chain(4..8),\n+//!     }\n //! }\n-//! println!(\"{:?}\", make_iter(yep).collect::<Vec<_>>());\n-//! println!(\"{:?}\", make_iter(nope).collect::<Vec<_>>());\n+//! println!(\"{:?}\", make_iter(true).collect::<Vec<_>>());\n+//! println!(\"{:?}\", make_iter(false).collect::<Vec<_>>());\n //! ```\n //!\n-//! If we try to do the same thing, but using pattern matching, we can't\n-//! return `impl Iterator` anymore because the concrete types of the return\n-//! values differ.\n+//! If we try to do the same thing, but using [`once()`] and [`empty()`],\n+//! we can't return `impl Iterator` anymore because the concrete types of\n+//! the return values differ.\n //!\n //! ```compile_fail,E0308\n //! # use std::iter::{empty, once};\n //! // This won't compile because all possible returns from the function\n //! // must have the same concrete type.\n-//! fn make_iter(opt: Option<i32>) -> impl Iterator<Item = i32> {\n-//!     match opt {\n-//!         Some(x) => return (0..4).chain(once(x)).chain(4..8),\n-//!         None => return (0..4).chain(empty()).chain(4..8)\n+//! fn make_iter(do_insert: bool) -> impl Iterator<Item = i32> {\n+//!     // Explicit returns to illustrate return types not matching\n+//!     match x {\n+//!         true => return (0..4).chain(once(42)).chain(4..8),\n+//!         false => return (0..4).chain(empty()).chain(4..8),\n //!     }\n //! }\n //! ```\n //!\n+//! [`once()`]: crate::iter::once\n+//!\n+//! ## Collecting into `Option`\n+//!\n+//! [`Option`] implements the [`FromIterator`] trait, which allows an\n+//! iterator over [`Option`] values to be collected into an [`Option`] of a\n+//! collection of each contained value of the original [`Option`] values,\n+//! or [`None`] if any of the elements was [`None`].\n+//!\n+//! [`FromIterator`]: Option#impl-FromIterator%3COption%3CA%3E%3E\n+//!\n+//! ```\n+//! let v = vec![Some(2), Some(4), None, Some(8)];\n+//! let res: Option<Vec<_>> = v.into_iter().collect();\n+//! assert_eq!(res, None);\n+//! let v = vec![Some(2), Some(4), Some(8)];\n+//! let res: Option<Vec<_>> = v.into_iter().collect();\n+//! assert_eq!(res, Some(vec![2, 4, 8]));\n+//! ```\n+//!\n+//! [`Option`] also implements the [`Product`] and [`Sum`] traits, allowing\n+//! an iterator over [`Option`] values to provide the\n+//! [`product`][m.product] and [`sum`][m.sum] methods.\n+//!\n+//! [`Product`]: Option#impl-Product%3COption%3CU%3E%3E\n+//! [`Sum`]: Option#impl-Sum%3COption%3CU%3E%3E\n+//! [m.product]: crate::iter::Iterator::product\n+//! [m.sum]: crate::iter::Iterator::sum\n+//!\n //! ## Modifying an [`Option`] in-place\n //!\n //! These methods return a mutable reference to the contained value of a"}, {"sha": "444de78a4645e1ea862346c497d6f44256ee83ac", "filename": "library/core/src/result.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/834f4b770ea58ea39ed18bd50a880e9d61bdc69f/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/834f4b770ea58ea39ed18bd50a880e9d61bdc69f/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=834f4b770ea58ea39ed18bd50a880e9d61bdc69f", "patch": "@@ -235,9 +235,10 @@\n //! ones that take a function as input (to be lazily evaluated).\n //!\n //! The [`and`] and [`or`] methods take another [`Result`] as input, and\n-//! produce an [`Result`] as output. Only the [`and`] method can produce a\n+//! produce a [`Result`] as output. The [`and`] method can produce a\n //! [`Result<U, E>`] value having a different inner type `U` than\n-//! [`Result<T, E>`].\n+//! [`Result<T, E>`]. The [`or`] method can produce a [`Result<T, F>`]\n+//! value having a different error type `F` than [`Result<T, E>`].\n //!\n //! | method  | self     | input     | output   |\n //! |---------|----------|-----------|----------|\n@@ -249,9 +250,11 @@\n //! | [`or`]  | `Ok(x)`  | (ignored) | `Ok(x)`  |\n //!\n //! The [`and_then`] and [`or_else`] methods take a function as input, and\n-//! only evaluate the function when they need to produce a new value. Only\n-//! the [`and_then`] method can produce an [`Result<U, E>`] value having a\n-//! different inner type `U` than [`Result<T, E>`].\n+//! only evaluate the function when they need to produce a new value. The\n+//! [`and_then`] method can produce a [`Result<U, E>`] value having a\n+//! different inner type `U` than [`Result<T, E>`]. The [`or_else`] method\n+//! can produce a [`Result<T, F>`] value having a different error type `F`\n+//! than [`Result<T, E>`].\n //!\n //! | method       | self     | function input | function result | output   |\n //! |--------------|----------|----------------|-----------------|----------|"}]}