{"sha": "bf8ed45adc485e0e8e678e7b43b0c67ff93392f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmOGVkNDVhZGM0ODVlMGU4ZTY3OGU3YjQzYjBjNjdmZjkzMzkyZjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-02-18T01:01:47Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-02-18T04:09:21Z"}, "message": "Implement Set container on top of a bit vector", "tree": {"sha": "074f021c34a2dcd43f23b104a694f46847ea39a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/074f021c34a2dcd43f23b104a694f46847ea39a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf8ed45adc485e0e8e678e7b43b0c67ff93392f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf8ed45adc485e0e8e678e7b43b0c67ff93392f5", "html_url": "https://github.com/rust-lang/rust/commit/bf8ed45adc485e0e8e678e7b43b0c67ff93392f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf8ed45adc485e0e8e678e7b43b0c67ff93392f5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "393a4b41f60612f234394b58b8e3bf3261ca9566", "url": "https://api.github.com/repos/rust-lang/rust/commits/393a4b41f60612f234394b58b8e3bf3261ca9566", "html_url": "https://github.com/rust-lang/rust/commit/393a4b41f60612f234394b58b8e3bf3261ca9566"}], "stats": {"total": 510, "additions": 470, "deletions": 40}, "files": [{"sha": "955729ed2fe0d249a06baadb7aa0b36166114898", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 470, "deletions": 40, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/bf8ed45adc485e0e8e678e7b43b0c67ff93392f5/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf8ed45adc485e0e8e678e7b43b0c67ff93392f5/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=bf8ed45adc485e0e8e678e7b43b0c67ff93392f5", "patch": "@@ -8,10 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::container::{Container, Mutable, Set};\n+use core::num::NumCast;\n use core::ops;\n use core::prelude::*;\n use core::uint;\n-use core::vec::{cast_to_mut, from_elem};\n+use core::vec::from_elem;\n use core::vec;\n \n struct SmallBitv {\n@@ -133,18 +135,15 @@ impl BigBitv {\n         let len = b.storage.len();\n         assert (self.storage.len() == len);\n         let mut changed = false;\n-        do uint::range(0, len) |i| {\n+        for uint::range(0, len) |i| {\n             let mask = big_mask(nbits, i);\n             let w0 = self.storage[i] & mask;\n             let w1 = b.storage[i] & mask;\n             let w = op(w0, w1) & mask;\n             if w0 != w {\n-                unsafe {\n-                    changed = true;\n-                    self.storage[i] = w;\n-                }\n+                changed = true;\n+                self.storage[i] = w;\n             }\n-            true\n         }\n         changed\n     }\n@@ -556,13 +555,314 @@ pub fn from_fn(len: uint, f: fn(index: uint) -> bool) -> Bitv {\n     bitv\n }\n \n+impl ops::Index<uint,bool> for Bitv {\n+    pure fn index(&self, i: uint) -> bool {\n+        self.get(i)\n+    }\n+}\n \n+#[inline(always)]\n+pure fn iterate_bits(base: uint, bits: uint, f: fn(uint) -> bool) -> bool {\n+    if bits == 0 {\n+        return true;\n+    }\n+    for uint::range(0, uint::bits) |i| {\n+        if bits & (1 << i) != 0 {\n+            if !f(base + i) {\n+                return false;\n+            }\n+        }\n+    }\n+    return true;\n+}\n \n+/// An implementation of a set using a bit vector as an underlying\n+/// representation for holding numerical elements.\n+///\n+/// It should also be noted that the amount of storage necessary for holding a\n+/// set of objects is proportional to the maximum of the objects when viewed\n+/// as a uint.\n+pub struct BitvSet {\n+    priv size: uint,\n+\n+    // In theory this is a Bitv instead of always a BigBitv, but knowing that\n+    // there's an array of storage makes our lives a whole lot easier when\n+    // performing union/intersection/etc operations\n+    priv bitv: BigBitv\n+}\n \n+impl BitvSet {\n+    /// Creates a new bit vector set with initially no contents\n+    static fn new() -> BitvSet {\n+        BitvSet{ size: 0, bitv: BigBitv::new(~[0]) }\n+    }\n \n-impl ops::Index<uint,bool> for Bitv {\n-    pure fn index(&self, i: uint) -> bool {\n-        self.get(i)\n+    /// Creates a new bit vector set from the given bit vector\n+    static fn from_bitv(bitv: Bitv) -> BitvSet {\n+        let mut size = 0;\n+        for bitv.ones |_| {\n+            size += 1;\n+        }\n+        let Bitv{rep, _} = bitv;\n+        match rep {\n+            Big(~b) => BitvSet{ size: size, bitv: b },\n+            Small(~SmallBitv{bits}) =>\n+                BitvSet{ size: size, bitv: BigBitv{ storage: ~[bits] } },\n+        }\n+    }\n+\n+    /// Returns the capacity in bits for this bit vector. Inserting any\n+    /// element less than this amount will not trigger a resizing.\n+    pure fn capacity(&self) -> uint { self.bitv.storage.len() * uint::bits }\n+\n+    /// Consumes this set to return the underlying bit vector\n+    fn unwrap(self) -> Bitv {\n+        let cap = self.capacity();\n+        let BitvSet{bitv, _} = self;\n+        return Bitv{ nbits:cap, rep: Big(~bitv) };\n+    }\n+\n+    #[inline(always)]\n+    priv fn other_op(&mut self, other: &BitvSet, f: fn(uint, uint) -> uint) {\n+        fn nbits(mut w: uint) -> uint {\n+            let mut bits = 0;\n+            for uint::bits.times {\n+                if w == 0 {\n+                    break;\n+                }\n+                bits += w & 1;\n+                w >>= 1;\n+            }\n+            return bits;\n+        }\n+        if self.capacity() < other.capacity() {\n+            self.bitv.storage.grow(other.capacity() / uint::bits, &0);\n+        }\n+        for other.bitv.storage.eachi |i, &w| {\n+            let old = self.bitv.storage[i];\n+            let new = f(old, w);\n+            self.bitv.storage[i] = new;\n+            self.size += nbits(new) - nbits(old);\n+        }\n+    }\n+\n+    /// Union in-place with the specified other bit vector\n+    fn union_with(&mut self, other: &BitvSet) {\n+        self.other_op(other, |w1, w2| w1 | w2);\n+    }\n+\n+    /// Intersect in-place with the specified other bit vector\n+    fn intersect_with(&mut self, other: &BitvSet) {\n+        self.other_op(other, |w1, w2| w1 & w2);\n+    }\n+\n+    /// Difference in-place with the specified other bit vector\n+    fn difference_with(&mut self, other: &BitvSet) {\n+        self.other_op(other, |w1, w2| w1 & !w2);\n+    }\n+\n+    /// Symmetric difference in-place with the specified other bit vector\n+    fn symmetric_difference_with(&mut self, other: &BitvSet) {\n+        self.other_op(other, |w1, w2| w1 ^ w2);\n+    }\n+}\n+\n+impl BaseIter<uint> for BitvSet {\n+    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+\n+    pure fn each(&self, blk: fn(v: &uint) -> bool) {\n+        for self.bitv.storage.eachi |i, &w| {\n+            if !iterate_bits(i * uint::bits, w, |b| blk(&b)) {\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n+impl cmp::Eq for BitvSet {\n+    pure fn eq(&self, other: &BitvSet) -> bool {\n+        if self.size != other.size {\n+            return false;\n+        }\n+        for self.each_common(other) |_, w1, w2| {\n+            if w1 != w2 {\n+                return false;\n+            }\n+        }\n+        for self.each_outlier(other) |_, _, w| {\n+            if w != 0 {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    pure fn ne(&self, other: &BitvSet) -> bool { !self.eq(other) }\n+}\n+\n+impl Container for BitvSet {\n+    pure fn len(&self) -> uint { self.size }\n+    pure fn is_empty(&self) -> bool { self.size == 0 }\n+}\n+\n+impl Mutable for BitvSet {\n+    fn clear(&mut self) {\n+        for self.bitv.each_storage |w| { *w = 0; }\n+        self.size = 0;\n+    }\n+}\n+\n+impl Set<uint> for BitvSet {\n+    pure fn contains(&self, value: &uint) -> bool {\n+        *value < self.bitv.storage.len() * uint::bits && self.bitv.get(*value)\n+    }\n+\n+    fn insert(&mut self, value: uint) -> bool {\n+        if self.contains(&value) {\n+            return false;\n+        }\n+        let nbits = self.capacity();\n+        if value >= nbits {\n+            let newsize = uint::max(value, nbits * 2) / uint::bits + 1;\n+            assert newsize > self.bitv.storage.len();\n+            self.bitv.storage.grow(newsize, &0);\n+        }\n+        self.size += 1;\n+        self.bitv.set(value, true);\n+        return true;\n+    }\n+\n+    fn remove(&mut self, value: &uint) -> bool {\n+        if !self.contains(value) {\n+            return false;\n+        }\n+        self.size -= 1;\n+        self.bitv.set(*value, false);\n+\n+        // Attempt to truncate our storage\n+        let mut i = self.bitv.storage.len();\n+        while i > 1 && self.bitv.storage[i - 1] == 0 {\n+            i -= 1;\n+        }\n+        self.bitv.storage.truncate(i);\n+\n+        return true;\n+    }\n+\n+    pure fn is_disjoint(&self, other: &BitvSet) -> bool {\n+        for self.intersection(other) |_| {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    pure fn is_subset(&self, other: &BitvSet) -> bool {\n+        for self.each_common(other) |_, w1, w2| {\n+            if w1 & w2 != w1 {\n+                return false;\n+            }\n+        }\n+        /* If anything is not ours, then everything is not ours so we're\n+           definitely a subset in that case. Otherwise if there's any stray\n+           ones that 'other' doesn't have, we're not a subset. */\n+        for self.each_outlier(other) |mine, _, w| {\n+            if !mine {\n+                return true;\n+            } else if w != 0 {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    pure fn is_superset(&self, other: &BitvSet) -> bool {\n+        other.is_subset(self)\n+    }\n+\n+    pure fn difference(&self, other: &BitvSet, f: fn(&uint) -> bool) {\n+        for self.each_common(other) |i, w1, w2| {\n+            if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n+                return;\n+            }\n+        }\n+        /* everything we have that they don't also shows up */\n+        self.each_outlier(other, |mine, i, w|\n+            !mine || iterate_bits(i, w, |b| f(&b))\n+        );\n+    }\n+\n+    pure fn symmetric_difference(&self, other: &BitvSet,\n+                                 f: fn(&uint) -> bool) {\n+        for self.each_common(other) |i, w1, w2| {\n+            if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n+                return;\n+            }\n+        }\n+        self.each_outlier(other, |_, i, w|\n+            iterate_bits(i, w, |b| f(&b))\n+        );\n+    }\n+\n+    pure fn intersection(&self, other: &BitvSet, f: fn(&uint) -> bool) {\n+        for self.each_common(other) |i, w1, w2| {\n+            if !iterate_bits(i, w1 & w2, |b| f(&b)) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    pure fn union(&self, other: &BitvSet, f: fn(&uint) -> bool) {\n+        for self.each_common(other) |i, w1, w2| {\n+            if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n+                return;\n+            }\n+        }\n+        self.each_outlier(other, |_, i, w|\n+            iterate_bits(i, w, |b| f(&b))\n+        );\n+    }\n+}\n+\n+priv impl BitvSet {\n+    /// Visits each of the words that the two bit vectors (self and other)\n+    /// both have in common. The three yielded arguments are (bit location,\n+    /// w1, w2) where the bit location is the number of bits offset so far,\n+    /// and w1/w2 are the words coming from the two vectors self, other.\n+    pure fn each_common(&self, other: &BitvSet,\n+                        f: fn(uint, uint, uint) -> bool) {\n+        let min = uint::min(self.bitv.storage.len(),\n+                            other.bitv.storage.len());\n+        for self.bitv.storage.view(0, min).eachi |i, &w| {\n+            if !f(i * uint::bits, w, other.bitv.storage[i]) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    /// Visits each word in self or other that extends beyond the other. This\n+    /// will only iterate through one of the vectors, and it only iterates\n+    /// over the portion that doesn't overlap with the other one.\n+    ///\n+    /// The yielded arguments are a bool, the bit offset, and a word. The bool\n+    /// is true if the word comes from 'self', and false if it comes from\n+    /// 'other'.\n+    pure fn each_outlier(&self, other: &BitvSet,\n+                         f: fn(bool, uint, uint) -> bool) {\n+        let len1 = self.bitv.storage.len();\n+        let len2 = other.bitv.storage.len();\n+        let min = uint::min(len1, len2);\n+\n+        /* only one of these loops will execute and that's the point */\n+        for self.bitv.storage.view(min, len1).eachi |i, &w| {\n+            if !f(true, (i + min) * uint::bits, w) {\n+                return;\n+            }\n+        }\n+        for other.bitv.storage.view(min, len2).eachi |i, &w| {\n+            if !f(false, (i + min) * uint::bits, w) {\n+                return;\n+            }\n+        }\n     }\n }\n \n@@ -946,48 +1246,178 @@ mod tests {\n \n     #[test]\n     pub fn test_small_difference() {\n-      let mut b1 = Bitv::new(3, false);\n-      let mut b2 = Bitv::new(3, false);\n-      b1.set(0, true);\n-      b1.set(1, true);\n-      b2.set(1, true);\n-      b2.set(2, true);\n-      assert b1.difference(&b2);\n-      assert b1[0];\n-      assert !b1[1];\n-      assert !b1[2];\n+        let mut b1 = Bitv::new(3, false);\n+        let mut b2 = Bitv::new(3, false);\n+        b1.set(0, true);\n+        b1.set(1, true);\n+        b2.set(1, true);\n+        b2.set(2, true);\n+        assert b1.difference(&b2);\n+        assert b1[0];\n+        assert !b1[1];\n+        assert !b1[2];\n     }\n \n     #[test]\n     pub fn test_big_difference() {\n-      let mut b1 = Bitv::new(100, false);\n-      let mut b2 = Bitv::new(100, false);\n-      b1.set(0, true);\n-      b1.set(40, true);\n-      b2.set(40, true);\n-      b2.set(80, true);\n-      assert b1.difference(&b2);\n-      assert b1[0];\n-      assert !b1[40];\n-      assert !b1[80];\n+        let mut b1 = Bitv::new(100, false);\n+        let mut b2 = Bitv::new(100, false);\n+        b1.set(0, true);\n+        b1.set(40, true);\n+        b2.set(40, true);\n+        b2.set(80, true);\n+        assert b1.difference(&b2);\n+        assert b1[0];\n+        assert !b1[40];\n+        assert !b1[80];\n     }\n \n     #[test]\n     pub fn test_small_clear() {\n-      let mut b = Bitv::new(14, true);\n-      b.clear();\n-      for b.ones |i| {\n-          fail!(fmt!(\"found 1 at %?\", i));\n-      }\n+        let mut b = Bitv::new(14, true);\n+        b.clear();\n+        for b.ones |i| {\n+            fail!(fmt!(\"found 1 at %?\", i));\n+        }\n     }\n \n     #[test]\n     pub fn test_big_clear() {\n-      let mut b = Bitv::new(140, true);\n-      b.clear();\n-      for b.ones |i| {\n-          fail!(fmt!(\"found 1 at %?\", i));\n-      }\n+        let mut b = Bitv::new(140, true);\n+        b.clear();\n+        for b.ones |i| {\n+            fail!(fmt!(\"found 1 at %?\", i));\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_bitv_set_basic() {\n+        let mut b = BitvSet::new();\n+        assert b.insert(3);\n+        assert !b.insert(3);\n+        assert b.contains(&3);\n+        assert b.insert(400);\n+        assert !b.insert(400);\n+        assert b.contains(&400);\n+        assert b.len() == 2;\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_intersection() {\n+        let mut a = BitvSet::new();\n+        let mut b = BitvSet::new();\n+\n+        assert a.insert(11);\n+        assert a.insert(1);\n+        assert a.insert(3);\n+        assert a.insert(77);\n+        assert a.insert(103);\n+        assert a.insert(5);\n+\n+        assert b.insert(2);\n+        assert b.insert(11);\n+        assert b.insert(77);\n+        assert b.insert(5);\n+        assert b.insert(3);\n+\n+        let mut i = 0;\n+        let expected = [3, 5, 11, 77];\n+        for a.intersection(&b) |x| {\n+            assert *x == expected[i];\n+            i += 1\n+        }\n+        assert i == expected.len();\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_difference() {\n+        let mut a = BitvSet::new();\n+        let mut b = BitvSet::new();\n+\n+        assert a.insert(1);\n+        assert a.insert(3);\n+        assert a.insert(5);\n+        assert a.insert(200);\n+        assert a.insert(500);\n+\n+        assert b.insert(3);\n+        assert b.insert(200);\n+\n+        let mut i = 0;\n+        let expected = [1, 5, 500];\n+        for a.difference(&b) |x| {\n+            assert *x == expected[i];\n+            i += 1\n+        }\n+        assert i == expected.len();\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_symmetric_difference() {\n+        let mut a = BitvSet::new();\n+        let mut b = BitvSet::new();\n+\n+        assert a.insert(1);\n+        assert a.insert(3);\n+        assert a.insert(5);\n+        assert a.insert(9);\n+        assert a.insert(11);\n+\n+        assert b.insert(3);\n+        assert b.insert(9);\n+        assert b.insert(14);\n+        assert b.insert(220);\n+\n+        let mut i = 0;\n+        let expected = [1, 5, 11, 14, 220];\n+        for a.symmetric_difference(&b) |x| {\n+            assert *x == expected[i];\n+            i += 1\n+        }\n+        assert i == expected.len();\n+    }\n+\n+    #[test]\n+    pub fn test_bitv_set_union() {\n+        let mut a = BitvSet::new();\n+        let mut b = BitvSet::new();\n+        assert a.insert(1);\n+        assert a.insert(3);\n+        assert a.insert(5);\n+        assert a.insert(9);\n+        assert a.insert(11);\n+        assert a.insert(160);\n+        assert a.insert(19);\n+        assert a.insert(24);\n+\n+        assert b.insert(1);\n+        assert b.insert(5);\n+        assert b.insert(9);\n+        assert b.insert(13);\n+        assert b.insert(19);\n+\n+        let mut i = 0;\n+        let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160];\n+        for a.union(&b) |x| {\n+            assert *x == expected[i];\n+            i += 1\n+        }\n+        assert i == expected.len();\n+    }\n+\n+    #[test]\n+    pub fn test_bitv_remove() {\n+        let mut a = BitvSet::new();\n+\n+        assert a.insert(1);\n+        assert a.remove(&1);\n+\n+        assert a.insert(100);\n+        assert a.remove(&100);\n+\n+        assert a.insert(1000);\n+        assert a.remove(&1000);\n+        assert a.capacity() == uint::bits;\n     }\n }\n "}]}