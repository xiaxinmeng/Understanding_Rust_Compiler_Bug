{"sha": "7c360dc117d554a11f7193505da0835c4b890c6f", "node_id": "C_kwDOAAsO6NoAKDdjMzYwZGMxMTdkNTU0YTExZjcxOTM1MDVkYTA4MzVjNGI4OTBjNmY", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-06-16T15:41:40Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-06-16T15:53:59Z"}, "message": "Move/rename `lazy::{OnceCell, Lazy}` to `cell::{OnceCell, LazyCell}`", "tree": {"sha": "214c085729d9636756ebc16e0f6b17e1b5802629", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/214c085729d9636756ebc16e0f6b17e1b5802629"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c360dc117d554a11f7193505da0835c4b890c6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c360dc117d554a11f7193505da0835c4b890c6f", "html_url": "https://github.com/rust-lang/rust/commit/7c360dc117d554a11f7193505da0835c4b890c6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c360dc117d554a11f7193505da0835c4b890c6f/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "392d2728683f140f6125732240e462c43c5caff4", "url": "https://api.github.com/repos/rust-lang/rust/commits/392d2728683f140f6125732240e462c43c5caff4", "html_url": "https://github.com/rust-lang/rust/commit/392d2728683f140f6125732240e462c43c5caff4"}], "stats": {"total": 807, "additions": 407, "deletions": 400}, "files": [{"sha": "71699b5cf38306dcad52c67822fbb4302892268e", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c360dc117d554a11f7193505da0835c4b890c6f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c360dc117d554a11f7193505da0835c4b890c6f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=7c360dc117d554a11f7193505da0835c4b890c6f", "patch": "@@ -36,9 +36,9 @@ use rustc_target::abi::Size;\n \n use libc::c_uint;\n use smallvec::SmallVec;\n+use std::cell::OnceCell;\n use std::cell::RefCell;\n use std::iter;\n-use std::lazy::OnceCell;\n use tracing::debug;\n \n mod create_scope_map;"}, {"sha": "39c7a408fb50f4fc5ec48ddb7a6e93435b83ba11", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c360dc117d554a11f7193505da0835c4b890c6f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c360dc117d554a11f7193505da0835c4b890c6f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=7c360dc117d554a11f7193505da0835c4b890c6f", "patch": "@@ -38,11 +38,11 @@ use regex::Regex;\n use tempfile::Builder as TempFileBuilder;\n \n use std::borrow::Borrow;\n+use std::cell::OnceCell;\n use std::collections::BTreeSet;\n use std::ffi::OsString;\n use std::fs::{File, OpenOptions};\n use std::io::{BufWriter, Write};\n-use std::lazy::OnceCell;\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::process::{ExitStatus, Output, Stdio};"}, {"sha": "ec3d3d49bcb8673a2446b2ecea3c9f5fffee5f60", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c360dc117d554a11f7193505da0835c4b890c6f/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c360dc117d554a11f7193505da0835c4b890c6f/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=7c360dc117d554a11f7193505da0835c4b890c6f", "patch": "@@ -173,7 +173,7 @@ cfg_if! {\n         pub use std::cell::RefMut as LockGuard;\n         pub use std::cell::RefMut as MappedLockGuard;\n \n-        pub use std::lazy::OnceCell;\n+        pub use std::cell::OnceCell;\n \n         use std::cell::RefCell as InnerRwLock;\n         use std::cell::RefCell as InnerLock;"}, {"sha": "145fbd43ab11402dbbb0862fbddf64eabdc6ad0e", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c360dc117d554a11f7193505da0835c4b890c6f/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c360dc117d554a11f7193505da0835c4b890c6f/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=7c360dc117d554a11f7193505da0835c4b890c6f", "patch": "@@ -18,7 +18,7 @@ use std::path::{Path, PathBuf};\n use tracing::{instrument, trace};\n \n #[cfg(not(parallel_compiler))]\n-use std::lazy::Lazy;\n+use std::cell::LazyCell as Lazy;\n #[cfg(parallel_compiler)]\n use std::lazy::SyncLazy as Lazy;\n "}, {"sha": "ad85ac71fc8862c5d2ed8be9e84bcef8f7262b8b", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c360dc117d554a11f7193505da0835c4b890c6f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c360dc117d554a11f7193505da0835c4b890c6f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=7c360dc117d554a11f7193505da0835c4b890c6f", "patch": "@@ -29,9 +29,9 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, WellFormedLoc};\n \n+use std::cell::LazyCell;\n use std::convert::TryInto;\n use std::iter;\n-use std::lazy::Lazy;\n use std::ops::ControlFlow;\n \n /// Helper type of a temporary returned by `.for_item(...)`.\n@@ -1728,7 +1728,7 @@ fn check_variances_for_type_defn<'tcx>(\n     identify_constrained_generic_params(tcx, ty_predicates, None, &mut constrained_parameters);\n \n     // Lazily calculated because it is only needed in case of an error.\n-    let explicitly_bounded_params = Lazy::new(|| {\n+    let explicitly_bounded_params = LazyCell::new(|| {\n         let icx = crate::collect::ItemCtxt::new(tcx, item.def_id.to_def_id());\n         hir_generics\n             .predicates"}, {"sha": "63c83ddb6f7cf637488ab7bea7fdf36d5e43914b", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c360dc117d554a11f7193505da0835c4b890c6f/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c360dc117d554a11f7193505da0835c4b890c6f/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=7c360dc117d554a11f7193505da0835c4b890c6f", "patch": "@@ -199,6 +199,14 @@ use crate::mem;\n use crate::ops::{CoerceUnsized, Deref, DerefMut};\n use crate::ptr::{self, NonNull};\n \n+mod lazy;\n+mod once;\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub use lazy::LazyCell;\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub use once::OnceCell;\n+\n /// A mutable memory location.\n ///\n /// # Examples"}, {"sha": "7844be5f783a9d46d933cd1bbfc147f32253090f", "filename": "library/core/src/cell/lazy.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/7c360dc117d554a11f7193505da0835c4b890c6f/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c360dc117d554a11f7193505da0835c4b890c6f/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs?ref=7c360dc117d554a11f7193505da0835c4b890c6f", "patch": "@@ -0,0 +1,104 @@\n+use crate::cell::{Cell, OnceCell};\n+use crate::fmt;\n+use crate::ops::Deref;\n+\n+/// A value which is initialized on the first access.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::cell::LazyCell;\n+///\n+/// let lazy: LazyCell<i32> = LazyCell::new(|| {\n+///     println!(\"initializing\");\n+///     92\n+/// });\n+/// println!(\"ready\");\n+/// println!(\"{}\", *lazy);\n+/// println!(\"{}\", *lazy);\n+///\n+/// // Prints:\n+/// //   ready\n+/// //   initializing\n+/// //   92\n+/// //   92\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub struct LazyCell<T, F = fn() -> T> {\n+    cell: OnceCell<T>,\n+    init: Cell<Option<F>>,\n+}\n+\n+impl<T, F> LazyCell<T, F> {\n+    /// Creates a new lazy value with the given initializing function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::cell::LazyCell;\n+    ///\n+    /// let hello = \"Hello, World!\".to_string();\n+    ///\n+    /// let lazy = LazyCell::new(|| hello.to_uppercase());\n+    ///\n+    /// assert_eq!(&*lazy, \"HELLO, WORLD!\");\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub const fn new(init: F) -> LazyCell<T, F> {\n+        LazyCell { cell: OnceCell::new(), init: Cell::new(Some(init)) }\n+    }\n+}\n+\n+impl<T, F: FnOnce() -> T> LazyCell<T, F> {\n+    /// Forces the evaluation of this lazy value and returns a reference to\n+    /// the result.\n+    ///\n+    /// This is equivalent to the `Deref` impl, but is explicit.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::cell::LazyCell;\n+    ///\n+    /// let lazy = LazyCell::new(|| 92);\n+    ///\n+    /// assert_eq!(LazyCell::force(&lazy), &92);\n+    /// assert_eq!(&*lazy, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn force(this: &LazyCell<T, F>) -> &T {\n+        this.cell.get_or_init(|| match this.init.take() {\n+            Some(f) => f(),\n+            None => panic!(\"`Lazy` instance has previously been poisoned\"),\n+        })\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F: FnOnce() -> T> Deref for LazyCell<T, F> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        LazyCell::force(self)\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Default> Default for LazyCell<T> {\n+    /// Creates a new lazy value using `Default` as the initializing function.\n+    fn default() -> LazyCell<T> {\n+        LazyCell::new(T::default)\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: fmt::Debug, F> fmt::Debug for LazyCell<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n+    }\n+}"}, {"sha": "3c39394dd8c8e7007200f4c063e523d72ca87368", "filename": "library/core/src/cell/once.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/7c360dc117d554a11f7193505da0835c4b890c6f/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c360dc117d554a11f7193505da0835c4b890c6f/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs?ref=7c360dc117d554a11f7193505da0835c4b890c6f", "patch": "@@ -0,0 +1,283 @@\n+use crate::cell::UnsafeCell;\n+use crate::fmt;\n+use crate::mem;\n+\n+/// A cell which can be written to only once.\n+///\n+/// Unlike `RefCell`, a `OnceCell` only provides shared `&T` references to its value.\n+/// Unlike `Cell`, a `OnceCell` doesn't require copying or replacing the value to access it.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::cell::OnceCell;\n+///\n+/// let cell = OnceCell::new();\n+/// assert!(cell.get().is_none());\n+///\n+/// let value: &String = cell.get_or_init(|| {\n+///     \"Hello, World!\".to_string()\n+/// });\n+/// assert_eq!(value, \"Hello, World!\");\n+/// assert!(cell.get().is_some());\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub struct OnceCell<T> {\n+    // Invariant: written to at most once.\n+    inner: UnsafeCell<Option<T>>,\n+}\n+\n+impl<T> OnceCell<T> {\n+    /// Creates a new empty cell.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    #[must_use]\n+    pub const fn new() -> OnceCell<T> {\n+        OnceCell { inner: UnsafeCell::new(None) }\n+    }\n+\n+    /// Gets the reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get(&self) -> Option<&T> {\n+        // SAFETY: Safe due to `inner`'s invariant\n+        unsafe { &*self.inner.get() }.as_ref()\n+    }\n+\n+    /// Gets the mutable reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_mut(&mut self) -> Option<&mut T> {\n+        self.inner.get_mut().as_mut()\n+    }\n+\n+    /// Sets the contents of the cell to `value`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This method returns `Ok(())` if the cell was empty and `Err(value)` if\n+    /// it was full.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::cell::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// assert!(cell.get().is_none());\n+    ///\n+    /// assert_eq!(cell.set(92), Ok(()));\n+    /// assert_eq!(cell.set(62), Err(62));\n+    ///\n+    /// assert!(cell.get().is_some());\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn set(&self, value: T) -> Result<(), T> {\n+        // SAFETY: Safe because we cannot have overlapping mutable borrows\n+        let slot = unsafe { &*self.inner.get() };\n+        if slot.is_some() {\n+            return Err(value);\n+        }\n+\n+        // SAFETY: This is the only place where we set the slot, no races\n+        // due to reentrancy/concurrency are possible, and we've\n+        // checked that slot is currently `None`, so this write\n+        // maintains the `inner`'s invariant.\n+        let slot = unsafe { &mut *self.inner.get() };\n+        *slot = Some(value);\n+        Ok(())\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f`\n+    /// if the cell was empty.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. Doing\n+    /// so results in a panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::cell::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// let value = cell.get_or_init(|| 92);\n+    /// assert_eq!(value, &92);\n+    /// let value = cell.get_or_init(|| unreachable!());\n+    /// assert_eq!(value, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_or_init<F>(&self, f: F) -> &T\n+    where\n+        F: FnOnce() -> T,\n+    {\n+        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n+            Ok(val) => val,\n+        }\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if\n+    /// the cell was empty. If the cell was empty and `f` failed, an\n+    /// error is returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. Doing\n+    /// so results in a panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::cell::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n+    /// assert!(cell.get().is_none());\n+    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n+    ///     Ok(92)\n+    /// });\n+    /// assert_eq!(value, Ok(&92));\n+    /// assert_eq!(cell.get(), Some(&92))\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n+    where\n+        F: FnOnce() -> Result<T, E>,\n+    {\n+        if let Some(val) = self.get() {\n+            return Ok(val);\n+        }\n+        /// Avoid inlining the initialization closure into the common path that fetches\n+        /// the already initialized value\n+        #[cold]\n+        fn outlined_call<F, T, E>(f: F) -> Result<T, E>\n+        where\n+            F: FnOnce() -> Result<T, E>,\n+        {\n+            f()\n+        }\n+        let val = outlined_call(f)?;\n+        // Note that *some* forms of reentrant initialization might lead to\n+        // UB (see `reentrant_init` test). I believe that just removing this\n+        // `assert`, while keeping `set/get` would be sound, but it seems\n+        // better to panic, rather than to silently use an old value.\n+        assert!(self.set(val).is_ok(), \"reentrant init\");\n+        Ok(self.get().unwrap())\n+    }\n+\n+    /// Consumes the cell, returning the wrapped value.\n+    ///\n+    /// Returns `None` if the cell was empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::cell::OnceCell;\n+    ///\n+    /// let cell: OnceCell<String> = OnceCell::new();\n+    /// assert_eq!(cell.into_inner(), None);\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn into_inner(self) -> Option<T> {\n+        // Because `into_inner` takes `self` by value, the compiler statically verifies\n+        // that it is not currently borrowed. So it is safe to move out `Option<T>`.\n+        self.inner.into_inner()\n+    }\n+\n+    /// Takes the value out of this `OnceCell`, moving it back to an uninitialized state.\n+    ///\n+    /// Has no effect and returns `None` if the `OnceCell` hasn't been initialized.\n+    ///\n+    /// Safety is guaranteed by requiring a mutable reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::cell::OnceCell;\n+    ///\n+    /// let mut cell: OnceCell<String> = OnceCell::new();\n+    /// assert_eq!(cell.take(), None);\n+    ///\n+    /// let mut cell = OnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n+    /// assert_eq!(cell.get(), None);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn take(&mut self) -> Option<T> {\n+        mem::take(self).into_inner()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T> Default for OnceCell<T> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.get() {\n+            Some(v) => f.debug_tuple(\"OnceCell\").field(v).finish(),\n+            None => f.write_str(\"OnceCell(Uninit)\"),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Clone> Clone for OnceCell<T> {\n+    fn clone(&self) -> OnceCell<T> {\n+        let res = OnceCell::new();\n+        if let Some(value) = self.get() {\n+            match res.set(value.clone()) {\n+                Ok(()) => (),\n+                Err(_) => unreachable!(),\n+            }\n+        }\n+        res\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: PartialEq> PartialEq for OnceCell<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Eq> Eq for OnceCell<T> {}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T> const From<T> for OnceCell<T> {\n+    /// Creates a new `OnceCell<T>` which already contains the given `value`.\n+    fn from(value: T) -> Self {\n+        OnceCell { inner: UnsafeCell::new(Some(value)) }\n+    }\n+}"}, {"sha": "f8c06c3f9aedb794a06851ff2f7ae988b4ebb020", "filename": "library/core/src/lazy.rs", "status": "modified", "additions": 0, "deletions": 388, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/7c360dc117d554a11f7193505da0835c4b890c6f/library%2Fcore%2Fsrc%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c360dc117d554a11f7193505da0835c4b890c6f/library%2Fcore%2Fsrc%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flazy.rs?ref=7c360dc117d554a11f7193505da0835c4b890c6f", "patch": "@@ -1,389 +1 @@\n //! Lazy values and one-time initialization of static data.\n-\n-use crate::cell::{Cell, UnsafeCell};\n-use crate::fmt;\n-use crate::mem;\n-use crate::ops::Deref;\n-\n-/// A cell which can be written to only once.\n-///\n-/// Unlike `RefCell`, a `OnceCell` only provides shared `&T` references to its value.\n-/// Unlike `Cell`, a `OnceCell` doesn't require copying or replacing the value to access it.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(once_cell)]\n-///\n-/// use std::lazy::OnceCell;\n-///\n-/// let cell = OnceCell::new();\n-/// assert!(cell.get().is_none());\n-///\n-/// let value: &String = cell.get_or_init(|| {\n-///     \"Hello, World!\".to_string()\n-/// });\n-/// assert_eq!(value, \"Hello, World!\");\n-/// assert!(cell.get().is_some());\n-/// ```\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-pub struct OnceCell<T> {\n-    // Invariant: written to at most once.\n-    inner: UnsafeCell<Option<T>>,\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T> Default for OnceCell<T> {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.get() {\n-            Some(v) => f.debug_tuple(\"OnceCell\").field(v).finish(),\n-            None => f.write_str(\"OnceCell(Uninit)\"),\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: Clone> Clone for OnceCell<T> {\n-    fn clone(&self) -> OnceCell<T> {\n-        let res = OnceCell::new();\n-        if let Some(value) = self.get() {\n-            match res.set(value.clone()) {\n-                Ok(()) => (),\n-                Err(_) => unreachable!(),\n-            }\n-        }\n-        res\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: PartialEq> PartialEq for OnceCell<T> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.get() == other.get()\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: Eq> Eq for OnceCell<T> {}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T> const From<T> for OnceCell<T> {\n-    /// Creates a new `OnceCell<T>` which already contains the given `value`.\n-    fn from(value: T) -> Self {\n-        OnceCell { inner: UnsafeCell::new(Some(value)) }\n-    }\n-}\n-\n-impl<T> OnceCell<T> {\n-    /// Creates a new empty cell.\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    #[must_use]\n-    pub const fn new() -> OnceCell<T> {\n-        OnceCell { inner: UnsafeCell::new(None) }\n-    }\n-\n-    /// Gets the reference to the underlying value.\n-    ///\n-    /// Returns `None` if the cell is empty.\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn get(&self) -> Option<&T> {\n-        // SAFETY: Safe due to `inner`'s invariant\n-        unsafe { &*self.inner.get() }.as_ref()\n-    }\n-\n-    /// Gets the mutable reference to the underlying value.\n-    ///\n-    /// Returns `None` if the cell is empty.\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn get_mut(&mut self) -> Option<&mut T> {\n-        self.inner.get_mut().as_mut()\n-    }\n-\n-    /// Sets the contents of the cell to `value`.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This method returns `Ok(())` if the cell was empty and `Err(value)` if\n-    /// it was full.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::OnceCell;\n-    ///\n-    /// let cell = OnceCell::new();\n-    /// assert!(cell.get().is_none());\n-    ///\n-    /// assert_eq!(cell.set(92), Ok(()));\n-    /// assert_eq!(cell.set(62), Err(62));\n-    ///\n-    /// assert!(cell.get().is_some());\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn set(&self, value: T) -> Result<(), T> {\n-        // SAFETY: Safe because we cannot have overlapping mutable borrows\n-        let slot = unsafe { &*self.inner.get() };\n-        if slot.is_some() {\n-            return Err(value);\n-        }\n-\n-        // SAFETY: This is the only place where we set the slot, no races\n-        // due to reentrancy/concurrency are possible, and we've\n-        // checked that slot is currently `None`, so this write\n-        // maintains the `inner`'s invariant.\n-        let slot = unsafe { &mut *self.inner.get() };\n-        *slot = Some(value);\n-        Ok(())\n-    }\n-\n-    /// Gets the contents of the cell, initializing it with `f`\n-    /// if the cell was empty.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `f` panics, the panic is propagated to the caller, and the cell\n-    /// remains uninitialized.\n-    ///\n-    /// It is an error to reentrantly initialize the cell from `f`. Doing\n-    /// so results in a panic.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::OnceCell;\n-    ///\n-    /// let cell = OnceCell::new();\n-    /// let value = cell.get_or_init(|| 92);\n-    /// assert_eq!(value, &92);\n-    /// let value = cell.get_or_init(|| unreachable!());\n-    /// assert_eq!(value, &92);\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn get_or_init<F>(&self, f: F) -> &T\n-    where\n-        F: FnOnce() -> T,\n-    {\n-        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n-            Ok(val) => val,\n-        }\n-    }\n-\n-    /// Gets the contents of the cell, initializing it with `f` if\n-    /// the cell was empty. If the cell was empty and `f` failed, an\n-    /// error is returned.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `f` panics, the panic is propagated to the caller, and the cell\n-    /// remains uninitialized.\n-    ///\n-    /// It is an error to reentrantly initialize the cell from `f`. Doing\n-    /// so results in a panic.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::OnceCell;\n-    ///\n-    /// let cell = OnceCell::new();\n-    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n-    /// assert!(cell.get().is_none());\n-    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n-    ///     Ok(92)\n-    /// });\n-    /// assert_eq!(value, Ok(&92));\n-    /// assert_eq!(cell.get(), Some(&92))\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n-    where\n-        F: FnOnce() -> Result<T, E>,\n-    {\n-        if let Some(val) = self.get() {\n-            return Ok(val);\n-        }\n-        /// Avoid inlining the initialization closure into the common path that fetches\n-        /// the already initialized value\n-        #[cold]\n-        fn outlined_call<F, T, E>(f: F) -> Result<T, E>\n-        where\n-            F: FnOnce() -> Result<T, E>,\n-        {\n-            f()\n-        }\n-        let val = outlined_call(f)?;\n-        // Note that *some* forms of reentrant initialization might lead to\n-        // UB (see `reentrant_init` test). I believe that just removing this\n-        // `assert`, while keeping `set/get` would be sound, but it seems\n-        // better to panic, rather than to silently use an old value.\n-        assert!(self.set(val).is_ok(), \"reentrant init\");\n-        Ok(self.get().unwrap())\n-    }\n-\n-    /// Consumes the cell, returning the wrapped value.\n-    ///\n-    /// Returns `None` if the cell was empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::OnceCell;\n-    ///\n-    /// let cell: OnceCell<String> = OnceCell::new();\n-    /// assert_eq!(cell.into_inner(), None);\n-    ///\n-    /// let cell = OnceCell::new();\n-    /// cell.set(\"hello\".to_string()).unwrap();\n-    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn into_inner(self) -> Option<T> {\n-        // Because `into_inner` takes `self` by value, the compiler statically verifies\n-        // that it is not currently borrowed. So it is safe to move out `Option<T>`.\n-        self.inner.into_inner()\n-    }\n-\n-    /// Takes the value out of this `OnceCell`, moving it back to an uninitialized state.\n-    ///\n-    /// Has no effect and returns `None` if the `OnceCell` hasn't been initialized.\n-    ///\n-    /// Safety is guaranteed by requiring a mutable reference.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::OnceCell;\n-    ///\n-    /// let mut cell: OnceCell<String> = OnceCell::new();\n-    /// assert_eq!(cell.take(), None);\n-    ///\n-    /// let mut cell = OnceCell::new();\n-    /// cell.set(\"hello\".to_string()).unwrap();\n-    /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n-    /// assert_eq!(cell.get(), None);\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn take(&mut self) -> Option<T> {\n-        mem::take(self).into_inner()\n-    }\n-}\n-\n-/// A value which is initialized on the first access.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(once_cell)]\n-///\n-/// use std::lazy::Lazy;\n-///\n-/// let lazy: Lazy<i32> = Lazy::new(|| {\n-///     println!(\"initializing\");\n-///     92\n-/// });\n-/// println!(\"ready\");\n-/// println!(\"{}\", *lazy);\n-/// println!(\"{}\", *lazy);\n-///\n-/// // Prints:\n-/// //   ready\n-/// //   initializing\n-/// //   92\n-/// //   92\n-/// ```\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-pub struct Lazy<T, F = fn() -> T> {\n-    cell: OnceCell<T>,\n-    init: Cell<Option<F>>,\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: fmt::Debug, F> fmt::Debug for Lazy<T, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n-    }\n-}\n-\n-impl<T, F> Lazy<T, F> {\n-    /// Creates a new lazy value with the given initializing function.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// # fn main() {\n-    /// use std::lazy::Lazy;\n-    ///\n-    /// let hello = \"Hello, World!\".to_string();\n-    ///\n-    /// let lazy = Lazy::new(|| hello.to_uppercase());\n-    ///\n-    /// assert_eq!(&*lazy, \"HELLO, WORLD!\");\n-    /// # }\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub const fn new(init: F) -> Lazy<T, F> {\n-        Lazy { cell: OnceCell::new(), init: Cell::new(Some(init)) }\n-    }\n-}\n-\n-impl<T, F: FnOnce() -> T> Lazy<T, F> {\n-    /// Forces the evaluation of this lazy value and returns a reference to\n-    /// the result.\n-    ///\n-    /// This is equivalent to the `Deref` impl, but is explicit.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::Lazy;\n-    ///\n-    /// let lazy = Lazy::new(|| 92);\n-    ///\n-    /// assert_eq!(Lazy::force(&lazy), &92);\n-    /// assert_eq!(&*lazy, &92);\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn force(this: &Lazy<T, F>) -> &T {\n-        this.cell.get_or_init(|| match this.init.take() {\n-            Some(f) => f(),\n-            None => panic!(\"`Lazy` instance has previously been poisoned\"),\n-        })\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T, F: FnOnce() -> T> Deref for Lazy<T, F> {\n-    type Target = T;\n-    fn deref(&self) -> &T {\n-        Lazy::force(self)\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: Default> Default for Lazy<T> {\n-    /// Creates a new lazy value using `Default` as the initializing function.\n-    fn default() -> Lazy<T> {\n-        Lazy::new(T::default)\n-    }\n-}"}, {"sha": "70fcc6d2d4bf7d9d1de717d017073ca85c9e97b1", "filename": "library/core/tests/lazy.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c360dc117d554a11f7193505da0835c4b890c6f/library%2Fcore%2Ftests%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c360dc117d554a11f7193505da0835c4b890c6f/library%2Fcore%2Ftests%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flazy.rs?ref=7c360dc117d554a11f7193505da0835c4b890c6f", "patch": "@@ -1,6 +1,5 @@\n use core::{\n-    cell::Cell,\n-    lazy::{Lazy, OnceCell},\n+    cell::{Cell, LazyCell, OnceCell},\n     sync::atomic::{AtomicUsize, Ordering::SeqCst},\n };\n \n@@ -91,7 +90,7 @@ fn into_inner() {\n #[test]\n fn lazy_new() {\n     let called = Cell::new(0);\n-    let x = Lazy::new(|| {\n+    let x = LazyCell::new(|| {\n         called.set(called.get() + 1);\n         92\n     });"}, {"sha": "66d6236c1117fab5469d5d94fbf8045f7d2a3f75", "filename": "library/std/src/lazy/tests.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c360dc117d554a11f7193505da0835c4b890c6f/library%2Fstd%2Fsrc%2Flazy%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c360dc117d554a11f7193505da0835c4b890c6f/library%2Fstd%2Fsrc%2Flazy%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flazy%2Ftests.rs?ref=7c360dc117d554a11f7193505da0835c4b890c6f", "patch": "@@ -1,5 +1,6 @@\n use crate::{\n-    lazy::{Lazy, SyncLazy, SyncOnceCell},\n+    cell::LazyCell,\n+    lazy::{SyncLazy, SyncOnceCell},\n     panic,\n     sync::{\n         atomic::{AtomicUsize, Ordering::SeqCst},\n@@ -21,7 +22,7 @@ fn lazy_default() {\n         }\n     }\n \n-    let lazy: Lazy<Mutex<Foo>> = <_>::default();\n+    let lazy: LazyCell<Mutex<Foo>> = <_>::default();\n \n     assert_eq!(CALLED.load(SeqCst), 0);\n \n@@ -36,7 +37,7 @@ fn lazy_default() {\n \n #[test]\n fn lazy_poisoning() {\n-    let x: Lazy<String> = Lazy::new(|| panic!(\"kaboom\"));\n+    let x: LazyCell<String> = LazyCell::new(|| panic!(\"kaboom\"));\n     for _ in 0..2 {\n         let res = panic::catch_unwind(panic::AssertUnwindSafe(|| x.len()));\n         assert!(res.is_err());"}]}