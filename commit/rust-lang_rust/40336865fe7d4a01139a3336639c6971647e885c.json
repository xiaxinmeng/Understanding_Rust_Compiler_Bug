{"sha": "40336865fe7d4a01139a3336639c6971647e885c", "node_id": "C_kwDOAAsO6NoAKDQwMzM2ODY1ZmU3ZDRhMDExMzlhMzMzNjYzOWM2OTcxNjQ3ZTg4NWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-15T18:27:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-15T18:27:37Z"}, "message": "Auto merge of #100595 - matthiaskrgr:rollup-f1zur58, r=matthiaskrgr\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #100031 (improve \"try ignoring the field\" diagnostic)\n - #100325 (Rustdoc-Json: Don't remove impls for items imported from private modules)\n - #100377 (Replace - with _ in fluent slugs to improve developer workflows)\n - #100458 (Adjust span of fn argument declaration)\n - #100514 (Delay span bug when failing to normalize negative coherence impl subject due to other malformed impls)\n - #100528 (Support 1st group of RISC-V Bitmanip backend target features)\n - #100559 (Parser simplifications)\n - #100568 (Fix STD build for ESP-IDF)\n - #100582 ([rustdoc] Fix handling of stripped enum variant in JSON output format)\n - #100586 (Reland changes replacing num_cpus with available_parallelism )\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c4a707523bfd7a0b4c4cc5f9da41862e2a885975", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4a707523bfd7a0b4c4cc5f9da41862e2a885975"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40336865fe7d4a01139a3336639c6971647e885c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40336865fe7d4a01139a3336639c6971647e885c", "html_url": "https://github.com/rust-lang/rust/commit/40336865fe7d4a01139a3336639c6971647e885c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40336865fe7d4a01139a3336639c6971647e885c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "html_url": "https://github.com/rust-lang/rust/commit/9b4ea391a132ec5f5de40079597ab7ff2fd691ad"}, {"sha": "e65de39763cc516a92c768c5644d7f86e973fb24", "url": "https://api.github.com/repos/rust-lang/rust/commits/e65de39763cc516a92c768c5644d7f86e973fb24", "html_url": "https://github.com/rust-lang/rust/commit/e65de39763cc516a92c768c5644d7f86e973fb24"}], "stats": {"total": 1485, "additions": 841, "deletions": 644}, "files": [{"sha": "395f5a127bd3dca45e5985df26fe904976240422", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -257,7 +257,6 @@ dependencies = [\n  \"anyhow\",\n  \"flate2\",\n  \"hex 0.4.2\",\n- \"num_cpus\",\n  \"rayon\",\n  \"serde\",\n  \"serde_json\",\n@@ -2140,9 +2139,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.129\"\n+version = \"0.2.131\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"64de3cc433455c14174d42e554d4027ee631c4d046d43e3ecc6efc4636cdc7a7\"\n+checksum = \"04c3b4822ccebfa39c02fc03d1534441b22ead323fa0f48bb7ddd8e6ba076a40\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -4442,7 +4441,6 @@ name = \"rustc_session\"\n version = \"0.0.0\"\n dependencies = [\n  \"getopts\",\n- \"num_cpus\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_errors\","}, {"sha": "9062a83b8be4468decf0257cbb5105e3c4259dee", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -227,6 +227,10 @@ const RISCV_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"zhinxmin\", Some(sym::riscv_target_feature)),\n     (\"zfh\", Some(sym::riscv_target_feature)),\n     (\"zfhmin\", Some(sym::riscv_target_feature)),\n+    (\"zba\", Some(sym::riscv_target_feature)),\n+    (\"zbb\", Some(sym::riscv_target_feature)),\n+    (\"zbc\", Some(sym::riscv_target_feature)),\n+    (\"zbs\", Some(sym::riscv_target_feature)),\n     (\"zbkb\", Some(sym::riscv_target_feature)),\n     (\"zbkc\", Some(sym::riscv_target_feature)),\n     (\"zbkx\", Some(sym::riscv_target_feature)),"}, {"sha": "4af40d2062d3a79c275cfe22d841105e282bbb5d", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1,18 +1,18 @@\n-borrowck-move-unsized =\n+borrowck_move_unsized =\n     cannot move a value of type `{$ty}`\n     .label = the size of `{$ty}` cannot be statically determined\n \n-borrowck-higher-ranked-lifetime-error =\n+borrowck_higher_ranked_lifetime_error =\n     higher-ranked lifetime error\n \n-borrowck-could-not-prove =\n+borrowck_could_not_prove =\n     could not prove `{$predicate}`\n \n-borrowck-could-not-normalize =\n+borrowck_could_not_normalize =\n     could not normalize `{$value}`\n \n-borrowck-higher-ranked-subtype-error =\n+borrowck_higher_ranked_subtype_error =\n     higher-ranked subtype error\n   \n-generic-does-not-live-long-enough =\n+generic_does_not_live_long_enough =\n     `{$kind}` does not live long enough\n\\ No newline at end of file"}, {"sha": "4d088e27b364ae36762db7512961333e7a34849f", "filename": "compiler/rustc_error_messages/locales/en-US/builtin_macros.ftl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fbuiltin_macros.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fbuiltin_macros.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fbuiltin_macros.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1,5 +1,5 @@\n-builtin-macros-requires-cfg-pattern =\n+builtin_macros_requires_cfg_pattern =\n     macro requires a cfg-pattern as an argument\n     .label = cfg-pattern required\n \n-builtin-macros-expected-one-cfg-pattern = expected 1 cfg-pattern\n+builtin_macros_expected_one_cfg_pattern = expected 1 cfg-pattern"}, {"sha": "341f05efefdfb2a44cf9cdf0f040718efebc01fa", "filename": "compiler/rustc_error_messages/locales/en-US/const_eval.ftl", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1,31 +1,31 @@\n-const-eval-unstable-in-stable =\n+const_eval_unstable_in_stable =\n     const-stable function cannot use `#[feature({$gate})]`\n-    .unstable-sugg = if it is not part of the public API, make this function unstably const\n-    .bypass-sugg = otherwise `#[rustc_allow_const_fn_unstable]` can be used to bypass stability checks\n+    .unstable_sugg = if it is not part of the public API, make this function unstably const\n+    .bypass_sugg = otherwise `#[rustc_allow_const_fn_unstable]` can be used to bypass stability checks\n \n-const-eval-thread-local-access =\n+const_eval_thread_local_access =\n     thread-local statics cannot be accessed at compile-time\n \n-const-eval-static-access =\n+const_eval_static_access =\n     {$kind}s cannot refer to statics\n     .help = consider extracting the value of the `static` to a `const`, and referring to that\n-    .teach-note = `static` and `const` variables can refer to other `const` variables. A `const` variable, however, cannot refer to a `static` variable.\n-    .teach-help = To fix this, the value can be extracted to a `const` and then used.\n+    .teach_note = `static` and `const` variables can refer to other `const` variables. A `const` variable, however, cannot refer to a `static` variable.\n+    .teach_help = To fix this, the value can be extracted to a `const` and then used.\n \n-const-eval-raw-ptr-to-int =\n+const_eval_raw_ptr_to_int =\n     pointers cannot be cast to integers during const eval\n     .note = at compile-time, pointers do not have an integer value\n     .note2 = avoiding this restriction via `transmute`, `union`, or raw pointers leads to compile-time undefined behavior\n \n-const-eval-raw-ptr-comparison =\n+const_eval_raw_ptr_comparison =\n     pointers cannot be reliably compared during const eval\n     .note = see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n \n-const-eval-panic-non-str = argument to `panic!()` in a const context must have type `&str`\n+const_eval_panic_non_str = argument to `panic!()` in a const context must have type `&str`\n \n-const-eval-mut-deref =\n+const_eval_mut_deref =\n     mutation through a reference is not allowed in {$kind}s\n \n-const-eval-transient-mut-borrow = mutable references are not allowed in {$kind}s\n+const_eval_transient_mut_borrow = mutable references are not allowed in {$kind}s\n \n-const-eval-transient-mut-borrow-raw = raw mutable references are not allowed in {$kind}s\n+const_eval_transient_mut_borrow_raw = raw mutable references are not allowed in {$kind}s"}, {"sha": "bdfa22e77eb2fcdc1fa0df21cdd151b91f2566c9", "filename": "compiler/rustc_error_messages/locales/en-US/expand.ftl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1,5 +1,5 @@\n-expand-explain-doc-comment-outer =\n+expand_explain_doc_comment_outer =\n     outer doc comments expand to `#[doc = \"...\"]`, which is what this macro attempted to match\n \n-expand-explain-doc-comment-inner =\n+expand_explain_doc_comment_inner =\n     inner doc comments expand to `#![doc = \"...\"]`, which is what this macro attempted to match"}, {"sha": "973171147166438023f0e61ef11e8b1058cc666e", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 163, "deletions": 163, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1,22 +1,22 @@\n-lint-array-into-iter =\n+lint_array_into_iter =\n     this method call resolves to `<&{$target} as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to <{$target} as IntoIterator>::into_iter in Rust 2021\n-    .use-iter-suggestion = use `.iter()` instead of `.into_iter()` to avoid ambiguity\n-    .remove-into-iter-suggestion = or remove `.into_iter()` to iterate by value\n-    .use-explicit-into-iter-suggestion =\n+    .use_iter_suggestion = use `.iter()` instead of `.into_iter()` to avoid ambiguity\n+    .remove_into_iter_suggestion = or remove `.into_iter()` to iterate by value\n+    .use_explicit_into_iter_suggestion =\n         or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n \n-lint-enum-intrinsics-mem-discriminant =\n+lint_enum_intrinsics_mem_discriminant =\n     the return value of `mem::discriminant` is unspecified when called with a non-enum type\n     .note = the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `{$ty_param}`, which is not an enum.\n \n-lint-enum-intrinsics-mem-variant =\n+lint_enum_intrinsics_mem_variant =\n     the return value of `mem::variant_count` is unspecified when called with a non-enum type\n     .note = the type parameter of `variant_count` should be an enum, but it was instantiated with the type `{$ty_param}`, which is not an enum.\n \n-lint-expectation = this lint expectation is unfulfilled\n+lint_expectation = this lint expectation is unfulfilled\n     .note = the `unfulfilled_lint_expectations` lint can't be expected and will always produce this message\n \n-lint-hidden-unicode-codepoints = unicode codepoint changing visible direction of text present in {$label}\n+lint_hidden_unicode_codepoints = unicode codepoint changing visible direction of text present in {$label}\n     .label = this {$label} contains {$count ->\n         [one] an invisible\n         *[other] invisible\n@@ -25,68 +25,68 @@ lint-hidden-unicode-codepoints = unicode codepoint changing visible direction of\n         *[other] codepoints\n     }\n     .note = these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen\n-    .suggestion-remove = if their presence wasn't intentional, you can remove them\n-    .suggestion-escape = if you want to keep them but make them visible in your source code, you can escape them\n-    .no-suggestion-note-escape = if you want to keep them but make them visible in your source code, you can escape them: {$escaped}\n+    .suggestion_remove = if their presence wasn't intentional, you can remove them\n+    .suggestion_escape = if you want to keep them but make them visible in your source code, you can escape them\n+    .no_suggestion_note_escape = if you want to keep them but make them visible in your source code, you can escape them: {$escaped}\n \n-lint-default-hash-types = prefer `{$preferred}` over `{$used}`, it has better performance\n+lint_default_hash_types = prefer `{$preferred}` over `{$used}`, it has better performance\n     .note = a `use rustc_data_structures::fx::{$preferred}` may be necessary\n \n-lint-query-instability = using `{$query}` can result in unstable query results\n+lint_query_instability = using `{$query}` can result in unstable query results\n     .note = if you believe this case to be fine, allow this lint and add a comment explaining your rationale\n \n-lint-tykind-kind = usage of `ty::TyKind::<kind>`\n+lint_tykind_kind = usage of `ty::TyKind::<kind>`\n     .suggestion = try using `ty::<kind>` directly\n \n-lint-tykind = usage of `ty::TyKind`\n+lint_tykind = usage of `ty::TyKind`\n     .help = try using `Ty` instead\n \n-lint-ty-qualified = usage of qualified `ty::{$ty}`\n+lint_ty_qualified = usage of qualified `ty::{$ty}`\n     .suggestion = try importing it and using it unqualified\n \n-lint-lintpass-by-hand = implementing `LintPass` by hand\n+lint_lintpass_by_hand = implementing `LintPass` by hand\n     .help = try using `declare_lint_pass!` or `impl_lint_pass!` instead\n \n-lint-non-existant-doc-keyword = found non-existing keyword `{$keyword}` used in `#[doc(keyword = \\\"...\\\")]`\n+lint_non_existant_doc_keyword = found non-existing keyword `{$keyword}` used in `#[doc(keyword = \\\"...\\\")]`\n     .help = only existing keywords are allowed in core/std\n \n-lint-diag-out-of-impl =\n+lint_diag_out_of_impl =\n     diagnostics should only be created in `SessionDiagnostic`/`AddSubdiagnostic` impls\n \n-lint-untranslatable-diag = diagnostics should be created using translatable messages\n+lint_untranslatable_diag = diagnostics should be created using translatable messages\n \n-lint-cstring-ptr = getting the inner pointer of a temporary `CString`\n-    .as-ptr-label = this pointer will be invalid\n-    .unwrap-label = this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\n+lint_cstring_ptr = getting the inner pointer of a temporary `CString`\n+    .as_ptr_label = this pointer will be invalid\n+    .unwrap_label = this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\n     .note = pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\n     .help = for more information, see https://doc.rust-lang.org/reference/destructors.html\n \n-lint-identifier-non-ascii-char = identifier contains non-ASCII characters\n+lint_identifier_non_ascii_char = identifier contains non-ASCII characters\n \n-lint-identifier-uncommon-codepoints = identifier contains uncommon Unicode codepoints\n+lint_identifier_uncommon_codepoints = identifier contains uncommon Unicode codepoints\n \n-lint-confusable-identifier-pair = identifier pair considered confusable between `{$existing_sym}` and `{$sym}`\n+lint_confusable_identifier_pair = identifier pair considered confusable between `{$existing_sym}` and `{$sym}`\n     .label = this is where the previous identifier occurred\n \n-lint-mixed-script-confusables =\n+lint_mixed_script_confusables =\n     the usage of Script Group `{$set}` in this crate consists solely of mixed script confusables\n-    .includes-note = the usage includes {$includes}\n+    .includes_note = the usage includes {$includes}\n     .note = please recheck to make sure their usages are indeed what you want\n \n-lint-non-fmt-panic = panic message is not a string literal\n+lint_non_fmt_panic = panic message is not a string literal\n     .note = this usage of `{$name}!()` is deprecated; it will be a hard error in Rust 2021\n-    .more-info-note = for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-    .supports-fmt-note = the `{$name}!()` macro supports formatting, so there's no need for the `format!()` macro here\n-    .supports-fmt-suggestion = remove the `format!(..)` macro call\n-    .display-suggestion = add a \"{\"{\"}{\"}\"}\" format string to `Display` the message\n-    .debug-suggestion =\n+    .more_info_note = for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n+    .supports_fmt_note = the `{$name}!()` macro supports formatting, so there's no need for the `format!()` macro here\n+    .supports_fmt_suggestion = remove the `format!(..)` macro call\n+    .display_suggestion = add a \"{\"{\"}{\"}\"}\" format string to `Display` the message\n+    .debug_suggestion =\n         add a \"{\"{\"}:?{\"}\"}\" format string to use the `Debug` implementation of `{$ty}`\n-    .panic-suggestion = {$already_suggested ->\n+    .panic_suggestion = {$already_suggested ->\n         [true] or use\n         *[false] use\n     } std::panic::panic_any instead\n \n-lint-non-fmt-panic-unused =\n+lint_non_fmt_panic_unused =\n     panic message contains {$count ->\n         [one] an unused\n         *[other] unused\n@@ -95,44 +95,44 @@ lint-non-fmt-panic-unused =\n         *[other] placeholders\n     }\n     .note = this message is not used as a format string when given without arguments, but will be in Rust 2021\n-    .add-args-suggestion = add the missing {$count ->\n+    .add_args_suggestion = add the missing {$count ->\n         [one] argument\n         *[other] arguments\n     }\n-    .add-fmt-suggestion = or add a \"{\"{\"}{\"}\"}\" format string to use the message literally\n+    .add_fmt_suggestion = or add a \"{\"{\"}{\"}\"}\" format string to use the message literally\n \n-lint-non-fmt-panic-braces =\n+lint_non_fmt_panic_braces =\n     panic message contains {$count ->\n         [one] a brace\n         *[other] braces\n     }\n     .note = this message is not used as a format string, but will be in Rust 2021\n     .suggestion = add a \"{\"{\"}{\"}\"}\" format string to use the message literally\n \n-lint-non-camel-case-type = {$sort} `{$name}` should have an upper camel case name\n+lint_non_camel_case_type = {$sort} `{$name}` should have an upper camel case name\n     .suggestion = convert the identifier to upper camel case\n     .label = should have an UpperCamelCase name\n \n-lint-non-snake-case = {$sort} `{$name}` should have a snake case name\n-    .rename-or-convert-suggestion = rename the identifier or convert it to a snake case raw identifier\n-    .cannot-convert-note = `{$sc}` cannot be used as a raw identifier\n-    .rename-suggestion = rename the identifier\n-    .convert-suggestion = convert the identifier to snake case\n+lint_non_snake_case = {$sort} `{$name}` should have a snake case name\n+    .rename_or_convert_suggestion = rename the identifier or convert it to a snake case raw identifier\n+    .cannot_convert_note = `{$sc}` cannot be used as a raw identifier\n+    .rename_suggestion = rename the identifier\n+    .convert_suggestion = convert the identifier to snake case\n     .help = convert the identifier to snake case: `{$sc}`\n     .label = should have a snake_case name\n \n-lint-non-upper_case-global = {$sort} `{$name}` should have an upper case name\n+lint_non_upper_case_global = {$sort} `{$name}` should have an upper case name\n     .suggestion = convert the identifier to upper case\n     .label = should have an UPPER_CASE name\n \n-lint-noop-method-call = call to `.{$method}()` on a reference in this situation does nothing\n+lint_noop_method_call = call to `.{$method}()` on a reference in this situation does nothing\n     .label = unnecessary method call\n     .note = the type `{$receiver_ty}` which `{$method}` is being called on is the same as the type returned from `{$method}`, so the method call does not do anything and can be removed\n \n-lint-pass-by-value = passing `{$ty}` by reference\n+lint_pass_by_value = passing `{$ty}` by reference\n     .suggestion = try passing by value\n \n-lint-redundant-semicolons =\n+lint_redundant_semicolons =\n     unnecessary trailing {$multiple ->\n         [true] semicolons\n         *[false] semicolon\n@@ -142,254 +142,254 @@ lint-redundant-semicolons =\n         *[false] this semicolon\n     }\n \n-lint-drop-trait-constraints =\n+lint_drop_trait_constraints =\n     bounds on `{$predicate}` are most likely incorrect, consider instead using `{$needs_drop}` to detect whether a type can be trivially dropped\n \n-lint-drop-glue =\n+lint_drop_glue =\n     types that do not implement `Drop` can still have drop glue, consider instead using `{$needs_drop}` to detect whether a type is trivially dropped\n \n-lint-range-endpoint-out-of-range = range endpoint is out of range for `{$ty}`\n+lint_range_endpoint_out_of_range = range endpoint is out of range for `{$ty}`\n     .suggestion = use an inclusive range instead\n \n-lint-overflowing-bin-hex = literal out of range for `{$ty}`\n-    .negative-note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}`\n-    .negative-becomes-note = and the value `-{$lit}` will become `{$actually}{$ty}`\n-    .positive-note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}` and will become `{$actually}{$ty}`\n+lint_overflowing_bin_hex = literal out of range for `{$ty}`\n+    .negative_note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}`\n+    .negative_becomes_note = and the value `-{$lit}` will become `{$actually}{$ty}`\n+    .positive_note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}` and will become `{$actually}{$ty}`\n     .suggestion = consider using the type `{$suggestion_ty}` instead\n     .help = consider using the type `{$suggestion_ty}` instead\n \n-lint-overflowing-int = literal out of range for `{$ty}`\n+lint_overflowing_int = literal out of range for `{$ty}`\n     .note = the literal `{$lit}` does not fit into the type `{$ty}` whose range is `{$min}..={$max}`\n     .help = consider using the type `{$suggestion_ty}` instead\n \n-lint-only-cast-u8-to-char = only `u8` can be cast into `char`\n+lint_only_cast_u8_to_char = only `u8` can be cast into `char`\n     .suggestion = use a `char` literal instead\n \n-lint-overflowing-uint = literal out of range for `{$ty}`\n+lint_overflowing_uint = literal out of range for `{$ty}`\n     .note = the literal `{$lit}` does not fit into the type `{$ty}` whose range is `{$min}..={$max}`\n \n-lint-overflowing-literal = literal out of range for `{$ty}`\n+lint_overflowing_literal = literal out of range for `{$ty}`\n     .note = the literal `{$lit}` does not fit into the type `{$ty}` and will be converted to `{$ty}::INFINITY`\n \n-lint-unused-comparisons = comparison is useless due to type limits\n+lint_unused_comparisons = comparison is useless due to type limits\n \n-lint-improper-ctypes = `extern` {$desc} uses type `{$ty}`, which is not FFI-safe\n+lint_improper_ctypes = `extern` {$desc} uses type `{$ty}`, which is not FFI-safe\n     .label = not FFI-safe\n     .note = the type is defined here\n \n-lint-improper-ctypes-opaque = opaque types have no C equivalent\n+lint_improper_ctypes_opaque = opaque types have no C equivalent\n \n-lint-improper-ctypes-fnptr-reason = this function pointer has Rust-specific calling convention\n-lint-improper-ctypes-fnptr-help = consider using an `extern fn(...) -> ...` function pointer instead\n+lint_improper_ctypes_fnptr_reason = this function pointer has Rust-specific calling convention\n+lint_improper_ctypes_fnptr_help = consider using an `extern fn(...) -> ...` function pointer instead\n \n-lint-improper-ctypes-tuple-reason = tuples have unspecified layout\n-lint-improper-ctypes-tuple-help = consider using a struct instead\n+lint_improper_ctypes_tuple_reason = tuples have unspecified layout\n+lint_improper_ctypes_tuple_help = consider using a struct instead\n \n-lint-improper-ctypes-str-reason = string slices have no C equivalent\n-lint-improper-ctypes-str-help = consider using `*const u8` and a length instead\n+lint_improper_ctypes_str_reason = string slices have no C equivalent\n+lint_improper_ctypes_str_help = consider using `*const u8` and a length instead\n \n-lint-improper-ctypes-dyn = trait objects have no C equivalent\n+lint_improper_ctypes_dyn = trait objects have no C equivalent\n \n-lint-improper-ctypes-slice-reason = slices have no C equivalent\n-lint-improper-ctypes-slice-help = consider using a raw pointer instead\n+lint_improper_ctypes_slice_reason = slices have no C equivalent\n+lint_improper_ctypes_slice_help = consider using a raw pointer instead\n \n-lint-improper-ctypes-128bit = 128-bit integers don't currently have a known stable ABI\n+lint_improper_ctypes_128bit = 128-bit integers don't currently have a known stable ABI\n \n-lint-improper-ctypes-char-reason = the `char` type has no C equivalent\n-lint-improper-ctypes-char-help = consider using `u32` or `libc::wchar_t` instead\n+lint_improper_ctypes_char_reason = the `char` type has no C equivalent\n+lint_improper_ctypes_char_help = consider using `u32` or `libc::wchar_t` instead\n \n-lint-improper-ctypes-non-exhaustive = this enum is non-exhaustive\n-lint-improper-ctypes-non-exhaustive-variant = this enum has non-exhaustive variants\n+lint_improper_ctypes_non_exhaustive = this enum is non-exhaustive\n+lint_improper_ctypes_non_exhaustive_variant = this enum has non-exhaustive variants\n \n-lint-improper-ctypes-enum-repr-reason = enum has no representation hint\n-lint-improper-ctypes-enum-repr-help =\n+lint_improper_ctypes_enum_repr_reason = enum has no representation hint\n+lint_improper_ctypes_enum_repr_help =\n     consider adding a `#[repr(C)]`, `#[repr(transparent)]`, or integer `#[repr(...)]` attribute to this enum\n \n-lint-improper-ctypes-struct-fieldless-reason = this struct has no fields\n-lint-improper-ctypes-struct-fieldless-help = consider adding a member to this struct\n+lint_improper_ctypes_struct_fieldless_reason = this struct has no fields\n+lint_improper_ctypes_struct_fieldless_help = consider adding a member to this struct\n \n-lint-improper-ctypes-union-fieldless-reason = this union has no fields\n-lint-improper-ctypes-union-fieldless-help = consider adding a member to this union\n+lint_improper_ctypes_union_fieldless_reason = this union has no fields\n+lint_improper_ctypes_union_fieldless_help = consider adding a member to this union\n \n-lint-improper-ctypes-struct-non-exhaustive = this struct is non-exhaustive\n-lint-improper-ctypes-union-non-exhaustive = this union is non-exhaustive\n+lint_improper_ctypes_struct_non_exhaustive = this struct is non-exhaustive\n+lint_improper_ctypes_union_non_exhaustive = this union is non-exhaustive\n \n-lint-improper-ctypes-struct-layout-reason = this struct has unspecified layout\n-lint-improper-ctypes-struct-layout-help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n+lint_improper_ctypes_struct_layout_reason = this struct has unspecified layout\n+lint_improper_ctypes_struct_layout_help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n \n-lint-improper-ctypes-union-layout-reason = this union has unspecified layout\n-lint-improper-ctypes-union-layout-help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this union\n+lint_improper_ctypes_union_layout_reason = this union has unspecified layout\n+lint_improper_ctypes_union_layout_help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this union\n \n-lint-improper-ctypes-box = box cannot be represented as a single pointer\n+lint_improper_ctypes_box = box cannot be represented as a single pointer\n \n-lint-improper-ctypes-enum-phantomdata = this enum contains a PhantomData field\n+lint_improper_ctypes_enum_phantomdata = this enum contains a PhantomData field\n \n-lint-improper-ctypes-struct-zst = this struct contains only zero-sized fields\n+lint_improper_ctypes_struct_zst = this struct contains only zero-sized fields\n \n-lint-improper-ctypes-array-reason = passing raw arrays by value is not FFI-safe\n-lint-improper-ctypes-array-help = consider passing a pointer to the array\n+lint_improper_ctypes_array_reason = passing raw arrays by value is not FFI-safe\n+lint_improper_ctypes_array_help = consider passing a pointer to the array\n \n-lint-improper-ctypes-only-phantomdata = composed only of `PhantomData`\n+lint_improper_ctypes_only_phantomdata = composed only of `PhantomData`\n \n-lint-variant-size-differences =\n+lint_variant_size_differences =\n     enum variant is more than three times larger ({$largest} bytes) than the next largest\n \n-lint-atomic-ordering-load = atomic loads cannot have `Release` or `AcqRel` ordering\n+lint_atomic_ordering_load = atomic loads cannot have `Release` or `AcqRel` ordering\n     .help = consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n \n-lint-atomic-ordering-store = atomic stores cannot have `Acquire` or `AcqRel` ordering\n+lint_atomic_ordering_store = atomic stores cannot have `Acquire` or `AcqRel` ordering\n     .help = consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n \n-lint-atomic-ordering-fence = memory fences cannot have `Relaxed` ordering\n+lint_atomic_ordering_fence = memory fences cannot have `Relaxed` ordering\n     .help = consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\n \n-lint-atomic-ordering-invalid = `{$method}`'s failure ordering may not be `Release` or `AcqRel`, since a failed `{$method}` does not result in a write\n+lint_atomic_ordering_invalid = `{$method}`'s failure ordering may not be `Release` or `AcqRel`, since a failed `{$method}` does not result in a write\n     .label = invalid failure ordering\n     .help = consider using `Acquire` or `Relaxed` failure ordering instead\n \n-lint-unused-op = unused {$op} that must be used\n+lint_unused_op = unused {$op} that must be used\n     .label = the {$op} produces a value\n     .suggestion = use `let _ = ...` to ignore the resulting value\n \n-lint-unused-result = unused result of type `{$ty}`\n+lint_unused_result = unused result of type `{$ty}`\n \n-lint-unused-closure =\n+lint_unused_closure =\n     unused {$pre}{$count ->\n         [one] closure\n         *[other] closures\n     }{$post} that must be used\n     .note = closures are lazy and do nothing unless called\n \n-lint-unused-generator =\n+lint_unused_generator =\n     unused {$pre}{$count ->\n         [one] generator\n         *[other] generator\n     }{$post} that must be used\n     .note = generators are lazy and do nothing unless resumed\n \n-lint-unused-def = unused {$pre}`{$def}`{$post} that must be used\n+lint_unused_def = unused {$pre}`{$def}`{$post} that must be used\n \n-lint-path-statement-drop = path statement drops value\n+lint_path_statement_drop = path statement drops value\n     .suggestion = use `drop` to clarify the intent\n \n-lint-path-statement-no-effect = path statement with no effect\n+lint_path_statement_no_effect = path statement with no effect\n \n-lint-unused-delim = unnecessary {$delim} around {$item}\n+lint_unused_delim = unnecessary {$delim} around {$item}\n     .suggestion = remove these {$delim}\n \n-lint-unused-import-braces = braces around {$node} is unnecessary\n+lint_unused_import_braces = braces around {$node} is unnecessary\n \n-lint-unused-allocation = unnecessary allocation, use `&` instead\n-lint-unused-allocation-mut = unnecessary allocation, use `&mut` instead\n+lint_unused_allocation = unnecessary allocation, use `&` instead\n+lint_unused_allocation_mut = unnecessary allocation, use `&mut` instead\n \n-lint-builtin-while-true = denote infinite loops with `loop {\"{\"} ... {\"}\"}`\n+lint_builtin_while_true = denote infinite loops with `loop {\"{\"} ... {\"}\"}`\n     .suggestion = use `loop`\n \n-lint-builtin-box-pointers = type uses owned (Box type) pointers: {$ty}\n+lint_builtin_box_pointers = type uses owned (Box type) pointers: {$ty}\n \n-lint-builtin-non-shorthand-field-patterns = the `{$ident}:` in this pattern is redundant\n+lint_builtin_non_shorthand_field_patterns = the `{$ident}:` in this pattern is redundant\n     .suggestion = use shorthand field pattern\n \n-lint-builtin-overridden-symbol-name =\n+lint_builtin_overridden_symbol_name =\n     the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them\n \n-lint-builtin-overridden-symbol-section =\n+lint_builtin_overridden_symbol_section =\n     the program's behavior with overridden link sections on items is unpredictable and Rust cannot provide guarantees when you manually override them\n \n-lint-builtin-allow-internal-unsafe =\n+lint_builtin_allow_internal_unsafe =\n     `allow_internal_unsafe` allows defining macros using unsafe without triggering the `unsafe_code` lint at their call site\n \n-lint-builtin-unsafe-block = usage of an `unsafe` block\n+lint_builtin_unsafe_block = usage of an `unsafe` block\n \n-lint-builtin-unsafe-trait = declaration of an `unsafe` trait\n+lint_builtin_unsafe_trait = declaration of an `unsafe` trait\n \n-lint-builtin-unsafe-impl = implementation of an `unsafe` trait\n+lint_builtin_unsafe_impl = implementation of an `unsafe` trait\n \n-lint-builtin-no-mangle-fn = declaration of a `no_mangle` function\n-lint-builtin-export-name-fn = declaration of a function with `export_name`\n-lint-builtin-link-section-fn = declaration of a function with `link_section`\n+lint_builtin_no_mangle_fn = declaration of a `no_mangle` function\n+lint_builtin_export_name_fn = declaration of a function with `export_name`\n+lint_builtin_link_section_fn = declaration of a function with `link_section`\n \n-lint-builtin-no-mangle-static = declaration of a `no_mangle` static\n-lint-builtin-export-name-static = declaration of a static with `export_name`\n-lint-builtin-link-section-static = declaration of a static with `link_section`\n+lint_builtin_no_mangle_static = declaration of a `no_mangle` static\n+lint_builtin_export_name_static = declaration of a static with `export_name`\n+lint_builtin_link_section_static = declaration of a static with `link_section`\n \n-lint-builtin-no-mangle-method = declaration of a `no_mangle` method\n-lint-builtin-export-name-method = declaration of a method with `export_name`\n+lint_builtin_no_mangle_method = declaration of a `no_mangle` method\n+lint_builtin_export_name_method = declaration of a method with `export_name`\n \n-lint-builtin-decl-unsafe-fn = declaration of an `unsafe` function\n-lint-builtin-decl-unsafe-method = declaration of an `unsafe` method\n-lint-builtin-impl-unsafe-method = implementation of an `unsafe` method\n+lint_builtin_decl_unsafe_fn = declaration of an `unsafe` function\n+lint_builtin_decl_unsafe_method = declaration of an `unsafe` method\n+lint_builtin_impl_unsafe_method = implementation of an `unsafe` method\n \n-lint-builtin-missing-doc = missing documentation for {$article} {$desc}\n+lint_builtin_missing_doc = missing documentation for {$article} {$desc}\n \n-lint-builtin-missing-copy-impl = type could implement `Copy`; consider adding `impl Copy`\n+lint_builtin_missing_copy_impl = type could implement `Copy`; consider adding `impl Copy`\n \n-lint-builtin-missing-debug-impl =\n+lint_builtin_missing_debug_impl =\n     type does not implement `{$debug}`; consider adding `#[derive(Debug)]` or a manual implementation\n \n-lint-builtin-anonymous-params = anonymous parameters are deprecated and will be removed in the next edition\n+lint_builtin_anonymous_params = anonymous parameters are deprecated and will be removed in the next edition\n     .suggestion = try naming the parameter or explicitly ignoring it\n \n-lint-builtin-deprecated-attr-link = use of deprecated attribute `{$name}`: {$reason}. See {$link}\n-lint-builtin-deprecated-attr-used = use of deprecated attribute `{$name}`: no longer used.\n-lint-builtin-deprecated-attr-default-suggestion = remove this attribute\n+lint_builtin_deprecated_attr_link = use of deprecated attribute `{$name}`: {$reason}. See {$link}\n+lint_builtin_deprecated_attr_used = use of deprecated attribute `{$name}`: no longer used.\n+lint_builtin_deprecated_attr_default_suggestion = remove this attribute\n \n-lint-builtin-unused-doc-comment = unused doc comment\n+lint_builtin_unused_doc_comment = unused doc comment\n     .label = rustdoc does not generate documentation for {$kind}\n-    .plain-help = use `//` for a plain comment\n-    .block-help = use `/* */` for a plain comment\n+    .plain_help = use `//` for a plain comment\n+    .block_help = use `/* */` for a plain comment\n \n-lint-builtin-no-mangle-generic = functions generic over types or consts must be mangled\n+lint_builtin_no_mangle_generic = functions generic over types or consts must be mangled\n     .suggestion = remove this attribute\n \n-lint-builtin-const-no-mangle = const items should never be `#[no_mangle]`\n+lint_builtin_const_no_mangle = const items should never be `#[no_mangle]`\n     .suggestion = try a static value\n \n-lint-builtin-mutable-transmutes =\n+lint_builtin_mutable_transmutes =\n     transmuting &T to &mut T is undefined behavior, even if the reference is unused, consider instead using an UnsafeCell\n \n-lint-builtin-unstable-features = unstable feature\n+lint_builtin_unstable_features = unstable feature\n \n-lint-builtin-unreachable-pub = unreachable `pub` {$what}\n+lint_builtin_unreachable_pub = unreachable `pub` {$what}\n     .suggestion = consider restricting its visibility\n     .help = or consider exporting it for use by other crates\n \n-lint-builtin-type-alias-bounds-help = use fully disambiguated paths (i.e., `<T as Trait>::Assoc`) to refer to associated types in type aliases\n+lint_builtin_type_alias_bounds_help = use fully disambiguated paths (i.e., `<T as Trait>::Assoc`) to refer to associated types in type aliases\n \n-lint-builtin-type-alias-where-clause = where clauses are not enforced in type aliases\n+lint_builtin_type_alias_where_clause = where clauses are not enforced in type aliases\n     .suggestion = the clause will not be checked when the type alias is used, and should be removed\n \n-lint-builtin-type-alias-generic-bounds = bounds on generic parameters are not enforced in type aliases\n+lint_builtin_type_alias_generic_bounds = bounds on generic parameters are not enforced in type aliases\n     .suggestion = the bound will not be checked when the type alias is used, and should be removed\n \n-lint-builtin-trivial-bounds = {$predicate_kind_name} bound {$predicate} does not depend on any type or lifetime parameters\n+lint_builtin_trivial_bounds = {$predicate_kind_name} bound {$predicate} does not depend on any type or lifetime parameters\n \n-lint-builtin-ellipsis-inclusive-range-patterns = `...` range patterns are deprecated\n+lint_builtin_ellipsis_inclusive_range_patterns = `...` range patterns are deprecated\n     .suggestion = use `..=` for an inclusive range\n \n-lint-builtin-unnameable-test-items = cannot test inner items\n+lint_builtin_unnameable_test_items = cannot test inner items\n \n-lint-builtin-keyword-idents = `{$kw}` is a keyword in the {$next} edition\n+lint_builtin_keyword_idents = `{$kw}` is a keyword in the {$next} edition\n     .suggestion = you can use a raw identifier to stay compatible\n \n-lint-builtin-explicit-outlives = outlives requirements can be inferred\n+lint_builtin_explicit_outlives = outlives requirements can be inferred\n     .suggestion = remove {$count ->\n         [one] this bound\n         *[other] these bounds\n     }\n \n-lint-builtin-incomplete-features = the feature `{$name}` is incomplete and may not be safe to use and/or cause compiler crashes\n+lint_builtin_incomplete_features = the feature `{$name}` is incomplete and may not be safe to use and/or cause compiler crashes\n     .note = see issue #{$n} <https://github.com/rust-lang/rust/issues/{$n}> for more information\n     .help = consider using `min_{$name}` instead, which is more stable and complete\n \n-lint-builtin-clashing-extern-same-name = `{$this_fi}` redeclared with a different signature\n-    .previous-decl-label = `{$orig}` previously declared here\n-    .mismatch-label = this signature doesn't match the previous declaration\n-lint-builtin-clashing-extern-diff-name = `{$this_fi}` redeclares `{$orig}` with a different signature\n-    .previous-decl-label = `{$orig}` previously declared here\n-    .mismatch-label = this signature doesn't match the previous declaration\n+lint_builtin_clashing_extern_same_name = `{$this_fi}` redeclared with a different signature\n+    .previous_decl_label = `{$orig}` previously declared here\n+    .mismatch_label = this signature doesn't match the previous declaration\n+lint_builtin_clashing_extern_diff_name = `{$this_fi}` redeclares `{$orig}` with a different signature\n+    .previous_decl_label = `{$orig}` previously declared here\n+    .mismatch_label = this signature doesn't match the previous declaration\n \n-lint-builtin-deref-nullptr = dereferencing a null pointer\n+lint_builtin_deref_nullptr = dereferencing a null pointer\n     .label = this code causes undefined behavior when executed\n \n-lint-builtin-asm-labels = avoid using named labels in inline assembly\n+lint_builtin_asm_labels = avoid using named labels in inline assembly"}, {"sha": "7e583753618354415320138517d7883d068fadda", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1,34 +1,34 @@\n-parser-struct-literal-body-without-path =\n+parser_struct_literal_body_without_path =\n     struct literal body without path\n     .suggestion = you might have forgotten to add the struct literal inside the block\n \n-parser-maybe-report-ambiguous-plus =\n+parser_maybe_report_ambiguous_plus =\n     ambiguous `+` in a type\n     .suggestion = use parentheses to disambiguate\n \n-parser-maybe-recover-from-bad-type-plus =\n+parser_maybe_recover_from_bad_type_plus =\n     expected a path on the left-hand side of `+`, not `{$ty}`\n \n-parser-add-paren = try adding parentheses\n+parser_add_paren = try adding parentheses\n \n-parser-forgot-paren = perhaps you forgot parentheses?\n+parser_forgot_paren = perhaps you forgot parentheses?\n \n-parser-expect-path = expected a path\n+parser_expect_path = expected a path\n \n-parser-maybe-recover-from-bad-qpath-stage-2 =\n+parser_maybe_recover_from_bad_qpath_stage_2 =\n     missing angle brackets in associated item path\n     .suggestion = try: `{$ty}`\n \n-parser-incorrect-semicolon =\n+parser_incorrect_semicolon =\n     expected item, found `;`\n     .suggestion = remove this semicolon\n     .help = {$name} declarations are not followed by a semicolon\n \n-parser-incorrect-use-of-await =\n+parser_incorrect_use_of_await =\n     incorrect use of `await`\n-    .parentheses-suggestion = `await` is not a method call, remove the parentheses\n-    .postfix-suggestion = `await` is a postfix operation\n+    .parentheses_suggestion = `await` is not a method call, remove the parentheses\n+    .postfix_suggestion = `await` is a postfix operation\n \n-parser-in-in-typo =\n+parser_in_in_typo =\n     expected iterable, found keyword `in`\n     .suggestion = remove the duplicated `in`"}, {"sha": "7374f6d3f27d3282c87816425c0dfa1611d002c1", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 114, "deletions": 114, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1,178 +1,178 @@\n--passes-previously-accepted =\n+-passes_previously_accepted =\n     this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n--passes-see-issue =\n+-passes_see_issue =\n     see issue #{$issue} <https://github.com/rust-lang/rust/issues/{$issue}> for more information\n \n-passes-outer-crate-level-attr =\n+passes_outer_crate_level_attr =\n     crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n \n-passes-inner-crate-level-attr =\n+passes_inner_crate_level_attr =\n     crate-level attribute should be in the root module\n \n-passes-ignored-attr-with-macro = `#[{$sym}]` is ignored on struct fields, match arms and macro defs\n-    .warn = {-passes-previously-accepted}\n-    .note = {-passes-see-issue(issue: \"80564\")}\n+passes_ignored_attr_with_macro = `#[{$sym}]` is ignored on struct fields, match arms and macro defs\n+    .warn = {-passes_previously_accepted}\n+    .note = {-passes_see_issue(issue: \"80564\")}\n \n-passes-ignored-attr = `#[{$sym}]` is ignored on struct fields and match arms\n-    .warn = {-passes-previously-accepted}\n-    .note = {-passes-see-issue(issue: \"80564\")}\n+passes_ignored_attr = `#[{$sym}]` is ignored on struct fields and match arms\n+    .warn = {-passes_previously_accepted}\n+    .note = {-passes_see_issue(issue: \"80564\")}\n \n-passes-inline-ignored-function-prototype = `#[inline]` is ignored on function prototypes\n+passes_inline_ignored_function_prototype = `#[inline]` is ignored on function prototypes\n \n-passes-inline-ignored-constants = `#[inline]` is ignored on constants\n-    .warn = {-passes-previously-accepted}\n-    .note = {-passes-see-issue(issue: \"65833\")}\n+passes_inline_ignored_constants = `#[inline]` is ignored on constants\n+    .warn = {-passes_previously_accepted}\n+    .note = {-passes_see_issue(issue: \"65833\")}\n \n-passes-inline-not-fn-or-closure = attribute should be applied to function or closure\n+passes_inline_not_fn_or_closure = attribute should be applied to function or closure\n     .label = not a function or closure\n \n-passes-no-coverage-ignored-function-prototype = `#[no_coverage]` is ignored on function prototypes\n+passes_no_coverage_ignored_function_prototype = `#[no_coverage]` is ignored on function prototypes\n \n-passes-no-coverage-propagate =\n+passes_no_coverage_propagate =\n     `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n \n-passes-no-coverage-fn-defn = `#[no_coverage]` may only be applied to function definitions\n+passes_no_coverage_fn_defn = `#[no_coverage]` may only be applied to function definitions\n \n-passes-no-coverage-not-coverable = `#[no_coverage]` must be applied to coverable code\n+passes_no_coverage_not_coverable = `#[no_coverage]` must be applied to coverable code\n     .label = not coverable code\n \n-passes-should-be-applied-to-fn = attribute should be applied to a function definition\n+passes_should_be_applied_to_fn = attribute should be applied to a function definition\n     .label = not a function definition\n \n-passes-naked-tracked-caller = cannot use `#[track_caller]` with `#[naked]`\n+passes_naked_tracked_caller = cannot use `#[track_caller]` with `#[naked]`\n \n-passes-should-be-applied-to-struct-enum = attribute should be applied to a struct or enum\n+passes_should_be_applied_to_struct_enum = attribute should be applied to a struct or enum\n     .label = not a struct or enum\n \n-passes-should-be-applied-to-trait = attribute should be applied to a trait\n+passes_should_be_applied_to_trait = attribute should be applied to a trait\n     .label = not a trait\n \n-passes-target-feature-on-statement = {passes-should-be-applied-to-fn}\n-    .warn = {-passes-previously-accepted}\n-    .label = {passes-should-be-applied-to-fn.label}\n+passes_target_feature_on_statement = {passes_should_be_applied_to_fn}\n+    .warn = {-passes_previously_accepted}\n+    .label = {passes_should_be_applied_to_fn.label}\n \n-passes-should-be-applied-to-static = attribute should be applied to a static\n+passes_should_be_applied_to_static = attribute should be applied to a static\n     .label = not a static\n \n-passes-doc-expect-str = doc {$attr_name} attribute expects a string: #[doc({$attr_name} = \"a\")]\n+passes_doc_expect_str = doc {$attr_name} attribute expects a string: #[doc({$attr_name} = \"a\")]\n \n-passes-doc-alias-empty = {$attr_str} attribute cannot have empty value\n+passes_doc_alias_empty = {$attr_str} attribute cannot have empty value\n \n-passes-doc-alias-bad-char = {$char_} character isn't allowed in {$attr_str}\n+passes_doc_alias_bad_char = {$char_} character isn't allowed in {$attr_str}\n \n-passes-doc-alias-start-end = {$attr_str} cannot start or end with ' '\n+passes_doc_alias_start_end = {$attr_str} cannot start or end with ' '\n \n-passes-doc-alias-bad-location = {$attr_str} isn't allowed on {$location}\n+passes_doc_alias_bad_location = {$attr_str} isn't allowed on {$location}\n \n-passes-doc-alias-not-an-alias = {$attr_str} is the same as the item's name\n+passes_doc_alias_not_an_alias = {$attr_str} is the same as the item's name\n \n-passes-doc-alias-duplicated = doc alias is duplicated\n+passes_doc_alias_duplicated = doc alias is duplicated\n     .label = first defined here\n \n-passes-doc-alias-not-string-literal = `#[doc(alias(\"a\"))]` expects string literals\n+passes_doc_alias_not_string_literal = `#[doc(alias(\"a\"))]` expects string literals\n \n-passes-doc-alias-malformed =\n+passes_doc_alias_malformed =\n     doc alias attribute expects a string `#[doc(alias = \"a\")]` or a list of strings `#[doc(alias(\"a\", \"b\"))]`\n \n-passes-doc-keyword-empty-mod = `#[doc(keyword = \"...\")]` should be used on empty modules\n+passes_doc_keyword_empty_mod = `#[doc(keyword = \"...\")]` should be used on empty modules\n \n-passes-doc-keyword-not-mod = `#[doc(keyword = \"...\")]` should be used on modules\n+passes_doc_keyword_not_mod = `#[doc(keyword = \"...\")]` should be used on modules\n \n-passes-doc-keyword-invalid-ident = `{$doc_keyword}` is not a valid identifier\n+passes_doc_keyword_invalid_ident = `{$doc_keyword}` is not a valid identifier\n \n-passes-doc-fake-variadic-not-valid =\n+passes_doc_fake_variadic_not_valid =\n     `#[doc(fake_variadic)]` must be used on the first of a set of tuple or fn pointer trait impls with varying arity\n \n-passes-doc-keyword-only-impl = `#[doc(keyword = \"...\")]` should be used on impl blocks\n+passes_doc_keyword_only_impl = `#[doc(keyword = \"...\")]` should be used on impl blocks\n \n-passes-doc-inline-conflict-first = this attribute...\n-passes-doc-inline-conflict-second = ...conflicts with this attribute\n-passes-doc-inline-conflict = conflicting doc inlining attributes\n+passes_doc_inline_conflict_first = this attribute...\n+passes_doc_inline_conflict_second = ...conflicts with this attribute\n+passes_doc_inline_conflict = conflicting doc inlining attributes\n     .help = remove one of the conflicting attributes\n \n-passes-doc-inline-only-use = this attribute can only be applied to a `use` item\n+passes_doc_inline_only_use = this attribute can only be applied to a `use` item\n     .label = only applicable on `use` items\n-    .not-a-use-item-label = not a `use` item\n+    .not_a_use_item_label = not a `use` item\n     .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n \n-passes-doc-attr-not-crate-level =\n+passes_doc_attr_not_crate_level =\n     `#![doc({$attr_name} = \"...\")]` isn't allowed as a crate-level attribute\n \n-passes-attr-crate-level = this attribute can only be applied at the crate level\n+passes_attr_crate_level = this attribute can only be applied at the crate level\n     .suggestion = to apply to the crate, use an inner attribute\n     .help = to apply to the crate, use an inner attribute\n     .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n-passes-doc-test-unknown = unknown `doc(test)` attribute `{$path}`\n+passes_doc_test_unknown = unknown `doc(test)` attribute `{$path}`\n \n-passes-doc-test-takes-list = `#[doc(test(...)]` takes a list of attributes\n+passes_doc_test_takes_list = `#[doc(test(...)]` takes a list of attributes\n \n-passes-doc-primitive = `doc(primitive)` should never have been stable\n+passes_doc_primitive = `doc(primitive)` should never have been stable\n \n-passes-doc-test-unknown-any = unknown `doc` attribute `{$path}`\n+passes_doc_test_unknown_any = unknown `doc` attribute `{$path}`\n \n-passes-doc-test-unknown-spotlight = unknown `doc` attribute `{$path}`\n+passes_doc_test_unknown_spotlight = unknown `doc` attribute `{$path}`\n     .note = `doc(spotlight)` was renamed to `doc(notable_trait)`\n     .suggestion = use `notable_trait` instead\n-    .no-op-note = `doc(spotlight)` is now a no-op\n+    .no_op_note = `doc(spotlight)` is now a no-op\n \n-passes-doc-test-unknown-include = unknown `doc` attribute `{$path}`\n+passes_doc_test_unknown_include = unknown `doc` attribute `{$path}`\n     .suggestion = use `doc = include_str!` instead\n \n-passes-doc-invalid = invalid `doc` attribute\n+passes_doc_invalid = invalid `doc` attribute\n \n-passes-pass-by-value = `pass_by_value` attribute should be applied to a struct, enum or type alias\n+passes_pass_by_value = `pass_by_value` attribute should be applied to a struct, enum or type alias\n     .label = is not a struct, enum or type alias\n \n-passes-allow-incoherent-impl =\n+passes_allow_incoherent_impl =\n     `rustc_allow_incoherent_impl` attribute should be applied to impl items.\n     .label = the only currently supported targets are inherent methods\n \n-passes-has-incoherent-inherent-impl =\n+passes_has_incoherent_inherent_impl =\n     `rustc_has_incoherent_inherent_impls` attribute should be applied to types or traits.\n     .label = only adts, extern types and traits are supported\n \n-passes-must-use-async =\n+passes_must_use_async =\n     `must_use` attribute on `async` functions applies to the anonymous `Future` returned by the function, not the value within\n     .label = this attribute does nothing, the `Future`s returned by async functions are already `must_use`\n \n-passes-must-use-no-effect = `#[must_use]` has no effect when applied to {$article} {$target}\n+passes_must_use_no_effect = `#[must_use]` has no effect when applied to {$article} {$target}\n \n-passes-must-not-suspend = `must_not_suspend` attribute should be applied to a struct, enum, or trait\n+passes_must_not_suspend = `must_not_suspend` attribute should be applied to a struct, enum, or trait\n     .label = is not a struct, enum, or trait\n \n-passes-cold = {passes-should-be-applied-to-fn}\n-    .warn = {-passes-previously-accepted}\n-    .label = {passes-should-be-applied-to-fn.label}\n+passes_cold = {passes_should_be_applied_to_fn}\n+    .warn = {-passes_previously_accepted}\n+    .label = {passes_should_be_applied_to_fn.label}\n \n-passes-link = attribute should be applied to an `extern` block with non-Rust ABI\n-    .warn = {-passes-previously-accepted}\n+passes_link = attribute should be applied to an `extern` block with non-Rust ABI\n+    .warn = {-passes_previously_accepted}\n     .label = not an `extern` block\n \n-passes-link-name = attribute should be applied to a foreign function or static\n-    .warn = {-passes-previously-accepted}\n+passes_link_name = attribute should be applied to a foreign function or static\n+    .warn = {-passes_previously_accepted}\n     .label = not a foreign function or static\n     .help = try `#[link(name = \"{$value}\")]` instead\n \n-passes-no-link = attribute should be applied to an `extern crate` item\n+passes_no_link = attribute should be applied to an `extern crate` item\n     .label = not an `extern crate` item\n \n-passes-export-name = attribute should be applied to a free function, impl method or static\n+passes_export_name = attribute should be applied to a free function, impl method or static\n     .label = not a free function, impl method or static\n \n-passes-rustc-layout-scalar-valid-range-not-struct = attribute should be applied to a struct\n+passes_rustc_layout_scalar_valid_range_not_struct = attribute should be applied to a struct\n     .label = not a struct\n \n-passes-rustc-layout-scalar-valid-range-arg = expected exactly one integer literal argument\n+passes_rustc_layout_scalar_valid_range_arg = expected exactly one integer literal argument\n \n-passes-rustc-legacy-const-generics-only = #[rustc_legacy_const_generics] functions must only have const generics\n+passes_rustc_legacy_const_generics_only = #[rustc_legacy_const_generics] functions must only have const generics\n     .label = non-const generic parameter\n \n-passes-rustc-legacy-const-generics-index = #[rustc_legacy_const_generics] must have one index for each generic parameter\n+passes_rustc_legacy_const_generics_index = #[rustc_legacy_const_generics] must have one index for each generic parameter\n     .label = generic parameters\n \n-passes-rustc-legacy-const-generics-index-exceed = index exceeds number of arguments\n+passes_rustc_legacy_const_generics_index_exceed = index exceeds number of arguments\n     .label = there {$arg_count ->\n         [one] is\n         *[other] are\n@@ -181,87 +181,87 @@ passes-rustc-legacy-const-generics-index-exceed = index exceeds number of argume\n         *[other] arguments\n     }\n \n-passes-rustc-legacy-const-generics-index-negative = arguments should be non-negative integers\n+passes_rustc_legacy_const_generics_index_negative = arguments should be non-negative integers\n \n-passes-rustc-dirty-clean = attribute requires -Z query-dep-graph to be enabled\n+passes_rustc_dirty_clean = attribute requires -Z query-dep-graph to be enabled\n \n-passes-link-section = attribute should be applied to a function or static\n-    .warn = {-passes-previously-accepted}\n+passes_link_section = attribute should be applied to a function or static\n+    .warn = {-passes_previously_accepted}\n     .label = not a function or static\n \n-passes-no-mangle-foreign = `#[no_mangle]` has no effect on a foreign {$foreign_item_kind}\n-    .warn = {-passes-previously-accepted}\n+passes_no_mangle_foreign = `#[no_mangle]` has no effect on a foreign {$foreign_item_kind}\n+    .warn = {-passes_previously_accepted}\n     .label = foreign {$foreign_item_kind}\n     .note = symbol names in extern blocks are not mangled\n     .suggestion = remove this attribute\n \n-passes-no-mangle = attribute should be applied to a free function, impl method or static\n-    .warn = {-passes-previously-accepted}\n+passes_no_mangle = attribute should be applied to a free function, impl method or static\n+    .warn = {-passes_previously_accepted}\n     .label = not a free function, impl method or static\n \n-passes-repr-ident = meta item in `repr` must be an identifier\n+passes_repr_ident = meta item in `repr` must be an identifier\n \n-passes-repr-conflicting = conflicting representation hints\n+passes_repr_conflicting = conflicting representation hints\n \n-passes-used-static = attribute must be applied to a `static` variable\n+passes_used_static = attribute must be applied to a `static` variable\n \n-passes-used-compiler-linker = `used(compiler)` and `used(linker)` can't be used together\n+passes_used_compiler_linker = `used(compiler)` and `used(linker)` can't be used together\n \n-passes-allow-internal-unstable = attribute should be applied to a macro\n+passes_allow_internal_unstable = attribute should be applied to a macro\n     .label = not a macro\n \n-passes-debug-visualizer-placement = attribute should be applied to a module\n+passes_debug_visualizer_placement = attribute should be applied to a module\n \n-passes-debug-visualizer-invalid = invalid argument\n-    .note-1 = expected: `natvis_file = \"...\"`\n-    .note-2 = OR\n-    .note-3 = expected: `gdb_script_file = \"...\"`\n+passes_debug_visualizer_invalid = invalid argument\n+    .note_1 = expected: `natvis_file = \"...\"`\n+    .note_2 = OR\n+    .note_3 = expected: `gdb_script_file = \"...\"`\n \n-passes-rustc-allow-const-fn-unstable = attribute should be applied to `const fn`\n+passes_rustc_allow_const_fn_unstable = attribute should be applied to `const fn`\n     .label = not a `const fn`\n \n-passes-rustc-std-internal-symbol = attribute should be applied to functions or statics\n+passes_rustc_std_internal_symbol = attribute should be applied to functions or statics\n     .label = not a function or static\n \n-passes-const-trait = attribute should be applied to a trait\n+passes_const_trait = attribute should be applied to a trait\n \n-passes-stability-promotable = attribute cannot be applied to an expression\n+passes_stability_promotable = attribute cannot be applied to an expression\n \n-passes-deprecated = attribute is ignored here\n+passes_deprecated = attribute is ignored here\n \n-passes-macro-use = `#[{$name}]` only has an effect on `extern crate` and modules\n+passes_macro_use = `#[{$name}]` only has an effect on `extern crate` and modules\n \n-passes-macro-export = `#[macro_export]` only has an effect on macro definitions\n+passes_macro_export = `#[macro_export]` only has an effect on macro definitions\n \n-passes-plugin-registrar = `#[plugin_registrar]` only has an effect on functions\n+passes_plugin_registrar = `#[plugin_registrar]` only has an effect on functions\n \n-passes-unused-empty-lints-note = attribute `{$name}` with an empty list has no effect\n+passes_unused_empty_lints_note = attribute `{$name}` with an empty list has no effect\n \n-passes-unused-no-lints-note = attribute `{$name}` without any lints has no effect\n+passes_unused_no_lints_note = attribute `{$name}` without any lints has no effect\n \n-passes-unused-default-method-body-const-note =\n+passes_unused_default_method_body_const_note =\n     `default_method_body_is_const` has been replaced with `#[const_trait]` on traits\n \n-passes-unused = unused attribute\n+passes_unused = unused attribute\n     .suggestion = remove this attribute\n \n-passes-non-exported-macro-invalid-attrs = attribute should be applied to function or closure\n+passes_non_exported_macro_invalid_attrs = attribute should be applied to function or closure\n     .label = not a function or closure\n \n-passes-unused-duplicate = unused attribute\n+passes_unused_duplicate = unused attribute\n     .suggestion = remove this attribute\n     .note = attribute also specified here\n-    .warn = {-passes-previously-accepted}\n+    .warn = {-passes_previously_accepted}\n \n-passes-unused-multiple = multiple `{$name}` attributes\n+passes_unused_multiple = multiple `{$name}` attributes\n     .suggestion = remove this attribute\n     .note = attribute also specified here\n \n-passes-rustc-lint-opt-ty = `#[rustc_lint_opt_ty]` should be applied to a struct\n+passes_rustc_lint_opt_ty = `#[rustc_lint_opt_ty]` should be applied to a struct\n     .label = not a struct\n \n-passes-rustc-lint-opt-deny-field-access = `#[rustc_lint_opt_deny_field_access]` should be applied to a field\n+passes_rustc_lint_opt_deny_field_access = `#[rustc_lint_opt_deny_field_access]` should be applied to a field\n     .label = not a field\n \n-passes-link-ordinal = attribute should be applied to a foreign function or static\n-    .label = not a foreign function or static\n\\ No newline at end of file\n+passes_link_ordinal = attribute should be applied to a foreign function or static\n+    .label = not a foreign function or static"}, {"sha": "97050635f45bf4fd751d3e269353392757aa8bc3", "filename": "compiler/rustc_error_messages/locales/en-US/privacy.ftl", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1,20 +1,20 @@\n-privacy-field-is-private = field `{$field_name}` of {$variant_descr} `{$def_path_str}` is private\n-privacy-field-is-private-is-update-syntax-label = field `{$field_name}` is private\n-privacy-field-is-private-label = private field\n+privacy_field_is_private = field `{$field_name}` of {$variant_descr} `{$def_path_str}` is private\n+privacy_field_is_private_is_update_syntax_label = field `{$field_name}` is private\n+privacy_field_is_private_label = private field\n \n-privacy-item-is-private = {$kind} `{$descr}` is private\n+privacy_item_is_private = {$kind} `{$descr}` is private\n     .label = private {$kind}\n-privacy-unnamed-item-is-private = {$kind} is private\n+privacy_unnamed_item_is_private = {$kind} is private\n     .label = private {$kind}\n \n-privacy-in-public-interface = {$vis_descr} {$kind} `{$descr}` in public interface\n+privacy_in_public_interface = {$vis_descr} {$kind} `{$descr}` in public interface\n     .label = can't leak {$vis_descr} {$kind}\n-    .visibility-label = `{$descr}` declared as {$vis_descr}\n+    .visibility_label = `{$descr}` declared as {$vis_descr}\n \n-privacy-from-private-dep-in-public-interface =\n+privacy_from_private_dep_in_public_interface =\n     {$kind} `{$descr}` from private dependency '{$krate}' in public interface\n \n-private-in-public-lint =\n+private_in_public_lint =\n     {$vis_descr} {$kind} `{$descr}` in public interface (error {$kind ->\n         [trait] E0445\n         *[other] E0446"}, {"sha": "494b8f913934f9c2f0bc165b10f75f8aba646d81", "filename": "compiler/rustc_error_messages/locales/en-US/typeck.ftl", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1,101 +1,101 @@\n-typeck-field-multiply-specified-in-initializer =\n+typeck_field_multiply_specified_in_initializer =\n     field `{$ident}` specified more than once\n     .label = used more than once\n-    .previous-use-label = first use of `{$ident}`\n+    .previous_use_label = first use of `{$ident}`\n \n-typeck-unrecognized-atomic-operation =\n+typeck_unrecognized_atomic_operation =\n     unrecognized atomic operation function: `{$op}`\n     .label = unrecognized atomic operation\n \n-typeck-wrong-number-of-generic-arguments-to-intrinsic =\n+typeck_wrong_number_of_generic_arguments_to_intrinsic =\n     intrinsic has wrong number of {$descr} parameters: found {$found}, expected {$expected}\n     .label = expected {$expected} {$descr} {$expected ->\n         [one] parameter\n         *[other] parameters\n     }\n \n-typeck-unrecognized-intrinsic-function =\n+typeck_unrecognized_intrinsic_function =\n     unrecognized intrinsic function: `{$name}`\n     .label = unrecognized intrinsic\n \n-typeck-lifetimes-or-bounds-mismatch-on-trait =\n+typeck_lifetimes_or_bounds_mismatch_on_trait =\n     lifetime parameters or bounds on {$item_kind} `{$ident}` do not match the trait declaration\n     .label = lifetimes do not match {$item_kind} in trait\n-    .generics-label = lifetimes in impl do not match this {$item_kind} in trait\n+    .generics_label = lifetimes in impl do not match this {$item_kind} in trait\n \n-typeck-drop-impl-on-wrong-item =\n+typeck_drop_impl_on_wrong_item =\n     the `Drop` trait may only be implemented for structs, enums, and unions\n     .label = must be a struct, enum, or union\n \n-typeck-field-already-declared =\n+typeck_field_already_declared =\n     field `{$field_name}` is already declared\n     .label = field already declared\n-    .previous-decl-label = `{$field_name}` first declared here\n+    .previous_decl_label = `{$field_name}` first declared here\n \n-typeck-copy-impl-on-type-with-dtor =\n+typeck_copy_impl_on_type_with_dtor =\n     the trait `Copy` may not be implemented for this type; the type has a destructor\n     .label = `Copy` not allowed on types with destructors\n \n-typeck-multiple-relaxed-default-bounds =\n+typeck_multiple_relaxed_default_bounds =\n     type parameter has more than one relaxed default bound, only one is supported\n \n-typeck-copy-impl-on-non-adt =\n+typeck_copy_impl_on_non_adt =\n     the trait `Copy` may not be implemented for this type\n     .label = type is not a structure or enumeration\n \n-typeck-trait-object-declared-with-no-traits =\n+typeck_trait_object_declared_with_no_traits =\n     at least one trait is required for an object type\n-    .alias-span = this alias does not contain a trait\n+    .alias_span = this alias does not contain a trait\n \n-typeck-ambiguous-lifetime-bound =\n+typeck_ambiguous_lifetime_bound =\n     ambiguous lifetime bound, explicit lifetime bound required\n \n-typeck-assoc-type-binding-not-allowed =\n+typeck_assoc_type_binding_not_allowed =\n     associated type bindings are not allowed here\n     .label = associated type not allowed here\n \n-typeck-functional-record-update-on-non-struct =\n+typeck_functional_record_update_on_non_struct =\n     functional record update syntax requires a struct\n \n-typeck-typeof-reserved-keyword-used =\n+typeck_typeof_reserved_keyword_used =\n     `typeof` is a reserved keyword but unimplemented\n     .suggestion = consider replacing `typeof(...)` with an actual type\n     .label = reserved keyword\n \n-typeck-return-stmt-outside-of-fn-body =\n+typeck_return_stmt_outside_of_fn_body =\n     return statement outside of function body\n-    .encl-body-label = the return is part of this body...\n-    .encl-fn-label = ...not the enclosing function body\n+    .encl_body_label = the return is part of this body...\n+    .encl_fn_label = ...not the enclosing function body\n \n-typeck-yield-expr-outside-of-generator =\n+typeck_yield_expr_outside_of_generator =\n     yield expression outside of generator literal\n \n-typeck-struct-expr-non-exhaustive =\n+typeck_struct_expr_non_exhaustive =\n     cannot create non-exhaustive {$what} using struct expression\n \n-typeck-method-call-on-unknown-type =\n+typeck_method_call_on_unknown_type =\n     the type of this value must be known to call a method on a raw pointer on it\n \n-typeck-value-of-associated-struct-already-specified =\n+typeck_value_of_associated_struct_already_specified =\n     the value of the associated type `{$item_name}` (from trait `{$def_path}`) is already specified\n     .label = re-bound here\n-    .previous-bound-label = `{$item_name}` bound here first\n+    .previous_bound_label = `{$item_name}` bound here first\n \n-typeck-address-of-temporary-taken = cannot take address of a temporary\n+typeck_address_of_temporary_taken = cannot take address of a temporary\n     .label = temporary value\n \n-typeck-add-return-type-add = try adding a return type\n+typeck_add_return_type_add = try adding a return type\n \n-typeck-add-return-type-missing-here = a return type might be missing here\n+typeck_add_return_type_missing_here = a return type might be missing here\n \n-typeck-expected-default-return-type = expected `()` because of default return type\n+typeck_expected_default_return_type = expected `()` because of default return type\n \n-typeck-expected-return-type = expected `{$expected}` because of return type\n+typeck_expected_return_type = expected `{$expected}` because of return type\n \n-typeck-unconstrained-opaque-type = unconstrained opaque type\n+typeck_unconstrained_opaque_type = unconstrained opaque type\n     .note = `{$name}` must be used in combination with a concrete type within the same module\n \n-typeck-missing-type-params =\n+typeck_missing_type_params =\n     the type {$parameterCount ->\n         [one] parameter\n         *[other] parameters\n@@ -111,15 +111,15 @@ typeck-missing-type-params =\n         [one] type\n         *[other] types\n     }\n-    .no-suggestion-label = missing {$parameterCount ->\n+    .no_suggestion_label = missing {$parameterCount ->\n         [one] reference\n         *[other] references\n     } to {$parameters}\n     .note = because of the default `Self` reference, type parameters must be specified on object types\n \n-typeck-manual-implementation =\n+typeck_manual_implementation =\n     manual implementations of `{$trait_name}` are experimental\n     .label = manual implementations of `{$trait_name}` are experimental\n     .help = add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n-typeck-substs-on-overridden-impl = could not resolve substs on overridden impl\n+typeck_substs_on_overridden_impl = could not resolve substs on overridden impl"}, {"sha": "2e7652ad333ffcdeafdeb5b87c7e8ddc17fee5a7", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -189,13 +189,25 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n             if let Entry::Message(Message { id: Identifier { name }, attributes, .. }) = entry {\n                 let _ = previous_defns.entry(name.to_string()).or_insert(ident_span);\n \n-                // `typeck-foo-bar` => `foo_bar` (in `typeck.ftl`)\n-                // `const-eval-baz` => `baz` (in `const_eval.ftl`)\n+                if name.contains('-') {\n+                    Diagnostic::spanned(\n+                        ident_span,\n+                        Level::Error,\n+                        format!(\"name `{name}` contains a '-' character\"),\n+                    )\n+                    .help(\"replace any '-'s with '_'s\")\n+                    .emit();\n+                }\n+\n+                // `typeck_foo_bar` => `foo_bar` (in `typeck.ftl`)\n+                // `const_eval_baz` => `baz` (in `const_eval.ftl`)\n+                // `const-eval-hyphen-having` => `hyphen_having` (in `const_eval.ftl`)\n+                // The last case we error about above, but we want to fall back gracefully\n+                // so that only the error is being emitted and not also one about the macro\n+                // failing.\n                 let snake_name = Ident::new(\n                     // FIXME: should probably trim prefix, not replace all occurrences\n-                    &name\n-                        .replace(&format!(\"{}-\", res.ident).replace('_', \"-\"), \"\")\n-                        .replace('-', \"_\"),\n+                    &name.replace('-', \"_\").replace(&format!(\"{}_\", res.ident), \"\"),\n                     span,\n                 );\n                 constants.extend(quote! {\n@@ -212,6 +224,16 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n                         continue;\n                     }\n \n+                    if attr_name.contains('-') {\n+                        Diagnostic::spanned(\n+                            ident_span,\n+                            Level::Error,\n+                            format!(\"attribute `{attr_name}` contains a '-' character\"),\n+                        )\n+                        .help(\"replace any '-'s with '_'s\")\n+                        .emit();\n+                    }\n+\n                     constants.extend(quote! {\n                         pub const #snake_name: crate::SubdiagnosticMessage =\n                             crate::SubdiagnosticMessage::FluentAttr("}, {"sha": "733454cb2a7471d7634d62aa18843f4e78dced85", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -38,9 +38,9 @@ use synstructure::Structure;\n /// ```\n ///\n /// ```fluent\n-/// move-out-of-borrow = cannot move out of {$name} because it is borrowed\n+/// move_out_of_borrow = cannot move out of {$name} because it is borrowed\n ///     .label = cannot move out of borrow\n-///     .first-borrow-label = `{$ty}` first borrowed here\n+///     .first_borrow_label = `{$ty}` first borrowed here\n ///     .suggestion = consider cloning here\n /// ```\n ///\n@@ -84,9 +84,9 @@ pub fn session_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n /// ```\n ///\n /// ```fluent\n-/// lint-atomic-ordering-invalid-fail-success = `{$method}`'s success ordering must be at least as strong as its failure ordering\n-///     .fail-label = `{$fail_ordering}` failure ordering\n-///     .success-label = `{$success_ordering}` success ordering\n+/// lint_atomic_ordering_invalid_fail_success = `{$method}`'s success ordering must be at least as strong as its failure ordering\n+///     .fail_label = `{$fail_ordering}` failure ordering\n+///     .success_label = `{$success_ordering}` success ordering\n ///     .suggestion = consider using `{$success_suggestion}` success ordering instead\n /// ```\n ///\n@@ -140,11 +140,11 @@ pub fn lint_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n /// ```\n ///\n /// ```fluent\n-/// parser-expected-identifier = expected identifier\n+/// parser_expected_identifier = expected identifier\n ///\n-/// parser-expected-identifier-found = expected identifier, found {$found}\n+/// parser_expected_identifier-found = expected identifier, found {$found}\n ///\n-/// parser-raw-identifier = escape `{$ident}` to use it as an identifier\n+/// parser_raw_identifier = escape `{$ident}` to use it as an identifier\n /// ```\n ///\n /// Then, later, to add the subdiagnostic:"}, {"sha": "2f9c13cf817ee7d185ba09ac514989feffcb0a96", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -65,10 +65,10 @@ pub fn newtype_index(input: TokenStream) -> TokenStream {\n /// ..where `typeck.ftl` has the following contents..\n ///\n /// ```fluent\n-/// typeck-field-multiply-specified-in-initializer =\n+/// typeck_field_multiply_specified_in_initializer =\n ///     field `{$ident}` specified more than once\n ///     .label = used more than once\n-///     .label-previous-use = first use of `{$ident}`\n+///     .label_previous_use = first use of `{$ident}`\n /// ```\n /// ...then the macro parse the Fluent resource, emitting a diagnostic if it fails to do so, and\n /// will generate the following code:\n@@ -81,11 +81,11 @@ pub fn newtype_index(input: TokenStream) -> TokenStream {\n /// mod fluent_generated {\n ///     mod typeck {\n ///         pub const field_multiply_specified_in_initializer: DiagnosticMessage =\n-///             DiagnosticMessage::fluent(\"typeck-field-multiply-specified-in-initializer\");\n+///             DiagnosticMessage::fluent(\"typeck_field_multiply_specified_in_initializer\");\n ///         pub const field_multiply_specified_in_initializer_label_previous_use: DiagnosticMessage =\n ///             DiagnosticMessage::fluent_attr(\n-///                 \"typeck-field-multiply-specified-in-initializer\",\n-///                 \"previous-use-label\"\n+///                 \"typeck_field_multiply_specified_in_initializer\",\n+///                 \"previous_use_label\"\n ///             );\n ///     }\n /// }"}, {"sha": "93e70e9abdaca8bf3c3e913fbec59bc6b1a9bab4", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -734,7 +734,7 @@ impl<'a> Parser<'a> {\n             let mut snapshot = self.create_snapshot_for_diagnostic();\n             let path =\n                 Path { segments: vec![], span: self.prev_token.span.shrink_to_lo(), tokens: None };\n-            let struct_expr = snapshot.parse_struct_expr(None, path, AttrVec::new(), false);\n+            let struct_expr = snapshot.parse_struct_expr(None, path, false);\n             let block_tail = self.parse_block_tail(lo, s, AttemptLocalParseRecovery::No);\n             return Some(match (struct_expr, block_tail) {\n                 (Ok(expr), Err(mut err)) => {\n@@ -1188,8 +1188,7 @@ impl<'a> Parser<'a> {\n             outer_op.node,\n         );\n \n-        let mk_err_expr =\n-            |this: &Self, span| Ok(Some(this.mk_expr(span, ExprKind::Err, AttrVec::new())));\n+        let mk_err_expr = |this: &Self, span| Ok(Some(this.mk_expr(span, ExprKind::Err)));\n \n         match inner_op.kind {\n             ExprKind::Binary(op, ref l1, ref r1) if op.node.is_comparison() => {\n@@ -1647,7 +1646,6 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         await_sp: Span,\n-        attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n         let (hi, expr, is_question) = if self.token == token::Not {\n             // Handle `await!(<expr>)`.\n@@ -1662,7 +1660,7 @@ impl<'a> Parser<'a> {\n             ExprKind::Try(_) => ExprKind::Err,\n             _ => ExprKind::Await(expr),\n         };\n-        let expr = self.mk_expr(lo.to(sp), kind, attrs);\n+        let expr = self.mk_expr(lo.to(sp), kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n@@ -1680,7 +1678,7 @@ impl<'a> Parser<'a> {\n             // Handle `await { <expr> }`.\n             // This needs to be handled separately from the next arm to avoid\n             // interpreting `await { <expr> }?` as `<expr>?.await`.\n-            self.parse_block_expr(None, self.token.span, BlockCheckMode::Default, AttrVec::new())\n+            self.parse_block_expr(None, self.token.span, BlockCheckMode::Default)\n         } else {\n             self.parse_expr()\n         }\n@@ -1823,7 +1821,7 @@ impl<'a> Parser<'a> {\n                 err.emit();\n                 // Recover from parse error, callers expect the closing delim to be consumed.\n                 self.consume_block(delim, ConsumeClosingDelim::Yes);\n-                self.mk_expr(lo.to(self.prev_token.span), ExprKind::Err, AttrVec::new())\n+                self.mk_expr(lo.to(self.prev_token.span), ExprKind::Err)\n             }\n         }\n     }"}, {"sha": "9d6d632c2e89af538f32478788458c569f939a9d", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 144, "deletions": 193, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -20,7 +20,6 @@ use rustc_ast::{AnonConst, BinOp, BinOpKind, FnDecl, FnRetTy, MacCall, Param, Ty\n use rustc_ast::{Arm, Async, BlockCheckMode, Expr, ExprKind, Label, Movability, RangeLimits};\n use rustc_ast::{ClosureBinder, StmtKind};\n use rustc_ast_pretty::pprust;\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, PResult};\n use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -45,20 +44,12 @@ macro_rules! maybe_whole_expr {\n                 token::NtPath(path) => {\n                     let path = (**path).clone();\n                     $p.bump();\n-                    return Ok($p.mk_expr(\n-                        $p.prev_token.span,\n-                        ExprKind::Path(None, path),\n-                        AttrVec::new(),\n-                    ));\n+                    return Ok($p.mk_expr($p.prev_token.span, ExprKind::Path(None, path)));\n                 }\n                 token::NtBlock(block) => {\n                     let block = block.clone();\n                     $p.bump();\n-                    return Ok($p.mk_expr(\n-                        $p.prev_token.span,\n-                        ExprKind::Block(block, None),\n-                        AttrVec::new(),\n-                    ));\n+                    return Ok($p.mk_expr($p.prev_token.span, ExprKind::Block(block, None)));\n                 }\n                 _ => {}\n             };\n@@ -120,7 +111,7 @@ impl<'a> Parser<'a> {\n                     // Special-case handling of `foo(_, _, _)`\n                     err.emit();\n                     self.bump();\n-                    Ok(self.mk_expr(self.prev_token.span, ExprKind::Err, AttrVec::new()))\n+                    Ok(self.mk_expr(self.prev_token.span, ExprKind::Err))\n                 }\n                 _ => Err(err),\n             },\n@@ -329,11 +320,9 @@ impl<'a> Parser<'a> {\n                 | AssocOp::GreaterEqual => {\n                     let ast_op = op.to_ast_binop().unwrap();\n                     let binary = self.mk_binary(source_map::respan(cur_op_span, ast_op), lhs, rhs);\n-                    self.mk_expr(span, binary, AttrVec::new())\n-                }\n-                AssocOp::Assign => {\n-                    self.mk_expr(span, ExprKind::Assign(lhs, rhs, cur_op_span), AttrVec::new())\n+                    self.mk_expr(span, binary)\n                 }\n+                AssocOp::Assign => self.mk_expr(span, ExprKind::Assign(lhs, rhs, cur_op_span)),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus => BinOpKind::Add,\n@@ -348,7 +337,7 @@ impl<'a> Parser<'a> {\n                         token::Shr => BinOpKind::Shr,\n                     };\n                     let aopexpr = self.mk_assign_op(source_map::respan(cur_op_span, aop), lhs, rhs);\n-                    self.mk_expr(span, aopexpr, AttrVec::new())\n+                    self.mk_expr(span, aopexpr)\n                 }\n                 AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotEq => {\n                     self.span_bug(span, \"AssocOp should have been handled by special case\")\n@@ -491,7 +480,7 @@ impl<'a> Parser<'a> {\n         let limits =\n             if op == AssocOp::DotDot { RangeLimits::HalfOpen } else { RangeLimits::Closed };\n         let range = self.mk_range(Some(lhs), rhs, limits);\n-        Ok(self.mk_expr(span, range, AttrVec::new()))\n+        Ok(self.mk_expr(span, range))\n     }\n \n     fn is_at_start_of_range_notation_rhs(&self) -> bool {\n@@ -540,7 +529,7 @@ impl<'a> Parser<'a> {\n                 (lo, None)\n             };\n             let range = this.mk_range(None, opt_end, limits);\n-            Ok(this.mk_expr(span, range, attrs.into()))\n+            Ok(this.mk_expr_with_attrs(span, range, attrs))\n         })\n     }\n \n@@ -553,7 +542,7 @@ impl<'a> Parser<'a> {\n             ($this:ident, $attrs:expr, |this, _| $body:expr) => {\n                 $this.collect_tokens_for_expr($attrs, |$this, attrs| {\n                     let (hi, ex) = $body?;\n-                    Ok($this.mk_expr(lo.to(hi), ex, attrs.into()))\n+                    Ok($this.mk_expr_with_attrs(lo.to(hi), ex, attrs))\n                 })\n             };\n         }\n@@ -705,11 +694,7 @@ impl<'a> Parser<'a> {\n         expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind,\n     ) -> PResult<'a, P<Expr>> {\n         let mk_expr = |this: &mut Self, lhs: P<Expr>, rhs: P<Ty>| {\n-            this.mk_expr(\n-                this.mk_expr_sp(&lhs, lhs_span, rhs.span),\n-                expr_kind(lhs, rhs),\n-                AttrVec::new(),\n-            )\n+            this.mk_expr(this.mk_expr_sp(&lhs, lhs_span, rhs.span), expr_kind(lhs, rhs))\n         };\n \n         // Save the state of the parser before parsing type normally, in case there is a\n@@ -737,7 +722,7 @@ impl<'a> Parser<'a> {\n                                 segments[0].ident.span,\n                             ),\n                         };\n-                        match self.parse_labeled_expr(label, AttrVec::new(), false) {\n+                        match self.parse_labeled_expr(label, false) {\n                             Ok(expr) => {\n                                 type_err.cancel();\n                                 self.struct_span_err(label.ident.span, \"malformed loop label\")\n@@ -990,7 +975,7 @@ impl<'a> Parser<'a> {\n             };\n             if has_question {\n                 // `expr?`\n-                e = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Try(e), AttrVec::new());\n+                e = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Try(e));\n                 continue;\n             }\n             let has_dot = if self.prev_token.kind == TokenKind::Ident(kw::Return, false) {\n@@ -1168,7 +1153,7 @@ impl<'a> Parser<'a> {\n         let span = self.prev_token.span;\n         let field = ExprKind::Field(base, Ident::new(field, span));\n         self.expect_no_suffix(span, \"a tuple index\", suffix);\n-        self.mk_expr(lo.to(span), field, AttrVec::new())\n+        self.mk_expr(lo.to(span), field)\n     }\n \n     /// Parse a function call expression, `expr(...)`.\n@@ -1182,9 +1167,9 @@ impl<'a> Parser<'a> {\n         };\n         let open_paren = self.token.span;\n \n-        let mut seq = self.parse_paren_expr_seq().map(|args| {\n-            self.mk_expr(lo.to(self.prev_token.span), self.mk_call(fun, args), AttrVec::new())\n-        });\n+        let mut seq = self\n+            .parse_paren_expr_seq()\n+            .map(|args| self.mk_expr(lo.to(self.prev_token.span), self.mk_call(fun, args)));\n         if let Some(expr) =\n             self.maybe_recover_struct_lit_bad_delims(lo, open_paren, &mut seq, snapshot)\n         {\n@@ -1264,7 +1249,7 @@ impl<'a> Parser<'a> {\n         let index = self.parse_expr()?;\n         self.suggest_missing_semicolon_before_array(prev_span, open_delim_span)?;\n         self.expect(&token::CloseDelim(Delimiter::Bracket))?;\n-        Ok(self.mk_expr(lo.to(self.prev_token.span), self.mk_index(base, index), AttrVec::new()))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), self.mk_index(base, index)))\n     }\n \n     /// Assuming we have just parsed `.`, continue parsing into an expression.\n@@ -1283,11 +1268,7 @@ impl<'a> Parser<'a> {\n             let args = self.parse_paren_expr_seq()?;\n             let fn_span = fn_span_lo.to(self.prev_token.span);\n             let span = lo.to(self.prev_token.span);\n-            Ok(self.mk_expr(\n-                span,\n-                ExprKind::MethodCall(segment, self_arg, args, fn_span),\n-                AttrVec::new(),\n-            ))\n+            Ok(self.mk_expr(span, ExprKind::MethodCall(segment, self_arg, args, fn_span)))\n         } else {\n             // Field access `expr.f`\n             if let Some(args) = segment.args {\n@@ -1299,7 +1280,7 @@ impl<'a> Parser<'a> {\n             }\n \n             let span = lo.to(self.prev_token.span);\n-            Ok(self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), AttrVec::new()))\n+            Ok(self.mk_expr(span, ExprKind::Field(self_arg, segment.ident)))\n         }\n     }\n \n@@ -1314,24 +1295,20 @@ impl<'a> Parser<'a> {\n \n         // Outer attributes are already parsed and will be\n         // added to the return value after the fact.\n-        //\n-        // Therefore, prevent sub-parser from parsing\n-        // attributes by giving them an empty \"already-parsed\" list.\n-        let attrs = AttrVec::new();\n \n         // Note: when adding new syntax here, don't forget to adjust `TokenKind::can_begin_expr()`.\n         let lo = self.token.span;\n         if let token::Literal(_) = self.token.kind {\n             // This match arm is a special-case of the `_` match arm below and\n             // could be removed without changing functionality, but it's faster\n             // to have it here, especially for programs with large constants.\n-            self.parse_lit_expr(attrs)\n+            self.parse_lit_expr()\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n-            self.parse_tuple_parens_expr(attrs)\n+            self.parse_tuple_parens_expr()\n         } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n-            self.parse_block_expr(None, lo, BlockCheckMode::Default, attrs)\n+            self.parse_block_expr(None, lo, BlockCheckMode::Default)\n         } else if self.check(&token::BinOp(token::Or)) || self.check(&token::OrOr) {\n-            self.parse_closure_expr(attrs).map_err(|mut err| {\n+            self.parse_closure_expr().map_err(|mut err| {\n                 // If the input is something like `if a { 1 } else { 2 } | if a { 3 } else { 4 }`\n                 // then suggest parens around the lhs.\n                 if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&lo) {\n@@ -1340,65 +1317,66 @@ impl<'a> Parser<'a> {\n                 err\n             })\n         } else if self.check(&token::OpenDelim(Delimiter::Bracket)) {\n-            self.parse_array_or_repeat_expr(attrs, Delimiter::Bracket)\n+            self.parse_array_or_repeat_expr(Delimiter::Bracket)\n         } else if self.check_path() {\n-            self.parse_path_start_expr(attrs)\n+            self.parse_path_start_expr()\n         } else if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n-            self.parse_closure_expr(attrs)\n+            self.parse_closure_expr()\n         } else if self.eat_keyword(kw::If) {\n-            self.parse_if_expr(attrs)\n+            self.parse_if_expr()\n         } else if self.check_keyword(kw::For) {\n             if self.choose_generics_over_qpath(1) {\n-                self.parse_closure_expr(attrs)\n+                self.parse_closure_expr()\n             } else {\n                 assert!(self.eat_keyword(kw::For));\n-                self.parse_for_expr(None, self.prev_token.span, attrs)\n+                self.parse_for_expr(None, self.prev_token.span)\n             }\n         } else if self.eat_keyword(kw::While) {\n-            self.parse_while_expr(None, self.prev_token.span, attrs)\n+            self.parse_while_expr(None, self.prev_token.span)\n         } else if let Some(label) = self.eat_label() {\n-            self.parse_labeled_expr(label, attrs, true)\n+            self.parse_labeled_expr(label, true)\n         } else if self.eat_keyword(kw::Loop) {\n             let sp = self.prev_token.span;\n-            self.parse_loop_expr(None, self.prev_token.span, attrs).map_err(|mut err| {\n+            self.parse_loop_expr(None, self.prev_token.span).map_err(|mut err| {\n                 err.span_label(sp, \"while parsing this `loop` expression\");\n                 err\n             })\n         } else if self.eat_keyword(kw::Continue) {\n             let kind = ExprKind::Continue(self.eat_label());\n-            Ok(self.mk_expr(lo.to(self.prev_token.span), kind, attrs))\n+            Ok(self.mk_expr(lo.to(self.prev_token.span), kind))\n         } else if self.eat_keyword(kw::Match) {\n             let match_sp = self.prev_token.span;\n-            self.parse_match_expr(attrs).map_err(|mut err| {\n+            self.parse_match_expr().map_err(|mut err| {\n                 err.span_label(match_sp, \"while parsing this `match` expression\");\n                 err\n             })\n         } else if self.eat_keyword(kw::Unsafe) {\n             let sp = self.prev_token.span;\n-            self.parse_block_expr(None, lo, BlockCheckMode::Unsafe(ast::UserProvided), attrs)\n-                .map_err(|mut err| {\n+            self.parse_block_expr(None, lo, BlockCheckMode::Unsafe(ast::UserProvided)).map_err(\n+                |mut err| {\n                     err.span_label(sp, \"while parsing this `unsafe` expression\");\n                     err\n-                })\n+                },\n+            )\n         } else if self.check_inline_const(0) {\n             self.parse_const_block(lo.to(self.token.span), false)\n         } else if self.is_do_catch_block() {\n-            self.recover_do_catch(attrs)\n+            self.recover_do_catch()\n         } else if self.is_try_block() {\n             self.expect_keyword(kw::Try)?;\n-            self.parse_try_block(lo, attrs)\n+            self.parse_try_block(lo)\n         } else if self.eat_keyword(kw::Return) {\n-            self.parse_return_expr(attrs)\n+            self.parse_return_expr()\n         } else if self.eat_keyword(kw::Break) {\n-            self.parse_break_expr(attrs)\n+            self.parse_break_expr()\n         } else if self.eat_keyword(kw::Yield) {\n-            self.parse_yield_expr(attrs)\n+            self.parse_yield_expr()\n         } else if self.is_do_yeet() {\n-            self.parse_yeet_expr(attrs)\n+            self.parse_yeet_expr()\n         } else if self.check_keyword(kw::Let) {\n-            self.parse_let_expr(attrs)\n+            self.parse_let_expr()\n         } else if self.eat_keyword(kw::Underscore) {\n-            Ok(self.mk_expr(self.prev_token.span, ExprKind::Underscore, attrs))\n+            Ok(self.mk_expr(self.prev_token.span, ExprKind::Underscore))\n         } else if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n             // Don't complain about bare semicolons after unclosed braces\n             // recovery in order to keep the error count down. Fixing the\n@@ -1417,32 +1395,32 @@ impl<'a> Parser<'a> {\n             if self.check_keyword(kw::Async) {\n                 if self.is_async_block() {\n                     // Check for `async {` and `async move {`.\n-                    self.parse_async_block(attrs)\n+                    self.parse_async_block()\n                 } else {\n-                    self.parse_closure_expr(attrs)\n+                    self.parse_closure_expr()\n                 }\n             } else if self.eat_keyword(kw::Await) {\n-                self.recover_incorrect_await_syntax(lo, self.prev_token.span, attrs)\n+                self.recover_incorrect_await_syntax(lo, self.prev_token.span)\n             } else {\n-                self.parse_lit_expr(attrs)\n+                self.parse_lit_expr()\n             }\n         } else {\n-            self.parse_lit_expr(attrs)\n+            self.parse_lit_expr()\n         }\n     }\n \n-    fn parse_lit_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_lit_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         match self.parse_opt_lit() {\n             Some(literal) => {\n-                let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Lit(literal), attrs);\n+                let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Lit(literal));\n                 self.maybe_recover_from_bad_qpath(expr)\n             }\n             None => self.try_macro_suggestion(),\n         }\n     }\n \n-    fn parse_tuple_parens_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_tuple_parens_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         self.expect(&token::OpenDelim(Delimiter::Parenthesis))?;\n         let (es, trailing_comma) = match self.parse_seq_to_end(\n@@ -1462,15 +1440,11 @@ impl<'a> Parser<'a> {\n             // `(e,)` is a tuple with only one field, `e`.\n             ExprKind::Tup(es)\n         };\n-        let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n-    fn parse_array_or_repeat_expr(\n-        &mut self,\n-        attrs: AttrVec,\n-        close_delim: Delimiter,\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_array_or_repeat_expr(&mut self, close_delim: Delimiter) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         self.bump(); // `[` or other open delim\n \n@@ -1499,68 +1473,64 @@ impl<'a> Parser<'a> {\n                 ExprKind::Array(vec![first_expr])\n             }\n         };\n-        let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n-    fn parse_path_start_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_path_start_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let (qself, path) = if self.eat_lt() {\n             let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n             (Some(qself), path)\n         } else {\n             (None, self.parse_path(PathStyle::Expr)?)\n         };\n-        let lo = path.span;\n \n         // `!`, as an operator, is prefix, so we know this isn't that.\n-        let (hi, kind) = if self.eat(&token::Not) {\n+        let (span, kind) = if self.eat(&token::Not) {\n             // MACRO INVOCATION expression\n             if qself.is_some() {\n                 self.struct_span_err(path.span, \"macros cannot use qualified paths\").emit();\n             }\n+            let lo = path.span;\n             let mac = MacCall {\n                 path,\n                 args: self.parse_mac_args()?,\n                 prior_type_ascription: self.last_type_ascription,\n             };\n-            (self.prev_token.span, ExprKind::MacCall(mac))\n-        } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n-            if let Some(expr) = self.maybe_parse_struct_expr(qself.as_ref(), &path, &attrs) {\n+            (lo.to(self.prev_token.span), ExprKind::MacCall(mac))\n+        } else if self.check(&token::OpenDelim(Delimiter::Brace)) &&\n+            let Some(expr) = self.maybe_parse_struct_expr(qself.as_ref(), &path) {\n                 if qself.is_some() {\n                     self.sess.gated_spans.gate(sym::more_qualified_paths, path.span);\n                 }\n                 return expr;\n-            } else {\n-                (path.span, ExprKind::Path(qself, path))\n-            }\n         } else {\n             (path.span, ExprKind::Path(qself, path))\n         };\n \n-        let expr = self.mk_expr(lo.to(hi), kind, attrs);\n+        let expr = self.mk_expr(span, kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `'label: $expr`. The label is already parsed.\n     fn parse_labeled_expr(\n         &mut self,\n         label: Label,\n-        attrs: AttrVec,\n         mut consume_colon: bool,\n     ) -> PResult<'a, P<Expr>> {\n         let lo = label.ident.span;\n         let label = Some(label);\n         let ate_colon = self.eat(&token::Colon);\n         let expr = if self.eat_keyword(kw::While) {\n-            self.parse_while_expr(label, lo, attrs)\n+            self.parse_while_expr(label, lo)\n         } else if self.eat_keyword(kw::For) {\n-            self.parse_for_expr(label, lo, attrs)\n+            self.parse_for_expr(label, lo)\n         } else if self.eat_keyword(kw::Loop) {\n-            self.parse_loop_expr(label, lo, attrs)\n+            self.parse_loop_expr(label, lo)\n         } else if self.check_noexpect(&token::OpenDelim(Delimiter::Brace))\n             || self.token.is_whole_block()\n         {\n-            self.parse_block_expr(label, lo, BlockCheckMode::Default, attrs)\n+            self.parse_block_expr(label, lo, BlockCheckMode::Default)\n         } else if !ate_colon\n             && (self.check_noexpect(&TokenKind::Comma) || self.check_noexpect(&TokenKind::Gt))\n         {\n@@ -1626,7 +1596,7 @@ impl<'a> Parser<'a> {\n                 // Replace `'label: non_block_expr` with `'label: {non_block_expr}` in order to supress future errors about `break 'label`.\n                 let stmt = self.mk_stmt(span, StmtKind::Expr(expr));\n                 let blk = self.mk_block(vec![stmt], BlockCheckMode::Default, span);\n-                self.mk_expr(span, ExprKind::Block(blk, label), ThinVec::new())\n+                self.mk_expr(span, ExprKind::Block(blk, label))\n             });\n \n             err.emit();\n@@ -1654,7 +1624,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Recover on the syntax `do catch { ... }` suggesting `try { ... }` instead.\n-    fn recover_do_catch(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn recover_do_catch(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         self.bump(); // `do`\n@@ -1671,7 +1641,7 @@ impl<'a> Parser<'a> {\n             .note(\"following RFC #2388, the new non-placeholder syntax is `try`\")\n             .emit();\n \n-        self.parse_try_block(lo, attrs)\n+        self.parse_try_block(lo)\n     }\n \n     /// Parse an expression if the token can begin one.\n@@ -1680,15 +1650,15 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `\"return\" expr?`.\n-    fn parse_return_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_return_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let kind = ExprKind::Ret(self.parse_expr_opt()?);\n-        let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `\"do\" \"yeet\" expr?`.\n-    fn parse_yeet_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_yeet_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         self.bump(); // `do`\n@@ -1698,7 +1668,7 @@ impl<'a> Parser<'a> {\n \n         let span = lo.to(self.prev_token.span);\n         self.sess.gated_spans.gate(sym::yeet_expr, span);\n-        let expr = self.mk_expr(span, kind, attrs);\n+        let expr = self.mk_expr(span, kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n@@ -1710,13 +1680,13 @@ impl<'a> Parser<'a> {\n     /// `break 'lbl: loop {}`); a labeled break with an unlabeled loop as its value\n     /// expression only gets a warning for compatibility reasons; and a labeled break\n     /// with a labeled loop does not even get a warning because there is no ambiguity.\n-    fn parse_break_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_break_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let mut label = self.eat_label();\n         let kind = if label.is_some() && self.token == token::Colon {\n             // The value expression can be a labeled loop, see issue #86948, e.g.:\n             // `loop { break 'label: loop { break 'label 42; }; }`\n-            let lexpr = self.parse_labeled_expr(label.take().unwrap(), AttrVec::new(), true)?;\n+            let lexpr = self.parse_labeled_expr(label.take().unwrap(), true)?;\n             self.struct_span_err(\n                 lexpr.span,\n                 \"parentheses are required around this expression to avoid confusion with a labeled break expression\",\n@@ -1758,17 +1728,17 @@ impl<'a> Parser<'a> {\n         } else {\n             None\n         };\n-        let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Break(label, kind), attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Break(label, kind));\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `\"yield\" expr?`.\n-    fn parse_yield_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_yield_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let kind = ExprKind::Yield(self.parse_expr_opt()?);\n         let span = lo.to(self.prev_token.span);\n         self.sess.gated_spans.gate(sym::generators, span);\n-        let expr = self.mk_expr(span, kind, attrs);\n+        let expr = self.mk_expr(span, kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n@@ -2012,14 +1982,10 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let minus_present = self.eat(&token::BinOp(token::Minus));\n         let lit = self.parse_lit()?;\n-        let expr = self.mk_expr(lit.span, ExprKind::Lit(lit), AttrVec::new());\n+        let expr = self.mk_expr(lit.span, ExprKind::Lit(lit));\n \n         if minus_present {\n-            Ok(self.mk_expr(\n-                lo.to(self.prev_token.span),\n-                self.mk_unary(UnOp::Neg, expr),\n-                AttrVec::new(),\n-            ))\n+            Ok(self.mk_expr(lo.to(self.prev_token.span), self.mk_unary(UnOp::Neg, expr)))\n         } else {\n             Ok(expr)\n         }\n@@ -2034,13 +2000,9 @@ impl<'a> Parser<'a> {\n     /// Emits a suggestion if it looks like the user meant an array but\n     /// accidentally used braces, causing the code to be interpreted as a block\n     /// expression.\n-    fn maybe_suggest_brackets_instead_of_braces(\n-        &mut self,\n-        lo: Span,\n-        attrs: AttrVec,\n-    ) -> Option<P<Expr>> {\n+    fn maybe_suggest_brackets_instead_of_braces(&mut self, lo: Span) -> Option<P<Expr>> {\n         let mut snapshot = self.create_snapshot_for_diagnostic();\n-        match snapshot.parse_array_or_repeat_expr(attrs, Delimiter::Brace) {\n+        match snapshot.parse_array_or_repeat_expr(Delimiter::Brace) {\n             Ok(arr) => {\n                 let hi = snapshot.prev_token.span;\n                 self.struct_span_err(arr.span, \"this is a block expression, not an array\")\n@@ -2106,10 +2068,9 @@ impl<'a> Parser<'a> {\n         opt_label: Option<Label>,\n         lo: Span,\n         blk_mode: BlockCheckMode,\n-        mut attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n         if self.is_array_like_block() {\n-            if let Some(arr) = self.maybe_suggest_brackets_instead_of_braces(lo, attrs.clone()) {\n+            if let Some(arr) = self.maybe_suggest_brackets_instead_of_braces(lo) {\n                 return Ok(arr);\n             }\n         }\n@@ -2124,19 +2085,18 @@ impl<'a> Parser<'a> {\n                 .emit();\n         }\n \n-        let (inner_attrs, blk) = self.parse_block_common(lo, blk_mode)?;\n-        attrs.extend(inner_attrs);\n-        Ok(self.mk_expr(blk.span, ExprKind::Block(blk, opt_label), attrs))\n+        let (attrs, blk) = self.parse_block_common(lo, blk_mode)?;\n+        Ok(self.mk_expr_with_attrs(blk.span, ExprKind::Block(blk, opt_label), attrs))\n     }\n \n     /// Parse a block which takes no attributes and has no label\n     fn parse_simple_block(&mut self) -> PResult<'a, P<Expr>> {\n         let blk = self.parse_block()?;\n-        Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new()))\n+        Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None)))\n     }\n \n     /// Parses a closure expression (e.g., `move |args| expr`).\n-    fn parse_closure_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_closure_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         let binder = if self.check_keyword(kw::For) {\n@@ -2171,7 +2131,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 // If an explicit return type is given, require a block to appear (RFC 968).\n                 let body_lo = self.token.span;\n-                self.parse_block_expr(None, body_lo, BlockCheckMode::Default, AttrVec::new())?\n+                self.parse_block_expr(None, body_lo, BlockCheckMode::Default)?\n             }\n         };\n \n@@ -2202,7 +2162,6 @@ impl<'a> Parser<'a> {\n                 body,\n                 lo.to(decl_hi),\n             ),\n-            attrs,\n         );\n \n         // Disable recovery for closure body\n@@ -2278,19 +2237,13 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an `if` expression (`if` token already eaten).\n-    fn parse_if_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_if_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let cond = self.parse_cond_expr()?;\n-\n-        self.parse_if_after_cond(attrs, lo, cond)\n+        self.parse_if_after_cond(lo, cond)\n     }\n \n-    fn parse_if_after_cond(\n-        &mut self,\n-        attrs: AttrVec,\n-        lo: Span,\n-        mut cond: P<Expr>,\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_if_after_cond(&mut self, lo: Span, mut cond: P<Expr>) -> PResult<'a, P<Expr>> {\n         let cond_span = cond.span;\n         // Tries to interpret `cond` as either a missing expression if it's a block,\n         // or as an unfinished expression if it's a binop and the RHS is a block.\n@@ -2346,7 +2299,7 @@ impl<'a> Parser<'a> {\n             block\n         };\n         let els = if self.eat_keyword(kw::Else) { Some(self.parse_else_expr()?) } else { None };\n-        Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::If(cond, thn, els), attrs))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::If(cond, thn, els)))\n     }\n \n     fn error_missing_if_then_block(\n@@ -2388,7 +2341,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `let $pat = $expr` pseudo-expression.\n-    fn parse_let_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_let_expr(&mut self) -> PResult<'a, P<Expr>> {\n         // This is a *approximate* heuristic that detects if `let` chains are\n         // being parsed in the right position. It's approximate because it\n         // doesn't deny all invalid `let` expressions, just completely wrong usages.\n@@ -2414,15 +2367,15 @@ impl<'a> Parser<'a> {\n             this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n         })?;\n         let span = lo.to(expr.span);\n-        Ok(self.mk_expr(span, ExprKind::Let(pat, expr, span), attrs))\n+        Ok(self.mk_expr(span, ExprKind::Let(pat, expr, span)))\n     }\n \n     /// Parses an `else { ... }` expression (`else` token already eaten).\n     fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let else_span = self.prev_token.span; // `else`\n         let attrs = self.parse_outer_attributes()?.take_for_recovery(); // For recovery.\n         let expr = if self.eat_keyword(kw::If) {\n-            self.parse_if_expr(AttrVec::new())?\n+            self.parse_if_expr()?\n         } else if self.check(&TokenKind::OpenDelim(Delimiter::Brace)) {\n             self.parse_simple_block()?\n         } else {\n@@ -2445,7 +2398,7 @@ impl<'a> Parser<'a> {\n                             Applicability::MaybeIncorrect,\n                         )\n                         .emit();\n-                    self.parse_if_after_cond(AttrVec::new(), cond.span.shrink_to_lo(), cond)?\n+                    self.parse_if_after_cond(cond.span.shrink_to_lo(), cond)?\n                 }\n                 Err(e) => {\n                     e.cancel();\n@@ -2482,12 +2435,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `for <src_pat> in <src_expr> <src_loop_block>` (`for` token already eaten).\n-    fn parse_for_expr(\n-        &mut self,\n-        opt_label: Option<Label>,\n-        lo: Span,\n-        mut attrs: AttrVec,\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_for_expr(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n         // Record whether we are about to parse `for (`.\n         // This is used below for recovery in case of `for ( $stuff ) $block`\n         // in which case we will suggest `for $stuff $block`.\n@@ -2510,11 +2458,10 @@ impl<'a> Parser<'a> {\n \n         let pat = self.recover_parens_around_for_head(pat, begin_paren);\n \n-        let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n-        attrs.extend(iattrs);\n+        let (attrs, loop_block) = self.parse_inner_attrs_and_block()?;\n \n         let kind = ExprKind::ForLoop(pat, expr, loop_block, opt_label);\n-        Ok(self.mk_expr(lo.to(self.prev_token.span), kind, attrs))\n+        Ok(self.mk_expr_with_attrs(lo.to(self.prev_token.span), kind, attrs))\n     }\n \n     fn error_missing_in_for_loop(&mut self) {\n@@ -2538,35 +2485,31 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `while` or `while let` expression (`while` token already eaten).\n-    fn parse_while_expr(\n-        &mut self,\n-        opt_label: Option<Label>,\n-        lo: Span,\n-        mut attrs: AttrVec,\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_while_expr(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n         let cond = self.parse_cond_expr().map_err(|mut err| {\n             err.span_label(lo, \"while parsing the condition of this `while` expression\");\n             err\n         })?;\n-        let (iattrs, body) = self.parse_inner_attrs_and_block().map_err(|mut err| {\n+        let (attrs, body) = self.parse_inner_attrs_and_block().map_err(|mut err| {\n             err.span_label(lo, \"while parsing the body of this `while` expression\");\n             err.span_label(cond.span, \"this `while` condition successfully parsed\");\n             err\n         })?;\n-        attrs.extend(iattrs);\n-        Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::While(cond, body, opt_label), attrs))\n+        Ok(self.mk_expr_with_attrs(\n+            lo.to(self.prev_token.span),\n+            ExprKind::While(cond, body, opt_label),\n+            attrs,\n+        ))\n     }\n \n     /// Parses `loop { ... }` (`loop` token already eaten).\n-    fn parse_loop_expr(\n-        &mut self,\n-        opt_label: Option<Label>,\n-        lo: Span,\n-        mut attrs: AttrVec,\n-    ) -> PResult<'a, P<Expr>> {\n-        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        attrs.extend(iattrs);\n-        Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::Loop(body, opt_label), attrs))\n+    fn parse_loop_expr(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n+        let (attrs, body) = self.parse_inner_attrs_and_block()?;\n+        Ok(self.mk_expr_with_attrs(\n+            lo.to(self.prev_token.span),\n+            ExprKind::Loop(body, opt_label),\n+            attrs,\n+        ))\n     }\n \n     pub(crate) fn eat_label(&mut self) -> Option<Label> {\n@@ -2577,7 +2520,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `match ... { ... }` expression (`match` token already eaten).\n-    fn parse_match_expr(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_match_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_token.span;\n         let lo = self.prev_token.span;\n         let scrutinee = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n@@ -2597,7 +2540,7 @@ impl<'a> Parser<'a> {\n                 return Err(e);\n             }\n         }\n-        attrs.extend(self.parse_inner_attributes()?);\n+        let attrs = self.parse_inner_attributes()?;\n \n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::CloseDelim(Delimiter::Brace) {\n@@ -2611,13 +2554,17 @@ impl<'a> Parser<'a> {\n                     if self.token == token::CloseDelim(Delimiter::Brace) {\n                         self.bump();\n                     }\n-                    return Ok(self.mk_expr(span, ExprKind::Match(scrutinee, arms), attrs));\n+                    return Ok(self.mk_expr_with_attrs(\n+                        span,\n+                        ExprKind::Match(scrutinee, arms),\n+                        attrs,\n+                    ));\n                 }\n             }\n         }\n         let hi = self.token.span;\n         self.bump();\n-        Ok(self.mk_expr(lo.to(hi), ExprKind::Match(scrutinee, arms), attrs))\n+        Ok(self.mk_expr_with_attrs(lo.to(hi), ExprKind::Match(scrutinee, arms), attrs))\n     }\n \n     /// Attempt to recover from match arm body with statements and no surrounding braces.\n@@ -2877,9 +2824,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `try {...}` expression (`try` token already eaten).\n-    fn parse_try_block(&mut self, span_lo: Span, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        attrs.extend(iattrs);\n+    fn parse_try_block(&mut self, span_lo: Span) -> PResult<'a, P<Expr>> {\n+        let (attrs, body) = self.parse_inner_attrs_and_block()?;\n         if self.eat_keyword(kw::Catch) {\n             let mut error = self.struct_span_err(\n                 self.prev_token.span,\n@@ -2891,7 +2837,7 @@ impl<'a> Parser<'a> {\n         } else {\n             let span = span_lo.to(body.span);\n             self.sess.gated_spans.gate(sym::try_blocks, span);\n-            Ok(self.mk_expr(span, ExprKind::TryBlock(body), attrs))\n+            Ok(self.mk_expr_with_attrs(span, ExprKind::TryBlock(body), attrs))\n         }\n     }\n \n@@ -2913,14 +2859,13 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an `async move? {...}` expression.\n-    fn parse_async_block(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+    fn parse_async_block(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         self.expect_keyword(kw::Async)?;\n         let capture_clause = self.parse_capture_clause()?;\n-        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        attrs.extend(iattrs);\n+        let (attrs, body) = self.parse_inner_attrs_and_block()?;\n         let kind = ExprKind::Async(capture_clause, DUMMY_NODE_ID, body);\n-        Ok(self.mk_expr(lo.to(self.prev_token.span), kind, attrs))\n+        Ok(self.mk_expr_with_attrs(lo.to(self.prev_token.span), kind, attrs))\n     }\n \n     fn is_async_block(&self) -> bool {\n@@ -2954,14 +2899,13 @@ impl<'a> Parser<'a> {\n         &mut self,\n         qself: Option<&ast::QSelf>,\n         path: &ast::Path,\n-        attrs: &AttrVec,\n     ) -> Option<PResult<'a, P<Expr>>> {\n         let struct_allowed = !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n         if struct_allowed || self.is_certainly_not_a_block() {\n             if let Err(err) = self.expect(&token::OpenDelim(Delimiter::Brace)) {\n                 return Some(Err(err));\n             }\n-            let expr = self.parse_struct_expr(qself.cloned(), path.clone(), attrs.clone(), true);\n+            let expr = self.parse_struct_expr(qself.cloned(), path.clone(), true);\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n                 // This is a struct literal, but we don't can't accept them here.\n                 self.error_struct_lit_not_allowed_here(path.span, expr.span);\n@@ -3098,7 +3042,6 @@ impl<'a> Parser<'a> {\n         &mut self,\n         qself: Option<ast::QSelf>,\n         pth: ast::Path,\n-        attrs: AttrVec,\n         recover: bool,\n     ) -> PResult<'a, P<Expr>> {\n         let lo = pth.span;\n@@ -3111,7 +3054,7 @@ impl<'a> Parser<'a> {\n         } else {\n             ExprKind::Struct(P(ast::StructExpr { qself, path: pth, fields, rest: base }))\n         };\n-        Ok(self.mk_expr(span, expr, attrs))\n+        Ok(self.mk_expr(span, expr))\n     }\n \n     /// Use in case of error after field-looking code: `S { foo: () with a }`.\n@@ -3166,7 +3109,7 @@ impl<'a> Parser<'a> {\n                 // Mimic `x: x` for the `x` field shorthand.\n                 let ident = this.parse_ident_common(false)?;\n                 let path = ast::Path::from_ident(ident);\n-                (ident, this.mk_expr(ident.span, ExprKind::Path(None, path), AttrVec::new()))\n+                (ident, this.mk_expr(ident.span, ExprKind::Path(None, path)))\n             } else {\n                 let ident = this.parse_field_name()?;\n                 this.error_on_eq_field_init(ident);\n@@ -3271,17 +3214,25 @@ impl<'a> Parser<'a> {\n \n     fn mk_await_expr(&mut self, self_arg: P<Expr>, lo: Span) -> P<Expr> {\n         let span = lo.to(self.prev_token.span);\n-        let await_expr = self.mk_expr(span, ExprKind::Await(self_arg), AttrVec::new());\n+        let await_expr = self.mk_expr(span, ExprKind::Await(self_arg));\n         self.recover_from_await_method_call();\n         await_expr\n     }\n \n-    pub(crate) fn mk_expr(&self, span: Span, kind: ExprKind, attrs: AttrVec) -> P<Expr> {\n-        P(Expr { kind, span, attrs, id: DUMMY_NODE_ID, tokens: None })\n+    pub(crate) fn mk_expr_with_attrs<A>(&self, span: Span, kind: ExprKind, attrs: A) -> P<Expr>\n+    where\n+        A: Into<AttrVec>,\n+    {\n+        P(Expr { kind, span, attrs: attrs.into(), id: DUMMY_NODE_ID, tokens: None })\n+    }\n+\n+    // njn: rename\n+    pub(crate) fn mk_expr(&self, span: Span, kind: ExprKind) -> P<Expr> {\n+        P(Expr { kind, span, attrs: AttrVec::new(), id: DUMMY_NODE_ID, tokens: None })\n     }\n \n     pub(super) fn mk_expr_err(&self, span: Span) -> P<Expr> {\n-        self.mk_expr(span, ExprKind::Err, AttrVec::new())\n+        self.mk_expr(span, ExprKind::Err)\n     }\n \n     /// Create expression span ensuring the span of the parent node"}, {"sha": "f3f070e6eb021675f7523cf3b8d52274a9ab3ce0", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -2338,7 +2338,7 @@ impl<'a> Parser<'a> {\n                 }\n             };\n \n-            let span = lo.until(this.token.span);\n+            let span = lo.to(this.prev_token.span);\n \n             Ok((\n                 Param {"}, {"sha": "d61da7b6cc00def1abf8f54f705e2a173d7fa323", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1116,10 +1116,14 @@ impl<'a> Parser<'a> {\n         let (attrs, blk) = self.parse_inner_attrs_and_block()?;\n         let anon_const = AnonConst {\n             id: DUMMY_NODE_ID,\n-            value: self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new()),\n+            value: self.mk_expr(blk.span, ExprKind::Block(blk, None)),\n         };\n         let blk_span = anon_const.value.span;\n-        Ok(self.mk_expr(span.to(blk_span), ExprKind::ConstBlock(anon_const), AttrVec::from(attrs)))\n+        Ok(self.mk_expr_with_attrs(\n+            span.to(blk_span),\n+            ExprKind::ConstBlock(anon_const),\n+            AttrVec::from(attrs),\n+        ))\n     }\n \n     /// Parses mutability (`mut` or nothing)."}, {"sha": "98c974420eb3175ae8ffc3071cdb8bad4c7ca3bb", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -4,8 +4,8 @@ use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter};\n use rustc_ast::{\n-    self as ast, AttrVec, Attribute, BindingMode, Expr, ExprKind, MacCall, Mutability, Pat,\n-    PatField, PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n+    self as ast, Attribute, BindingMode, Expr, ExprKind, MacCall, Mutability, Pat, PatField,\n+    PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n };\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n@@ -385,7 +385,7 @@ impl<'a> Parser<'a> {\n             if qself.is_none() && self.check(&token::Not) {\n                 self.parse_pat_mac_invoc(path)?\n             } else if let Some(form) = self.parse_range_end() {\n-                let begin = self.mk_expr(span, ExprKind::Path(qself, path), AttrVec::new());\n+                let begin = self.mk_expr(span, ExprKind::Path(qself, path));\n                 self.parse_pat_range_begin_with(begin, form)?\n             } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n                 self.parse_pat_struct(qself, path)?\n@@ -807,7 +807,7 @@ impl<'a> Parser<'a> {\n                 (None, self.parse_path(PathStyle::Expr)?)\n             };\n             let hi = self.prev_token.span;\n-            Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path), AttrVec::new()))\n+            Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path)))\n         } else {\n             self.parse_literal_maybe_minus()\n         }"}, {"sha": "8332c171a9cbb6e71b2b4e4a09c7a69186ad8447", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -652,12 +652,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_const_arg(&mut self) -> PResult<'a, AnonConst> {\n         // Parse const argument.\n         let value = if let token::OpenDelim(Delimiter::Brace) = self.token.kind {\n-            self.parse_block_expr(\n-                None,\n-                self.token.span,\n-                BlockCheckMode::Default,\n-                ast::AttrVec::new(),\n-            )?\n+            self.parse_block_expr(None, self.token.span, BlockCheckMode::Default)?\n         } else {\n             self.handle_unambiguous_unbraced_const_arg()?\n         };"}, {"sha": "ade0f4fbc86a27b2e1bc4048e326958f63d79659", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -143,10 +143,10 @@ impl<'a> Parser<'a> {\n             }\n \n             let expr = if this.eat(&token::OpenDelim(Delimiter::Brace)) {\n-                this.parse_struct_expr(None, path, AttrVec::new(), true)?\n+                this.parse_struct_expr(None, path, true)?\n             } else {\n                 let hi = this.prev_token.span;\n-                this.mk_expr(lo.to(hi), ExprKind::Path(None, path), AttrVec::new())\n+                this.mk_expr(lo.to(hi), ExprKind::Path(None, path))\n             };\n \n             let expr = this.with_res(Restrictions::STMT_EXPR, |this| {\n@@ -192,7 +192,7 @@ impl<'a> Parser<'a> {\n             StmtKind::MacCall(P(MacCallStmt { mac, style, attrs, tokens: None }))\n         } else {\n             // Since none of the above applied, this is an expression statement macro.\n-            let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac), AttrVec::new());\n+            let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac));\n             let e = self.maybe_recover_from_bad_qpath(e)?;\n             let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n             let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;"}, {"sha": "7124b84bfef3893414cc39da5c93d41da1134446", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -98,7 +98,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, RootVariableMinCaptureList, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{BytePos, Span};\n \n use std::collections::VecDeque;\n use std::io;\n@@ -1549,23 +1549,27 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 .or_insert_with(|| (ln, var, vec![id_and_sp]));\n         });\n \n+        let can_remove = matches!(&pat.kind, hir::PatKind::Struct(_, _, true));\n+\n         for (_, (ln, var, hir_ids_and_spans)) in vars {\n             if self.used_on_entry(ln, var) {\n                 let id = hir_ids_and_spans[0].0;\n                 let spans =\n                     hir_ids_and_spans.into_iter().map(|(_, _, ident_span)| ident_span).collect();\n                 on_used_on_entry(spans, id, ln, var);\n             } else {\n-                self.report_unused(hir_ids_and_spans, ln, var);\n+                self.report_unused(hir_ids_and_spans, ln, var, can_remove);\n             }\n         }\n     }\n \n+    #[tracing::instrument(skip(self), level = \"INFO\")]\n     fn report_unused(\n         &self,\n         hir_ids_and_spans: Vec<(HirId, Span, Span)>,\n         ln: LiveNode,\n         var: Variable,\n+        can_remove: bool,\n     ) {\n         let first_hir_id = hir_ids_and_spans[0].0;\n \n@@ -1590,6 +1594,32 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                             .emit();\n                     },\n                 )\n+            } else if can_remove {\n+                self.ir.tcx.struct_span_lint_hir(\n+                    lint::builtin::UNUSED_VARIABLES,\n+                    first_hir_id,\n+                    hir_ids_and_spans.iter().map(|(_, pat_span, _)| *pat_span).collect::<Vec<_>>(),\n+                    |lint| {\n+                        let mut err = lint.build(&format!(\"unused variable: `{}`\", name));\n+                        err.multipart_suggestion(\n+                            \"try removing the field\",\n+                            hir_ids_and_spans\n+                                .iter()\n+                                .map(|(_, pat_span, _)| {\n+                                    let span = self\n+                                        .ir\n+                                        .tcx\n+                                        .sess\n+                                        .source_map()\n+                                        .span_extend_to_next_char(*pat_span, ',', true);\n+                                    (span.with_hi(BytePos(span.hi().0 + 1)), String::new())\n+                                })\n+                                .collect(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        err.emit();\n+                    },\n+                );\n             } else {\n                 let (shorthands, non_shorthands): (Vec<_>, Vec<_>) =\n                     hir_ids_and_spans.iter().copied().partition(|(hir_id, _, ident_span)| {"}, {"sha": "6b1eaa4d399d9d291133d36e7de2d46c93464b22", "filename": "compiler/rustc_session/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_session%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_session%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2FCargo.toml?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -15,6 +15,5 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_fs_util = { path = \"../rustc_fs_util\" }\n-num_cpus = \"1.0\"\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }"}, {"sha": "46bba02537dc7b830f20d03450c307b964c0c301", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -582,7 +582,7 @@ mod parse {\n     pub(crate) fn parse_threads(slot: &mut usize, v: Option<&str>) -> bool {\n         match v.and_then(|s| s.parse().ok()) {\n             Some(0) => {\n-                *slot = ::num_cpus::get();\n+                *slot = std::thread::available_parallelism().map_or(1, std::num::NonZeroUsize::get);\n                 true\n             }\n             Some(i) => {"}, {"sha": "ad9f5ba85a1912d23d50aa413de0d3e8bdcf8f2c", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -722,7 +722,7 @@ impl SourceMap {\n         })\n     }\n \n-    /// Extends the given `Span` to just after the next occurrence of `c`.\n+    /// Extends the given `Span` to just before the next occurrence of `c`.\n     pub fn span_extend_to_next_char(&self, sp: Span, c: char, accept_newlines: bool) -> Span {\n         if let Ok(next_source) = self.span_to_next_source(sp) {\n             let next_source = next_source.split(c).next().unwrap_or(\"\");"}, {"sha": "9bb41b900b89a35f34a6d8f393dfadea91a20de0", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -307,7 +307,13 @@ fn negative_impl<'cx, 'tcx>(\n             tcx.impl_subject(impl1_def_id),\n         ) {\n             Ok(s) => s,\n-            Err(err) => bug!(\"failed to fully normalize {:?}: {:?}\", impl1_def_id, err),\n+            Err(err) => {\n+                tcx.sess.delay_span_bug(\n+                    tcx.def_span(impl1_def_id),\n+                    format!(\"failed to fully normalize {:?}: {:?}\", impl1_def_id, err),\n+                );\n+                return false;\n+            }\n         };\n \n         // Attempt to prove that impl2 applies, given all of the above."}, {"sha": "84c06fdce70f551ace3e51f554d26aea3d7cbe55", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -53,7 +53,6 @@ dependencies = [\n  \"hex\",\n  \"ignore\",\n  \"libc\",\n- \"num_cpus\",\n  \"once_cell\",\n  \"opener\",\n  \"pretty_assertions\","}, {"sha": "2dad41bb18fceb48cc5a73848615dba9b14ae7bc", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -38,7 +38,6 @@ test = false\n cmake = \"0.1.38\"\n fd-lock = \"3.0.6\"\n filetime = \"0.2\"\n-num_cpus = \"1.0\"\n getopts = \"0.2.19\"\n cc = \"1.0.69\"\n libc = \"0.2\""}, {"sha": "203db2d3876ecf495a539912de46efb7d3064b28", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1465,7 +1465,7 @@ fn set<T>(field: &mut T, val: Option<T>) {\n \n fn threads_from_config(v: u32) -> u32 {\n     match v {\n-        0 => num_cpus::get() as u32,\n+        0 => std::thread::available_parallelism().map_or(1, std::num::NonZeroUsize::get) as u32,\n         n => n,\n     }\n }"}, {"sha": "789da74810035fee1ba918183bab31b61ff2348c", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -220,7 +220,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         let j_msg = format!(\n             \"number of jobs to run in parallel; \\\n              defaults to {} (this host's logical CPU count)\",\n-            num_cpus::get()\n+            std::thread::available_parallelism().map_or(1, std::num::NonZeroUsize::get)\n         );\n         opts.optopt(\"j\", \"jobs\", &j_msg, \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");"}, {"sha": "dcfa92d1004cde1830a95765233700aa1a3ec3d0", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1008,7 +1008,9 @@ impl Build {\n     /// Returns the number of parallel jobs that have been configured for this\n     /// build.\n     fn jobs(&self) -> u32 {\n-        self.config.jobs.unwrap_or_else(|| num_cpus::get() as u32)\n+        self.config.jobs.unwrap_or_else(|| {\n+            std::thread::available_parallelism().map_or(1, std::num::NonZeroUsize::get) as u32\n+        })\n     }\n \n     fn debuginfo_map_to(&self, which: GitRepo) -> Option<String> {"}, {"sha": "1fedb0144d1d088b6645305a8c71b2c3668c903d", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -662,12 +662,10 @@ impl FromWithTcx<clean::Variant> for Variant {\n             Tuple(fields) => Variant::Tuple(\n                 fields\n                     .into_iter()\n-                    .map(|f| {\n-                        if let clean::StructFieldItem(ty) = *f.kind {\n-                            ty.into_tcx(tcx)\n-                        } else {\n-                            unreachable!()\n-                        }\n+                    .filter_map(|f| match *f.kind {\n+                        clean::StructFieldItem(ty) => Some(ty.into_tcx(tcx)),\n+                        clean::StrippedItem(_) => None,\n+                        _ => unreachable!(),\n                     })\n                     .collect(),\n             ),"}, {"sha": "83ed3752a824cd541aa608be7c46fb97b1d234c3", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -88,7 +88,17 @@ impl<'a> DocFolder for Stripper<'a> {\n             }\n \n             // handled in the `strip-priv-imports` pass\n-            clean::ExternCrateItem { .. } | clean::ImportItem(..) => {}\n+            clean::ExternCrateItem { .. } => {}\n+            clean::ImportItem(ref imp) => {\n+                // Because json doesn't inline imports from private modules, we need to mark\n+                // the imported item as retained so it's impls won't be stripped.i\n+                //\n+                // FIXME: Is it necessary to check for json output here: See\n+                // https://github.com/rust-lang/rust/pull/100325#discussion_r941495215\n+                if let Some(did) = imp.source.did && self.is_json_output {\n+                    self.retained.insert(did.into());\n+                }\n+            }\n \n             clean::ImplItem(..) => {}\n "}, {"sha": "4e358583528ee81fa49bfb3cd2d942fdf94b5543", "filename": "src/test/run-make/translation/broken.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Frun-make%2Ftranslation%2Fbroken.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Frun-make%2Ftranslation%2Fbroken.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftranslation%2Fbroken.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1,3 +1,3 @@\n # `foo` isn't provided by this diagnostic so it is expected that the fallback message is used.\n-parser-struct-literal-body-without-path = this is a {$foo} message\n+parser_struct_literal_body_without_path = this is a {$foo} message\n     .suggestion = this is a test suggestion"}, {"sha": "77bbda3575b55339b6595d0f9eebccfb6989c353", "filename": "src/test/run-make/translation/missing.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Frun-make%2Ftranslation%2Fmissing.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Frun-make%2Ftranslation%2Fmissing.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftranslation%2Fmissing.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1,3 +1,3 @@\n-# `parser-struct-literal-body-without-path` isn't provided by this resource at all, so the\n+# `parser_struct_literal_body_without_path` isn't provided by this resource at all, so the\n # fallback should be used.\n foo = bar"}, {"sha": "d5ea8673875eeef77a0527fe4f12dd0b0afaa147", "filename": "src/test/run-make/translation/working.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Frun-make%2Ftranslation%2Fworking.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Frun-make%2Ftranslation%2Fworking.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftranslation%2Fworking.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1,2 +1,2 @@\n-parser-struct-literal-body-without-path = this is a test message\n+parser_struct_literal_body_without_path = this is a test message\n     .suggestion = this is a test suggestion"}, {"sha": "96c96a975d31a6eefec54681dc166042d66a78ca", "filename": "src/test/rustdoc-json/enum_variant_hidden.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Frustdoc-json%2Fenum_variant_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Frustdoc-json%2Fenum_variant_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fenum_variant_hidden.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -0,0 +1,13 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/100529>.\n+\n+#![no_core]\n+#![feature(no_core)]\n+\n+// @has enum_variant_hidden.json \"$.index[*][?(@.name=='ParseError')]\"\n+// @has - \"$.index[*][?(@.name=='UnexpectedEndTag')]\"\n+// @is - \"$.index[*][?(@.name=='UnexpectedEndTag')].inner.variant_kind\" '\"tuple\"'\n+// @is - \"$.index[*][?(@.name=='UnexpectedEndTag')].inner.variant_inner\" []\n+\n+pub enum ParseError {\n+    UnexpectedEndTag(#[doc(hidden)] u32),\n+}"}, {"sha": "ef4d8aa39f88c0f60a891acf0888a1e94d153e32", "filename": "src/test/rustdoc-json/impls/import_from_private.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Frustdoc-json%2Fimpls%2Fimport_from_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Frustdoc-json%2Fimpls%2Fimport_from_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fimpls%2Fimport_from_private.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -0,0 +1,24 @@\n+// https://github.com/rust-lang/rust/issues/100252\n+\n+#![feature(no_core)]\n+#![no_core]\n+\n+mod bar {\n+    // @set baz = import_from_private.json \"$.index[*][?(@.kind=='struct')].id\"\n+    pub struct Baz;\n+    // @set impl = - \"$.index[*][?(@.kind=='impl')].id\"\n+    impl Baz {\n+        // @set doit = - \"$.index[*][?(@.kind=='method')].id\"\n+        pub fn doit() {}\n+    }\n+}\n+\n+// @set import = - \"$.index[*][?(@.kind=='import')].id\"\n+pub use bar::Baz;\n+\n+// FIXME(adotinthevoid): Use hasexact once #99474 lands\n+\n+// @has - \"$.index[*][?(@.kind=='module')].inner.items[*]\" $import\n+// @is  - \"$.index[*][?(@.kind=='import')].inner.id\" $baz\n+// @has - \"$.index[*][?(@.kind=='struct')].inner.impls[*]\" $impl\n+// @has - \"$.index[*][?(@.kind=='impl')].inner.items[*]\" $doit"}, {"sha": "84b6c3e6c005581f5a9be0476884e9f8fa18086b", "filename": "src/test/ui-fulldeps/fluent-messages/label-with-hyphens.ftl", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Flabel-with-hyphens.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Flabel-with-hyphens.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Flabel-with-hyphens.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -0,0 +1,2 @@\n+some_slug = hi\n+    .label-has-hyphens = test"}, {"sha": "74b2aa1d44d1f9552a039d1b90b7ad4042c63dd3", "filename": "src/test/ui-fulldeps/fluent-messages/missing-message.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fmissing-message.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fmissing-message.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fmissing-message.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1 +1 @@\n-missing-message = \n+missing_message ="}, {"sha": "07517c9a2434f3611ae027877327a05d233cf0d6", "filename": "src/test/ui-fulldeps/fluent-messages/slug-with-hyphens.ftl", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fslug-with-hyphens.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fslug-with-hyphens.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fslug-with-hyphens.ftl?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -0,0 +1 @@\n+this-slug-has-hyphens = hi"}, {"sha": "f0f35780666bbdd07a98ed3ae15488ea6c721f65", "filename": "src/test/ui-fulldeps/fluent-messages/test.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -55,6 +55,24 @@ mod duplicate {\n     }\n }\n \n+mod slug_with_hyphens {\n+    use super::fluent_messages;\n+\n+    fluent_messages! {\n+        slug_with_hyphens => \"./slug-with-hyphens.ftl\",\n+//~^ ERROR name `this-slug-has-hyphens` contains a '-' character\n+    }\n+}\n+\n+mod label_with_hyphens {\n+    use super::fluent_messages;\n+\n+    fluent_messages! {\n+        label_with_hyphens => \"./label-with-hyphens.ftl\",\n+//~^ ERROR attribute `label-has-hyphens` contains a '-' character\n+    }\n+}\n+\n mod valid {\n     use super::fluent_messages;\n "}, {"sha": "856642c4818da2058a55b5d9b1443fa0593c02a9", "filename": "src/test/ui-fulldeps/fluent-messages/test.stderr", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.stderr?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -22,11 +22,11 @@ LL |         missing_message => \"./missing-message.ftl\",\n    |\n    = help: see additional errors emitted\n \n-error: expected a message field for \"missing-message\"\n+error: expected a message field for \"missing_message\"\n  --> ./missing-message.ftl:1:1\n   |\n-1 | missing-message = \n-  | ^^^^^^^^^^^^^^^^^^\n+1 | missing_message =\n+  | ^^^^^^^^^^^^^^^^^\n   |\n \n error: overrides existing message: `key`\n@@ -41,5 +41,21 @@ help: previously defined in this resource\n LL |         a => \"./duplicate-a.ftl\",\n    |         ^\n \n-error: aborting due to 4 previous errors\n+error: name `this-slug-has-hyphens` contains a '-' character\n+  --> $DIR/test.rs:62:9\n+   |\n+LL |         slug_with_hyphens => \"./slug-with-hyphens.ftl\",\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: replace any '-'s with '_'s\n+\n+error: attribute `label-has-hyphens` contains a '-' character\n+  --> $DIR/test.rs:71:9\n+   |\n+LL |         label_with_hyphens => \"./label-with-hyphens.ftl\",\n+   |         ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: replace any '-'s with '_'s\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "bf49e7444583b55eecb43ecd31e8dc544f657aaa", "filename": "src/test/ui/argument-suggestions/complex.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fargument-suggestions%2Fcomplex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fargument-suggestions%2Fcomplex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fcomplex.stderr?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -8,7 +8,7 @@ note: function defined here\n   --> $DIR/complex.rs:11:4\n    |\n LL | fn complex(_i: u32, _s: &str, _e: E, _f: F, _g: G, _x: X, _y: Y, _z: Z ) {}\n-   |    ^^^^^^^ -------  --------  -----  -----  -----  -----  -----  ------\n+   |    ^^^^^^^ -------  --------  -----  -----  -----  -----  -----  -----\n help: did you mean\n    |\n LL |   complex(/* u32 */, &\"\", /* E */, F::X2, G{}, X {}, Y {}, Z {});"}, {"sha": "60b379faf4e060fe4c4317ffe4b7ce3a0f44de04", "filename": "src/test/ui/c-variadic/issue-86053-1.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fc-variadic%2Fissue-86053-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fc-variadic%2Fissue-86053-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fissue-86053-1.stderr?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -44,19 +44,19 @@ error: `...` must be the last argument of a C-variadic function\n   --> $DIR/issue-86053-1.rs:11:12\n    |\n LL |     self , ... ,   self ,   self , ... ) where F : FnOnce ( & 'a & 'b usize ) {\n-   |            ^^^^\n+   |            ^^^\n \n error: only foreign or `unsafe extern \"C\"` functions may be C-variadic\n   --> $DIR/issue-86053-1.rs:11:12\n    |\n LL |     self , ... ,   self ,   self , ... ) where F : FnOnce ( & 'a & 'b usize ) {\n-   |            ^^^^\n+   |            ^^^\n \n error: only foreign or `unsafe extern \"C\"` functions may be C-variadic\n   --> $DIR/issue-86053-1.rs:11:36\n    |\n LL |     self , ... ,   self ,   self , ... ) where F : FnOnce ( & 'a & 'b usize ) {\n-   |                                    ^^^^\n+   |                                    ^^^\n \n error[E0412]: cannot find type `F` in this scope\n   --> $DIR/issue-86053-1.rs:11:48"}, {"sha": "1c8316f87fa073ef9bdf16e5503df9942beaaf0d", "filename": "src/test/ui/coherence/issue-100191-2.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191-2.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -0,0 +1,12 @@\n+//~ ERROR overflow evaluating the requirement `T: Trait<_>`\n+\n+#![feature(specialization, with_negative_coherence)]\n+#![allow(incomplete_features)]\n+\n+pub trait Trait<T> {}\n+\n+default impl<T, U> Trait<T> for U {}\n+\n+impl<T> Trait<<T as Iterator>::Item> for T {}\n+\n+fn main() {}"}, {"sha": "ea09fb15bdfa3460b0b61025f5c443d5a19b35e6", "filename": "src/test/ui/coherence/issue-100191-2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191-2.stderr?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -0,0 +1,14 @@\n+error[E0275]: overflow evaluating the requirement `T: Trait<_>`\n+   |\n+   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_100191_2`)\n+note: required because of the requirements on the impl of `Trait<_>` for `T`\n+  --> $DIR/issue-100191-2.rs:8:20\n+   |\n+LL | default impl<T, U> Trait<T> for U {}\n+   |                    ^^^^^^^^     ^\n+   = note: 128 redundant requirements hidden\n+   = note: required because of the requirements on the impl of `Trait<_>` for `T`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0275`."}, {"sha": "e8597fde54d3ba133ec922311d78233642e949cc", "filename": "src/test/ui/coherence/issue-100191.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -0,0 +1,21 @@\n+#![crate_type = \"lib\"]\n+#![feature(specialization, with_negative_coherence)]\n+#![allow(incomplete_features)]\n+\n+trait X {}\n+trait Y: X {}\n+trait Z {\n+    type Assoc: Y;\n+}\n+struct A<T>(T);\n+\n+impl<T> Y for T where T: X {}\n+impl<T: X> Z for A<T> {\n+    type Assoc = T;\n+}\n+\n+// this impl is invalid, but causes an ICE anyway\n+impl<T> From<<A<T> as Z>::Assoc> for T {}\n+//~^ ERROR type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n+\n+fn main() {}"}, {"sha": "1adb0f1e4fa7b288ffd6338b6e26e54bcce3702c", "filename": "src/test/ui/coherence/issue-100191.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191.stderr?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -0,0 +1,12 @@\n+error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n+  --> $DIR/issue-100191.rs:18:6\n+   |\n+LL | impl<T> From<<A<T> as Z>::Assoc> for T {}\n+   |      ^ type parameter `T` must be used as the type parameter for some local type\n+   |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n+   = note: only traits defined in the current crate can be implemented for a type parameter\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0210`."}, {"sha": "948aa2b94d9656dffa72ed6b022038bc93743269", "filename": "src/test/ui/suggestions/dont-try-removing-the-field.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fsuggestions%2Fdont-try-removing-the-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fsuggestions%2Fdont-try-removing-the-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-try-removing-the-field.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![allow(dead_code)]\n+\n+struct Foo {\n+    foo: i32,\n+    bar: i32,\n+    baz: (),\n+}\n+\n+fn use_foo(x: Foo) -> (i32, i32) {\n+    let Foo { foo, bar, baz } = x; //~ WARNING unused variable: `baz`\n+                                   //~| help: try ignoring the field\n+    return (foo, bar);\n+}\n+\n+fn main() {}"}, {"sha": "263171a4ac456d13d06b8e589c4347efebccc90e", "filename": "src/test/ui/suggestions/dont-try-removing-the-field.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fsuggestions%2Fdont-try-removing-the-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fsuggestions%2Fdont-try-removing-the-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-try-removing-the-field.stderr?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -0,0 +1,10 @@\n+warning: unused variable: `baz`\n+  --> $DIR/dont-try-removing-the-field.rs:12:25\n+   |\n+LL |     let Foo { foo, bar, baz } = x;\n+   |                         ^^^ help: try ignoring the field: `baz: _`\n+   |\n+   = note: `#[warn(unused_variables)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "17de49fbd841de4cb9aef08178564bd414095208", "filename": "src/test/ui/suggestions/suggest-ref-macro.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-ref-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-ref-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-ref-macro.stderr?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -10,14 +10,8 @@ LL | #[hello]\n note: function defined here\n   --> $DIR/suggest-ref-macro.rs:8:1\n    |\n-LL |   #[hello]\n-   |  _-^^^^^^^\n-LL | | fn abc() {}\n-LL | |\n-LL | | fn x(_: &mut i32) {}\n-LL | |\n-LL | | macro_rules! bla {\n-   | |_____________-\n+LL | #[hello]\n+   | ^^^^^^^^\n    = note: this error originates in the attribute macro `hello` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0308]: mismatched types"}, {"sha": "9d0573ca2554d536b610bcb5b57e84fc43684e45", "filename": "src/test/ui/suggestions/try-removing-the-field.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fsuggestions%2Ftry-removing-the-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fsuggestions%2Ftry-removing-the-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftry-removing-the-field.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![allow(dead_code)]\n+\n+struct Foo {\n+    foo: i32,\n+    bar: (),\n+    baz: (),\n+}\n+\n+fn use_foo(x: Foo) -> i32 {\n+    let Foo { foo, bar, .. } = x; //~ WARNING unused variable: `bar`\n+                                  //~| help: try removing the field\n+    return foo;\n+}\n+\n+fn main() {}"}, {"sha": "448a2c3d2ec27a8be9663a575f51ded43a2cf9b4", "filename": "src/test/ui/suggestions/try-removing-the-field.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fsuggestions%2Ftry-removing-the-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Fsuggestions%2Ftry-removing-the-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftry-removing-the-field.stderr?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -0,0 +1,12 @@\n+warning: unused variable: `bar`\n+  --> $DIR/try-removing-the-field.rs:12:20\n+   |\n+LL |     let Foo { foo, bar, .. } = x;\n+   |                    ^^^-\n+   |                    |\n+   |                    help: try removing the field\n+   |\n+   = note: `#[warn(unused_variables)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "847bc517ea3d368a72d0e52ceec779df61c22357", "filename": "src/test/ui/type/type-check/issue-88577-check-fn-with-more-than-65535-arguments.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-88577-check-fn-with-more-than-65535-arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-88577-check-fn-with-more-than-65535-arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-88577-check-fn-with-more-than-65535-arguments.stderr?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -1,13 +1,13 @@\n error: function can not have more than 65535 arguments\n-  --> $DIR/issue-88577-check-fn-with-more-than-65535-arguments.rs:6:24\n+  --> $DIR/issue-88577-check-fn-with-more-than-65535-arguments.rs:6:22\n    |\n-LL |           fn _f($($t: ()),*) {}\n-   |  ________________________^\n-LL | |     }\n-LL | | }\n-LL | |\n-LL | | many_args!{[_]########## ######}\n-   | |____________^\n+LL |         fn _f($($t: ()),*) {}\n+   |                      ^\n+...\n+LL | many_args!{[_]########## ######}\n+   | -------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `many_args` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "c437bde5ae69a47233ef3a16678dac8aff9d51a3", "filename": "src/tools/build-manifest/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2FCargo.toml?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -13,4 +13,3 @@ tar = \"0.4.29\"\n sha2 = \"0.10.1\"\n rayon = \"1.5.1\"\n hex = \"0.4.2\"\n-num_cpus = \"1.13.0\""}, {"sha": "1a6760d8c68b9fa91e45aecdd3485e6891b491d3", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40336865fe7d4a01139a3336639c6971647e885c/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=40336865fe7d4a01139a3336639c6971647e885c", "patch": "@@ -210,7 +210,7 @@ fn main() {\n     let num_threads = if let Some(num) = env::var_os(\"BUILD_MANIFEST_NUM_THREADS\") {\n         num.to_str().unwrap().parse().expect(\"invalid number for BUILD_MANIFEST_NUM_THREADS\")\n     } else {\n-        num_cpus::get()\n+        std::thread::available_parallelism().map_or(1, std::num::NonZeroUsize::get)\n     };\n     rayon::ThreadPoolBuilder::new()\n         .num_threads(num_threads)"}]}