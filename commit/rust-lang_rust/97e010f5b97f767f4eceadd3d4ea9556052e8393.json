{"sha": "97e010f5b97f767f4eceadd3d4ea9556052e8393", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ZTAxMGY1Yjk3Zjc2N2Y0ZWNlYWRkM2Q0ZWE5NTU2MDUyZTgzOTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-21T14:25:47Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-27T13:26:23Z"}, "message": "barriers prevent deallocation", "tree": {"sha": "a9cf1495ff2038af3c767e296c866bf03cc38233", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9cf1495ff2038af3c767e296c866bf03cc38233"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97e010f5b97f767f4eceadd3d4ea9556052e8393", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97e010f5b97f767f4eceadd3d4ea9556052e8393", "html_url": "https://github.com/rust-lang/rust/commit/97e010f5b97f767f4eceadd3d4ea9556052e8393", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97e010f5b97f767f4eceadd3d4ea9556052e8393/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "194710e112ef5cc7bd9f8a7f5924c4574eca0406", "url": "https://api.github.com/repos/rust-lang/rust/commits/194710e112ef5cc7bd9f8a7f5924c4574eca0406", "html_url": "https://github.com/rust-lang/rust/commit/194710e112ef5cc7bd9f8a7f5924c4574eca0406"}], "stats": {"total": 95, "additions": 70, "deletions": 25}, "files": [{"sha": "e06943f2ba0697939667f50fd48c662c5e240ca1", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 57, "deletions": 25, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/97e010f5b97f767f4eceadd3d4ea9556052e8393/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e010f5b97f767f4eceadd3d4ea9556052e8393/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=97e010f5b97f767f4eceadd3d4ea9556052e8393", "patch": "@@ -90,6 +90,14 @@ pub enum RefKind {\n     Raw,\n }\n \n+/// What kind of access is being performed?\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum AccessKind {\n+    Read,\n+    Write,\n+    Dealloc,\n+}\n+\n /// Extra global state in the memory, available to the memory access hooks\n #[derive(Debug)]\n pub struct BarrierTracking {\n@@ -221,13 +229,13 @@ impl<'tcx> Stack {\n     fn access(\n         &mut self,\n         bor: Borrow,\n-        is_write: bool,\n+        kind: AccessKind,\n         barrier_tracking: &BarrierTracking,\n     ) -> EvalResult<'tcx> {\n         // Check if we can match the frozen \"item\".\n         // Not possible on writes!\n         if self.is_frozen() {\n-            if !is_write {\n+            if kind == AccessKind::Read {\n                 // When we are frozen, we just accept all reads.  No harm in this.\n                 // The deref already checked that `Uniq` items are in the stack, and that\n                 // the location is frozen if it should be.\n@@ -247,26 +255,41 @@ impl<'tcx> Stack {\n                     )))\n                 }\n                 (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n-                    // Found matching unique item.\n-                    return Ok(())\n+                    // Found matching unique item.  Continue after the match.\n                 }\n-                (BorStackItem::Shr, _) if !is_write => {\n+                (BorStackItem::Shr, _) if kind == AccessKind::Read => {\n                     // When reading, everything can use a shared item!\n                     // We do not want to do this when writing: Writing to an `&mut`\n                     // should reaffirm its exclusivity (i.e., make sure it is\n-                    // on top of the stack).\n-                    return Ok(())\n+                    // on top of the stack).  Continue after the match.\n                 }\n                 (BorStackItem::Shr, Borrow::Shr(_)) => {\n-                    // Found matching shared item.\n-                    return Ok(())\n+                    // Found matching shared item.  Continue after the match.\n                 }\n                 _ => {\n-                    // Pop this.  This ensures U2.\n+                    // Pop this, go on.  This ensures U2.\n                     let itm = self.borrows.pop().unwrap();\n                     trace!(\"access: Popping {:?}\", itm);\n+                    continue\n+                }\n+            }\n+            // If we got here, we found a matching item.  Congratulations!\n+            // However, we are not done yet: If this access is deallocating, we must make sure\n+            // there are no active barriers remaining on the stack.\n+            if kind == AccessKind::Dealloc {\n+                for &itm in self.borrows.iter().rev() {\n+                    match itm {\n+                        BorStackItem::FnBarrier(call) if barrier_tracking.is_active(call) => {\n+                            return err!(MachineError(format!(\n+                                \"Deallocating with active barrier ({})\", call\n+                            )))\n+                        }\n+                        _ => {},\n+                    }\n                 }\n             }\n+            // NOW we are done.\n+            return Ok(())\n         }\n         // If we got here, we did not find our item.\n         err!(MachineError(format!(\n@@ -352,18 +375,16 @@ impl<'tcx> Stacks {\n         &self,\n         ptr: Pointer<Borrow>,\n         size: Size,\n-        is_write: bool,\n-        barrier_tracking: &BarrierTracking,\n+        kind: AccessKind,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"{} access of tag {:?}: {:?}, size {}\",\n-            if is_write { \"read\" } else { \"write\" },\n-            ptr.tag, ptr, size.bytes());\n+        trace!(\"{:?} access of tag {:?}: {:?}, size {}\", kind, ptr.tag, ptr, size.bytes());\n         // Even reads can have a side-effect, by invalidating other references.\n         // This is fundamentally necessary since `&mut` asserts that there\n         // are no accesses through other references, not even reads.\n+        let barrier_tracking = self.barrier_tracking.borrow();\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.access(ptr.tag, is_write, barrier_tracking)?;\n+            stack.access(ptr.tag, kind, &*barrier_tracking)?;\n         }\n         Ok(())\n     }\n@@ -377,16 +398,24 @@ impl<'tcx> Stacks {\n         mut barrier: Option<CallId>,\n         new_bor: Borrow,\n         new_kind: RefKind,\n-        barrier_tracking: &BarrierTracking,\n     ) -> EvalResult<'tcx> {\n         assert_eq!(new_bor.is_unique(), new_kind == RefKind::Unique);\n         trace!(\"reborrow for tag {:?} to {:?} as {:?}: {:?}, size {}\",\n             ptr.tag, new_bor, new_kind, ptr, size.bytes());\n         if new_kind == RefKind::Raw {\n             // No barrier for raw, including `&UnsafeCell`.  They can rightfully\n             // alias with `&mut`.\n+            // FIXME: This means that the `dereferencable` attribute on non-frozen shared\n+            // references is incorrect!  They are dereferencable when the function is\n+            // called, but might become non-dereferencable during the coruse of execution.\n+            // Also see [1], [2].\n+            //\n+            // [1]: <https://internals.rust-lang.org/t/\n+            //       is-it-possible-to-be-memory-safe-with-deallocated-self/8457/8>,\n+            // [2]: <https://lists.llvm.org/pipermail/llvm-dev/2018-July/124555.html>\n             barrier = None;\n         }\n+        let barrier_tracking = self.barrier_tracking.borrow();\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n             // Access source `ptr`, create new ref.\n@@ -410,7 +439,12 @@ impl<'tcx> Stacks {\n                 continue;\n             }\n             // We need to do some actual work.\n-            stack.access(ptr.tag, new_kind == RefKind::Unique, barrier_tracking)?;\n+            let access_kind = if new_kind == RefKind::Unique {\n+                AccessKind::Write\n+            } else {\n+                AccessKind::Read\n+            };\n+            stack.access(ptr.tag, access_kind, &*barrier_tracking)?;\n             if let Some(call) = barrier {\n                 stack.barrier(call);\n             }\n@@ -440,7 +474,7 @@ impl AllocationExtra<Borrow, MemoryState> for Stacks {\n         ptr: Pointer<Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.access(ptr, size, /*is_write*/false, &*alloc.extra.barrier_tracking.borrow())\n+        alloc.extra.access(ptr, size, AccessKind::Read)\n     }\n \n     #[inline(always)]\n@@ -449,7 +483,7 @@ impl AllocationExtra<Borrow, MemoryState> for Stacks {\n         ptr: Pointer<Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.access(ptr, size, /*is_write*/true, &*alloc.extra.barrier_tracking.borrow())\n+        alloc.extra.access(ptr, size, AccessKind::Write)\n     }\n \n     #[inline(always)]\n@@ -458,9 +492,7 @@ impl AllocationExtra<Borrow, MemoryState> for Stacks {\n         ptr: Pointer<Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        // This is like mutating\n-        alloc.extra.access(ptr, size, /*is_write*/true, &*alloc.extra.barrier_tracking.borrow())\n-        // FIXME: Error out of there are any barriers?\n+        alloc.extra.access(ptr, size, AccessKind::Dealloc)\n     }\n }\n \n@@ -627,12 +659,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n             // Reference that cares about freezing. We need a frozen-sensitive reborrow.\n             self.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n                 let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n-                alloc.extra.reborrow(cur_ptr, size, barrier, new_bor, kind, &*self.memory().extra.borrow())\n+                alloc.extra.reborrow(cur_ptr, size, barrier, new_bor, kind)\n             })?;\n         } else {\n             // Just treat this as one big chunk.\n             let kind = if new_bor.is_unique() { RefKind::Unique } else { RefKind::Raw };\n-            alloc.extra.reborrow(ptr, size, barrier, new_bor, kind, &*self.memory().extra.borrow())?;\n+            alloc.extra.reborrow(ptr, size, barrier, new_bor, kind)?;\n         }\n         Ok(new_ptr)\n     }"}, {"sha": "eb988a5899593f5371a6562a014b26ae9fa6047c", "filename": "tests/compile-fail-fullmir/stacked_borrows/deallocate_against_barrier.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/97e010f5b97f767f4eceadd3d4ea9556052e8393/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fdeallocate_against_barrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e010f5b97f767f4eceadd3d4ea9556052e8393/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fdeallocate_against_barrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fdeallocate_against_barrier.rs?ref=97e010f5b97f767f4eceadd3d4ea9556052e8393", "patch": "@@ -0,0 +1,13 @@\n+// error-pattern: Deallocating with active barrier\n+\n+fn inner(x: &mut i32, f: fn(&mut i32)) {\n+    // `f` may mutate, but it may not deallocate!\n+    f(x)\n+}\n+\n+fn main() {\n+    inner(Box::leak(Box::new(0)), |x| {\n+        let raw = x as *mut _;\n+        drop(unsafe { Box::from_raw(raw) });\n+    });\n+}"}]}