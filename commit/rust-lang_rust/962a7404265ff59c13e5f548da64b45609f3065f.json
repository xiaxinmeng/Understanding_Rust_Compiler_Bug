{"sha": "962a7404265ff59c13e5f548da64b45609f3065f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MmE3NDA0MjY1ZmY1OWMxM2U1ZjU0OGRhNjRiNDU2MDlmMzA2NWY=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-09T20:43:45Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-18T04:24:33Z"}, "message": "Rewrite file descriptor handling", "tree": {"sha": "967c40def5017f683b81237a1b368d2e1a035dc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/967c40def5017f683b81237a1b368d2e1a035dc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/962a7404265ff59c13e5f548da64b45609f3065f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/962a7404265ff59c13e5f548da64b45609f3065f", "html_url": "https://github.com/rust-lang/rust/commit/962a7404265ff59c13e5f548da64b45609f3065f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/962a7404265ff59c13e5f548da64b45609f3065f/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "636ad629f8dc0d803b5738c78fb0ad44efb767c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/636ad629f8dc0d803b5738c78fb0ad44efb767c9", "html_url": "https://github.com/rust-lang/rust/commit/636ad629f8dc0d803b5738c78fb0ad44efb767c9"}], "stats": {"total": 117, "additions": 74, "deletions": 43}, "files": [{"sha": "26bcdbde0573c360e3709591e892af8ac6eb82eb", "filename": "src/shims/fs.rs", "status": "modified", "additions": 73, "deletions": 43, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/962a7404265ff59c13e5f548da64b45609f3065f/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962a7404265ff59c13e5f548da64b45609f3065f/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=962a7404265ff59c13e5f548da64b45609f3065f", "patch": "@@ -1,4 +1,4 @@\n-use std::collections::HashMap;\n+use std::collections::BTreeMap;\n use std::convert::{TryFrom, TryInto};\n use std::fs::{remove_file, rename, File, OpenOptions};\n use std::io::{Read, Seek, SeekFrom, Write};\n@@ -13,34 +13,58 @@ use helpers::immty_from_uint_checked;\n use shims::time::system_time_to_duration;\n \n #[derive(Debug)]\n-pub struct FileHandle {\n-    file: File,\n-    writable: bool,\n+pub enum FileHandle {\n+    StdInPlaceholder,\n+    StdOutPlaceholder,\n+    StdErrPlaceholder,\n+    File { file: File, writable: bool },\n+    // In the future, could add support for dirfd() and other functions by\n+    // adding a Directory variant here\n }\n \n pub struct FileHandler {\n-    handles: HashMap<i32, FileHandle>,\n-    low: i32,\n+    handles: BTreeMap<i32, FileHandle>,\n }\n \n impl FileHandler {\n-    fn next_fd(&self) -> i32 {\n-        self.low + 1\n+    fn insert_fd(&mut self, file_handle: FileHandle) -> i32 {\n+        self.insert_fd_with_min_fd(file_handle, 3)\n     }\n \n-    fn register_fd(&mut self, fd: i32, handle: FileHandle) {\n-        self.low = fd;\n-        self.handles.insert(fd, handle).unwrap_none();\n+    fn insert_fd_with_min_fd(&mut self, file_handle: FileHandle, min_fd: i32) -> i32 {\n+        let min_fd = std::cmp::max(min_fd, 3);\n+        let candidate_new_fd = self\n+            .handles\n+            .range(min_fd..)\n+            .zip(min_fd..)\n+            .find_map(|((fd, _fh), counter)| {\n+                if *fd != counter {\n+                    // There was a gap in the fds stored, return the first unused one\n+                    // (note that this relies on BTreeMap iterating in key order)\n+                    Some(counter)\n+                } else {\n+                    // This fd is used, keep going\n+                    None\n+                }\n+            });\n+        let new_fd = candidate_new_fd.unwrap_or_else(|| {\n+            // find_map ran out of BTreeMap entries before finding a free fd, use one plus the\n+            // maximum fd in the map\n+            self.handles.keys().rev().next().map(|last_fd| last_fd + 1).unwrap_or(min_fd)\n+        });\n+        self.handles.insert(new_fd, file_handle).unwrap_none();\n+        new_fd\n     }\n }\n \n impl Default for FileHandler {\n     fn default() -> Self {\n-        FileHandler {\n-            handles: Default::default(),\n-            // 0, 1 and 2 are reserved for stdin, stdout and stderr.\n-            low: 2,\n-        }\n+        let mut handles: BTreeMap<i32, FileHandle> = Default::default();\n+        // 0, 1 and 2 are reserved for stdin, stdout and stderr.\n+        handles.insert(0, FileHandle::StdInPlaceholder);\n+        handles.insert(1, FileHandle::StdOutPlaceholder);\n+        handles.insert(2, FileHandle::StdErrPlaceholder);\n+        FileHandler { handles }\n     }\n }\n \n@@ -119,9 +143,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = options.open(&path).map(|file| {\n             let fh = &mut this.machine.file_handler;\n-            let fd = fh.next_fd();\n-            fh.register_fd(fd, FileHandle { file, writable });\n-            fd\n+            fh.insert_fd(FileHandle::File { file, writable })\n         });\n \n         this.try_unwrap_io_result(fd)\n@@ -150,23 +172,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             } else {\n                 this.handle_not_found()\n             }\n-        } else if cmd == this.eval_libc_i32(\"F_DUPFD\")? || cmd == this.eval_libc_i32(\"F_DUPFD_CLOEXEC\")? {\n+        } else if cmd == this.eval_libc_i32(\"F_DUPFD\")?\n+            || cmd == this.eval_libc_i32(\"F_DUPFD_CLOEXEC\")?\n+        {\n             // Note that we always assume the FD_CLOEXEC flag is set for every open file, in part\n             // because exec() isn't supported. The F_DUPFD and F_DUPFD_CLOEXEC commands only\n             // differ in whether the FD_CLOEXEC flag is pre-set on the new file descriptor,\n             // thus they can share the same implementation here.\n-            let arg_op = arg_op\n-                .ok_or_else(|| err_unsup_format!(\"fcntl with command F_DUPFD or F_DUPFD_CLOEXEC requires a third argument\"))?;\n+            let arg_op = arg_op.ok_or_else(|| {\n+                err_unsup_format!(\n+                    \"fcntl with command F_DUPFD or F_DUPFD_CLOEXEC requires a third argument\"\n+                )\n+            })?;\n             let arg = this.read_scalar(arg_op)?.to_i32()?;\n             let fh = &mut this.machine.file_handler;\n             let (file_result, writable) = match fh.handles.get(&fd) {\n-                Some(original) => (original.file.try_clone(), original.writable),\n+                Some(FileHandle::File { file, writable }) => (file.try_clone(), *writable),\n+                Some(_) => throw_unsup_format!(\"Duplicating file descriptors for stdin, stdout, or stderr is not supported\"),\n                 None => return this.handle_not_found(),\n             };\n             let fd_result = file_result.map(|duplicated| {\n-                let new_fd = std::cmp::max(fh.next_fd(), arg);\n-                fh.register_fd(new_fd, FileHandle { file: duplicated, writable });\n-                new_fd\n+                fh.insert_fd_with_min_fd(FileHandle::File { file: duplicated, writable }, arg)\n             });\n             this.try_unwrap_io_result(fd_result)\n         } else {\n@@ -181,23 +207,28 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n \n-        if let Some(handle) = this.machine.file_handler.handles.remove(&fd) {\n+        if fd <= 2 {\n+            // early return to prevent removing StdInPlaceholder, etc., from the handles map\n+            return this.handle_not_found();\n+        }\n+\n+        if let Some(FileHandle::File { file, writable }) = this.machine.file_handler.handles.remove(&fd) {\n             // We sync the file if it was opened in a mode different than read-only.\n-            if handle.writable {\n+            if writable {\n                 // `File::sync_all` does the checks that are done when closing a file. We do this to\n                 // to handle possible errors correctly.\n-                let result = this.try_unwrap_io_result(handle.file.sync_all().map(|_| 0i32));\n+                let result = this.try_unwrap_io_result(file.sync_all().map(|_| 0i32));\n                 // Now we actually close the file.\n-                drop(handle);\n+                drop(file);\n                 // And return the result.\n                 result\n             } else {\n                 // We drop the file, this closes it but ignores any errors produced when closing\n-                // it. This is done because `File::sync_call` cannot be done over files like\n+                // it. This is done because `File::sync_all` cannot be done over files like\n                 // `/dev/urandom` which are read-only. Check\n                 // https://github.com/rust-lang/miri/issues/999#issuecomment-568920439 for a deeper\n                 // discussion.\n-                drop(handle);\n+                drop(file);\n                 Ok(0)\n             }\n         } else {\n@@ -230,16 +261,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n         let count = count.min(this.isize_max() as u64).min(isize::max_value() as u64);\n \n-        if let Some(handle) = this.machine.file_handler.handles.get_mut(&fd) {\n+        if let Some(FileHandle::File { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n             // This can never fail because `count` was capped to be smaller than\n             // `isize::max_value()`.\n             let count = isize::try_from(count).unwrap();\n             // We want to read at most `count` bytes. We are sure that `count` is not negative\n             // because it was a target's `usize`. Also we are sure that its smaller than\n             // `usize::max_value()` because it is a host's `isize`.\n             let mut bytes = vec![0; count as usize];\n-            let result = handle\n-                .file\n+            let result = file\n                 .read(&mut bytes)\n                 // `File::read` never returns a value larger than `count`, so this cannot fail.\n                 .map(|c| i64::try_from(c).unwrap());\n@@ -285,9 +315,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n         let count = count.min(this.isize_max() as u64).min(isize::max_value() as u64);\n \n-        if let Some(handle) = this.machine.file_handler.handles.get_mut(&fd) {\n+        if let Some(FileHandle::File { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n             let bytes = this.memory.read_bytes(buf, Size::from_bytes(count))?;\n-            let result = handle.file.write(&bytes).map(|c| i64::try_from(c).unwrap());\n+            let result = file.write(&bytes).map(|c| i64::try_from(c).unwrap());\n             this.try_unwrap_io_result(result)\n         } else {\n             this.handle_not_found()\n@@ -320,8 +350,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(-1);\n         };\n \n-        if let Some(handle) = this.machine.file_handler.handles.get_mut(&fd) {\n-            let result = handle.file.seek(seek_from).map(|offset| offset as i64);\n+        if let Some(FileHandle::File { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n+            let result = file.seek(seek_from).map(|offset| offset as i64);\n             this.try_unwrap_io_result(result)\n         } else {\n             this.handle_not_found()\n@@ -682,11 +712,11 @@ impl FileMetadata {\n         fd: i32,\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n         let option = ecx.machine.file_handler.handles.get(&fd);\n-        let handle = match option {\n-            Some(handle) => handle,\n-            None => return ecx.handle_not_found().map(|_: i32| None),\n+        let file = match option {\n+            Some(FileHandle::File { file, writable: _ }) => file,\n+            Some(_) | None => return ecx.handle_not_found().map(|_: i32| None),\n         };\n-        let metadata = handle.file.metadata();\n+        let metadata = file.metadata();\n \n         FileMetadata::from_meta(ecx, metadata)\n     }"}, {"sha": "8fc03bcb11b88b740baf751e89fa861b5a860a50", "filename": "tests/run-pass/fs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/962a7404265ff59c13e5f548da64b45609f3065f/tests%2Frun-pass%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962a7404265ff59c13e5f548da64b45609f3065f/tests%2Frun-pass%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs.rs?ref=962a7404265ff59c13e5f548da64b45609f3065f", "patch": "@@ -50,6 +50,7 @@ fn main() {\n     cloned.read_to_end(&mut contents).unwrap();\n     assert_eq!(bytes, contents.as_slice());\n \n+    let mut file = File::open(&path).unwrap();\n     // Test that seeking to the beginning and reading until EOF gets the text again.\n     file.seek(SeekFrom::Start(0)).unwrap();\n     let mut contents = Vec::new();"}]}