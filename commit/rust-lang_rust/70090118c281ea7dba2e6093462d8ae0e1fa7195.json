{"sha": "70090118c281ea7dba2e6093462d8ae0e1fa7195", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMDkwMTE4YzI4MWVhN2RiYTJlNjA5MzQ2MmQ4YWUwZTFmYTcxOTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-22T01:09:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-22T01:09:04Z"}, "message": "Auto merge of #78752 - jyn514:html-diff, r=GuillaumeGomez\n\nGive a better error when rustdoc tests fail\n\n- Run the default rustdoc against the current rustdoc\n- Diff output recursively\n- Colorize diff output\n\nCloses https://github.com/rust-lang/rust/issues/78750.\n\n## Resolved questions\n\n- Should this be opt-in instead of on by default?\n  + No\n- Should this call through to `delta`? That's not a very common program to have installed, but I'm not sure how to do diffs after the fact. Maybe `compiletest` can take a `--syntax-highlighter` parameter or something?\n  + I decided to use `delta` if available and `diff --color` otherwise. It prints a warning if delta isn't installed so you know you can get nicer diffs\n\n## Open questions.\n\n- What version of rustdoc would this compare against? Ideally it would compare against `$(git merge-base HEAD origin/master)` - maybe that's feasible if we install those artifacts from CI?\n- Does it always make sense to compare the tests? Especially for new tests, I'm not sure how useful it would be ... but then again, one of the questions I want to know most as a reviewer is 'did it break before?'.\n\nr? `@GuillaumeGomez`\ncc `@Mark-Simulacrum`", "tree": {"sha": "4d00450fe6416fb42524aa73228d5de7188e50e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d00450fe6416fb42524aa73228d5de7188e50e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70090118c281ea7dba2e6093462d8ae0e1fa7195", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70090118c281ea7dba2e6093462d8ae0e1fa7195", "html_url": "https://github.com/rust-lang/rust/commit/70090118c281ea7dba2e6093462d8ae0e1fa7195", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70090118c281ea7dba2e6093462d8ae0e1fa7195/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "html_url": "https://github.com/rust-lang/rust/commit/a1a13b2bc4fa6370b9501135d97c5fe0bc401894"}, {"sha": "25a3ffe5d4768e37fe98c9637db84af4714549d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/25a3ffe5d4768e37fe98c9637db84af4714549d4", "html_url": "https://github.com/rust-lang/rust/commit/25a3ffe5d4768e37fe98c9637db84af4714549d4"}], "stats": {"total": 156, "additions": 146, "deletions": 10}, "files": [{"sha": "8d23227fdb8b78dab6a6ac3556ac581e81f127de", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/70090118c281ea7dba2e6093462d8ae0e1fa7195/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70090118c281ea7dba2e6093462d8ae0e1fa7195/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=70090118c281ea7dba2e6093462d8ae0e1fa7195", "patch": "@@ -153,11 +153,14 @@ fn parse_line(file_name: &str, line: &str, output: &str, proc_res: &ProcRes) ->\n                 if serde_json::from_str::<FutureIncompatReport>(line).is_ok() {\n                     vec![]\n                 } else {\n-                    proc_res.fatal(Some(&format!(\n-                        \"failed to decode compiler output as json: \\\n+                    proc_res.fatal(\n+                        Some(&format!(\n+                            \"failed to decode compiler output as json: \\\n                          `{}`\\nline: {}\\noutput: {}\",\n-                        error, line, output\n-                    )));\n+                            error, line, output\n+                        )),\n+                        || (),\n+                    );\n                 }\n             }\n         }"}, {"sha": "32347db5dbb1ceb1b35af940413223733f1bdf52", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70090118c281ea7dba2e6093462d8ae0e1fa7195/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70090118c281ea7dba2e6093462d8ae0e1fa7195/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=70090118c281ea7dba2e6093462d8ae0e1fa7195", "patch": "@@ -379,7 +379,7 @@ pub fn run_tests(config: Config) {\n         }\n         Err(e) => {\n             // We don't know if tests passed or not, but if there was an error\n-            // during testing we don't want to just suceeed (we may not have\n+            // during testing we don't want to just succeed (we may not have\n             // tested something), so fail.\n             //\n             // This should realistically \"never\" happen, so don't try to make"}, {"sha": "4ca0b2aba0ad1c64edaab74c90afedd61fcbfa9c", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 138, "deletions": 5, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/70090118c281ea7dba2e6093462d8ae0e1fa7195/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70090118c281ea7dba2e6093462d8ae0e1fa7195/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=70090118c281ea7dba2e6093462d8ae0e1fa7195", "patch": "@@ -287,6 +287,7 @@ pub fn compute_stamp_hash(config: &Config) -> String {\n     format!(\"{:x}\", hash.finish())\n }\n \n+#[derive(Copy, Clone)]\n struct TestCx<'test> {\n     config: &'test Config,\n     props: &'test TestProps,\n@@ -1729,7 +1730,7 @@ impl<'test> TestCx<'test> {\n         self.config.target.contains(\"vxworks\") && !self.is_vxworks_pure_static()\n     }\n \n-    fn compose_and_run_compiler(&self, mut rustc: Command, input: Option<String>) -> ProcRes {\n+    fn build_all_auxiliary(&self, rustc: &mut Command) -> PathBuf {\n         let aux_dir = self.aux_output_dir_name();\n \n         if !self.props.aux_builds.is_empty() {\n@@ -1748,6 +1749,11 @@ impl<'test> TestCx<'test> {\n             rustc.arg(\"--extern\").arg(format!(\"{}={}/{}\", aux_name, aux_dir.display(), lib_name));\n         }\n \n+        aux_dir\n+    }\n+\n+    fn compose_and_run_compiler(&self, mut rustc: Command, input: Option<String>) -> ProcRes {\n+        let aux_dir = self.build_all_auxiliary(&mut rustc);\n         self.props.unset_rustc_env.clone().iter().fold(&mut rustc, |rustc, v| rustc.env_remove(v));\n         rustc.envs(self.props.rustc_env.clone());\n         self.compose_and_run(\n@@ -2209,7 +2215,17 @@ impl<'test> TestCx<'test> {\n \n     fn fatal_proc_rec(&self, err: &str, proc_res: &ProcRes) -> ! {\n         self.error(err);\n-        proc_res.fatal(None);\n+        proc_res.fatal(None, || ());\n+    }\n+\n+    fn fatal_proc_rec_with_ctx(\n+        &self,\n+        err: &str,\n+        proc_res: &ProcRes,\n+        on_failure: impl FnOnce(Self),\n+    ) -> ! {\n+        self.error(err);\n+        proc_res.fatal(None, || on_failure(*self));\n     }\n \n     // codegen tests (using FileCheck)\n@@ -2326,15 +2342,131 @@ impl<'test> TestCx<'test> {\n             let res = self.cmd2procres(\n                 Command::new(&self.config.docck_python)\n                     .arg(root.join(\"src/etc/htmldocck.py\"))\n-                    .arg(out_dir)\n+                    .arg(&out_dir)\n                     .arg(&self.testpaths.file),\n             );\n             if !res.status.success() {\n-                self.fatal_proc_rec(\"htmldocck failed!\", &res);\n+                self.fatal_proc_rec_with_ctx(\"htmldocck failed!\", &res, |mut this| {\n+                    this.compare_to_default_rustdoc(&out_dir)\n+                });\n             }\n         }\n     }\n \n+    fn compare_to_default_rustdoc(&mut self, out_dir: &Path) {\n+        println!(\"info: generating a diff against nightly rustdoc\");\n+\n+        let suffix =\n+            self.safe_revision().map_or(\"nightly\".into(), |path| path.to_owned() + \"-nightly\");\n+        let compare_dir = output_base_dir(self.config, self.testpaths, Some(&suffix));\n+        // Don't give an error if the directory didn't already exist\n+        let _ = fs::remove_dir_all(&compare_dir);\n+        create_dir_all(&compare_dir).unwrap();\n+\n+        // We need to create a new struct for the lifetimes on `config` to work.\n+        let new_rustdoc = TestCx {\n+            config: &Config {\n+                // FIXME: use beta or a user-specified rustdoc instead of\n+                // hardcoding the default toolchain\n+                rustdoc_path: Some(\"rustdoc\".into()),\n+                // Needed for building auxiliary docs below\n+                rustc_path: \"rustc\".into(),\n+                ..self.config.clone()\n+            },\n+            ..*self\n+        };\n+\n+        let output_file = TargetLocation::ThisDirectory(new_rustdoc.aux_output_dir_name());\n+        let mut rustc = new_rustdoc.make_compile_args(\n+            &new_rustdoc.testpaths.file,\n+            output_file,\n+            EmitMetadata::No,\n+            AllowUnused::Yes,\n+        );\n+        rustc.arg(\"-L\").arg(&new_rustdoc.aux_output_dir_name());\n+        new_rustdoc.build_all_auxiliary(&mut rustc);\n+\n+        let proc_res = new_rustdoc.document(&compare_dir);\n+        if !proc_res.status.success() {\n+            proc_res.fatal(Some(\"failed to run nightly rustdoc\"), || ());\n+        }\n+\n+        #[rustfmt::skip]\n+        let tidy_args = [\n+            \"--indent\", \"yes\",\n+            \"--indent-spaces\", \"2\",\n+            \"--wrap\", \"0\",\n+            \"--show-warnings\", \"no\",\n+            \"--markup\", \"yes\",\n+            \"--quiet\", \"yes\",\n+            \"-modify\",\n+        ];\n+        let tidy_dir = |dir| {\n+            let tidy = |file: &_| {\n+                Command::new(\"tidy\")\n+                    .args(&tidy_args)\n+                    .arg(file)\n+                    .spawn()\n+                    .unwrap_or_else(|err| {\n+                        self.fatal(&format!(\"failed to run tidy - is it installed? - {}\", err))\n+                    })\n+                    .wait()\n+                    .unwrap()\n+            };\n+            for entry in walkdir::WalkDir::new(dir) {\n+                let entry = entry.expect(\"failed to read file\");\n+                if entry.file_type().is_file()\n+                    && entry.path().extension().and_then(|p| p.to_str()) == Some(\"html\".into())\n+                {\n+                    tidy(entry.path());\n+                }\n+            }\n+        };\n+        tidy_dir(out_dir);\n+        tidy_dir(&compare_dir);\n+\n+        let pager = {\n+            let output = Command::new(\"git\").args(&[\"config\", \"--get\", \"core.pager\"]).output().ok();\n+            output.and_then(|out| {\n+                if out.status.success() {\n+                    Some(String::from_utf8(out.stdout).expect(\"invalid UTF8 in git pager\"))\n+                } else {\n+                    None\n+                }\n+            })\n+        };\n+        let mut diff = Command::new(\"diff\");\n+        diff.args(&[\"-u\", \"-r\"]).args(&[out_dir, &compare_dir]);\n+\n+        let output = if let Some(pager) = pager {\n+            let diff_pid = diff.stdout(Stdio::piped()).spawn().expect(\"failed to run `diff`\");\n+            let pager = pager.trim();\n+            if self.config.verbose {\n+                eprintln!(\"using pager {}\", pager);\n+            }\n+            let output = Command::new(pager)\n+                // disable paging; we want this to be non-interactive\n+                .env(\"PAGER\", \"\")\n+                .stdin(diff_pid.stdout.unwrap())\n+                // Capture output and print it explicitly so it will in turn be\n+                // captured by libtest.\n+                .output()\n+                .unwrap();\n+            assert!(output.status.success());\n+            output\n+        } else {\n+            eprintln!(\"warning: no pager configured, falling back to `diff --color`\");\n+            eprintln!(\n+                \"help: try configuring a git pager (e.g. `delta`) with `git config --global core.pager delta`\"\n+            );\n+            let output = diff.arg(\"--color\").output().unwrap();\n+            assert!(output.status.success() || output.status.code() == Some(1));\n+            output\n+        };\n+        println!(\"{}\", String::from_utf8_lossy(&output.stdout));\n+        eprintln!(\"{}\", String::from_utf8_lossy(&output.stderr));\n+    }\n+\n     fn get_lines<P: AsRef<Path>>(\n         &self,\n         path: &P,\n@@ -3591,7 +3723,7 @@ pub struct ProcRes {\n }\n \n impl ProcRes {\n-    pub fn fatal(&self, err: Option<&str>) -> ! {\n+    pub fn fatal(&self, err: Option<&str>, on_failure: impl FnOnce()) -> ! {\n         if let Some(e) = err {\n             println!(\"\\nerror: {}\", e);\n         }\n@@ -3613,6 +3745,7 @@ impl ProcRes {\n             json::extract_rendered(&self.stdout),\n             json::extract_rendered(&self.stderr),\n         );\n+        on_failure();\n         // Use resume_unwind instead of panic!() to prevent a panic message + backtrace from\n         // compiletest, which is unnecessary noise.\n         std::panic::resume_unwind(Box::new(()));"}]}