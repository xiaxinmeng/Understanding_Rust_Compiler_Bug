{"sha": "11de7ac2fb6514484076217acb8d93eb36468681", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZGU3YWMyZmI2NTE0NDg0MDc2MjE3YWNiOGQ5M2ViMzY0Njg2ODE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-08-12T13:20:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-12T13:20:18Z"}, "message": "Merge #4743\n\n4743: Add tracking of packed repr, use it to highlight unsafe refs r=matklad a=Nashenas88\n\nTaking a reference to a misaligned field on a packed struct is an\r\nunsafe operation. Highlight that behavior. Currently, the misaligned\r\npart isn't tracked, so this highlight is a bit too aggressive.\r\n\r\nFixes #4600\n\nCo-authored-by: Paul Daniel Faria <Nashenas88@users.noreply.github.com>\nCo-authored-by: Paul Daniel Faria <nashenas88@users.noreply.github.com>\nCo-authored-by: Paul Daniel Faria <paulf@pop-os.localdomain>", "tree": {"sha": "b727a8db741367634eebf4dc685e0f56fddb2a68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b727a8db741367634eebf4dc685e0f56fddb2a68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11de7ac2fb6514484076217acb8d93eb36468681", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfM+ySCRBK7hj4Ov3rIwAAdHIIAIRztk07ez4Wqrwts3pghOre\nyMGrEoyPKM4zaJpqxFueZngLHIQtpAJPP055I9eYX8oJypAZUQI8x4Ijn9GLFypP\ngjQGGkqAvv9EJvanHpzRdGKtqwX7P4OlGZJbMg7NeuWO0vHthsRZsPL3ovNNxfkp\n41MxJK3ORjF5H81++5XoauVRKh1z/Fp14tZL/YefgqYgi3ggdA/qqOgnCpQYlp8k\nRIWJ30v7NOnfbGzLj08/Lh1GwPGjc/7Z57oNYcz2nH/25H06C3EcQ4Bopeht4DP1\n1uOoj5ZS0MfyW9sp+4htOiTRWYdEZBuUnprQ1LIXX6HeojmdxYskPMsFpITO+ds=\n=YYa1\n-----END PGP SIGNATURE-----\n", "payload": "tree b727a8db741367634eebf4dc685e0f56fddb2a68\nparent 2d41cc0ea323e3c4d97300e4d66de11d6b7148ef\nparent 72baf1acdd544c645fd69c16967b91be9e75371b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1597238418 +0000\ncommitter GitHub <noreply@github.com> 1597238418 +0000\n\nMerge #4743\n\n4743: Add tracking of packed repr, use it to highlight unsafe refs r=matklad a=Nashenas88\n\nTaking a reference to a misaligned field on a packed struct is an\r\nunsafe operation. Highlight that behavior. Currently, the misaligned\r\npart isn't tracked, so this highlight is a bit too aggressive.\r\n\r\nFixes #4600\n\nCo-authored-by: Paul Daniel Faria <Nashenas88@users.noreply.github.com>\nCo-authored-by: Paul Daniel Faria <nashenas88@users.noreply.github.com>\nCo-authored-by: Paul Daniel Faria <paulf@pop-os.localdomain>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11de7ac2fb6514484076217acb8d93eb36468681", "html_url": "https://github.com/rust-lang/rust/commit/11de7ac2fb6514484076217acb8d93eb36468681", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11de7ac2fb6514484076217acb8d93eb36468681/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d41cc0ea323e3c4d97300e4d66de11d6b7148ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d41cc0ea323e3c4d97300e4d66de11d6b7148ef", "html_url": "https://github.com/rust-lang/rust/commit/2d41cc0ea323e3c4d97300e4d66de11d6b7148ef"}, {"sha": "72baf1acdd544c645fd69c16967b91be9e75371b", "url": "https://api.github.com/repos/rust-lang/rust/commits/72baf1acdd544c645fd69c16967b91be9e75371b", "html_url": "https://github.com/rust-lang/rust/commit/72baf1acdd544c645fd69c16967b91be9e75371b"}], "stats": {"total": 316, "additions": 284, "deletions": 32}, "files": [{"sha": "0007d7fa881a1fdf95a8de92b5d0c7eca4c04d10", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/11de7ac2fb6514484076217acb8d93eb36468681/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11de7ac2fb6514484076217acb8d93eb36468681/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=11de7ac2fb6514484076217acb8d93eb36468681", "patch": "@@ -4,6 +4,7 @@ use std::{iter, sync::Arc};\n use arrayvec::ArrayVec;\n use either::Either;\n use hir_def::{\n+    adt::ReprKind,\n     adt::StructKind,\n     adt::VariantData,\n     builtin_type::BuiltinType,\n@@ -431,6 +432,10 @@ impl Struct {\n         Type::from_def(db, self.id.lookup(db.upcast()).container.module(db.upcast()).krate, self.id)\n     }\n \n+    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprKind> {\n+        db.struct_data(self.id).repr.clone()\n+    }\n+\n     fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n         db.struct_data(self.id).variant_data.clone()\n     }\n@@ -1253,6 +1258,19 @@ impl Type {\n         )\n     }\n \n+    pub fn is_packed(&self, db: &dyn HirDatabase) -> bool {\n+        let adt_id = match self.ty.value {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(adt_id), .. }) => adt_id,\n+            _ => return false,\n+        };\n+\n+        let adt = adt_id.into();\n+        match adt {\n+            Adt::Struct(s) => matches!(s.repr(db), Some(ReprKind::Packed)),\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_raw_ptr(&self) -> bool {\n         matches!(&self.ty.value, Ty::Apply(ApplicationTy { ctor: TypeCtor::RawPtr(..), .. }))\n     }"}, {"sha": "34b02c5365f95ffa258dac6930b720764becfe81", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11de7ac2fb6514484076217acb8d93eb36468681/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11de7ac2fb6514484076217acb8d93eb36468681/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=11de7ac2fb6514484076217acb8d93eb36468681", "patch": "@@ -49,7 +49,7 @@ pub use hir_def::{\n     docs::Documentation,\n     nameres::ModuleSource,\n     path::{ModPath, Path, PathKind},\n-    type_ref::Mutability,\n+    type_ref::{Mutability, TypeRef},\n };\n pub use hir_expand::{\n     hygiene::Hygiene, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc,"}, {"sha": "872f5fa4c79451f86d4bb5f6748af7944a6e3736", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 98, "deletions": 1, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/11de7ac2fb6514484076217acb8d93eb36468681/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11de7ac2fb6514484076217acb8d93eb36468681/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=11de7ac2fb6514484076217acb8d93eb36468681", "patch": "@@ -25,7 +25,8 @@ use crate::{\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, resolve_hir_path_qualifier, SourceAnalyzer},\n     AssocItem, Callable, Crate, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef,\n-    Module, ModuleDef, Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, VariantDef,\n+    Module, ModuleDef, Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, TypeRef,\n+    VariantDef,\n };\n use resolver::TypeNs;\n \n@@ -279,6 +280,18 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn assert_contains_node(&self, node: &SyntaxNode) {\n         self.imp.assert_contains_node(node)\n     }\n+\n+    pub fn is_unsafe_method_call(&self, method_call_expr: ast::MethodCallExpr) -> bool {\n+        self.imp.is_unsafe_method_call(method_call_expr)\n+    }\n+\n+    pub fn is_unsafe_ref_expr(&self, ref_expr: &ast::RefExpr) -> bool {\n+        self.imp.is_unsafe_ref_expr(ref_expr)\n+    }\n+\n+    pub fn is_unsafe_ident_pat(&self, ident_pat: &ast::IdentPat) -> bool {\n+        self.imp.is_unsafe_ident_pat(ident_pat)\n+    }\n }\n \n impl<'db> SemanticsImpl<'db> {\n@@ -574,6 +587,90 @@ impl<'db> SemanticsImpl<'db> {\n         });\n         InFile::new(file_id, node)\n     }\n+\n+    pub fn is_unsafe_method_call(&self, method_call_expr: ast::MethodCallExpr) -> bool {\n+        method_call_expr\n+            .expr()\n+            .and_then(|expr| {\n+                let field_expr = if let ast::Expr::FieldExpr(field_expr) = expr {\n+                    field_expr\n+                } else {\n+                    return None;\n+                };\n+                let ty = self.type_of_expr(&field_expr.expr()?)?;\n+                if !ty.is_packed(self.db) {\n+                    return None;\n+                }\n+\n+                let func = self.resolve_method_call(&method_call_expr).map(Function::from)?;\n+                let is_unsafe = func.has_self_param(self.db)\n+                    && matches!(func.params(self.db).first(), Some(TypeRef::Reference(..)));\n+                Some(is_unsafe)\n+            })\n+            .unwrap_or(false)\n+    }\n+\n+    pub fn is_unsafe_ref_expr(&self, ref_expr: &ast::RefExpr) -> bool {\n+        ref_expr\n+            .expr()\n+            .and_then(|expr| {\n+                let field_expr = match expr {\n+                    ast::Expr::FieldExpr(field_expr) => field_expr,\n+                    _ => return None,\n+                };\n+                let expr = field_expr.expr()?;\n+                self.type_of_expr(&expr)\n+            })\n+            // Binding a reference to a packed type is possibly unsafe.\n+            .map(|ty| ty.is_packed(self.db))\n+            .unwrap_or(false)\n+\n+        // FIXME This needs layout computation to be correct. It will highlight\n+        // more than it should with the current implementation.\n+    }\n+\n+    pub fn is_unsafe_ident_pat(&self, ident_pat: &ast::IdentPat) -> bool {\n+        if !ident_pat.ref_token().is_some() {\n+            return false;\n+        }\n+\n+        ident_pat\n+            .syntax()\n+            .parent()\n+            .and_then(|parent| {\n+                // `IdentPat` can live under `RecordPat` directly under `RecordPatField` or\n+                // `RecordPatFieldList`. `RecordPatField` also lives under `RecordPatFieldList`,\n+                // so this tries to lookup the `IdentPat` anywhere along that structure to the\n+                // `RecordPat` so we can get the containing type.\n+                let record_pat = ast::RecordPatField::cast(parent.clone())\n+                    .and_then(|record_pat| record_pat.syntax().parent())\n+                    .or_else(|| Some(parent.clone()))\n+                    .and_then(|parent| {\n+                        ast::RecordPatFieldList::cast(parent)?\n+                            .syntax()\n+                            .parent()\n+                            .and_then(ast::RecordPat::cast)\n+                    });\n+\n+                // If this doesn't match a `RecordPat`, fallback to a `LetStmt` to see if\n+                // this is initialized from a `FieldExpr`.\n+                if let Some(record_pat) = record_pat {\n+                    self.type_of_pat(&ast::Pat::RecordPat(record_pat))\n+                } else if let Some(let_stmt) = ast::LetStmt::cast(parent) {\n+                    let field_expr = match let_stmt.initializer()? {\n+                        ast::Expr::FieldExpr(field_expr) => field_expr,\n+                        _ => return None,\n+                    };\n+\n+                    self.type_of_expr(&field_expr.expr()?)\n+                } else {\n+                    None\n+                }\n+            })\n+            // Binding a reference to a packed type is possibly unsafe.\n+            .map(|ty| ty.is_packed(self.db))\n+            .unwrap_or(false)\n+    }\n }\n \n pub trait ToDef: AstNode + Clone {"}, {"sha": "35c3a9140257b4c0067722b1255f96cdfa244756", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/11de7ac2fb6514484076217acb8d93eb36468681/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11de7ac2fb6514484076217acb8d93eb36468681/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=11de7ac2fb6514484076217acb8d93eb36468681", "patch": "@@ -9,11 +9,12 @@ use hir_expand::{\n };\n use ra_arena::{map::ArenaMap, Arena};\n use ra_syntax::ast::{self, NameOwner, VisibilityOwner};\n+use tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n \n use crate::{\n     body::{CfgExpander, LowerCtx},\n     db::DefDatabase,\n-    item_tree::{Field, Fields, ItemTree},\n+    item_tree::{AttrOwner, Field, Fields, ItemTree, ModItem},\n     src::HasChildSource,\n     src::HasSource,\n     trace::Trace,\n@@ -29,6 +30,7 @@ use ra_cfg::CfgOptions;\n pub struct StructData {\n     pub name: Name,\n     pub variant_data: Arc<VariantData>,\n+    pub repr: Option<ReprKind>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -58,26 +60,58 @@ pub struct FieldData {\n     pub visibility: RawVisibility,\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ReprKind {\n+    Packed,\n+    Other,\n+}\n+\n+fn repr_from_value(item_tree: &ItemTree, of: AttrOwner) -> Option<ReprKind> {\n+    item_tree.attrs(of).by_key(\"repr\").tt_values().find_map(parse_repr_tt)\n+}\n+\n+fn parse_repr_tt(tt: &Subtree) -> Option<ReprKind> {\n+    match tt.delimiter {\n+        Some(Delimiter { kind: DelimiterKind::Parenthesis, .. }) => {}\n+        _ => return None,\n+    }\n+\n+    let mut it = tt.token_trees.iter();\n+    match it.next()? {\n+        TokenTree::Leaf(Leaf::Ident(ident)) if ident.text == \"packed\" => Some(ReprKind::Packed),\n+        _ => Some(ReprKind::Other),\n+    }\n+}\n+\n impl StructData {\n     pub(crate) fn struct_data_query(db: &dyn DefDatabase, id: StructId) -> Arc<StructData> {\n         let loc = id.lookup(db);\n         let item_tree = db.item_tree(loc.id.file_id);\n+        let repr = repr_from_value(&item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.module(db).krate].cfg_options.clone();\n \n         let strukt = &item_tree[loc.id.value];\n         let variant_data = lower_fields(&item_tree, &cfg_options, &strukt.fields);\n-\n-        Arc::new(StructData { name: strukt.name.clone(), variant_data: Arc::new(variant_data) })\n+        Arc::new(StructData {\n+            name: strukt.name.clone(),\n+            variant_data: Arc::new(variant_data),\n+            repr,\n+        })\n     }\n     pub(crate) fn union_data_query(db: &dyn DefDatabase, id: UnionId) -> Arc<StructData> {\n         let loc = id.lookup(db);\n         let item_tree = db.item_tree(loc.id.file_id);\n+        let repr = repr_from_value(&item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.module(db).krate].cfg_options.clone();\n \n         let union = &item_tree[loc.id.value];\n         let variant_data = lower_fields(&item_tree, &cfg_options, &union.fields);\n \n-        Arc::new(StructData { name: union.name.clone(), variant_data: Arc::new(variant_data) })\n+        Arc::new(StructData {\n+            name: union.name.clone(),\n+            variant_data: Arc::new(variant_data),\n+            repr,\n+        })\n     }\n }\n "}, {"sha": "c10e15db8b6e5fb68ef720a84e15bb75ac83d50e", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 69, "deletions": 20, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/11de7ac2fb6514484076217acb8d93eb36468681/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11de7ac2fb6514484076217acb8d93eb36468681/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=11de7ac2fb6514484076217acb8d93eb36468681", "patch": "@@ -497,9 +497,9 @@ fn highlight_element(\n             match name_kind {\n                 Some(NameClass::ExternCrate(_)) => HighlightTag::Module.into(),\n                 Some(NameClass::Definition(def)) => {\n-                    highlight_name(db, def, false) | HighlightModifier::Definition\n+                    highlight_name(sema, db, def, None, false) | HighlightModifier::Definition\n                 }\n-                Some(NameClass::ConstReference(def)) => highlight_name(db, def, false),\n+                Some(NameClass::ConstReference(def)) => highlight_name(sema, db, def, None, false),\n                 Some(NameClass::FieldShorthand { field, .. }) => {\n                     let mut h = HighlightTag::Field.into();\n                     if let Definition::Field(field) = field {\n@@ -532,7 +532,7 @@ fn highlight_element(\n                                 binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n                             }\n                         };\n-                        highlight_name(db, def, possibly_unsafe)\n+                        highlight_name(sema, db, def, Some(name_ref), possibly_unsafe)\n                     }\n                     NameRefClass::FieldShorthand { .. } => HighlightTag::Field.into(),\n                 },\n@@ -566,9 +566,20 @@ fn highlight_element(\n             }\n         }\n         p if p.is_punct() => match p {\n-            T![::] | T![->] | T![=>] | T![&] | T![..] | T![=] | T![@] => {\n-                HighlightTag::Operator.into()\n+            T![&] => {\n+                let h = HighlightTag::Operator.into();\n+                let is_unsafe = element\n+                    .parent()\n+                    .and_then(ast::RefExpr::cast)\n+                    .map(|ref_expr| sema.is_unsafe_ref_expr(&ref_expr))\n+                    .unwrap_or(false);\n+                if is_unsafe {\n+                    h | HighlightModifier::Unsafe\n+                } else {\n+                    h\n+                }\n             }\n+            T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] => HighlightTag::Operator.into(),\n             T![!] if element.parent().and_then(ast::MacroCall::cast).is_some() => {\n                 HighlightTag::Macro.into()\n             }\n@@ -649,6 +660,18 @@ fn highlight_element(\n                         HighlightTag::SelfKeyword.into()\n                     }\n                 }\n+                T![ref] => element\n+                    .parent()\n+                    .and_then(ast::IdentPat::cast)\n+                    .and_then(|ident_pat| {\n+                        if sema.is_unsafe_ident_pat(&ident_pat) {\n+                            Some(HighlightModifier::Unsafe)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .map(|modifier| h | modifier)\n+                    .unwrap_or(h),\n                 _ => h,\n             }\n         }\n@@ -678,7 +701,13 @@ fn is_child_of_impl(element: &SyntaxElement) -> bool {\n     }\n }\n \n-fn highlight_name(db: &RootDatabase, def: Definition, possibly_unsafe: bool) -> Highlight {\n+fn highlight_name(\n+    sema: &Semantics<RootDatabase>,\n+    db: &RootDatabase,\n+    def: Definition,\n+    name_ref: Option<ast::NameRef>,\n+    possibly_unsafe: bool,\n+) -> Highlight {\n     match def {\n         Definition::Macro(_) => HighlightTag::Macro,\n         Definition::Field(field) => {\n@@ -697,6 +726,15 @@ fn highlight_name(db: &RootDatabase, def: Definition, possibly_unsafe: bool) ->\n                 let mut h = HighlightTag::Function.into();\n                 if func.is_unsafe(db) {\n                     h |= HighlightModifier::Unsafe;\n+                } else {\n+                    let is_unsafe = name_ref\n+                        .and_then(|name_ref| name_ref.syntax().parent())\n+                        .and_then(ast::MethodCallExpr::cast)\n+                        .map(|method_call_expr| sema.is_unsafe_method_call(method_call_expr))\n+                        .unwrap_or(false);\n+                    if is_unsafe {\n+                        h |= HighlightModifier::Unsafe;\n+                    }\n                 }\n                 return h;\n             }\n@@ -768,8 +806,18 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n         _ => return default.into(),\n     };\n \n-    let tag = match parent.kind() {\n-        METHOD_CALL_EXPR => HighlightTag::Function,\n+    match parent.kind() {\n+        METHOD_CALL_EXPR => {\n+            let mut h = Highlight::new(HighlightTag::Function);\n+            let is_unsafe = ast::MethodCallExpr::cast(parent)\n+                .map(|method_call_expr| sema.is_unsafe_method_call(method_call_expr))\n+                .unwrap_or(false);\n+            if is_unsafe {\n+                h |= HighlightModifier::Unsafe;\n+            }\n+\n+            h\n+        }\n         FIELD_EXPR => {\n             let h = HighlightTag::Field;\n             let is_union = ast::FieldExpr::cast(parent)\n@@ -782,7 +830,11 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n                     })\n                 })\n                 .unwrap_or(false);\n-            return if is_union { h | HighlightModifier::Unsafe } else { h.into() };\n+            if is_union {\n+                h | HighlightModifier::Unsafe\n+            } else {\n+                h.into()\n+            }\n         }\n         PATH_SEGMENT => {\n             let path = match parent.parent().and_then(ast::Path::cast) {\n@@ -807,18 +859,15 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n             };\n \n             match parent.kind() {\n-                CALL_EXPR => HighlightTag::Function,\n-                _ => {\n-                    if name.text().chars().next().unwrap_or_default().is_uppercase() {\n-                        HighlightTag::Struct\n-                    } else {\n-                        HighlightTag::Constant\n-                    }\n+                CALL_EXPR => HighlightTag::Function.into(),\n+                _ => if name.text().chars().next().unwrap_or_default().is_uppercase() {\n+                    HighlightTag::Struct.into()\n+                } else {\n+                    HighlightTag::Constant\n                 }\n+                .into(),\n             }\n         }\n-        _ => default,\n-    };\n-\n-    tag.into()\n+        _ => default.into(),\n+    }\n }"}, {"sha": "a8087635a878e3801ef95d0396eadc9d4040be2a", "filename": "crates/ra_ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/11de7ac2fb6514484076217acb8d93eb36468681/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11de7ac2fb6514484076217acb8d93eb36468681/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=11de7ac2fb6514484076217acb8d93eb36468681", "patch": "@@ -292,20 +292,47 @@ struct TypeForStaticMut {\n \n static mut global_mut: TypeForStaticMut = TypeForStaticMut { a: 0 };\n \n+#[repr(packed)]\n+struct Packed {\n+    a: u16,\n+}\n+\n+trait DoTheAutoref {\n+    fn calls_autoref(&self);\n+}\n+\n+impl DoTheAutoref for u16 {\n+    fn calls_autoref(&self) {}\n+}\n+\n fn main() {\n-    let x = &5 as *const usize;\n+    let x = &5 as *const _ as *const usize;\n     let u = Union { b: 0 };\n     unsafe {\n+        // unsafe fn and method calls\n         unsafe_fn();\n         let b = u.b;\n         match u {\n             Union { b: 0 } => (),\n             Union { a } => (),\n         }\n         HasUnsafeFn.unsafe_method();\n-        let y = *(x);\n-        let z = -x;\n+\n+        // unsafe deref\n+        let y = *x;\n+\n+        // unsafe access to a static mut\n         let a = global_mut.a;\n+\n+        // unsafe ref of packed fields\n+        let packed = Packed { a: 0 };\n+        let a = &packed.a;\n+        let ref a = packed.a;\n+        let Packed { ref a } = packed;\n+        let Packed { a: ref _a } = packed;\n+\n+        // unsafe auto ref of packed field\n+        packed.a.calls_autoref();\n     }\n }\n \"#"}, {"sha": "552fea668923f1f9fd9e9a17973d7575885bb90b", "filename": "crates/ra_ide/test_data/highlight_unsafe.html", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/11de7ac2fb6514484076217acb8d93eb36468681/crates%2Fra_ide%2Ftest_data%2Fhighlight_unsafe.html", "raw_url": "https://github.com/rust-lang/rust/raw/11de7ac2fb6514484076217acb8d93eb36468681/crates%2Fra_ide%2Ftest_data%2Fhighlight_unsafe.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Ftest_data%2Fhighlight_unsafe.html?ref=11de7ac2fb6514484076217acb8d93eb36468681", "patch": "@@ -54,19 +54,46 @@\n \n <span class=\"keyword\">static</span> <span class=\"keyword\">mut</span> <span class=\"static declaration mutable unsafe\">global_mut</span><span class=\"punctuation\">:</span> <span class=\"struct\">TypeForStaticMut</span> <span class=\"operator\">=</span> <span class=\"struct\">TypeForStaticMut</span> <span class=\"punctuation\">{</span> <span class=\"field\">a</span><span class=\"punctuation\">:</span> <span class=\"numeric_literal\">0</span> <span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n \n+<span class=\"attribute\">#</span><span class=\"attribute\">[</span><span class=\"function attribute\">repr</span><span class=\"punctuation\">(</span><span class=\"attribute\">packed</span><span class=\"punctuation\">)</span><span class=\"attribute\">]</span>\n+<span class=\"keyword\">struct</span> <span class=\"struct declaration\">Packed</span> <span class=\"punctuation\">{</span>\n+    <span class=\"field declaration\">a</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">u16</span><span class=\"punctuation\">,</span>\n+<span class=\"punctuation\">}</span>\n+\n+<span class=\"keyword\">trait</span> <span class=\"trait declaration\">DoTheAutoref</span> <span class=\"punctuation\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">calls_autoref</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n+<span class=\"punctuation\">}</span>\n+\n+<span class=\"keyword\">impl</span> <span class=\"trait\">DoTheAutoref</span> <span class=\"keyword\">for</span> <span class=\"builtin_type\">u16</span> <span class=\"punctuation\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">calls_autoref</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n+<span class=\"punctuation\">}</span>\n+\n <span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span>\n-    <span class=\"keyword\">let</span> <span class=\"variable declaration\">x</span> <span class=\"operator\">=</span> <span class=\"operator\">&</span><span class=\"numeric_literal\">5</span> <span class=\"keyword\">as</span> <span class=\"keyword\">*</span><span class=\"keyword\">const</span> <span class=\"builtin_type\">usize</span><span class=\"punctuation\">;</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">x</span> <span class=\"operator\">=</span> <span class=\"operator\">&</span><span class=\"numeric_literal\">5</span> <span class=\"keyword\">as</span> <span class=\"keyword\">*</span><span class=\"keyword\">const</span> <span class=\"punctuation\">_</span> <span class=\"keyword\">as</span> <span class=\"keyword\">*</span><span class=\"keyword\">const</span> <span class=\"builtin_type\">usize</span><span class=\"punctuation\">;</span>\n     <span class=\"keyword\">let</span> <span class=\"variable declaration\">u</span> <span class=\"operator\">=</span> <span class=\"union\">Union</span> <span class=\"punctuation\">{</span> <span class=\"field\">b</span><span class=\"punctuation\">:</span> <span class=\"numeric_literal\">0</span> <span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n     <span class=\"keyword unsafe\">unsafe</span> <span class=\"punctuation\">{</span>\n+        <span class=\"comment\">// unsafe fn and method calls</span>\n         <span class=\"function unsafe\">unsafe_fn</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n         <span class=\"keyword\">let</span> <span class=\"variable declaration\">b</span> <span class=\"operator\">=</span> <span class=\"variable\">u</span><span class=\"punctuation\">.</span><span class=\"field unsafe\">b</span><span class=\"punctuation\">;</span>\n         <span class=\"keyword control\">match</span> <span class=\"variable\">u</span> <span class=\"punctuation\">{</span>\n             <span class=\"union\">Union</span> <span class=\"punctuation\">{</span> <span class=\"field unsafe\">b</span><span class=\"punctuation\">:</span> <span class=\"numeric_literal\">0</span> <span class=\"punctuation\">}</span> <span class=\"operator\">=&gt;</span> <span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span>\n             <span class=\"union\">Union</span> <span class=\"punctuation\">{</span> <span class=\"field unsafe\">a</span> <span class=\"punctuation\">}</span> <span class=\"operator\">=&gt;</span> <span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span>\n         <span class=\"punctuation\">}</span>\n         <span class=\"struct\">HasUnsafeFn</span><span class=\"punctuation\">.</span><span class=\"function unsafe\">unsafe_method</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n-        <span class=\"keyword\">let</span> <span class=\"variable declaration\">y</span> <span class=\"operator\">=</span> <span class=\"operator unsafe\">*</span><span class=\"punctuation\">(</span><span class=\"variable\">x</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n-        <span class=\"keyword\">let</span> <span class=\"variable declaration\">z</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">-</span><span class=\"variable\">x</span><span class=\"punctuation\">;</span>\n+\n+        <span class=\"comment\">// unsafe deref</span>\n+        <span class=\"keyword\">let</span> <span class=\"variable declaration\">y</span> <span class=\"operator\">=</span> <span class=\"operator unsafe\">*</span><span class=\"variable\">x</span><span class=\"punctuation\">;</span>\n+\n+        <span class=\"comment\">// unsafe access to a static mut</span>\n         <span class=\"keyword\">let</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"static mutable unsafe\">global_mut</span><span class=\"punctuation\">.</span><span class=\"field\">a</span><span class=\"punctuation\">;</span>\n+\n+        <span class=\"comment\">// unsafe ref of packed fields</span>\n+        <span class=\"keyword\">let</span> <span class=\"variable declaration\">packed</span> <span class=\"operator\">=</span> <span class=\"struct\">Packed</span> <span class=\"punctuation\">{</span> <span class=\"field\">a</span><span class=\"punctuation\">:</span> <span class=\"numeric_literal\">0</span> <span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n+        <span class=\"keyword\">let</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"operator unsafe\">&</span><span class=\"variable\">packed</span><span class=\"punctuation\">.</span><span class=\"field\">a</span><span class=\"punctuation\">;</span>\n+        <span class=\"keyword\">let</span> <span class=\"keyword unsafe\">ref</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"variable\">packed</span><span class=\"punctuation\">.</span><span class=\"field\">a</span><span class=\"punctuation\">;</span>\n+        <span class=\"keyword\">let</span> <span class=\"struct\">Packed</span> <span class=\"punctuation\">{</span> <span class=\"keyword unsafe\">ref</span> <span class=\"field\">a</span> <span class=\"punctuation\">}</span> <span class=\"operator\">=</span> <span class=\"variable\">packed</span><span class=\"punctuation\">;</span>\n+        <span class=\"keyword\">let</span> <span class=\"struct\">Packed</span> <span class=\"punctuation\">{</span> <span class=\"field\">a</span><span class=\"punctuation\">:</span> <span class=\"keyword unsafe\">ref</span> <span class=\"variable declaration\">_a</span> <span class=\"punctuation\">}</span> <span class=\"operator\">=</span> <span class=\"variable\">packed</span><span class=\"punctuation\">;</span>\n+\n+        <span class=\"comment\">// unsafe auto ref of packed field</span>\n+        <span class=\"variable\">packed</span><span class=\"punctuation\">.</span><span class=\"field\">a</span><span class=\"punctuation\">.</span><span class=\"function unsafe\">calls_autoref</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n     <span class=\"punctuation\">}</span>\n <span class=\"punctuation\">}</span></code></pre>\n\\ No newline at end of file"}]}