{"sha": "d1be642ce3c24d1a0517c9bf91af926740618b01", "node_id": "C_kwDOAAsO6NoAKGQxYmU2NDJjZTNjMjRkMWEwNTE3YzliZjkxYWY5MjY3NDA2MThiMDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-08T21:59:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-08T21:59:49Z"}, "message": "Auto merge of #109925 - notriddle:notriddle/item-union, r=GuillaumeGomez\n\nrustdoc: migrate item_union to an Askama template", "tree": {"sha": "62c195ac2163838a6824cde825466833c986b93a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62c195ac2163838a6824cde825466833c986b93a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1be642ce3c24d1a0517c9bf91af926740618b01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1be642ce3c24d1a0517c9bf91af926740618b01", "html_url": "https://github.com/rust-lang/rust/commit/d1be642ce3c24d1a0517c9bf91af926740618b01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1be642ce3c24d1a0517c9bf91af926740618b01/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af06dce64bf87ea9206bdf6cff61c144b9ce8458", "url": "https://api.github.com/repos/rust-lang/rust/commits/af06dce64bf87ea9206bdf6cff61c144b9ce8458", "html_url": "https://github.com/rust-lang/rust/commit/af06dce64bf87ea9206bdf6cff61c144b9ce8458"}, {"sha": "c325fda0bfb32affaeba76c360779585278b8c61", "url": "https://api.github.com/repos/rust-lang/rust/commits/c325fda0bfb32affaeba76c360779585278b8c61", "html_url": "https://github.com/rust-lang/rust/commit/c325fda0bfb32affaeba76c360779585278b8c61"}], "stats": {"total": 1071, "additions": 595, "deletions": 476}, "files": [{"sha": "7a2449cbe9ace94bacecacdc3c7bca88255d729b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1be642ce3c24d1a0517c9bf91af926740618b01/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1be642ce3c24d1a0517c9bf91af926740618b01/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=d1be642ce3c24d1a0517c9bf91af926740618b01", "patch": "@@ -136,10 +136,6 @@ impl Buffer {\n         self.into_inner()\n     }\n \n-    pub(crate) fn is_for_html(&self) -> bool {\n-        self.for_html\n-    }\n-\n     pub(crate) fn reserve(&mut self, additional: usize) {\n         self.buffer.reserve(additional)\n     }"}, {"sha": "1e3cd2668506fa6b4ac49379ef018b59de739029", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 194, "deletions": 164, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/d1be642ce3c24d1a0517c9bf91af926740618b01/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1be642ce3c24d1a0517c9bf91af926740618b01/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=d1be642ce3c24d1a0517c9bf91af926740618b01", "patch": "@@ -50,6 +50,7 @@ use std::string::ToString;\n use askama::Template;\n use rustc_ast_pretty::pprust;\n use rustc_attr::{ConstStability, Deprecation, StabilityLevel};\n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_hir::Mutability;\n@@ -69,7 +70,7 @@ use crate::formats::item_type::ItemType;\n use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n-    href, join_with_double_colon, print_abi_with_space, print_constness_with_space,\n+    display_fn, href, join_with_double_colon, print_abi_with_space, print_constness_with_space,\n     print_default_space, print_generic_bounds, print_where_clause, visibility_print_with_space,\n     Buffer, Ending, HrefError, PrintWithSpace,\n };\n@@ -408,128 +409,134 @@ fn scrape_examples_help(shared: &SharedContext<'_>) -> String {\n     )\n }\n \n-fn document(\n-    w: &mut Buffer,\n-    cx: &mut Context<'_>,\n-    item: &clean::Item,\n-    parent: Option<&clean::Item>,\n+fn document<'a, 'cx: 'a>(\n+    cx: &'a mut Context<'cx>,\n+    item: &'a clean::Item,\n+    parent: Option<&'a clean::Item>,\n     heading_offset: HeadingOffset,\n-) {\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n     if let Some(ref name) = item.name {\n         info!(\"Documenting {}\", name);\n     }\n-    document_item_info(cx, item, parent).render_into(w).unwrap();\n-    if parent.is_none() {\n-        document_full_collapsible(w, item, cx, heading_offset);\n-    } else {\n-        document_full(w, item, cx, heading_offset);\n-    }\n+\n+    display_fn(move |f| {\n+        document_item_info(cx, item, parent).render_into(f).unwrap();\n+        if parent.is_none() {\n+            write!(f, \"{}\", document_full_collapsible(item, cx, heading_offset))?;\n+        } else {\n+            write!(f, \"{}\", document_full(item, cx, heading_offset))?;\n+        }\n+        Ok(())\n+    })\n }\n \n /// Render md_text as markdown.\n-fn render_markdown(\n-    w: &mut Buffer,\n-    cx: &mut Context<'_>,\n-    md_text: &str,\n+fn render_markdown<'a, 'cx: 'a>(\n+    cx: &'a mut Context<'cx>,\n+    md_text: &'a str,\n     links: Vec<RenderedLink>,\n     heading_offset: HeadingOffset,\n-) {\n-    write!(\n-        w,\n-        \"<div class=\\\"docblock\\\">{}</div>\",\n-        Markdown {\n-            content: md_text,\n-            links: &links,\n-            ids: &mut cx.id_map,\n-            error_codes: cx.shared.codes,\n-            edition: cx.shared.edition(),\n-            playground: &cx.shared.playground,\n-            heading_offset,\n-        }\n-        .into_string()\n-    )\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    display_fn(move |f| {\n+        write!(\n+            f,\n+            \"<div class=\\\"docblock\\\">{}</div>\",\n+            Markdown {\n+                content: md_text,\n+                links: &links,\n+                ids: &mut cx.id_map,\n+                error_codes: cx.shared.codes,\n+                edition: cx.shared.edition(),\n+                playground: &cx.shared.playground,\n+                heading_offset,\n+            }\n+            .into_string()\n+        )\n+    })\n }\n \n /// Writes a documentation block containing only the first paragraph of the documentation. If the\n /// docs are longer, a \"Read more\" link is appended to the end.\n-fn document_short(\n-    w: &mut Buffer,\n-    item: &clean::Item,\n-    cx: &mut Context<'_>,\n-    link: AssocItemLink<'_>,\n-    parent: &clean::Item,\n+fn document_short<'a, 'cx: 'a>(\n+    item: &'a clean::Item,\n+    cx: &'a mut Context<'cx>,\n+    link: AssocItemLink<'a>,\n+    parent: &'a clean::Item,\n     show_def_docs: bool,\n-) {\n-    document_item_info(cx, item, Some(parent)).render_into(w).unwrap();\n-    if !show_def_docs {\n-        return;\n-    }\n-    if let Some(s) = item.doc_value() {\n-        let (mut summary_html, has_more_content) =\n-            MarkdownSummaryLine(&s, &item.links(cx)).into_string_with_has_more_content();\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    display_fn(move |f| {\n+        document_item_info(cx, item, Some(parent)).render_into(f).unwrap();\n+        if !show_def_docs {\n+            return Ok(());\n+        }\n+        if let Some(s) = item.doc_value() {\n+            let (mut summary_html, has_more_content) =\n+                MarkdownSummaryLine(&s, &item.links(cx)).into_string_with_has_more_content();\n \n-        if has_more_content {\n-            let link = format!(r#\" <a{}>Read more</a>\"#, assoc_href_attr(item, link, cx));\n+            if has_more_content {\n+                let link = format!(r#\" <a{}>Read more</a>\"#, assoc_href_attr(item, link, cx));\n \n-            if let Some(idx) = summary_html.rfind(\"</p>\") {\n-                summary_html.insert_str(idx, &link);\n-            } else {\n-                summary_html.push_str(&link);\n+                if let Some(idx) = summary_html.rfind(\"</p>\") {\n+                    summary_html.insert_str(idx, &link);\n+                } else {\n+                    summary_html.push_str(&link);\n+                }\n             }\n-        }\n \n-        write!(w, \"<div class='docblock'>{}</div>\", summary_html,);\n-    }\n+            write!(f, \"<div class='docblock'>{}</div>\", summary_html)?;\n+        }\n+        Ok(())\n+    })\n }\n \n-fn document_full_collapsible(\n-    w: &mut Buffer,\n-    item: &clean::Item,\n-    cx: &mut Context<'_>,\n+fn document_full_collapsible<'a, 'cx: 'a>(\n+    item: &'a clean::Item,\n+    cx: &'a mut Context<'cx>,\n     heading_offset: HeadingOffset,\n-) {\n-    document_full_inner(w, item, cx, true, heading_offset);\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    document_full_inner(item, cx, true, heading_offset)\n }\n \n-fn document_full(\n-    w: &mut Buffer,\n-    item: &clean::Item,\n-    cx: &mut Context<'_>,\n+fn document_full<'a, 'cx: 'a>(\n+    item: &'a clean::Item,\n+    cx: &'a mut Context<'cx>,\n     heading_offset: HeadingOffset,\n-) {\n-    document_full_inner(w, item, cx, false, heading_offset);\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    document_full_inner(item, cx, false, heading_offset)\n }\n \n-fn document_full_inner(\n-    w: &mut Buffer,\n-    item: &clean::Item,\n-    cx: &mut Context<'_>,\n+fn document_full_inner<'a, 'cx: 'a>(\n+    item: &'a clean::Item,\n+    cx: &'a mut Context<'cx>,\n     is_collapsible: bool,\n     heading_offset: HeadingOffset,\n-) {\n-    if let Some(s) = item.collapsed_doc_value() {\n-        debug!(\"Doc block: =====\\n{}\\n=====\", s);\n-        if is_collapsible {\n-            w.write_str(\n-                \"<details class=\\\"toggle top-doc\\\" open>\\\n-                <summary class=\\\"hideme\\\">\\\n-                     <span>Expand description</span>\\\n-                </summary>\",\n-            );\n-            render_markdown(w, cx, &s, item.links(cx), heading_offset);\n-            w.write_str(\"</details>\");\n-        } else {\n-            render_markdown(w, cx, &s, item.links(cx), heading_offset);\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    display_fn(move |f| {\n+        if let Some(s) = item.collapsed_doc_value() {\n+            debug!(\"Doc block: =====\\n{}\\n=====\", s);\n+            if is_collapsible {\n+                write!(\n+                    f,\n+                    \"<details class=\\\"toggle top-doc\\\" open>\\\n+                    <summary class=\\\"hideme\\\">\\\n+                        <span>Expand description</span>\\\n+                    </summary>{}</details>\",\n+                    render_markdown(cx, &s, item.links(cx), heading_offset)\n+                )?;\n+            } else {\n+                write!(f, \"{}\", render_markdown(cx, &s, item.links(cx), heading_offset))?;\n+            }\n         }\n-    }\n \n-    let kind = match &*item.kind {\n-        clean::ItemKind::StrippedItem(box kind) | kind => kind,\n-    };\n+        let kind = match &*item.kind {\n+            clean::ItemKind::StrippedItem(box kind) | kind => kind,\n+        };\n \n-    if let clean::ItemKind::FunctionItem(..) | clean::ItemKind::MethodItem(..) = kind {\n-        render_call_locations(w, cx, item);\n-    }\n+        if let clean::ItemKind::FunctionItem(..) | clean::ItemKind::MethodItem(..) = kind {\n+            render_call_locations(f, cx, item);\n+        }\n+        Ok(())\n+    })\n }\n \n #[derive(Template)]\n@@ -653,7 +660,7 @@ fn short_item_info(\n // \"Auto Trait Implementations,\" \"Blanket Trait Implementations\" (on struct/enum pages).\n pub(crate) fn render_impls(\n     cx: &mut Context<'_>,\n-    w: &mut Buffer,\n+    mut w: impl Write,\n     impls: &[&Impl],\n     containing_item: &clean::Item,\n     toggle_open_by_default: bool,\n@@ -665,7 +672,7 @@ pub(crate) fn render_impls(\n             let did = i.trait_did().unwrap();\n             let provided_trait_methods = i.inner_impl().provided_trait_methods(tcx);\n             let assoc_link = AssocItemLink::GotoSource(did.into(), &provided_trait_methods);\n-            let mut buffer = if w.is_for_html() { Buffer::html() } else { Buffer::new() };\n+            let mut buffer = Buffer::new();\n             render_impl(\n                 &mut buffer,\n                 cx,\n@@ -686,7 +693,7 @@ pub(crate) fn render_impls(\n         })\n         .collect::<Vec<_>>();\n     rendered_impls.sort();\n-    w.write_str(&rendered_impls.join(\"\"));\n+    w.write_str(&rendered_impls.join(\"\")).unwrap();\n }\n \n /// Build a (possibly empty) `href` attribute (a key-value pair) for the given associated item.\n@@ -842,7 +849,7 @@ fn assoc_method(\n     let (indent, indent_str, end_newline) = if parent == ItemType::Trait {\n         header_len += 4;\n         let indent_str = \"    \";\n-        render_attributes_in_pre(w, meth, indent_str);\n+        write!(w, \"{}\", render_attributes_in_pre(meth, indent_str));\n         (4, indent_str, Ending::NoNewline)\n     } else {\n         render_attributes_in_code(w, meth);\n@@ -1038,10 +1045,16 @@ fn attributes(it: &clean::Item) -> Vec<String> {\n \n // When an attribute is rendered inside a `<pre>` tag, it is formatted using\n // a whitespace prefix and newline.\n-fn render_attributes_in_pre(w: &mut Buffer, it: &clean::Item, prefix: &str) {\n-    for a in attributes(it) {\n-        writeln!(w, \"{}{}\", prefix, a);\n-    }\n+fn render_attributes_in_pre<'a>(\n+    it: &'a clean::Item,\n+    prefix: &'a str,\n+) -> impl fmt::Display + Captures<'a> {\n+    crate::html::format::display_fn(move |f| {\n+        for a in attributes(it) {\n+            writeln!(f, \"{}{}\", prefix, a)?;\n+        }\n+        Ok(())\n+    })\n }\n \n // When an attribute is rendered inside a <code> tag, it is formatted using\n@@ -1067,61 +1080,68 @@ impl<'a> AssocItemLink<'a> {\n     }\n }\n \n-fn write_impl_section_heading(w: &mut Buffer, title: &str, id: &str) {\n+fn write_impl_section_heading(mut w: impl fmt::Write, title: &str, id: &str) {\n     write!(\n         w,\n         \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n             {title}\\\n             <a href=\\\"#{id}\\\" class=\\\"anchor\\\">\u00a7</a>\\\n          </h2>\"\n-    );\n+    )\n+    .unwrap();\n }\n \n pub(crate) fn render_all_impls(\n-    w: &mut Buffer,\n+    mut w: impl Write,\n     cx: &mut Context<'_>,\n     containing_item: &clean::Item,\n     concrete: &[&Impl],\n     synthetic: &[&Impl],\n     blanket_impl: &[&Impl],\n ) {\n-    let mut impls = Buffer::empty_from(w);\n+    let mut impls = Buffer::html();\n     render_impls(cx, &mut impls, concrete, containing_item, true);\n     let impls = impls.into_inner();\n     if !impls.is_empty() {\n-        write_impl_section_heading(w, \"Trait Implementations\", \"trait-implementations\");\n-        write!(w, \"<div id=\\\"trait-implementations-list\\\">{}</div>\", impls);\n+        write_impl_section_heading(&mut w, \"Trait Implementations\", \"trait-implementations\");\n+        write!(w, \"<div id=\\\"trait-implementations-list\\\">{}</div>\", impls).unwrap();\n     }\n \n     if !synthetic.is_empty() {\n-        write_impl_section_heading(w, \"Auto Trait Implementations\", \"synthetic-implementations\");\n-        w.write_str(\"<div id=\\\"synthetic-implementations-list\\\">\");\n-        render_impls(cx, w, synthetic, containing_item, false);\n-        w.write_str(\"</div>\");\n+        write_impl_section_heading(\n+            &mut w,\n+            \"Auto Trait Implementations\",\n+            \"synthetic-implementations\",\n+        );\n+        w.write_str(\"<div id=\\\"synthetic-implementations-list\\\">\").unwrap();\n+        render_impls(cx, &mut w, synthetic, containing_item, false);\n+        w.write_str(\"</div>\").unwrap();\n     }\n \n     if !blanket_impl.is_empty() {\n-        write_impl_section_heading(w, \"Blanket Implementations\", \"blanket-implementations\");\n-        w.write_str(\"<div id=\\\"blanket-implementations-list\\\">\");\n-        render_impls(cx, w, blanket_impl, containing_item, false);\n-        w.write_str(\"</div>\");\n+        write_impl_section_heading(&mut w, \"Blanket Implementations\", \"blanket-implementations\");\n+        w.write_str(\"<div id=\\\"blanket-implementations-list\\\">\").unwrap();\n+        render_impls(cx, &mut w, blanket_impl, containing_item, false);\n+        w.write_str(\"</div>\").unwrap();\n     }\n }\n \n-fn render_assoc_items(\n-    w: &mut Buffer,\n-    cx: &mut Context<'_>,\n-    containing_item: &clean::Item,\n+fn render_assoc_items<'a, 'cx: 'a>(\n+    cx: &'a mut Context<'cx>,\n+    containing_item: &'a clean::Item,\n     it: DefId,\n-    what: AssocItemRender<'_>,\n-) {\n+    what: AssocItemRender<'a>,\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n     let mut derefs = DefIdSet::default();\n     derefs.insert(it);\n-    render_assoc_items_inner(w, cx, containing_item, it, what, &mut derefs)\n+    display_fn(move |f| {\n+        render_assoc_items_inner(f, cx, containing_item, it, what, &mut derefs);\n+        Ok(())\n+    })\n }\n \n fn render_assoc_items_inner(\n-    w: &mut Buffer,\n+    mut w: &mut dyn fmt::Write,\n     cx: &mut Context<'_>,\n     containing_item: &clean::Item,\n     it: DefId,\n@@ -1134,7 +1154,7 @@ fn render_assoc_items_inner(\n     let Some(v) = cache.impls.get(&it) else { return };\n     let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| i.inner_impl().trait_.is_none());\n     if !non_trait.is_empty() {\n-        let mut tmp_buf = Buffer::empty_from(w);\n+        let mut tmp_buf = Buffer::html();\n         let (render_mode, id) = match what {\n             AssocItemRender::All => {\n                 write_impl_section_heading(&mut tmp_buf, \"Implementations\", \"implementations\");\n@@ -1158,7 +1178,7 @@ fn render_assoc_items_inner(\n                 (RenderMode::ForDeref { mut_: deref_mut_ }, cx.derive_id(id))\n             }\n         };\n-        let mut impls_buf = Buffer::empty_from(w);\n+        let mut impls_buf = Buffer::html();\n         for i in &non_trait {\n             render_impl(\n                 &mut impls_buf,\n@@ -1178,10 +1198,10 @@ fn render_assoc_items_inner(\n             );\n         }\n         if !impls_buf.is_empty() {\n-            w.push_buffer(tmp_buf);\n-            write!(w, \"<div id=\\\"{}\\\">\", id);\n-            w.push_buffer(impls_buf);\n-            w.write_str(\"</div>\");\n+            write!(w, \"{}\", tmp_buf.into_inner()).unwrap();\n+            write!(w, \"<div id=\\\"{}\\\">\", id).unwrap();\n+            write!(w, \"{}\", impls_buf.into_inner()).unwrap();\n+            w.write_str(\"</div>\").unwrap();\n         }\n     }\n \n@@ -1191,7 +1211,7 @@ fn render_assoc_items_inner(\n         if let Some(impl_) = deref_impl {\n             let has_deref_mut =\n                 traits.iter().any(|t| t.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n-            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut, derefs);\n+            render_deref_methods(&mut w, cx, impl_, containing_item, has_deref_mut, derefs);\n         }\n \n         // If we were already one level into rendering deref methods, we don't want to render\n@@ -1210,7 +1230,7 @@ fn render_assoc_items_inner(\n }\n \n fn render_deref_methods(\n-    w: &mut Buffer,\n+    mut w: impl Write,\n     cx: &mut Context<'_>,\n     impl_: &Impl,\n     container_item: &clean::Item,\n@@ -1242,10 +1262,10 @@ fn render_deref_methods(\n                 return;\n             }\n         }\n-        render_assoc_items_inner(w, cx, container_item, did, what, derefs);\n+        render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs);\n     } else if let Some(prim) = target.primitive_type() {\n         if let Some(&did) = cache.primitive_locations.get(&prim) {\n-            render_assoc_items_inner(w, cx, container_item, did, what, derefs);\n+            render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs);\n         }\n     }\n }\n@@ -1478,18 +1498,25 @@ fn render_impl(\n                             document_item_info(cx, it, Some(parent))\n                                 .render_into(&mut info_buffer)\n                                 .unwrap();\n-                            document_full(&mut doc_buffer, item, cx, HeadingOffset::H5);\n+                            write!(\n+                                &mut doc_buffer,\n+                                \"{}\",\n+                                document_full(item, cx, HeadingOffset::H5)\n+                            );\n                             short_documented = false;\n                         } else {\n                             // In case the item isn't documented,\n                             // provide short documentation from the trait.\n-                            document_short(\n+                            write!(\n                                 &mut doc_buffer,\n-                                it,\n-                                cx,\n-                                link,\n-                                parent,\n-                                rendering_params.show_def_docs,\n+                                \"{}\",\n+                                document_short(\n+                                    it,\n+                                    cx,\n+                                    link,\n+                                    parent,\n+                                    rendering_params.show_def_docs,\n+                                )\n                             );\n                         }\n                     }\n@@ -1498,18 +1525,15 @@ fn render_impl(\n                         .render_into(&mut info_buffer)\n                         .unwrap();\n                     if rendering_params.show_def_docs {\n-                        document_full(&mut doc_buffer, item, cx, HeadingOffset::H5);\n+                        write!(&mut doc_buffer, \"{}\", document_full(item, cx, HeadingOffset::H5));\n                         short_documented = false;\n                     }\n                 }\n             } else {\n-                document_short(\n+                write!(\n                     &mut doc_buffer,\n-                    item,\n-                    cx,\n-                    link,\n-                    parent,\n-                    rendering_params.show_def_docs,\n+                    \"{}\",\n+                    document_short(item, cx, link, parent, rendering_params.show_def_docs,)\n                 );\n             }\n         }\n@@ -2206,7 +2230,7 @@ const MAX_FULL_EXAMPLES: usize = 5;\n const NUM_VISIBLE_LINES: usize = 10;\n \n /// Generates the HTML for example call locations generated via the --scrape-examples flag.\n-fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item) {\n+fn render_call_locations<W: fmt::Write>(mut w: W, cx: &mut Context<'_>, item: &clean::Item) {\n     let tcx = cx.tcx();\n     let def_id = item.item_id.expect_def_id();\n     let key = tcx.def_path_hash(def_id);\n@@ -2215,7 +2239,7 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n     // Generate a unique ID so users can link to this section for a given method\n     let id = cx.id_map.derive(\"scraped-examples\");\n     write!(\n-        w,\n+        &mut w,\n         \"<div class=\\\"docblock scraped-example-list\\\">\\\n           <span></span>\\\n           <h5 id=\\\"{id}\\\">\\\n@@ -2224,7 +2248,8 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n           </h5>\",\n         root_path = cx.root_path(),\n         id = id\n-    );\n+    )\n+    .unwrap();\n \n     // Create a URL to a particular location in a reverse-dependency's source file\n     let link_to_loc = |call_data: &CallData, loc: &CallLocation| -> (String, String) {\n@@ -2242,7 +2267,7 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n     };\n \n     // Generate the HTML for a single example, being the title and code block\n-    let write_example = |w: &mut Buffer, (path, call_data): (&PathBuf, &CallData)| -> bool {\n+    let write_example = |mut w: &mut W, (path, call_data): (&PathBuf, &CallData)| -> bool {\n         let contents = match fs::read_to_string(&path) {\n             Ok(contents) => contents,\n             Err(err) => {\n@@ -2290,7 +2315,7 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n         let locations_encoded = serde_json::to_string(&line_ranges).unwrap();\n \n         write!(\n-            w,\n+            &mut w,\n             \"<div class=\\\"scraped-example {expanded_cls}\\\" data-locs=\\\"{locations}\\\">\\\n                 <div class=\\\"scraped-example-title\\\">\\\n                    {name} (<a href=\\\"{url}\\\">{title}</a>)\\\n@@ -2303,10 +2328,12 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n             // The locations are encoded as a data attribute, so they can be read\n             // later by the JS for interactions.\n             locations = Escape(&locations_encoded)\n-        );\n+        )\n+        .unwrap();\n \n         if line_ranges.len() > 1 {\n-            write!(w, r#\"<button class=\"prev\">&pr;</button> <button class=\"next\">&sc;</button>\"#);\n+            write!(w, r#\"<button class=\"prev\">&pr;</button> <button class=\"next\">&sc;</button>\"#)\n+                .unwrap();\n         }\n \n         // Look for the example file in the source map if it exists, otherwise return a dummy span\n@@ -2333,15 +2360,15 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n         decoration_info.insert(\"highlight\", byte_ranges);\n \n         sources::print_src(\n-            w,\n+            &mut w,\n             contents_subset,\n             file_span,\n             cx,\n             &cx.root_path(),\n             highlight::DecorationInfo(decoration_info),\n             sources::SourceContext::Embedded { offset: line_min, needs_expansion },\n         );\n-        write!(w, \"</div></div>\");\n+        write!(w, \"</div></div>\").unwrap();\n \n         true\n     };\n@@ -2375,7 +2402,7 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n \n     // An example may fail to write if its source can't be read for some reason, so this method\n     // continues iterating until a write succeeds\n-    let write_and_skip_failure = |w: &mut Buffer, it: &mut Peekable<_>| {\n+    let write_and_skip_failure = |w: &mut W, it: &mut Peekable<_>| {\n         while let Some(example) = it.next() {\n             if write_example(&mut *w, example) {\n                 break;\n@@ -2384,7 +2411,7 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n     };\n \n     // Write just one example that's visible by default in the method's description.\n-    write_and_skip_failure(w, &mut it);\n+    write_and_skip_failure(&mut w, &mut it);\n \n     // Then add the remaining examples in a hidden section.\n     if it.peek().is_some() {\n@@ -2397,31 +2424,34 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n                   <div class=\\\"hide-more\\\">Hide additional examples</div>\\\n                   <div class=\\\"more-scraped-examples\\\">\\\n                     <div class=\\\"toggle-line\\\"><div class=\\\"toggle-line-inner\\\"></div></div>\"\n-        );\n+        )\n+        .unwrap();\n \n         // Only generate inline code for MAX_FULL_EXAMPLES number of examples. Otherwise we could\n         // make the page arbitrarily huge!\n         for _ in 0..MAX_FULL_EXAMPLES {\n-            write_and_skip_failure(w, &mut it);\n+            write_and_skip_failure(&mut w, &mut it);\n         }\n \n         // For the remaining examples, generate a <ul> containing links to the source files.\n         if it.peek().is_some() {\n-            write!(w, r#\"<div class=\"example-links\">Additional examples can be found in:<br><ul>\"#);\n+            write!(w, r#\"<div class=\"example-links\">Additional examples can be found in:<br><ul>\"#)\n+                .unwrap();\n             it.for_each(|(_, call_data)| {\n                 let (url, _) = link_to_loc(call_data, &call_data.locations[0]);\n                 write!(\n                     w,\n                     r#\"<li><a href=\"{url}\">{name}</a></li>\"#,\n                     url = url,\n                     name = call_data.display_name\n-                );\n+                )\n+                .unwrap();\n             });\n-            write!(w, \"</ul></div>\");\n+            write!(w, \"</ul></div>\").unwrap();\n         }\n \n-        write!(w, \"</div></details>\");\n+        write!(w, \"</div></details>\").unwrap();\n     }\n \n-    write!(w, \"</div>\");\n+    write!(w, \"</div>\").unwrap();\n }"}, {"sha": "6bce57340040bfe355beaead3081780116a2596c", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 375, "deletions": 305, "changes": 680, "blob_url": "https://github.com/rust-lang/rust/blob/d1be642ce3c24d1a0517c9bf91af926740618b01/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1be642ce3c24d1a0517c9bf91af926740618b01/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=d1be642ce3c24d1a0517c9bf91af926740618b01", "patch": "@@ -202,23 +202,24 @@ fn should_hide_fields(n_fields: usize) -> bool {\n     n_fields > 12\n }\n \n-fn toggle_open(w: &mut Buffer, text: impl fmt::Display) {\n+fn toggle_open(mut w: impl fmt::Write, text: impl fmt::Display) {\n     write!(\n         w,\n         \"<details class=\\\"toggle type-contents-toggle\\\">\\\n             <summary class=\\\"hideme\\\">\\\n                 <span>Show {}</span>\\\n             </summary>\",\n         text\n-    );\n+    )\n+    .unwrap();\n }\n \n-fn toggle_close(w: &mut Buffer) {\n-    w.write_str(\"</details>\");\n+fn toggle_close(mut w: impl fmt::Write) {\n+    w.write_str(\"</details>\").unwrap();\n }\n \n fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items: &[clean::Item]) {\n-    document(w, cx, item, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, item, None, HeadingOffset::H2));\n \n     let mut indices = (0..items.len()).filter(|i| !items[*i].is_stripped()).collect::<Vec<usize>>();\n \n@@ -544,12 +545,12 @@ fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &cle\n         f.decl.output.as_return().and_then(|output| notable_traits_button(output, cx));\n \n     wrap_item(w, |w| {\n-        render_attributes_in_pre(w, it, \"\");\n         w.reserve(header_len);\n         write!(\n             w,\n-            \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n+            \"{attrs}{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n                 {name}{generics}{decl}{notable_traits}{where_clause}\",\n+            attrs = render_attributes_in_pre(it, \"\"),\n             vis = visibility,\n             constness = constness,\n             asyncness = asyncness,\n@@ -562,7 +563,7 @@ fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &cle\n             notable_traits = notable_traits.unwrap_or_default(),\n         );\n     });\n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n }\n \n fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Trait) {\n@@ -580,17 +581,17 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     let must_implement_one_of_functions = tcx.trait_def(t.def_id).must_implement_one_of.clone();\n \n     // Output the trait definition\n-    wrap_item(w, |w| {\n-        render_attributes_in_pre(w, it, \"\");\n+    wrap_item(w, |mut w| {\n         write!(\n             w,\n-            \"{}{}{}trait {}{}{}\",\n+            \"{attrs}{}{}{}trait {}{}{}\",\n             visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n             t.unsafety(tcx).print_with_space(),\n             if t.is_auto(tcx) { \"auto \" } else { \"\" },\n             it.name.unwrap(),\n             t.generics.print(cx),\n-            bounds\n+            bounds,\n+            attrs = render_attributes_in_pre(it, \"\"),\n         );\n \n         if !t.generics.where_predicates.is_empty() {\n@@ -610,7 +611,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             if should_hide_fields(count_types) {\n                 toggle = true;\n                 toggle_open(\n-                    w,\n+                    &mut w,\n                     format_args!(\"{} associated items\", count_types + count_consts + count_methods),\n                 );\n             }\n@@ -634,7 +635,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             if !toggle && should_hide_fields(count_types + count_consts) {\n                 toggle = true;\n                 toggle_open(\n-                    w,\n+                    &mut w,\n                     format_args!(\n                         \"{} associated constant{} and {} method{}\",\n                         count_consts,\n@@ -662,7 +663,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             }\n             if !toggle && should_hide_fields(count_methods) {\n                 toggle = true;\n-                toggle_open(w, format_args!(\"{} methods\", count_methods));\n+                toggle_open(&mut w, format_args!(\"{} methods\", count_methods));\n             }\n             if count_consts != 0 && count_methods != 0 {\n                 w.write_str(\"\\n\");\n@@ -710,14 +711,14 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n                 }\n             }\n             if toggle {\n-                toggle_close(w);\n+                toggle_close(&mut w);\n             }\n             w.write_str(\"}\");\n         }\n     });\n \n     // Trait documentation\n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     fn write_small_section_header(w: &mut Buffer, id: &str, title: &str, extra_content: &str) {\n         write!(\n@@ -735,7 +736,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         let item_type = m.type_();\n         let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n         let mut content = Buffer::empty_from(w);\n-        document(&mut content, cx, m, Some(t), HeadingOffset::H5);\n+        write!(&mut content, \"{}\", document(cx, m, Some(t), HeadingOffset::H5));\n         let toggled = !content.is_empty();\n         if toggled {\n             let method_toggle_class = if item_type.is_method() { \" method-toggle\" } else { \"\" };\n@@ -847,7 +848,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All);\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All));\n \n     let cloned_shared = Rc::clone(&cx.shared);\n     let cache = &cloned_shared.cache;\n@@ -1057,147 +1058,201 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n \n fn item_trait_alias(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::TraitAlias) {\n     wrap_item(w, |w| {\n-        render_attributes_in_pre(w, it, \"\");\n         write!(\n             w,\n-            \"trait {}{}{} = {};\",\n+            \"{attrs}trait {}{}{} = {};\",\n             it.name.unwrap(),\n             t.generics.print(cx),\n             print_where_clause(&t.generics, cx, 0, Ending::Newline),\n-            bounds(&t.bounds, true, cx)\n+            bounds(&t.bounds, true, cx),\n+            attrs = render_attributes_in_pre(it, \"\"),\n         );\n     });\n \n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n }\n \n fn item_opaque_ty(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n     wrap_item(w, |w| {\n-        render_attributes_in_pre(w, it, \"\");\n         write!(\n             w,\n-            \"type {}{}{where_clause} = impl {bounds};\",\n+            \"{attrs}type {}{}{where_clause} = impl {bounds};\",\n             it.name.unwrap(),\n             t.generics.print(cx),\n             where_clause = print_where_clause(&t.generics, cx, 0, Ending::Newline),\n             bounds = bounds(&t.bounds, false, cx),\n+            attrs = render_attributes_in_pre(it, \"\"),\n         );\n     });\n \n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n }\n \n fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n     fn write_content(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n         wrap_item(w, |w| {\n-            render_attributes_in_pre(w, it, \"\");\n             write!(\n                 w,\n-                \"{}type {}{}{where_clause} = {type_};\",\n+                \"{attrs}{}type {}{}{where_clause} = {type_};\",\n                 visibility_print_with_space(it.visibility(cx.tcx()), it.item_id, cx),\n                 it.name.unwrap(),\n                 t.generics.print(cx),\n                 where_clause = print_where_clause(&t.generics, cx, 0, Ending::Newline),\n                 type_ = t.type_.print(cx),\n+                attrs = render_attributes_in_pre(it, \"\"),\n             );\n         });\n     }\n \n     write_content(w, cx, it, t);\n \n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     let def_id = it.item_id.expect_def_id();\n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n-    document_type_layout(w, cx, def_id);\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n fn item_union(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean::Union) {\n-    wrap_item(w, |w| {\n-        render_attributes_in_pre(w, it, \"\");\n-        render_union(w, it, Some(&s.generics), &s.fields, cx);\n-    });\n+    #[derive(Template)]\n+    #[template(path = \"item_union.html\")]\n+    struct ItemUnion<'a, 'cx> {\n+        cx: std::cell::RefCell<&'a mut Context<'cx>>,\n+        it: &'a clean::Item,\n+        s: &'a clean::Union,\n+    }\n \n-    document(w, cx, it, None, HeadingOffset::H2);\n+    impl<'a, 'cx: 'a> ItemUnion<'a, 'cx> {\n+        fn render_assoc_items<'b>(\n+            &'b self,\n+        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+            display_fn(move |f| {\n+                let def_id = self.it.item_id.expect_def_id();\n+                let mut cx = self.cx.borrow_mut();\n+                let v = render_assoc_items(*cx, self.it, def_id, AssocItemRender::All);\n+                write!(f, \"{v}\")\n+            })\n+        }\n+        fn document_type_layout<'b>(\n+            &'b self,\n+        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+            display_fn(move |f| {\n+                let def_id = self.it.item_id.expect_def_id();\n+                let cx = self.cx.borrow_mut();\n+                let v = document_type_layout(*cx, def_id);\n+                write!(f, \"{v}\")\n+            })\n+        }\n+        fn render_union<'b>(&'b self) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+            display_fn(move |f| {\n+                let cx = self.cx.borrow_mut();\n+                let v = render_union(self.it, Some(&self.s.generics), &self.s.fields, *cx);\n+                write!(f, \"{v}\")\n+            })\n+        }\n+        fn render_attributes_in_pre<'b>(\n+            &'b self,\n+        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+            display_fn(move |f| {\n+                let v = render_attributes_in_pre(self.it, \"\");\n+                write!(f, \"{v}\")\n+            })\n+        }\n+        fn document<'b>(&'b self) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+            display_fn(move |f| {\n+                let mut cx = self.cx.borrow_mut();\n+                let v = document(*cx, self.it, None, HeadingOffset::H2);\n+                write!(f, \"{v}\")\n+            })\n+        }\n+        fn document_field<'b>(\n+            &'b self,\n+            field: &'a clean::Item,\n+        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+            display_fn(move |f| {\n+                let mut cx = self.cx.borrow_mut();\n+                let v = document(*cx, field, Some(self.it), HeadingOffset::H3);\n+                write!(f, \"{v}\")\n+            })\n+        }\n+        fn stability_field(&self, field: &clean::Item) -> Option<String> {\n+            let cx = self.cx.borrow();\n+            field.stability_class(cx.tcx())\n+        }\n+        fn print_ty<'b>(\n+            &'b self,\n+            ty: &'a clean::Type,\n+        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+            display_fn(move |f| {\n+                let cx = self.cx.borrow();\n+                let v = ty.print(*cx);\n+                write!(f, \"{v}\")\n+            })\n+        }\n \n-    let mut fields = s\n-        .fields\n-        .iter()\n-        .filter_map(|f| match *f.kind {\n-            clean::StructFieldItem(ref ty) => Some((f, ty)),\n-            _ => None,\n-        })\n-        .peekable();\n-    if fields.peek().is_some() {\n-        write!(\n-            w,\n-            \"<h2 id=\\\"fields\\\" class=\\\"fields small-section-header\\\">\\\n-                Fields<a href=\\\"#fields\\\" class=\\\"anchor\\\">\u00a7</a>\\\n-            </h2>\"\n-        );\n-        for (field, ty) in fields {\n-            let name = field.name.expect(\"union field name\");\n-            let id = format!(\"{}.{}\", ItemType::StructField, name);\n-            write!(\n-                w,\n-                \"<span id=\\\"{id}\\\" class=\\\"{shortty} small-section-header\\\">\\\n-                     <a href=\\\"#{id}\\\" class=\\\"anchor field\\\">\u00a7</a>\\\n-                     <code>{name}: {ty}</code>\\\n-                 </span>\",\n-                shortty = ItemType::StructField,\n-                ty = ty.print(cx),\n-            );\n-            if let Some(stability_class) = field.stability_class(cx.tcx()) {\n-                write!(w, \"<span class=\\\"stab {stability_class}\\\"></span>\");\n-            }\n-            document(w, cx, field, Some(it), HeadingOffset::H3);\n+        fn fields_iter(\n+            &self,\n+        ) -> std::iter::Peekable<impl Iterator<Item = (&'a clean::Item, &'a clean::Type)>> {\n+            self.s\n+                .fields\n+                .iter()\n+                .filter_map(|f| match *f.kind {\n+                    clean::StructFieldItem(ref ty) => Some((f, ty)),\n+                    _ => None,\n+                })\n+                .peekable()\n         }\n     }\n-    let def_id = it.item_id.expect_def_id();\n-    render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n-    document_type_layout(w, cx, def_id);\n+\n+    ItemUnion { cx: std::cell::RefCell::new(cx), it, s }.render_into(w).unwrap();\n }\n \n-fn print_tuple_struct_fields(w: &mut Buffer, cx: &Context<'_>, s: &[clean::Item]) {\n-    for (i, ty) in s.iter().enumerate() {\n-        if i > 0 {\n-            w.write_str(\", \");\n-        }\n-        match *ty.kind {\n-            clean::StrippedItem(box clean::StructFieldItem(_)) => w.write_str(\"_\"),\n-            clean::StructFieldItem(ref ty) => write!(w, \"{}\", ty.print(cx)),\n-            _ => unreachable!(),\n+fn print_tuple_struct_fields<'a, 'cx: 'a>(\n+    cx: &'a Context<'cx>,\n+    s: &'a [clean::Item],\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    display_fn(|f| {\n+        for (i, ty) in s.iter().enumerate() {\n+            if i > 0 {\n+                f.write_str(\", \")?;\n+            }\n+            match *ty.kind {\n+                clean::StrippedItem(box clean::StructFieldItem(_)) => f.write_str(\"_\")?,\n+                clean::StructFieldItem(ref ty) => write!(f, \"{}\", ty.print(cx))?,\n+                _ => unreachable!(),\n+            }\n         }\n-    }\n+        Ok(())\n+    })\n }\n \n fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::Enum) {\n     let tcx = cx.tcx();\n     let count_variants = e.variants().count();\n-    wrap_item(w, |w| {\n-        render_attributes_in_pre(w, it, \"\");\n+    wrap_item(w, |mut w| {\n         write!(\n             w,\n-            \"{}enum {}{}\",\n+            \"{attrs}{}enum {}{}\",\n             visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n             it.name.unwrap(),\n             e.generics.print(cx),\n+            attrs = render_attributes_in_pre(it, \"\"),\n         );\n         if !print_where_clause_and_check(w, &e.generics, cx) {\n             // If there wasn't a `where` clause, we add a whitespace.\n@@ -1211,7 +1266,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n             w.write_str(\"{\\n\");\n             let toggle = should_hide_fields(count_variants);\n             if toggle {\n-                toggle_open(w, format_args!(\"{} variants\", count_variants));\n+                toggle_open(&mut w, format_args!(\"{} variants\", count_variants));\n             }\n             for v in e.variants() {\n                 w.write_str(\"    \");\n@@ -1221,9 +1276,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n                     clean::VariantItem(ref var) => match var.kind {\n                         clean::VariantKind::CLike => write!(w, \"{}\", name),\n                         clean::VariantKind::Tuple(ref s) => {\n-                            write!(w, \"{}(\", name);\n-                            print_tuple_struct_fields(w, cx, s);\n-                            w.write_str(\")\");\n+                            write!(w, \"{name}({})\", print_tuple_struct_fields(cx, s),);\n                         }\n                         clean::VariantKind::Struct(ref s) => {\n                             render_struct(w, v, None, None, &s.fields, \"    \", false, cx);\n@@ -1238,24 +1291,25 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n                 w.write_str(\"    // some variants omitted\\n\");\n             }\n             if toggle {\n-                toggle_close(w);\n+                toggle_close(&mut w);\n             }\n             w.write_str(\"}\");\n         }\n     });\n \n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     if count_variants != 0 {\n         write!(\n             w,\n             \"<h2 id=\\\"variants\\\" class=\\\"variants small-section-header\\\">\\\n                 Variants{}<a href=\\\"#variants\\\" class=\\\"anchor\\\">\u00a7</a>\\\n-            </h2>\",\n-            document_non_exhaustive_header(it)\n+            </h2>\\\n+            {}\\\n+            <div class=\\\"variants\\\">\",\n+            document_non_exhaustive_header(it),\n+            document_non_exhaustive(it)\n         );\n-        document_non_exhaustive(w, it);\n-        write!(w, \"<div class=\\\"variants\\\">\");\n         for variant in e.variants() {\n             let id = cx.derive_id(format!(\"{}.{}\", ItemType::Variant, variant.name.unwrap()));\n             write!(\n@@ -1276,9 +1330,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n             let clean::VariantItem(variant_data) = &*variant.kind else { unreachable!() };\n \n             if let clean::VariantKind::Tuple(ref s) = variant_data.kind {\n-                w.write_str(\"(\");\n-                print_tuple_struct_fields(w, cx, s);\n-                w.write_str(\")\");\n+                write!(w, \"({})\", print_tuple_struct_fields(cx, s),);\n             }\n             w.write_str(\"</h3></section>\");\n \n@@ -1302,9 +1354,10 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n                 write!(\n                     w,\n                     \"<div class=\\\"sub-variant\\\" id=\\\"{variant_id}\\\">\\\n-                        <h4>{heading}</h4>\",\n+                        <h4>{heading}</h4>\\\n+                        {}\",\n+                    document_non_exhaustive(variant)\n                 );\n-                document_non_exhaustive(w, variant);\n                 for field in fields {\n                     match *field.kind {\n                         clean::StrippedItem(box clean::StructFieldItem(_)) => {}\n@@ -1322,29 +1375,32 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n                                      <code>{f}: {t}</code>\\\n                                  </span>\",\n                                 f = field.name.unwrap(),\n-                                t = ty.print(cx)\n+                                t = ty.print(cx),\n+                            );\n+                            write!(\n+                                w,\n+                                \"{}</div>\",\n+                                document(cx, field, Some(variant), HeadingOffset::H5)\n                             );\n-                            document(w, cx, field, Some(variant), HeadingOffset::H5);\n-                            write!(w, \"</div>\");\n                         }\n                         _ => unreachable!(),\n                     }\n                 }\n                 w.write_str(\"</div>\");\n             }\n \n-            document(w, cx, variant, Some(it), HeadingOffset::H4);\n+            write!(w, \"{}\", document(cx, variant, Some(it), HeadingOffset::H4));\n         }\n         write!(w, \"</div>\");\n     }\n     let def_id = it.item_id.expect_def_id();\n-    render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n-    document_type_layout(w, cx, def_id);\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n fn item_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Macro) {\n     highlight::render_item_decl_with_highlighting(&t.source, w);\n-    document(w, cx, it, None, HeadingOffset::H2)\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n }\n \n fn item_proc_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, m: &clean::ProcMacro) {\n@@ -1370,14 +1426,14 @@ fn item_proc_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, m: &c\n             }\n         }\n     });\n-    document(w, cx, it, None, HeadingOffset::H2)\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n }\n \n fn item_primitive(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n     let def_id = it.item_id.expect_def_id();\n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n     if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n-        render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n+        write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n     } else {\n         // We handle the \"reference\" primitive type on its own because we only want to list\n         // implementations on generic types.\n@@ -1433,7 +1489,7 @@ fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &cle\n         }\n     });\n \n-    document(w, cx, it, None, HeadingOffset::H2)\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n }\n \n fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean::Struct) {\n@@ -1442,7 +1498,7 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n         render_struct(w, it, Some(&s.generics), s.ctor_kind, &s.fields, \"\", true, cx);\n     });\n \n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     let mut fields = s\n         .fields\n@@ -1458,11 +1514,12 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n                 w,\n                 \"<h2 id=\\\"fields\\\" class=\\\"fields small-section-header\\\">\\\n                      {}{}<a href=\\\"#fields\\\" class=\\\"anchor\\\">\u00a7</a>\\\n-                 </h2>\",\n+                 </h2>\\\n+                 {}\",\n                 if s.ctor_kind.is_none() { \"Fields\" } else { \"Tuple Fields\" },\n-                document_non_exhaustive_header(it)\n+                document_non_exhaustive_header(it),\n+                document_non_exhaustive(it)\n             );\n-            document_non_exhaustive(w, it);\n             for (index, (field, ty)) in fields.enumerate() {\n                 let field_name =\n                     field.name.map_or_else(|| index.to_string(), |sym| sym.as_str().to_string());\n@@ -1476,13 +1533,13 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n                     item_type = ItemType::StructField,\n                     ty = ty.print(cx)\n                 );\n-                document(w, cx, field, Some(it), HeadingOffset::H3);\n+                write!(w, \"{}\", document(cx, field, Some(it), HeadingOffset::H3));\n             }\n         }\n     }\n     let def_id = it.item_id.expect_def_id();\n-    render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n-    document_type_layout(w, cx, def_id);\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n fn item_static(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean::Static) {\n@@ -1497,7 +1554,7 @@ fn item_static(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n             typ = s.type_.print(cx)\n         );\n     });\n-    document(w, cx, it, None, HeadingOffset::H2)\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n }\n \n fn item_foreign_type(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n@@ -1512,13 +1569,13 @@ fn item_foreign_type(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n         );\n     });\n \n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n-    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n }\n \n fn item_keyword(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n-    document(w, cx, it, None, HeadingOffset::H2)\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n }\n \n /// Compare two strings treating multi-digit numbers as single units (i.e. natural sort order).\n@@ -1655,64 +1712,69 @@ fn render_implementor(\n     );\n }\n \n-fn render_union(\n-    w: &mut Buffer,\n-    it: &clean::Item,\n-    g: Option<&clean::Generics>,\n-    fields: &[clean::Item],\n-    cx: &Context<'_>,\n-) {\n-    let tcx = cx.tcx();\n-    write!(\n-        w,\n-        \"{}union {}\",\n-        visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n-        it.name.unwrap(),\n-    );\n-\n-    let where_displayed = g\n-        .map(|g| {\n-            write!(w, \"{}\", g.print(cx));\n-            print_where_clause_and_check(w, g, cx)\n-        })\n-        .unwrap_or(false);\n+fn render_union<'a, 'cx: 'a>(\n+    it: &'a clean::Item,\n+    g: Option<&'a clean::Generics>,\n+    fields: &'a [clean::Item],\n+    cx: &'a Context<'cx>,\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    display_fn(move |mut f| {\n+        let tcx = cx.tcx();\n+        write!(\n+            f,\n+            \"{}union {}\",\n+            visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n+            it.name.unwrap(),\n+        )?;\n+\n+        let where_displayed = g\n+            .map(|g| {\n+                let mut buf = Buffer::html();\n+                write!(buf, \"{}\", g.print(cx));\n+                let where_displayed = print_where_clause_and_check(&mut buf, g, cx);\n+                write!(f, \"{buf}\", buf = buf.into_inner()).unwrap();\n+                where_displayed\n+            })\n+            .unwrap_or(false);\n \n-    // If there wasn't a `where` clause, we add a whitespace.\n-    if !where_displayed {\n-        w.write_str(\" \");\n-    }\n+        // If there wasn't a `where` clause, we add a whitespace.\n+        if !where_displayed {\n+            f.write_str(\" \")?;\n+        }\n \n-    write!(w, \"{{\\n\");\n-    let count_fields =\n-        fields.iter().filter(|f| matches!(*f.kind, clean::StructFieldItem(..))).count();\n-    let toggle = should_hide_fields(count_fields);\n-    if toggle {\n-        toggle_open(w, format_args!(\"{} fields\", count_fields));\n-    }\n+        write!(f, \"{{\\n\")?;\n+        let count_fields =\n+            fields.iter().filter(|field| matches!(*field.kind, clean::StructFieldItem(..))).count();\n+        let toggle = should_hide_fields(count_fields);\n+        if toggle {\n+            toggle_open(&mut f, format_args!(\"{} fields\", count_fields));\n+        }\n \n-    for field in fields {\n-        if let clean::StructFieldItem(ref ty) = *field.kind {\n-            write!(\n-                w,\n-                \"    {}{}: {},\\n\",\n-                visibility_print_with_space(field.visibility(tcx), field.item_id, cx),\n-                field.name.unwrap(),\n-                ty.print(cx)\n-            );\n+        for field in fields {\n+            if let clean::StructFieldItem(ref ty) = *field.kind {\n+                write!(\n+                    f,\n+                    \"    {}{}: {},\\n\",\n+                    visibility_print_with_space(field.visibility(tcx), field.item_id, cx),\n+                    field.name.unwrap(),\n+                    ty.print(cx)\n+                )?;\n+            }\n         }\n-    }\n \n-    if it.has_stripped_entries().unwrap() {\n-        write!(w, \"    /* private fields */\\n\");\n-    }\n-    if toggle {\n-        toggle_close(w);\n-    }\n-    w.write_str(\"}\");\n+        if it.has_stripped_entries().unwrap() {\n+            write!(f, \"    /* private fields */\\n\")?;\n+        }\n+        if toggle {\n+            toggle_close(&mut f);\n+        }\n+        f.write_str(\"}\").unwrap();\n+        Ok(())\n+    })\n }\n \n fn render_struct(\n-    w: &mut Buffer,\n+    mut w: &mut Buffer,\n     it: &clean::Item,\n     g: Option<&clean::Generics>,\n     ty: Option<CtorKind>,\n@@ -1747,7 +1809,7 @@ fn render_struct(\n             let has_visible_fields = count_fields > 0;\n             let toggle = should_hide_fields(count_fields);\n             if toggle {\n-                toggle_open(w, format_args!(\"{} fields\", count_fields));\n+                toggle_open(&mut w, format_args!(\"{} fields\", count_fields));\n             }\n             for field in fields {\n                 if let clean::StructFieldItem(ref ty) = *field.kind {\n@@ -1771,7 +1833,7 @@ fn render_struct(\n                 write!(w, \" /* private fields */ \");\n             }\n             if toggle {\n-                toggle_close(w);\n+                toggle_close(&mut w);\n             }\n             w.write_str(\"}\");\n         }\n@@ -1817,161 +1879,169 @@ fn document_non_exhaustive_header(item: &clean::Item) -> &str {\n     if item.is_non_exhaustive() { \" (Non-exhaustive)\" } else { \"\" }\n }\n \n-fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n-    if item.is_non_exhaustive() {\n-        write!(\n-            w,\n-            \"<details class=\\\"toggle non-exhaustive\\\">\\\n-                 <summary class=\\\"hideme\\\"><span>{}</span></summary>\\\n-                 <div class=\\\"docblock\\\">\",\n-            {\n-                if item.is_struct() {\n-                    \"This struct is marked as non-exhaustive\"\n-                } else if item.is_enum() {\n-                    \"This enum is marked as non-exhaustive\"\n-                } else if item.is_variant() {\n-                    \"This variant is marked as non-exhaustive\"\n-                } else {\n-                    \"This type is marked as non-exhaustive\"\n+fn document_non_exhaustive<'a>(item: &'a clean::Item) -> impl fmt::Display + 'a {\n+    display_fn(|f| {\n+        if item.is_non_exhaustive() {\n+            write!(\n+                f,\n+                \"<details class=\\\"toggle non-exhaustive\\\">\\\n+                    <summary class=\\\"hideme\\\"><span>{}</span></summary>\\\n+                    <div class=\\\"docblock\\\">\",\n+                {\n+                    if item.is_struct() {\n+                        \"This struct is marked as non-exhaustive\"\n+                    } else if item.is_enum() {\n+                        \"This enum is marked as non-exhaustive\"\n+                    } else if item.is_variant() {\n+                        \"This variant is marked as non-exhaustive\"\n+                    } else {\n+                        \"This type is marked as non-exhaustive\"\n+                    }\n                 }\n+            )?;\n+\n+            if item.is_struct() {\n+                f.write_str(\n+                    \"Non-exhaustive structs could have additional fields added in future. \\\n+                    Therefore, non-exhaustive structs cannot be constructed in external crates \\\n+                    using the traditional <code>Struct { .. }</code> syntax; cannot be \\\n+                    matched against without a wildcard <code>..</code>; and \\\n+                    struct update syntax will not work.\",\n+                )?;\n+            } else if item.is_enum() {\n+                f.write_str(\n+                    \"Non-exhaustive enums could have additional variants added in future. \\\n+                    Therefore, when matching against variants of non-exhaustive enums, an \\\n+                    extra wildcard arm must be added to account for any future variants.\",\n+                )?;\n+            } else if item.is_variant() {\n+                f.write_str(\n+                    \"Non-exhaustive enum variants could have additional fields added in future. \\\n+                    Therefore, non-exhaustive enum variants cannot be constructed in external \\\n+                    crates and cannot be matched against.\",\n+                )?;\n+            } else {\n+                f.write_str(\n+                    \"This type will require a wildcard arm in any match statements or constructors.\",\n+                )?;\n             }\n-        );\n \n-        if item.is_struct() {\n-            w.write_str(\n-                \"Non-exhaustive structs could have additional fields added in future. \\\n-                 Therefore, non-exhaustive structs cannot be constructed in external crates \\\n-                 using the traditional <code>Struct { .. }</code> syntax; cannot be \\\n-                 matched against without a wildcard <code>..</code>; and \\\n-                 struct update syntax will not work.\",\n-            );\n-        } else if item.is_enum() {\n-            w.write_str(\n-                \"Non-exhaustive enums could have additional variants added in future. \\\n-                 Therefore, when matching against variants of non-exhaustive enums, an \\\n-                 extra wildcard arm must be added to account for any future variants.\",\n-            );\n-        } else if item.is_variant() {\n-            w.write_str(\n-                \"Non-exhaustive enum variants could have additional fields added in future. \\\n-                 Therefore, non-exhaustive enum variants cannot be constructed in external \\\n-                 crates and cannot be matched against.\",\n-            );\n-        } else {\n-            w.write_str(\n-                \"This type will require a wildcard arm in any match statements or constructors.\",\n-            );\n+            f.write_str(\"</div></details>\")?;\n         }\n-\n-        w.write_str(\"</div></details>\");\n-    }\n+        Ok(())\n+    })\n }\n \n-fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n-    fn write_size_of_layout(w: &mut Buffer, layout: &LayoutS, tag_size: u64) {\n+fn document_type_layout<'a, 'cx: 'a>(\n+    cx: &'a Context<'cx>,\n+    ty_def_id: DefId,\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    fn write_size_of_layout(mut w: impl fmt::Write, layout: &LayoutS, tag_size: u64) {\n         if layout.abi.is_unsized() {\n-            write!(w, \"(unsized)\");\n+            write!(w, \"(unsized)\").unwrap();\n         } else {\n             let size = layout.size.bytes() - tag_size;\n-            write!(w, \"{size} byte{pl}\", pl = if size == 1 { \"\" } else { \"s\" },);\n+            write!(w, \"{size} byte{pl}\", pl = if size == 1 { \"\" } else { \"s\" }).unwrap();\n             if layout.abi.is_uninhabited() {\n                 write!(\n                     w,\n                     \" (<a href=\\\"https://doc.rust-lang.org/stable/reference/glossary.html#uninhabited\\\">uninhabited</a>)\"\n-                );\n+                ).unwrap();\n             }\n         }\n     }\n \n-    if !cx.shared.show_type_layout {\n-        return;\n-    }\n-\n-    writeln!(\n-        w,\n-        \"<h2 id=\\\"layout\\\" class=\\\"small-section-header\\\"> \\\n-        Layout<a href=\\\"#layout\\\" class=\\\"anchor\\\">\u00a7</a></h2>\"\n-    );\n-    writeln!(w, \"<div class=\\\"docblock\\\">\");\n-\n-    let tcx = cx.tcx();\n-    let param_env = tcx.param_env(ty_def_id);\n-    let ty = tcx.type_of(ty_def_id).subst_identity();\n-    match tcx.layout_of(param_env.and(ty)) {\n-        Ok(ty_layout) => {\n-            writeln!(\n-                w,\n-                \"<div class=\\\"warning\\\"><p><strong>Note:</strong> Most layout information is \\\n-                 <strong>completely unstable</strong> and may even differ between compilations. \\\n-                 The only exception is types with certain <code>repr(...)</code> attributes. \\\n-                 Please see the Rust Reference\u2019s \\\n-                 <a href=\\\"https://doc.rust-lang.org/reference/type-layout.html\\\">\u201cType Layout\u201d</a> \\\n-                 chapter for details on type layout guarantees.</p></div>\"\n-            );\n-            w.write_str(\"<p><strong>Size:</strong> \");\n-            write_size_of_layout(w, &ty_layout.layout.0, 0);\n-            writeln!(w, \"</p>\");\n-            if let Variants::Multiple { variants, tag, tag_encoding, .. } =\n-                &ty_layout.layout.variants()\n-            {\n-                if !variants.is_empty() {\n-                    w.write_str(\n-                        \"<p><strong>Size for each variant:</strong></p>\\\n-                            <ul>\",\n-                    );\n-\n-                    let Adt(adt, _) = ty_layout.ty.kind() else {\n-                        span_bug!(tcx.def_span(ty_def_id), \"not an adt\")\n-                    };\n+    display_fn(move |mut f| {\n+        if !cx.shared.show_type_layout {\n+            return Ok(());\n+        }\n \n-                    let tag_size = if let TagEncoding::Niche { .. } = tag_encoding {\n-                        0\n-                    } else if let Primitive::Int(i, _) = tag.primitive() {\n-                        i.size().bytes()\n-                    } else {\n-                        span_bug!(tcx.def_span(ty_def_id), \"tag is neither niche nor int\")\n-                    };\n+        writeln!(\n+            f,\n+            \"<h2 id=\\\"layout\\\" class=\\\"small-section-header\\\"> \\\n+            Layout<a href=\\\"#layout\\\" class=\\\"anchor\\\">\u00a7</a></h2>\"\n+        )?;\n+        writeln!(f, \"<div class=\\\"docblock\\\">\")?;\n \n-                    for (index, layout) in variants.iter_enumerated() {\n-                        let name = adt.variant(index).name;\n-                        write!(w, \"<li><code>{name}</code>: \");\n-                        write_size_of_layout(w, layout, tag_size);\n-                        writeln!(w, \"</li>\");\n+        let tcx = cx.tcx();\n+        let param_env = tcx.param_env(ty_def_id);\n+        let ty = tcx.type_of(ty_def_id).subst_identity();\n+        match tcx.layout_of(param_env.and(ty)) {\n+            Ok(ty_layout) => {\n+                writeln!(\n+                    f,\n+                    \"<div class=\\\"warning\\\"><p><strong>Note:</strong> Most layout information is \\\n+                    <strong>completely unstable</strong> and may even differ between compilations. \\\n+                    The only exception is types with certain <code>repr(...)</code> attributes. \\\n+                    Please see the Rust Reference\u2019s \\\n+                    <a href=\\\"https://doc.rust-lang.org/reference/type-layout.html\\\">\u201cType Layout\u201d</a> \\\n+                    chapter for details on type layout guarantees.</p></div>\"\n+                )?;\n+                f.write_str(\"<p><strong>Size:</strong> \")?;\n+                write_size_of_layout(&mut f, &ty_layout.layout.0, 0);\n+                writeln!(f, \"</p>\")?;\n+                if let Variants::Multiple { variants, tag, tag_encoding, .. } =\n+                    &ty_layout.layout.variants()\n+                {\n+                    if !variants.is_empty() {\n+                        f.write_str(\n+                            \"<p><strong>Size for each variant:</strong></p>\\\n+                                <ul>\",\n+                        )?;\n+\n+                        let Adt(adt, _) = ty_layout.ty.kind() else {\n+                            span_bug!(tcx.def_span(ty_def_id), \"not an adt\")\n+                        };\n+\n+                        let tag_size = if let TagEncoding::Niche { .. } = tag_encoding {\n+                            0\n+                        } else if let Primitive::Int(i, _) = tag.primitive() {\n+                            i.size().bytes()\n+                        } else {\n+                            span_bug!(tcx.def_span(ty_def_id), \"tag is neither niche nor int\")\n+                        };\n+\n+                        for (index, layout) in variants.iter_enumerated() {\n+                            let name = adt.variant(index).name;\n+                            write!(&mut f, \"<li><code>{name}</code>: \")?;\n+                            write_size_of_layout(&mut f, layout, tag_size);\n+                            writeln!(&mut f, \"</li>\")?;\n+                        }\n+                        f.write_str(\"</ul>\")?;\n                     }\n-                    w.write_str(\"</ul>\");\n                 }\n             }\n+            // This kind of layout error can occur with valid code, e.g. if you try to\n+            // get the layout of a generic type such as `Vec<T>`.\n+            Err(LayoutError::Unknown(_)) => {\n+                writeln!(\n+                    f,\n+                    \"<p><strong>Note:</strong> Unable to compute type layout, \\\n+                    possibly due to this type having generic parameters. \\\n+                    Layout can only be computed for concrete, fully-instantiated types.</p>\"\n+                )?;\n+            }\n+            // This kind of error probably can't happen with valid code, but we don't\n+            // want to panic and prevent the docs from building, so we just let the\n+            // user know that we couldn't compute the layout.\n+            Err(LayoutError::SizeOverflow(_)) => {\n+                writeln!(\n+                    f,\n+                    \"<p><strong>Note:</strong> Encountered an error during type layout; \\\n+                    the type was too big.</p>\"\n+                )?;\n+            }\n+            Err(LayoutError::NormalizationFailure(_, _)) => {\n+                writeln!(\n+                    f,\n+                    \"<p><strong>Note:</strong> Encountered an error during type layout; \\\n+                    the type failed to be normalized.</p>\"\n+                )?;\n+            }\n         }\n-        // This kind of layout error can occur with valid code, e.g. if you try to\n-        // get the layout of a generic type such as `Vec<T>`.\n-        Err(LayoutError::Unknown(_)) => {\n-            writeln!(\n-                w,\n-                \"<p><strong>Note:</strong> Unable to compute type layout, \\\n-                 possibly due to this type having generic parameters. \\\n-                 Layout can only be computed for concrete, fully-instantiated types.</p>\"\n-            );\n-        }\n-        // This kind of error probably can't happen with valid code, but we don't\n-        // want to panic and prevent the docs from building, so we just let the\n-        // user know that we couldn't compute the layout.\n-        Err(LayoutError::SizeOverflow(_)) => {\n-            writeln!(\n-                w,\n-                \"<p><strong>Note:</strong> Encountered an error during type layout; \\\n-                 the type was too big.</p>\"\n-            );\n-        }\n-        Err(LayoutError::NormalizationFailure(_, _)) => {\n-            writeln!(\n-                w,\n-                \"<p><strong>Note:</strong> Encountered an error during type layout; \\\n-                the type failed to be normalized.</p>\"\n-            )\n-        }\n-    }\n \n-    writeln!(w, \"</div>\");\n+        writeln!(f, \"</div>\")\n+    })\n }\n \n fn pluralize(count: usize) -> &'static str {"}, {"sha": "c8397967c879108bde00a81501140816217bede5", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1be642ce3c24d1a0517c9bf91af926740618b01/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1be642ce3c24d1a0517c9bf91af926740618b01/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=d1be642ce3c24d1a0517c9bf91af926740618b01", "patch": "@@ -2,7 +2,6 @@ use crate::clean;\n use crate::docfs::PathError;\n use crate::error::Error;\n use crate::html::format;\n-use crate::html::format::Buffer;\n use crate::html::highlight;\n use crate::html::layout;\n use crate::html::render::Context;\n@@ -17,6 +16,7 @@ use rustc_span::source_map::FileName;\n \n use std::cell::RefCell;\n use std::ffi::OsStr;\n+use std::fmt;\n use std::fs;\n use std::ops::RangeInclusive;\n use std::path::{Component, Path, PathBuf};\n@@ -294,7 +294,7 @@ pub(crate) enum SourceContext {\n /// Wrapper struct to render the source code of a file. This will do things like\n /// adding line numbers to the left-hand side.\n pub(crate) fn print_src(\n-    buf: &mut Buffer,\n+    mut writer: impl fmt::Write,\n     s: &str,\n     file_span: rustc_span::Span,\n     context: &Context<'_>,\n@@ -329,5 +329,5 @@ pub(crate) fn print_src(\n         );\n         Ok(())\n     });\n-    Source { embedded, needs_expansion, lines, code_html: code }.render_into(buf).unwrap();\n+    Source { embedded, needs_expansion, lines, code_html: code }.render_into(&mut writer).unwrap();\n }"}, {"sha": "a01457971c178e8c16a86effce9eeab8938e5b96", "filename": "src/librustdoc/html/templates/item_union.html", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d1be642ce3c24d1a0517c9bf91af926740618b01/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_union.html", "raw_url": "https://github.com/rust-lang/rust/raw/d1be642ce3c24d1a0517c9bf91af926740618b01/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_union.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_union.html?ref=d1be642ce3c24d1a0517c9bf91af926740618b01", "patch": "@@ -0,0 +1,23 @@\n+<pre class=\"rust item-decl\"><code>\n+    {{ self.render_attributes_in_pre() | safe }}\n+    {{ self.render_union() | safe }}\n+</code></pre>\n+{{ self.document() | safe }}\n+{% if self.fields_iter().peek().is_some() %}\n+    <h2 id=\"fields\" class=\"fields small-section-header\">\n+        Fields<a href=\"#fields\" class=\"anchor\">\u00a7</a>\n+    </h2>\n+    {% for (field, ty) in self.fields_iter() %}\n+        {% let name = field.name.expect(\"union field name\") %}\n+        <span id=\"structfield.{{ name }}\" class=\"{{ ItemType::StructField }} small-section-header\">\n+            <a href=\"#structfield.{{ name }}\" class=\"anchor field\">\u00a7</a>\n+            <code>{{ name }}: {{ self.print_ty(ty) | safe }}</code>\n+        </span>\n+        {% if let Some(stability_class) = self.stability_field(field) %}\n+            <span class=\"stab {{ stability_class }}\"></span>\n+        {% endif %}\n+        {{ self.document_field(field) | safe }}\n+    {% endfor %}\n+{% endif %}\n+{{ self.render_assoc_items() | safe }}\n+{{ self.document_type_layout() | safe }}"}]}