{"sha": "46333d527b138e8e202380a5ce4409dfe1414148", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2MzMzZDUyN2IxMzhlOGUyMDIzODBhNWNlNDQwOWRmZTE0MTQxNDg=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-09T22:35:53Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-12T15:04:31Z"}, "message": "Deprecate Zero and One traits", "tree": {"sha": "12a9e363e31b019f74bcf9748fd2bc58770fd86d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12a9e363e31b019f74bcf9748fd2bc58770fd86d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46333d527b138e8e202380a5ce4409dfe1414148", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46333d527b138e8e202380a5ce4409dfe1414148", "html_url": "https://github.com/rust-lang/rust/commit/46333d527b138e8e202380a5ce4409dfe1414148", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46333d527b138e8e202380a5ce4409dfe1414148/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0da49dcf1352bc038bb32c1a7bc1ac1be50d541c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c", "html_url": "https://github.com/rust-lang/rust/commit/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c"}], "stats": {"total": 463, "additions": 233, "deletions": 230}, "files": [{"sha": "473493938a4489dcd1bee2435b46d6758dab1b32", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -228,7 +228,7 @@ impl Iterator<(uint, uint)> for ElementSwaps {\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         // For a vector of size n, there are exactly n! permutations.\n-        let n = range(2, self.sdir.len() + 1).product();\n+        let n = range(2, self.sdir.len() + 1).product(1);\n         (n - self.swaps_made, Some(n - self.swaps_made))\n     }\n }"}, {"sha": "662349a4b862b0ea594a5d2ffb21528d4908b4f5", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -116,7 +116,7 @@ impl<S: Str> StrVector for [S] {\n         }\n \n         // `len` calculation may overflow but push_str will check boundaries\n-        let len = self.iter().map(|s| s.as_slice().len()).sum();\n+        let len = self.iter().map(|s| s.as_slice().len()).sum(0);\n \n         let mut result = String::with_capacity(len);\n \n@@ -140,7 +140,7 @@ impl<S: Str> StrVector for [S] {\n         // this is wrong without the guarantee that `self` is non-empty\n         // `len` calculation may overflow but push_str but will check boundaries\n         let len = sep.len() * (self.len() - 1)\n-            + self.iter().map(|s| s.as_slice().len()).sum();\n+            + self.iter().map(|s| s.as_slice().len()).sum(0);\n         let mut result = String::with_capacity(len);\n         let mut first = true;\n \n@@ -2151,7 +2151,7 @@ mod tests {\n     #[test]\n     fn test_str_container() {\n         fn sum_len(v: &[&str]) -> uint {\n-            v.iter().map(|x| x.len()).sum()\n+            v.iter().map(|x| x.len()).sum(0)\n         }\n \n         let s = String::from_str(\"01234\");"}, {"sha": "365d5a7212b1681861523730c697bede32812067", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -14,7 +14,7 @@ use char;\n use fmt;\n use iter::{range, DoubleEndedIterator};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive, Primitive};\n-use num::{Zero, One, cast};\n+use num::cast;\n use result::Ok;\n use slice::{mod, SlicePrelude};\n use str::StrPrelude;\n@@ -97,8 +97,8 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n         _ => ()\n     }\n \n-    let _0: T = Zero::zero();\n-    let _1: T = One::one();\n+    let _0: T = Float::zero();\n+    let _1: T = Float::one();\n \n     match num.classify() {\n         FPNaN => return f(\"NaN\".as_bytes()),"}, {"sha": "787d2d2c6781372f9babfdfcf6b939f77267e090", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -16,7 +16,7 @@\n \n use fmt;\n use iter::DoubleEndedIterator;\n-use num::{Int, cast, zero};\n+use num::{Int, cast};\n use slice::SlicePrelude;\n \n /// A type that represents a specific radix\n@@ -38,7 +38,7 @@ trait GenericRadix {\n         let mut buf = [0u8, ..64];\n         let base = cast(self.base()).unwrap();\n         let mut curr = buf.len();\n-        let is_positive = x >= zero();\n+        let is_positive = x >= Int::zero();\n         if is_positive {\n             // Accumulate each digit of the number from the least significant\n             // to the most significant figure.\n@@ -47,7 +47,7 @@ trait GenericRadix {\n                 x = x / base;                             // Deaccumulate the number.\n                 *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n                 curr -= 1;\n-                if x == zero() { break; }                 // No more digits left to accumulate.\n+                if x == Int::zero() { break; }                 // No more digits left to accumulate.\n             }\n         } else {\n             // Do the same as above, but accounting for two's complement.\n@@ -56,7 +56,7 @@ trait GenericRadix {\n                 x = x / base;                             // Deaccumulate the number.\n                 *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n                 curr -= 1;\n-                if x == zero() { break; }                 // No more digits left to accumulate.\n+                if x == Int::zero() { break; }                 // No more digits left to accumulate.\n             }\n         }\n         f.pad_integral(is_positive, self.prefix(), buf[curr..])"}, {"sha": "a24b6d85007e1613f4d45ebf4755a2c45e0f6cf8", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -60,10 +60,10 @@ This `for` loop syntax can be applied to any iterator over any type.\n \n use clone::Clone;\n use cmp;\n-use cmp::{PartialOrd, Ord};\n+use cmp::Ord;\n use mem;\n-use num::{Zero, One, ToPrimitive, Int};\n-use ops::{Add, Mul, Sub};\n+use num::{ToPrimitive, Int};\n+use ops::{Add, Mul};\n use option::{Option, Some, None};\n use uint;\n #[deprecated = \"renamed to Extend\"] pub use self::Extend as Extendable;\n@@ -402,7 +402,7 @@ pub trait Iterator<A> {\n     ///             .inspect(|&x| println!(\"filtering {}\", x))\n     ///             .filter(|&x| x % 2 == 0)\n     ///             .inspect(|&x| println!(\"{} made it through\", x))\n-    ///             .sum();\n+    ///             .sum(0);\n     /// println!(\"{}\", sum);\n     /// ```\n     #[inline]\n@@ -780,16 +780,15 @@ pub trait AdditiveIterator<A> {\n     ///\n     /// let a = [1i, 2, 3, 4, 5];\n     /// let mut it = a.iter().map(|&x| x);\n-    /// assert!(it.sum() == 15);\n+    /// assert!(it.sum(0) == 15);\n     /// ```\n-    fn sum(&mut self) -> A;\n+    fn sum(&mut self, init: A) -> A;\n }\n \n-impl<A: Add<A, A> + Zero, T: Iterator<A>> AdditiveIterator<A> for T {\n+impl<A: Add<A, A>, T: Iterator<A>> AdditiveIterator<A> for T {\n     #[inline]\n-    fn sum(&mut self) -> A {\n-        let zero: A = Zero::zero();\n-        self.fold(zero, |s, x| s + x)\n+    fn sum(&mut self, init: A) -> A {\n+        self.fold(init, |s, x| s + x)\n     }\n }\n \n@@ -803,20 +802,19 @@ pub trait MultiplicativeIterator<A> {\n     /// use std::iter::{count, MultiplicativeIterator};\n     ///\n     /// fn factorial(n: uint) -> uint {\n-    ///     count(1u, 1).take_while(|&i| i <= n).product()\n+    ///     count(1u, 1).take_while(|&i| i <= n).product(1)\n     /// }\n     /// assert!(factorial(0) == 1);\n     /// assert!(factorial(1) == 1);\n     /// assert!(factorial(5) == 120);\n     /// ```\n-    fn product(&mut self) -> A;\n+    fn product(&mut self, init: A) -> A;\n }\n \n-impl<A: Mul<A, A> + One, T: Iterator<A>> MultiplicativeIterator<A> for T {\n+impl<A: Mul<A, A>, T: Iterator<A>> MultiplicativeIterator<A> for T {\n     #[inline]\n-    fn product(&mut self) -> A {\n-        let one: A = One::one();\n-        self.fold(one, |p, x| p * x)\n+    fn product(&mut self, init: A) -> A {\n+        self.fold(init, |p, x| p * x)\n     }\n }\n \n@@ -1905,7 +1903,7 @@ impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n pub struct Range<A> {\n     state: A,\n     stop: A,\n-    one: A\n+    one: A,\n }\n \n /// Returns an iterator over the given range [start, stop) (that is, starting\n@@ -1922,12 +1920,16 @@ pub struct Range<A> {\n /// }\n /// ```\n #[inline]\n-pub fn range<A: Add<A, A> + PartialOrd + Clone + One>(start: A, stop: A) -> Range<A> {\n-    Range{state: start, stop: stop, one: One::one()}\n+pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n+    Range {\n+        state: start,\n+        stop: stop,\n+        one: Int::one(),\n+    }\n }\n \n // FIXME: #10414: Unfortunate type bound\n-impl<A: Add<A, A> + PartialOrd + Clone + ToPrimitive> Iterator<A> for Range<A> {\n+impl<A: Int + ToPrimitive> Iterator<A> for Range<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.state < self.stop {\n@@ -1974,7 +1976,7 @@ impl<A: Add<A, A> + PartialOrd + Clone + ToPrimitive> Iterator<A> for Range<A> {\n \n /// `Int` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n-impl<A: Int + PartialOrd + Clone + ToPrimitive> DoubleEndedIterator<A> for Range<A> {\n+impl<A: Int + ToPrimitive> DoubleEndedIterator<A> for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.stop > self.state {\n@@ -1995,12 +1997,14 @@ pub struct RangeInclusive<A> {\n \n /// Return an iterator over the range [start, stop]\n #[inline]\n-pub fn range_inclusive<A: Add<A, A> + PartialOrd + Clone + One>(start: A, stop: A)\n-    -> RangeInclusive<A> {\n-    RangeInclusive{range: range(start, stop), done: false}\n+pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n+    RangeInclusive {\n+        range: range(start, stop),\n+        done: false,\n+    }\n }\n \n-impl<A: Add<A, A> + PartialOrd + Clone + ToPrimitive> Iterator<A> for RangeInclusive<A> {\n+impl<A: Int + ToPrimitive> Iterator<A> for RangeInclusive<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         match self.range.next() {\n@@ -2032,8 +2036,7 @@ impl<A: Add<A, A> + PartialOrd + Clone + ToPrimitive> Iterator<A> for RangeInclu\n     }\n }\n \n-impl<A: Sub<A, A> + Int + PartialOrd + Clone + ToPrimitive> DoubleEndedIterator<A>\n-    for RangeInclusive<A> {\n+impl<A: Int + ToPrimitive> DoubleEndedIterator<A> for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.range.stop > self.range.state {\n@@ -2061,7 +2064,7 @@ pub struct RangeStep<A> {\n /// Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[inline]\n pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n-    let rev = step < Zero::zero();\n+    let rev = step < Int::zero();\n     RangeStep{state: start, stop: stop, step: step, rev: rev}\n }\n \n@@ -2094,8 +2097,14 @@ pub struct RangeStepInclusive<A> {\n /// Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[inline]\n pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n-    let rev = step < Zero::zero();\n-    RangeStepInclusive{state: start, stop: stop, step: step, rev: rev, done: false}\n+    let rev = step < Int::zero();\n+    RangeStepInclusive {\n+        state: start,\n+        stop: stop,\n+        step: step,\n+        rev: rev,\n+        done: false,\n+    }\n }\n \n impl<A: Int> Iterator<A> for RangeStepInclusive<A> {"}, {"sha": "fddb41c38ef219d760ae43e70f577dbce58cd18d", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -114,9 +114,15 @@ impl Float for f32 {\n     #[inline]\n     fn neg_infinity() -> f32 { NEG_INFINITY }\n \n+    #[inline]\n+    fn zero() -> f32 { 0.0 }\n+\n     #[inline]\n     fn neg_zero() -> f32 { -0.0 }\n \n+    #[inline]\n+    fn one() -> f32 { 1.0 }\n+\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool { self != self }"}, {"sha": "f06b7e97cf1c65450792513c0d1820c83d624b5a", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -120,9 +120,15 @@ impl Float for f64 {\n     #[inline]\n     fn neg_infinity() -> f64 { NEG_INFINITY }\n \n+    #[inline]\n+    fn zero() -> f64 { 0.0 }\n+\n     #[inline]\n     fn neg_zero() -> f64 { -0.0 }\n \n+    #[inline]\n+    fn one() -> f64 { 1.0 }\n+\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool { self != self }"}, {"sha": "adce510610ba2d616e16b1ae523150d4712e4c08", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 99, "deletions": 121, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -27,6 +27,7 @@ use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::{Option, Some, None};\n \n /// The base trait for numeric types\n+#[allow(deprecated)]\n pub trait Num: PartialEq + Zero + One\n              + Neg<Self>\n              + Add<Self,Self>\n@@ -49,112 +50,6 @@ pub fn div_rem<T: Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) {\n     (x / y, x % y)\n }\n \n-/// Defines an additive identity element for `Self`.\n-///\n-/// # Deriving\n-///\n-/// This trait can be automatically be derived using `#[deriving(Zero)]`\n-/// attribute. If you choose to use this, make sure that the laws outlined in\n-/// the documentation for `Zero::zero` still hold.\n-pub trait Zero: Add<Self, Self> {\n-    /// Returns the additive identity element of `Self`, `0`.\n-    ///\n-    /// # Laws\n-    ///\n-    /// ```{.text}\n-    /// a + 0 = a       \u2200 a \u2208 Self\n-    /// 0 + a = a       \u2200 a \u2208 Self\n-    /// ```\n-    ///\n-    /// # Purity\n-    ///\n-    /// This function should return the same result at all times regardless of\n-    /// external mutable state, for example values stored in TLS or in\n-    /// `static mut`s.\n-    // FIXME (#5527): This should be an associated constant\n-    fn zero() -> Self;\n-\n-    /// Returns `true` if `self` is equal to the additive identity.\n-    #[inline]\n-    fn is_zero(&self) -> bool;\n-}\n-\n-macro_rules! zero_impl(\n-    ($t:ty, $v:expr) => {\n-        impl Zero for $t {\n-            #[inline]\n-            fn zero() -> $t { $v }\n-            #[inline]\n-            fn is_zero(&self) -> bool { *self == $v }\n-        }\n-    }\n-)\n-\n-zero_impl!(uint, 0u)\n-zero_impl!(u8,   0u8)\n-zero_impl!(u16,  0u16)\n-zero_impl!(u32,  0u32)\n-zero_impl!(u64,  0u64)\n-\n-zero_impl!(int, 0i)\n-zero_impl!(i8,  0i8)\n-zero_impl!(i16, 0i16)\n-zero_impl!(i32, 0i32)\n-zero_impl!(i64, 0i64)\n-\n-zero_impl!(f32, 0.0f32)\n-zero_impl!(f64, 0.0f64)\n-\n-/// Returns the additive identity, `0`.\n-#[inline(always)] pub fn zero<T: Zero>() -> T { Zero::zero() }\n-\n-/// Defines a multiplicative identity element for `Self`.\n-pub trait One: Mul<Self, Self> {\n-    /// Returns the multiplicative identity element of `Self`, `1`.\n-    ///\n-    /// # Laws\n-    ///\n-    /// ```{.text}\n-    /// a * 1 = a       \u2200 a \u2208 Self\n-    /// 1 * a = a       \u2200 a \u2208 Self\n-    /// ```\n-    ///\n-    /// # Purity\n-    ///\n-    /// This function should return the same result at all times regardless of\n-    /// external mutable state, for example values stored in TLS or in\n-    /// `static mut`s.\n-    // FIXME (#5527): This should be an associated constant\n-    fn one() -> Self;\n-}\n-\n-macro_rules! one_impl(\n-    ($t:ty, $v:expr) => {\n-        impl One for $t {\n-            #[inline]\n-            fn one() -> $t { $v }\n-        }\n-    }\n-)\n-\n-one_impl!(uint, 1u)\n-one_impl!(u8,  1u8)\n-one_impl!(u16, 1u16)\n-one_impl!(u32, 1u32)\n-one_impl!(u64, 1u64)\n-\n-one_impl!(int, 1i)\n-one_impl!(i8,  1i8)\n-one_impl!(i16, 1i16)\n-one_impl!(i32, 1i32)\n-one_impl!(i64, 1i64)\n-\n-one_impl!(f32, 1.0f32)\n-one_impl!(f64, 1.0f64)\n-\n-/// Returns the multiplicative identity, `1`.\n-#[inline(always)] pub fn one<T: One>() -> T { One::one() }\n-\n /// Useful functions for signed numbers (i.e. numbers that can be negative).\n pub trait Signed: Num + Neg<Self> {\n     /// Computes the absolute value.\n@@ -281,10 +176,10 @@ trait_impl!(Unsigned for uint u8 u16 u32 u64)\n /// assert_eq!(num::pow(2i, 4), 16);\n /// ```\n #[inline]\n-pub fn pow<T: One + Mul<T, T>>(mut base: T, mut exp: uint) -> T {\n+pub fn pow<T: Int>(mut base: T, mut exp: uint) -> T {\n     if exp == 1 { base }\n     else {\n-        let mut acc = one::<T>();\n+        let mut acc: T = Int::one();\n         while exp > 0 {\n             if (exp & 1) == 1 {\n                 acc = acc * base;\n@@ -317,6 +212,14 @@ pub trait Int: Primitive\n              + BitXor<Self,Self>\n              + Shl<uint,Self>\n              + Shr<uint,Self> {\n+    /// Returns the `0` value of this integer.\n+    // FIXME (#5527): Should be an associated constant\n+    fn zero() -> Self;\n+\n+    /// Returns the `1` value of this integer.\n+    // FIXME (#5527): Should be an associated constant\n+    fn one() -> Self;\n+\n     /// Returns the smallest value that can be represented by this integer.\n     // FIXME (#5527): Should be and associated constant\n     fn min_value() -> Self;\n@@ -551,9 +454,9 @@ pub trait Int: Primitive\n     #[inline]\n     fn saturating_add(self, other: Self) -> Self {\n         match self.checked_add(other) {\n-            Some(x)                       => x,\n-            None if other >= Zero::zero() => Int::max_value(),\n-            None                          => Int::min_value(),\n+            Some(x)                      => x,\n+            None if other >= Int::zero() => Int::max_value(),\n+            None                         => Int::min_value(),\n         }\n     }\n \n@@ -562,9 +465,9 @@ pub trait Int: Primitive\n     #[inline]\n     fn saturating_sub(self, other: Self) -> Self {\n         match self.checked_sub(other) {\n-            Some(x)                       => x,\n-            None if other >= Zero::zero() => Int::min_value(),\n-            None                          => Int::max_value(),\n+            Some(x)                      => x,\n+            None if other >= Int::zero() => Int::min_value(),\n+            None                         => Int::max_value(),\n         }\n     }\n }\n@@ -586,6 +489,12 @@ macro_rules! uint_impl {\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n         impl Int for $T {\n+            #[inline]\n+            fn zero() -> $T { 0 }\n+\n+            #[inline]\n+            fn one() -> $T { 1 }\n+\n             #[inline]\n             fn min_value() -> $T { 0 }\n \n@@ -710,6 +619,12 @@ macro_rules! int_impl {\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n         impl Int for $T {\n+            #[inline]\n+            fn zero() -> $T { 0 }\n+\n+            #[inline]\n+            fn one() -> $T { 1 }\n+\n             #[inline]\n             fn min_value() -> $T { (-1 as $T) << ($BITS - 1) }\n \n@@ -798,34 +713,34 @@ int_impl!(int = i64, u64, 64,\n pub trait UnsignedInt: Int {\n     /// Returns `true` iff `self == 2^k` for some `k`.\n     fn is_power_of_two(self) -> bool {\n-        (self - one()) & self == zero()\n+        (self - Int::one()) & self == Int::zero()\n     }\n \n     /// Returns the smallest power of two greater than or equal to `self`.\n     #[inline]\n     fn next_power_of_two(self) -> Self {\n         let halfbits = size_of::<Self>() * 4;\n-        let mut tmp = self - one();\n+        let mut tmp = self - Int::one();\n         let mut shift = 1u;\n         while shift <= halfbits {\n             tmp = tmp | (tmp >> shift);\n             shift = shift << 1u;\n         }\n-        tmp + one()\n+        tmp + Int::one()\n     }\n \n     /// Returns the smallest power of two greater than or equal to `n`. If the\n     /// next power of two is greater than the type's maximum value, `None` is\n     /// returned, otherwise the power of two is wrapped in `Some`.\n     fn checked_next_power_of_two(self) -> Option<Self> {\n         let halfbits = size_of::<Self>() * 4;\n-        let mut tmp = self - one();\n+        let mut tmp = self - Int::one();\n         let mut shift = 1u;\n         while shift <= halfbits {\n             tmp = tmp | (tmp >> shift);\n             shift = shift << 1u;\n         }\n-        tmp.checked_add(one())\n+        tmp.checked_add(Int::one())\n     }\n }\n \n@@ -927,7 +842,7 @@ macro_rules! impl_to_primitive_int_to_int(\n macro_rules! impl_to_primitive_int_to_uint(\n     ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         {\n-            let zero: $SrcT = Zero::zero();\n+            let zero: $SrcT = Int::zero();\n             let max_value: $DstT = Int::max_value();\n             if zero <= $slf && $slf as u64 <= max_value as u64 {\n                 Some($slf as $DstT)\n@@ -996,7 +911,7 @@ macro_rules! impl_to_primitive_uint_to_uint(\n             if size_of::<$SrcT>() <= size_of::<$DstT>() {\n                 Some($slf as $DstT)\n             } else {\n-                let zero: $SrcT = Zero::zero();\n+                let zero: $SrcT = Int::zero();\n                 let max_value: $DstT = Int::max_value();\n                 if zero <= $slf && $slf as u64 <= max_value as u64 {\n                     Some($slf as $DstT)\n@@ -1351,8 +1266,12 @@ pub trait Float: Signed + Primitive {\n     fn infinity() -> Self;\n     /// Returns the negative infinite value.\n     fn neg_infinity() -> Self;\n+    /// Returns the `0` value.\n+    fn zero() -> Self;\n     /// Returns -0.0.\n     fn neg_zero() -> Self;\n+    /// Returns the `1` value.\n+    fn one() -> Self;\n \n     /// Returns true if this value is NaN and false otherwise.\n     fn is_nan(self) -> bool;\n@@ -1485,6 +1404,65 @@ pub trait Float: Signed + Primitive {\n \n // DEPRECATED\n \n+#[deprecated = \"The generic `Zero` trait will be removed soon.\"]\n+pub trait Zero: Add<Self, Self> {\n+    #[deprecated = \"Use `Int::zero()` or `Float::zero()`.\"]\n+    fn zero() -> Self;\n+    #[deprecated = \"Use `x == Int::zero()` or `x == Float::zero()`.\"]\n+    fn is_zero(&self) -> bool;\n+}\n+#[deprecated = \"Use `Int::zero()` or `Float::zero()`.\"]\n+#[allow(deprecated)]\n+pub fn zero<T: Zero>() -> T { Zero::zero() }\n+macro_rules! zero_impl {\n+    ($t:ty, $v:expr) => {\n+        impl Zero for $t {\n+            fn zero() -> $t { $v }\n+            fn is_zero(&self) -> bool { *self == $v }\n+        }\n+    }\n+}\n+zero_impl!(uint, 0u)\n+zero_impl!(u8,   0u8)\n+zero_impl!(u16,  0u16)\n+zero_impl!(u32,  0u32)\n+zero_impl!(u64,  0u64)\n+zero_impl!(int, 0i)\n+zero_impl!(i8,  0i8)\n+zero_impl!(i16, 0i16)\n+zero_impl!(i32, 0i32)\n+zero_impl!(i64, 0i64)\n+zero_impl!(f32, 0.0f32)\n+zero_impl!(f64, 0.0f64)\n+\n+#[deprecated = \"The generic `One` trait will be removed soon.\"]\n+pub trait One: Mul<Self, Self> {\n+    #[deprecated = \"Use `Int::one()` or `Float::one()`.\"]\n+    fn one() -> Self;\n+}\n+#[deprecated = \"Use `Int::one()` or `Float::one()`.\"]\n+#[allow(deprecated)]\n+pub fn one<T: One>() -> T { One::one() }\n+macro_rules! one_impl {\n+    ($t:ty, $v:expr) => {\n+        impl One for $t {\n+            fn one() -> $t { $v }\n+        }\n+    }\n+}\n+one_impl!(uint, 1u)\n+one_impl!(u8,  1u8)\n+one_impl!(u16, 1u16)\n+one_impl!(u32, 1u32)\n+one_impl!(u64, 1u64)\n+one_impl!(int, 1i)\n+one_impl!(i8,  1i8)\n+one_impl!(i16, 1i16)\n+one_impl!(i32, 1i32)\n+one_impl!(i64, 1i64)\n+one_impl!(f32, 1.0f32)\n+one_impl!(f64, 1.0f64)\n+\n #[deprecated = \"Use `Signed::abs`\"]\n pub fn abs<T: Signed>(value: T) -> T {\n     value.abs()"}, {"sha": "7e7e11a3645fb25571612b02b852b576ff715337", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -294,17 +294,17 @@ fn test_iterator_len() {\n #[test]\n fn test_iterator_sum() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).sum(), 6);\n-    assert_eq!(v.iter().map(|&x| x).sum(), 55);\n-    assert_eq!(v[0..0].iter().map(|&x| x).sum(), 0);\n+    assert_eq!(v[0..4].iter().map(|&x| x).sum(0), 6);\n+    assert_eq!(v.iter().map(|&x| x).sum(0), 55);\n+    assert_eq!(v[0..0].iter().map(|&x| x).sum(0), 0);\n }\n \n #[test]\n fn test_iterator_product() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).product(), 0);\n-    assert_eq!(v[1..5].iter().map(|&x| x).product(), 24);\n-    assert_eq!(v[0..0].iter().map(|&x| x).product(), 1);\n+    assert_eq!(v[0..4].iter().map(|&x| x).product(1), 0);\n+    assert_eq!(v[1..5].iter().map(|&x| x).product(1), 24);\n+    assert_eq!(v[0..0].iter().map(|&x| x).product(1), 1);\n }\n \n #[test]"}, {"sha": "52bb0dc0784f954fbee7a872ebe3c377611ef2c6", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -69,7 +69,7 @@ impl<'a> fmt::Show for Matrix<'a> {\n             pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0u)\n         }).collect();\n \n-        let total_width = column_widths.iter().map(|n| *n).sum() + column_count * 3 + 1;\n+        let total_width = column_widths.iter().map(|n| *n).sum(0) + column_count * 3 + 1;\n         let br = String::from_char(total_width, '+');\n         try!(write!(f, \"{}\\n\", br));\n         for row in pretty_printed_matrix.into_iter() {"}, {"sha": "1f7ad8120dc6e7e381542c3f0e14e78801997fd8", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -756,7 +756,7 @@ fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n         let total_score = m.iter()\n             .map(|row| row.pats[col])\n             .map(|pat| pat_score(def_map, pat))\n-            .sum();\n+            .sum(0);\n \n         // Irrefutable columns always go first, they'd only be duplicated in the branches.\n         if total_score == 0 {"}, {"sha": "88a681a85e9ef64db5d70b96594f69b3f516f2ec", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -1194,7 +1194,7 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n             lifetimes_for_params.push((input_pat, accumulator));\n         }\n \n-        if lifetimes_for_params.iter().map(|&(_, ref x)| x.len()).sum() == 1 {\n+        if lifetimes_for_params.iter().map(|&(_, ref x)| x.len()).sum(0) == 1 {\n             implied_output_region =\n                 Some(lifetimes_for_params.iter()\n                                          .filter_map(|&(_, ref x)|"}, {"sha": "445279724b380149ce7a694aaa1c002ded885df4", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -15,7 +15,6 @@\n #![allow(deprecated)] // to_be32\n \n use std::iter::range_step;\n-use std::num::Zero;\n use std::slice::bytes::{MutableByteVector, copy_memory};\n use serialize::hex::ToHex;\n \n@@ -64,7 +63,7 @@ impl ToBits for u64 {\n fn add_bytes_to_bits<T: Int + ToBits>(bits: T, bytes: T) -> T {\n     let (new_high_bits, new_low_bits) = bytes.to_bits();\n \n-    if new_high_bits > Zero::zero() {\n+    if new_high_bits > Int::zero() {\n         panic!(\"numeric overflow occurred.\")\n     }\n "}, {"sha": "a6fa68e1953865ccff3365b08a40033745f0c72f", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -55,6 +55,18 @@ impl Add<Counts, Counts> for Counts {\n }\n \n impl Counts {\n+    fn zero() -> Counts {\n+        Counts {\n+            deprecated:   0,\n+            experimental: 0,\n+            unstable:     0,\n+            stable:       0,\n+            frozen:       0,\n+            locked:       0,\n+            unmarked:     0,\n+        }\n+    }\n+\n     pub fn total(&self) -> uint {\n         self.deprecated + self.experimental + self.unstable + self.stable +\n             self.frozen + self.locked + self.unmarked\n@@ -92,14 +104,14 @@ fn visible(item: &Item) -> bool {\n \n fn count_stability(stab: Option<&Stability>) -> Counts {\n     match stab {\n-        None             => Counts { unmarked: 1,     .. Zero::zero() },\n+        None             => Counts { unmarked: 1,     .. Counts::zero() },\n         Some(ref stab) => match stab.level {\n-            Deprecated   => Counts { deprecated: 1,   .. Zero::zero() },\n-            Experimental => Counts { experimental: 1, .. Zero::zero() },\n-            Unstable     => Counts { unstable: 1,     .. Zero::zero() },\n-            Stable       => Counts { stable: 1,       .. Zero::zero() },\n-            Frozen       => Counts { frozen: 1,       .. Zero::zero() },\n-            Locked       => Counts { locked: 1,       .. Zero::zero() },\n+            Deprecated   => Counts { deprecated: 1,   .. Counts::zero() },\n+            Experimental => Counts { experimental: 1, .. Counts::zero() },\n+            Unstable     => Counts { unstable: 1,     .. Counts::zero() },\n+            Stable       => Counts { stable: 1,       .. Counts::zero() },\n+            Frozen       => Counts { frozen: 1,       .. Counts::zero() },\n+            Locked       => Counts { locked: 1,       .. Counts::zero() },\n         }\n     }\n }\n@@ -136,14 +148,14 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n             let subcounts = subitems.iter().filter(|i| visible(*i))\n                                            .map(summarize_item)\n                                            .map(|s| s.val0())\n-                                           .sum();\n+                                           .sum(Counts::zero());\n             (item_counts + subcounts, None)\n         }\n         // `pub` automatically\n         EnumItem(Enum { variants: ref subitems, .. }) => {\n             let subcounts = subitems.iter().map(summarize_item)\n                                            .map(|s| s.val0())\n-                                           .sum();\n+                                           .sum(Counts::zero());\n             (item_counts + subcounts, None)\n         }\n         TraitItem(Trait {\n@@ -161,7 +173,7 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n                                        .map(extract_item)\n                                        .map(summarize_item)\n                                        .map(|s| s.val0())\n-                                       .sum();\n+                                       .sum(Counts::zero());\n             (item_counts + subcounts, None)\n         }\n         ModuleItem(Module { ref items, .. }) => {\n@@ -182,7 +194,7 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n             }))\n         }\n         // no stability information for the following items:\n-        ViewItemItem(_) | PrimitiveItem(_) => (Zero::zero(), None),\n+        ViewItemItem(_) | PrimitiveItem(_) => (Counts::zero(), None),\n         _ => (item_counts, None)\n     }\n }\n@@ -192,7 +204,7 @@ pub fn build(krate: &Crate) -> ModuleSummary {\n     match krate.module {\n         None => ModuleSummary {\n             name: krate.name.clone(),\n-            counts: Zero::zero(),\n+            counts: Counts::zero(),\n             submodules: Vec::new(),\n         },\n         Some(ref item) => ModuleSummary {"}, {"sha": "837784da6df3597d4a5a0b00191ef88d3675f2f4", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -1522,7 +1522,7 @@ impl<T: Iterator<char>> Parser<T> {\n             }\n         }\n \n-        let exp = num::pow(10_f64, exp);\n+        let exp = 10_f64.powi(exp as i32);\n         if neg_exp {\n             res /= exp;\n         } else {"}, {"sha": "c72b8205f19b492c66c146e5ff0498357b16cb4a", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -655,7 +655,7 @@ mod tests {\n         let nan: f32 = Float::nan();\n         let inf: f32 = Float::infinity();\n         let neg_inf: f32 = Float::neg_infinity();\n-        let zero: f32 = Zero::zero();\n+        let zero: f32 = Float::zero();\n         let neg_zero: f32 = Float::neg_zero();\n         assert!(!nan.is_normal());\n         assert!(!inf.is_normal());\n@@ -672,7 +672,7 @@ mod tests {\n         let nan: f32 = Float::nan();\n         let inf: f32 = Float::infinity();\n         let neg_inf: f32 = Float::neg_infinity();\n-        let zero: f32 = Zero::zero();\n+        let zero: f32 = Float::zero();\n         let neg_zero: f32 = Float::neg_zero();\n         assert_eq!(nan.classify(), FPNaN);\n         assert_eq!(inf.classify(), FPInfinite);"}, {"sha": "311fd0e87a323cf598fae7e13e73f9bbf1fab38d", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -653,7 +653,7 @@ mod tests {\n         let nan: f64 = Float::nan();\n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n-        let zero: f64 = Zero::zero();\n+        let zero: f64 = Float::zero();\n         let neg_zero: f64 = Float::neg_zero();\n         assert!(!nan.is_normal());\n         assert!(!inf.is_normal());\n@@ -670,7 +670,7 @@ mod tests {\n         let nan: f64 = Float::nan();\n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n-        let zero: f64 = Zero::zero();\n+        let zero: f64 = Float::zero();\n         let neg_zero: f64 = Float::neg_zero();\n         assert_eq!(nan.classify(), FPNaN);\n         assert_eq!(inf.classify(), FPInfinite);"}, {"sha": "f831de88858ad9a57613be4874597ec3604dac11", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -771,10 +771,7 @@ mod tests {\n         assert_pow!((3i,     0 ) => 1);\n         assert_pow!((5i,     1 ) => 5);\n         assert_pow!((-4i,    2 ) => 16);\n-        assert_pow!((0.5f64, 5 ) => 0.03125);\n         assert_pow!((8i,     3 ) => 512);\n-        assert_pow!((8.0f64, 5 ) => 32768.0);\n-        assert_pow!((8.5f64, 5 ) => 44370.53125);\n         assert_pow!((2u64,   50) => 1125899906842624);\n     }\n }"}, {"sha": "7c21b020647a472802e556302693ee9bab0a2bfb", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -94,7 +94,7 @@ pub enum SignFormat {\n fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) {\n     assert!(2 <= radix && radix <= 36);\n \n-    let _0: T = num::zero();\n+    let _0: T = Int::zero();\n \n     let neg = num < _0;\n     let radix_gen: T = num::cast(radix).unwrap();\n@@ -194,8 +194,8 @@ pub fn float_to_str_bytes_common<T: Float>(\n         _ => ()\n     }\n \n-    let _0: T = num::zero();\n-    let _1: T = num::one();\n+    let _0: T = Float::zero();\n+    let _1: T = Float::one();\n \n     match num.classify() {\n         FPNaN => { return (b\"NaN\".to_vec(), true); }\n@@ -430,8 +430,8 @@ pub fn from_str_radix_float<T: Float>(src: &str, radix: uint) -> Option<T> {\n            \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n            radix);\n \n-    let _0: T = num::zero();\n-    let _1: T = num::one();\n+    let _0: T = Float::zero();\n+    let _1: T = Float::one();\n     let radix_t: T = num::cast(radix as int).unwrap();\n \n     // Special values\n@@ -558,8 +558,8 @@ pub fn from_str_radix_float<T: Float>(src: &str, radix: uint) -> Option<T> {\n             };\n \n             match (is_positive, exp) {\n-                (true,  Some(exp)) => num::pow(base, exp),\n-                (false, Some(exp)) => _1 / num::pow(base, exp),\n+                (true,  Some(exp)) => base.powi(exp as i32),\n+                (false, Some(exp)) => _1 / base.powi(exp as i32),\n                 (_, None)          => return None,\n             }\n         },\n@@ -578,8 +578,8 @@ pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n         num::cast(x).unwrap()\n     }\n \n-    let _0: T = num::zero();\n-    let _1: T = num::one();\n+    let _0: T = Int::zero();\n+    let _1: T = Int::one();\n     let is_signed = _0 > Int::min_value();\n \n     let (is_positive, src) =  match src.slice_shift_char() {"}, {"sha": "cdc18a19f513a880042f10b4085e5ca4840dc376", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -356,7 +356,7 @@ impl Path {\n                         Some(vec![SEP_BYTE])\n                     } else {\n                         let n = if is_abs { comps.len() } else { comps.len() - 1} +\n-                                comps.iter().map(|v| v.len()).sum();\n+                                comps.iter().map(|v| v.len()).sum(0);\n                         let mut v = Vec::with_capacity(n);\n                         let mut it = comps.into_iter();\n                         if !is_abs {"}, {"sha": "8c4d3e1ab4fc40c8b3d97c42163195d2cd14fdb1", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -781,7 +781,7 @@ impl Path {\n                         let prefix_ = s.slice_to(prefix_len(prefix));\n                         let n = prefix_.len() +\n                                 if is_abs { comps.len() } else { comps.len() - 1} +\n-                                comps.iter().map(|v| v.len()).sum();\n+                                comps.iter().map(|v| v.len()).sum(0);\n                         let mut s = String::with_capacity(n);\n                         match prefix {\n                             Some(DiskPrefix) => {"}, {"sha": "65eb987afeaf795d998cdb64fede47c32372110b", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -13,7 +13,6 @@\n \n use io::{mod, IoError, IoResult};\n use prelude::*;\n-use num;\n use sys::{last_error, retry, fs};\n use c_str::CString;\n use path::BytesContainer;\n@@ -57,8 +56,8 @@ pub fn unimpl() -> IoError {\n }\n \n // unix has nonzero values as errors\n-pub fn mkerr_libc<Int: num::Zero>(ret: Int) -> IoResult<()> {\n-    if !ret.is_zero() {\n+pub fn mkerr_libc<T: Int>(ret: T) -> IoResult<()> {\n+    if ret != Int::zero() {\n         Err(last_error())\n     } else {\n         Ok(())"}, {"sha": "939ae79facf7698364185d42aa66a7fca3200821", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -116,11 +116,11 @@ pub fn decode_error_detailed(errno: i32) -> IoError {\n }\n \n #[inline]\n-pub fn retry<I: PartialEq + num::One + Neg<I>> (f: || -> I) -> I {\n-    let minus_one = -num::one::<I>();\n+pub fn retry<T: Signed + Int> (f: || -> T) -> T {\n+    let one: T = Int::one();\n     loop {\n         let n = f();\n-        if n == minus_one && os::errno() == libc::EINTR as int { }\n+        if n == -one && os::errno() == libc::EINTR as int { }\n         else { return n }\n     }\n }"}, {"sha": "c21f34dcab077d7574589aa4a4263fff196ffec4", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -19,7 +19,6 @@ use parse::token;\n use ptr::P;\n \n use std::fmt;\n-use std::num::Zero;\n use std::fmt::Show;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n@@ -857,9 +856,9 @@ pub enum Sign {\n     Plus\n }\n \n-impl<T: PartialOrd+Zero> Sign {\n+impl<T: Int> Sign {\n     pub fn new(n: T) -> Sign {\n-        if n < Zero::zero() {\n+        if n < Int::zero() {\n             Minus\n         } else {\n             Plus"}, {"sha": "6be5bca552d1305761b4c9d7ff144768cae72141", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -16,7 +16,6 @@ use std::fmt::Show;\n use std::hash::Hash;\n use std::io;\n use std::mem;\n-use std::num::Zero;\n \n fn local_cmp<T:Float>(x: T, y: T) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n@@ -144,7 +143,6 @@ pub struct Summary<T> {\n }\n \n impl<T: FloatMath + FromPrimitive> Summary<T> {\n-\n     /// Construct a new summary of a sample set.\n     pub fn new(samples: &[T]) -> Summary<T> {\n         Summary {\n@@ -182,7 +180,7 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n                 // `lo`. Together `hi+lo` are exactly equal to `x+y`.\n                 let hi = x + y;\n                 let lo = y - (hi - x);\n-                if !lo.is_zero() {\n+                if lo != Float::zero() {\n                     partials[j] = lo;\n                     j += 1;\n                 }\n@@ -195,7 +193,7 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n                 partials.truncate(j+1);\n             }\n         }\n-        let zero: T = Zero::zero();\n+        let zero: T = Float::zero();\n         partials.iter().fold(zero, |p, q| p + *q)\n     }\n \n@@ -220,10 +218,10 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n \n     fn var(self) -> T {\n         if self.len() < 2 {\n-            Zero::zero()\n+            Float::zero()\n         } else {\n             let mean = self.mean();\n-            let mut v: T = Zero::zero();\n+            let mut v: T = Float::zero();\n             for s in self.iter() {\n                 let x = *s - mean;\n                 v = v + x*x;\n@@ -292,7 +290,7 @@ fn percentile_of_sorted<T: Float + FromPrimitive>(sorted_samples: &[T],\n     if sorted_samples.len() == 1 {\n         return sorted_samples[0];\n     }\n-    let zero: T = Zero::zero();\n+    let zero: T = Float::zero();\n     assert!(zero <= pct);\n     let hundred = FromPrimitive::from_uint(100).unwrap();\n     assert!(pct <= hundred);\n@@ -368,14 +366,14 @@ pub fn write_boxplot<T: Float + Show + FromPrimitive>(\n     let himag = ten.powf(s.max.abs().log10().floor());\n \n     // need to consider when the limit is zero\n-    let zero: T = Zero::zero();\n-    let lo = if lomag.is_zero() {\n+    let zero: T = Float::zero();\n+    let lo = if lomag == Float::zero() {\n         zero\n     } else {\n         (s.min / lomag).floor() * lomag\n     };\n \n-    let hi = if himag.is_zero() {\n+    let hi = if himag == Float::zero() {\n         zero\n     } else {\n         (s.max / himag).ceil() * himag\n@@ -1044,11 +1042,11 @@ mod tests {\n     }\n     #[test]\n     fn test_sum_f64s() {\n-        assert_eq!([0.5f64, 3.2321f64, 1.5678f64].sum(), 5.2999);\n+        assert_eq!([0.5f64, 3.2321f64, 1.5678f64].sum(0.0), 5.2999);\n     }\n     #[test]\n     fn test_sum_f64_between_ints_that_sum_to_0() {\n-        assert_eq!([1e30f64, 1.2f64, -1e30f64].sum(), 1.2);\n+        assert_eq!([1e30f64, 1.2f64, -1e30f64].sum(0.0), 1.2);\n     }\n }\n \n@@ -1060,7 +1058,7 @@ mod bench {\n     #[bench]\n     pub fn sum_three_items(b: &mut Bencher) {\n         b.iter(|| {\n-            [1e20f64, 1.5f64, -1e20f64].sum();\n+            [1e20f64, 1.5f64, -1e20f64].sum(0.0);\n         })\n     }\n     #[bench]\n@@ -1069,7 +1067,7 @@ mod bench {\n         let v = Vec::from_fn(500, |i| nums[i%5]);\n \n         b.iter(|| {\n-            v.as_slice().sum();\n+            v.as_slice().sum(0.0);\n         })\n     }\n }"}, {"sha": "674633c9422d7bb9dc3ecdd6e6fcff2de9fdbda6", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -153,7 +153,7 @@ impl UnicodeStrPrelude for str {\n \n     #[inline]\n     fn width(&self, is_cjk: bool) -> uint {\n-        self.chars().map(|c| c.width(is_cjk).unwrap_or(0)).sum()\n+        self.chars().map(|c| c.width(is_cjk).unwrap_or(0)).sum(0)\n     }\n \n     #[inline]"}, {"sha": "6bf594ce15d67c655b1545a39741c7d51cad1182", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -104,7 +104,7 @@ fn A(i: uint, j: uint) -> f64 {\n }\n \n fn dot(v: &[f64], u: &[f64]) -> f64 {\n-    v.iter().zip(u.iter()).map(|(a, b)| *a * *b).sum()\n+    v.iter().zip(u.iter()).map(|(a, b)| *a * *b).sum(0.0)\n }\n \n // Executes a closure in parallel over the given mutable slice. The closure `f`"}, {"sha": "e45c81f1a0cf9f1516a0d7cbabd439be84d4ba9b", "filename": "src/test/run-pass/issue-15673.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46333d527b138e8e202380a5ce4409dfe1414148/src%2Ftest%2Frun-pass%2Fissue-15673.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46333d527b138e8e202380a5ce4409dfe1414148/src%2Ftest%2Frun-pass%2Fissue-15673.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15673.rs?ref=46333d527b138e8e202380a5ce4409dfe1414148", "patch": "@@ -11,5 +11,5 @@\n use std::iter::AdditiveIterator;\n fn main() {\n     let x: [u64, ..3] = [1, 2, 3];\n-    assert_eq!(6, range(0, 3).map(|i| x[i]).sum());\n+    assert_eq!(6, range(0, 3).map(|i| x[i]).sum(0));\n }"}]}