{"sha": "ab88c19f15fe12625524a6474e0d63ead0333be0", "node_id": "C_kwDOAAsO6NoAKGFiODhjMTlmMTVmZTEyNjI1NTI0YTY0NzRlMGQ2M2VhZDAzMzNiZTA", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-10-05T11:57:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-05T11:57:32Z"}, "message": "Rollup merge of #101061 - RalfJung:panic-on-uninit, r=oli-obk\n\npanic-on-uninit: adjust checks to 0x01-filling\n\nNow that `mem::uninitiailized` actually fills memory with `0x01` (https://github.com/rust-lang/rust/pull/99182), we can make it panic in a few less cases without risking a lot more UB -- which hopefully slightly improves compatibility with some old code, and which might increase the chance that we can check inside arrays in the future.\n\nWe detect almost all of these with our lint, so authors of such code should still be warned -- but if this happens deep inside a dependency, the panic can be quite interruptive, so it might be better not to do it when there is no risk of LLVM UB.  Therefore, adjust the `might_permit_raw_init` logic to care primarily about LLVM UB. To my knowledge, it actually covers all cases of LLVM UB now.\n\nFixes https://github.com/rust-lang/rust/issues/66151\n\nCc ``@5225225``", "tree": {"sha": "eb5946f2c631f32f38b3fb2abee05eef4a84d37c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb5946f2c631f32f38b3fb2abee05eef4a84d37c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab88c19f15fe12625524a6474e0d63ead0333be0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjPXEsCRBK7hj4Ov3rIwAAfdoIAAmveTYNbMxcY14PprEK9Imx\n5OwmcelvcV3Jzbe5JwqrC8RQS768qQHZ7QgrVCY0kBAY4h9YWaUtVOfro90xlvjv\nmTv7ncae6oltDuk3uay/2K/xvfMaLIcl07CTegun5skb4UxQf3Wrz9dmBFsQ0yFr\nCCyeVPx69zG28+P10rghbozw8oRYuZonkOVnVXjj1vFU8aebMS3iCpvlExIXCEYh\nfVqrYjVITiNwcRV/f741/q26nGQwlJozObMwoWUM4yT5ZYXKNMplo3yJ/4tba02X\ngBhuad6HsxvTdezDFfMzb/0BMgDnsnUQvmsEgi6DhojIM/byylYBFogGSJy7+f4=\n=dfv2\n-----END PGP SIGNATURE-----\n", "payload": "tree eb5946f2c631f32f38b3fb2abee05eef4a84d37c\nparent f8f501997a4b293db86d6358c21a5de5642a5d66\nparent a0131f0a369dcb44c855d0ce483744e6efaa3df8\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1664971052 +0530\ncommitter GitHub <noreply@github.com> 1664971052 +0530\n\nRollup merge of #101061 - RalfJung:panic-on-uninit, r=oli-obk\n\npanic-on-uninit: adjust checks to 0x01-filling\n\nNow that `mem::uninitiailized` actually fills memory with `0x01` (https://github.com/rust-lang/rust/pull/99182), we can make it panic in a few less cases without risking a lot more UB -- which hopefully slightly improves compatibility with some old code, and which might increase the chance that we can check inside arrays in the future.\n\nWe detect almost all of these with our lint, so authors of such code should still be warned -- but if this happens deep inside a dependency, the panic can be quite interruptive, so it might be better not to do it when there is no risk of LLVM UB.  Therefore, adjust the `might_permit_raw_init` logic to care primarily about LLVM UB. To my knowledge, it actually covers all cases of LLVM UB now.\n\nFixes https://github.com/rust-lang/rust/issues/66151\n\nCc ``@5225225``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab88c19f15fe12625524a6474e0d63ead0333be0", "html_url": "https://github.com/rust-lang/rust/commit/ab88c19f15fe12625524a6474e0d63ead0333be0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab88c19f15fe12625524a6474e0d63ead0333be0/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8f501997a4b293db86d6358c21a5de5642a5d66", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8f501997a4b293db86d6358c21a5de5642a5d66", "html_url": "https://github.com/rust-lang/rust/commit/f8f501997a4b293db86d6358c21a5de5642a5d66"}, {"sha": "a0131f0a369dcb44c855d0ce483744e6efaa3df8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0131f0a369dcb44c855d0ce483744e6efaa3df8", "html_url": "https://github.com/rust-lang/rust/commit/a0131f0a369dcb44c855d0ce483744e6efaa3df8"}], "stats": {"total": 633, "additions": 393, "deletions": 240}, "files": [{"sha": "230f841cf4d57df80d22ffaebfa298e4e004331a", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab88c19f15fe12625524a6474e0d63ead0333be0/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab88c19f15fe12625524a6474e0d63ead0333be0/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=ab88c19f15fe12625524a6474e0d63ead0333be0", "patch": "@@ -32,7 +32,6 @@ extern crate rustc_middle;\n pub mod const_eval;\n mod errors;\n pub mod interpret;\n-mod might_permit_raw_init;\n pub mod transform;\n pub mod util;\n \n@@ -61,7 +60,6 @@ pub fn provide(providers: &mut Providers) {\n         const_eval::deref_mir_constant(tcx, param_env, value)\n     };\n     providers.permits_uninit_init =\n-        |tcx, ty| might_permit_raw_init::might_permit_raw_init(tcx, ty, InitKind::Uninit);\n-    providers.permits_zero_init =\n-        |tcx, ty| might_permit_raw_init::might_permit_raw_init(tcx, ty, InitKind::Zero);\n+        |tcx, ty| util::might_permit_raw_init(tcx, ty, InitKind::UninitMitigated0x01Fill);\n+    providers.permits_zero_init = |tcx, ty| util::might_permit_raw_init(tcx, ty, InitKind::Zero);\n }"}, {"sha": "37ffa19ccd6b9d7097c431545641129fdac547b6", "filename": "compiler/rustc_const_eval/src/might_permit_raw_init.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f8f501997a4b293db86d6358c21a5de5642a5d66/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f501997a4b293db86d6358c21a5de5642a5d66/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs?ref=f8f501997a4b293db86d6358c21a5de5642a5d66", "patch": "@@ -1,44 +0,0 @@\n-use crate::const_eval::CompileTimeInterpreter;\n-use crate::interpret::{InterpCx, MemoryKind, OpTy};\n-use rustc_middle::ty::layout::LayoutCx;\n-use rustc_middle::ty::{layout::TyAndLayout, ParamEnv, TyCtxt};\n-use rustc_session::Limit;\n-use rustc_target::abi::InitKind;\n-\n-pub fn might_permit_raw_init<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    ty: TyAndLayout<'tcx>,\n-    kind: InitKind,\n-) -> bool {\n-    let strict = tcx.sess.opts.unstable_opts.strict_init_checks;\n-\n-    if strict {\n-        let machine = CompileTimeInterpreter::new(\n-            Limit::new(0),\n-            /*can_access_statics:*/ false,\n-            /*check_alignment:*/ true,\n-        );\n-\n-        let mut cx = InterpCx::new(tcx, rustc_span::DUMMY_SP, ParamEnv::reveal_all(), machine);\n-\n-        let allocated = cx\n-            .allocate(ty, MemoryKind::Machine(crate::const_eval::MemoryKind::Heap))\n-            .expect(\"OOM: failed to allocate for uninit check\");\n-\n-        if kind == InitKind::Zero {\n-            cx.write_bytes_ptr(\n-                allocated.ptr,\n-                std::iter::repeat(0_u8).take(ty.layout.size().bytes_usize()),\n-            )\n-            .expect(\"failed to write bytes for zero valid check\");\n-        }\n-\n-        let ot: OpTy<'_, _> = allocated.into();\n-\n-        // Assume that if it failed, it's a validation failure.\n-        cx.validate_operand(&ot).is_ok()\n-    } else {\n-        let layout_cx = LayoutCx { tcx, param_env: ParamEnv::reveal_all() };\n-        ty.might_permit_raw_init(&layout_cx, kind)\n-    }\n-}"}, {"sha": "6ca71223391d2a5828b39b655cb113473cd0e46f", "filename": "compiler/rustc_const_eval/src/util/might_permit_raw_init.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ab88c19f15fe12625524a6474e0d63ead0333be0/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab88c19f15fe12625524a6474e0d63ead0333be0/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs?ref=ab88c19f15fe12625524a6474e0d63ead0333be0", "patch": "@@ -0,0 +1,151 @@\n+use rustc_middle::ty::layout::{LayoutCx, LayoutOf, TyAndLayout};\n+use rustc_middle::ty::{ParamEnv, TyCtxt};\n+use rustc_session::Limit;\n+use rustc_target::abi::{Abi, FieldsShape, InitKind, Scalar, Variants};\n+\n+use crate::const_eval::CompileTimeInterpreter;\n+use crate::interpret::{InterpCx, MemoryKind, OpTy};\n+\n+/// Determines if this type permits \"raw\" initialization by just transmuting some memory into an\n+/// instance of `T`.\n+///\n+/// `init_kind` indicates if the memory is zero-initialized or left uninitialized. We assume\n+/// uninitialized memory is mitigated by filling it with 0x01, which reduces the chance of causing\n+/// LLVM UB.\n+///\n+/// By default we check whether that operation would cause *LLVM UB*, i.e., whether the LLVM IR we\n+/// generate has UB or not. This is a mitigation strategy, which is why we are okay with accepting\n+/// Rust UB as long as there is no risk of miscompilations. The `strict_init_checks` can be set to\n+/// do a full check against Rust UB instead (in which case we will also ignore the 0x01-filling and\n+/// to the full uninit check).\n+pub fn might_permit_raw_init<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: TyAndLayout<'tcx>,\n+    kind: InitKind,\n+) -> bool {\n+    if tcx.sess.opts.unstable_opts.strict_init_checks {\n+        might_permit_raw_init_strict(ty, tcx, kind)\n+    } else {\n+        let layout_cx = LayoutCx { tcx, param_env: ParamEnv::reveal_all() };\n+        might_permit_raw_init_lax(ty, &layout_cx, kind)\n+    }\n+}\n+\n+/// Implements the 'strict' version of the `might_permit_raw_init` checks; see that function for\n+/// details.\n+fn might_permit_raw_init_strict<'tcx>(\n+    ty: TyAndLayout<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    kind: InitKind,\n+) -> bool {\n+    let machine = CompileTimeInterpreter::new(\n+        Limit::new(0),\n+        /*can_access_statics:*/ false,\n+        /*check_alignment:*/ true,\n+    );\n+\n+    let mut cx = InterpCx::new(tcx, rustc_span::DUMMY_SP, ParamEnv::reveal_all(), machine);\n+\n+    let allocated = cx\n+        .allocate(ty, MemoryKind::Machine(crate::const_eval::MemoryKind::Heap))\n+        .expect(\"OOM: failed to allocate for uninit check\");\n+\n+    if kind == InitKind::Zero {\n+        cx.write_bytes_ptr(\n+            allocated.ptr,\n+            std::iter::repeat(0_u8).take(ty.layout.size().bytes_usize()),\n+        )\n+        .expect(\"failed to write bytes for zero valid check\");\n+    }\n+\n+    let ot: OpTy<'_, _> = allocated.into();\n+\n+    // Assume that if it failed, it's a validation failure.\n+    // This does *not* actually check that references are dereferenceable, but since all types that\n+    // require dereferenceability also require non-null, we don't actually get any false negatives\n+    // due to this.\n+    cx.validate_operand(&ot).is_ok()\n+}\n+\n+/// Implements the 'lax' (default) version of the `might_permit_raw_init` checks; see that function for\n+/// details.\n+fn might_permit_raw_init_lax<'tcx>(\n+    this: TyAndLayout<'tcx>,\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    init_kind: InitKind,\n+) -> bool {\n+    let scalar_allows_raw_init = move |s: Scalar| -> bool {\n+        match init_kind {\n+            InitKind::Zero => {\n+                // The range must contain 0.\n+                s.valid_range(cx).contains(0)\n+            }\n+            InitKind::UninitMitigated0x01Fill => {\n+                // The range must include an 0x01-filled buffer.\n+                let mut val: u128 = 0x01;\n+                for _ in 1..s.size(cx).bytes() {\n+                    // For sizes >1, repeat the 0x01.\n+                    val = (val << 8) | 0x01;\n+                }\n+                s.valid_range(cx).contains(val)\n+            }\n+        }\n+    };\n+\n+    // Check the ABI.\n+    let valid = match this.abi {\n+        Abi::Uninhabited => false, // definitely UB\n+        Abi::Scalar(s) => scalar_allows_raw_init(s),\n+        Abi::ScalarPair(s1, s2) => scalar_allows_raw_init(s1) && scalar_allows_raw_init(s2),\n+        Abi::Vector { element: s, count } => count == 0 || scalar_allows_raw_init(s),\n+        Abi::Aggregate { .. } => true, // Fields are checked below.\n+    };\n+    if !valid {\n+        // This is definitely not okay.\n+        return false;\n+    }\n+\n+    // Special magic check for references and boxes (i.e., special pointer types).\n+    if let Some(pointee) = this.ty.builtin_deref(false) {\n+        let pointee = cx.layout_of(pointee.ty).expect(\"need to be able to compute layouts\");\n+        // We need to ensure that the LLVM attributes `aligned` and `dereferenceable(size)` are satisfied.\n+        if pointee.align.abi.bytes() > 1 {\n+            // 0x01-filling is not aligned.\n+            return false;\n+        }\n+        if pointee.size.bytes() > 0 {\n+            // A 'fake' integer pointer is not sufficiently dereferenceable.\n+            return false;\n+        }\n+    }\n+\n+    // If we have not found an error yet, we need to recursively descend into fields.\n+    match &this.fields {\n+        FieldsShape::Primitive | FieldsShape::Union { .. } => {}\n+        FieldsShape::Array { .. } => {\n+            // Arrays never have scalar layout in LLVM, so if the array is not actually\n+            // accessed, there is no LLVM UB -- therefore we can skip this.\n+        }\n+        FieldsShape::Arbitrary { offsets, .. } => {\n+            for idx in 0..offsets.len() {\n+                if !might_permit_raw_init_lax(this.field(cx, idx), cx, init_kind) {\n+                    // We found a field that is unhappy with this kind of initialization.\n+                    return false;\n+                }\n+            }\n+        }\n+    }\n+\n+    match &this.variants {\n+        Variants::Single { .. } => {\n+            // All fields of this single variant have already been checked above, there is nothing\n+            // else to do.\n+        }\n+        Variants::Multiple { .. } => {\n+            // We cannot tell LLVM anything about the details of this multi-variant layout, so\n+            // invalid values \"hidden\" inside the variant cannot cause LLVM trouble.\n+        }\n+    }\n+\n+    true\n+}"}, {"sha": "7a05cfd235faecd03dfce3339459ccd6f79c1ce8", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab88c19f15fe12625524a6474e0d63ead0333be0/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab88c19f15fe12625524a6474e0d63ead0333be0/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=ab88c19f15fe12625524a6474e0d63ead0333be0", "patch": "@@ -3,8 +3,10 @@ mod alignment;\n mod call_kind;\n pub mod collect_writes;\n mod find_self_call;\n+mod might_permit_raw_init;\n \n pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n pub use self::call_kind::{call_kind, CallDesugaringKind, CallKind};\n pub use self::find_self_call::find_self_call;\n+pub use self::might_permit_raw_init::might_permit_raw_init;"}, {"sha": "7171ca7bf89508cdfb65db31f743e70e01c97376", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 69, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ab88c19f15fe12625524a6474e0d63ead0333be0/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab88c19f15fe12625524a6474e0d63ead0333be0/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=ab88c19f15fe12625524a6474e0d63ead0333be0", "patch": "@@ -1392,7 +1392,7 @@ pub struct PointeeInfo {\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum InitKind {\n     Zero,\n-    Uninit,\n+    UninitMitigated0x01Fill,\n }\n \n /// Trait that needs to be implemented by the higher-level type representation\n@@ -1498,72 +1498,4 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n             Abi::Aggregate { sized } => sized && self.size.bytes() == 0,\n         }\n     }\n-\n-    /// Determines if this type permits \"raw\" initialization by just transmuting some\n-    /// memory into an instance of `T`.\n-    ///\n-    /// `init_kind` indicates if the memory is zero-initialized or left uninitialized.\n-    ///\n-    /// This code is intentionally conservative, and will not detect\n-    /// * zero init of an enum whose 0 variant does not allow zero initialization\n-    /// * making uninitialized types who have a full valid range (ints, floats, raw pointers)\n-    /// * Any form of invalid value being made inside an array (unless the value is uninhabited)\n-    ///\n-    /// A strict form of these checks that uses const evaluation exists in\n-    /// `rustc_const_eval::might_permit_raw_init`, and a tracking issue for making these checks\n-    /// stricter is <https://github.com/rust-lang/rust/issues/66151>.\n-    ///\n-    /// FIXME: Once all the conservatism is removed from here, and the checks are ran by default,\n-    /// we can use the const evaluation checks always instead.\n-    pub fn might_permit_raw_init<C>(self, cx: &C, init_kind: InitKind) -> bool\n-    where\n-        Self: Copy,\n-        Ty: TyAbiInterface<'a, C>,\n-        C: HasDataLayout,\n-    {\n-        let scalar_allows_raw_init = move |s: Scalar| -> bool {\n-            match init_kind {\n-                InitKind::Zero => {\n-                    // The range must contain 0.\n-                    s.valid_range(cx).contains(0)\n-                }\n-                InitKind::Uninit => {\n-                    // The range must include all values.\n-                    s.is_always_valid(cx)\n-                }\n-            }\n-        };\n-\n-        // Check the ABI.\n-        let valid = match self.abi {\n-            Abi::Uninhabited => false, // definitely UB\n-            Abi::Scalar(s) => scalar_allows_raw_init(s),\n-            Abi::ScalarPair(s1, s2) => scalar_allows_raw_init(s1) && scalar_allows_raw_init(s2),\n-            Abi::Vector { element: s, count } => count == 0 || scalar_allows_raw_init(s),\n-            Abi::Aggregate { .. } => true, // Fields are checked below.\n-        };\n-        if !valid {\n-            // This is definitely not okay.\n-            return false;\n-        }\n-\n-        // If we have not found an error yet, we need to recursively descend into fields.\n-        match &self.fields {\n-            FieldsShape::Primitive | FieldsShape::Union { .. } => {}\n-            FieldsShape::Array { .. } => {\n-                // FIXME(#66151): For now, we are conservative and do not check arrays by default.\n-            }\n-            FieldsShape::Arbitrary { offsets, .. } => {\n-                for idx in 0..offsets.len() {\n-                    if !self.field(cx, idx).might_permit_raw_init(cx, init_kind) {\n-                        // We found a field that is unhappy with this kind of initialization.\n-                        return false;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // FIXME(#66151): For now, we are conservative and do not check `self.variants`.\n-        true\n-    }\n }"}, {"sha": "6b5612dda90a7c371d67dd40a244849625bfe609", "filename": "src/test/ui/consts/assert-type-intrinsics.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab88c19f15fe12625524a6474e0d63ead0333be0/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab88c19f15fe12625524a6474e0d63ead0333be0/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.rs?ref=ab88c19f15fe12625524a6474e0d63ead0333be0", "patch": "@@ -11,12 +11,15 @@ fn main() {\n     use std::mem::MaybeUninit;\n \n     const _BAD1: () = unsafe {\n-        MaybeUninit::<!>::uninit().assume_init();\n+        intrinsics::assert_inhabited::<!>(); //~ERROR: any use of this value will cause an error\n+        //~^WARN: previously accepted\n     };\n     const _BAD2: () = {\n-        intrinsics::assert_uninit_valid::<bool>();\n+        intrinsics::assert_uninit_valid::<!>(); //~ERROR: any use of this value will cause an error\n+        //~^WARN: previously accepted\n     };\n     const _BAD3: () = {\n-        intrinsics::assert_zero_valid::<&'static i32>();\n+        intrinsics::assert_zero_valid::<&'static i32>(); //~ERROR: any use of this value will cause an error\n+        //~^WARN: previously accepted\n     };\n }"}, {"sha": "9f97d8367056fd765c59f37bded695375e18d03c", "filename": "src/test/ui/consts/assert-type-intrinsics.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ab88c19f15fe12625524a6474e0d63ead0333be0/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab88c19f15fe12625524a6474e0d63ead0333be0/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.stderr?ref=ab88c19f15fe12625524a6474e0d63ead0333be0", "patch": "@@ -3,26 +3,26 @@ error: any use of this value will cause an error\n    |\n LL |     const _BAD1: () = unsafe {\n    |     ---------------\n-LL |         MaybeUninit::<!>::uninit().assume_init();\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to instantiate uninhabited type `!`\n+LL |         intrinsics::assert_inhabited::<!>();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to instantiate uninhabited type `!`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n    = note: `#[deny(const_err)]` on by default\n \n error: any use of this value will cause an error\n-  --> $DIR/assert-type-intrinsics.rs:17:9\n+  --> $DIR/assert-type-intrinsics.rs:18:9\n    |\n LL |     const _BAD2: () = {\n    |     ---------------\n-LL |         intrinsics::assert_uninit_valid::<bool>();\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to leave type `bool` uninitialized, which is invalid\n+LL |         intrinsics::assert_uninit_valid::<!>();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to instantiate uninhabited type `!`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/assert-type-intrinsics.rs:20:9\n+  --> $DIR/assert-type-intrinsics.rs:22:9\n    |\n LL |     const _BAD3: () = {\n    |     ---------------\n@@ -40,29 +40,29 @@ error: any use of this value will cause an error\n    |\n LL |     const _BAD1: () = unsafe {\n    |     ---------------\n-LL |         MaybeUninit::<!>::uninit().assume_init();\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to instantiate uninhabited type `!`\n+LL |         intrinsics::assert_inhabited::<!>();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to instantiate uninhabited type `!`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n    = note: `#[deny(const_err)]` on by default\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/assert-type-intrinsics.rs:17:9\n+  --> $DIR/assert-type-intrinsics.rs:18:9\n    |\n LL |     const _BAD2: () = {\n    |     ---------------\n-LL |         intrinsics::assert_uninit_valid::<bool>();\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to leave type `bool` uninitialized, which is invalid\n+LL |         intrinsics::assert_uninit_valid::<!>();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to instantiate uninhabited type `!`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n    = note: `#[deny(const_err)]` on by default\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/assert-type-intrinsics.rs:20:9\n+  --> $DIR/assert-type-intrinsics.rs:22:9\n    |\n LL |     const _BAD3: () = {\n    |     ---------------"}, {"sha": "ae44ffd29bd56ec4c05eb890a38709823b8d5751", "filename": "src/test/ui/intrinsics/panic-uninitialized-zeroed.rs", "status": "modified", "additions": 168, "deletions": 82, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/ab88c19f15fe12625524a6474e0d63ead0333be0/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab88c19f15fe12625524a6474e0d63ead0333be0/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs?ref=ab88c19f15fe12625524a6474e0d63ead0333be0", "patch": "@@ -34,6 +34,12 @@ enum OneVariant_NonZero {\n     DeadVariant(Bar),\n }\n \n+#[allow(dead_code, non_camel_case_types)]\n+enum OneVariant_Ref {\n+    Variant(&'static i32),\n+    DeadVariant(Bar),\n+}\n+\n // An `Aggregate` abi enum where 0 is not a valid discriminant.\n #[allow(dead_code)]\n #[repr(i32)]\n@@ -63,6 +69,7 @@ enum ZeroIsValid {\n     One(NonNull<()>) = 1,\n }\n \n+#[track_caller]\n fn test_panic_msg<T>(op: impl (FnOnce() -> T) + panic::UnwindSafe, msg: &str) {\n     let err = panic::catch_unwind(op).err();\n     assert_eq!(\n@@ -71,6 +78,15 @@ fn test_panic_msg<T>(op: impl (FnOnce() -> T) + panic::UnwindSafe, msg: &str) {\n     );\n }\n \n+#[track_caller]\n+fn test_panic_msg_only_if_strict<T>(op: impl (FnOnce() -> T) + panic::UnwindSafe, msg: &str) {\n+    let err = panic::catch_unwind(op).err();\n+    assert_eq!(\n+        err.as_ref().and_then(|a| a.downcast_ref::<&str>()),\n+        if cfg!(strict) { Some(&msg) } else { None },\n+    );\n+}\n+\n fn main() {\n     unsafe {\n         // Uninhabited types\n@@ -139,92 +155,216 @@ fn main() {\n             \"attempted to instantiate uninhabited type `[Bar; 2]`\"\n         );\n \n-        // Types that do not like zero-initialziation\n+        // Types that don't allow either.\n         test_panic_msg(\n-            || mem::uninitialized::<fn()>(),\n-            \"attempted to leave type `fn()` uninitialized, which is invalid\"\n+            || mem::zeroed::<&i32>(),\n+            \"attempted to zero-initialize type `&i32`, which is invalid\"\n         );\n         test_panic_msg(\n-            || mem::zeroed::<fn()>(),\n-            \"attempted to zero-initialize type `fn()`, which is invalid\"\n+            || mem::uninitialized::<&i32>(),\n+            \"attempted to leave type `&i32` uninitialized, which is invalid\"\n         );\n \n         test_panic_msg(\n-            || mem::uninitialized::<*const dyn Send>(),\n-            \"attempted to leave type `*const dyn core::marker::Send` uninitialized, which is invalid\"\n+            || mem::zeroed::<Box<[i32; 0]>>(),\n+            \"attempted to zero-initialize type `alloc::boxed::Box<[i32; 0]>`, which is invalid\"\n+        );\n+        test_panic_msg(\n+            || mem::uninitialized::<Box<[i32; 0]>>(),\n+            \"attempted to leave type `alloc::boxed::Box<[i32; 0]>` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<Box<u8>>(),\n+            \"attempted to zero-initialize type `alloc::boxed::Box<u8>`, which is invalid\"\n         );\n+        test_panic_msg(\n+            || mem::uninitialized::<Box<u8>>(),\n+            \"attempted to leave type `alloc::boxed::Box<u8>` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<&[i32]>(),\n+            \"attempted to zero-initialize type `&[i32]`, which is invalid\"\n+        );\n+        test_panic_msg(\n+            || mem::uninitialized::<&[i32]>(),\n+            \"attempted to leave type `&[i32]` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<&(u8, [u8])>(),\n+            \"attempted to zero-initialize type `&(u8, [u8])`, which is invalid\"\n+        );\n+        test_panic_msg(\n+            || mem::uninitialized::<&(u8, [u8])>(),\n+            \"attempted to leave type `&(u8, [u8])` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<&dyn Send>(),\n+            \"attempted to zero-initialize type `&dyn core::marker::Send`, which is invalid\"\n+        );\n+        test_panic_msg(\n+            || mem::uninitialized::<&dyn Send>(),\n+            \"attempted to leave type `&dyn core::marker::Send` uninitialized, which is invalid\"\n+        );\n+\n         test_panic_msg(\n             || mem::zeroed::<*const dyn Send>(),\n             \"attempted to zero-initialize type `*const dyn core::marker::Send`, which is invalid\"\n         );\n+        test_panic_msg(\n+            || mem::uninitialized::<*const dyn Send>(),\n+            \"attempted to leave type `*const dyn core::marker::Send` uninitialized, which is invalid\"\n+        );\n \n         test_panic_msg(\n-            || mem::uninitialized::<(NonNull<u32>, u32, u32)>(),\n-            \"attempted to leave type `(core::ptr::non_null::NonNull<u32>, u32, u32)` uninitialized, \\\n+            || mem::uninitialized::<NoNullVariant>(),\n+            \"attempted to leave type `NoNullVariant` uninitialized, \\\n+                which is invalid\"\n+        );\n+        test_panic_msg(\n+            || mem::zeroed::<NoNullVariant>(),\n+            \"attempted to zero-initialize type `NoNullVariant`, \\\n                 which is invalid\"\n         );\n \n         test_panic_msg(\n-            || mem::zeroed::<(NonNull<u32>, u32, u32)>(),\n-            \"attempted to zero-initialize type `(core::ptr::non_null::NonNull<u32>, u32, u32)`, \\\n+            || mem::zeroed::<OneVariant_Ref>(),\n+            \"attempted to zero-initialize type `OneVariant_Ref`, \\\n                 which is invalid\"\n         );\n+        test_panic_msg(\n+            || mem::uninitialized::<OneVariant_Ref>(),\n+            \"attempted to leave type `OneVariant_Ref` uninitialized, which is invalid\"\n+        );\n \n+        // Types where both are invalid, but we allow uninit since the 0x01-filling is not LLVM UB.\n         test_panic_msg(\n-            || mem::uninitialized::<OneVariant_NonZero>(),\n-            \"attempted to leave type `OneVariant_NonZero` uninitialized, \\\n+            || mem::zeroed::<fn()>(),\n+            \"attempted to zero-initialize type `fn()`, which is invalid\"\n+        );\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<fn()>(),\n+            \"attempted to leave type `fn()` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<&()>(),\n+            \"attempted to zero-initialize type `&()`, which is invalid\"\n+        );\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<&()>(),\n+            \"attempted to leave type `&()` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<&[u8]>(),\n+            \"attempted to zero-initialize type `&[u8]`, which is invalid\"\n+        );\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<&[u8]>(),\n+            \"attempted to leave type `&[u8]` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<&str>(),\n+            \"attempted to zero-initialize type `&str`, which is invalid\"\n+        );\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<&str>(),\n+            \"attempted to leave type `&str` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<(NonNull<u32>, u32, u32)>(),\n+            \"attempted to zero-initialize type `(core::ptr::non_null::NonNull<u32>, u32, u32)`, \\\n                 which is invalid\"\n         );\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<(NonNull<u32>, u32, u32)>(),\n+            \"attempted to leave type `(core::ptr::non_null::NonNull<u32>, u32, u32)` uninitialized, which is invalid\"\n+        );\n+\n         test_panic_msg(\n             || mem::zeroed::<OneVariant_NonZero>(),\n             \"attempted to zero-initialize type `OneVariant_NonZero`, \\\n                 which is invalid\"\n         );\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<OneVariant_NonZero>(),\n+            \"attempted to leave type `OneVariant_NonZero` uninitialized, which is invalid\"\n+        );\n \n+        // Types where both are invalid but we allow the zeroed form since it is not LLVM UB.\n+        test_panic_msg_only_if_strict(\n+            || mem::zeroed::<LR_NonZero>(),\n+            \"attempted to zero-initialize type `LR_NonZero`, which is invalid\"\n+        );\n         test_panic_msg(\n             || mem::uninitialized::<LR_NonZero>(),\n             \"attempted to leave type `LR_NonZero` uninitialized, which is invalid\"\n         );\n \n+        test_panic_msg_only_if_strict(\n+            || mem::zeroed::<ManuallyDrop<LR_NonZero>>(),\n+            \"attempted to zero-initialize type `core::mem::manually_drop::ManuallyDrop<LR_NonZero>`, \\\n+             which is invalid\"\n+        );\n         test_panic_msg(\n             || mem::uninitialized::<ManuallyDrop<LR_NonZero>>(),\n             \"attempted to leave type `core::mem::manually_drop::ManuallyDrop<LR_NonZero>` uninitialized, \\\n              which is invalid\"\n         );\n \n-        test_panic_msg(\n-            || mem::uninitialized::<NoNullVariant>(),\n-            \"attempted to leave type `NoNullVariant` uninitialized, \\\n-                which is invalid\"\n+        // Some strict-only things\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<i32>(),\n+            \"attempted to leave type `i32` uninitialized, which is invalid\"\n         );\n \n-        test_panic_msg(\n-            || mem::zeroed::<NoNullVariant>(),\n-            \"attempted to zero-initialize type `NoNullVariant`, \\\n-                which is invalid\"\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<*const ()>(),\n+            \"attempted to leave type `*const ()` uninitialized, which is invalid\"\n         );\n \n-        // Types that can be zero, but not uninit.\n-        test_panic_msg(\n-            || mem::uninitialized::<bool>(),\n-            \"attempted to leave type `bool` uninitialized, which is invalid\"\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<[i32; 1]>(),\n+            \"attempted to leave type `[i32; 1]` uninitialized, which is invalid\"\n         );\n \n+        test_panic_msg_only_if_strict(\n+            || mem::zeroed::<[NonNull<()>; 1]>(),\n+            \"attempted to zero-initialize type `[core::ptr::non_null::NonNull<()>; 1]`, which is invalid\"\n+        );\n+\n+        // Types that can be zero, but not uninit (though some are mitigated).\n+        let _val = mem::zeroed::<LR>();\n         test_panic_msg(\n             || mem::uninitialized::<LR>(),\n             \"attempted to leave type `LR` uninitialized, which is invalid\"\n         );\n \n+        let _val = mem::zeroed::<ManuallyDrop<LR>>();\n         test_panic_msg(\n             || mem::uninitialized::<ManuallyDrop<LR>>(),\n             \"attempted to leave type `core::mem::manually_drop::ManuallyDrop<LR>` uninitialized, which is invalid\"\n         );\n \n-        // Some things that should work.\n         let _val = mem::zeroed::<bool>();\n-        let _val = mem::zeroed::<LR>();\n-        let _val = mem::zeroed::<ManuallyDrop<LR>>();\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<bool>(),\n+            \"attempted to leave type `bool` uninitialized, which is invalid\"\n+        );\n+\n         let _val = mem::zeroed::<OneVariant>();\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<OneVariant>(),\n+            \"attempted to leave type `OneVariant` uninitialized, which is invalid\"\n+        );\n+\n+        // Some things that are actually allowed.\n         let _val = mem::zeroed::<Option<&'static i32>>();\n         let _val = mem::zeroed::<MaybeUninit<NonNull<u32>>>();\n         let _val = mem::zeroed::<[!; 0]>();\n@@ -233,59 +373,5 @@ fn main() {\n         let _val = mem::uninitialized::<[!; 0]>();\n         let _val = mem::uninitialized::<()>();\n         let _val = mem::uninitialized::<ZeroSized>();\n-\n-        if cfg!(strict) {\n-            test_panic_msg(\n-                || mem::uninitialized::<i32>(),\n-                \"attempted to leave type `i32` uninitialized, which is invalid\"\n-            );\n-\n-            test_panic_msg(\n-                || mem::uninitialized::<*const ()>(),\n-                \"attempted to leave type `*const ()` uninitialized, which is invalid\"\n-            );\n-\n-            test_panic_msg(\n-                || mem::uninitialized::<[i32; 1]>(),\n-                \"attempted to leave type `[i32; 1]` uninitialized, which is invalid\"\n-            );\n-\n-            test_panic_msg(\n-                || mem::zeroed::<NonNull<()>>(),\n-                \"attempted to zero-initialize type `core::ptr::non_null::NonNull<()>`, which is invalid\"\n-            );\n-\n-            test_panic_msg(\n-                || mem::zeroed::<[NonNull<()>; 1]>(),\n-                \"attempted to zero-initialize type `[core::ptr::non_null::NonNull<()>; 1]`, which is invalid\"\n-            );\n-\n-            // FIXME(#66151) we conservatively do not error here yet (by default).\n-            test_panic_msg(\n-                || mem::zeroed::<LR_NonZero>(),\n-                \"attempted to zero-initialize type `LR_NonZero`, which is invalid\"\n-            );\n-\n-            test_panic_msg(\n-                || mem::zeroed::<ManuallyDrop<LR_NonZero>>(),\n-                \"attempted to zero-initialize type `core::mem::manually_drop::ManuallyDrop<LR_NonZero>`, \\\n-                 which is invalid\"\n-            );\n-        } else {\n-            // These are UB because they have not been officially blessed, but we await the resolution\n-            // of <https://github.com/rust-lang/unsafe-code-guidelines/issues/71> before doing\n-            // anything about that.\n-            let _val = mem::uninitialized::<i32>();\n-            let _val = mem::uninitialized::<*const ()>();\n-\n-            // These are UB, but best to test them to ensure we don't become unintentionally\n-            // stricter.\n-\n-            // It's currently unchecked to create invalid enums and values inside arrays.\n-            let _val = mem::zeroed::<LR_NonZero>();\n-            let _val = mem::zeroed::<[LR_NonZero; 1]>();\n-            let _val = mem::zeroed::<[NonNull<()>; 1]>();\n-            let _val = mem::uninitialized::<[NonNull<()>; 1]>();\n-        }\n     }\n }"}, {"sha": "946a0e3886139f992001204e0e960aad7444a9b8", "filename": "src/test/ui/lint/invalid_value.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab88c19f15fe12625524a6474e0d63ead0333be0/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab88c19f15fe12625524a6474e0d63ead0333be0/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs?ref=ab88c19f15fe12625524a6474e0d63ead0333be0", "patch": "@@ -88,6 +88,9 @@ fn main() {\n         let _val: NonNull<i32> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: NonNull<i32> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: (NonZeroU32, i32) = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: (NonZeroU32, i32) = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         let _val: *const dyn Send = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: *const dyn Send = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n@@ -133,7 +136,7 @@ fn main() {\n         let _val: Result<i32, i32> = mem::zeroed();\n         let _val: Result<i32, i32> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n-        // Some things that happen to work due to rustc implementation details,\n+        // Some things that happen to be UB-free due to rustc implementation details,\n         // but are not guaranteed to keep working.\n         let _val: OneFruit = mem::zeroed();\n         let _val: OneFruit = mem::uninitialized();"}, {"sha": "3901692001abd7bfef6567d124bfa5607dcb41d5", "filename": "src/test/ui/lint/invalid_value.stderr", "status": "modified", "additions": 47, "deletions": 25, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ab88c19f15fe12625524a6474e0d63ead0333be0/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab88c19f15fe12625524a6474e0d63ead0333be0/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr?ref=ab88c19f15fe12625524a6474e0d63ead0333be0", "patch": "@@ -315,8 +315,30 @@ LL |         let _val: NonNull<i32> = mem::uninitialized();\n    |\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n+error: the type `(NonZeroU32, i32)` does not permit zero-initialization\n+  --> $DIR/invalid_value.rs:91:39\n+   |\n+LL |         let _val: (NonZeroU32, i32) = mem::zeroed();\n+   |                                       ^^^^^^^^^^^^^\n+   |                                       |\n+   |                                       this code causes undefined behavior when executed\n+   |                                       help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+   = note: `std::num::NonZeroU32` must be non-null\n+\n+error: the type `(NonZeroU32, i32)` does not permit being left uninitialized\n+  --> $DIR/invalid_value.rs:92:39\n+   |\n+LL |         let _val: (NonZeroU32, i32) = mem::uninitialized();\n+   |                                       ^^^^^^^^^^^^^^^^^^^^\n+   |                                       |\n+   |                                       this code causes undefined behavior when executed\n+   |                                       help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+   = note: `std::num::NonZeroU32` must be non-null\n+\n error: the type `*const dyn Send` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:91:37\n+  --> $DIR/invalid_value.rs:94:37\n    |\n LL |         let _val: *const dyn Send = mem::zeroed();\n    |                                     ^^^^^^^^^^^^^\n@@ -327,7 +349,7 @@ LL |         let _val: *const dyn Send = mem::zeroed();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `*const dyn Send` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:92:37\n+  --> $DIR/invalid_value.rs:95:37\n    |\n LL |         let _val: *const dyn Send = mem::uninitialized();\n    |                                     ^^^^^^^^^^^^^^^^^^^^\n@@ -338,7 +360,7 @@ LL |         let _val: *const dyn Send = mem::uninitialized();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `[fn(); 2]` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:94:31\n+  --> $DIR/invalid_value.rs:97:31\n    |\n LL |         let _val: [fn(); 2] = mem::zeroed();\n    |                               ^^^^^^^^^^^^^\n@@ -349,7 +371,7 @@ LL |         let _val: [fn(); 2] = mem::zeroed();\n    = note: function pointers must be non-null\n \n error: the type `[fn(); 2]` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:95:31\n+  --> $DIR/invalid_value.rs:98:31\n    |\n LL |         let _val: [fn(); 2] = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -360,7 +382,7 @@ LL |         let _val: [fn(); 2] = mem::uninitialized();\n    = note: function pointers must be non-null\n \n error: the type `TwoUninhabited` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:97:36\n+  --> $DIR/invalid_value.rs:100:36\n    |\n LL |         let _val: TwoUninhabited = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n@@ -375,7 +397,7 @@ LL | enum TwoUninhabited {\n    | ^^^^^^^^^^^^^^^^^^^\n \n error: the type `TwoUninhabited` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:98:36\n+  --> $DIR/invalid_value.rs:101:36\n    |\n LL |         let _val: TwoUninhabited = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n@@ -390,7 +412,7 @@ LL | enum TwoUninhabited {\n    | ^^^^^^^^^^^^^^^^^^^\n \n error: the type `OneFruitNonZero` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:100:37\n+  --> $DIR/invalid_value.rs:103:37\n    |\n LL |         let _val: OneFruitNonZero = mem::zeroed();\n    |                                     ^^^^^^^^^^^^^\n@@ -405,7 +427,7 @@ LL |     Banana(NonZeroU32),\n    |            ^^^^^^^^^^\n \n error: the type `OneFruitNonZero` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:101:37\n+  --> $DIR/invalid_value.rs:104:37\n    |\n LL |         let _val: OneFruitNonZero = mem::uninitialized();\n    |                                     ^^^^^^^^^^^^^^^^^^^^\n@@ -420,7 +442,7 @@ LL |     Banana(NonZeroU32),\n    |            ^^^^^^^^^^\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:105:26\n+  --> $DIR/invalid_value.rs:108:26\n    |\n LL |         let _val: bool = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -431,7 +453,7 @@ LL |         let _val: bool = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `Wrap<char>` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:108:32\n+  --> $DIR/invalid_value.rs:111:32\n    |\n LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -446,7 +468,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `NonBig` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:111:28\n+  --> $DIR/invalid_value.rs:114:28\n    |\n LL |         let _val: NonBig = mem::uninitialized();\n    |                            ^^^^^^^^^^^^^^^^^^^^\n@@ -457,7 +479,7 @@ LL |         let _val: NonBig = mem::uninitialized();\n    = note: `NonBig` must be initialized inside its custom valid range\n \n error: the type `Fruit` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:114:27\n+  --> $DIR/invalid_value.rs:117:27\n    |\n LL |         let _val: Fruit = mem::uninitialized();\n    |                           ^^^^^^^^^^^^^^^^^^^^\n@@ -472,7 +494,7 @@ LL | enum Fruit {\n    | ^^^^^^^^^^\n \n error: the type `[bool; 2]` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:117:31\n+  --> $DIR/invalid_value.rs:120:31\n    |\n LL |         let _val: [bool; 2] = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -483,7 +505,7 @@ LL |         let _val: [bool; 2] = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `i32` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:120:25\n+  --> $DIR/invalid_value.rs:123:25\n    |\n LL |         let _val: i32 = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -494,7 +516,7 @@ LL |         let _val: i32 = mem::uninitialized();\n    = note: integers must not be uninitialized\n \n error: the type `f32` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:123:25\n+  --> $DIR/invalid_value.rs:126:25\n    |\n LL |         let _val: f32 = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -505,7 +527,7 @@ LL |         let _val: f32 = mem::uninitialized();\n    = note: floats must not be uninitialized\n \n error: the type `*const ()` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:126:31\n+  --> $DIR/invalid_value.rs:129:31\n    |\n LL |         let _val: *const () = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -516,7 +538,7 @@ LL |         let _val: *const () = mem::uninitialized();\n    = note: raw pointers must not be uninitialized\n \n error: the type `*const [()]` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:129:33\n+  --> $DIR/invalid_value.rs:132:33\n    |\n LL |         let _val: *const [()] = mem::uninitialized();\n    |                                 ^^^^^^^^^^^^^^^^^^^^\n@@ -527,7 +549,7 @@ LL |         let _val: *const [()] = mem::uninitialized();\n    = note: raw pointers must not be uninitialized\n \n error: the type `Result<i32, i32>` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:134:38\n+  --> $DIR/invalid_value.rs:137:38\n    |\n LL |         let _val: Result<i32, i32> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n@@ -542,7 +564,7 @@ LL | pub enum Result<T, E> {\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:142:34\n+  --> $DIR/invalid_value.rs:145:34\n    |\n LL |         let _val: &'static i32 = mem::transmute(0usize);\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n@@ -553,7 +575,7 @@ LL |         let _val: &'static i32 = mem::transmute(0usize);\n    = note: references must be non-null\n \n error: the type `&[i32]` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:143:36\n+  --> $DIR/invalid_value.rs:146:36\n    |\n LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -564,7 +586,7 @@ LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    = note: references must be non-null\n \n error: the type `NonZeroU32` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:144:32\n+  --> $DIR/invalid_value.rs:147:32\n    |\n LL |         let _val: NonZeroU32 = mem::transmute(0);\n    |                                ^^^^^^^^^^^^^^^^^\n@@ -575,7 +597,7 @@ LL |         let _val: NonZeroU32 = mem::transmute(0);\n    = note: `std::num::NonZeroU32` must be non-null\n \n error: the type `NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:147:34\n+  --> $DIR/invalid_value.rs:150:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -586,7 +608,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:148:34\n+  --> $DIR/invalid_value.rs:151:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -597,7 +619,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:149:26\n+  --> $DIR/invalid_value.rs:152:26\n    |\n LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -607,5 +629,5 @@ LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |\n    = note: booleans must be either `true` or `false`\n \n-error: aborting due to 48 previous errors\n+error: aborting due to 50 previous errors\n "}]}