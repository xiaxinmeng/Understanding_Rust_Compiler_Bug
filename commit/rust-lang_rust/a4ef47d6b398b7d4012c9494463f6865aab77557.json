{"sha": "a4ef47d6b398b7d4012c9494463f6865aab77557", "node_id": "C_kwDOAAsO6NoAKGE0ZWY0N2Q2YjM5OGI3ZDQwMTJjOTQ5NDQ2M2Y2ODY1YWFiNzc1NTc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-20T22:35:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-20T22:35:15Z"}, "message": "Rollup merge of #105897 - oli-obk:tait_patterns, r=TaKO8Ki\n\nFix an opaque type ICE\n\nfixes #104551\n\nThe issue is that if you have\n\n```rust\ntype T = impl Sized;\nlet (_a, _b): T = ..\n```\n\nwe have only the type annotation `T`, but want to use that ascription for `_a` and `_b`, so what we generate is a type ascription plus a field projection saying `_a`'s type is `T::0`. Of course `T` has no fields. Of course we could also not generate type annotations for projections into opaque types at all, but that's more fragile, as we now have to make sure that https://github.com/rust-lang/rust/blob/12bbdbdb440119a0b86d2ee742ec1460cdb2c5b9/compiler/rustc_mir_build/src/build/matches/mod.rs#L709 doesn't have any arm that introduces a user type annotation except for `PatKind::Binding`.", "tree": {"sha": "025f84899e5a8db3ef6dac70f060a58478ec7e7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/025f84899e5a8db3ef6dac70f060a58478ec7e7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4ef47d6b398b7d4012c9494463f6865aab77557", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjojijCRBK7hj4Ov3rIwAAmA0IAGq8869KGRAt/N6jIi/f1qq3\nHhZXVjF4sYMht9NLCTmzmvNjUBXEQXx9ot/NbgY5NUf3znF0zHuq5D4w7ZFayweo\no96+vDWOZg2d/gf/wj2VvVUesnhjpOw4sRzaD6Z1j5zBFBLslVEA9tXpMF9unrP+\nwuWerVeOsMAPHMJcc2YnQ2v9w9/rA/uU+7mXxtkDZ1KqmD1cLoUh+vEHxPzP+kjt\n8hT2CzZenLYvNIpQd1YcZoWx22HjZTf2gKQ0EAsU1LlmasXBHusn6pnUmQPgyKNx\nPQa7FV9tElqG7DB8EYAIqSQoy/plee8EfASZWRT0kFhou9ljviHjiqkG4NThDYA=\n=wqB/\n-----END PGP SIGNATURE-----\n", "payload": "tree 025f84899e5a8db3ef6dac70f060a58478ec7e7d\nparent 4726e514d70d53b38530e3608d364bf1ada6bd97\nparent c9588d5bf8db14d80249b029b07f79026956ae85\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1671575715 +0100\ncommitter GitHub <noreply@github.com> 1671575715 +0100\n\nRollup merge of #105897 - oli-obk:tait_patterns, r=TaKO8Ki\n\nFix an opaque type ICE\n\nfixes #104551\n\nThe issue is that if you have\n\n```rust\ntype T = impl Sized;\nlet (_a, _b): T = ..\n```\n\nwe have only the type annotation `T`, but want to use that ascription for `_a` and `_b`, so what we generate is a type ascription plus a field projection saying `_a`'s type is `T::0`. Of course `T` has no fields. Of course we could also not generate type annotations for projections into opaque types at all, but that's more fragile, as we now have to make sure that https://github.com/rust-lang/rust/blob/12bbdbdb440119a0b86d2ee742ec1460cdb2c5b9/compiler/rustc_mir_build/src/build/matches/mod.rs#L709 doesn't have any arm that introduces a user type annotation except for `PatKind::Binding`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4ef47d6b398b7d4012c9494463f6865aab77557", "html_url": "https://github.com/rust-lang/rust/commit/a4ef47d6b398b7d4012c9494463f6865aab77557", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4ef47d6b398b7d4012c9494463f6865aab77557/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4726e514d70d53b38530e3608d364bf1ada6bd97", "url": "https://api.github.com/repos/rust-lang/rust/commits/4726e514d70d53b38530e3608d364bf1ada6bd97", "html_url": "https://github.com/rust-lang/rust/commit/4726e514d70d53b38530e3608d364bf1ada6bd97"}, {"sha": "c9588d5bf8db14d80249b029b07f79026956ae85", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9588d5bf8db14d80249b029b07f79026956ae85", "html_url": "https://github.com/rust-lang/rust/commit/c9588d5bf8db14d80249b029b07f79026956ae85"}], "stats": {"total": 104, "additions": 69, "deletions": 35}, "files": [{"sha": "bcc8afbfd952d15763d32cd6239c5c129ee8f35b", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a4ef47d6b398b7d4012c9494463f6865aab77557/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ef47d6b398b7d4012c9494463f6865aab77557/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=a4ef47d6b398b7d4012c9494463f6865aab77557", "patch": "@@ -18,11 +18,11 @@ use rustc_infer::infer::{\n use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::Region;\n use rustc_middle::ty::TypeVisitor;\n use rustc_middle::ty::{self, RegionVid, Ty};\n+use rustc_middle::ty::{Region, TyCtxt};\n use rustc_span::symbol::{kw, Ident};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n \n use crate::borrowck_errors;\n use crate::session_diagnostics::{\n@@ -70,7 +70,25 @@ impl<'tcx> ConstraintDescription for ConstraintCategory<'tcx> {\n ///\n /// Usually we expect this to either be empty or contain a small number of items, so we can avoid\n /// allocation most of the time.\n-pub(crate) type RegionErrors<'tcx> = Vec<RegionErrorKind<'tcx>>;\n+pub(crate) struct RegionErrors<'tcx>(Vec<RegionErrorKind<'tcx>>, TyCtxt<'tcx>);\n+\n+impl<'tcx> RegionErrors<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        Self(vec![], tcx)\n+    }\n+    #[track_caller]\n+    pub fn push(&mut self, val: impl Into<RegionErrorKind<'tcx>>) {\n+        let val = val.into();\n+        self.1.sess.delay_span_bug(DUMMY_SP, \"{val:?}\");\n+        self.0.push(val);\n+    }\n+    pub fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+    pub fn into_iter(self) -> impl Iterator<Item = RegionErrorKind<'tcx>> {\n+        self.0.into_iter()\n+    }\n+}\n \n #[derive(Clone, Debug)]\n pub(crate) enum RegionErrorKind<'tcx> {"}, {"sha": "308f6e19a73e86b2277985a092a5748a77827bd2", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a4ef47d6b398b7d4012c9494463f6865aab77557/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ef47d6b398b7d4012c9494463f6865aab77557/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=a4ef47d6b398b7d4012c9494463f6865aab77557", "patch": "@@ -562,7 +562,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mir_def_id = body.source.def_id();\n         self.propagate_constraints(body);\n \n-        let mut errors_buffer = RegionErrors::new();\n+        let mut errors_buffer = RegionErrors::new(infcx.tcx);\n \n         // If this is a closure, we can propagate unsatisfied\n         // `outlives_requirements` to our creator, so create a vector\n@@ -1647,26 +1647,29 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n         debug!(\"check_bound_universal_region: longer_fr_scc={:?}\", longer_fr_scc,);\n \n-        // If we have some bound universal region `'a`, then the only\n-        // elements it can contain is itself -- we don't know anything\n-        // else about it!\n-        let Some(error_element) = ({\n-            self.scc_values.elements_contained_in(longer_fr_scc).find(|element| match element {\n-                RegionElement::Location(_) => true,\n-                RegionElement::RootUniversalRegion(_) => true,\n-                RegionElement::PlaceholderRegion(placeholder1) => placeholder != *placeholder1,\n-            })\n-        }) else {\n-            return;\n-        };\n-        debug!(\"check_bound_universal_region: error_element = {:?}\", error_element);\n+        for error_element in self.scc_values.elements_contained_in(longer_fr_scc) {\n+            match error_element {\n+                RegionElement::Location(_) | RegionElement::RootUniversalRegion(_) => {}\n+                // If we have some bound universal region `'a`, then the only\n+                // elements it can contain is itself -- we don't know anything\n+                // else about it!\n+                RegionElement::PlaceholderRegion(placeholder1) => {\n+                    if placeholder == placeholder1 {\n+                        continue;\n+                    }\n+                }\n+            }\n \n-        // Find the region that introduced this `error_element`.\n-        errors_buffer.push(RegionErrorKind::BoundUniversalRegionError {\n-            longer_fr,\n-            error_element,\n-            placeholder,\n-        });\n+            errors_buffer.push(RegionErrorKind::BoundUniversalRegionError {\n+                longer_fr,\n+                error_element,\n+                placeholder,\n+            });\n+\n+            // Stop after the first error, it gets too noisy otherwise, and does not provide more information.\n+            break;\n+        }\n+        debug!(\"check_bound_universal_region: all bounds satisfied\");\n     }\n \n     #[instrument(level = \"debug\", skip(self, infcx, errors_buffer))]"}, {"sha": "247607ff29e20717196020ee862ae279fbb268b6", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a4ef47d6b398b7d4012c9494463f6865aab77557/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ef47d6b398b7d4012c9494463f6865aab77557/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=a4ef47d6b398b7d4012c9494463f6865aab77557", "patch": "@@ -1153,27 +1153,31 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         let annotated_type = self.user_type_annotations[user_ty.base].inferred_ty;\n+        trace!(?annotated_type);\n         let mut curr_projected_ty = PlaceTy::from_ty(annotated_type);\n \n         let tcx = self.infcx.tcx;\n \n         for proj in &user_ty.projs {\n+            if let ty::Alias(ty::Opaque, ..) = curr_projected_ty.ty.kind() {\n+                // There is nothing that we can compare here if we go through an opaque type.\n+                // We're always in its defining scope as we can otherwise not project through\n+                // it, so we're constraining it anyways.\n+                return Ok(());\n+            }\n             let projected_ty = curr_projected_ty.projection_ty_core(\n                 tcx,\n                 self.param_env,\n                 proj,\n-                |this, field, _| {\n+                |this, field, ()| {\n                     let ty = this.field_ty(tcx, field);\n                     self.normalize(ty, locations)\n                 },\n                 |_, _| unreachable!(),\n             );\n             curr_projected_ty = projected_ty;\n         }\n-        debug!(\n-            \"user_ty base: {:?} freshened: {:?} projs: {:?} yields: {:?}\",\n-            user_ty.base, annotated_type, user_ty.projs, curr_projected_ty\n-        );\n+        trace!(?curr_projected_ty);\n \n         let ty = curr_projected_ty.ty;\n         self.relate_types(ty, v.xform(ty::Variance::Contravariant), a, locations, category)?;"}, {"sha": "599f0b9d3fab4de99f30f25ba9fd1bf6774ed3ab", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a4ef47d6b398b7d4012c9494463f6865aab77557/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ef47d6b398b7d4012c9494463f6865aab77557/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=a4ef47d6b398b7d4012c9494463f6865aab77557", "patch": "@@ -32,8 +32,9 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// not carry a `Ty` for `T`.)\n     ///\n     /// Note that the resulting type has not been normalized.\n+    #[instrument(level = \"debug\", skip(tcx), ret)]\n     pub fn field_ty(self, tcx: TyCtxt<'tcx>, f: Field) -> Ty<'tcx> {\n-        let answer = match self.ty.kind() {\n+        match self.ty.kind() {\n             ty::Adt(adt_def, substs) => {\n                 let variant_def = match self.variant_index {\n                     None => adt_def.non_enum_variant(),\n@@ -47,9 +48,7 @@ impl<'tcx> PlaceTy<'tcx> {\n             }\n             ty::Tuple(tys) => tys[f.index()],\n             _ => bug!(\"extracting field of non-tuple non-adt: {:?}\", self),\n-        };\n-        debug!(\"field_ty self: {:?} f: {:?} yields: {:?}\", self, f, answer);\n-        answer\n+        }\n     }\n \n     /// Convenience wrapper around `projection_ty_core` for"}, {"sha": "1d96893c7a3ea966aecc4852e79ea01fba386200", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4ef47d6b398b7d4012c9494463f6865aab77557/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ef47d6b398b7d4012c9494463f6865aab77557/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=a4ef47d6b398b7d4012c9494463f6865aab77557", "patch": "@@ -66,14 +66,14 @@ pub fn as_constant_inner<'tcx>(\n \n             let literal = ConstantKind::Val(ConstValue::Scalar(Scalar::Int(lit)), ty);\n \n-            Constant { span, user_ty: user_ty, literal }\n+            Constant { span, user_ty, literal }\n         }\n         ExprKind::ZstLiteral { ref user_ty } => {\n             let user_ty = user_ty.as_ref().map(push_cuta).flatten();\n \n             let literal = ConstantKind::Val(ConstValue::ZeroSized, ty);\n \n-            Constant { span, user_ty: user_ty, literal }\n+            Constant { span, user_ty, literal }\n         }\n         ExprKind::NamedConst { def_id, substs, ref user_ty } => {\n             let user_ty = user_ty.as_ref().map(push_cuta).flatten();"}, {"sha": "f90aba80bf3cf574f17fb3b0571cac22b5b4d6d2", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4ef47d6b398b7d4012c9494463f6865aab77557/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ef47d6b398b7d4012c9494463f6865aab77557/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=a4ef47d6b398b7d4012c9494463f6865aab77557", "patch": "@@ -2210,7 +2210,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             BindingMode::ByValue => ty::BindingMode::BindByValue(mutability),\n             BindingMode::ByRef(_) => ty::BindingMode::BindByReference(mutability),\n         };\n-        let local = LocalDecl::<'tcx> {\n+        let local = LocalDecl {\n             mutability,\n             ty: var_ty,\n             user_ty: if user_ty.is_empty() { None } else { Some(Box::new(user_ty)) },"}, {"sha": "b752e58380a897e43aab7fd81123af3a03515242", "filename": "src/test/ui/type-alias-impl-trait/destructuring.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4ef47d6b398b7d4012c9494463f6865aab77557/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdestructuring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ef47d6b398b7d4012c9494463f6865aab77557/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdestructuring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdestructuring.rs?ref=a4ef47d6b398b7d4012c9494463f6865aab77557", "patch": "@@ -0,0 +1,10 @@\n+#![feature(type_alias_impl_trait)]\n+\n+// check-pass\n+\n+// issue: https://github.com/rust-lang/rust/issues/104551\n+\n+fn main() {\n+    type T = impl Sized;\n+    let (_a, _b): T = (1u32, 2u32);\n+}"}]}