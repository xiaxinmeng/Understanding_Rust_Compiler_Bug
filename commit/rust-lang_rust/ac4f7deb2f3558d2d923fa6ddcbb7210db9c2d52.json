{"sha": "ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNGY3ZGViMmYzNTU4ZDJkOTIzZmE2ZGRjYmI3MjEwZGI5YzJkNTI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-10-26T08:53:27Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-10-26T08:53:27Z"}, "message": "Add 'compiler/rustc_codegen_cranelift/' from commit '793d26047f994e23415f8f6bb5686ff25d3dda92'\n\ngit-subtree-dir: compiler/rustc_codegen_cranelift\ngit-subtree-mainline: cf798c1ec65a5ec3491846777f9003fabb881b4a\ngit-subtree-split: 793d26047f994e23415f8f6bb5686ff25d3dda92", "tree": {"sha": "ca7dcb9c908285e2af6eb0d8807d3e81dc9ba2ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca7dcb9c908285e2af6eb0d8807d3e81dc9ba2ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "html_url": "https://github.com/rust-lang/rust/commit/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf798c1ec65a5ec3491846777f9003fabb881b4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf798c1ec65a5ec3491846777f9003fabb881b4a", "html_url": "https://github.com/rust-lang/rust/commit/cf798c1ec65a5ec3491846777f9003fabb881b4a"}, {"sha": "793d26047f994e23415f8f6bb5686ff25d3dda92", "url": "https://api.github.com/repos/rust-lang/rust/commits/793d26047f994e23415f8f6bb5686ff25d3dda92", "html_url": "https://github.com/rust-lang/rust/commit/793d26047f994e23415f8f6bb5686ff25d3dda92"}], "stats": {"total": 16617, "additions": 16617, "deletions": 0}, "files": [{"sha": "6313b56c57848efce05faa7aa7e901ccfc2886ea", "filename": "compiler/rustc_codegen_cranelift/.gitattributes", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2F.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2F.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitattributes?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1 @@\n+* text=auto eol=lf"}, {"sha": "841e1a0870ed34da319bbbeb08cee4a36cee98c7", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,54 @@\n+name: CI\n+\n+on:\n+  - push\n+  - pull_request\n+\n+jobs:\n+  build:\n+    runs-on: ${{ matrix.os }}\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        os: [ubuntu-latest, macos-latest]\n+\n+    steps:\n+    - uses: actions/checkout@v2\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v2\n+      with:\n+        path: ~/.cargo/bin\n+        key: ${{ runner.os }}-cargo-installed-crates\n+\n+    - name: Cache cargo registry and index\n+      uses: actions/cache@v2\n+      with:\n+        path: |\n+            ~/.cargo/registry\n+            ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v2\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./prepare.sh\n+\n+    - name: Test\n+      run: |\n+        # Enable backtraces for easier debugging\n+        export RUST_BACKTRACE=1\n+\n+        # Reduce amount of benchmark runs as they are slow\n+        export COMPILE_RUNS=2\n+        export RUN_RUNS=2\n+\n+        ./test.sh --release"}, {"sha": "0da9927b479b45326a4e50ac9500df5d0c60802e", "filename": "compiler/rustc_codegen_cranelift/.gitignore", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitignore?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,14 @@\n+target\n+**/*.rs.bk\n+*.rlib\n+*.o\n+perf.data\n+perf.data.old\n+*.events\n+*.string*\n+/build_sysroot/sysroot\n+/build_sysroot/sysroot_src\n+/rust\n+/rand\n+/regex\n+/simple-raytracer"}, {"sha": "04ab5085c196c3f924e295cf4cf46be6386cc223", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,53 @@\n+{\n+    // source for rustc_* is not included in the rust-src component; disable the errors about this\n+    \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\"],\n+    \"rust-analyzer.cargo.loadOutDirsFromCheck\": true,\n+    \"rust-analyzer.linkedProjects\": [\n+        \"./Cargo.toml\",\n+        //\"./build_sysroot/sysroot_src/src/libstd/Cargo.toml\",\n+        {\n+            \"roots\": [\n+                \"./example/mini_core.rs\",\n+                \"./example/mini_core_hello_world.rs\",\n+                \"./example/mod_bench.rs\"\n+            ],\n+            \"crates\": [\n+                {\n+                    \"root_module\": \"./example/mini_core.rs\",\n+                    \"edition\": \"2018\",\n+                    \"deps\": [],\n+                    \"cfg\": [],\n+                },\n+                {\n+                    \"root_module\": \"./example/mini_core_hello_world.rs\",\n+                    \"edition\": \"2018\",\n+                    \"deps\": [{ \"crate\": 0, \"name\": \"mini_core\" }],\n+                    \"cfg\": [],\n+                },\n+                {\n+                    \"root_module\": \"./example/mod_bench.rs\",\n+                    \"edition\": \"2018\",\n+                    \"deps\": [],\n+                    \"cfg\": [],\n+                },\n+            ]\n+        },\n+        {\n+            \"roots\": [\"./scripts/filter_profile.rs\"],\n+            \"crates\": [\n+                {\n+                    \"root_module\": \"./scripts/filter_profile.rs\",\n+                    \"edition\": \"2018\",\n+                    \"deps\": [{ \"crate\": 1, \"name\": \"std\" }],\n+                    \"cfg\": [],\n+                },\n+                {\n+                    \"root_module\": \"./build_sysroot/sysroot_src/library/std/src/lib.rs\",\n+                    \"edition\": \"2018\",\n+                    \"deps\": [],\n+                    \"cfg\": [],\n+                },\n+            ]\n+        }\n+    ]\n+}"}, {"sha": "6cfbed0a5e43051d18f85e10e31dea76a946814b", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "added", "additions": 425, "deletions": 0, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,425 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+[[package]]\n+name = \"anyhow\"\n+version = \"1.0.33\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a1fd36ffbb1fb7c834eac128ea8d0e310c5aeb635548f9d58861e1308d46e71c\"\n+\n+[[package]]\n+name = \"ar\"\n+version = \"0.8.0\"\n+source = \"git+https://github.com/bjorn3/rust-ar.git?branch=do_not_remove_cg_clif_ranlib#de9ab0e56bf3a208381d342aa5b60f9ff2891648\"\n+\n+[[package]]\n+name = \"autocfg\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n+\n+[[package]]\n+name = \"bitflags\"\n+version = \"1.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n+\n+[[package]]\n+name = \"byteorder\"\n+version = \"1.3.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"08c48aae112d48ed9f069b33538ea9e3e90aa263cfa3d1c24309612b1f7472de\"\n+\n+[[package]]\n+name = \"cc\"\n+version = \"1.0.61\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ed67cbde08356238e75fc4656be4749481eeffb09e19f320a25237d5221c985d\"\n+\n+[[package]]\n+name = \"cfg-if\"\n+version = \"0.1.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n+\n+[[package]]\n+name = \"cranelift-bforest\"\n+version = \"0.67.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#4fd90dccabb266e983740e1f5daf8bde9266b286\"\n+dependencies = [\n+ \"cranelift-entity\",\n+]\n+\n+[[package]]\n+name = \"cranelift-codegen\"\n+version = \"0.67.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#4fd90dccabb266e983740e1f5daf8bde9266b286\"\n+dependencies = [\n+ \"byteorder\",\n+ \"cranelift-bforest\",\n+ \"cranelift-codegen-meta\",\n+ \"cranelift-codegen-shared\",\n+ \"cranelift-entity\",\n+ \"gimli\",\n+ \"log\",\n+ \"regalloc\",\n+ \"smallvec\",\n+ \"target-lexicon\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"cranelift-codegen-meta\"\n+version = \"0.67.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#4fd90dccabb266e983740e1f5daf8bde9266b286\"\n+dependencies = [\n+ \"cranelift-codegen-shared\",\n+ \"cranelift-entity\",\n+]\n+\n+[[package]]\n+name = \"cranelift-codegen-shared\"\n+version = \"0.67.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#4fd90dccabb266e983740e1f5daf8bde9266b286\"\n+\n+[[package]]\n+name = \"cranelift-entity\"\n+version = \"0.67.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#4fd90dccabb266e983740e1f5daf8bde9266b286\"\n+\n+[[package]]\n+name = \"cranelift-frontend\"\n+version = \"0.67.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#4fd90dccabb266e983740e1f5daf8bde9266b286\"\n+dependencies = [\n+ \"cranelift-codegen\",\n+ \"log\",\n+ \"smallvec\",\n+ \"target-lexicon\",\n+]\n+\n+[[package]]\n+name = \"cranelift-module\"\n+version = \"0.67.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#4fd90dccabb266e983740e1f5daf8bde9266b286\"\n+dependencies = [\n+ \"anyhow\",\n+ \"cranelift-codegen\",\n+ \"cranelift-entity\",\n+ \"log\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"cranelift-native\"\n+version = \"0.67.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#4fd90dccabb266e983740e1f5daf8bde9266b286\"\n+dependencies = [\n+ \"cranelift-codegen\",\n+ \"raw-cpuid\",\n+ \"target-lexicon\",\n+]\n+\n+[[package]]\n+name = \"cranelift-object\"\n+version = \"0.67.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#4fd90dccabb266e983740e1f5daf8bde9266b286\"\n+dependencies = [\n+ \"anyhow\",\n+ \"cranelift-codegen\",\n+ \"cranelift-module\",\n+ \"log\",\n+ \"object\",\n+ \"target-lexicon\",\n+]\n+\n+[[package]]\n+name = \"cranelift-simplejit\"\n+version = \"0.67.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#4fd90dccabb266e983740e1f5daf8bde9266b286\"\n+dependencies = [\n+ \"cranelift-codegen\",\n+ \"cranelift-entity\",\n+ \"cranelift-module\",\n+ \"cranelift-native\",\n+ \"errno\",\n+ \"libc\",\n+ \"log\",\n+ \"region\",\n+ \"target-lexicon\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"crc32fast\"\n+version = \"1.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ba125de2af0df55319f41944744ad91c71113bf74a4646efff39afe1f6842db1\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n+[[package]]\n+name = \"errno\"\n+version = \"0.2.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6eab5ee3df98a279d9b316b1af6ac95422127b1290317e6d18c1743c99418b01\"\n+dependencies = [\n+ \"errno-dragonfly\",\n+ \"libc\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"errno-dragonfly\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"14ca354e36190500e1e1fb267c647932382b54053c50b14970856c0b00a35067\"\n+dependencies = [\n+ \"gcc\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"gcc\"\n+version = \"0.3.55\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8f5f3913fa0bfe7ee1fd8248b6b9f42a5af4b9d65ec2dd2c3c26132b950ecfc2\"\n+\n+[[package]]\n+name = \"gimli\"\n+version = \"0.22.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"aaf91faf136cb47367fa430cd46e37a788775e7fa104f8b4bcb3861dc389b724\"\n+dependencies = [\n+ \"indexmap\",\n+]\n+\n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.9.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d7afe4a420e3fe79967a00898cc1f4db7c8a49a9333a29f8a4bd76a253d5cd04\"\n+\n+[[package]]\n+name = \"indexmap\"\n+version = \"1.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"55e2e4c765aa53a0424761bf9f41aa7a6ac1efa87238f59560640e27fca028f2\"\n+dependencies = [\n+ \"autocfg\",\n+ \"hashbrown\",\n+]\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.79\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2448f6066e80e3bfc792e9c98bf705b4b0fc6e8ef5b43e5889aff0eaa9c58743\"\n+\n+[[package]]\n+name = \"libloading\"\n+version = \"0.6.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3557c9384f7f757f6d139cd3a4c62ef4e850696c16bf27924a5538c8a09717a1\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"log\"\n+version = \"0.4.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4fabed175da42fed1fa0746b0ea71f412aa9d35e76e95e59b192c64b9dc2bf8b\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n+[[package]]\n+name = \"mach\"\n+version = \"0.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b823e83b2affd8f40a9ee8c29dbc56404c1e34cd2710921f2801e2cf29527afa\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"object\"\n+version = \"0.21.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"37fd5004feb2ce328a52b0b3d01dbf4ffff72583493900ed15f22d4111c51693\"\n+dependencies = [\n+ \"crc32fast\",\n+ \"indexmap\",\n+]\n+\n+[[package]]\n+name = \"proc-macro2\"\n+version = \"1.0.24\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e0704ee1a7e00d7bb417d0770ea303c1bccbabf0ef1667dae92b5967f5f8a71\"\n+dependencies = [\n+ \"unicode-xid\",\n+]\n+\n+[[package]]\n+name = \"quote\"\n+version = \"1.0.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"aa563d17ecb180e500da1cfd2b028310ac758de548efdd203e18f283af693f37\"\n+dependencies = [\n+ \"proc-macro2\",\n+]\n+\n+[[package]]\n+name = \"raw-cpuid\"\n+version = \"7.0.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b4a349ca83373cfa5d6dbb66fd76e58b2cca08da71a5f6400de0a0a6a9bceeaf\"\n+dependencies = [\n+ \"bitflags\",\n+ \"cc\",\n+ \"rustc_version\",\n+]\n+\n+[[package]]\n+name = \"regalloc\"\n+version = \"0.0.31\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"571f7f397d61c4755285cd37853fe8e03271c243424a907415909379659381c5\"\n+dependencies = [\n+ \"log\",\n+ \"rustc-hash\",\n+ \"smallvec\",\n+]\n+\n+[[package]]\n+name = \"region\"\n+version = \"2.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"877e54ea2adcd70d80e9179344c97f93ef0dffd6b03e1f4529e6e83ab2fa9ae0\"\n+dependencies = [\n+ \"bitflags\",\n+ \"libc\",\n+ \"mach\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"rustc-hash\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n+\n+[[package]]\n+name = \"rustc_codegen_cranelift\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"ar\",\n+ \"cranelift-codegen\",\n+ \"cranelift-frontend\",\n+ \"cranelift-module\",\n+ \"cranelift-object\",\n+ \"cranelift-simplejit\",\n+ \"gimli\",\n+ \"indexmap\",\n+ \"libloading\",\n+ \"object\",\n+ \"target-lexicon\",\n+]\n+\n+[[package]]\n+name = \"rustc_version\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n+dependencies = [\n+ \"semver\",\n+]\n+\n+[[package]]\n+name = \"semver\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n+dependencies = [\n+ \"semver-parser\",\n+]\n+\n+[[package]]\n+name = \"semver-parser\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n+\n+[[package]]\n+name = \"smallvec\"\n+version = \"1.4.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fbee7696b84bbf3d89a1c2eccff0850e3047ed46bfcd2e92c29a2d074d57e252\"\n+\n+[[package]]\n+name = \"syn\"\n+version = \"1.0.44\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e03e57e4fcbfe7749842d53e24ccb9aa12b7252dbe5e91d2acad31834c8b8fdd\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-xid\",\n+]\n+\n+[[package]]\n+name = \"target-lexicon\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fe2635952a442a01fd4cb53d98858b5e4bb461b02c0d111f22f31772e3e7a8b2\"\n+\n+[[package]]\n+name = \"thiserror\"\n+version = \"1.0.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"318234ffa22e0920fe9a40d7b8369b5f649d490980cf7aadcf1eb91594869b42\"\n+dependencies = [\n+ \"thiserror-impl\",\n+]\n+\n+[[package]]\n+name = \"thiserror-impl\"\n+version = \"1.0.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cae2447b6282786c3493999f40a9be2a6ad20cb8bd268b0a0dbf5a065535c0ab\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"unicode-xid\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f7fe0bb3479651439c9112f72b6c505038574c9fbb575ed1bf3b797fa39dd564\"\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.3.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\n+dependencies = [\n+ \"winapi-i686-pc-windows-gnu\",\n+ \"winapi-x86_64-pc-windows-gnu\",\n+]\n+\n+[[package]]\n+name = \"winapi-i686-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n+\n+[[package]]\n+name = \"winapi-x86_64-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\""}, {"sha": "1c8e350d24297cb3519865ea8343d3179956832a", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,76 @@\n+[package]\n+name = \"rustc_codegen_cranelift\"\n+version = \"0.1.0\"\n+authors = [\"bjorn3 <bjorn3@users.noreply.github.com>\"]\n+edition = \"2018\"\n+\n+[lib]\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+# These have to be in sync with each other\n+cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\"] }\n+cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n+cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n+cranelift-simplejit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n+cranelift-object = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n+target-lexicon = \"0.11.0\"\n+gimli = { version = \"0.22.0\", default-features = false, features = [\"write\"]}\n+object = { version = \"0.21.1\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+\n+ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n+indexmap = \"1.0.2\"\n+libloading = { version = \"0.6.0\", optional = true }\n+\n+# Uncomment to use local checkout of cranelift\n+#[patch.\"https://github.com/bytecodealliance/wasmtime/\"]\n+#cranelift-codegen = { path = \"../wasmtime/cranelift/codegen\" }\n+#cranelift-frontend = { path = \"../wasmtime/cranelift/frontend\" }\n+#cranelift-module = { path = \"../wasmtime/cranelift/module\" }\n+#cranelift-simplejit = { path = \"../wasmtime/cranelift/simplejit\" }\n+#cranelift-object = { path = \"../wasmtime/cranelift/object\" }\n+\n+#[patch.crates-io]\n+#gimli = { path = \"../\" }\n+\n+[features]\n+default = [\"jit\", \"inline_asm\"]\n+jit = [\"cranelift-simplejit\", \"libloading\"]\n+inline_asm = []\n+\n+[profile.dev]\n+# By compiling dependencies with optimizations, performing tests gets much faster.\n+opt-level = 3\n+\n+[profile.dev.package.rustc_codegen_cranelift]\n+# Disabling optimizations for cg_clif itself makes compilation after a change faster.\n+opt-level = 0\n+\n+[profile.release.package.rustc_codegen_cranelift]\n+incremental = true\n+\n+# Disable optimizations and debuginfo of build scripts and some of the heavy build deps, as the\n+# execution time of build scripts is so fast that optimizing them slows down the total build time.\n+[profile.dev.build-override]\n+opt-level = 0\n+debug = false\n+\n+[profile.release.build-override]\n+opt-level = 0\n+debug = false\n+\n+[profile.dev.package.cranelift-codegen-meta]\n+opt-level = 0\n+debug = false\n+\n+[profile.release.package.cranelift-codegen-meta]\n+opt-level = 0\n+debug = false\n+\n+[profile.dev.package.syn]\n+opt-level = 0\n+debug = false\n+\n+[profile.release.package.syn]\n+opt-level = 0\n+debug = false"}, {"sha": "261eeb9e9f8b2b4b0d119366dda99c6fd7d35c64", "filename": "compiler/rustc_codegen_cranelift/LICENSE-APACHE", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2FLICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2FLICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FLICENSE-APACHE?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,201 @@\n+                                 Apache License\n+                           Version 2.0, January 2004\n+                        http://www.apache.org/licenses/\n+\n+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+   1. Definitions.\n+\n+      \"License\" shall mean the terms and conditions for use, reproduction,\n+      and distribution as defined by Sections 1 through 9 of this document.\n+\n+      \"Licensor\" shall mean the copyright owner or entity authorized by\n+      the copyright owner that is granting the License.\n+\n+      \"Legal Entity\" shall mean the union of the acting entity and all\n+      other entities that control, are controlled by, or are under common\n+      control with that entity. For the purposes of this definition,\n+      \"control\" means (i) the power, direct or indirect, to cause the\n+      direction or management of such entity, whether by contract or\n+      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+      outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+      exercising permissions granted by this License.\n+\n+      \"Source\" form shall mean the preferred form for making modifications,\n+      including but not limited to software source code, documentation\n+      source, and configuration files.\n+\n+      \"Object\" form shall mean any form resulting from mechanical\n+      transformation or translation of a Source form, including but\n+      not limited to compiled object code, generated documentation,\n+      and conversions to other media types.\n+\n+      \"Work\" shall mean the work of authorship, whether in Source or\n+      Object form, made available under the License, as indicated by a\n+      copyright notice that is included in or attached to the work\n+      (an example is provided in the Appendix below).\n+\n+      \"Derivative Works\" shall mean any work, whether in Source or Object\n+      form, that is based on (or derived from) the Work and for which the\n+      editorial revisions, annotations, elaborations, or other modifications\n+      represent, as a whole, an original work of authorship. For the purposes\n+      of this License, Derivative Works shall not include works that remain\n+      separable from, or merely link (or bind by name) to the interfaces of,\n+      the Work and Derivative Works thereof.\n+\n+      \"Contribution\" shall mean any work of authorship, including\n+      the original version of the Work and any modifications or additions\n+      to that Work or Derivative Works thereof, that is intentionally\n+      submitted to Licensor for inclusion in the Work by the copyright owner\n+      or by an individual or Legal Entity authorized to submit on behalf of\n+      the copyright owner. For the purposes of this definition, \"submitted\"\n+      means any form of electronic, verbal, or written communication sent\n+      to the Licensor or its representatives, including but not limited to\n+      communication on electronic mailing lists, source code control systems,\n+      and issue tracking systems that are managed by, or on behalf of, the\n+      Licensor for the purpose of discussing and improving the Work, but\n+      excluding communication that is conspicuously marked or otherwise\n+      designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+      on behalf of whom a Contribution has been received by Licensor and\n+      subsequently incorporated within the Work.\n+\n+   2. Grant of Copyright License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      copyright license to reproduce, prepare Derivative Works of,\n+      publicly display, publicly perform, sublicense, and distribute the\n+      Work and such Derivative Works in Source or Object form.\n+\n+   3. Grant of Patent License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      (except as stated in this section) patent license to make, have made,\n+      use, offer to sell, sell, import, and otherwise transfer the Work,\n+      where such license applies only to those patent claims licensable\n+      by such Contributor that are necessarily infringed by their\n+      Contribution(s) alone or by combination of their Contribution(s)\n+      with the Work to which such Contribution(s) was submitted. If You\n+      institute patent litigation against any entity (including a\n+      cross-claim or counterclaim in a lawsuit) alleging that the Work\n+      or a Contribution incorporated within the Work constitutes direct\n+      or contributory patent infringement, then any patent licenses\n+      granted to You under this License for that Work shall terminate\n+      as of the date such litigation is filed.\n+\n+   4. Redistribution. You may reproduce and distribute copies of the\n+      Work or Derivative Works thereof in any medium, with or without\n+      modifications, and in Source or Object form, provided that You\n+      meet the following conditions:\n+\n+      (a) You must give any other recipients of the Work or\n+          Derivative Works a copy of this License; and\n+\n+      (b) You must cause any modified files to carry prominent notices\n+          stating that You changed the files; and\n+\n+      (c) You must retain, in the Source form of any Derivative Works\n+          that You distribute, all copyright, patent, trademark, and\n+          attribution notices from the Source form of the Work,\n+          excluding those notices that do not pertain to any part of\n+          the Derivative Works; and\n+\n+      (d) If the Work includes a \"NOTICE\" text file as part of its\n+          distribution, then any Derivative Works that You distribute must\n+          include a readable copy of the attribution notices contained\n+          within such NOTICE file, excluding those notices that do not\n+          pertain to any part of the Derivative Works, in at least one\n+          of the following places: within a NOTICE text file distributed\n+          as part of the Derivative Works; within the Source form or\n+          documentation, if provided along with the Derivative Works; or,\n+          within a display generated by the Derivative Works, if and\n+          wherever such third-party notices normally appear. The contents\n+          of the NOTICE file are for informational purposes only and\n+          do not modify the License. You may add Your own attribution\n+          notices within Derivative Works that You distribute, alongside\n+          or as an addendum to the NOTICE text from the Work, provided\n+          that such additional attribution notices cannot be construed\n+          as modifying the License.\n+\n+      You may add Your own copyright statement to Your modifications and\n+      may provide additional or different license terms and conditions\n+      for use, reproduction, or distribution of Your modifications, or\n+      for any such Derivative Works as a whole, provided Your use,\n+      reproduction, and distribution of the Work otherwise complies with\n+      the conditions stated in this License.\n+\n+   5. Submission of Contributions. Unless You explicitly state otherwise,\n+      any Contribution intentionally submitted for inclusion in the Work\n+      by You to the Licensor shall be under the terms and conditions of\n+      this License, without any additional terms or conditions.\n+      Notwithstanding the above, nothing herein shall supersede or modify\n+      the terms of any separate license agreement you may have executed\n+      with Licensor regarding such Contributions.\n+\n+   6. Trademarks. This License does not grant permission to use the trade\n+      names, trademarks, service marks, or product names of the Licensor,\n+      except as required for reasonable and customary use in describing the\n+      origin of the Work and reproducing the content of the NOTICE file.\n+\n+   7. Disclaimer of Warranty. Unless required by applicable law or\n+      agreed to in writing, Licensor provides the Work (and each\n+      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+      implied, including, without limitation, any warranties or conditions\n+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+      PARTICULAR PURPOSE. You are solely responsible for determining the\n+      appropriateness of using or redistributing the Work and assume any\n+      risks associated with Your exercise of permissions under this License.\n+\n+   8. Limitation of Liability. In no event and under no legal theory,\n+      whether in tort (including negligence), contract, or otherwise,\n+      unless required by applicable law (such as deliberate and grossly\n+      negligent acts) or agreed to in writing, shall any Contributor be\n+      liable to You for damages, including any direct, indirect, special,\n+      incidental, or consequential damages of any character arising as a\n+      result of this License or out of the use or inability to use the\n+      Work (including but not limited to damages for loss of goodwill,\n+      work stoppage, computer failure or malfunction, or any and all\n+      other commercial damages or losses), even if such Contributor\n+      has been advised of the possibility of such damages.\n+\n+   9. Accepting Warranty or Additional Liability. While redistributing\n+      the Work or Derivative Works thereof, You may choose to offer,\n+      and charge a fee for, acceptance of support, warranty, indemnity,\n+      or other liability obligations and/or rights consistent with this\n+      License. However, in accepting such obligations, You may act only\n+      on Your own behalf and on Your sole responsibility, not on behalf\n+      of any other Contributor, and only if You agree to indemnify,\n+      defend, and hold each Contributor harmless for any liability\n+      incurred by, or claims asserted against, such Contributor by reason\n+      of your accepting any such warranty or additional liability.\n+\n+   END OF TERMS AND CONDITIONS\n+\n+   APPENDIX: How to apply the Apache License to your work.\n+\n+      To apply the Apache License to your work, attach the following\n+      boilerplate notice, with the fields enclosed by brackets \"[]\"\n+      replaced with your own identifying information. (Don't include\n+      the brackets!)  The text should be enclosed in the appropriate\n+      comment syntax for the file format. We also recommend that a\n+      file or class name and description of purpose be included on the\n+      same \"printed page\" as the copyright notice for easier\n+      identification within third-party archives.\n+\n+   Copyright [yyyy] [name of copyright owner]\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License."}, {"sha": "31aa79387f27e730e33d871925e152e35e428031", "filename": "compiler/rustc_codegen_cranelift/LICENSE-MIT", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2FLICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2FLICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FLICENSE-MIT?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,23 @@\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE."}, {"sha": "680ff877656b0fe5279188328d09439173159d84", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,88 @@\n+# WIP Cranelift codegen backend for rust\n+\n+> \u26a0\u26a0\u26a0 Certain kinds of FFI don't work yet. \u26a0\u26a0\u26a0\n+\n+The goal of this project is to create an alternative codegen backend for the rust compiler based on [Cranelift](https://github.com/bytecodealliance/wasmtime/blob/master/cranelift). This has the potential to improve compilation times in debug mode. If your project doesn't use any of the things listed under \"Not yet supported\", it should work fine. If not please open an issue.\n+\n+## Building\n+\n+```bash\n+$ git clone https://github.com/bjorn3/rustc_codegen_cranelift.git\n+$ cd rustc_codegen_cranelift\n+$ ./prepare.sh # download and patch sysroot src and install hyperfine for benchmarking\n+$ ./test.sh --release\n+```\n+\n+## Usage\n+\n+rustc_codegen_cranelift can be used as a near-drop-in replacement for `cargo build` or `cargo run` for existing projects.\n+\n+Assuming `$cg_clif_dir` is the directory you cloned this repo into and you followed the instructions (`prepare.sh` and `test.sh`).\n+\n+### Cargo\n+\n+In the directory with your project (where you can do the usual `cargo build`), run:\n+\n+```bash\n+$ $cg_clif_dir/cargo.sh run\n+```\n+\n+This should build and run your project with rustc_codegen_cranelift instead of the usual LLVM backend.\n+\n+If you compiled cg_clif in debug mode (aka you didn't pass `--release` to `./test.sh`) you should set `CHANNEL=\"debug\"`.\n+\n+### Rustc\n+\n+> You should prefer using the Cargo method.\n+\n+```bash\n+$ $cg_clif_dir/target/release/cg_clif my_crate.rs\n+```\n+\n+### Jit mode\n+\n+In jit mode cg_clif will immediately execute your code without creating an executable file.\n+\n+> This requires all dependencies to be available as dynamic library.\n+> The jit mode will probably need cargo integration to make this possible.\n+\n+```bash\n+$ $cg_clif_dir/cargo.sh jit\n+```\n+\n+or\n+\n+```bash\n+$ $cg_clif_dir/target/release/cg_clif --jit my_crate.rs\n+```\n+\n+### Shell\n+\n+These are a few functions that allow you to easily run rust code from the shell using cg_clif as jit.\n+\n+```bash\n+function jit_naked() {\n+    echo \"$@\" | $cg_clif_dir/target/release/cg_clif - --jit\n+}\n+\n+function jit() {\n+    jit_naked \"fn main() { $@ }\"\n+}\n+\n+function jit_calc() {\n+    jit 'println!(\"0x{:x}\", ' $@ ');';\n+}\n+```\n+\n+## Env vars\n+\n+[see env_vars.md](docs/env_vars.md)\n+\n+## Not yet supported\n+\n+* Good non-rust abi support ([several problems](https://github.com/bjorn3/rustc_codegen_cranelift/issues/10))\n+* Inline assembly ([no cranelift support](https://github.com/bytecodealliance/wasmtime/issues/1041)\n+    * On Linux there is support for invoking an external assembler for `global_asm!` and `asm!`.\n+      `llvm_asm!` will remain unimplemented forever. `asm!` doesn't yet support reg classes. You\n+      have to specify specific registers instead.\n+* SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171), some basic things work)"}, {"sha": "03ba5b53d2e40155c9c1c87e3f7f4789c4488609", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,324 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+[[package]]\n+name = \"addr2line\"\n+version = \"0.13.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1b6a2d3371669ab3ca9797670853d61402b03d0b4b9ebf33d677dfa720203072\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"gimli\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"adler\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ee2a4ec343196209d6594e19543ae87a39f96d5534d7174822a3ad825dd6ed7e\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"alloc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"core\",\n+]\n+\n+[[package]]\n+name = \"alloc_system\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"core\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"autocfg\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n+\n+[[package]]\n+name = \"cc\"\n+version = \"1.0.61\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ed67cbde08356238e75fc4656be4749481eeffb09e19f320a25237d5221c985d\"\n+\n+[[package]]\n+name = \"cfg-if\"\n+version = \"0.1.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"compiler_builtins\"\n+version = \"0.1.36\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7cd0782e0a7da7598164153173e5a5d4d9b1da094473c98dce0ff91406112369\"\n+dependencies = [\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"core\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"dlmalloc\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"35055b1021724f4eb5262eb49130eebff23fc59fc5a14160e05faad8eeb36673\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"libc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"fortanix-sgx-abi\"\n+version = \"0.3.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c56c422ef86062869b2d57ae87270608dc5929969dd130a6e248979cf4fb6ca6\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"getopts\"\n+version = \"0.2.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5\"\n+dependencies = [\n+ \"rustc-std-workspace-core\",\n+ \"rustc-std-workspace-std\",\n+ \"unicode-width\",\n+]\n+\n+[[package]]\n+name = \"gimli\"\n+version = \"0.22.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"aaf91faf136cb47367fa430cd46e37a788775e7fa104f8b4bcb3861dc389b724\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.9.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d7afe4a420e3fe79967a00898cc1f4db7c8a49a9333a29f8a4bd76a253d5cd04\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.1.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5aca5565f760fb5b220e499d72710ed156fdb74e631659e99377d9ebfbd13ae8\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"libc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.80\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4d58d1b70b004888f764dfbf6a26a3b0342a1632d33968e4a179d8011c760614\"\n+dependencies = [\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"miniz_oxide\"\n+version = \"0.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0f2d26ec3309788e423cfbf68ad1800f061638098d76a83681af979dc4eda19d\"\n+dependencies = [\n+ \"adler\",\n+ \"autocfg\",\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"object\"\n+version = \"0.20.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1ab52be62400ca80aa00285d25253d7f7c437b7375c4de678f5405d3afe82ca5\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"panic_abort\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"compiler_builtins\",\n+ \"core\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"panic_unwind\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"alloc\",\n+ \"cfg-if\",\n+ \"compiler_builtins\",\n+ \"core\",\n+ \"libc\",\n+ \"unwind\",\n+]\n+\n+[[package]]\n+name = \"proc_macro\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"std\",\n+]\n+\n+[[package]]\n+name = \"rustc-demangle\"\n+version = \"0.1.18\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6e3bad0ee36814ca07d7968269dd4b7ec89ec2da10c4bb613928d3077083c232\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"rustc-std-workspace-alloc\"\n+version = \"1.99.0\"\n+dependencies = [\n+ \"alloc\",\n+]\n+\n+[[package]]\n+name = \"rustc-std-workspace-core\"\n+version = \"1.99.0\"\n+dependencies = [\n+ \"core\",\n+]\n+\n+[[package]]\n+name = \"rustc-std-workspace-std\"\n+version = \"1.99.0\"\n+dependencies = [\n+ \"std\",\n+]\n+\n+[[package]]\n+name = \"std\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"addr2line\",\n+ \"alloc\",\n+ \"cfg-if\",\n+ \"compiler_builtins\",\n+ \"core\",\n+ \"dlmalloc\",\n+ \"fortanix-sgx-abi\",\n+ \"hashbrown\",\n+ \"hermit-abi\",\n+ \"libc\",\n+ \"miniz_oxide\",\n+ \"object\",\n+ \"panic_abort\",\n+ \"panic_unwind\",\n+ \"rustc-demangle\",\n+ \"unwind\",\n+ \"wasi\",\n+]\n+\n+[[package]]\n+name = \"sysroot\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"alloc\",\n+ \"alloc_system\",\n+ \"compiler_builtins\",\n+ \"core\",\n+ \"std\",\n+ \"test\",\n+]\n+\n+[[package]]\n+name = \"term\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core\",\n+ \"std\",\n+]\n+\n+[[package]]\n+name = \"test\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"core\",\n+ \"getopts\",\n+ \"libc\",\n+ \"panic_abort\",\n+ \"panic_unwind\",\n+ \"proc_macro\",\n+ \"std\",\n+ \"term\",\n+]\n+\n+[[package]]\n+name = \"unicode-width\"\n+version = \"0.1.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9337591893a19b88d8d87f2cec1e73fad5cdfd10e5a6f349f498ad6ea2ffb1e3\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-core\",\n+ \"rustc-std-workspace-std\",\n+]\n+\n+[[package]]\n+name = \"unwind\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cc\",\n+ \"cfg-if\",\n+ \"compiler_builtins\",\n+ \"core\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"wasi\"\n+version = \"0.9.0+wasi-snapshot-preview1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]"}, {"sha": "e562dedb5324b1d8807668f435858f8a8646c712", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.toml", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,26 @@\n+[package]\n+authors = [\"bjorn3 <bjorn3@users.noreply.github.com>\"]\n+name = \"sysroot\"\n+version = \"0.0.0\"\n+\n+[dependencies]\n+core = { path = \"./sysroot_src/library/core\" }\n+compiler_builtins = \"0.1\"\n+alloc = { path = \"./sysroot_src/library/alloc\" }\n+std = { path = \"./sysroot_src/library/std\", features = [\"panic_unwind\", \"backtrace\"] }\n+test = { path = \"./sysroot_src/library/test\" }\n+\n+alloc_system = { path = \"./alloc_system\" }\n+\n+[patch.crates-io]\n+rustc-std-workspace-core = { path = \"./sysroot_src/library/rustc-std-workspace-core\" }\n+rustc-std-workspace-alloc = { path = \"./sysroot_src/library/rustc-std-workspace-alloc\" }\n+rustc-std-workspace-std = { path = \"./sysroot_src/library/rustc-std-workspace-std\" }\n+\n+[profile.dev]\n+lto = \"off\"\n+\n+[profile.release]\n+debug = true\n+incremental = true\n+lto = \"off\""}, {"sha": "9fffca843006fa1d936640f1f4280452ef6e8f7e", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/alloc_system/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2FCargo.toml?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+authors = [\"The Rust Project Developers\", \"bjorn3 (edited to be usable outside the rust source)\"]\n+name = \"alloc_system\"\n+version = \"0.0.0\"\n+[lib]\n+name = \"alloc_system\"\n+path = \"lib.rs\"\n+test = false\n+doc = false\n+[dependencies]\n+core = { path = \"../sysroot_src/library/core\" }\n+libc = { version = \"0.2.43\", features = ['rustc-dep-of-std'], default-features = false }\n+compiler_builtins = \"0.1\""}, {"sha": "ca145e4f2a52058a6fff6f2282da94b6e529e165", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/alloc_system/lib.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2Flib.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,342 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![no_std]\n+#![allow(unused_attributes)]\n+#![unstable(feature = \"alloc_system\",\n+            reason = \"this library is unlikely to be stabilized in its current \\\n+                      form or name\",\n+            issue = \"32838\")]\n+#![feature(allocator_api)]\n+#![feature(core_intrinsics)]\n+#![feature(nll)]\n+#![feature(staged_api)]\n+#![feature(rustc_attrs)]\n+#![feature(alloc_layout_extra)]\n+#![cfg_attr(\n+    all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+    feature(integer_atomics, stdsimd)\n+)]\n+#![cfg_attr(any(unix, target_os = \"cloudabi\", target_os = \"redox\"), feature(libc))]\n+// The minimum alignment guaranteed by the architecture. This value is used to\n+// add fast paths for low alignment values.\n+#[cfg(all(any(target_arch = \"x86\",\n+              target_arch = \"arm\",\n+              target_arch = \"mips\",\n+              target_arch = \"powerpc\",\n+              target_arch = \"powerpc64\",\n+              target_arch = \"asmjs\",\n+              target_arch = \"wasm32\")))]\n+#[allow(dead_code)]\n+const MIN_ALIGN: usize = 8;\n+#[cfg(all(any(target_arch = \"x86_64\",\n+              target_arch = \"aarch64\",\n+              target_arch = \"mips64\",\n+              target_arch = \"s390x\",\n+              target_arch = \"sparc64\")))]\n+#[allow(dead_code)]\n+const MIN_ALIGN: usize = 16;\n+\n+/// The default memory allocator provided by the operating system.\n+///\n+/// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n+/// plus related functions.\n+///\n+/// This type can be used in a `static` item\n+/// with the `#[global_allocator]` attribute\n+/// to force the global allocator to be the system\u2019s one.\n+/// (The default is jemalloc for executables, on some platforms.)\n+///\n+/// ```rust\n+/// use std::alloc::System;\n+///\n+/// #[global_allocator]\n+/// static A: System = System;\n+///\n+/// fn main() {\n+///     let a = Box::new(4); // Allocates from the system allocator.\n+///     println!(\"{}\", a);\n+/// }\n+/// ```\n+///\n+/// It can also be used directly to allocate memory\n+/// independently of the standard library\u2019s global allocator.\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+pub struct System;\n+#[cfg(any(windows, unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n+mod realloc_fallback {\n+    use core::alloc::{GlobalAlloc, Layout};\n+    use core::cmp;\n+    use core::ptr;\n+    impl super::System {\n+        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut u8, old_layout: Layout,\n+                                              new_size: usize) -> *mut u8 {\n+            // Docs for GlobalAlloc::realloc require this to be valid:\n+            let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n+            let new_ptr = GlobalAlloc::alloc(self, new_layout);\n+            if !new_ptr.is_null() {\n+                let size = cmp::min(old_layout.size(), new_size);\n+                ptr::copy_nonoverlapping(ptr, new_ptr, size);\n+                GlobalAlloc::dealloc(self, ptr, old_layout);\n+            }\n+            new_ptr\n+        }\n+    }\n+}\n+#[cfg(any(unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n+mod platform {\n+    extern crate libc;\n+    use core::ptr;\n+    use MIN_ALIGN;\n+    use System;\n+    use core::alloc::{GlobalAlloc, Layout};\n+    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+    unsafe impl GlobalAlloc for System {\n+        #[inline]\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+                libc::malloc(layout.size()) as *mut u8\n+            } else {\n+                #[cfg(target_os = \"macos\")]\n+                {\n+                    if layout.align() > (1 << 31) {\n+                        return ptr::null_mut()\n+                    }\n+                }\n+                aligned_malloc(&layout)\n+            }\n+        }\n+        #[inline]\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+                libc::calloc(layout.size(), 1) as *mut u8\n+            } else {\n+                let ptr = self.alloc(layout.clone());\n+                if !ptr.is_null() {\n+                    ptr::write_bytes(ptr, 0, layout.size());\n+                }\n+                ptr\n+            }\n+        }\n+        #[inline]\n+        unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n+            libc::free(ptr as *mut libc::c_void)\n+        }\n+        #[inline]\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n+                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n+            } else {\n+                self.realloc_fallback(ptr, layout, new_size)\n+            }\n+        }\n+    }\n+    #[cfg(any(target_os = \"android\",\n+              target_os = \"hermit\",\n+              target_os = \"redox\",\n+              target_os = \"solaris\"))]\n+    #[inline]\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+        // On android we currently target API level 9 which unfortunately\n+        // doesn't have the `posix_memalign` API used below. Instead we use\n+        // `memalign`, but this unfortunately has the property on some systems\n+        // where the memory returned cannot be deallocated by `free`!\n+        //\n+        // Upon closer inspection, however, this appears to work just fine with\n+        // Android, so for this platform we should be fine to call `memalign`\n+        // (which is present in API level 9). Some helpful references could\n+        // possibly be chromium using memalign [1], attempts at documenting that\n+        // memalign + free is ok [2] [3], or the current source of chromium\n+        // which still uses memalign on android [4].\n+        //\n+        // [1]: https://codereview.chromium.org/10796020/\n+        // [2]: https://code.google.com/p/android/issues/detail?id=35391\n+        // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n+        // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n+        //                                       /memory/aligned_memory.cc\n+        libc::memalign(layout.align(), layout.size()) as *mut u8\n+    }\n+    #[cfg(not(any(target_os = \"android\",\n+                  target_os = \"hermit\",\n+                  target_os = \"redox\",\n+                  target_os = \"solaris\")))]\n+    #[inline]\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+        let mut out = ptr::null_mut();\n+        let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n+        if ret != 0 {\n+            ptr::null_mut()\n+        } else {\n+            out as *mut u8\n+        }\n+    }\n+}\n+#[cfg(windows)]\n+#[allow(nonstandard_style)]\n+mod platform {\n+    use MIN_ALIGN;\n+    use System;\n+    use core::alloc::{GlobalAlloc, Layout};\n+    type LPVOID = *mut u8;\n+    type HANDLE = LPVOID;\n+    type SIZE_T = usize;\n+    type DWORD = u32;\n+    type BOOL = i32;\n+    extern \"system\" {\n+        fn GetProcessHeap() -> HANDLE;\n+        fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n+        fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n+        fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n+        fn GetLastError() -> DWORD;\n+    }\n+    #[repr(C)]\n+    struct Header(*mut u8);\n+    const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n+    unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n+        &mut *(ptr as *mut Header).offset(-1)\n+    }\n+    unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n+        let aligned = ptr.add(align - (ptr as usize & (align - 1)));\n+        *get_header(aligned) = Header(ptr);\n+        aligned\n+    }\n+    #[inline]\n+    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut u8 {\n+        let ptr = if layout.align() <= MIN_ALIGN {\n+            HeapAlloc(GetProcessHeap(), flags, layout.size())\n+        } else {\n+            let size = layout.size() + layout.align();\n+            let ptr = HeapAlloc(GetProcessHeap(), flags, size);\n+            if ptr.is_null() {\n+                ptr\n+            } else {\n+                align_ptr(ptr, layout.align())\n+            }\n+        };\n+        ptr as *mut u8\n+    }\n+    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+    unsafe impl GlobalAlloc for System {\n+        #[inline]\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+            allocate_with_flags(layout, 0)\n+        }\n+        #[inline]\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+            allocate_with_flags(layout, HEAP_ZERO_MEMORY)\n+        }\n+        #[inline]\n+        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+            if layout.align() <= MIN_ALIGN {\n+                let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n+                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n+                              GetLastError());\n+            } else {\n+                let header = get_header(ptr);\n+                let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n+                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n+                              GetLastError());\n+            }\n+        }\n+        #[inline]\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN {\n+                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut u8\n+            } else {\n+                self.realloc_fallback(ptr, layout, new_size)\n+            }\n+        }\n+    }\n+}\n+// This is an implementation of a global allocator on the wasm32 platform when\n+// emscripten is not in use. In that situation there's no actual runtime for us\n+// to lean on for allocation, so instead we provide our own!\n+//\n+// The wasm32 instruction set has two instructions for getting the current\n+// amount of memory and growing the amount of memory. These instructions are the\n+// foundation on which we're able to build an allocator, so we do so! Note that\n+// the instructions are also pretty \"global\" and this is the \"global\" allocator\n+// after all!\n+//\n+// The current allocator here is the `dlmalloc` crate which we've got included\n+// in the rust-lang/rust repository as a submodule. The crate is a port of\n+// dlmalloc.c from C to Rust and is basically just so we can have \"pure Rust\"\n+// for now which is currently technically required (can't link with C yet).\n+//\n+// The crate itself provides a global allocator which on wasm has no\n+// synchronization as there are no threads!\n+#[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n+mod platform {\n+    extern crate dlmalloc;\n+    use core::alloc::{GlobalAlloc, Layout};\n+    use System;\n+    static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n+    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+    unsafe impl GlobalAlloc for System {\n+        #[inline]\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+            let _lock = lock::lock();\n+            DLMALLOC.malloc(layout.size(), layout.align())\n+        }\n+        #[inline]\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+            let _lock = lock::lock();\n+            DLMALLOC.calloc(layout.size(), layout.align())\n+        }\n+        #[inline]\n+        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+            let _lock = lock::lock();\n+            DLMALLOC.free(ptr, layout.size(), layout.align())\n+        }\n+        #[inline]\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+            let _lock = lock::lock();\n+            DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n+        }\n+    }\n+    #[cfg(target_feature = \"atomics\")]\n+    mod lock {\n+        use core::arch::wasm32;\n+        use core::sync::atomic::{AtomicI32, Ordering::SeqCst};\n+        static LOCKED: AtomicI32 = AtomicI32::new(0);\n+        pub struct DropLock;\n+        pub fn lock() -> DropLock {\n+            loop {\n+                if LOCKED.swap(1, SeqCst) == 0 {\n+                    return DropLock\n+                }\n+                unsafe {\n+                    let r = wasm32::atomic::wait_i32(\n+                        &LOCKED as *const AtomicI32 as *mut i32,\n+                        1,  // expected value\n+                        -1, // timeout\n+                    );\n+                    debug_assert!(r == 0 || r == 1);\n+                }\n+            }\n+        }\n+        impl Drop for DropLock {\n+            fn drop(&mut self) {\n+                let r = LOCKED.swap(0, SeqCst);\n+                debug_assert_eq!(r, 1);\n+                unsafe {\n+                    wasm32::atomic::wake(\n+                        &LOCKED as *const AtomicI32 as *mut i32,\n+                        1, // only one thread\n+                    );\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(not(target_feature = \"atomics\"))]\n+    mod lock {\n+        #[inline]\n+        pub fn lock() {} // no atomics, no threads, that's easy!\n+    }\n+}"}, {"sha": "04c82ca2a512855fee6d3776c07970e63a3ca510", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/build_sysroot.sh", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,36 @@\n+#!/bin/bash\n+\n+# Requires the CHANNEL env var to be set to `debug` or `release.`\n+\n+set -e\n+cd $(dirname \"$0\")\n+\n+pushd ../ >/dev/null\n+source ./scripts/config.sh\n+popd >/dev/null\n+\n+# Cleanup for previous run\n+#     v Clean target dir except for build scripts and incremental cache\n+rm -r target/*/{debug,release}/{build,deps,examples,libsysroot*,native} 2>/dev/null || true\n+rm -r sysroot/ 2>/dev/null || true\n+\n+# Use rustc with cg_clif as hotpluggable backend instead of the custom cg_clif driver so that\n+# build scripts are still compiled using cg_llvm.\n+export RUSTC=$(pwd)/../\"target/\"$CHANNEL\"/cg_clif_build_sysroot\"\n+export RUSTFLAGS=$RUSTFLAGS\" --clif\"\n+\n+# Build libs\n+export RUSTFLAGS=\"$RUSTFLAGS -Zforce-unstable-if-unmarked -Cpanic=abort\"\n+if [[ \"$1\" == \"--release\" ]]; then\n+    sysroot_channel='release'\n+    # FIXME Enable incremental again once rust-lang/rust#74946 is fixed\n+    # FIXME Enable -Zmir-opt-level=2 again once it doesn't ice anymore\n+    CARGO_INCREMENTAL=0 RUSTFLAGS=\"$RUSTFLAGS\" cargo build --target $TARGET_TRIPLE --release\n+else\n+    sysroot_channel='debug'\n+    cargo build --target $TARGET_TRIPLE\n+fi\n+\n+# Copy files to sysroot\n+mkdir -p sysroot/lib/rustlib/$TARGET_TRIPLE/lib/\n+cp -r target/$TARGET_TRIPLE/$sysroot_channel/deps/* sysroot/lib/rustlib/$TARGET_TRIPLE/lib/"}, {"sha": "14aa77478f54dbcd12fe1a975f69b3020cce4fe0", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/prepare_sysroot_src.sh", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,32 @@\n+#!/bin/bash\n+set -e\n+cd $(dirname \"$0\")\n+\n+SRC_DIR=$(dirname $(rustup which rustc))\"/../lib/rustlib/src/rust/\"\n+DST_DIR=\"sysroot_src\"\n+\n+if [ ! -e $SRC_DIR ]; then\n+    echo \"Please install rust-src component\"\n+    exit 1\n+fi\n+\n+rm -rf $DST_DIR\n+mkdir -p $DST_DIR/library\n+cp -r $SRC_DIR/library $DST_DIR/\n+\n+pushd $DST_DIR\n+echo \"[GIT] init\"\n+git init\n+echo \"[GIT] add\"\n+git add .\n+echo \"[GIT] commit\"\n+git commit -m \"Initial commit\" -q\n+for file in $(ls ../../patches/ | grep -v patcha); do\n+echo \"[GIT] apply\" $file\n+git apply ../../patches/$file\n+git add -A\n+git commit --no-gpg-sign -m \"Patch $file\"\n+done\n+popd\n+\n+echo \"Successfully prepared libcore for building\""}, {"sha": "0c9ac1ac8e4bd702086402213af792ae0636d192", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/src/lib.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fsrc%2Flib.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1 @@\n+#![no_std]"}, {"sha": "cebc3e67363a885c7ea223acb8236686e42ef5c8", "filename": "compiler/rustc_codegen_cranelift/cargo.sh", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fcargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fcargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fcargo.sh?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,22 @@\n+#!/bin/bash\n+\n+if [ -z $CHANNEL ]; then\n+export CHANNEL='release'\n+fi\n+\n+pushd $(dirname \"$0\") >/dev/null\n+source scripts/config.sh\n+\n+# read nightly compiler from rust-toolchain file\n+TOOLCHAIN=$(cat rust-toolchain)\n+\n+popd >/dev/null\n+\n+cmd=$1\n+shift\n+\n+if [[ \"$cmd\" = \"jit\" ]]; then\n+cargo +${TOOLCHAIN} rustc $@ -- --jit\n+else\n+cargo +${TOOLCHAIN} $cmd $@\n+fi"}, {"sha": "3003a0ea2d102d779ec08cafe902a33af5d62340", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,5 @@\n+#!/bin/bash --verbose\n+set -e\n+\n+rm -rf target/ build_sysroot/{sysroot/,sysroot_src/,target/} perf.data{,.old}\n+rm -rf rand/ regex/ simple-raytracer/"}, {"sha": "01dc0fcc5376138bccca396b78e729a5942bf94c", "filename": "compiler/rustc_codegen_cranelift/crate_patches/0001-rand-Enable-c2-chacha-simd-feature.patch", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0001-rand-Enable-c2-chacha-simd-feature.patch", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0001-rand-Enable-c2-chacha-simd-feature.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0001-rand-Enable-c2-chacha-simd-feature.patch?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,23 @@\n+From 9c5663e36391fa20becf84f3af2e82afa5bb720b Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Sat, 15 Aug 2020 19:56:03 +0200\n+Subject: [PATCH] [rand] Enable c2-chacha simd feature\n+\n+---\n+ rand_chacha/Cargo.toml | 2 +-\n+ 1 file changed, 1 insertion(+), 1 deletion(-)\n+\n+diff --git a/rand_chacha/Cargo.toml b/rand_chacha/Cargo.toml\n+index 9190b7f..872cca2 100644\n+--- a/rand_chacha/Cargo.toml\n++++ b/rand_chacha/Cargo.toml\n+@@ -24,5 +24,5 @@ ppv-lite86 = { version = \"0.2.8\", default-features = false }\n+ \n+ [features]\n+ default = [\"std\"]\n+-std = [\"ppv-lite86/std\"]\n++std = [\"ppv-lite86/std\", \"ppv-lite86/simd\"]\n+ simd = [] # deprecated\n+-- \n+2.20.1\n+"}, {"sha": "19fd20d7269017cfa1dd21a9db67999d61d4b619", "filename": "compiler/rustc_codegen_cranelift/crate_patches/0002-rand-Disable-failing-test.patch", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0002-rand-Disable-failing-test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0002-rand-Disable-failing-test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0002-rand-Disable-failing-test.patch?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,33 @@\n+From a8fb97120d71252538b6b026695df40d02696bdb Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Sat, 15 Aug 2020 20:04:38 +0200\n+Subject: [PATCH] [rand] Disable failing test\n+\n+---\n+ src/distributions/uniform.rs | 3 ++-\n+ 1 file changed, 2 insertions(+), 1 deletion(-)\n+\n+diff --git a/src/distributions/uniform.rs b/src/distributions/uniform.rs\n+index 480b859..c80bb6f 100644\n+--- a/src/distributions/uniform.rs\n++++ b/src/distributions/uniform.rs\n+@@ -1085,7 +1085,7 @@ mod tests {\n+             _ => panic!(\"`UniformDurationMode` was not serialized/deserialized correctly\")\n+         }\n+     }\n+-    \n++\n+     #[test]\n+     #[cfg(feature = \"serde1\")]\n+     fn test_uniform_serialization() {\n+@@ -1314,6 +1314,7 @@ mod tests {\n+         not(target_arch = \"wasm32\"),\n+         not(target_arch = \"asmjs\")\n+     ))]\n++    #[ignore] // FIXME\n+     fn test_float_assertions() {\n+         use super::SampleUniform;\n+         use std::panic::catch_unwind;\n+-- \n+2.20.1\n+"}, {"sha": "502b1b03623101aed67066eff4c4a98ea37ac13f", "filename": "compiler/rustc_codegen_cranelift/docs/dwarf.md", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fdwarf.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fdwarf.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fdwarf.md?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,153 @@\n+# Line number information\n+\n+Line number information maps between machine code instructions and the source level location.\n+\n+## Encoding\n+\n+The line number information is stored in the `.debug_line` section for ELF and `__debug_line`\n+section of the `__DWARF` segment for Mach-O object files. The line number information contains a\n+header followed by the line program. The line program is a program for a virtual machine with\n+instructions like set line number for the current machine code instruction and advance the current\n+machine code instruction.\n+\n+## Tips\n+\n+You need to set either `DW_AT_low_pc` and `DW_AT_high_pc` **or** `DW_AT_ranges` of a\n+`DW_TAG_compilation_unit` to the range of addresses in the compilation unit. After that you need\n+to set `DW_AT_stmt_list` to the `.debug_line` section offset of the line program. Otherwise a\n+debugger won't find the line number information. On macOS the debuginfo relocations **must** be\n+section relative and not symbol relative.\n+See [#303 (comment)](https://github.com/bjorn3/rustc_codegen_cranelift/issues/303#issuecomment-457825535)\n+for more information.\n+\n+# Function debuginfo\n+\n+## Tips\n+\n+`DW_TAG_subprogram` requires `DW_AT_name`, `DW_AT_low_pc` and `DW_AT_high_pc` **or** `DW_AT_ranges`.\n+Otherwise gdb will silently skip it. When `DW_AT_high_pc` is a length instead of an address, the\n+DWARF version must be at least 4.\n+\n+<details>\n+<summary>IRC log of #gdb on irc.freenode.org at 2020-04-23</summary>\n+\n+```\n+(13:46:11) bjorn3: i am writing a backend for a compiler that uses DWARF for debuginfo. for some reason gdb seems to completely ignore all DW_TAG_subprogram, while lldb works fine. any idea what the problem could be?\n+(13:47:49) bjorn3: this is the output of llvm-dwarfdump: https://gist.github.com/bjorn3/8a34e333c80f13cb048381e94b4a3756\n+(13:47:50) osa1: luispm: why is that problem not exists in 'commands'? (the target vs. host)\n+(13:52:16) luispm: osa1, commands is a bit more high level. It executes isolated commands. Breakpoint conditions need to be evaluated in the context of a valid expression. That expression may involve variables, symbols etc.\n+(13:52:36) luispm: osa1, Oh, i see your point now. Commands is only executed on the host.\n+(13:53:18) luispm: osa1, The commands are not tied to the execution context of the debugged program. The breakpoint conditions determine if execution must stop or continue etc.\n+(13:55:00) luispm: bjorn3, Likely something GDB thinks is wrong. Does enabling \"set debug dwarf*\" show anything?\n+(13:56:01) bjorn3: luispm: no\n+(13:56:12) bjorn3: for more context: https://github.com/bjorn3/rustc_codegen_cranelift/pull/978\n+(13:58:16) osa1 verliet de ruimte (quit: Quit: osa1).\n+(13:58:28) bjorn3: luispm: wait, for b m<TAB> it shows nothing, but when stepping into a new function it does\n+(13:58:45) bjorn3: it still doesn't show anything for `info args` though\n+(13:58:50) bjorn3: No symbol table info available.\n+(14:00:50) luispm: bjorn3, Is that expected given the nature of the binary?\n+(14:01:17) bjorn3: b main<TAB> may show nothing as I only set DW_AT_linkage_name and not DW_AT_name\n+(14:01:24) bjorn3: info args should work though\n+(14:03:26) luispm: Sorry, I'm not sure what's up. There may be a genuine bug there.\n+(14:03:41) luispm: tromey (not currently in the channel, but maybe later today) may have more input.\n+(14:04:08) bjorn3: okay, thanks luispm!\n+(14:04:27) luispm: In the worst case, reporting a bug may prompt someone to look into that as well.\n+(14:04:48) luispm: Or send an e-mail to the gdb@sourceware.org mailing list.\n+(14:05:11) bjorn3: I don't know if it is a bug in gdb, or just me producing (slightly) wrong DWARF\n+(14:39:40) irker749: gdb: tom binutils-gdb.git:master * 740480b88af / gdb/ChangeLog gdb/darwin-nat.c gdb/inferior.c gdb/inferior.h: Remove iterate_over_inferiors\n+(15:22:45) irker749: gdb: tromey binutils-gdb.git:master * ecc6c6066b5 / gdb/ChangeLog gdb/dwarf2/read.c gdb/unittests/lookup_name_info-selftests.c: Fix Ada crash with .debug_names\n+(15:23:13) bjorn3: tromey: ping\n+(15:23:29) tromey: bjorn3: hey\n+(15:24:16) bjorn3: I am writing a backend for a compiler which uses DWARF for debuginfo. I unfortunately can't get gdb to show arguments. lldb works fine.\n+(15:25:13) bjorn3: it just says: No symbol table info available.\n+(15:25:21) bjorn3: any idea what it could be?\n+(15:25:34) bjorn3: dwarfdump output: https://gist.github.com/bjorn3/8a34e333c80f13cb048381e94b4a3756\n+(15:26:48) bjorn3: more context: https://github.com/bjorn3/rustc_codegen_cranelift/pull/978\n+(15:28:05) tromey: offhand I don't know, but if you can send me an executable I can look\n+(15:28:17) bjorn3: how should I send it?\n+(15:29:26) tromey: good question\n+(15:29:41) tromey: you could try emailing it to tromey at adacore.com\n+(15:29:47) tromey: dunno if that will work or not\n+(15:30:26) bjorn3: i will try\n+(15:37:27) bjorn3: tromey: i sent an email with the subject \"gdb args not showing\"\n+(15:38:29) tromey: will check now\n+(15:38:40) bjorn3: thanks!\n+(15:42:51) irker749: gdb: tdevries binutils-gdb.git:master * de82891ce5b / gdb/ChangeLog gdb/block.c gdb/block.h gdb/symtab.c gdb/testsuite/ChangeLog gdb/testsuite/gdb.base/decl-before-def-decl.c gdb/testsuite/gdb.base/decl-before-def-def.c gdb/testsuite/gdb.base/decl-before-def.exp: [gdb/symtab] Prefer def over decl (inter-CU case)\n+(15:42:52) irker749: gdb: tdevries binutils-gdb.git:master * 70bc38f5138 / gdb/ChangeLog gdb/symtab.c gdb/testsuite/ChangeLog gdb/testsuite/gdb.base/decl-before-def.exp: [gdb/symtab] Prefer def over decl (inter-CU case, with context)\n+(15:43:36) tromey: bjorn3: sorry, got distracted.  I have the file now\n+(15:45:35) tromey: my first thing when investigating was to enable complaints\n+(15:45:37) tromey: so I did\n+(15:45:40) tromey: set complaints 1000\n+(15:45:42) tromey: then\n+(15:45:51) tromey: file -readnow mini_core_hello_world\n+(15:46:00) tromey: gdb printed just one style of complaint\n+(15:46:07) tromey: During symbol reading: missing name for subprogram DIE at 0x3f7\n+(15:46:18) tromey: (which is really pretty good, most compilers manage to generate a bunch)\n+(15:46:29) tromey: and then the gdb DWARF reader says\n+(15:46:34) tromey:   /* Ignore functions with missing or empty names.  These are actually\n+(15:46:34) tromey:      illegal according to the DWARF standard.  */\n+(15:46:34) tromey:   if (name == NULL)\n+(15:46:34) tromey:     {\n+(15:46:37) tromey:       complaint (_(\"missing name for subprogram DIE at %s\"),\n+(15:46:40) tromey: \t\t sect_offset_str (die->sect_off));\n+(15:46:47) tromey: I wonder if that comment is correct though\n+(15:47:34) tromey: I guess pedantically maybe it is, DWARF 5 3.3.1 says\n+(15:47:43) tromey: The subroutine or entry point entry has a DW_AT_name attribute whose value is\n+(15:47:43) tromey: a null-terminated string containing the subroutine or entry point name.\n+(15:48:14) bjorn3: i tried set complaints, but it returned complaints for system files. i didn't know about file -readnow.\n+(15:48:21) tromey: cool\n+(15:48:26) bjorn3: i will try adding DW_AT_name\n+(15:48:45) tromey: without readnow unfortunately you get less stuff, because for whatever reason gdb has 2 separate DWARF scanners\n+(15:49:02) tromey: sort of anyway\n+(15:49:43) tromey: this seems kind of pedantic of gdb, like if there's a linkage name but no DW_AT_name, then why bail?\n+(15:50:01) tromey: also what about anonymous functions\n+(15:50:17) tromey: but anyway this explains the current situation and if you don't mind adding DW_AT_name, then that's probably simplest\n+(15:51:47) bjorn3: i added DW_AT_name.\n+(15:51:54) bjorn3: now it says cannot get low and high bounds for subprogram DIE at ...\n+(15:52:01) tromey: ugh\n+(15:52:10) bjorn3: i will add DW_AT_low_pc and DW_AT_high_pc\n+(15:52:15) tromey:   /* Ignore functions with missing or invalid low and high pc attributes.  */\n+(15:52:37) tromey: you can also use DW_AT_ranges\n+(15:52:55) tromey: if you'd prefer\n+(15:53:08) bjorn3: already using DW_AT_ranges for DW_TAG_compilation_unit\n+(15:53:19) bjorn3: for individual functions, there are no gaps\n+(15:57:07) bjorn3: still the same error with DW_AT_low_pc and DW_AT_high_pc\n+(15:57:24) bjorn3: tromey: ^\n+(15:58:08) tromey: hmmm\n+(15:58:30) bjorn3: should i send the new executable?\n+(15:58:31) tromey: send me another executable & I will debug\n+(15:58:33) tromey: yep\n+(15:59:23) bjorn3: sent as repy of the previous mail\n+(16:03:23) tromey: the low PC has DW_FORM_addr, but the high PC has DW_FORM_udata, which seems weird\n+(16:03:50) mjw: no\n+(16:03:54) tromey: no?\n+(16:04:00) mjw: I suggested that for the DWARF standard...\n+(16:04:05) mjw: sorry\n+(16:04:58) mjw: The idea was that instead of two relocations and two address wide fields, you have one address and a constant offset.\n+(16:05:05) tromey: ahh, I see the code now\n+(16:05:07) tromey: I forgot about this\n+(16:05:18) tromey: \t  if (cu->header.version >= 4 && attr_high->form_is_constant ())\n+(16:05:18) tromey: \t    high += low;\n+(16:05:36) mjw: that second offset doesn't need a relocation and can often be packed in something small, like an uleb128\n+(16:05:51) mjw: using udata might not be ideal though, but is allowed\n+(16:05:51) tromey: bjorn3: the problem is that this CU claims to be DWARF 3 but is using a DWARF 4 feature\n+(16:05:58) mjw: aha\n+(16:05:59) bjorn3: which one?\n+(16:06:03) ryoshu: hi\n+(16:06:08) tromey:              high_pc              (udata) 107 (+0x00000000000011b0 <_ZN21mini_core_hello_world5start17hec55b7ca64fc434eE>)\n+(16:06:08) tromey:\n+(16:06:12) ryoshu: just soft ping, I have a queue of patches :)\n+(16:06:22) tromey: using this as a length requires DWARF 4\n+(16:06:36) tromey: for gdb at least it's fine to always emit DWARF 4\n+(16:06:44) bjorn3: trying dwarf 4 now\n+(16:06:48) tromey: I think there are some DWARF 5 features still in the works but DWARF 4 should be solid AFAIK\n+(16:07:03) tromey: fini\n+(16:07:08) tromey: lol wrong window\n+(16:07:56) mjw: Maybe you can accept it for DWARF < 4. But if I remember correctly it might be that people might have been using udata as if it was an address...\n+(16:08:13) tromey: yeah, I vaguely recall this as well, though I'd expect there to be a comment\n+(16:08:21) mjw: Cannot really remember why it needed version >= 4. Maybe there was no good reason?\n+(16:08:32) bjorn3: tromey: it works!!!! thanks for all the help!\n+(16:08:41) tromey: my pleasure bjorn3\n+```\n+\n+</details>"}, {"sha": "07b75622a58ef2dac71189a7e1063bbc7ba5d9b3", "filename": "compiler/rustc_codegen_cranelift/docs/env_vars.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,15 @@\n+# List of env vars recognized by cg_clif\n+\n+<dl>\n+    <dt>CG_CLIF_JIT_ARGS</dt>\n+    <dd>When JIT mode is enable pass these arguments to the program.</dd>\n+    <dt>CG_CLIF_INCR_CACHE_DISABLED</dt>\n+    <dd>Don't cache object files in the incremental cache. Useful during development of cg_clif\n+    to make it possible to use incremental mode for all analyses performed by rustc without caching\n+    object files when their content should have been changed by a change to cg_clif.</dd>\n+    <dt>CG_CLIF_DISPLAY_CG_TIME</dt>\n+    <dd>If \"1\", display the time it took to perform codegen for a crate</dd>\n+    <dt>CG_CLIF_FUNCTION_SECTIONS</dt>\n+    <dd>Use a single section for each function. This will often reduce the executable size at the\n+        cost of making linking significantly slower.</dd>\n+</dl>"}, {"sha": "dc2ad4c676e804d99e3f8a9afdd6dee98cb02bde", "filename": "compiler/rustc_codegen_cranelift/example/alloc_example.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,37 @@\n+#![feature(start, box_syntax, alloc_system, core_intrinsics, alloc_prelude, alloc_error_handler)]\n+#![no_std]\n+\n+extern crate alloc;\n+extern crate alloc_system;\n+\n+use alloc::prelude::v1::*;\n+\n+use alloc_system::System;\n+\n+#[global_allocator]\n+static ALLOC: System = System;\n+\n+#[link(name = \"c\")]\n+extern \"C\" {\n+    fn puts(s: *const u8) -> i32;\n+}\n+\n+#[panic_handler]\n+fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n+    core::intrinsics::abort();\n+}\n+\n+#[alloc_error_handler]\n+fn alloc_error_handler(_: alloc::alloc::Layout) -> ! {\n+    core::intrinsics::abort();\n+}\n+\n+#[start]\n+fn main(_argc: isize, _argv: *const *const u8) -> isize {\n+    let world: Box<&str> = box \"Hello World!\\0\";\n+    unsafe {\n+        puts(*world as *const str as *const u8);\n+    }\n+\n+    0\n+}"}, {"sha": "0b0039a1370a4fb6d609f9fb1443c6c390ab7335", "filename": "compiler/rustc_codegen_cranelift/example/arbitrary_self_types_pointers_and_wrappers.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,82 @@\n+// Adapted from rustc run-pass test suite\n+\n+#![feature(no_core, arbitrary_self_types, box_syntax)]\n+#![feature(rustc_attrs)]\n+\n+#![feature(start, lang_items)]\n+#![no_core]\n+\n+extern crate mini_core;\n+\n+use mini_core::*;\n+\n+macro_rules! assert_eq {\n+    ($l:expr, $r: expr) => {\n+        if $l != $r {\n+            panic(stringify!($l != $r));\n+        }\n+    }\n+}\n+\n+struct Ptr<T: ?Sized>(Box<T>);\n+\n+impl<T: ?Sized> Deref for Ptr<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &*self.0\n+    }\n+}\n+\n+impl<T: Unsize<U> + ?Sized, U: ?Sized> CoerceUnsized<Ptr<U>> for Ptr<T> {}\n+impl<T: Unsize<U> + ?Sized, U: ?Sized> DispatchFromDyn<Ptr<U>> for Ptr<T> {}\n+\n+struct Wrapper<T: ?Sized>(T);\n+\n+impl<T: ?Sized> Deref for Wrapper<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n+impl<T: CoerceUnsized<U>, U> CoerceUnsized<Wrapper<U>> for Wrapper<T> {}\n+impl<T: DispatchFromDyn<U>, U> DispatchFromDyn<Wrapper<U>> for Wrapper<T> {}\n+\n+\n+trait Trait {\n+    // This method isn't object-safe yet. Unsized by-value `self` is object-safe (but not callable\n+    // without unsized_locals), but wrappers arond `Self` currently are not.\n+    // FIXME (mikeyhew) uncomment this when unsized rvalues object-safety is implemented\n+    // fn wrapper(self: Wrapper<Self>) -> i32;\n+    fn ptr_wrapper(self: Ptr<Wrapper<Self>>) -> i32;\n+    fn wrapper_ptr(self: Wrapper<Ptr<Self>>) -> i32;\n+    fn wrapper_ptr_wrapper(self: Wrapper<Ptr<Wrapper<Self>>>) -> i32;\n+}\n+\n+impl Trait for i32 {\n+    fn ptr_wrapper(self: Ptr<Wrapper<Self>>) -> i32 {\n+        **self\n+    }\n+    fn wrapper_ptr(self: Wrapper<Ptr<Self>>) -> i32 {\n+        **self\n+    }\n+    fn wrapper_ptr_wrapper(self: Wrapper<Ptr<Wrapper<Self>>>) -> i32 {\n+        ***self\n+    }\n+}\n+\n+#[start]\n+fn main(_: isize, _: *const *const u8) -> isize {\n+    let pw = Ptr(box Wrapper(5)) as Ptr<Wrapper<dyn Trait>>;\n+    assert_eq!(pw.ptr_wrapper(), 5);\n+\n+    let wp = Wrapper(Ptr(box 6)) as Wrapper<Ptr<dyn Trait>>;\n+    assert_eq!(wp.wrapper_ptr(), 6);\n+\n+    let wpw = Wrapper(Ptr(box Wrapper(7))) as Wrapper<Ptr<Wrapper<dyn Trait>>>;\n+    assert_eq!(wpw.wrapper_ptr_wrapper(), 7);\n+\n+    0\n+}"}, {"sha": "6c338e99912ec2eec32edaa156f6d9fc7b9d8523", "filename": "compiler/rustc_codegen_cranelift/example/dst-field-align.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Fdst-field-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Fdst-field-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fdst-field-align.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,67 @@\n+// run-pass\n+#![allow(dead_code)]\n+struct Foo<T: ?Sized> {\n+    a: u16,\n+    b: T\n+}\n+\n+trait Bar {\n+    fn get(&self) -> usize;\n+}\n+\n+impl Bar for usize {\n+    fn get(&self) -> usize { *self }\n+}\n+\n+struct Baz<T: ?Sized> {\n+    a: T\n+}\n+\n+struct HasDrop<T: ?Sized> {\n+    ptr: Box<usize>,\n+    data: T\n+}\n+\n+fn main() {\n+    // Test that zero-offset works properly\n+    let b : Baz<usize> = Baz { a: 7 };\n+    assert_eq!(b.a.get(), 7);\n+    let b : &Baz<dyn Bar> = &b;\n+    assert_eq!(b.a.get(), 7);\n+\n+    // Test that the field is aligned properly\n+    let f : Foo<usize> = Foo { a: 0, b: 11 };\n+    assert_eq!(f.b.get(), 11);\n+    let ptr1 : *const u8 = &f.b as *const _ as *const u8;\n+\n+    let f : &Foo<dyn Bar> = &f;\n+    let ptr2 : *const u8 = &f.b as *const _ as *const u8;\n+    assert_eq!(f.b.get(), 11);\n+\n+    // The pointers should be the same\n+    assert_eq!(ptr1, ptr2);\n+\n+    // Test that nested DSTs work properly\n+    let f : Foo<Foo<usize>> = Foo { a: 0, b: Foo { a: 1, b: 17 }};\n+    assert_eq!(f.b.b.get(), 17);\n+    let f : &Foo<Foo<dyn Bar>> = &f;\n+    assert_eq!(f.b.b.get(), 17);\n+\n+    // Test that get the pointer via destructuring works\n+\n+    let f : Foo<usize> = Foo { a: 0, b: 11 };\n+    let f : &Foo<dyn Bar> = &f;\n+    let &Foo { a: _, b: ref bar } = f;\n+    assert_eq!(bar.get(), 11);\n+\n+    // Make sure that drop flags don't screw things up\n+\n+    let d : HasDrop<Baz<[i32; 4]>> = HasDrop {\n+        ptr: Box::new(0),\n+        data: Baz { a: [1,2,3,4] }\n+    };\n+    assert_eq!([1,2,3,4], d.data.a);\n+\n+    let d : &HasDrop<Baz<[i32]>> = &d;\n+    assert_eq!(&[1,2,3,4], &d.data.a);\n+}"}, {"sha": "d5c122bf681fff187472cb48db55b7bc52d3a7bc", "filename": "compiler/rustc_codegen_cranelift/example/example.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Fexample.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Fexample.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fexample.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,208 @@\n+#![feature(no_core, unboxed_closures)]\n+#![no_core]\n+#![allow(dead_code)]\n+\n+extern crate mini_core;\n+\n+use mini_core::*;\n+\n+pub fn abc(a: u8) -> u8 {\n+    a * 2\n+}\n+\n+pub fn bcd(b: bool, a: u8) -> u8 {\n+    if b {\n+        a * 2\n+    } else {\n+        a * 3\n+    }\n+}\n+\n+pub fn call() {\n+    abc(42);\n+}\n+\n+pub fn indirect_call() {\n+    let f: fn() = call;\n+    f();\n+}\n+\n+pub enum BoolOption {\n+    Some(bool),\n+    None,\n+}\n+\n+pub fn option_unwrap_or(o: BoolOption, d: bool) -> bool {\n+    match o {\n+        BoolOption::Some(b) => b,\n+        BoolOption::None => d,\n+    }\n+}\n+\n+pub fn ret_42() -> u8 {\n+    42\n+}\n+\n+pub fn return_str() -> &'static str {\n+    \"hello world\"\n+}\n+\n+pub fn promoted_val() -> &'static u8 {\n+    &(1 * 2)\n+}\n+\n+pub fn cast_ref_to_raw_ptr(abc: &u8) -> *const u8 {\n+    abc as *const u8\n+}\n+\n+pub fn cmp_raw_ptr(a: *const u8, b: *const u8) -> bool {\n+    a == b\n+}\n+\n+pub fn int_cast(a: u16, b: i16) -> (u8, u16, u32, usize, i8, i16, i32, isize, u8, u32) {\n+    (\n+        a as u8, a as u16, a as u32, a as usize, a as i8, a as i16, a as i32, a as isize, b as u8,\n+        b as u32,\n+    )\n+}\n+\n+pub fn char_cast(c: char) -> u8 {\n+    c as u8\n+}\n+\n+pub struct DebugTuple(());\n+\n+pub fn debug_tuple() -> DebugTuple {\n+    DebugTuple(())\n+}\n+\n+pub fn size_of<T>() -> usize {\n+    intrinsics::size_of::<T>()\n+}\n+\n+pub fn use_size_of() -> usize {\n+    size_of::<u64>()\n+}\n+\n+pub unsafe fn use_copy_intrinsic(src: *const u8, dst: *mut u8) {\n+    intrinsics::copy::<u8>(src, dst, 1);\n+}\n+\n+pub unsafe fn use_copy_intrinsic_ref(src: *const u8, dst: *mut u8) {\n+    let copy2 = &intrinsics::copy::<u8>;\n+    copy2(src, dst, 1);\n+}\n+\n+pub const ABC: u8 = 6 * 7;\n+\n+pub fn use_const() -> u8 {\n+    ABC\n+}\n+\n+pub fn call_closure_3arg() {\n+    (|_, _, _| {})(0u8, 42u16, 0u8)\n+}\n+\n+pub fn call_closure_2arg() {\n+    (|_, _| {})(0u8, 42u16)\n+}\n+\n+pub struct IsNotEmpty;\n+\n+impl<'a, 'b> FnOnce<(&'a &'b [u16],)> for IsNotEmpty {\n+    type Output = (u8, u8);\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b [u16],)) -> (u8, u8) {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl<'a, 'b> FnMut<(&'a &'b [u16],)> for IsNotEmpty {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, _arg: (&'a &'b [u16],)) -> (u8, u8) {\n+        (0, 42)\n+    }\n+}\n+\n+pub fn call_is_not_empty() {\n+    IsNotEmpty.call_once((&(&[0u16] as &[_]),));\n+}\n+\n+pub fn eq_char(a: char, b: char) -> bool {\n+    a == b\n+}\n+\n+pub unsafe fn transmute(c: char) -> u32 {\n+    intrinsics::transmute(c)\n+}\n+\n+pub unsafe fn deref_str_ptr(s: *const str) -> &'static str {\n+    &*s\n+}\n+\n+pub fn use_array(arr: [u8; 3]) -> u8 {\n+    arr[1]\n+}\n+\n+pub fn repeat_array() -> [u8; 3] {\n+    [0; 3]\n+}\n+\n+pub fn array_as_slice(arr: &[u8; 3]) -> &[u8] {\n+    arr\n+}\n+\n+pub unsafe fn use_ctlz_nonzero(a: u16) -> u16 {\n+    intrinsics::ctlz_nonzero(a)\n+}\n+\n+pub fn ptr_as_usize(ptr: *const u8) -> usize {\n+    ptr as usize\n+}\n+\n+pub fn float_cast(a: f32, b: f64) -> (f64, f32) {\n+    (a as f64, b as f32)\n+}\n+\n+pub fn int_to_float(a: u8, b: i32) -> (f64, f32) {\n+    (a as f64, b as f32)\n+}\n+\n+pub fn make_array() -> [u8; 3] {\n+    [42, 0, 5]\n+}\n+\n+pub fn some_promoted_tuple() -> &'static (&'static str, &'static str) {\n+    &(\"abc\", \"some\")\n+}\n+\n+pub fn index_slice(s: &[u8]) -> u8 {\n+    s[2]\n+}\n+\n+pub struct StrWrapper {\n+    s: str,\n+}\n+\n+pub fn str_wrapper_get(w: &StrWrapper) -> &str {\n+    &w.s\n+}\n+\n+pub fn i16_as_i8(a: i16) -> i8 {\n+    a as i8\n+}\n+\n+pub struct Unsized(u8, str);\n+\n+pub fn get_sized_field_ref_from_unsized_type(u: &Unsized) -> &u8 {\n+    &u.0\n+}\n+\n+pub fn get_unsized_field_ref_from_unsized_type(u: &Unsized) -> &str {\n+    &u.1\n+}\n+\n+pub fn reuse_byref_argument_storage(a: (u8, u16, u32)) -> u8 {\n+    a.0\n+}"}, {"sha": "a972beedaa38752f6bb1f476f41e97558bf27e2e", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "added", "additions": 603, "deletions": 0, "changes": 603, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,603 @@\n+#![feature(\n+    no_core, lang_items, intrinsics, unboxed_closures, type_ascription, extern_types,\n+    untagged_unions, decl_macro, rustc_attrs, transparent_unions, optin_builtin_traits,\n+    thread_local,\n+)]\n+#![no_core]\n+#![allow(dead_code)]\n+\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"unsize\"]\n+pub trait Unsize<T: ?Sized> {}\n+\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+\n+#[lang = \"dispatch_from_dyn\"]\n+pub trait DispatchFromDyn<T> {}\n+\n+// &T -> &U\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n+// &mut T -> &mut U\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut T {}\n+// *const T -> *const U\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n+// *mut T -> *mut U\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U>> for Box<T> {}\n+\n+#[lang = \"receiver\"]\n+pub trait Receiver {}\n+\n+impl<T: ?Sized> Receiver for &T {}\n+impl<T: ?Sized> Receiver for &mut T {}\n+impl<T: ?Sized> Receiver for Box<T> {}\n+\n+#[lang = \"copy\"]\n+pub unsafe trait Copy {}\n+\n+unsafe impl Copy for bool {}\n+unsafe impl Copy for u8 {}\n+unsafe impl Copy for u16 {}\n+unsafe impl Copy for u32 {}\n+unsafe impl Copy for u64 {}\n+unsafe impl Copy for usize {}\n+unsafe impl Copy for i8 {}\n+unsafe impl Copy for i16 {}\n+unsafe impl Copy for i32 {}\n+unsafe impl Copy for isize {}\n+unsafe impl Copy for f32 {}\n+unsafe impl Copy for char {}\n+unsafe impl<'a, T: ?Sized> Copy for &'a T {}\n+unsafe impl<T: ?Sized> Copy for *const T {}\n+unsafe impl<T: ?Sized> Copy for *mut T {}\n+unsafe impl<T: Copy> Copy for Option<T> {}\n+\n+#[lang = \"sync\"]\n+pub unsafe trait Sync {}\n+\n+unsafe impl Sync for bool {}\n+unsafe impl Sync for u8 {}\n+unsafe impl Sync for u16 {}\n+unsafe impl Sync for u32 {}\n+unsafe impl Sync for u64 {}\n+unsafe impl Sync for usize {}\n+unsafe impl Sync for i8 {}\n+unsafe impl Sync for i16 {}\n+unsafe impl Sync for i32 {}\n+unsafe impl Sync for isize {}\n+unsafe impl Sync for char {}\n+unsafe impl<'a, T: ?Sized> Sync for &'a T {}\n+unsafe impl Sync for [u8; 16] {}\n+\n+#[lang = \"freeze\"]\n+unsafe auto trait Freeze {}\n+\n+unsafe impl<T: ?Sized> Freeze for PhantomData<T> {}\n+unsafe impl<T: ?Sized> Freeze for *const T {}\n+unsafe impl<T: ?Sized> Freeze for *mut T {}\n+unsafe impl<T: ?Sized> Freeze for &T {}\n+unsafe impl<T: ?Sized> Freeze for &mut T {}\n+\n+#[lang = \"structural_peq\"]\n+pub trait StructuralPartialEq {}\n+\n+#[lang = \"structural_teq\"]\n+pub trait StructuralEq {}\n+\n+#[lang = \"not\"]\n+pub trait Not {\n+    type Output;\n+\n+    fn not(self) -> Self::Output;\n+}\n+\n+impl Not for bool {\n+    type Output = bool;\n+\n+    fn not(self) -> bool {\n+        !self\n+    }\n+}\n+\n+#[lang = \"mul\"]\n+pub trait Mul<RHS = Self> {\n+    type Output;\n+\n+    #[must_use]\n+    fn mul(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Mul for u8 {\n+    type Output = Self;\n+\n+    fn mul(self, rhs: Self) -> Self::Output {\n+        self * rhs\n+    }\n+}\n+\n+impl Mul for usize {\n+    type Output = Self;\n+\n+    fn mul(self, rhs: Self) -> Self::Output {\n+        self * rhs\n+    }\n+}\n+\n+#[lang = \"add\"]\n+pub trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Add for u8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for usize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+#[lang = \"sub\"]\n+pub trait Sub<RHS = Self> {\n+    type Output;\n+\n+    fn sub(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Sub for usize {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for u8 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for i8 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for i16 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+#[lang = \"rem\"]\n+pub trait Rem<RHS = Self> {\n+    type Output;\n+\n+    fn rem(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Rem for usize {\n+    type Output = Self;\n+\n+    fn rem(self, rhs: Self) -> Self {\n+        self % rhs\n+    }\n+}\n+\n+#[lang = \"bitor\"]\n+pub trait BitOr<RHS = Self> {\n+    type Output;\n+\n+    #[must_use]\n+    fn bitor(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl BitOr for bool {\n+    type Output = bool;\n+\n+    fn bitor(self, rhs: bool) -> bool {\n+        self | rhs\n+    }\n+}\n+\n+impl<'a> BitOr<bool> for &'a bool {\n+    type Output = bool;\n+\n+    fn bitor(self, rhs: bool) -> bool {\n+        *self | rhs\n+    }\n+}\n+\n+#[lang = \"eq\"]\n+pub trait PartialEq<Rhs: ?Sized = Self> {\n+    fn eq(&self, other: &Rhs) -> bool;\n+    fn ne(&self, other: &Rhs) -> bool;\n+}\n+\n+impl PartialEq for u8 {\n+    fn eq(&self, other: &u8) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &u8) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for u16 {\n+    fn eq(&self, other: &u16) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &u16) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for u32 {\n+    fn eq(&self, other: &u32) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &u32) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+\n+impl PartialEq for u64 {\n+    fn eq(&self, other: &u64) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &u64) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for usize {\n+    fn eq(&self, other: &usize) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &usize) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for i8 {\n+    fn eq(&self, other: &i8) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &i8) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for i32 {\n+    fn eq(&self, other: &i32) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &i32) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for isize {\n+    fn eq(&self, other: &isize) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &isize) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for char {\n+    fn eq(&self, other: &char) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &char) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl<T: ?Sized> PartialEq for *const T {\n+    fn eq(&self, other: &*const T) -> bool {\n+        *self == *other\n+    }\n+    fn ne(&self, other: &*const T) -> bool {\n+        *self != *other\n+    }\n+}\n+\n+impl <T: PartialEq> PartialEq for Option<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Some(lhs), Some(rhs)) => *lhs == *rhs,\n+            (None, None) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn ne(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Some(lhs), Some(rhs)) => *lhs != *rhs,\n+            (None, None) => false,\n+            _ => true,\n+        }\n+    }\n+}\n+\n+#[lang = \"neg\"]\n+pub trait Neg {\n+    type Output;\n+\n+    fn neg(self) -> Self::Output;\n+}\n+\n+impl Neg for i8 {\n+    type Output = i8;\n+\n+    fn neg(self) -> i8 {\n+        -self\n+    }\n+}\n+\n+impl Neg for i16 {\n+    type Output = i16;\n+\n+    fn neg(self) -> i16 {\n+        self\n+    }\n+}\n+\n+impl Neg for isize {\n+    type Output = isize;\n+\n+    fn neg(self) -> isize {\n+        -self\n+    }\n+}\n+\n+impl Neg for f32 {\n+    type Output = f32;\n+\n+    fn neg(self) -> f32 {\n+        -self\n+    }\n+}\n+\n+pub enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+\n+pub use Option::*;\n+\n+#[lang = \"phantom_data\"]\n+pub struct PhantomData<T: ?Sized>;\n+\n+#[lang = \"fn_once\"]\n+#[rustc_paren_sugar]\n+pub trait FnOnce<Args> {\n+    #[lang = \"fn_once_output\"]\n+    type Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+#[lang = \"fn_mut\"]\n+#[rustc_paren_sugar]\n+pub trait FnMut<Args>: FnOnce<Args> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n+#[lang = \"panic\"]\n+#[track_caller]\n+pub fn panic(_msg: &str) -> ! {\n+    unsafe {\n+        libc::puts(\"Panicking\\n\\0\" as *const str as *const i8);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"panic_bounds_check\"]\n+#[track_caller]\n+fn panic_bounds_check(index: usize, len: usize) -> ! {\n+    unsafe {\n+        libc::printf(\"index out of bounds: the len is %d but the index is %d\\n\\0\" as *const str as *const i8, len, index);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"eh_personality\"]\n+fn eh_personality() -> ! {\n+    loop {}\n+}\n+\n+#[lang = \"drop_in_place\"]\n+#[allow(unconditional_recursion)]\n+pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+    // Code here does not matter - this is replaced by the\n+    // real drop glue by the compiler.\n+    drop_in_place(to_drop);\n+}\n+\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target: ?Sized;\n+\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+#[lang = \"owned_box\"]\n+pub struct Box<T: ?Sized>(*mut T);\n+\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n+\n+impl<T: ?Sized> Drop for Box<T> {\n+    fn drop(&mut self) {\n+        // drop is currently performed by compiler.\n+    }\n+}\n+\n+impl<T> Deref for Box<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &**self\n+    }\n+}\n+\n+#[lang = \"exchange_malloc\"]\n+unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n+    libc::malloc(size)\n+}\n+\n+#[lang = \"box_free\"]\n+unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n+    libc::free(ptr as *mut u8);\n+}\n+\n+#[lang = \"drop\"]\n+pub trait Drop {\n+    fn drop(&mut self);\n+}\n+\n+#[lang = \"manually_drop\"]\n+#[repr(transparent)]\n+pub struct ManuallyDrop<T: ?Sized> {\n+    pub value: T,\n+}\n+\n+#[lang = \"maybe_uninit\"]\n+#[repr(transparent)]\n+pub union MaybeUninit<T> {\n+    pub uninit: (),\n+    pub value: ManuallyDrop<T>,\n+}\n+\n+pub mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+        pub fn size_of<T>() -> usize;\n+        pub fn size_of_val<T: ?::Sized>(val: *const T) -> usize;\n+        pub fn min_align_of<T>() -> usize;\n+        pub fn min_align_of_val<T: ?::Sized>(val: *const T) -> usize;\n+        pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n+        pub fn transmute<T, U>(e: T) -> U;\n+        pub fn ctlz_nonzero<T>(x: T) -> T;\n+        pub fn needs_drop<T>() -> bool;\n+        pub fn bitreverse<T>(x: T) -> T;\n+        pub fn bswap<T>(x: T) -> T;\n+        pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n+    }\n+}\n+\n+pub mod libc {\n+    #[cfg_attr(not(windows), link(name = \"c\"))]\n+    #[cfg_attr(windows, link(name = \"msvcrt\"))]\n+    extern \"C\" {\n+        pub fn puts(s: *const i8) -> i32;\n+        pub fn printf(format: *const i8, ...) -> i32;\n+        pub fn malloc(size: usize) -> *mut u8;\n+        pub fn free(ptr: *mut u8);\n+        pub fn memcpy(dst: *mut u8, src: *const u8, size: usize);\n+        pub fn memmove(dst: *mut u8, src: *const u8, size: usize);\n+        pub fn strncpy(dst: *mut u8, src: *const u8, size: usize);\n+    }\n+}\n+\n+#[lang = \"index\"]\n+pub trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+impl<T> Index<usize> for [T; 3] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+impl<T> Index<usize> for [T] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+extern {\n+    type VaListImpl;\n+}\n+\n+#[lang = \"va_list\"]\n+#[repr(transparent)]\n+pub struct VaList<'a>(&'a mut VaListImpl);\n+\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro stringify($($t:tt)*) { /* compiler built-in */ }\n+\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro file() { /* compiler built-in */ }\n+\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro line() { /* compiler built-in */ }\n+\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro cfg() { /* compiler built-in */ }\n+\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro global_asm() { /* compiler built-in */ }\n+\n+pub static A_STATIC: u8 = 42;\n+\n+#[lang = \"panic_location\"]\n+struct PanicLocation {\n+    file: &'static str,\n+    line: u32,\n+    column: u32,\n+}\n+\n+#[no_mangle]\n+pub fn get_tls() -> u8 {\n+    #[thread_local]\n+    static A: u8 = 42;\n+\n+    A\n+}"}, {"sha": "376056e19383fd1f4ac71043726ecc40e7630e43", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "added", "additions": 448, "deletions": 0, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,448 @@\n+#![feature(\n+    no_core, start, lang_items, box_syntax, never_type, linkage,\n+    extern_types, thread_local\n+)]\n+#![no_core]\n+#![allow(dead_code, non_camel_case_types)]\n+\n+extern crate mini_core;\n+\n+use mini_core::*;\n+use mini_core::libc::*;\n+\n+unsafe extern \"C\" fn my_puts(s: *const i8) {\n+    puts(s);\n+}\n+\n+#[lang = \"termination\"]\n+trait Termination {\n+    fn report(self) -> i32;\n+}\n+\n+impl Termination for () {\n+    fn report(self) -> i32 {\n+        unsafe {\n+            NUM = 6 * 7 + 1 + (1u8 == 1u8) as u8; // 44\n+            *NUM_REF as i32\n+        }\n+    }\n+}\n+\n+trait SomeTrait {\n+    fn object_safe(&self);\n+}\n+\n+impl SomeTrait for &'static str {\n+    fn object_safe(&self) {\n+        unsafe {\n+            puts(*self as *const str as *const i8);\n+        }\n+    }\n+}\n+\n+struct NoisyDrop {\n+    text: &'static str,\n+    inner: NoisyDropInner,\n+}\n+\n+struct NoisyDropInner;\n+\n+impl Drop for NoisyDrop {\n+    fn drop(&mut self) {\n+        unsafe {\n+            puts(self.text as *const str as *const i8);\n+        }\n+    }\n+}\n+\n+impl Drop for NoisyDropInner {\n+    fn drop(&mut self) {\n+        unsafe {\n+            puts(\"Inner got dropped!\\0\" as *const str as *const i8);\n+        }\n+    }\n+}\n+\n+impl SomeTrait for NoisyDrop {\n+    fn object_safe(&self) {}\n+}\n+\n+enum Ordering {\n+    Less = -1,\n+    Equal = 0,\n+    Greater = 1,\n+}\n+\n+#[lang = \"start\"]\n+fn start<T: Termination + 'static>(\n+    main: fn() -> T,\n+    argc: isize,\n+    argv: *const *const u8,\n+) -> isize {\n+    if argc == 3 {\n+        unsafe { puts(*argv as *const i8); }\n+        unsafe { puts(*((argv as usize + intrinsics::size_of::<*const u8>()) as *const *const i8)); }\n+        unsafe { puts(*((argv as usize + 2 * intrinsics::size_of::<*const u8>()) as *const *const i8)); }\n+    }\n+\n+    main().report();\n+    0\n+}\n+\n+static mut NUM: u8 = 6 * 7;\n+static NUM_REF: &'static u8 = unsafe { &NUM };\n+\n+macro_rules! assert {\n+    ($e:expr) => {\n+        if !$e {\n+            panic(stringify!(! $e));\n+        }\n+    };\n+}\n+\n+macro_rules! assert_eq {\n+    ($l:expr, $r: expr) => {\n+        if $l != $r {\n+            panic(stringify!($l != $r));\n+        }\n+    }\n+}\n+\n+struct Unique<T: ?Sized> {\n+    pointer: *const T,\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> {}\n+\n+unsafe fn zeroed<T>() -> T {\n+    let mut uninit = MaybeUninit { uninit: () };\n+    intrinsics::write_bytes(&mut uninit.value.value as *mut T, 0, 1);\n+    uninit.value.value\n+}\n+\n+fn take_f32(_f: f32) {}\n+fn take_unique(_u: Unique<()>) {}\n+\n+fn return_u128_pair() -> (u128, u128) {\n+    (0, 0)\n+}\n+\n+fn call_return_u128_pair() {\n+    return_u128_pair();\n+}\n+\n+fn main() {\n+    take_unique(Unique {\n+        pointer: 0 as *const (),\n+        _marker: PhantomData,\n+    });\n+    take_f32(0.1);\n+\n+    call_return_u128_pair();\n+\n+    let slice = &[0, 1] as &[i32];\n+    let slice_ptr = slice as *const [i32] as *const i32;\n+\n+    assert_eq!(slice_ptr as usize % 4, 0);\n+\n+    //return;\n+\n+    unsafe {\n+        printf(\"Hello %s\\n\\0\" as *const str as *const i8, \"printf\\0\" as *const str as *const i8);\n+\n+        let hello: &[u8] = b\"Hello\\0\" as &[u8; 6];\n+        let ptr: *const i8 = hello as *const [u8] as *const i8;\n+        puts(ptr);\n+\n+        let world: Box<&str> = box \"World!\\0\";\n+        puts(*world as *const str as *const i8);\n+        world as Box<dyn SomeTrait>;\n+\n+        assert_eq!(intrinsics::bitreverse(0b10101000u8), 0b00010101u8);\n+\n+        assert_eq!(intrinsics::bswap(0xabu8), 0xabu8);\n+        assert_eq!(intrinsics::bswap(0xddccu16), 0xccddu16);\n+        assert_eq!(intrinsics::bswap(0xffee_ddccu32), 0xccdd_eeffu32);\n+        assert_eq!(intrinsics::bswap(0x1234_5678_ffee_ddccu64), 0xccdd_eeff_7856_3412u64);\n+\n+        assert_eq!(intrinsics::size_of_val(hello) as u8, 6);\n+\n+        let chars = &['C', 'h', 'a', 'r', 's'];\n+        let chars = chars as &[char];\n+        assert_eq!(intrinsics::size_of_val(chars) as u8, 4 * 5);\n+\n+        let a: &dyn SomeTrait = &\"abc\\0\";\n+        a.object_safe();\n+\n+        assert_eq!(intrinsics::size_of_val(a) as u8, 16);\n+        assert_eq!(intrinsics::size_of_val(&0u32) as u8, 4);\n+\n+        assert_eq!(intrinsics::min_align_of::<u16>() as u8, 2);\n+        assert_eq!(intrinsics::min_align_of_val(&a) as u8, intrinsics::min_align_of::<&str>() as u8);\n+\n+        assert!(!intrinsics::needs_drop::<u8>());\n+        assert!(intrinsics::needs_drop::<NoisyDrop>());\n+\n+        Unique {\n+            pointer: 0 as *const &str,\n+            _marker: PhantomData,\n+        } as Unique<dyn SomeTrait>;\n+\n+        struct MyDst<T: ?Sized>(T);\n+\n+        intrinsics::size_of_val(&MyDst([0u8; 4]) as &MyDst<[u8]>);\n+\n+        struct Foo {\n+            x: u8,\n+            y: !,\n+        }\n+\n+        unsafe fn uninitialized<T>() -> T {\n+            MaybeUninit { uninit: () }.value.value\n+        }\n+\n+        zeroed::<(u8, u8)>();\n+        #[allow(unreachable_code)]\n+        {\n+            if false {\n+                zeroed::<!>();\n+                zeroed::<Foo>();\n+                uninitialized::<Foo>();\n+            }\n+        }\n+    }\n+\n+    let _ = box NoisyDrop {\n+        text: \"Boxed outer got dropped!\\0\",\n+        inner: NoisyDropInner,\n+    } as Box<dyn SomeTrait>;\n+\n+    const FUNC_REF: Option<fn()> = Some(main);\n+    match FUNC_REF {\n+        Some(_) => {},\n+        None => assert!(false),\n+    }\n+\n+    match Ordering::Less {\n+        Ordering::Less => {},\n+        _ => assert!(false),\n+    }\n+\n+    [NoisyDropInner, NoisyDropInner];\n+\n+    let x = &[0u32, 42u32] as &[u32];\n+    match x {\n+        [] => assert_eq!(0u32, 1),\n+        [_, ref y @ ..] => assert_eq!(&x[1] as *const u32 as usize, &y[0] as *const u32 as usize),\n+    }\n+\n+    assert_eq!(((|()| 42u8) as fn(()) -> u8)(()), 42);\n+\n+    #[cfg(not(jit))]\n+    {\n+        extern {\n+            #[linkage = \"extern_weak\"]\n+            static ABC: *const u8;\n+        }\n+\n+        {\n+            extern {\n+                #[linkage = \"extern_weak\"]\n+                static ABC: *const u8;\n+            }\n+        }\n+\n+        unsafe { assert_eq!(ABC as usize, 0); }\n+    }\n+\n+    &mut (|| Some(0 as *const ())) as &mut dyn FnMut() -> Option<*const ()>;\n+\n+    let f = 1000.0;\n+    assert_eq!(f as u8, 255);\n+    let f2 = -1000.0;\n+    assert_eq!(f2 as i8, -128);\n+    assert_eq!(f2 as u8, 0);\n+\n+    static ANOTHER_STATIC: &u8 = &A_STATIC;\n+    assert_eq!(*ANOTHER_STATIC, 42);\n+\n+    check_niche_behavior();\n+\n+    extern \"C\" {\n+        type ExternType;\n+    }\n+\n+    struct ExternTypeWrapper {\n+        _a: ExternType,\n+    }\n+\n+    let nullptr = 0 as *const ();\n+    let extern_nullptr = nullptr as *const ExternTypeWrapper;\n+    extern_nullptr as *const ();\n+    let slice_ptr = &[] as *const [u8];\n+    slice_ptr as *const u8;\n+\n+    let repeat = [Some(42); 2];\n+    assert_eq!(repeat[0], Some(42));\n+    assert_eq!(repeat[1], Some(42));\n+\n+    #[cfg(not(jit))]\n+    test_tls();\n+\n+    #[cfg(all(not(jit), target_os = \"linux\"))]\n+    unsafe {\n+        global_asm_test();\n+    }\n+}\n+\n+#[cfg(all(not(jit), target_os = \"linux\"))]\n+extern \"C\" {\n+    fn global_asm_test();\n+}\n+\n+#[cfg(all(not(jit), target_os = \"linux\"))]\n+global_asm! {\n+    \"\n+    .global global_asm_test\n+    global_asm_test:\n+    // comment that would normally be removed by LLVM\n+    ret\n+    \"\n+}\n+\n+#[repr(C)]\n+enum c_void {\n+    _1,\n+    _2,\n+}\n+\n+type c_int = i32;\n+type c_ulong = u64;\n+\n+type pthread_t = c_ulong;\n+\n+#[repr(C)]\n+struct pthread_attr_t {\n+    __size: [u64; 7],\n+}\n+\n+#[link(name = \"pthread\")]\n+extern \"C\" {\n+    fn pthread_attr_init(attr: *mut pthread_attr_t) -> c_int;\n+\n+    fn pthread_create(\n+        native: *mut pthread_t,\n+        attr: *const pthread_attr_t,\n+        f: extern \"C\" fn(_: *mut c_void) -> *mut c_void,\n+        value: *mut c_void\n+    ) -> c_int;\n+\n+    fn pthread_join(\n+        native: pthread_t,\n+        value: *mut *mut c_void\n+    ) -> c_int;\n+}\n+\n+#[thread_local]\n+#[cfg(not(jit))]\n+static mut TLS: u8 = 42;\n+\n+#[cfg(not(jit))]\n+extern \"C\" fn mutate_tls(_: *mut c_void) -> *mut c_void {\n+    unsafe { TLS = 0; }\n+    0 as *mut c_void\n+}\n+\n+#[cfg(not(jit))]\n+fn test_tls() {\n+    unsafe {\n+        let mut attr: pthread_attr_t = zeroed();\n+        let mut thread: pthread_t = 0;\n+\n+        assert_eq!(TLS, 42);\n+\n+        if pthread_attr_init(&mut attr) != 0 {\n+            assert!(false);\n+        }\n+\n+        if pthread_create(&mut thread, &attr, mutate_tls, 0 as *mut c_void) != 0 {\n+            assert!(false);\n+        }\n+\n+        let mut res = 0 as *mut c_void;\n+        pthread_join(thread, &mut res);\n+\n+        // TLS of main thread must not have been changed by the other thread.\n+        assert_eq!(TLS, 42);\n+\n+        puts(\"TLS works!\\n\\0\" as *const str as *const i8);\n+    }\n+}\n+\n+// Copied ui/issues/issue-61696.rs\n+\n+pub enum Infallible {}\n+\n+// The check that the `bool` field of `V1` is encoding a \"niche variant\"\n+// (i.e. not `V1`, so `V3` or `V4`) used to be mathematically incorrect,\n+// causing valid `V1` values to be interpreted as other variants.\n+pub enum E1 {\n+    V1 { f: bool },\n+    V2 { f: Infallible },\n+    V3,\n+    V4,\n+}\n+\n+// Computing the discriminant used to be done using the niche type (here `u8`,\n+// from the `bool` field of `V1`), overflowing for variants with large enough\n+// indices (`V3` and `V4`), causing them to be interpreted as other variants.\n+pub enum E2<X> {\n+    V1 { f: bool },\n+\n+    /*_00*/ _01(X), _02(X), _03(X), _04(X), _05(X), _06(X), _07(X),\n+    _08(X), _09(X), _0A(X), _0B(X), _0C(X), _0D(X), _0E(X), _0F(X),\n+    _10(X), _11(X), _12(X), _13(X), _14(X), _15(X), _16(X), _17(X),\n+    _18(X), _19(X), _1A(X), _1B(X), _1C(X), _1D(X), _1E(X), _1F(X),\n+    _20(X), _21(X), _22(X), _23(X), _24(X), _25(X), _26(X), _27(X),\n+    _28(X), _29(X), _2A(X), _2B(X), _2C(X), _2D(X), _2E(X), _2F(X),\n+    _30(X), _31(X), _32(X), _33(X), _34(X), _35(X), _36(X), _37(X),\n+    _38(X), _39(X), _3A(X), _3B(X), _3C(X), _3D(X), _3E(X), _3F(X),\n+    _40(X), _41(X), _42(X), _43(X), _44(X), _45(X), _46(X), _47(X),\n+    _48(X), _49(X), _4A(X), _4B(X), _4C(X), _4D(X), _4E(X), _4F(X),\n+    _50(X), _51(X), _52(X), _53(X), _54(X), _55(X), _56(X), _57(X),\n+    _58(X), _59(X), _5A(X), _5B(X), _5C(X), _5D(X), _5E(X), _5F(X),\n+    _60(X), _61(X), _62(X), _63(X), _64(X), _65(X), _66(X), _67(X),\n+    _68(X), _69(X), _6A(X), _6B(X), _6C(X), _6D(X), _6E(X), _6F(X),\n+    _70(X), _71(X), _72(X), _73(X), _74(X), _75(X), _76(X), _77(X),\n+    _78(X), _79(X), _7A(X), _7B(X), _7C(X), _7D(X), _7E(X), _7F(X),\n+    _80(X), _81(X), _82(X), _83(X), _84(X), _85(X), _86(X), _87(X),\n+    _88(X), _89(X), _8A(X), _8B(X), _8C(X), _8D(X), _8E(X), _8F(X),\n+    _90(X), _91(X), _92(X), _93(X), _94(X), _95(X), _96(X), _97(X),\n+    _98(X), _99(X), _9A(X), _9B(X), _9C(X), _9D(X), _9E(X), _9F(X),\n+    _A0(X), _A1(X), _A2(X), _A3(X), _A4(X), _A5(X), _A6(X), _A7(X),\n+    _A8(X), _A9(X), _AA(X), _AB(X), _AC(X), _AD(X), _AE(X), _AF(X),\n+    _B0(X), _B1(X), _B2(X), _B3(X), _B4(X), _B5(X), _B6(X), _B7(X),\n+    _B8(X), _B9(X), _BA(X), _BB(X), _BC(X), _BD(X), _BE(X), _BF(X),\n+    _C0(X), _C1(X), _C2(X), _C3(X), _C4(X), _C5(X), _C6(X), _C7(X),\n+    _C8(X), _C9(X), _CA(X), _CB(X), _CC(X), _CD(X), _CE(X), _CF(X),\n+    _D0(X), _D1(X), _D2(X), _D3(X), _D4(X), _D5(X), _D6(X), _D7(X),\n+    _D8(X), _D9(X), _DA(X), _DB(X), _DC(X), _DD(X), _DE(X), _DF(X),\n+    _E0(X), _E1(X), _E2(X), _E3(X), _E4(X), _E5(X), _E6(X), _E7(X),\n+    _E8(X), _E9(X), _EA(X), _EB(X), _EC(X), _ED(X), _EE(X), _EF(X),\n+    _F0(X), _F1(X), _F2(X), _F3(X), _F4(X), _F5(X), _F6(X), _F7(X),\n+    _F8(X), _F9(X), _FA(X), _FB(X), _FC(X), _FD(X), _FE(X), _FF(X),\n+\n+    V3,\n+    V4,\n+}\n+\n+fn check_niche_behavior () {\n+    if let E1::V2 { .. } = (E1::V1 { f: true }) {\n+        intrinsics::abort();\n+    }\n+\n+    if let E2::V1 { .. } = E2::V3::<Infallible> {\n+        intrinsics::abort();\n+    }\n+}"}, {"sha": "bc65221362346caa557fbe467bc7efab01d41b9a", "filename": "compiler/rustc_codegen_cranelift/example/mod_bench.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmod_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmod_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmod_bench.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,35 @@\n+#![feature(start, box_syntax, core_intrinsics, lang_items)]\n+#![no_std]\n+\n+#[link(name = \"c\")]\n+extern {}\n+\n+#[panic_handler]\n+fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n+    core::intrinsics::abort();\n+}\n+\n+#[lang=\"eh_personality\"]\n+fn eh_personality(){}\n+\n+// Required for rustc_codegen_llvm\n+#[no_mangle]\n+unsafe extern \"C\" fn _Unwind_Resume() {\n+    core::intrinsics::unreachable();\n+}\n+\n+#[start]\n+fn main(_argc: isize, _argv: *const *const u8) -> isize {\n+    for i in 2..10_000_000 {\n+        black_box((i + 1) % i);\n+    }\n+\n+    0\n+}\n+\n+#[inline(never)]\n+fn black_box(i: u32) {\n+    if i != 1 {\n+        core::intrinsics::abort();\n+    }\n+}"}, {"sha": "079b4299049119e3c87573445bc4e6e224ebfffe", "filename": "compiler/rustc_codegen_cranelift/example/std_example.rs", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,343 @@\n+#![feature(core_intrinsics, generators, generator_trait, is_sorted)]\n+\n+#[cfg(target_arch = \"x86_64\")]\n+use std::arch::x86_64::*;\n+use std::io::Write;\n+use std::ops::Generator;\n+\n+fn main() {\n+    println!(\"{:?}\", std::env::args().collect::<Vec<_>>());\n+\n+    let mutex = std::sync::Mutex::new(());\n+    let _guard = mutex.lock().unwrap();\n+\n+    let _ = ::std::iter::repeat('a' as u8).take(10).collect::<Vec<_>>();\n+    let stderr = ::std::io::stderr();\n+    let mut stderr = stderr.lock();\n+\n+    std::thread::spawn(move || {\n+        println!(\"Hello from another thread!\");\n+    });\n+\n+    writeln!(stderr, \"some {} text\", \"<unknown>\").unwrap();\n+\n+    let _ = std::process::Command::new(\"true\").env(\"c\", \"d\").spawn();\n+\n+    println!(\"cargo:rustc-link-lib=z\");\n+\n+    static ONCE: std::sync::Once = std::sync::Once::new();\n+    ONCE.call_once(|| {});\n+\n+    let _eq = LoopState::Continue(()) == LoopState::Break(());\n+\n+    // Make sure ByValPair values with differently sized components are correctly passed\n+    map(None::<(u8, Box<Instruction>)>);\n+\n+    println!(\"{}\", 2.3f32.exp());\n+    println!(\"{}\", 2.3f32.exp2());\n+    println!(\"{}\", 2.3f32.abs());\n+    println!(\"{}\", 2.3f32.sqrt());\n+    println!(\"{}\", 2.3f32.floor());\n+    println!(\"{}\", 2.3f32.ceil());\n+    println!(\"{}\", 2.3f32.min(1.0));\n+    println!(\"{}\", 2.3f32.max(1.0));\n+    println!(\"{}\", 2.3f32.powi(2));\n+    println!(\"{}\", 2.3f32.log2());\n+    assert_eq!(2.3f32.copysign(-1.0), -2.3f32);\n+    println!(\"{}\", 2.3f32.powf(2.0));\n+\n+    assert_eq!(-128i8, (-128i8).saturating_sub(1));\n+    assert_eq!(127i8, 127i8.saturating_sub(-128));\n+    assert_eq!(-128i8, (-128i8).saturating_add(-128));\n+    assert_eq!(127i8, 127i8.saturating_add(1));\n+\n+    assert_eq!(0b0000000000000000000000000010000010000000000000000000000000000000_0000000000100000000000000000000000001000000000000100000000000000u128.leading_zeros(), 26);\n+    assert_eq!(0b0000000000000000000000000010000000000000000000000000000000000000_0000000000000000000000000000000000001000000000000000000010000000u128.trailing_zeros(), 7);\n+\n+    let _d = 0i128.checked_div(2i128);\n+    let _d = 0u128.checked_div(2u128);\n+    assert_eq!(1u128 + 2, 3);\n+\n+    assert_eq!(0b100010000000000000000000000000000u128 >> 10, 0b10001000000000000000000u128);\n+    assert_eq!(0xFEDCBA987654321123456789ABCDEFu128 >> 64, 0xFEDCBA98765432u128);\n+    assert_eq!(0xFEDCBA987654321123456789ABCDEFu128 as i128 >> 64, 0xFEDCBA98765432i128);\n+\n+    let tmp = 353985398u128;\n+    assert_eq!(tmp * 932490u128, 330087843781020u128);\n+\n+    let tmp = -0x1234_5678_9ABC_DEF0i64;\n+    assert_eq!(tmp as i128, -0x1234_5678_9ABC_DEF0i128);\n+\n+    // Check that all u/i128 <-> float casts work correctly.\n+    let houndred_u128 = 100u128;\n+    let houndred_i128 = 100i128;\n+    let houndred_f32 = 100.0f32;\n+    let houndred_f64 = 100.0f64;\n+    assert_eq!(houndred_u128 as f32, 100.0);\n+    assert_eq!(houndred_u128 as f64, 100.0);\n+    assert_eq!(houndred_f32 as u128, 100);\n+    assert_eq!(houndred_f64 as u128, 100);\n+    assert_eq!(houndred_i128 as f32, 100.0);\n+    assert_eq!(houndred_i128 as f64, 100.0);\n+    assert_eq!(houndred_f32 as i128, 100);\n+    assert_eq!(houndred_f64 as i128, 100);\n+\n+    // Test signed 128bit comparing\n+    let max = usize::MAX as i128;\n+    if 100i128 < 0i128 || 100i128 > max {\n+        panic!();\n+    }\n+\n+    test_checked_mul();\n+\n+    let _a = 1u32 << 2u8;\n+\n+    let empty: [i32; 0] = [];\n+    assert!(empty.is_sorted());\n+\n+    println!(\"{:?}\", std::intrinsics::caller_location());\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    unsafe {\n+        test_simd();\n+    }\n+\n+    Box::pin(move |mut _task_context| {\n+        yield ();\n+    }).as_mut().resume(0);\n+\n+    #[derive(Copy, Clone)]\n+    enum Nums {\n+        NegOne = -1,\n+    }\n+\n+    let kind = Nums::NegOne;\n+    assert_eq!(-1i128, kind as i128);\n+\n+    let options = [1u128];\n+    match options[0] {\n+        1 => (),\n+        0 => loop {},\n+        v => panic(v),\n+    };\n+}\n+\n+fn panic(_: u128) {\n+    panic!();\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_simd() {\n+    assert!(is_x86_feature_detected!(\"sse2\"));\n+\n+    let x = _mm_setzero_si128();\n+    let y = _mm_set1_epi16(7);\n+    let or = _mm_or_si128(x, y);\n+    let cmp_eq = _mm_cmpeq_epi8(y, y);\n+    let cmp_lt = _mm_cmplt_epi8(y, y);\n+\n+    assert_eq!(std::mem::transmute::<_, [u16; 8]>(or), [7, 7, 7, 7, 7, 7, 7, 7]);\n+    assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_eq), [0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff]);\n+    assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_lt), [0, 0, 0, 0, 0, 0, 0, 0]);\n+\n+    test_mm_slli_si128();\n+    test_mm_movemask_epi8();\n+    test_mm256_movemask_epi8();\n+    test_mm_add_epi8();\n+    test_mm_add_pd();\n+    test_mm_cvtepi8_epi16();\n+    test_mm_cvtsi128_si64();\n+\n+    test_mm_extract_epi8();\n+    test_mm_insert_epi16();\n+\n+    let mask1 = _mm_movemask_epi8(dbg!(_mm_setr_epi8(255u8 as i8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)));\n+    assert_eq!(mask1, 1);\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_slli_si128() {\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, 1);\n+    let e = _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n+    assert_eq_m128i(r, e);\n+\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, 15);\n+    let e = _mm_setr_epi8(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\n+    assert_eq_m128i(r, e);\n+\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, 16);\n+    assert_eq_m128i(r, _mm_set1_epi8(0));\n+\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, -1);\n+    assert_eq_m128i(_mm_set1_epi8(0), r);\n+\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, -0x80000000);\n+    assert_eq_m128i(r, _mm_set1_epi8(0));\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_movemask_epi8() {\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        0b1000_0000u8 as i8, 0b0, 0b1000_0000u8 as i8, 0b01,\n+        0b0101, 0b1111_0000u8 as i8, 0, 0,\n+        0, 0, 0b1111_0000u8 as i8, 0b0101,\n+        0b01, 0b1000_0000u8 as i8, 0b0, 0b1000_0000u8 as i8,\n+    );\n+    let r = _mm_movemask_epi8(a);\n+    assert_eq!(r, 0b10100100_00100101);\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"avx2\")]\n+unsafe fn test_mm256_movemask_epi8() {\n+    let a = _mm256_set1_epi8(-1);\n+    let r = _mm256_movemask_epi8(a);\n+    let e = -1;\n+    assert_eq!(r, e);\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_add_epi8() {\n+    let a = _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n+    #[rustfmt::skip]\n+    let b = _mm_setr_epi8(\n+        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n+    );\n+    let r = _mm_add_epi8(a, b);\n+    #[rustfmt::skip]\n+    let e = _mm_setr_epi8(\n+        16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,\n+    );\n+    assert_eq_m128i(r, e);\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_add_pd() {\n+    let a = _mm_setr_pd(1.0, 2.0);\n+    let b = _mm_setr_pd(5.0, 10.0);\n+    let r = _mm_add_pd(a, b);\n+    assert_eq_m128d(r, _mm_setr_pd(6.0, 12.0));\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+fn assert_eq_m128i(x: std::arch::x86_64::__m128i, y: std::arch::x86_64::__m128i) {\n+    unsafe {\n+        assert_eq!(std::mem::transmute::<_, [u8; 16]>(x), std::mem::transmute::<_, [u8; 16]>(y));\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"sse2\")]\n+pub unsafe fn assert_eq_m128d(a: __m128d, b: __m128d) {\n+    if _mm_movemask_pd(_mm_cmpeq_pd(a, b)) != 0b11 {\n+        panic!(\"{:?} != {:?}\", a, b);\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_cvtsi128_si64() {\n+    let r = _mm_cvtsi128_si64(std::mem::transmute::<[i64; 2], _>([5, 0]));\n+    assert_eq!(r, 5);\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"sse4.1\")]\n+unsafe fn test_mm_cvtepi8_epi16() {\n+    let a = _mm_set1_epi8(10);\n+    let r = _mm_cvtepi8_epi16(a);\n+    let e = _mm_set1_epi16(10);\n+    assert_eq_m128i(r, e);\n+    let a = _mm_set1_epi8(-10);\n+    let r = _mm_cvtepi8_epi16(a);\n+    let e = _mm_set1_epi16(-10);\n+    assert_eq_m128i(r, e);\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"sse4.1\")]\n+unsafe fn test_mm_extract_epi8() {\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        -1, 1, 2, 3, 4, 5, 6, 7,\n+        8, 9, 10, 11, 12, 13, 14, 15\n+    );\n+    let r1 = _mm_extract_epi8(a, 0);\n+    let r2 = _mm_extract_epi8(a, 19);\n+    assert_eq!(r1, 0xFF);\n+    assert_eq!(r2, 3);\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_insert_epi16() {\n+    let a = _mm_setr_epi16(0, 1, 2, 3, 4, 5, 6, 7);\n+    let r = _mm_insert_epi16(a, 9, 0);\n+    let e = _mm_setr_epi16(9, 1, 2, 3, 4, 5, 6, 7);\n+    assert_eq_m128i(r, e);\n+}\n+\n+fn test_checked_mul() {\n+    let u: Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n+    assert_eq!(u, None);\n+\n+    assert_eq!(1u8.checked_mul(255u8), Some(255u8));\n+    assert_eq!(255u8.checked_mul(255u8), None);\n+    assert_eq!(1i8.checked_mul(127i8), Some(127i8));\n+    assert_eq!(127i8.checked_mul(127i8), None);\n+    assert_eq!((-1i8).checked_mul(-127i8), Some(127i8));\n+    assert_eq!(1i8.checked_mul(-128i8), Some(-128i8));\n+    assert_eq!((-128i8).checked_mul(-128i8), None);\n+\n+    assert_eq!(1u64.checked_mul(u64::max_value()), Some(u64::max_value()));\n+    assert_eq!(u64::max_value().checked_mul(u64::max_value()), None);\n+    assert_eq!(1i64.checked_mul(i64::max_value()), Some(i64::max_value()));\n+    assert_eq!(i64::max_value().checked_mul(i64::max_value()), None);\n+    assert_eq!((-1i64).checked_mul(i64::min_value() + 1), Some(i64::max_value()));\n+    assert_eq!(1i64.checked_mul(i64::min_value()), Some(i64::min_value()));\n+    assert_eq!(i64::min_value().checked_mul(i64::min_value()), None);\n+}\n+\n+#[derive(PartialEq)]\n+enum LoopState {\n+    Continue(()),\n+    Break(())\n+}\n+\n+pub enum Instruction {\n+    Increment,\n+    Loop,\n+}\n+\n+fn map(a: Option<(u8, Box<Instruction>)>) -> Option<Box<Instruction>> {\n+    match a {\n+        None => None,\n+        Some((_, instr)) => Some(instr),\n+    }\n+}"}, {"sha": "2cb84786f56d02e55dc36d9c5515e5bf499c2309", "filename": "compiler/rustc_codegen_cranelift/example/subslice-patterns-const-eval.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Fsubslice-patterns-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Fsubslice-patterns-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fsubslice-patterns-const-eval.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,97 @@\n+// Based on https://github.com/rust-lang/rust/blob/c5840f9d252c2f5cc16698dbf385a29c5de3ca07/src/test/ui/array-slice-vec/subslice-patterns-const-eval-match.rs\n+\n+// Test that array subslice patterns are correctly handled in const evaluation.\n+\n+// run-pass\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct N(u8);\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct Z;\n+\n+macro_rules! n {\n+    ($($e:expr),* $(,)?) => {\n+        [$(N($e)),*]\n+    }\n+}\n+\n+// This macro has an unused variable so that it can be repeated base on the\n+// number of times a repeated variable (`$e` in `z`) occurs.\n+macro_rules! zed {\n+    ($e:expr) => { Z }\n+}\n+\n+macro_rules! z {\n+    ($($e:expr),* $(,)?) => {\n+        [$(zed!($e)),*]\n+    }\n+}\n+\n+// Compare constant evaluation and runtime evaluation of a given expression.\n+macro_rules! compare_evaluation {\n+    ($e:expr, $t:ty $(,)?) => {{\n+        const CONST_EVAL: $t = $e;\n+        const fn const_eval() -> $t { $e }\n+        static CONST_EVAL2: $t = const_eval();\n+        let runtime_eval = $e;\n+        assert_eq!(CONST_EVAL, runtime_eval);\n+        assert_eq!(CONST_EVAL2, runtime_eval);\n+    }}\n+}\n+\n+// Repeat `$test`, substituting the given macro variables with the given\n+// identifiers.\n+//\n+// For example:\n+//\n+// repeat! {\n+//     ($name); X; Y:\n+//     struct $name;\n+// }\n+//\n+// Expands to:\n+//\n+// struct X; struct Y;\n+//\n+// This is used to repeat the tests using both the `N` and `Z`\n+// types.\n+macro_rules! repeat {\n+    (($($dollar:tt $placeholder:ident)*); $($($values:ident),+);*: $($test:tt)*) => {\n+        macro_rules! single {\n+            ($($dollar $placeholder:ident),*) => { $($test)* }\n+        }\n+        $(single!($($values),+);)*\n+    }\n+}\n+\n+fn main() {\n+    repeat! {\n+        ($arr $Ty); n, N; z, Z:\n+        compare_evaluation!({ let [_, x @ .., _] = $arr!(1, 2, 3, 4); x }, [$Ty; 2]);\n+        compare_evaluation!({ let [_, ref x @ .., _] = $arr!(1, 2, 3, 4); x }, &'static [$Ty; 2]);\n+        compare_evaluation!({ let [_, x @ .., _] = &$arr!(1, 2, 3, 4); x }, &'static [$Ty; 2]);\n+\n+        compare_evaluation!({ let [_, _, x @ .., _, _] = $arr!(1, 2, 3, 4); x }, [$Ty; 0]);\n+        compare_evaluation!(\n+            { let [_, _, ref x @ .., _, _] = $arr!(1, 2, 3, 4); x },\n+            &'static [$Ty; 0],\n+        );\n+        compare_evaluation!(\n+            { let [_, _, x @ .., _, _] = &$arr!(1, 2, 3, 4); x },\n+            &'static [$Ty; 0],\n+        );\n+\n+        compare_evaluation!({ let [_, .., x] = $arr!(1, 2, 3, 4); x }, $Ty);\n+        compare_evaluation!({ let [_, .., ref x] = $arr!(1, 2, 3, 4); x }, &'static $Ty);\n+        compare_evaluation!({ let [_, _y @ .., x] = &$arr!(1, 2, 3, 4); x }, &'static $Ty);\n+    }\n+\n+    compare_evaluation!({ let [_, .., N(x)] = n!(1, 2, 3, 4); x }, u8);\n+    compare_evaluation!({ let [_, .., N(ref x)] = n!(1, 2, 3, 4); x }, &'static u8);\n+    compare_evaluation!({ let [_, .., N(x)] = &n!(1, 2, 3, 4); x }, &'static u8);\n+\n+    compare_evaluation!({ let [N(x), .., _] = n!(1, 2, 3, 4); x }, u8);\n+    compare_evaluation!({ let [N(ref x), .., _] = n!(1, 2, 3, 4); x }, &'static u8);\n+    compare_evaluation!({ let [N(x), .., _] = &n!(1, 2, 3, 4); x }, &'static u8);\n+}"}, {"sha": "93bab17e46b27c4dec994bd9346507db8f708dde", "filename": "compiler/rustc_codegen_cranelift/example/track-caller-attribute.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Ftrack-caller-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fexample%2Ftrack-caller-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Ftrack-caller-attribute.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,40 @@\n+// Based on https://github.com/anp/rust/blob/175631311716d7dfeceec40d2587cde7142ffa8c/src/test/ui/rfc-2091-track-caller/track-caller-attribute.rs\n+\n+// run-pass\n+\n+use std::panic::Location;\n+\n+#[track_caller]\n+fn tracked() -> &'static Location<'static> {\n+    Location::caller()\n+}\n+\n+fn nested_intrinsic() -> &'static Location<'static> {\n+    Location::caller()\n+}\n+\n+fn nested_tracked() -> &'static Location<'static> {\n+    tracked()\n+}\n+\n+fn main() {\n+    let location = Location::caller();\n+    assert_eq!(location.file(), file!());\n+    assert_eq!(location.line(), 21);\n+    assert_eq!(location.column(), 20);\n+\n+    let tracked = tracked();\n+    assert_eq!(tracked.file(), file!());\n+    assert_eq!(tracked.line(), 26);\n+    assert_eq!(tracked.column(), 19);\n+\n+    let nested = nested_intrinsic();\n+    assert_eq!(nested.file(), file!());\n+    assert_eq!(nested.line(), 13);\n+    assert_eq!(nested.column(), 5);\n+\n+    let contained = nested_tracked();\n+    assert_eq!(contained.file(), file!());\n+    assert_eq!(contained.line(), 17);\n+    assert_eq!(contained.column(), 5);\n+}"}, {"sha": "ee8548783de65f98b6f79274a34f557cd2633ed7", "filename": "compiler/rustc_codegen_cranelift/patches/0022-core-Disable-not-compiling-tests.patch", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,123 @@\n+From f6befc4bb51d84f5f1cf35938a168c953d421350 Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Sun, 24 Nov 2019 15:10:23 +0100\n+Subject: [PATCH] [core] Disable not compiling tests\n+\n+---\n+ library/core/tests/Cargo.toml         | 8 ++++++++\n+ library/core/tests/num/flt2dec/mod.rs | 1 -\n+ library/core/tests/num/int_macros.rs  | 2 ++\n+ library/core/tests/num/uint_macros.rs | 2 ++\n+ library/core/tests/ptr.rs             | 2 ++\n+ library/core/tests/slice.rs           | 2 ++\n+ 6 files changed, 16 insertions(+), 1 deletion(-)\n+ create mode 100644 library/core/tests/Cargo.toml\n+\n+diff --git a/library/core/tests/Cargo.toml b/library/core/tests/Cargo.toml\n+new file mode 100644\n+index 0000000..46fd999\n+--- /dev/null\n++++ b/library/core/tests/Cargo.toml\n+@@ -0,0 +1,8 @@\n++[package]\n++name = \"core\"\n++version = \"0.0.0\"\n++edition = \"2018\"\n++\n++[lib]\n++name = \"coretests\"\n++path = \"lib.rs\"\n+diff --git a/library/core/tests/num/flt2dec/mod.rs b/library/core/tests/num/flt2dec/mod.rs\n+index a35897e..f0bf645 100644\n+--- a/library/core/tests/num/flt2dec/mod.rs\n++++ b/library/core/tests/num/flt2dec/mod.rs\n+@@ -13,7 +13,6 @@ mod strategy {\n+     mod dragon;\n+     mod grisu;\n+ }\n+-mod random;\n+ \n+ pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n+     match decode(v).1 {\n+diff --git a/library/core/tests/num/int_macros.rs b/library/core/tests/num/int_macros.rs\n+index 0475aeb..9558198 100644\n+--- a/library/core/tests/num/int_macros.rs\n++++ b/library/core/tests/num/int_macros.rs\n+@@ -88,6 +88,7 @@ mod tests {\n+                 assert_eq!(x.trailing_ones(), 0);\n+             }\n+ \n++            /*\n+             #[test]\n+             fn test_rotate() {\n+                 assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n+@@ -112,6 +113,7 @@ mod tests {\n+                 assert_eq!(B.rotate_left(64), B);\n+                 assert_eq!(C.rotate_left(64), C);\n+             }\n++            */\n+ \n+             #[test]\n+             fn test_swap_bytes() {\n+diff --git a/library/core/tests/num/uint_macros.rs b/library/core/tests/num/uint_macros.rs\n+index 04ed14f..a6e372e 100644\n+--- a/library/core/tests/num/uint_macros.rs\n++++ b/library/core/tests/num/uint_macros.rs\n+@@ -52,6 +52,7 @@ mod tests {\n+                 assert_eq!(x.trailing_ones(), 0);\n+             }\n+ \n++            /*\n+             #[test]\n+             fn test_rotate() {\n+                 assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n+@@ -76,6 +77,7 @@ mod tests {\n+                 assert_eq!(B.rotate_left(64), B);\n+                 assert_eq!(C.rotate_left(64), C);\n+             }\n++            */\n+ \n+             #[test]\n+             fn test_swap_bytes() {\n+diff --git a/library/core/tests/ptr.rs b/library/core/tests/ptr.rs\n+index 1a6be3a..42dbd59 100644\n+--- a/library/core/tests/ptr.rs\n++++ b/library/core/tests/ptr.rs\n+@@ -250,6 +250,7 @@ fn test_unsized_nonnull() {\n+     assert!(ys == zs);\n+ }\n+ \n++/*\n+ #[test]\n+ #[allow(warnings)]\n+ // Have a symbol for the test below. It doesn\u2019t need to be an actual variadic function, match the\n+@@ -289,6 +290,7 @@ fn write_unaligned_drop() {\n+     }\n+     DROPS.with(|d| assert_eq!(*d.borrow(), [0]));\n+ }\n++*/\n+ \n+ #[test]\n+ fn align_offset_zst() {\n+diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n+index 6609bc3..241b497 100644\n+--- a/library/core/tests/slice.rs\n++++ b/library/core/tests/slice.rs\n+@@ -1209,6 +1209,7 @@ fn brute_force_rotate_test_1() {\n+     }\n+ }\n+ \n++/*\n+ #[test]\n+ #[cfg(not(target_arch = \"wasm32\"))]\n+ fn sort_unstable() {\n+@@ -1394,6 +1395,7 @@ fn partition_at_index() {\n+     v.select_nth_unstable(0);\n+     assert!(v == [0xDEADBEEF]);\n+ }\n++*/\n+ \n+ #[test]\n+ #[should_panic(expected = \"index 0 greater than length of slice\")]\n+--\n+2.21.0 (Apple Git-122)"}, {"sha": "5d2c3049f60ebfb03d44e5885d14390d1e0371d2", "filename": "compiler/rustc_codegen_cranelift/patches/0023-core-Ignore-failing-tests.patch", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-core-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-core-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-core-Ignore-failing-tests.patch?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,90 @@\n+From dd82e95c9de212524e14fc60155de1ae40156dfc Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Sun, 24 Nov 2019 15:34:06 +0100\n+Subject: [PATCH] [core] Ignore failing tests\n+\n+---\n+ library/core/tests/iter.rs       |  4 ++++\n+ library/core/tests/num/bignum.rs | 10 ++++++++++\n+ library/core/tests/num/mod.rs    |  5 +++--\n+ library/core/tests/time.rs       |  1 +\n+ 4 files changed, 18 insertions(+), 2 deletions(-)\n+\n+diff --git a/library/core/tests/array.rs b/library/core/tests/array.rs\n+index 4bc44e9..8e3c7a4 100644\n+--- a/library/core/tests/array.rs\n++++ b/library/core/tests/array.rs\n+@@ -242,6 +242,7 @@ fn iterator_drops() {\n+     assert_eq!(i.get(), 5);\n+ }\n+ \n++/*\n+ // This test does not work on targets without panic=unwind support.\n+ // To work around this problem, test is marked is should_panic, so it will\n+ // be automagically skipped on unsuitable targets, such as\n+@@ -283,6 +284,7 @@ fn array_default_impl_avoids_leaks_on_panic() {\n+     assert_eq!(COUNTER.load(Relaxed), 0);\n+     panic!(\"test succeeded\")\n+ }\n++*/\n+ \n+ #[test]\n+ fn empty_array_is_always_default() {\n+@@ -304,6 +304,7 @@ fn array_map() {\n+     assert_eq!(b, [1, 2, 3]);\n+ }\n+ \n++/*\n+ // See note on above test for why `should_panic` is used.\n+ #[test]\n+ #[should_panic(expected = \"test succeeded\")]\n+@@ -332,6 +333,7 @@ fn array_map_drop_safety() {\n+     assert_eq!(DROPPED.load(Ordering::SeqCst), num_to_create);\n+     panic!(\"test succeeded\")\n+ }\n++*/\n+ \n+ #[test]\n+ fn cell_allows_array_cycle() {\n+diff --git a/library/core/tests/num/mod.rs b/library/core/tests/num/mod.rs\n+index a17c094..5bb11d2 100644\n+--- a/library/core/tests/num/mod.rs\n++++ b/library/core/tests/num/mod.rs\n+@@ -651,11 +651,12 @@ macro_rules! test_float {\n+                 assert_eq!((9.0 as $fty).min($neginf), $neginf);\n+                 assert_eq!(($neginf as $fty).min(-9.0), $neginf);\n+                 assert_eq!((-9.0 as $fty).min($neginf), $neginf);\n+-                assert_eq!(($nan as $fty).min(9.0), 9.0);\n+-                assert_eq!(($nan as $fty).min(-9.0), -9.0);\n+-                assert_eq!((9.0 as $fty).min($nan), 9.0);\n+-                assert_eq!((-9.0 as $fty).min($nan), -9.0);\n+-                assert!(($nan as $fty).min($nan).is_nan());\n++                // Cranelift fmin has NaN propagation\n++                //assert_eq!(($nan as $fty).min(9.0), 9.0);\n++                //assert_eq!(($nan as $fty).min(-9.0), -9.0);\n++                //assert_eq!((9.0 as $fty).min($nan), 9.0);\n++                //assert_eq!((-9.0 as $fty).min($nan), -9.0);\n++                //assert!(($nan as $fty).min($nan).is_nan());\n+             }\n+             #[test]\n+             fn max() {\n+@@ -673,11 +674,12 @@ macro_rules! test_float {\n+                 assert_eq!((9.0 as $fty).max($neginf), 9.0);\n+                 assert_eq!(($neginf as $fty).max(-9.0), -9.0);\n+                 assert_eq!((-9.0 as $fty).max($neginf), -9.0);\n+-                assert_eq!(($nan as $fty).max(9.0), 9.0);\n+-                assert_eq!(($nan as $fty).max(-9.0), -9.0);\n+-                assert_eq!((9.0 as $fty).max($nan), 9.0);\n+-                assert_eq!((-9.0 as $fty).max($nan), -9.0);\n+-                assert!(($nan as $fty).max($nan).is_nan());\n++                // Cranelift fmax has NaN propagation\n++                //assert_eq!(($nan as $fty).max(9.0), 9.0);\n++                //assert_eq!(($nan as $fty).max(-9.0), -9.0);\n++                //assert_eq!((9.0 as $fty).max($nan), 9.0);\n++                //assert_eq!((-9.0 as $fty).max($nan), -9.0);\n++                //assert!(($nan as $fty).max($nan).is_nan());\n+             }\n+             #[test]\n+             fn rem_euclid() {\n+-- \n+2.21.0 (Apple Git-122)"}, {"sha": "87f96f5dcf41ffd52417a3c0e7ccc83b1b00dbca", "filename": "compiler/rustc_codegen_cranelift/prepare.sh", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fprepare.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fprepare.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fprepare.sh?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,29 @@\n+#!/bin/bash --verbose\n+set -e\n+\n+rustup component add rust-src rustc-dev llvm-tools-preview\n+./build_sysroot/prepare_sysroot_src.sh\n+cargo install hyperfine || echo \"Skipping hyperfine install\"\n+\n+git clone https://github.com/rust-random/rand.git || echo \"rust-random/rand has already been cloned\"\n+pushd rand\n+git checkout -- .\n+git checkout 0f933f9c7176e53b2a3c7952ded484e1783f0bf1\n+git am ../crate_patches/*-rand-*.patch\n+popd\n+\n+git clone https://github.com/rust-lang/regex.git || echo \"rust-lang/regex has already been cloned\"\n+pushd regex\n+git checkout -- .\n+git checkout 341f207c1071f7290e3f228c710817c280c8dca1\n+popd\n+\n+git clone https://github.com/ebobby/simple-raytracer || echo \"ebobby/simple-raytracer has already been cloned\"\n+pushd simple-raytracer\n+git checkout -- .\n+git checkout 804a7a21b9e673a482797aa289a18ed480e4d813\n+\n+# build with cg_llvm for perf comparison\n+cargo build\n+mv target/debug/main raytracer_cg_llvm\n+popd"}, {"sha": "87e54719fdc76316af8e8a35a9f8147a3628c186", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1 @@\n+nightly-2020-10-26"}, {"sha": "83cec9c6f36966087559be9ea91788373c0b1a66", "filename": "compiler/rustc_codegen_cranelift/scripts/Readme.md", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fscripts%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fscripts%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2FReadme.md?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,2 @@\n+This directory is for scripts that are either never directly invoked or are not used very often.\n+Scripts that are frequently used should be kept at the project root."}, {"sha": "530b7f242a0982172d31c90a84174d02dd8441cf", "filename": "compiler/rustc_codegen_cranelift/scripts/config.sh", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,56 @@\n+set -e\n+\n+unamestr=`uname`\n+if [[ \"$unamestr\" == 'Linux' ]]; then\n+   dylib_ext='so'\n+elif [[ \"$unamestr\" == 'Darwin' ]]; then\n+   dylib_ext='dylib'\n+else\n+   echo \"Unsupported os\"\n+   exit 1\n+fi\n+\n+HOST_TRIPLE=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n+TARGET_TRIPLE=$HOST_TRIPLE\n+#TARGET_TRIPLE=\"x86_64-pc-windows-gnu\"\n+#TARGET_TRIPLE=\"aarch64-unknown-linux-gnu\"\n+\n+linker=''\n+RUN_WRAPPER=''\n+export JIT_SUPPORTED=1\n+if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n+   export JIT_SUPPORTED=0\n+   if [[ \"$TARGET_TRIPLE\" == \"aarch64-unknown-linux-gnu\" ]]; then\n+      # We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n+      linker='-Clinker=aarch64-linux-gnu-gcc'\n+      RUN_WRAPPER='qemu-aarch64 -L /usr/aarch64-linux-gnu'\n+   elif [[ \"$TARGET_TRIPLE\" == \"x86_64-pc-windows-gnu\" ]]; then\n+      # We are cross-compiling for Windows. Run tests in wine.\n+      RUN_WRAPPER='wine'\n+   else\n+      echo \"Unknown non-native platform\"\n+   fi\n+fi\n+\n+if echo \"$RUSTC_WRAPPER\" | grep sccache; then\n+echo\n+echo -e \"\\x1b[1;93m=== Warning: Unset RUSTC_WRAPPER to prevent interference with sccache ===\\x1b[0m\"\n+echo\n+export RUSTC_WRAPPER=\n+fi\n+\n+export RUSTC=$(pwd)/\"target/\"$CHANNEL\"/cg_clif\"\n+export RUSTFLAGS=$linker\n+export RUSTDOCFLAGS=$linker' -Ztrim-diagnostic-paths=no -Cpanic=abort -Zpanic-abort-tests '\\\n+'-Zcodegen-backend='$(pwd)'/target/'$CHANNEL'/librustc_codegen_cranelift.'$dylib_ext' --sysroot '$(pwd)'/build_sysroot/sysroot'\n+\n+# FIXME remove once the atomic shim is gone\n+if [[ `uname` == 'Darwin' ]]; then\n+   export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n+fi\n+\n+export LD_LIBRARY_PATH=\"$(pwd)/target/out:$(pwd)/build_sysroot/sysroot/lib/rustlib/\"$TARGET_TRIPLE\"/lib:\\\n+$(pwd)/target/\"$CHANNEL\":$(rustc --print sysroot)/lib\"\n+export DYLD_LIBRARY_PATH=$LD_LIBRARY_PATH\n+\n+export CG_CLIF_DISPLAY_CG_TIME=1"}, {"sha": "c70c3ec47f31fac0fe6a4cd07b6f21edd811a824", "filename": "compiler/rustc_codegen_cranelift/scripts/filter_profile.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,126 @@\n+#!/bin/bash\n+#![forbid(unsafe_code)]/* This line is ignored by bash\n+# This block is ignored by rustc\n+CHANNEL=\"release\"\n+pushd $(dirname \"$0\")/../\n+source scripts/config.sh\n+popd\n+PROFILE=$1 OUTPUT=$2 exec $RUSTC $RUSTFLAGS --jit $0\n+#*/\n+\n+//! This program filters away uninteresting samples and trims uninteresting frames for stackcollapse\n+//! profiles.\n+//!\n+//! Usage: ./filter_profile.rs <profile in stackcollapse format> <output file>\n+//!\n+//! This file is specially crafted to be both a valid bash script and valid rust source file. If\n+//! executed as bash script this will run the rust source using cg_clif in JIT mode.\n+\n+use std::io::Write;\n+\n+fn main() -> Result<(), Box<dyn std::error::Error>> {\n+    let profile_name = std::env::var(\"PROFILE\").unwrap();\n+    let output_name = std::env::var(\"OUTPUT\").unwrap();\n+    if profile_name.is_empty() || output_name.is_empty() {\n+        println!(\"Usage: ./filter_profile.rs <profile in stackcollapse format> <output file>\");\n+        std::process::exit(1);\n+    }\n+    let profile = std::fs::read_to_string(profile_name)\n+        .map_err(|err| format!(\"Failed to read profile {}\", err))?;\n+    let mut output = std::fs::OpenOptions::new()\n+        .create(true)\n+        .write(true)\n+        .truncate(true)\n+        .open(output_name)?;\n+\n+    for line in profile.lines() {\n+        let mut stack = &line[..line.rfind(\" \").unwrap()];\n+        let count = &line[line.rfind(\" \").unwrap() + 1..];\n+\n+        // Filter away uninteresting samples\n+        if !stack.contains(\"rustc_codegen_cranelift\") {\n+            continue;\n+        }\n+\n+        if stack.contains(\"rustc_mir::monomorphize::partitioning::collect_and_partition_mono_items\")\n+            || stack.contains(\"rustc_incremental::assert_dep_graph::assert_dep_graph\")\n+            || stack.contains(\"rustc_symbol_mangling::test::report_symbol_names\")\n+        {\n+            continue;\n+        }\n+\n+        // Trim start\n+        if let Some(index) = stack.find(\"rustc_interface::passes::configure_and_expand\") {\n+            stack = &stack[index..];\n+        } else if let Some(index) = stack.find(\"rustc_interface::passes::analysis\") {\n+            stack = &stack[index..];\n+        } else if let Some(index) = stack.find(\"rustc_interface::passes::start_codegen\") {\n+            stack = &stack[index..];\n+        } else if let Some(index) = stack.find(\"rustc_interface::queries::Linker::link\") {\n+            stack = &stack[index..];\n+        }\n+\n+        if let Some(index) = stack.find(\"rustc_codegen_cranelift::driver::aot::module_codegen\") {\n+            stack = &stack[index..];\n+        }\n+\n+        // Trim end\n+        const MALLOC: &str = \"malloc\";\n+        if let Some(index) = stack.find(MALLOC) {\n+            stack = &stack[..index + MALLOC.len()];\n+        }\n+\n+        const FREE: &str = \"free\";\n+        if let Some(index) = stack.find(FREE) {\n+            stack = &stack[..index + FREE.len()];\n+        }\n+\n+        const TYPECK_ITEM_BODIES: &str = \"rustc_typeck::check::typeck_item_bodies\";\n+        if let Some(index) = stack.find(TYPECK_ITEM_BODIES) {\n+            stack = &stack[..index + TYPECK_ITEM_BODIES.len()];\n+        }\n+\n+        const COLLECT_AND_PARTITION_MONO_ITEMS: &str =\n+            \"rustc_mir::monomorphize::partitioning::collect_and_partition_mono_items\";\n+        if let Some(index) = stack.find(COLLECT_AND_PARTITION_MONO_ITEMS) {\n+            stack = &stack[..index + COLLECT_AND_PARTITION_MONO_ITEMS.len()];\n+        }\n+\n+        const ASSERT_DEP_GRAPH: &str = \"rustc_incremental::assert_dep_graph::assert_dep_graph\";\n+        if let Some(index) = stack.find(ASSERT_DEP_GRAPH) {\n+            stack = &stack[..index + ASSERT_DEP_GRAPH.len()];\n+        }\n+\n+        const REPORT_SYMBOL_NAMES: &str = \"rustc_symbol_mangling::test::report_symbol_names\";\n+        if let Some(index) = stack.find(REPORT_SYMBOL_NAMES) {\n+            stack = &stack[..index + REPORT_SYMBOL_NAMES.len()];\n+        }\n+\n+        const ENCODE_METADATA: &str = \"rustc_middle::ty::context::TyCtxt::encode_metadata\";\n+        if let Some(index) = stack.find(ENCODE_METADATA) {\n+            stack = &stack[..index + ENCODE_METADATA.len()];\n+        }\n+\n+        const SUBST_AND_NORMALIZE_ERASING_REGIONS: &str = \"rustc_middle::ty::normalize_erasing_regions::<impl rustc_middle::ty::context::TyCtxt>::subst_and_normalize_erasing_regions\";\n+        if let Some(index) = stack.find(SUBST_AND_NORMALIZE_ERASING_REGIONS) {\n+            stack = &stack[..index + SUBST_AND_NORMALIZE_ERASING_REGIONS.len()];\n+        }\n+\n+        const NORMALIZE_ERASING_LATE_BOUND_REGIONS: &str = \"rustc_middle::ty::normalize_erasing_regions::<impl rustc_middle::ty::context::TyCtxt>::normalize_erasing_late_bound_regions\";\n+        if let Some(index) = stack.find(NORMALIZE_ERASING_LATE_BOUND_REGIONS) {\n+            stack = &stack[..index + NORMALIZE_ERASING_LATE_BOUND_REGIONS.len()];\n+        }\n+\n+        const INST_BUILD: &str = \"<cranelift_frontend::frontend::FuncInstBuilder as cranelift_codegen::ir::builder::InstBuilderBase>::build\";\n+        if let Some(index) = stack.find(INST_BUILD) {\n+            stack = &stack[..index + INST_BUILD.len()];\n+        }\n+\n+        output.write_all(stack.as_bytes())?;\n+        output.write_all(&*b\" \")?;\n+        output.write_all(count.as_bytes())?;\n+        output.write_all(&*b\"\\n\")?;\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "38991d6d47dd04a58e0f9f9f473debaae938b657", "filename": "compiler/rustc_codegen_cranelift/scripts/rustup.sh", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,33 @@\n+#!/bin/bash\n+\n+set -e\n+\n+case $1 in\n+    \"prepare\")\n+        TOOLCHAIN=$(date +%Y-%m-%d)\n+\n+        echo \"=> Installing new nightly\"\n+        rustup toolchain install --profile minimal nightly-${TOOLCHAIN} # Sanity check to see if the nightly exists\n+        echo nightly-${TOOLCHAIN} > rust-toolchain\n+        rustup component add rustfmt || true\n+\n+        echo \"=> Uninstalling all old nighlies\"\n+        for nightly in $(rustup toolchain list | grep nightly | grep -v $TOOLCHAIN | grep -v nightly-x86_64); do\n+            rustup toolchain uninstall $nightly\n+        done\n+\n+        ./clean_all.sh\n+        ./prepare.sh\n+\n+        (cd build_sysroot && cargo update)\n+\n+        ;;\n+    \"commit\")\n+        git add rust-toolchain build_sysroot/Cargo.lock\n+        git commit -m \"Rustup to $(rustc -V)\"\n+        ;;\n+    *)\n+        echo \"Unknown command '$1'\"\n+        echo \"Usage: ./rustup.sh prepare|commit\"\n+        ;;\n+esac"}, {"sha": "7bb00c8d46a4c6c296d04c05f68ca81d5f2e15bb", "filename": "compiler/rustc_codegen_cranelift/src/abi/comments.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,130 @@\n+//! Annotate the clif ir with comments describing how arguments are passed into the current function\n+//! and where all locals are stored.\n+\n+use std::borrow::Cow;\n+\n+use rustc_middle::mir;\n+\n+use cranelift_codegen::entity::EntityRef;\n+\n+use crate::abi::pass_mode::*;\n+use crate::prelude::*;\n+\n+pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+    fx.add_global_comment(format!(\n+        \"kind  loc.idx   param    pass mode                            ty\"\n+    ));\n+}\n+\n+pub(super) fn add_arg_comment<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    kind: &str,\n+    local: Option<mir::Local>,\n+    local_field: Option<usize>,\n+    params: EmptySinglePair<Value>,\n+    pass_mode: PassMode,\n+    ty: Ty<'tcx>,\n+) {\n+    let local = if let Some(local) = local {\n+        Cow::Owned(format!(\"{:?}\", local))\n+    } else {\n+        Cow::Borrowed(\"???\")\n+    };\n+    let local_field = if let Some(local_field) = local_field {\n+        Cow::Owned(format!(\".{}\", local_field))\n+    } else {\n+        Cow::Borrowed(\"\")\n+    };\n+\n+    let params = match params {\n+        Empty => Cow::Borrowed(\"-\"),\n+        Single(param) => Cow::Owned(format!(\"= {:?}\", param)),\n+        Pair(param_a, param_b) => Cow::Owned(format!(\"= {:?}, {:?}\", param_a, param_b)),\n+    };\n+\n+    let pass_mode = format!(\"{:?}\", pass_mode);\n+    fx.add_global_comment(format!(\n+        \"{kind:5}{local:>3}{local_field:<5} {params:10} {pass_mode:36} {ty:?}\",\n+        kind = kind,\n+        local = local,\n+        local_field = local_field,\n+        params = params,\n+        pass_mode = pass_mode,\n+        ty = ty,\n+    ));\n+}\n+\n+pub(super) fn add_locals_header_comment(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+    fx.add_global_comment(String::new());\n+    fx.add_global_comment(format!(\n+        \"kind  local ty                              size align (abi,pref)\"\n+    ));\n+}\n+\n+pub(super) fn add_local_place_comments<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    place: CPlace<'tcx>,\n+    local: Local,\n+) {\n+    let TyAndLayout { ty, layout } = place.layout();\n+    let rustc_target::abi::Layout {\n+        size,\n+        align,\n+        abi: _,\n+        variants: _,\n+        fields: _,\n+        largest_niche: _,\n+    } = layout;\n+\n+    let (kind, extra) = match *place.inner() {\n+        CPlaceInner::Var(place_local, var) => {\n+            assert_eq!(local, place_local);\n+            (\"ssa\", Cow::Owned(format!(\",var={}\", var.index())))\n+        }\n+        CPlaceInner::VarPair(place_local, var1, var2) => {\n+            assert_eq!(local, place_local);\n+            (\n+                \"ssa\",\n+                Cow::Owned(format!(\",var=({}, {})\", var1.index(), var2.index())),\n+            )\n+        }\n+        CPlaceInner::VarLane(_local, _var, _lane) => unreachable!(),\n+        CPlaceInner::Addr(ptr, meta) => {\n+            let meta = if let Some(meta) = meta {\n+                Cow::Owned(format!(\",meta={}\", meta))\n+            } else {\n+                Cow::Borrowed(\"\")\n+            };\n+            match ptr.base_and_offset() {\n+                (crate::pointer::PointerBase::Addr(addr), offset) => (\n+                    \"reuse\",\n+                    format!(\"storage={}{}{}\", addr, offset, meta).into(),\n+                ),\n+                (crate::pointer::PointerBase::Stack(stack_slot), offset) => (\n+                    \"stack\",\n+                    format!(\"storage={}{}{}\", stack_slot, offset, meta).into(),\n+                ),\n+                (crate::pointer::PointerBase::Dangling(align), offset) => (\n+                    \"zst\",\n+                    format!(\"align={},offset={}\", align.bytes(), offset).into(),\n+                ),\n+            }\n+        }\n+    };\n+\n+    fx.add_global_comment(format!(\n+        \"{:<5} {:5} {:30} {:4}b {}, {}{}{}\",\n+        kind,\n+        format!(\"{:?}\", local),\n+        format!(\"{:?}\", ty),\n+        size.bytes(),\n+        align.abi.bytes(),\n+        align.pref.bytes(),\n+        if extra.is_empty() {\n+            \"\"\n+        } else {\n+            \"              \"\n+        },\n+        extra,\n+    ));\n+}"}, {"sha": "801691228431770e98453154e9d80a110a793653", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "added", "additions": 766, "deletions": 0, "changes": 766, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,766 @@\n+//! Handling of everything related to the calling convention. Also fills `fx.local_map`.\n+\n+#[cfg(debug_assertions)]\n+mod comments;\n+mod pass_mode;\n+mod returning;\n+\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_target::spec::abi::Abi;\n+\n+use cranelift_codegen::ir::{AbiParam, ArgumentPurpose};\n+\n+use self::pass_mode::*;\n+use crate::prelude::*;\n+\n+pub(crate) use self::returning::{can_return_to_ssa_var, codegen_return};\n+\n+// Copied from https://github.com/rust-lang/rust/blob/f52c72948aa1dd718cc1f168d21c91c584c0a662/src/librustc_middle/ty/layout.rs#L2301\n+#[rustfmt::skip]\n+pub(crate) fn fn_sig_for_fn_abi<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> ty::PolyFnSig<'tcx> {\n+    use rustc_middle::ty::subst::Subst;\n+\n+    // FIXME(davidtwco,eddyb): A `ParamEnv` should be passed through to this function.\n+    let ty = instance.ty(tcx, ty::ParamEnv::reveal_all());\n+    match *ty.kind() {\n+        ty::FnDef(..) => {\n+            // HACK(davidtwco,eddyb): This is a workaround for polymorphization considering\n+            // parameters unused if they show up in the signature, but not in the `mir::Body`\n+            // (i.e. due to being inside a projection that got normalized, see\n+            // `src/test/ui/polymorphization/normalized_sig_types.rs`), and codegen not keeping\n+            // track of a polymorphization `ParamEnv` to allow normalizing later.\n+            let mut sig = match *ty.kind() {\n+                ty::FnDef(def_id, substs) => tcx\n+                    .normalize_erasing_regions(tcx.param_env(def_id), tcx.fn_sig(def_id))\n+                    .subst(tcx, substs),\n+                _ => unreachable!(),\n+            };\n+\n+            if let ty::InstanceDef::VtableShim(..) = instance.def {\n+                // Modify `fn(self, ...)` to `fn(self: *mut Self, ...)`.\n+                sig = sig.map_bound(|mut sig| {\n+                    let mut inputs_and_output = sig.inputs_and_output.to_vec();\n+                    inputs_and_output[0] = tcx.mk_mut_ptr(inputs_and_output[0]);\n+                    sig.inputs_and_output = tcx.intern_type_list(&inputs_and_output);\n+                    sig\n+                });\n+            }\n+            sig\n+        }\n+        ty::Closure(def_id, substs) => {\n+            let sig = substs.as_closure().sig();\n+\n+            let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n+            sig.map_bound(|sig| {\n+                tcx.mk_fn_sig(\n+                    std::iter::once(env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n+                    sig.output(),\n+                    sig.c_variadic,\n+                    sig.unsafety,\n+                    sig.abi,\n+                )\n+            })\n+        }\n+        ty::Generator(_, substs, _) => {\n+            let sig = substs.as_generator().poly_sig();\n+\n+            let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n+            let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n+\n+            let pin_did = tcx.require_lang_item(rustc_hir::LangItem::Pin, None);\n+            let pin_adt_ref = tcx.adt_def(pin_did);\n+            let pin_substs = tcx.intern_substs(&[env_ty.into()]);\n+            let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n+\n+            sig.map_bound(|sig| {\n+                let state_did = tcx.require_lang_item(rustc_hir::LangItem::GeneratorState, None);\n+                let state_adt_ref = tcx.adt_def(state_did);\n+                let state_substs =\n+                    tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n+                let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+\n+                tcx.mk_fn_sig(\n+                    [env_ty, sig.resume_ty].iter(),\n+                    &ret_ty,\n+                    false,\n+                    rustc_hir::Unsafety::Normal,\n+                    rustc_target::spec::abi::Abi::Rust,\n+                )\n+            })\n+        }\n+        _ => bug!(\"unexpected type {:?} in Instance::fn_sig\", ty),\n+    }\n+}\n+\n+fn clif_sig_from_fn_sig<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    triple: &target_lexicon::Triple,\n+    sig: FnSig<'tcx>,\n+    span: Span,\n+    is_vtable_fn: bool,\n+    requires_caller_location: bool,\n+) -> Signature {\n+    let abi = match sig.abi {\n+        Abi::System => Abi::C,\n+        abi => abi,\n+    };\n+    let (call_conv, inputs, output): (CallConv, Vec<Ty<'tcx>>, Ty<'tcx>) = match abi {\n+        Abi::Rust => (\n+            CallConv::triple_default(triple),\n+            sig.inputs().to_vec(),\n+            sig.output(),\n+        ),\n+        Abi::C | Abi::Unadjusted => (\n+            CallConv::triple_default(triple),\n+            sig.inputs().to_vec(),\n+            sig.output(),\n+        ),\n+        Abi::SysV64 => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n+        Abi::RustCall => {\n+            assert_eq!(sig.inputs().len(), 2);\n+            let extra_args = match sig.inputs().last().unwrap().kind() {\n+                ty::Tuple(ref tupled_arguments) => tupled_arguments,\n+                _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n+            };\n+            let mut inputs: Vec<Ty<'tcx>> = vec![sig.inputs()[0]];\n+            inputs.extend(extra_args.types());\n+            (CallConv::triple_default(triple), inputs, sig.output())\n+        }\n+        Abi::System => unreachable!(),\n+        Abi::RustIntrinsic => (\n+            CallConv::triple_default(triple),\n+            sig.inputs().to_vec(),\n+            sig.output(),\n+        ),\n+        _ => unimplemented!(\"unsupported abi {:?}\", sig.abi),\n+    };\n+\n+    let inputs = inputs\n+        .into_iter()\n+        .enumerate()\n+        .map(|(i, ty)| {\n+            let mut layout = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n+            if i == 0 && is_vtable_fn {\n+                // Virtual calls turn their self param into a thin pointer.\n+                // See https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src/librustc/ty/layout.rs#L2519-L2572 for more info\n+                layout = tcx\n+                    .layout_of(ParamEnv::reveal_all().and(tcx.mk_mut_ptr(tcx.mk_unit())))\n+                    .unwrap();\n+            }\n+            let pass_mode = get_pass_mode(tcx, layout);\n+            if abi != Abi::Rust && abi != Abi::RustCall && abi != Abi::RustIntrinsic {\n+                match pass_mode {\n+                    PassMode::NoPass | PassMode::ByVal(_) => {}\n+                    PassMode::ByRef { size: Some(size) } => {\n+                        let purpose = ArgumentPurpose::StructArgument(u32::try_from(size.bytes()).expect(\"struct too big to pass on stack\"));\n+                        return EmptySinglePair::Single(AbiParam::special(pointer_ty(tcx), purpose)).into_iter();\n+                    }\n+                    PassMode::ByValPair(_, _) | PassMode::ByRef { size: None } => {\n+                        tcx.sess.span_warn(\n+                            span,\n+                            &format!(\n+                                \"Argument of type `{:?}` with pass mode `{:?}` is not yet supported \\\n+                                for non-rust abi `{}`. Calling this function may result in a crash.\",\n+                                layout.ty,\n+                                pass_mode,\n+                                abi,\n+                            ),\n+                        );\n+                    }\n+                }\n+            }\n+            pass_mode.get_param_ty(tcx).map(AbiParam::new).into_iter()\n+        })\n+        .flatten();\n+\n+    let (mut params, returns): (Vec<_>, Vec<_>) = match get_pass_mode(\n+        tcx,\n+        tcx.layout_of(ParamEnv::reveal_all().and(output)).unwrap(),\n+    ) {\n+        PassMode::NoPass => (inputs.collect(), vec![]),\n+        PassMode::ByVal(ret_ty) => (inputs.collect(), vec![AbiParam::new(ret_ty)]),\n+        PassMode::ByValPair(ret_ty_a, ret_ty_b) => (\n+            inputs.collect(),\n+            vec![AbiParam::new(ret_ty_a), AbiParam::new(ret_ty_b)],\n+        ),\n+        PassMode::ByRef { size: Some(_) } => {\n+            (\n+                Some(pointer_ty(tcx)) // First param is place to put return val\n+                    .into_iter()\n+                    .map(|ty| AbiParam::special(ty, ArgumentPurpose::StructReturn))\n+                    .chain(inputs)\n+                    .collect(),\n+                vec![],\n+            )\n+        }\n+        PassMode::ByRef { size: None } => todo!(),\n+    };\n+\n+    if requires_caller_location {\n+        params.push(AbiParam::new(pointer_ty(tcx)));\n+    }\n+\n+    Signature {\n+        params,\n+        returns,\n+        call_conv,\n+    }\n+}\n+\n+pub(crate) fn get_function_name_and_sig<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    triple: &target_lexicon::Triple,\n+    inst: Instance<'tcx>,\n+    support_vararg: bool,\n+) -> (String, Signature) {\n+    assert!(!inst.substs.needs_infer());\n+    let fn_sig = tcx.normalize_erasing_late_bound_regions(\n+        ParamEnv::reveal_all(),\n+        &fn_sig_for_fn_abi(tcx, inst),\n+    );\n+    if fn_sig.c_variadic && !support_vararg {\n+        tcx.sess.span_fatal(\n+            tcx.def_span(inst.def_id()),\n+            \"Variadic function definitions are not yet supported\",\n+        );\n+    }\n+    let sig = clif_sig_from_fn_sig(\n+        tcx,\n+        triple,\n+        fn_sig,\n+        tcx.def_span(inst.def_id()),\n+        false,\n+        inst.def.requires_caller_location(tcx),\n+    );\n+    (tcx.symbol_name(inst).name.to_string(), sig)\n+}\n+\n+/// Instance must be monomorphized\n+pub(crate) fn import_function<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    module: &mut impl Module,\n+    inst: Instance<'tcx>,\n+) -> FuncId {\n+    let (name, sig) = get_function_name_and_sig(tcx, module.isa().triple(), inst, true);\n+    module\n+        .declare_function(&name, Linkage::Import, &sig)\n+        .unwrap()\n+}\n+\n+impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n+    /// Instance must be monomorphized\n+    pub(crate) fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n+        let func_id = import_function(self.tcx, &mut self.cx.module, inst);\n+        let func_ref = self\n+            .cx\n+            .module\n+            .declare_func_in_func(func_id, &mut self.bcx.func);\n+\n+        #[cfg(debug_assertions)]\n+        self.add_comment(func_ref, format!(\"{:?}\", inst));\n+\n+        func_ref\n+    }\n+\n+    pub(crate) fn lib_call(\n+        &mut self,\n+        name: &str,\n+        input_tys: Vec<types::Type>,\n+        output_tys: Vec<types::Type>,\n+        args: &[Value],\n+    ) -> &[Value] {\n+        let sig = Signature {\n+            params: input_tys.iter().cloned().map(AbiParam::new).collect(),\n+            returns: output_tys.iter().cloned().map(AbiParam::new).collect(),\n+            call_conv: CallConv::triple_default(self.triple()),\n+        };\n+        let func_id = self\n+            .cx\n+            .module\n+            .declare_function(&name, Linkage::Import, &sig)\n+            .unwrap();\n+        let func_ref = self\n+            .cx\n+            .module\n+            .declare_func_in_func(func_id, &mut self.bcx.func);\n+        let call_inst = self.bcx.ins().call(func_ref, args);\n+        #[cfg(debug_assertions)]\n+        {\n+            self.add_comment(call_inst, format!(\"easy_call {}\", name));\n+        }\n+        let results = self.bcx.inst_results(call_inst);\n+        assert!(results.len() <= 2, \"{}\", results.len());\n+        results\n+    }\n+\n+    pub(crate) fn easy_call(\n+        &mut self,\n+        name: &str,\n+        args: &[CValue<'tcx>],\n+        return_ty: Ty<'tcx>,\n+    ) -> CValue<'tcx> {\n+        let (input_tys, args): (Vec<_>, Vec<_>) = args\n+            .into_iter()\n+            .map(|arg| {\n+                (\n+                    self.clif_type(arg.layout().ty).unwrap(),\n+                    arg.load_scalar(self),\n+                )\n+            })\n+            .unzip();\n+        let return_layout = self.layout_of(return_ty);\n+        let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n+            tup.types().map(|ty| self.clif_type(ty).unwrap()).collect()\n+        } else {\n+            vec![self.clif_type(return_ty).unwrap()]\n+        };\n+        let ret_vals = self.lib_call(name, input_tys, return_tys, &args);\n+        match *ret_vals {\n+            [] => CValue::by_ref(\n+                Pointer::const_addr(self, i64::from(self.pointer_type.bytes())),\n+                return_layout,\n+            ),\n+            [val] => CValue::by_val(val, return_layout),\n+            [val, extra] => CValue::by_val_pair(val, extra, return_layout),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+/// Make a [`CPlace`] capable of holding value of the specified type.\n+fn make_local_place<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    local: Local,\n+    layout: TyAndLayout<'tcx>,\n+    is_ssa: bool,\n+) -> CPlace<'tcx> {\n+    let place = if is_ssa {\n+        if let rustc_target::abi::Abi::ScalarPair(_, _) = layout.abi {\n+            CPlace::new_var_pair(fx, local, layout)\n+        } else {\n+            CPlace::new_var(fx, local, layout)\n+        }\n+    } else {\n+        CPlace::new_stack_slot(fx, layout)\n+    };\n+\n+    #[cfg(debug_assertions)]\n+    self::comments::add_local_place_comments(fx, place, local);\n+\n+    place\n+}\n+\n+pub(crate) fn codegen_fn_prelude<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    start_block: Block,\n+) {\n+    let ssa_analyzed = crate::analyze::analyze(fx);\n+\n+    #[cfg(debug_assertions)]\n+    self::comments::add_args_header_comment(fx);\n+\n+    let ret_place = self::returning::codegen_return_param(fx, &ssa_analyzed, start_block);\n+    assert_eq!(fx.local_map.push(ret_place), RETURN_PLACE);\n+\n+    // None means pass_mode == NoPass\n+    enum ArgKind<'tcx> {\n+        Normal(Option<CValue<'tcx>>),\n+        Spread(Vec<Option<CValue<'tcx>>>),\n+    }\n+\n+    let func_params = fx\n+        .mir\n+        .args_iter()\n+        .map(|local| {\n+            let arg_ty = fx.monomorphize(&fx.mir.local_decls[local].ty);\n+\n+            // Adapted from https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src/librustc_codegen_llvm/mir/mod.rs#L442-L482\n+            if Some(local) == fx.mir.spread_arg {\n+                // This argument (e.g. the last argument in the \"rust-call\" ABI)\n+                // is a tuple that was spread at the ABI level and now we have\n+                // to reconstruct it into a tuple local variable, from multiple\n+                // individual function arguments.\n+\n+                let tupled_arg_tys = match arg_ty.kind() {\n+                    ty::Tuple(ref tys) => tys,\n+                    _ => bug!(\"spread argument isn't a tuple?! but {:?}\", arg_ty),\n+                };\n+\n+                let mut params = Vec::new();\n+                for (i, arg_ty) in tupled_arg_tys.types().enumerate() {\n+                    let param = cvalue_for_param(fx, start_block, Some(local), Some(i), arg_ty);\n+                    params.push(param);\n+                }\n+\n+                (local, ArgKind::Spread(params), arg_ty)\n+            } else {\n+                let param = cvalue_for_param(fx, start_block, Some(local), None, arg_ty);\n+                (local, ArgKind::Normal(param), arg_ty)\n+            }\n+        })\n+        .collect::<Vec<(Local, ArgKind<'tcx>, Ty<'tcx>)>>();\n+\n+    assert!(fx.caller_location.is_none());\n+    if fx.instance.def.requires_caller_location(fx.tcx) {\n+        // Store caller location for `#[track_caller]`.\n+        fx.caller_location = Some(\n+            cvalue_for_param(fx, start_block, None, None, fx.tcx.caller_location_ty()).unwrap(),\n+        );\n+    }\n+\n+    fx.bcx.switch_to_block(start_block);\n+    fx.bcx.ins().nop();\n+\n+    #[cfg(debug_assertions)]\n+    self::comments::add_locals_header_comment(fx);\n+\n+    for (local, arg_kind, ty) in func_params {\n+        let layout = fx.layout_of(ty);\n+\n+        let is_ssa = ssa_analyzed[local] == crate::analyze::SsaKind::Ssa;\n+\n+        // While this is normally an optimization to prevent an unnecessary copy when an argument is\n+        // not mutated by the current function, this is necessary to support unsized arguments.\n+        match arg_kind {\n+            ArgKind::Normal(Some(val)) => {\n+                if let Some((addr, meta)) = val.try_to_ptr() {\n+                    let local_decl = &fx.mir.local_decls[local];\n+                    //                       v this ! is important\n+                    let internally_mutable = !val.layout().ty.is_freeze(\n+                        fx.tcx.at(local_decl.source_info.span),\n+                        ParamEnv::reveal_all(),\n+                    );\n+                    if local_decl.mutability == mir::Mutability::Not && !internally_mutable {\n+                        // We wont mutate this argument, so it is fine to borrow the backing storage\n+                        // of this argument, to prevent a copy.\n+\n+                        let place = if let Some(meta) = meta {\n+                            CPlace::for_ptr_with_extra(addr, meta, val.layout())\n+                        } else {\n+                            CPlace::for_ptr(addr, val.layout())\n+                        };\n+\n+                        #[cfg(debug_assertions)]\n+                        self::comments::add_local_place_comments(fx, place, local);\n+\n+                        assert_eq!(fx.local_map.push(place), local);\n+                        continue;\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        let place = make_local_place(fx, local, layout, is_ssa);\n+        assert_eq!(fx.local_map.push(place), local);\n+\n+        match arg_kind {\n+            ArgKind::Normal(param) => {\n+                if let Some(param) = param {\n+                    place.write_cvalue(fx, param);\n+                }\n+            }\n+            ArgKind::Spread(params) => {\n+                for (i, param) in params.into_iter().enumerate() {\n+                    if let Some(param) = param {\n+                        place\n+                            .place_field(fx, mir::Field::new(i))\n+                            .write_cvalue(fx, param);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    for local in fx.mir.vars_and_temps_iter() {\n+        let ty = fx.monomorphize(&fx.mir.local_decls[local].ty);\n+        let layout = fx.layout_of(ty);\n+\n+        let is_ssa = ssa_analyzed[local] == crate::analyze::SsaKind::Ssa;\n+\n+        let place = make_local_place(fx, local, layout, is_ssa);\n+        assert_eq!(fx.local_map.push(place), local);\n+    }\n+\n+    fx.bcx\n+        .ins()\n+        .jump(*fx.block_map.get(START_BLOCK).unwrap(), &[]);\n+}\n+\n+pub(crate) fn codegen_terminator_call<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    span: Span,\n+    current_block: Block,\n+    func: &Operand<'tcx>,\n+    args: &[Operand<'tcx>],\n+    destination: Option<(Place<'tcx>, BasicBlock)>,\n+) {\n+    let fn_ty = fx.monomorphize(&func.ty(fx.mir, fx.tcx));\n+    let fn_sig = fx\n+        .tcx\n+        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_ty.fn_sig(fx.tcx));\n+\n+    let destination = destination.map(|(place, bb)| (trans_place(fx, place), bb));\n+\n+    // Handle special calls like instrinsics and empty drop glue.\n+    let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n+        let instance = ty::Instance::resolve(fx.tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n+            .unwrap()\n+            .unwrap()\n+            .polymorphize(fx.tcx);\n+\n+        if fx.tcx.symbol_name(instance).name.starts_with(\"llvm.\") {\n+            crate::intrinsics::codegen_llvm_intrinsic_call(\n+                fx,\n+                &fx.tcx.symbol_name(instance).name,\n+                substs,\n+                args,\n+                destination,\n+            );\n+            return;\n+        }\n+\n+        match instance.def {\n+            InstanceDef::Intrinsic(_) => {\n+                crate::intrinsics::codegen_intrinsic_call(fx, instance, args, destination, span);\n+                return;\n+            }\n+            InstanceDef::DropGlue(_, None) => {\n+                // empty drop glue - a nop.\n+                let (_, dest) = destination.expect(\"Non terminating drop_in_place_real???\");\n+                let ret_block = fx.get_block(dest);\n+                fx.bcx.ins().jump(ret_block, &[]);\n+                return;\n+            }\n+            _ => Some(instance),\n+        }\n+    } else {\n+        None\n+    };\n+\n+    let is_cold = instance\n+        .map(|inst| {\n+            fx.tcx\n+                .codegen_fn_attrs(inst.def_id())\n+                .flags\n+                .contains(CodegenFnAttrFlags::COLD)\n+        })\n+        .unwrap_or(false);\n+    if is_cold {\n+        fx.cold_blocks.insert(current_block);\n+    }\n+\n+    // Unpack arguments tuple for closures\n+    let args = if fn_sig.abi == Abi::RustCall {\n+        assert_eq!(args.len(), 2, \"rust-call abi requires two arguments\");\n+        let self_arg = trans_operand(fx, &args[0]);\n+        let pack_arg = trans_operand(fx, &args[1]);\n+\n+        let tupled_arguments = match pack_arg.layout().ty.kind() {\n+            ty::Tuple(ref tupled_arguments) => tupled_arguments,\n+            _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n+        };\n+\n+        let mut args = Vec::with_capacity(1 + tupled_arguments.len());\n+        args.push(self_arg);\n+        for i in 0..tupled_arguments.len() {\n+            args.push(pack_arg.value_field(fx, mir::Field::new(i)));\n+        }\n+        args\n+    } else {\n+        args.into_iter()\n+            .map(|arg| trans_operand(fx, arg))\n+            .collect::<Vec<_>>()\n+    };\n+\n+    //   | indirect call target\n+    //   |         | the first argument to be passed\n+    //   v         v          v virtual calls are special cased below\n+    let (func_ref, first_arg, is_virtual_call) = match instance {\n+        // Trait object call\n+        Some(Instance {\n+            def: InstanceDef::Virtual(_, idx),\n+            ..\n+        }) => {\n+            #[cfg(debug_assertions)]\n+            {\n+                let nop_inst = fx.bcx.ins().nop();\n+                fx.add_comment(\n+                    nop_inst,\n+                    format!(\n+                        \"virtual call; self arg pass mode: {:?}\",\n+                        get_pass_mode(fx.tcx, args[0].layout())\n+                    ),\n+                );\n+            }\n+            let (ptr, method) = crate::vtable::get_ptr_and_method_ref(fx, args[0], idx);\n+            (Some(method), Single(ptr), true)\n+        }\n+\n+        // Normal call\n+        Some(_) => (\n+            None,\n+            args.get(0)\n+                .map(|arg| adjust_arg_for_abi(fx, *arg))\n+                .unwrap_or(Empty),\n+            false,\n+        ),\n+\n+        // Indirect call\n+        None => {\n+            #[cfg(debug_assertions)]\n+            {\n+                let nop_inst = fx.bcx.ins().nop();\n+                fx.add_comment(nop_inst, \"indirect call\");\n+            }\n+            let func = trans_operand(fx, func).load_scalar(fx);\n+            (\n+                Some(func),\n+                args.get(0)\n+                    .map(|arg| adjust_arg_for_abi(fx, *arg))\n+                    .unwrap_or(Empty),\n+                false,\n+            )\n+        }\n+    };\n+\n+    let ret_place = destination.map(|(place, _)| place);\n+    let (call_inst, call_args) =\n+        self::returning::codegen_with_call_return_arg(fx, fn_sig, ret_place, |fx, return_ptr| {\n+            let mut call_args: Vec<Value> = return_ptr\n+                .into_iter()\n+                .chain(first_arg.into_iter())\n+                .chain(\n+                    args.into_iter()\n+                        .skip(1)\n+                        .map(|arg| adjust_arg_for_abi(fx, arg).into_iter())\n+                        .flatten(),\n+                )\n+                .collect::<Vec<_>>();\n+\n+            if instance\n+                .map(|inst| inst.def.requires_caller_location(fx.tcx))\n+                .unwrap_or(false)\n+            {\n+                // Pass the caller location for `#[track_caller]`.\n+                let caller_location = fx.get_caller_location(span);\n+                call_args.extend(adjust_arg_for_abi(fx, caller_location).into_iter());\n+            }\n+\n+            let call_inst = if let Some(func_ref) = func_ref {\n+                let sig = clif_sig_from_fn_sig(\n+                    fx.tcx,\n+                    fx.triple(),\n+                    fn_sig,\n+                    span,\n+                    is_virtual_call,\n+                    false, // calls through function pointers never pass the caller location\n+                );\n+                let sig = fx.bcx.import_signature(sig);\n+                fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n+            } else {\n+                let func_ref =\n+                    fx.get_function_ref(instance.expect(\"non-indirect call on non-FnDef type\"));\n+                fx.bcx.ins().call(func_ref, &call_args)\n+            };\n+\n+            (call_inst, call_args)\n+        });\n+\n+    // FIXME find a cleaner way to support varargs\n+    if fn_sig.c_variadic {\n+        if fn_sig.abi != Abi::C {\n+            fx.tcx.sess.span_fatal(\n+                span,\n+                &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi),\n+            );\n+        }\n+        let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n+        let abi_params = call_args\n+            .into_iter()\n+            .map(|arg| {\n+                let ty = fx.bcx.func.dfg.value_type(arg);\n+                if !ty.is_int() {\n+                    // FIXME set %al to upperbound on float args once floats are supported\n+                    fx.tcx\n+                        .sess\n+                        .span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n+                }\n+                AbiParam::new(ty)\n+            })\n+            .collect::<Vec<AbiParam>>();\n+        fx.bcx.func.dfg.signatures[sig_ref].params = abi_params;\n+    }\n+\n+    if let Some((_, dest)) = destination {\n+        let ret_block = fx.get_block(dest);\n+        fx.bcx.ins().jump(ret_block, &[]);\n+    } else {\n+        trap_unreachable(fx, \"[corruption] Diverging function returned\");\n+    }\n+}\n+\n+pub(crate) fn codegen_drop<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    span: Span,\n+    drop_place: CPlace<'tcx>,\n+) {\n+    let ty = drop_place.layout().ty;\n+    let drop_fn = Instance::resolve_drop_in_place(fx.tcx, ty).polymorphize(fx.tcx);\n+\n+    if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n+        // we don't actually need to drop anything\n+    } else {\n+        let drop_fn_ty = drop_fn.ty(fx.tcx, ParamEnv::reveal_all());\n+        let fn_sig = fx.tcx.normalize_erasing_late_bound_regions(\n+            ParamEnv::reveal_all(),\n+            &drop_fn_ty.fn_sig(fx.tcx),\n+        );\n+        assert_eq!(fn_sig.output(), fx.tcx.mk_unit());\n+\n+        match ty.kind() {\n+            ty::Dynamic(..) => {\n+                let (ptr, vtable) = drop_place.to_ptr_maybe_unsized();\n+                let ptr = ptr.get_addr(fx);\n+                let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable.unwrap());\n+\n+                let sig = clif_sig_from_fn_sig(\n+                    fx.tcx,\n+                    fx.triple(),\n+                    fn_sig,\n+                    span,\n+                    true,\n+                    false, // `drop_in_place` is never `#[track_caller]`\n+                );\n+                let sig = fx.bcx.import_signature(sig);\n+                fx.bcx.ins().call_indirect(sig, drop_fn, &[ptr]);\n+            }\n+            _ => {\n+                assert!(!matches!(drop_fn.def, InstanceDef::Virtual(_, _)));\n+\n+                let arg_value = drop_place.place_ref(\n+                    fx,\n+                    fx.layout_of(fx.tcx.mk_ref(\n+                        &ty::RegionKind::ReErased,\n+                        TypeAndMut {\n+                            ty,\n+                            mutbl: crate::rustc_hir::Mutability::Mut,\n+                        },\n+                    )),\n+                );\n+                let arg_value = adjust_arg_for_abi(fx, arg_value);\n+\n+                let mut call_args: Vec<Value> = arg_value.into_iter().collect::<Vec<_>>();\n+\n+                if drop_fn.def.requires_caller_location(fx.tcx) {\n+                    // Pass the caller location for `#[track_caller]`.\n+                    let caller_location = fx.get_caller_location(span);\n+                    call_args.extend(adjust_arg_for_abi(fx, caller_location).into_iter());\n+                }\n+\n+                let func_ref = fx.get_function_ref(drop_fn);\n+                fx.bcx.ins().call(func_ref, &call_args);\n+            }\n+        }\n+    }\n+}"}, {"sha": "8e3682c86c5fb678cb87f089835c23b3c13342d4", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,188 @@\n+//! Argument passing\n+\n+use crate::prelude::*;\n+\n+pub(super) use EmptySinglePair::*;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub(super) enum PassMode {\n+    NoPass,\n+    ByVal(Type),\n+    ByValPair(Type, Type),\n+    ByRef { size: Option<Size> },\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub(super) enum EmptySinglePair<T> {\n+    Empty,\n+    Single(T),\n+    Pair(T, T),\n+}\n+\n+impl<T> EmptySinglePair<T> {\n+    pub(super) fn into_iter(self) -> EmptySinglePairIter<T> {\n+        EmptySinglePairIter(self)\n+    }\n+\n+    pub(super) fn map<U>(self, mut f: impl FnMut(T) -> U) -> EmptySinglePair<U> {\n+        match self {\n+            Empty => Empty,\n+            Single(v) => Single(f(v)),\n+            Pair(a, b) => Pair(f(a), f(b)),\n+        }\n+    }\n+}\n+\n+pub(super) struct EmptySinglePairIter<T>(EmptySinglePair<T>);\n+\n+impl<T> Iterator for EmptySinglePairIter<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        match std::mem::replace(&mut self.0, Empty) {\n+            Empty => None,\n+            Single(v) => Some(v),\n+            Pair(a, b) => {\n+                self.0 = Single(b);\n+                Some(a)\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: std::fmt::Debug> EmptySinglePair<T> {\n+    pub(super) fn assert_single(self) -> T {\n+        match self {\n+            Single(v) => v,\n+            _ => panic!(\"Called assert_single on {:?}\", self),\n+        }\n+    }\n+\n+    pub(super) fn assert_pair(self) -> (T, T) {\n+        match self {\n+            Pair(a, b) => (a, b),\n+            _ => panic!(\"Called assert_pair on {:?}\", self),\n+        }\n+    }\n+}\n+\n+impl PassMode {\n+    pub(super) fn get_param_ty(self, tcx: TyCtxt<'_>) -> EmptySinglePair<Type> {\n+        match self {\n+            PassMode::NoPass => Empty,\n+            PassMode::ByVal(clif_type) => Single(clif_type),\n+            PassMode::ByValPair(a, b) => Pair(a, b),\n+            PassMode::ByRef { size: Some(_) } => Single(pointer_ty(tcx)),\n+            PassMode::ByRef { size: None } => Pair(pointer_ty(tcx), pointer_ty(tcx)),\n+        }\n+    }\n+}\n+\n+pub(super) fn get_pass_mode<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> PassMode {\n+    if layout.is_zst() {\n+        // WARNING zst arguments must never be passed, as that will break CastKind::ClosureFnPointer\n+        PassMode::NoPass\n+    } else {\n+        match &layout.abi {\n+            Abi::Uninhabited => PassMode::NoPass,\n+            Abi::Scalar(scalar) => PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone())),\n+            Abi::ScalarPair(a, b) => {\n+                let a = scalar_to_clif_type(tcx, a.clone());\n+                let b = scalar_to_clif_type(tcx, b.clone());\n+                if a == types::I128 && b == types::I128 {\n+                    // Returning (i128, i128) by-val-pair would take 4 regs, while only 3 are\n+                    // available on x86_64. Cranelift gets confused when too many return params\n+                    // are used.\n+                    PassMode::ByRef {\n+                        size: Some(layout.size),\n+                    }\n+                } else {\n+                    PassMode::ByValPair(a, b)\n+                }\n+            }\n+\n+            // FIXME implement Vector Abi in a cg_llvm compatible way\n+            Abi::Vector { .. } => {\n+                if let Some(vector_ty) = crate::intrinsics::clif_vector_type(tcx, layout) {\n+                    PassMode::ByVal(vector_ty)\n+                } else {\n+                    PassMode::ByRef {\n+                        size: Some(layout.size),\n+                    }\n+                }\n+            }\n+\n+            Abi::Aggregate { sized: true } => PassMode::ByRef {\n+                size: Some(layout.size),\n+            },\n+            Abi::Aggregate { sized: false } => PassMode::ByRef { size: None },\n+        }\n+    }\n+}\n+\n+/// Get a set of values to be passed as function arguments.\n+pub(super) fn adjust_arg_for_abi<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    arg: CValue<'tcx>,\n+) -> EmptySinglePair<Value> {\n+    match get_pass_mode(fx.tcx, arg.layout()) {\n+        PassMode::NoPass => Empty,\n+        PassMode::ByVal(_) => Single(arg.load_scalar(fx)),\n+        PassMode::ByValPair(_, _) => {\n+            let (a, b) = arg.load_scalar_pair(fx);\n+            Pair(a, b)\n+        }\n+        PassMode::ByRef { size: _ } => match arg.force_stack(fx) {\n+            (ptr, None) => Single(ptr.get_addr(fx)),\n+            (ptr, Some(meta)) => Pair(ptr.get_addr(fx), meta),\n+        },\n+    }\n+}\n+\n+/// Create a [`CValue`] containing the value of a function parameter adding clif function parameters\n+/// as necessary.\n+pub(super) fn cvalue_for_param<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    start_block: Block,\n+    #[cfg_attr(not(debug_assertions), allow(unused_variables))] local: Option<mir::Local>,\n+    #[cfg_attr(not(debug_assertions), allow(unused_variables))] local_field: Option<usize>,\n+    arg_ty: Ty<'tcx>,\n+) -> Option<CValue<'tcx>> {\n+    let layout = fx.layout_of(arg_ty);\n+    let pass_mode = get_pass_mode(fx.tcx, layout);\n+\n+    if let PassMode::NoPass = pass_mode {\n+        return None;\n+    }\n+\n+    let clif_types = pass_mode.get_param_ty(fx.tcx);\n+    let block_params = clif_types.map(|t| fx.bcx.append_block_param(start_block, t));\n+\n+    #[cfg(debug_assertions)]\n+    crate::abi::comments::add_arg_comment(\n+        fx,\n+        \"arg\",\n+        local,\n+        local_field,\n+        block_params,\n+        pass_mode,\n+        arg_ty,\n+    );\n+\n+    match pass_mode {\n+        PassMode::NoPass => unreachable!(),\n+        PassMode::ByVal(_) => Some(CValue::by_val(block_params.assert_single(), layout)),\n+        PassMode::ByValPair(_, _) => {\n+            let (a, b) = block_params.assert_pair();\n+            Some(CValue::by_val_pair(a, b, layout))\n+        }\n+        PassMode::ByRef { size: Some(_) } => Some(CValue::by_ref(\n+            Pointer::new(block_params.assert_single()),\n+            layout,\n+        )),\n+        PassMode::ByRef { size: None } => {\n+            let (ptr, meta) = block_params.assert_pair();\n+            Some(CValue::by_ref_unsized(Pointer::new(ptr), meta, layout))\n+        }\n+    }\n+}"}, {"sha": "f6d40c880d094f8b644e7b4cb8c57975825298a5", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,130 @@\n+//! Return value handling\n+\n+use crate::abi::pass_mode::*;\n+use crate::prelude::*;\n+\n+fn return_layout<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx, impl Module>) -> TyAndLayout<'tcx> {\n+    fx.layout_of(fx.monomorphize(&fx.mir.local_decls[RETURN_PLACE].ty))\n+}\n+\n+/// Can the given type be returned into an ssa var or does it need to be returned on the stack.\n+pub(crate) fn can_return_to_ssa_var<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    dest_layout: TyAndLayout<'tcx>,\n+) -> bool {\n+    match get_pass_mode(tcx, dest_layout) {\n+        PassMode::NoPass | PassMode::ByVal(_) | PassMode::ByValPair(_, _) => true,\n+        // FIXME Make it possible to return ByRef to an ssa var.\n+        PassMode::ByRef { size: _ } => false,\n+    }\n+}\n+\n+/// Return a place where the return value of the current function can be written to. If necessary\n+/// this adds an extra parameter pointing to where the return value needs to be stored.\n+pub(super) fn codegen_return_param<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    ssa_analyzed: &rustc_index::vec::IndexVec<Local, crate::analyze::SsaKind>,\n+    start_block: Block,\n+) -> CPlace<'tcx> {\n+    let ret_layout = return_layout(fx);\n+    let ret_pass_mode = get_pass_mode(fx.tcx, ret_layout);\n+    let (ret_place, ret_param) = match ret_pass_mode {\n+        PassMode::NoPass => (CPlace::no_place(ret_layout), Empty),\n+        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => {\n+            let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n+            (\n+                super::make_local_place(fx, RETURN_PLACE, ret_layout, is_ssa),\n+                Empty,\n+            )\n+        }\n+        PassMode::ByRef { size: Some(_) } => {\n+            let ret_param = fx.bcx.append_block_param(start_block, fx.pointer_type);\n+            (\n+                CPlace::for_ptr(Pointer::new(ret_param), ret_layout),\n+                Single(ret_param),\n+            )\n+        }\n+        PassMode::ByRef { size: None } => todo!(),\n+    };\n+\n+    #[cfg(not(debug_assertions))]\n+    let _ = ret_param;\n+\n+    #[cfg(debug_assertions)]\n+    crate::abi::comments::add_arg_comment(\n+        fx,\n+        \"ret\",\n+        Some(RETURN_PLACE),\n+        None,\n+        ret_param,\n+        ret_pass_mode,\n+        ret_layout.ty,\n+    );\n+\n+    ret_place\n+}\n+\n+/// Invokes the closure with if necessary a value representing the return pointer. When the closure\n+/// returns the call return value(s) if any are written to the correct place.\n+pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n+    fx: &mut FunctionCx<'_, 'tcx, M>,\n+    fn_sig: FnSig<'tcx>,\n+    ret_place: Option<CPlace<'tcx>>,\n+    f: impl FnOnce(&mut FunctionCx<'_, 'tcx, M>, Option<Value>) -> (Inst, T),\n+) -> (Inst, T) {\n+    let ret_layout = fx.layout_of(fn_sig.output());\n+\n+    let output_pass_mode = get_pass_mode(fx.tcx, ret_layout);\n+    let return_ptr = match output_pass_mode {\n+        PassMode::NoPass => None,\n+        PassMode::ByRef { size: Some(_) } => match ret_place {\n+            Some(ret_place) => Some(ret_place.to_ptr().get_addr(fx)),\n+            None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)), // FIXME allocate temp stack slot\n+        },\n+        PassMode::ByRef { size: None } => todo!(),\n+        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,\n+    };\n+\n+    let (call_inst, meta) = f(fx, return_ptr);\n+\n+    match output_pass_mode {\n+        PassMode::NoPass => {}\n+        PassMode::ByVal(_) => {\n+            if let Some(ret_place) = ret_place {\n+                let ret_val = fx.bcx.inst_results(call_inst)[0];\n+                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_layout));\n+            }\n+        }\n+        PassMode::ByValPair(_, _) => {\n+            if let Some(ret_place) = ret_place {\n+                let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n+                let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n+                ret_place.write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_layout));\n+            }\n+        }\n+        PassMode::ByRef { size: Some(_) } => {}\n+        PassMode::ByRef { size: None } => todo!(),\n+    }\n+\n+    (call_inst, meta)\n+}\n+\n+/// Codegen a return instruction with the right return value(s) if any.\n+pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+    match get_pass_mode(fx.tcx, return_layout(fx)) {\n+        PassMode::NoPass | PassMode::ByRef { size: Some(_) } => {\n+            fx.bcx.ins().return_(&[]);\n+        }\n+        PassMode::ByRef { size: None } => todo!(),\n+        PassMode::ByVal(_) => {\n+            let place = fx.get_local_place(RETURN_PLACE);\n+            let ret_val = place.to_cvalue(fx).load_scalar(fx);\n+            fx.bcx.ins().return_(&[ret_val]);\n+        }\n+        PassMode::ByValPair(_, _) => {\n+            let place = fx.get_local_place(RETURN_PLACE);\n+            let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n+            fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n+        }\n+    }\n+}"}, {"sha": "0735ad6f83299a1a6eb2721455351475d3b03820", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,153 @@\n+//! Allocator shim\n+// Adapted from rustc\n+\n+use crate::prelude::*;\n+\n+use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n+use rustc_span::symbol::sym;\n+\n+/// Returns whether an allocator shim was created\n+pub(crate) fn codegen(\n+    tcx: TyCtxt<'_>,\n+    module: &mut impl Module,\n+    unwind_context: &mut UnwindContext<'_>,\n+) -> bool {\n+    let any_dynamic_crate = tcx.dependency_formats(LOCAL_CRATE).iter().any(|(_, list)| {\n+        use rustc_middle::middle::dependency_format::Linkage;\n+        list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n+    });\n+    if any_dynamic_crate {\n+        false\n+    } else if let Some(kind) = tcx.allocator_kind() {\n+        codegen_inner(module, unwind_context, kind);\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+fn codegen_inner(\n+    module: &mut impl Module,\n+    unwind_context: &mut UnwindContext<'_>,\n+    kind: AllocatorKind,\n+) {\n+    let usize_ty = module.target_config().pointer_type();\n+\n+    for method in ALLOCATOR_METHODS {\n+        let mut arg_tys = Vec::with_capacity(method.inputs.len());\n+        for ty in method.inputs.iter() {\n+            match *ty {\n+                AllocatorTy::Layout => {\n+                    arg_tys.push(usize_ty); // size\n+                    arg_tys.push(usize_ty); // align\n+                }\n+                AllocatorTy::Ptr => arg_tys.push(usize_ty),\n+                AllocatorTy::Usize => arg_tys.push(usize_ty),\n+\n+                AllocatorTy::ResultPtr | AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n+            }\n+        }\n+        let output = match method.output {\n+            AllocatorTy::ResultPtr => Some(usize_ty),\n+            AllocatorTy::Unit => None,\n+\n+            AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n+                panic!(\"invalid allocator output\")\n+            }\n+        };\n+\n+        let sig = Signature {\n+            call_conv: CallConv::triple_default(module.isa().triple()),\n+            params: arg_tys.iter().cloned().map(AbiParam::new).collect(),\n+            returns: output.into_iter().map(AbiParam::new).collect(),\n+        };\n+\n+        let caller_name = format!(\"__rust_{}\", method.name);\n+        let callee_name = kind.fn_name(method.name);\n+        //eprintln!(\"Codegen allocator shim {} -> {} ({:?} -> {:?})\", caller_name, callee_name, sig.params, sig.returns);\n+\n+        let func_id = module\n+            .declare_function(&caller_name, Linkage::Export, &sig)\n+            .unwrap();\n+\n+        let callee_func_id = module\n+            .declare_function(&callee_name, Linkage::Import, &sig)\n+            .unwrap();\n+\n+        let mut ctx = Context::new();\n+        ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig.clone());\n+        {\n+            let mut func_ctx = FunctionBuilderContext::new();\n+            let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n+\n+            let block = bcx.create_block();\n+            bcx.switch_to_block(block);\n+            let args = arg_tys\n+                .into_iter()\n+                .map(|ty| bcx.append_block_param(block, ty))\n+                .collect::<Vec<Value>>();\n+\n+            let callee_func_ref = module.declare_func_in_func(callee_func_id, &mut bcx.func);\n+            let call_inst = bcx.ins().call(callee_func_ref, &args);\n+            let results = bcx.inst_results(call_inst).to_vec(); // Clone to prevent borrow error\n+\n+            bcx.ins().return_(&results);\n+            bcx.seal_all_blocks();\n+            bcx.finalize();\n+        }\n+        module\n+            .define_function(\n+                func_id,\n+                &mut ctx,\n+                &mut cranelift_codegen::binemit::NullTrapSink {},\n+            )\n+            .unwrap();\n+        unwind_context.add_function(func_id, &ctx, module.isa());\n+    }\n+\n+    let sig = Signature {\n+        call_conv: CallConv::triple_default(module.isa().triple()),\n+        params: vec![AbiParam::new(usize_ty), AbiParam::new(usize_ty)],\n+        returns: vec![],\n+    };\n+\n+    let callee_name = kind.fn_name(sym::oom);\n+    //eprintln!(\"Codegen allocator shim {} -> {} ({:?} -> {:?})\", caller_name, callee_name, sig.params, sig.returns);\n+\n+    let func_id = module\n+        .declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig)\n+        .unwrap();\n+\n+    let callee_func_id = module\n+        .declare_function(&callee_name, Linkage::Import, &sig)\n+        .unwrap();\n+\n+    let mut ctx = Context::new();\n+    ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig.clone());\n+    {\n+        let mut func_ctx = FunctionBuilderContext::new();\n+        let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n+\n+        let block = bcx.create_block();\n+        bcx.switch_to_block(block);\n+        let args = (&[usize_ty, usize_ty])\n+            .into_iter()\n+            .map(|&ty| bcx.append_block_param(block, ty))\n+            .collect::<Vec<Value>>();\n+\n+        let callee_func_ref = module.declare_func_in_func(callee_func_id, &mut bcx.func);\n+        bcx.ins().call(callee_func_ref, &args);\n+\n+        bcx.ins().trap(TrapCode::UnreachableCodeReached);\n+        bcx.seal_all_blocks();\n+        bcx.finalize();\n+    }\n+    module\n+        .define_function(\n+            func_id,\n+            &mut ctx,\n+            &mut cranelift_codegen::binemit::NullTrapSink {},\n+        )\n+        .unwrap();\n+    unwind_context.add_function(func_id, &ctx, module.isa());\n+}"}, {"sha": "fd25b19a583aa3fae04c74b21a0e1b80cd222920", "filename": "compiler/rustc_codegen_cranelift/src/analyze.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,61 @@\n+//! SSA analysis\n+\n+use crate::prelude::*;\n+\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::mir::StatementKind::*;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub(crate) enum SsaKind {\n+    NotSsa,\n+    Ssa,\n+}\n+\n+pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Module>) -> IndexVec<Local, SsaKind> {\n+    let mut flag_map = fx\n+        .mir\n+        .local_decls\n+        .iter()\n+        .map(|local_decl| {\n+            let ty = fx.monomorphize(&local_decl.ty);\n+            if fx.clif_type(ty).is_some() || fx.clif_pair_type(ty).is_some() {\n+                SsaKind::Ssa\n+            } else {\n+                SsaKind::NotSsa\n+            }\n+        })\n+        .collect::<IndexVec<Local, SsaKind>>();\n+\n+    for bb in fx.mir.basic_blocks().iter() {\n+        for stmt in bb.statements.iter() {\n+            match &stmt.kind {\n+                Assign(place_and_rval) => match &place_and_rval.1 {\n+                    Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n+                        not_ssa(&mut flag_map, place.local)\n+                    }\n+                    _ => {}\n+                },\n+                _ => {}\n+            }\n+        }\n+\n+        match &bb.terminator().kind {\n+            TerminatorKind::Call { destination, .. } => {\n+                if let Some((dest_place, _dest_bb)) = destination {\n+                    let dest_layout = fx\n+                        .layout_of(fx.monomorphize(&dest_place.ty(&fx.mir.local_decls, fx.tcx).ty));\n+                    if !crate::abi::can_return_to_ssa_var(fx.tcx, dest_layout) {\n+                        not_ssa(&mut flag_map, dest_place.local)\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    flag_map\n+}\n+\n+fn not_ssa(flag_map: &mut IndexVec<Local, SsaKind>, local: Local) {\n+    flag_map[local] = SsaKind::NotSsa;\n+}"}, {"sha": "6382f8df3446b149218d0bef1f40f26614550ad4", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,309 @@\n+//! Creation of ar archives like for the lib and staticlib crate type\n+\n+use std::collections::BTreeMap;\n+use std::fs::File;\n+use std::path::{Path, PathBuf};\n+\n+use rustc_codegen_ssa::back::archive::{find_library, ArchiveBuilder};\n+use rustc_codegen_ssa::METADATA_FILENAME;\n+use rustc_session::Session;\n+\n+use object::{Object, SymbolKind};\n+\n+#[derive(Debug)]\n+enum ArchiveEntry {\n+    FromArchive {\n+        archive_index: usize,\n+        entry_index: usize,\n+    },\n+    File(PathBuf),\n+}\n+\n+pub(crate) struct ArArchiveBuilder<'a> {\n+    sess: &'a Session,\n+    dst: PathBuf,\n+    lib_search_paths: Vec<PathBuf>,\n+    use_gnu_style_archive: bool,\n+    no_builtin_ranlib: bool,\n+\n+    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n+    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n+    // the end of an archive for linkers to not get confused.\n+    entries: Vec<(String, ArchiveEntry)>,\n+    update_symbols: bool,\n+}\n+\n+impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n+    fn new(sess: &'a Session, output: &Path, input: Option<&Path>) -> Self {\n+        use rustc_codegen_ssa::back::link::archive_search_paths;\n+\n+        let (src_archives, entries) = if let Some(input) = input {\n+            let mut archive = ar::Archive::new(File::open(input).unwrap());\n+            let mut entries = Vec::new();\n+\n+            let mut i = 0;\n+            while let Some(entry) = archive.next_entry() {\n+                let entry = entry.unwrap();\n+                entries.push((\n+                    String::from_utf8(entry.header().identifier().to_vec()).unwrap(),\n+                    ArchiveEntry::FromArchive {\n+                        archive_index: 0,\n+                        entry_index: i,\n+                    },\n+                ));\n+                i += 1;\n+            }\n+\n+            (vec![(input.to_owned(), archive)], entries)\n+        } else {\n+            (vec![], Vec::new())\n+        };\n+\n+        ArArchiveBuilder {\n+            sess,\n+            dst: output.to_path_buf(),\n+            lib_search_paths: archive_search_paths(sess),\n+            use_gnu_style_archive: sess.target.options.archive_format == \"gnu\",\n+            // FIXME fix builtin ranlib on macOS\n+            no_builtin_ranlib: sess.target.options.is_like_osx,\n+\n+            src_archives,\n+            entries,\n+            update_symbols: false,\n+        }\n+    }\n+\n+    fn src_files(&mut self) -> Vec<String> {\n+        self.entries.iter().map(|(name, _)| name.clone()).collect()\n+    }\n+\n+    fn remove_file(&mut self, name: &str) {\n+        let index = self\n+            .entries\n+            .iter()\n+            .position(|(entry_name, _)| entry_name == name)\n+            .expect(\"Tried to remove file not existing in src archive\");\n+        self.entries.remove(index);\n+    }\n+\n+    fn add_file(&mut self, file: &Path) {\n+        self.entries.push((\n+            file.file_name().unwrap().to_str().unwrap().to_string(),\n+            ArchiveEntry::File(file.to_owned()),\n+        ));\n+    }\n+\n+    fn add_native_library(&mut self, name: rustc_span::symbol::Symbol) {\n+        let location = find_library(name, &self.lib_search_paths, self.sess);\n+        self.add_archive(location.clone(), |_| false)\n+            .unwrap_or_else(|e| {\n+                panic!(\n+                    \"failed to add native library {}: {}\",\n+                    location.to_string_lossy(),\n+                    e\n+                );\n+            });\n+    }\n+\n+    fn add_rlib(\n+        &mut self,\n+        rlib: &Path,\n+        name: &str,\n+        lto: bool,\n+        skip_objects: bool,\n+    ) -> std::io::Result<()> {\n+        let obj_start = name.to_owned();\n+\n+        self.add_archive(rlib.to_owned(), move |fname: &str| {\n+            // Ignore metadata files, no matter the name.\n+            if fname == METADATA_FILENAME {\n+                return true;\n+            }\n+\n+            // Don't include Rust objects if LTO is enabled\n+            if lto && fname.starts_with(&obj_start) && fname.ends_with(\".o\") {\n+                return true;\n+            }\n+\n+            // Otherwise if this is *not* a rust object and we're skipping\n+            // objects then skip this file\n+            if skip_objects && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\")) {\n+                return true;\n+            }\n+\n+            // ok, don't skip this\n+            return false;\n+        })\n+    }\n+\n+    fn update_symbols(&mut self) {\n+        self.update_symbols = true;\n+    }\n+\n+    fn build(mut self) {\n+        enum BuilderKind {\n+            Bsd(ar::Builder<File>),\n+            Gnu(ar::GnuBuilder<File>),\n+        }\n+\n+        let sess = self.sess;\n+\n+        let mut symbol_table = BTreeMap::new();\n+\n+        let mut entries = Vec::new();\n+\n+        for (entry_name, entry) in self.entries {\n+            // FIXME only read the symbol table of the object files to avoid having to keep all\n+            // object files in memory at once, or read them twice.\n+            let data = match entry {\n+                ArchiveEntry::FromArchive {\n+                    archive_index,\n+                    entry_index,\n+                } => {\n+                    // FIXME read symbols from symtab\n+                    use std::io::Read;\n+                    let (ref _src_archive_path, ref mut src_archive) =\n+                        self.src_archives[archive_index];\n+                    let mut entry = src_archive.jump_to_entry(entry_index).unwrap();\n+                    let mut data = Vec::new();\n+                    entry.read_to_end(&mut data).unwrap();\n+                    data\n+                }\n+                ArchiveEntry::File(file) => std::fs::read(file).unwrap_or_else(|err| {\n+                    sess.fatal(&format!(\n+                        \"error while reading object file during archive building: {}\",\n+                        err\n+                    ));\n+                }),\n+            };\n+\n+            if !self.no_builtin_ranlib {\n+                match object::File::parse(&data) {\n+                    Ok(object) => {\n+                        symbol_table.insert(\n+                            entry_name.as_bytes().to_vec(),\n+                            object\n+                                .symbols()\n+                                .filter_map(|(_index, symbol)| {\n+                                    if symbol.is_undefined()\n+                                        || symbol.is_local()\n+                                        || symbol.kind() != SymbolKind::Data\n+                                            && symbol.kind() != SymbolKind::Text\n+                                            && symbol.kind() != SymbolKind::Tls\n+                                    {\n+                                        None\n+                                    } else {\n+                                        symbol.name().map(|name| name.as_bytes().to_vec())\n+                                    }\n+                                })\n+                                .collect::<Vec<_>>(),\n+                        );\n+                    }\n+                    Err(err) => {\n+                        let err = err.to_string();\n+                        if err == \"Unknown file magic\" {\n+                            // Not an object file; skip it.\n+                        } else {\n+                            sess.fatal(&format!(\n+                                \"error parsing `{}` during archive creation: {}\",\n+                                entry_name, err\n+                            ));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            entries.push((entry_name, data));\n+        }\n+\n+        let mut builder = if self.use_gnu_style_archive {\n+            BuilderKind::Gnu(\n+                ar::GnuBuilder::new(\n+                    File::create(&self.dst).unwrap_or_else(|err| {\n+                        sess.fatal(&format!(\n+                            \"error opening destination during archive building: {}\",\n+                            err\n+                        ));\n+                    }),\n+                    entries\n+                        .iter()\n+                        .map(|(name, _)| name.as_bytes().to_vec())\n+                        .collect(),\n+                    ar::GnuSymbolTableFormat::Size32,\n+                    symbol_table,\n+                )\n+                .unwrap(),\n+            )\n+        } else {\n+            BuilderKind::Bsd(\n+                ar::Builder::new(\n+                    File::create(&self.dst).unwrap_or_else(|err| {\n+                        sess.fatal(&format!(\n+                            \"error opening destination during archive building: {}\",\n+                            err\n+                        ));\n+                    }),\n+                    symbol_table,\n+                )\n+                .unwrap(),\n+            )\n+        };\n+\n+        // Add all files\n+        for (entry_name, data) in entries.into_iter() {\n+            let header = ar::Header::new(entry_name.into_bytes(), data.len() as u64);\n+            match builder {\n+                BuilderKind::Bsd(ref mut builder) => builder.append(&header, &mut &*data).unwrap(),\n+                BuilderKind::Gnu(ref mut builder) => builder.append(&header, &mut &*data).unwrap(),\n+            }\n+        }\n+\n+        // Finalize archive\n+        std::mem::drop(builder);\n+\n+        if self.no_builtin_ranlib {\n+            let ranlib = crate::toolchain::get_toolchain_binary(self.sess, \"ranlib\");\n+\n+            // Run ranlib to be able to link the archive\n+            let status = std::process::Command::new(ranlib)\n+                .arg(self.dst)\n+                .status()\n+                .expect(\"Couldn't run ranlib\");\n+\n+            if !status.success() {\n+                self.sess\n+                    .fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> ArArchiveBuilder<'a> {\n+    fn add_archive<F>(&mut self, archive_path: PathBuf, mut skip: F) -> std::io::Result<()>\n+    where\n+        F: FnMut(&str) -> bool + 'static,\n+    {\n+        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n+        let archive_index = self.src_archives.len();\n+\n+        let mut i = 0;\n+        while let Some(entry) = archive.next_entry() {\n+            let entry = entry?;\n+            let file_name = String::from_utf8(entry.header().identifier().to_vec())\n+                .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n+            if !skip(&file_name) {\n+                self.entries.push((\n+                    file_name,\n+                    ArchiveEntry::FromArchive {\n+                        archive_index,\n+                        entry_index: i,\n+                    },\n+                ));\n+            }\n+            i += 1;\n+        }\n+\n+        self.src_archives.push((archive_path, archive));\n+        Ok(())\n+    }\n+}"}, {"sha": "92281fdacc941ea719593352fec253f87217ecb5", "filename": "compiler/rustc_codegen_cranelift/src/atomic_shim.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fatomic_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fatomic_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fatomic_shim.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,186 @@\n+//! Atomic intrinsics are implemented using a global lock for now, as Cranelift doesn't support\n+//! atomic operations yet.\n+\n+// FIXME implement atomic instructions in Cranelift.\n+\n+use crate::prelude::*;\n+\n+#[cfg(all(feature = \"jit\", unix))]\n+#[no_mangle]\n+pub static mut __cg_clif_global_atomic_mutex: libc::pthread_mutex_t =\n+    libc::PTHREAD_MUTEX_INITIALIZER;\n+\n+pub(crate) fn init_global_lock(\n+    module: &mut impl Module,\n+    bcx: &mut FunctionBuilder<'_>,\n+    use_jit: bool,\n+) {\n+    if use_jit {\n+        // When using JIT, dylibs won't find the __cg_clif_global_atomic_mutex data object defined here,\n+        // so instead we define it in the cg_clif dylib.\n+\n+        return;\n+    }\n+\n+    let mut data_ctx = DataContext::new();\n+    data_ctx.define_zeroinit(1024); // 1024 bytes should be big enough on all platforms.\n+    data_ctx.set_align(16);\n+    let atomic_mutex = module\n+        .declare_data(\n+            \"__cg_clif_global_atomic_mutex\",\n+            Linkage::Export,\n+            true,\n+            false,\n+        )\n+        .unwrap();\n+    module.define_data(atomic_mutex, &data_ctx).unwrap();\n+\n+    let pthread_mutex_init = module\n+        .declare_function(\n+            \"pthread_mutex_init\",\n+            Linkage::Import,\n+            &cranelift_codegen::ir::Signature {\n+                call_conv: module.target_config().default_call_conv,\n+                params: vec![\n+                    AbiParam::new(\n+                        module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n+                    ),\n+                    AbiParam::new(\n+                        module.target_config().pointer_type(), /* *const pthread_mutex_attr_t */\n+                    ),\n+                ],\n+                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n+            },\n+        )\n+        .unwrap();\n+\n+    let pthread_mutex_init = module.declare_func_in_func(pthread_mutex_init, bcx.func);\n+\n+    let atomic_mutex = module.declare_data_in_func(atomic_mutex, bcx.func);\n+    let atomic_mutex = bcx\n+        .ins()\n+        .global_value(module.target_config().pointer_type(), atomic_mutex);\n+\n+    let nullptr = bcx.ins().iconst(module.target_config().pointer_type(), 0);\n+\n+    bcx.ins().call(pthread_mutex_init, &[atomic_mutex, nullptr]);\n+}\n+\n+pub(crate) fn init_global_lock_constructor(\n+    module: &mut impl Module,\n+    constructor_name: &str,\n+) -> FuncId {\n+    let sig = Signature::new(CallConv::SystemV);\n+    let init_func_id = module\n+        .declare_function(constructor_name, Linkage::Export, &sig)\n+        .unwrap();\n+\n+    let mut ctx = Context::new();\n+    ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n+    {\n+        let mut func_ctx = FunctionBuilderContext::new();\n+        let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n+\n+        let block = bcx.create_block();\n+        bcx.switch_to_block(block);\n+\n+        crate::atomic_shim::init_global_lock(module, &mut bcx, false);\n+\n+        bcx.ins().return_(&[]);\n+        bcx.seal_all_blocks();\n+        bcx.finalize();\n+    }\n+    module\n+        .define_function(\n+            init_func_id,\n+            &mut ctx,\n+            &mut cranelift_codegen::binemit::NullTrapSink {},\n+        )\n+        .unwrap();\n+\n+    init_func_id\n+}\n+\n+pub(crate) fn lock_global_lock(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+    let atomic_mutex = fx\n+        .cx\n+        .module\n+        .declare_data(\n+            \"__cg_clif_global_atomic_mutex\",\n+            Linkage::Import,\n+            true,\n+            false,\n+        )\n+        .unwrap();\n+\n+    let pthread_mutex_lock = fx\n+        .cx\n+        .module\n+        .declare_function(\n+            \"pthread_mutex_lock\",\n+            Linkage::Import,\n+            &cranelift_codegen::ir::Signature {\n+                call_conv: fx.cx.module.target_config().default_call_conv,\n+                params: vec![AbiParam::new(\n+                    fx.cx.module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n+                )],\n+                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n+            },\n+        )\n+        .unwrap();\n+\n+    let pthread_mutex_lock = fx\n+        .cx\n+        .module\n+        .declare_func_in_func(pthread_mutex_lock, fx.bcx.func);\n+\n+    let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n+    let atomic_mutex = fx\n+        .bcx\n+        .ins()\n+        .global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n+\n+    fx.bcx.ins().call(pthread_mutex_lock, &[atomic_mutex]);\n+}\n+\n+pub(crate) fn unlock_global_lock(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+    let atomic_mutex = fx\n+        .cx\n+        .module\n+        .declare_data(\n+            \"__cg_clif_global_atomic_mutex\",\n+            Linkage::Import,\n+            true,\n+            false,\n+        )\n+        .unwrap();\n+\n+    let pthread_mutex_unlock = fx\n+        .cx\n+        .module\n+        .declare_function(\n+            \"pthread_mutex_unlock\",\n+            Linkage::Import,\n+            &cranelift_codegen::ir::Signature {\n+                call_conv: fx.cx.module.target_config().default_call_conv,\n+                params: vec![AbiParam::new(\n+                    fx.cx.module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n+                )],\n+                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n+            },\n+        )\n+        .unwrap();\n+\n+    let pthread_mutex_unlock = fx\n+        .cx\n+        .module\n+        .declare_func_in_func(pthread_mutex_unlock, fx.bcx.func);\n+\n+    let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n+    let atomic_mutex = fx\n+        .bcx\n+        .ins()\n+        .global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n+\n+    fx.bcx.ins().call(pthread_mutex_unlock, &[atomic_mutex]);\n+}"}, {"sha": "8b900fd0dd0c8b58b245e21aa579cf9b32f49e14", "filename": "compiler/rustc_codegen_cranelift/src/backend.rs", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,206 @@\n+//! Abstraction around the object writing crate\n+\n+use std::convert::{TryFrom, TryInto};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_session::Session;\n+\n+use cranelift_module::FuncId;\n+\n+use object::write::*;\n+use object::{RelocationEncoding, RelocationKind, SectionKind, SymbolFlags};\n+\n+use cranelift_object::{ObjectBuilder, ObjectModule, ObjectProduct};\n+\n+use gimli::SectionId;\n+\n+use crate::debuginfo::{DebugReloc, DebugRelocName};\n+\n+pub(crate) trait WriteMetadata {\n+    fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>, is_like_osx: bool);\n+}\n+\n+impl WriteMetadata for object::write::Object {\n+    fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>, _is_like_osx: bool) {\n+        let segment = self\n+            .segment_name(object::write::StandardSegment::Data)\n+            .to_vec();\n+        let section_id = self.add_section(segment, b\".rustc\".to_vec(), object::SectionKind::Data);\n+        let offset = self.append_section_data(section_id, &data, 1);\n+        // For MachO and probably PE this is necessary to prevent the linker from throwing away the\n+        // .rustc section. For ELF this isn't necessary, but it also doesn't harm.\n+        self.add_symbol(object::write::Symbol {\n+            name: symbol_name.into_bytes(),\n+            value: offset,\n+            size: data.len() as u64,\n+            kind: object::SymbolKind::Data,\n+            scope: object::SymbolScope::Dynamic,\n+            weak: false,\n+            section: SymbolSection::Section(section_id),\n+            flags: SymbolFlags::None,\n+        });\n+    }\n+}\n+\n+pub(crate) trait WriteDebugInfo {\n+    type SectionId: Copy;\n+\n+    fn add_debug_section(&mut self, name: SectionId, data: Vec<u8>) -> Self::SectionId;\n+    fn add_debug_reloc(\n+        &mut self,\n+        section_map: &FxHashMap<SectionId, Self::SectionId>,\n+        from: &Self::SectionId,\n+        reloc: &DebugReloc,\n+    );\n+}\n+\n+impl WriteDebugInfo for ObjectProduct {\n+    type SectionId = (object::write::SectionId, object::write::SymbolId);\n+\n+    fn add_debug_section(\n+        &mut self,\n+        id: SectionId,\n+        data: Vec<u8>,\n+    ) -> (object::write::SectionId, object::write::SymbolId) {\n+        let name = if self.object.format() == object::BinaryFormat::MachO {\n+            id.name().replace('.', \"__\") // machO expects __debug_info instead of .debug_info\n+        } else {\n+            id.name().to_string()\n+        }\n+        .into_bytes();\n+\n+        let segment = self.object.segment_name(StandardSegment::Debug).to_vec();\n+        // FIXME use SHT_X86_64_UNWIND for .eh_frame\n+        let section_id = self.object.add_section(\n+            segment,\n+            name.clone(),\n+            if id == SectionId::EhFrame {\n+                SectionKind::ReadOnlyData\n+            } else {\n+                SectionKind::Debug\n+            },\n+        );\n+        self.object\n+            .section_mut(section_id)\n+            .set_data(data, if id == SectionId::EhFrame { 8 } else { 1 });\n+        let symbol_id = self.object.section_symbol(section_id);\n+        (section_id, symbol_id)\n+    }\n+\n+    fn add_debug_reloc(\n+        &mut self,\n+        section_map: &FxHashMap<SectionId, Self::SectionId>,\n+        from: &Self::SectionId,\n+        reloc: &DebugReloc,\n+    ) {\n+        let (symbol, symbol_offset) = match reloc.name {\n+            DebugRelocName::Section(id) => (section_map.get(&id).unwrap().1, 0),\n+            DebugRelocName::Symbol(id) => {\n+                let symbol_id = self.function_symbol(FuncId::from_u32(id.try_into().unwrap()));\n+                self.object\n+                    .symbol_section_and_offset(symbol_id)\n+                    .expect(\"Debug reloc for undef sym???\")\n+            }\n+        };\n+        self.object\n+            .add_relocation(\n+                from.0,\n+                Relocation {\n+                    offset: u64::from(reloc.offset),\n+                    symbol,\n+                    kind: reloc.kind,\n+                    encoding: RelocationEncoding::Generic,\n+                    size: reloc.size * 8,\n+                    addend: i64::try_from(symbol_offset).unwrap() + reloc.addend,\n+                },\n+            )\n+            .unwrap();\n+    }\n+}\n+\n+// FIXME remove once atomic instructions are implemented in Cranelift.\n+pub(crate) trait AddConstructor {\n+    fn add_constructor(&mut self, func_id: FuncId);\n+}\n+\n+impl AddConstructor for ObjectProduct {\n+    fn add_constructor(&mut self, func_id: FuncId) {\n+        let symbol = self.function_symbol(func_id);\n+        let segment = self\n+            .object\n+            .segment_name(object::write::StandardSegment::Data);\n+        let init_array_section =\n+            self.object\n+                .add_section(segment.to_vec(), b\".init_array\".to_vec(), SectionKind::Data);\n+        let address_size = self\n+            .object\n+            .architecture()\n+            .address_size()\n+            .expect(\"address_size must be known\")\n+            .bytes();\n+        self.object.append_section_data(\n+            init_array_section,\n+            &std::iter::repeat(0)\n+                .take(address_size.into())\n+                .collect::<Vec<u8>>(),\n+            8,\n+        );\n+        self.object\n+            .add_relocation(\n+                init_array_section,\n+                object::write::Relocation {\n+                    offset: 0,\n+                    size: address_size * 8,\n+                    kind: RelocationKind::Absolute,\n+                    encoding: RelocationEncoding::Generic,\n+                    symbol,\n+                    addend: 0,\n+                },\n+            )\n+            .unwrap();\n+    }\n+}\n+\n+pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object)) -> Vec<u8> {\n+    let triple = crate::build_isa(sess, true).triple().clone();\n+\n+    let binary_format = match triple.binary_format {\n+        target_lexicon::BinaryFormat::Elf => object::BinaryFormat::Elf,\n+        target_lexicon::BinaryFormat::Coff => object::BinaryFormat::Coff,\n+        target_lexicon::BinaryFormat::Macho => object::BinaryFormat::MachO,\n+        binary_format => sess.fatal(&format!(\"binary format {} is unsupported\", binary_format)),\n+    };\n+    let architecture = match triple.architecture {\n+        target_lexicon::Architecture::X86_32(_) => object::Architecture::I386,\n+        target_lexicon::Architecture::X86_64 => object::Architecture::X86_64,\n+        target_lexicon::Architecture::Arm(_) => object::Architecture::Arm,\n+        target_lexicon::Architecture::Aarch64(_) => object::Architecture::Aarch64,\n+        architecture => sess.fatal(&format!(\n+            \"target architecture {:?} is unsupported\",\n+            architecture,\n+        )),\n+    };\n+    let endian = match triple.endianness().unwrap() {\n+        target_lexicon::Endianness::Little => object::Endianness::Little,\n+        target_lexicon::Endianness::Big => object::Endianness::Big,\n+    };\n+\n+    let mut metadata_object = object::write::Object::new(binary_format, architecture, endian);\n+    metadata_object.add_file_symbol(name.as_bytes().to_vec());\n+    f(&mut metadata_object);\n+    metadata_object.write().unwrap()\n+}\n+\n+pub(crate) fn make_module(sess: &Session, name: String) -> ObjectModule {\n+    let mut builder = ObjectBuilder::new(\n+        crate::build_isa(sess, true),\n+        name + \".o\",\n+        cranelift_module::default_libcall_names(),\n+    )\n+    .unwrap();\n+    if std::env::var(\"CG_CLIF_FUNCTION_SECTIONS\").is_ok() {\n+        builder.per_function_section(true);\n+    }\n+    let module = ObjectModule::new(builder);\n+    module\n+}"}, {"sha": "fa9b8853d39e9eec25bef7090c838d3dc918c8f0", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "added", "additions": 1020, "deletions": 0, "changes": 1020, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,1020 @@\n+//! Codegen of a single function\n+\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::adjustment::PointerCast;\n+\n+use crate::prelude::*;\n+\n+pub(crate) fn trans_fn<'tcx>(\n+    cx: &mut crate::CodegenCx<'tcx, impl Module>,\n+    instance: Instance<'tcx>,\n+    linkage: Linkage,\n+) {\n+    let tcx = cx.tcx;\n+\n+    let mir = tcx.instance_mir(instance.def);\n+\n+    // Declare function\n+    let (name, sig) = get_function_name_and_sig(tcx, cx.module.isa().triple(), instance, false);\n+    let func_id = cx.module.declare_function(&name, linkage, &sig).unwrap();\n+\n+    cx.cached_context.clear();\n+\n+    // Make the FunctionBuilder\n+    let mut func_ctx = FunctionBuilderContext::new();\n+    let mut func = std::mem::replace(&mut cx.cached_context.func, Function::new());\n+    func.name = ExternalName::user(0, func_id.as_u32());\n+    func.signature = sig;\n+    func.collect_debug_info();\n+\n+    let mut bcx = FunctionBuilder::new(&mut func, &mut func_ctx);\n+\n+    // Predefine blocks\n+    let start_block = bcx.create_block();\n+    let block_map: IndexVec<BasicBlock, Block> = (0..mir.basic_blocks().len())\n+        .map(|_| bcx.create_block())\n+        .collect();\n+\n+    // Make FunctionCx\n+    let pointer_type = cx.module.target_config().pointer_type();\n+    let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n+\n+    let mut fx = FunctionCx {\n+        cx,\n+        tcx,\n+        pointer_type,\n+\n+        instance,\n+        mir,\n+\n+        bcx,\n+        block_map,\n+        local_map: IndexVec::with_capacity(mir.local_decls.len()),\n+        caller_location: None, // set by `codegen_fn_prelude`\n+        cold_blocks: EntitySet::new(),\n+\n+        clif_comments,\n+        source_info_set: indexmap::IndexSet::new(),\n+        next_ssa_var: 0,\n+\n+        inline_asm_index: 0,\n+    };\n+\n+    let arg_uninhabited = fx.mir.args_iter().any(|arg| {\n+        fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty))\n+            .abi\n+            .is_uninhabited()\n+    });\n+\n+    if arg_uninhabited {\n+        fx.bcx\n+            .append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n+        crate::trap::trap_unreachable(&mut fx, \"function has uninhabited argument\");\n+    } else {\n+        tcx.sess.time(\"codegen clif ir\", || {\n+            tcx.sess.time(\"codegen prelude\", || {\n+                crate::abi::codegen_fn_prelude(&mut fx, start_block)\n+            });\n+            codegen_fn_content(&mut fx);\n+        });\n+    }\n+\n+    // Recover all necessary data from fx, before accessing func will prevent future access to it.\n+    let instance = fx.instance;\n+    let mut clif_comments = fx.clif_comments;\n+    let source_info_set = fx.source_info_set;\n+    let local_map = fx.local_map;\n+    let cold_blocks = fx.cold_blocks;\n+\n+    // Store function in context\n+    let context = &mut cx.cached_context;\n+    context.func = func;\n+\n+    crate::pretty_clif::write_clif_file(tcx, \"unopt\", None, instance, &context, &clif_comments);\n+\n+    // Verify function\n+    verify_func(tcx, &clif_comments, &context.func);\n+\n+    // Perform rust specific optimizations\n+    tcx.sess.time(\"optimize clif ir\", || {\n+        crate::optimize::optimize_function(\n+            tcx,\n+            instance,\n+            context,\n+            &cold_blocks,\n+            &mut clif_comments,\n+        );\n+    });\n+\n+    // If the return block is not reachable, then the SSA builder may have inserted an `iconst.i128`\n+    // instruction, which doesn't have an encoding.\n+    context.compute_cfg();\n+    context.compute_domtree();\n+    context.eliminate_unreachable_code(cx.module.isa()).unwrap();\n+    context.dce(cx.module.isa()).unwrap();\n+\n+    // Define function\n+    let module = &mut cx.module;\n+    tcx.sess.time(\"define function\", || {\n+        module\n+            .define_function(\n+                func_id,\n+                context,\n+                &mut cranelift_codegen::binemit::NullTrapSink {},\n+            )\n+            .unwrap()\n+    });\n+\n+    // Write optimized function to file for debugging\n+    crate::pretty_clif::write_clif_file(\n+        tcx,\n+        \"opt\",\n+        Some(cx.module.isa()),\n+        instance,\n+        &context,\n+        &clif_comments,\n+    );\n+\n+    // Define debuginfo for function\n+    let isa = cx.module.isa();\n+    let debug_context = &mut cx.debug_context;\n+    let unwind_context = &mut cx.unwind_context;\n+    tcx.sess.time(\"generate debug info\", || {\n+        if let Some(debug_context) = debug_context {\n+            debug_context.define_function(\n+                instance,\n+                func_id,\n+                &name,\n+                isa,\n+                context,\n+                &source_info_set,\n+                local_map,\n+            );\n+        }\n+        unwind_context.add_function(func_id, &context, isa);\n+    });\n+\n+    // Clear context to make it usable for the next function\n+    context.clear();\n+}\n+\n+pub(crate) fn verify_func(\n+    tcx: TyCtxt<'_>,\n+    writer: &crate::pretty_clif::CommentWriter,\n+    func: &Function,\n+) {\n+    tcx.sess.time(\"verify clif ir\", || {\n+        let flags = cranelift_codegen::settings::Flags::new(cranelift_codegen::settings::builder());\n+        match cranelift_codegen::verify_function(&func, &flags) {\n+            Ok(_) => {}\n+            Err(err) => {\n+                tcx.sess.err(&format!(\"{:?}\", err));\n+                let pretty_error = cranelift_codegen::print_errors::pretty_verifier_error(\n+                    &func,\n+                    None,\n+                    Some(Box::new(writer)),\n+                    err,\n+                );\n+                tcx.sess\n+                    .fatal(&format!(\"cranelift verify error:\\n{}\", pretty_error));\n+            }\n+        }\n+    });\n+}\n+\n+fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+    crate::constant::check_constants(fx);\n+\n+    for (bb, bb_data) in fx.mir.basic_blocks().iter_enumerated() {\n+        let block = fx.get_block(bb);\n+        fx.bcx.switch_to_block(block);\n+\n+        if bb_data.is_cleanup {\n+            // Unwinding after panicking is not supported\n+            continue;\n+\n+            // FIXME once unwinding is supported uncomment next lines\n+            // // Unwinding is unlikely to happen, so mark cleanup block's as cold.\n+            // fx.cold_blocks.insert(block);\n+        }\n+\n+        fx.bcx.ins().nop();\n+        for stmt in &bb_data.statements {\n+            fx.set_debug_loc(stmt.source_info);\n+            trans_stmt(fx, block, stmt);\n+        }\n+\n+        #[cfg(debug_assertions)]\n+        {\n+            let mut terminator_head = \"\\n\".to_string();\n+            bb_data\n+                .terminator()\n+                .kind\n+                .fmt_head(&mut terminator_head)\n+                .unwrap();\n+            let inst = fx.bcx.func.layout.last_inst(block).unwrap();\n+            fx.add_comment(inst, terminator_head);\n+        }\n+\n+        fx.set_debug_loc(bb_data.terminator().source_info);\n+\n+        match &bb_data.terminator().kind {\n+            TerminatorKind::Goto { target } => {\n+                if let TerminatorKind::Return = fx.mir[*target].terminator().kind {\n+                    let mut can_immediately_return = true;\n+                    for stmt in &fx.mir[*target].statements {\n+                        if let StatementKind::StorageDead(_) = stmt.kind {\n+                        } else {\n+                            // FIXME Can sometimes happen, see rust-lang/rust#70531\n+                            can_immediately_return = false;\n+                            break;\n+                        }\n+                    }\n+\n+                    if can_immediately_return {\n+                        crate::abi::codegen_return(fx);\n+                        continue;\n+                    }\n+                }\n+\n+                let block = fx.get_block(*target);\n+                fx.bcx.ins().jump(block, &[]);\n+            }\n+            TerminatorKind::Return => {\n+                crate::abi::codegen_return(fx);\n+            }\n+            TerminatorKind::Assert {\n+                cond,\n+                expected,\n+                msg,\n+                target,\n+                cleanup: _,\n+            } => {\n+                if !fx.tcx.sess.overflow_checks() {\n+                    if let mir::AssertKind::OverflowNeg(_) = *msg {\n+                        let target = fx.get_block(*target);\n+                        fx.bcx.ins().jump(target, &[]);\n+                        continue;\n+                    }\n+                }\n+                let cond = trans_operand(fx, cond).load_scalar(fx);\n+\n+                let target = fx.get_block(*target);\n+                let failure = fx.bcx.create_block();\n+                fx.cold_blocks.insert(failure);\n+\n+                if *expected {\n+                    fx.bcx.ins().brz(cond, failure, &[]);\n+                } else {\n+                    fx.bcx.ins().brnz(cond, failure, &[]);\n+                };\n+                fx.bcx.ins().jump(target, &[]);\n+\n+                fx.bcx.switch_to_block(failure);\n+                fx.bcx.ins().nop();\n+\n+                match msg {\n+                    AssertKind::BoundsCheck { ref len, ref index } => {\n+                        let len = trans_operand(fx, len).load_scalar(fx);\n+                        let index = trans_operand(fx, index).load_scalar(fx);\n+                        let location = fx\n+                            .get_caller_location(bb_data.terminator().source_info.span)\n+                            .load_scalar(fx);\n+\n+                        codegen_panic_inner(\n+                            fx,\n+                            rustc_hir::LangItem::PanicBoundsCheck,\n+                            &[index, len, location],\n+                            bb_data.terminator().source_info.span,\n+                        );\n+                    }\n+                    _ => {\n+                        let msg_str = msg.description();\n+                        codegen_panic(fx, msg_str, bb_data.terminator().source_info.span);\n+                    }\n+                }\n+            }\n+\n+            TerminatorKind::SwitchInt {\n+                discr,\n+                switch_ty,\n+                targets,\n+            } => {\n+                let discr = trans_operand(fx, discr).load_scalar(fx);\n+\n+                if switch_ty.kind() == fx.tcx.types.bool.kind() {\n+                    assert_eq!(targets.iter().count(), 1);\n+                    let (then_value, then_block) = targets.iter().next().unwrap();\n+                    let then_block = fx.get_block(then_block);\n+                    let else_block = fx.get_block(targets.otherwise());\n+                    let test_zero = match then_value {\n+                        0 => true,\n+                        1 => false,\n+                        _ => unreachable!(\"{:?}\", targets),\n+                    };\n+\n+                    let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n+                    let (discr, is_inverted) =\n+                        crate::optimize::peephole::maybe_unwrap_bool_not(&mut fx.bcx, discr);\n+                    let test_zero = if is_inverted { !test_zero } else { test_zero };\n+                    let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n+                    let discr =\n+                        crate::optimize::peephole::make_branchable_value(&mut fx.bcx, discr);\n+                    if test_zero {\n+                        fx.bcx.ins().brz(discr, then_block, &[]);\n+                        fx.bcx.ins().jump(else_block, &[]);\n+                    } else {\n+                        fx.bcx.ins().brnz(discr, then_block, &[]);\n+                        fx.bcx.ins().jump(else_block, &[]);\n+                    }\n+                } else {\n+                    let mut switch = ::cranelift_frontend::Switch::new();\n+                    for (value, block) in targets.iter() {\n+                        let block = fx.get_block(block);\n+                        switch.set_entry(value, block);\n+                    }\n+                    let otherwise_block = fx.get_block(targets.otherwise());\n+                    switch.emit(&mut fx.bcx, discr, otherwise_block);\n+                }\n+            }\n+            TerminatorKind::Call {\n+                func,\n+                args,\n+                destination,\n+                fn_span,\n+                cleanup: _,\n+                from_hir_call: _,\n+            } => {\n+                fx.tcx.sess.time(\"codegen call\", || {\n+                    crate::abi::codegen_terminator_call(\n+                        fx,\n+                        *fn_span,\n+                        block,\n+                        func,\n+                        args,\n+                        *destination,\n+                    )\n+                });\n+            }\n+            TerminatorKind::InlineAsm {\n+                template,\n+                operands,\n+                options,\n+                destination,\n+                line_spans: _,\n+            } => {\n+                crate::inline_asm::codegen_inline_asm(\n+                    fx,\n+                    bb_data.terminator().source_info.span,\n+                    template,\n+                    operands,\n+                    *options,\n+                );\n+\n+                match *destination {\n+                    Some(destination) => {\n+                        let destination_block = fx.get_block(destination);\n+                        fx.bcx.ins().jump(destination_block, &[]);\n+                    }\n+                    None => {\n+                        crate::trap::trap_unreachable(\n+                            fx,\n+                            \"[corruption] Returned from noreturn inline asm\",\n+                        );\n+                    }\n+                }\n+            }\n+            TerminatorKind::Resume | TerminatorKind::Abort => {\n+                trap_unreachable(fx, \"[corruption] Unwinding bb reached.\");\n+            }\n+            TerminatorKind::Unreachable => {\n+                trap_unreachable(fx, \"[corruption] Hit unreachable code.\");\n+            }\n+            TerminatorKind::Yield { .. }\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::GeneratorDrop => {\n+                bug!(\"shouldn't exist at trans {:?}\", bb_data.terminator());\n+            }\n+            TerminatorKind::Drop {\n+                place,\n+                target,\n+                unwind: _,\n+            } => {\n+                let drop_place = trans_place(fx, *place);\n+                crate::abi::codegen_drop(fx, bb_data.terminator().source_info.span, drop_place);\n+\n+                let target_block = fx.get_block(*target);\n+                fx.bcx.ins().jump(target_block, &[]);\n+            }\n+        };\n+    }\n+\n+    fx.bcx.seal_all_blocks();\n+    fx.bcx.finalize();\n+}\n+\n+fn trans_stmt<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    #[allow(unused_variables)] cur_block: Block,\n+    stmt: &Statement<'tcx>,\n+) {\n+    let _print_guard = crate::PrintOnPanic(|| format!(\"stmt {:?}\", stmt));\n+\n+    fx.set_debug_loc(stmt.source_info);\n+\n+    #[cfg(false_debug_assertions)]\n+    match &stmt.kind {\n+        StatementKind::StorageLive(..) | StatementKind::StorageDead(..) => {} // Those are not very useful\n+        _ => {\n+            let inst = fx.bcx.func.layout.last_inst(cur_block).unwrap();\n+            fx.add_comment(inst, format!(\"{:?}\", stmt));\n+        }\n+    }\n+\n+    match &stmt.kind {\n+        StatementKind::SetDiscriminant {\n+            place,\n+            variant_index,\n+        } => {\n+            let place = trans_place(fx, **place);\n+            crate::discriminant::codegen_set_discriminant(fx, place, *variant_index);\n+        }\n+        StatementKind::Assign(to_place_and_rval) => {\n+            let lval = trans_place(fx, to_place_and_rval.0);\n+            let dest_layout = lval.layout();\n+            match &to_place_and_rval.1 {\n+                Rvalue::Use(operand) => {\n+                    let val = trans_operand(fx, operand);\n+                    lval.write_cvalue(fx, val);\n+                }\n+                Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n+                    let place = trans_place(fx, *place);\n+                    let ref_ = place.place_ref(fx, lval.layout());\n+                    lval.write_cvalue(fx, ref_);\n+                }\n+                Rvalue::ThreadLocalRef(def_id) => {\n+                    let val = crate::constant::codegen_tls_ref(fx, *def_id, lval.layout());\n+                    lval.write_cvalue(fx, val);\n+                }\n+                Rvalue::BinaryOp(bin_op, lhs, rhs) => {\n+                    let lhs = trans_operand(fx, lhs);\n+                    let rhs = trans_operand(fx, rhs);\n+\n+                    let res = crate::num::codegen_binop(fx, *bin_op, lhs, rhs);\n+                    lval.write_cvalue(fx, res);\n+                }\n+                Rvalue::CheckedBinaryOp(bin_op, lhs, rhs) => {\n+                    let lhs = trans_operand(fx, lhs);\n+                    let rhs = trans_operand(fx, rhs);\n+\n+                    let res = if !fx.tcx.sess.overflow_checks() {\n+                        let val =\n+                            crate::num::trans_int_binop(fx, *bin_op, lhs, rhs).load_scalar(fx);\n+                        let is_overflow = fx.bcx.ins().iconst(types::I8, 0);\n+                        CValue::by_val_pair(val, is_overflow, lval.layout())\n+                    } else {\n+                        crate::num::trans_checked_int_binop(fx, *bin_op, lhs, rhs)\n+                    };\n+\n+                    lval.write_cvalue(fx, res);\n+                }\n+                Rvalue::UnaryOp(un_op, operand) => {\n+                    let operand = trans_operand(fx, operand);\n+                    let layout = operand.layout();\n+                    let val = operand.load_scalar(fx);\n+                    let res = match un_op {\n+                        UnOp::Not => match layout.ty.kind() {\n+                            ty::Bool => {\n+                                let res = fx.bcx.ins().icmp_imm(IntCC::Equal, val, 0);\n+                                CValue::by_val(fx.bcx.ins().bint(types::I8, res), layout)\n+                            }\n+                            ty::Uint(_) | ty::Int(_) => {\n+                                CValue::by_val(fx.bcx.ins().bnot(val), layout)\n+                            }\n+                            _ => unreachable!(\"un op Not for {:?}\", layout.ty),\n+                        },\n+                        UnOp::Neg => match layout.ty.kind() {\n+                            ty::Int(IntTy::I128) => {\n+                                // FIXME remove this case once ineg.i128 works\n+                                let zero = CValue::const_val(fx, layout, 0);\n+                                crate::num::trans_int_binop(fx, BinOp::Sub, zero, operand)\n+                            }\n+                            ty::Int(_) => CValue::by_val(fx.bcx.ins().ineg(val), layout),\n+                            ty::Float(_) => CValue::by_val(fx.bcx.ins().fneg(val), layout),\n+                            _ => unreachable!(\"un op Neg for {:?}\", layout.ty),\n+                        },\n+                    };\n+                    lval.write_cvalue(fx, res);\n+                }\n+                Rvalue::Cast(CastKind::Pointer(PointerCast::ReifyFnPointer), operand, to_ty) => {\n+                    let from_ty = fx.monomorphize(&operand.ty(&fx.mir.local_decls, fx.tcx));\n+                    let to_layout = fx.layout_of(fx.monomorphize(to_ty));\n+                    match *from_ty.kind() {\n+                        ty::FnDef(def_id, substs) => {\n+                            let func_ref = fx.get_function_ref(\n+                                Instance::resolve_for_fn_ptr(\n+                                    fx.tcx,\n+                                    ParamEnv::reveal_all(),\n+                                    def_id,\n+                                    substs,\n+                                )\n+                                .unwrap()\n+                                .polymorphize(fx.tcx),\n+                            );\n+                            let func_addr = fx.bcx.ins().func_addr(fx.pointer_type, func_ref);\n+                            lval.write_cvalue(fx, CValue::by_val(func_addr, to_layout));\n+                        }\n+                        _ => bug!(\"Trying to ReifyFnPointer on non FnDef {:?}\", from_ty),\n+                    }\n+                }\n+                Rvalue::Cast(CastKind::Pointer(PointerCast::UnsafeFnPointer), operand, to_ty)\n+                | Rvalue::Cast(CastKind::Pointer(PointerCast::MutToConstPointer), operand, to_ty)\n+                | Rvalue::Cast(CastKind::Pointer(PointerCast::ArrayToPointer), operand, to_ty) => {\n+                    let to_layout = fx.layout_of(fx.monomorphize(to_ty));\n+                    let operand = trans_operand(fx, operand);\n+                    lval.write_cvalue(fx, operand.cast_pointer_to(to_layout));\n+                }\n+                Rvalue::Cast(CastKind::Misc, operand, to_ty) => {\n+                    let operand = trans_operand(fx, operand);\n+                    let from_ty = operand.layout().ty;\n+                    let to_ty = fx.monomorphize(to_ty);\n+\n+                    fn is_fat_ptr<'tcx>(\n+                        fx: &FunctionCx<'_, 'tcx, impl Module>,\n+                        ty: Ty<'tcx>,\n+                    ) -> bool {\n+                        ty.builtin_deref(true)\n+                            .map(\n+                                |ty::TypeAndMut {\n+                                     ty: pointee_ty,\n+                                     mutbl: _,\n+                                 }| {\n+                                    has_ptr_meta(fx.tcx, pointee_ty)\n+                                },\n+                            )\n+                            .unwrap_or(false)\n+                    }\n+\n+                    if is_fat_ptr(fx, from_ty) {\n+                        if is_fat_ptr(fx, to_ty) {\n+                            // fat-ptr -> fat-ptr\n+                            lval.write_cvalue(fx, operand.cast_pointer_to(dest_layout));\n+                        } else {\n+                            // fat-ptr -> thin-ptr\n+                            let (ptr, _extra) = operand.load_scalar_pair(fx);\n+                            lval.write_cvalue(fx, CValue::by_val(ptr, dest_layout))\n+                        }\n+                    } else if let ty::Adt(adt_def, _substs) = from_ty.kind() {\n+                        // enum -> discriminant value\n+                        assert!(adt_def.is_enum());\n+                        match to_ty.kind() {\n+                            ty::Uint(_) | ty::Int(_) => {}\n+                            _ => unreachable!(\"cast adt {} -> {}\", from_ty, to_ty),\n+                        }\n+\n+                        use rustc_target::abi::{Int, TagEncoding, Variants};\n+\n+                        match &operand.layout().variants {\n+                            Variants::Single { index } => {\n+                                let discr = operand\n+                                    .layout()\n+                                    .ty\n+                                    .discriminant_for_variant(fx.tcx, *index)\n+                                    .unwrap();\n+                                let discr = if discr.ty.is_signed() {\n+                                    rustc_middle::mir::interpret::sign_extend(\n+                                        discr.val,\n+                                        fx.layout_of(discr.ty).size,\n+                                    )\n+                                } else {\n+                                    discr.val\n+                                };\n+\n+                                let discr = CValue::const_val(fx, fx.layout_of(to_ty), discr);\n+                                lval.write_cvalue(fx, discr);\n+                            }\n+                            Variants::Multiple {\n+                                tag,\n+                                tag_field,\n+                                tag_encoding: TagEncoding::Direct,\n+                                variants: _,\n+                            } => {\n+                                let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n+\n+                                // Read the tag/niche-encoded discriminant from memory.\n+                                let encoded_discr =\n+                                    operand.value_field(fx, mir::Field::new(*tag_field));\n+                                let encoded_discr = encoded_discr.load_scalar(fx);\n+\n+                                // Decode the discriminant (specifically if it's niche-encoded).\n+                                let signed = match tag.value {\n+                                    Int(_, signed) => signed,\n+                                    _ => false,\n+                                };\n+                                let val = clif_intcast(fx, encoded_discr, cast_to, signed);\n+                                let val = CValue::by_val(val, dest_layout);\n+                                lval.write_cvalue(fx, val);\n+                            }\n+                            Variants::Multiple { .. } => unreachable!(),\n+                        }\n+                    } else {\n+                        let to_clif_ty = fx.clif_type(to_ty).unwrap();\n+                        let from = operand.load_scalar(fx);\n+\n+                        let res = clif_int_or_float_cast(\n+                            fx,\n+                            from,\n+                            type_sign(from_ty),\n+                            to_clif_ty,\n+                            type_sign(to_ty),\n+                        );\n+                        lval.write_cvalue(fx, CValue::by_val(res, dest_layout));\n+                    }\n+                }\n+                Rvalue::Cast(\n+                    CastKind::Pointer(PointerCast::ClosureFnPointer(_)),\n+                    operand,\n+                    _to_ty,\n+                ) => {\n+                    let operand = trans_operand(fx, operand);\n+                    match *operand.layout().ty.kind() {\n+                        ty::Closure(def_id, substs) => {\n+                            let instance = Instance::resolve_closure(\n+                                fx.tcx,\n+                                def_id,\n+                                substs,\n+                                ty::ClosureKind::FnOnce,\n+                            )\n+                            .polymorphize(fx.tcx);\n+                            let func_ref = fx.get_function_ref(instance);\n+                            let func_addr = fx.bcx.ins().func_addr(fx.pointer_type, func_ref);\n+                            lval.write_cvalue(fx, CValue::by_val(func_addr, lval.layout()));\n+                        }\n+                        _ => bug!(\"{} cannot be cast to a fn ptr\", operand.layout().ty),\n+                    }\n+                }\n+                Rvalue::Cast(CastKind::Pointer(PointerCast::Unsize), operand, _to_ty) => {\n+                    let operand = trans_operand(fx, operand);\n+                    operand.unsize_value(fx, lval);\n+                }\n+                Rvalue::Discriminant(place) => {\n+                    let place = trans_place(fx, *place);\n+                    let value = place.to_cvalue(fx);\n+                    let discr =\n+                        crate::discriminant::codegen_get_discriminant(fx, value, dest_layout);\n+                    lval.write_cvalue(fx, discr);\n+                }\n+                Rvalue::Repeat(operand, times) => {\n+                    let operand = trans_operand(fx, operand);\n+                    let times = fx\n+                        .monomorphize(times)\n+                        .eval(fx.tcx, ParamEnv::reveal_all())\n+                        .val\n+                        .try_to_bits(fx.tcx.data_layout.pointer_size)\n+                        .unwrap();\n+                    if fx.clif_type(operand.layout().ty) == Some(types::I8) {\n+                        let times = fx.bcx.ins().iconst(fx.pointer_type, times as i64);\n+                        // FIXME use emit_small_memset where possible\n+                        let addr = lval.to_ptr().get_addr(fx);\n+                        let val = operand.load_scalar(fx);\n+                        fx.bcx\n+                            .call_memset(fx.cx.module.target_config(), addr, val, times);\n+                    } else {\n+                        let loop_block = fx.bcx.create_block();\n+                        let loop_block2 = fx.bcx.create_block();\n+                        let done_block = fx.bcx.create_block();\n+                        let index = fx.bcx.append_block_param(loop_block, fx.pointer_type);\n+                        let zero = fx.bcx.ins().iconst(fx.pointer_type, 0);\n+                        fx.bcx.ins().jump(loop_block, &[zero]);\n+\n+                        fx.bcx.switch_to_block(loop_block);\n+                        let done = fx.bcx.ins().icmp_imm(IntCC::Equal, index, times as i64);\n+                        fx.bcx.ins().brnz(done, done_block, &[]);\n+                        fx.bcx.ins().jump(loop_block2, &[]);\n+\n+                        fx.bcx.switch_to_block(loop_block2);\n+                        let to = lval.place_index(fx, index);\n+                        to.write_cvalue(fx, operand);\n+                        let index = fx.bcx.ins().iadd_imm(index, 1);\n+                        fx.bcx.ins().jump(loop_block, &[index]);\n+\n+                        fx.bcx.switch_to_block(done_block);\n+                        fx.bcx.ins().nop();\n+                    }\n+                }\n+                Rvalue::Len(place) => {\n+                    let place = trans_place(fx, *place);\n+                    let usize_layout = fx.layout_of(fx.tcx.types.usize);\n+                    let len = codegen_array_len(fx, place);\n+                    lval.write_cvalue(fx, CValue::by_val(len, usize_layout));\n+                }\n+                Rvalue::NullaryOp(NullOp::Box, content_ty) => {\n+                    let usize_type = fx.clif_type(fx.tcx.types.usize).unwrap();\n+                    let content_ty = fx.monomorphize(content_ty);\n+                    let layout = fx.layout_of(content_ty);\n+                    let llsize = fx.bcx.ins().iconst(usize_type, layout.size.bytes() as i64);\n+                    let llalign = fx\n+                        .bcx\n+                        .ins()\n+                        .iconst(usize_type, layout.align.abi.bytes() as i64);\n+                    let box_layout = fx.layout_of(fx.tcx.mk_box(content_ty));\n+\n+                    // Allocate space:\n+                    let def_id = match fx\n+                        .tcx\n+                        .lang_items()\n+                        .require(rustc_hir::LangItem::ExchangeMalloc)\n+                    {\n+                        Ok(id) => id,\n+                        Err(s) => {\n+                            fx.tcx\n+                                .sess\n+                                .fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n+                        }\n+                    };\n+                    let instance = ty::Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n+                    let func_ref = fx.get_function_ref(instance);\n+                    let call = fx.bcx.ins().call(func_ref, &[llsize, llalign]);\n+                    let ptr = fx.bcx.inst_results(call)[0];\n+                    lval.write_cvalue(fx, CValue::by_val(ptr, box_layout));\n+                }\n+                Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n+                    assert!(lval\n+                        .layout()\n+                        .ty\n+                        .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all()));\n+                    let ty_size = fx.layout_of(fx.monomorphize(ty)).size.bytes();\n+                    let val =\n+                        CValue::const_val(fx, fx.layout_of(fx.tcx.types.usize), ty_size.into());\n+                    lval.write_cvalue(fx, val);\n+                }\n+                Rvalue::Aggregate(kind, operands) => match **kind {\n+                    AggregateKind::Array(_ty) => {\n+                        for (i, operand) in operands.into_iter().enumerate() {\n+                            let operand = trans_operand(fx, operand);\n+                            let index = fx.bcx.ins().iconst(fx.pointer_type, i as i64);\n+                            let to = lval.place_index(fx, index);\n+                            to.write_cvalue(fx, operand);\n+                        }\n+                    }\n+                    _ => unreachable!(\"shouldn't exist at trans {:?}\", to_place_and_rval.1),\n+                },\n+            }\n+        }\n+        StatementKind::StorageLive(_)\n+        | StatementKind::StorageDead(_)\n+        | StatementKind::Nop\n+        | StatementKind::FakeRead(..)\n+        | StatementKind::Retag { .. }\n+        | StatementKind::AscribeUserType(..) => {}\n+\n+        StatementKind::LlvmInlineAsm(asm) => {\n+            use rustc_span::symbol::Symbol;\n+            let LlvmInlineAsm {\n+                asm,\n+                outputs,\n+                inputs,\n+            } = &**asm;\n+            let rustc_hir::LlvmInlineAsmInner {\n+                asm: asm_code,         // Name\n+                outputs: output_names, // Vec<LlvmInlineAsmOutput>\n+                inputs: input_names,   // Vec<Name>\n+                clobbers,              // Vec<Name>\n+                volatile,              // bool\n+                alignstack,            // bool\n+                dialect: _,\n+                asm_str_style: _,\n+            } = asm;\n+            match asm_code.as_str().trim() {\n+                \"\" => {\n+                    // Black box\n+                }\n+                \"mov %rbx, %rsi\\n                  cpuid\\n                  xchg %rbx, %rsi\" => {\n+                    assert_eq!(\n+                        input_names,\n+                        &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]\n+                    );\n+                    assert_eq!(output_names.len(), 4);\n+                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"])\n+                        .iter()\n+                        .enumerate()\n+                    {\n+                        assert_eq!(&output_names[i].constraint.as_str(), c);\n+                        assert!(!output_names[i].is_rw);\n+                        assert!(!output_names[i].is_indirect);\n+                    }\n+\n+                    assert_eq!(clobbers, &[]);\n+\n+                    assert!(!volatile);\n+                    assert!(!alignstack);\n+\n+                    assert_eq!(inputs.len(), 2);\n+                    let leaf = trans_operand(fx, &inputs[0].1).load_scalar(fx); // %eax\n+                    let subleaf = trans_operand(fx, &inputs[1].1).load_scalar(fx); // %ecx\n+\n+                    let (eax, ebx, ecx, edx) =\n+                        crate::intrinsics::codegen_cpuid_call(fx, leaf, subleaf);\n+\n+                    assert_eq!(outputs.len(), 4);\n+                    trans_place(fx, outputs[0])\n+                        .write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n+                    trans_place(fx, outputs[1])\n+                        .write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n+                    trans_place(fx, outputs[2])\n+                        .write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n+                    trans_place(fx, outputs[3])\n+                        .write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n+                }\n+                \"xgetbv\" => {\n+                    assert_eq!(input_names, &[Symbol::intern(\"{ecx}\")]);\n+\n+                    assert_eq!(output_names.len(), 2);\n+                    for (i, c) in (&[\"={eax}\", \"={edx}\"]).iter().enumerate() {\n+                        assert_eq!(&output_names[i].constraint.as_str(), c);\n+                        assert!(!output_names[i].is_rw);\n+                        assert!(!output_names[i].is_indirect);\n+                    }\n+\n+                    assert_eq!(clobbers, &[]);\n+\n+                    assert!(!volatile);\n+                    assert!(!alignstack);\n+\n+                    crate::trap::trap_unimplemented(fx, \"_xgetbv arch intrinsic is not supported\");\n+                }\n+                // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n+                _ if fx\n+                    .tcx\n+                    .symbol_name(fx.instance)\n+                    .name\n+                    .starts_with(\"___chkstk\") =>\n+                {\n+                    crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n+                }\n+                _ if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" => {\n+                    crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n+                }\n+                // Used in sys::windows::abort_internal\n+                \"int $$0x29\" => {\n+                    crate::trap::trap_unimplemented(fx, \"Windows abort\");\n+                }\n+                _ => fx\n+                    .tcx\n+                    .sess\n+                    .span_fatal(stmt.source_info.span, \"Inline assembly is not supported\"),\n+            }\n+        }\n+        StatementKind::Coverage { .. } => fx.tcx.sess.fatal(\"-Zcoverage is unimplemented\"),\n+    }\n+}\n+\n+fn codegen_array_len<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    place: CPlace<'tcx>,\n+) -> Value {\n+    match *place.layout().ty.kind() {\n+        ty::Array(_elem_ty, len) => {\n+            let len = fx\n+                .monomorphize(&len)\n+                .eval(fx.tcx, ParamEnv::reveal_all())\n+                .eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64;\n+            fx.bcx.ins().iconst(fx.pointer_type, len)\n+        }\n+        ty::Slice(_elem_ty) => place\n+            .to_ptr_maybe_unsized()\n+            .1\n+            .expect(\"Length metadata for slice place\"),\n+        _ => bug!(\"Rvalue::Len({:?})\", place),\n+    }\n+}\n+\n+pub(crate) fn trans_place<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    place: Place<'tcx>,\n+) -> CPlace<'tcx> {\n+    let mut cplace = fx.get_local_place(place.local);\n+\n+    for elem in place.projection {\n+        match elem {\n+            PlaceElem::Deref => {\n+                cplace = cplace.place_deref(fx);\n+            }\n+            PlaceElem::Field(field, _ty) => {\n+                cplace = cplace.place_field(fx, field);\n+            }\n+            PlaceElem::Index(local) => {\n+                let index = fx.get_local_place(local).to_cvalue(fx).load_scalar(fx);\n+                cplace = cplace.place_index(fx, index);\n+            }\n+            PlaceElem::ConstantIndex {\n+                offset,\n+                min_length: _,\n+                from_end,\n+            } => {\n+                let offset: u64 = offset;\n+                let index = if !from_end {\n+                    fx.bcx.ins().iconst(fx.pointer_type, offset as i64)\n+                } else {\n+                    let len = codegen_array_len(fx, cplace);\n+                    fx.bcx.ins().iadd_imm(len, -(offset as i64))\n+                };\n+                cplace = cplace.place_index(fx, index);\n+            }\n+            PlaceElem::Subslice { from, to, from_end } => {\n+                // These indices are generated by slice patterns.\n+                // slice[from:-to] in Python terms.\n+\n+                let from: u64 = from;\n+                let to: u64 = to;\n+\n+                match cplace.layout().ty.kind() {\n+                    ty::Array(elem_ty, _len) => {\n+                        assert!(!from_end, \"array subslices are never `from_end`\");\n+                        let elem_layout = fx.layout_of(elem_ty);\n+                        let ptr = cplace.to_ptr();\n+                        cplace = CPlace::for_ptr(\n+                            ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * (from as i64)),\n+                            fx.layout_of(fx.tcx.mk_array(elem_ty, u64::from(to) - u64::from(from))),\n+                        );\n+                    }\n+                    ty::Slice(elem_ty) => {\n+                        assert!(from_end, \"slice subslices should be `from_end`\");\n+                        let elem_layout = fx.layout_of(elem_ty);\n+                        let (ptr, len) = cplace.to_ptr_maybe_unsized();\n+                        let len = len.unwrap();\n+                        cplace = CPlace::for_ptr_with_extra(\n+                            ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * (from as i64)),\n+                            fx.bcx.ins().iadd_imm(len, -(from as i64 + to as i64)),\n+                            cplace.layout(),\n+                        );\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            }\n+            PlaceElem::Downcast(_adt_def, variant) => {\n+                cplace = cplace.downcast_variant(fx, variant);\n+            }\n+        }\n+    }\n+\n+    cplace\n+}\n+\n+pub(crate) fn trans_operand<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    operand: &Operand<'tcx>,\n+) -> CValue<'tcx> {\n+    match operand {\n+        Operand::Move(place) | Operand::Copy(place) => {\n+            let cplace = trans_place(fx, *place);\n+            cplace.to_cvalue(fx)\n+        }\n+        Operand::Constant(const_) => crate::constant::trans_constant(fx, const_),\n+    }\n+}\n+\n+pub(crate) fn codegen_panic<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    msg_str: &str,\n+    span: Span,\n+) {\n+    let location = fx.get_caller_location(span).load_scalar(fx);\n+\n+    let msg_ptr = fx.anonymous_str(\"assert\", msg_str);\n+    let msg_len = fx\n+        .bcx\n+        .ins()\n+        .iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n+    let args = [msg_ptr, msg_len, location];\n+\n+    codegen_panic_inner(fx, rustc_hir::LangItem::Panic, &args, span);\n+}\n+\n+pub(crate) fn codegen_panic_inner<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    lang_item: rustc_hir::LangItem,\n+    args: &[Value],\n+    span: Span,\n+) {\n+    let def_id = fx\n+        .tcx\n+        .lang_items()\n+        .require(lang_item)\n+        .unwrap_or_else(|s| fx.tcx.sess.span_fatal(span, &s));\n+\n+    let instance = Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n+    let symbol_name = fx.tcx.symbol_name(instance).name;\n+\n+    fx.lib_call(\n+        &*symbol_name,\n+        vec![fx.pointer_type, fx.pointer_type, fx.pointer_type],\n+        vec![],\n+        args,\n+    );\n+\n+    crate::trap::trap_unreachable(fx, \"panic lang item returned\");\n+}"}, {"sha": "590c9ef0ce191e6c333a064cfff912f1f5b6ad51", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,88 @@\n+#![feature(rustc_private)]\n+\n+extern crate rustc_data_structures;\n+extern crate rustc_driver;\n+extern crate rustc_interface;\n+extern crate rustc_session;\n+extern crate rustc_target;\n+\n+use rustc_data_structures::profiling::print_time_passes_entry;\n+use rustc_interface::interface;\n+use rustc_session::config::ErrorOutputType;\n+use rustc_session::early_error;\n+use rustc_target::spec::PanicStrategy;\n+\n+#[derive(Default)]\n+pub struct CraneliftPassesCallbacks {\n+    time_passes: bool,\n+}\n+\n+impl rustc_driver::Callbacks for CraneliftPassesCallbacks {\n+    fn config(&mut self, config: &mut interface::Config) {\n+        // If a --prints=... option has been given, we don't print the \"total\"\n+        // time because it will mess up the --prints output. See #64339.\n+        self.time_passes = config.opts.prints.is_empty()\n+            && (config.opts.debugging_opts.time_passes || config.opts.debugging_opts.time);\n+\n+        // FIXME workaround for an ICE\n+        config.opts.debugging_opts.trim_diagnostic_paths = false;\n+\n+        config.opts.cg.panic = Some(PanicStrategy::Abort);\n+        config.opts.debugging_opts.panic_abort_tests = true;\n+        config.opts.maybe_sysroot = Some(\n+            std::env::current_exe()\n+                .unwrap()\n+                .parent()\n+                .unwrap()\n+                .parent()\n+                .unwrap()\n+                .parent()\n+                .unwrap()\n+                .join(\"build_sysroot\")\n+                .join(\"sysroot\"),\n+        );\n+    }\n+}\n+\n+fn main() {\n+    let start = std::time::Instant::now();\n+    rustc_driver::init_rustc_env_logger();\n+    let mut callbacks = CraneliftPassesCallbacks::default();\n+    rustc_driver::install_ice_hook();\n+    let exit_code = rustc_driver::catch_with_exit_code(|| {\n+        let mut use_jit = false;\n+\n+        let mut args = std::env::args_os()\n+            .enumerate()\n+            .map(|(i, arg)| {\n+                arg.into_string().unwrap_or_else(|arg| {\n+                    early_error(\n+                        ErrorOutputType::default(),\n+                        &format!(\"Argument {} is not valid Unicode: {:?}\", i, arg),\n+                    )\n+                })\n+            })\n+            .filter(|arg| {\n+                if arg == \"--jit\" {\n+                    use_jit = true;\n+                    false\n+                } else {\n+                    true\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+        if use_jit {\n+            args.push(\"-Cprefer-dynamic\".to_string());\n+        }\n+        let mut run_compiler = rustc_driver::RunCompiler::new(&args, &mut callbacks);\n+        run_compiler.set_make_codegen_backend(Some(Box::new(move |_| {\n+            Box::new(rustc_codegen_cranelift::CraneliftCodegenBackend {\n+                config: rustc_codegen_cranelift::BackendConfig { use_jit },\n+            })\n+        })));\n+        run_compiler.run()\n+    });\n+    // The extra `\\t` is necessary to align this label with the others.\n+    print_time_passes_entry(callbacks.time_passes, \"\\ttotal\", start.elapsed());\n+    std::process::exit(exit_code)\n+}"}, {"sha": "c207d98d6c197bdac2c8a7161e33604c9b6c473d", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif_build_sysroot.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,106 @@\n+//! The only difference between this and cg_clif.rs is that this binary defaults to using cg_llvm\n+//! instead of cg_clif and requires `--clif` to use cg_clif and that this binary doesn't have JIT\n+//! support.\n+//! This is necessary as with Cargo `RUSTC` applies to both target crates and host crates. The host\n+//! crates must be built with cg_llvm as we are currently building a sysroot for cg_clif.\n+//! `RUSTFLAGS` however is only applied to target crates, so `--clif` would only be passed to the\n+//! target crates.\n+\n+#![feature(rustc_private)]\n+\n+extern crate rustc_data_structures;\n+extern crate rustc_driver;\n+extern crate rustc_interface;\n+extern crate rustc_session;\n+extern crate rustc_target;\n+\n+use std::path::PathBuf;\n+\n+use rustc_interface::interface;\n+use rustc_session::config::ErrorOutputType;\n+use rustc_session::early_error;\n+use rustc_target::spec::PanicStrategy;\n+\n+fn find_sysroot() -> String {\n+    // Taken from https://github.com/Manishearth/rust-clippy/pull/911.\n+    let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n+    let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n+    match (home, toolchain) {\n+        (Some(home), Some(toolchain)) => format!(\"{}/toolchains/{}\", home, toolchain),\n+        _ => option_env!(\"RUST_SYSROOT\")\n+            .expect(\"need to specify RUST_SYSROOT env var or use rustup or multirust\")\n+            .to_owned(),\n+    }\n+}\n+\n+pub struct CraneliftPassesCallbacks {\n+    use_clif: bool,\n+}\n+\n+impl rustc_driver::Callbacks for CraneliftPassesCallbacks {\n+    fn config(&mut self, config: &mut interface::Config) {\n+        if !self.use_clif {\n+            config.opts.maybe_sysroot = Some(PathBuf::from(find_sysroot()));\n+            return;\n+        }\n+\n+        // FIXME workaround for an ICE\n+        config.opts.debugging_opts.trim_diagnostic_paths = false;\n+\n+        config.opts.cg.panic = Some(PanicStrategy::Abort);\n+        config.opts.debugging_opts.panic_abort_tests = true;\n+        config.opts.maybe_sysroot = Some(\n+            std::env::current_exe()\n+                .unwrap()\n+                .parent()\n+                .unwrap()\n+                .parent()\n+                .unwrap()\n+                .parent()\n+                .unwrap()\n+                .join(\"build_sysroot\")\n+                .join(\"sysroot\"),\n+        );\n+    }\n+}\n+\n+fn main() {\n+    rustc_driver::init_rustc_env_logger();\n+    rustc_driver::install_ice_hook();\n+    let exit_code = rustc_driver::catch_with_exit_code(|| {\n+        let mut use_clif = false;\n+\n+        let args = std::env::args_os()\n+            .enumerate()\n+            .map(|(i, arg)| {\n+                arg.into_string().unwrap_or_else(|arg| {\n+                    early_error(\n+                        ErrorOutputType::default(),\n+                        &format!(\"Argument {} is not valid Unicode: {:?}\", i, arg),\n+                    )\n+                })\n+            })\n+            .filter(|arg| {\n+                if arg == \"--clif\" {\n+                    use_clif = true;\n+                    false\n+                } else {\n+                    true\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+\n+        let mut callbacks = CraneliftPassesCallbacks { use_clif };\n+\n+        let mut run_compiler = rustc_driver::RunCompiler::new(&args, &mut callbacks);\n+        if use_clif {\n+            run_compiler.set_make_codegen_backend(Some(Box::new(move |_| {\n+                Box::new(rustc_codegen_cranelift::CraneliftCodegenBackend {\n+                    config: rustc_codegen_cranelift::BackendConfig { use_jit: false },\n+                })\n+            })));\n+        }\n+        run_compiler.run()\n+    });\n+    std::process::exit(exit_code)\n+}"}, {"sha": "122a36b5bf741d25c38e0116889307f350b5f856", "filename": "compiler/rustc_codegen_cranelift/src/cast.rs", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,201 @@\n+//! Various number casting functions\n+\n+use crate::prelude::*;\n+\n+pub(crate) fn clif_intcast(\n+    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    val: Value,\n+    to: Type,\n+    signed: bool,\n+) -> Value {\n+    let from = fx.bcx.func.dfg.value_type(val);\n+    match (from, to) {\n+        // equal\n+        (_, _) if from == to => val,\n+\n+        // extend\n+        (_, types::I128) => {\n+            let lo = if from == types::I64 {\n+                val\n+            } else if signed {\n+                fx.bcx.ins().sextend(types::I64, val)\n+            } else {\n+                fx.bcx.ins().uextend(types::I64, val)\n+            };\n+            let hi = if signed {\n+                fx.bcx.ins().sshr_imm(lo, 63)\n+            } else {\n+                fx.bcx.ins().iconst(types::I64, 0)\n+            };\n+            fx.bcx.ins().iconcat(lo, hi)\n+        }\n+        (_, _) if to.wider_or_equal(from) => {\n+            if signed {\n+                fx.bcx.ins().sextend(to, val)\n+            } else {\n+                fx.bcx.ins().uextend(to, val)\n+            }\n+        }\n+\n+        // reduce\n+        (types::I128, _) => {\n+            let (lsb, _msb) = fx.bcx.ins().isplit(val);\n+            if to == types::I64 {\n+                lsb\n+            } else {\n+                fx.bcx.ins().ireduce(to, lsb)\n+            }\n+        }\n+        (_, _) => fx.bcx.ins().ireduce(to, val),\n+    }\n+}\n+\n+pub(crate) fn clif_int_or_float_cast(\n+    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    from: Value,\n+    from_signed: bool,\n+    to_ty: Type,\n+    to_signed: bool,\n+) -> Value {\n+    let from_ty = fx.bcx.func.dfg.value_type(from);\n+\n+    if from_ty.is_int() && to_ty.is_int() {\n+        // int-like -> int-like\n+        clif_intcast(\n+            fx,\n+            from,\n+            to_ty,\n+            // This is correct as either from_signed == to_signed (=> this is trivially correct)\n+            // Or from_clif_ty == to_clif_ty, which means this is a no-op.\n+            from_signed,\n+        )\n+    } else if from_ty.is_int() && to_ty.is_float() {\n+        if from_ty == types::I128 {\n+            // _______ss__f_\n+            // __float  tisf: i128 -> f32\n+            // __float  tidf: i128 -> f64\n+            // __floatuntisf: u128 -> f32\n+            // __floatuntidf: u128 -> f64\n+\n+            let name = format!(\n+                \"__float{sign}ti{flt}f\",\n+                sign = if from_signed { \"\" } else { \"un\" },\n+                flt = match to_ty {\n+                    types::F32 => \"s\",\n+                    types::F64 => \"d\",\n+                    _ => unreachable!(\"{:?}\", to_ty),\n+                },\n+            );\n+\n+            let from_rust_ty = if from_signed {\n+                fx.tcx.types.i128\n+            } else {\n+                fx.tcx.types.u128\n+            };\n+\n+            let to_rust_ty = match to_ty {\n+                types::F32 => fx.tcx.types.f32,\n+                types::F64 => fx.tcx.types.f64,\n+                _ => unreachable!(),\n+            };\n+\n+            return fx\n+                .easy_call(\n+                    &name,\n+                    &[CValue::by_val(from, fx.layout_of(from_rust_ty))],\n+                    to_rust_ty,\n+                )\n+                .load_scalar(fx);\n+        }\n+\n+        // int-like -> float\n+        if from_signed {\n+            fx.bcx.ins().fcvt_from_sint(to_ty, from)\n+        } else {\n+            fx.bcx.ins().fcvt_from_uint(to_ty, from)\n+        }\n+    } else if from_ty.is_float() && to_ty.is_int() {\n+        if to_ty == types::I128 {\n+            // _____sssf___\n+            // __fix   sfti: f32 -> i128\n+            // __fix   dfti: f64 -> i128\n+            // __fixunssfti: f32 -> u128\n+            // __fixunsdfti: f64 -> u128\n+\n+            let name = format!(\n+                \"__fix{sign}{flt}fti\",\n+                sign = if to_signed { \"\" } else { \"uns\" },\n+                flt = match from_ty {\n+                    types::F32 => \"s\",\n+                    types::F64 => \"d\",\n+                    _ => unreachable!(\"{:?}\", to_ty),\n+                },\n+            );\n+\n+            let from_rust_ty = match from_ty {\n+                types::F32 => fx.tcx.types.f32,\n+                types::F64 => fx.tcx.types.f64,\n+                _ => unreachable!(),\n+            };\n+\n+            let to_rust_ty = if to_signed {\n+                fx.tcx.types.i128\n+            } else {\n+                fx.tcx.types.u128\n+            };\n+\n+            return fx\n+                .easy_call(\n+                    &name,\n+                    &[CValue::by_val(from, fx.layout_of(from_rust_ty))],\n+                    to_rust_ty,\n+                )\n+                .load_scalar(fx);\n+        }\n+\n+        // float -> int-like\n+        if to_ty == types::I8 || to_ty == types::I16 {\n+            // FIXME implement fcvt_to_*int_sat.i8/i16\n+            let val = if to_signed {\n+                fx.bcx.ins().fcvt_to_sint_sat(types::I32, from)\n+            } else {\n+                fx.bcx.ins().fcvt_to_uint_sat(types::I32, from)\n+            };\n+            let (min, max) = match (to_ty, to_signed) {\n+                (types::I8, false) => (0, i64::from(u8::MAX)),\n+                (types::I16, false) => (0, i64::from(u16::MAX)),\n+                (types::I8, true) => (i64::from(i8::MIN), i64::from(i8::MAX)),\n+                (types::I16, true) => (i64::from(i16::MIN), i64::from(i16::MAX)),\n+                _ => unreachable!(),\n+            };\n+            let min_val = fx.bcx.ins().iconst(types::I32, min);\n+            let max_val = fx.bcx.ins().iconst(types::I32, max);\n+\n+            let val = if to_signed {\n+                let has_underflow = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, val, min);\n+                let has_overflow = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThan, val, max);\n+                let bottom_capped = fx.bcx.ins().select(has_underflow, min_val, val);\n+                fx.bcx.ins().select(has_overflow, max_val, bottom_capped)\n+            } else {\n+                let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, val, max);\n+                fx.bcx.ins().select(has_overflow, max_val, val)\n+            };\n+            fx.bcx.ins().ireduce(to_ty, val)\n+        } else {\n+            if to_signed {\n+                fx.bcx.ins().fcvt_to_sint_sat(to_ty, from)\n+            } else {\n+                fx.bcx.ins().fcvt_to_uint_sat(to_ty, from)\n+            }\n+        }\n+    } else if from_ty.is_float() && to_ty.is_float() {\n+        // float -> float\n+        match (from_ty, to_ty) {\n+            (types::F32, types::F64) => fx.bcx.ins().fpromote(types::F64, from),\n+            (types::F64, types::F32) => fx.bcx.ins().fdemote(types::F32, from),\n+            _ => from,\n+        }\n+    } else {\n+        unreachable!(\"cast value from {:?} to {:?}\", from_ty, to_ty);\n+    }\n+}"}, {"sha": "e998403dea6bbea475d96f2e17f8baf2540c1936", "filename": "compiler/rustc_codegen_cranelift/src/codegen_i128.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,165 @@\n+//! Replaces 128-bit operators with lang item calls where necessary\n+\n+use crate::prelude::*;\n+\n+pub(crate) fn maybe_codegen<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    bin_op: BinOp,\n+    checked: bool,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+) -> Option<CValue<'tcx>> {\n+    if lhs.layout().ty != fx.tcx.types.u128 && lhs.layout().ty != fx.tcx.types.i128 {\n+        return None;\n+    }\n+\n+    let lhs_val = lhs.load_scalar(fx);\n+    let rhs_val = rhs.load_scalar(fx);\n+\n+    let is_signed = type_sign(lhs.layout().ty);\n+\n+    match bin_op {\n+        BinOp::BitAnd | BinOp::BitOr | BinOp::BitXor => {\n+            assert!(!checked);\n+            return None;\n+        }\n+        BinOp::Add | BinOp::Sub if !checked => return None,\n+        BinOp::Add => {\n+            let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n+            return Some(if is_signed {\n+                fx.easy_call(\"__rust_i128_addo\", &[lhs, rhs], out_ty)\n+            } else {\n+                fx.easy_call(\"__rust_u128_addo\", &[lhs, rhs], out_ty)\n+            });\n+        }\n+        BinOp::Sub => {\n+            let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n+            return Some(if is_signed {\n+                fx.easy_call(\"__rust_i128_subo\", &[lhs, rhs], out_ty)\n+            } else {\n+                fx.easy_call(\"__rust_u128_subo\", &[lhs, rhs], out_ty)\n+            });\n+        }\n+        BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n+        BinOp::Mul => {\n+            let res = if checked {\n+                let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n+                if is_signed {\n+                    fx.easy_call(\"__rust_i128_mulo\", &[lhs, rhs], out_ty)\n+                } else {\n+                    fx.easy_call(\"__rust_u128_mulo\", &[lhs, rhs], out_ty)\n+                }\n+            } else {\n+                let val_ty = if is_signed {\n+                    fx.tcx.types.i128\n+                } else {\n+                    fx.tcx.types.u128\n+                };\n+                fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty)\n+            };\n+            return Some(res);\n+        }\n+        BinOp::Div => {\n+            assert!(!checked);\n+            if is_signed {\n+                Some(fx.easy_call(\"__divti3\", &[lhs, rhs], fx.tcx.types.i128))\n+            } else {\n+                Some(fx.easy_call(\"__udivti3\", &[lhs, rhs], fx.tcx.types.u128))\n+            }\n+        }\n+        BinOp::Rem => {\n+            assert!(!checked);\n+            if is_signed {\n+                Some(fx.easy_call(\"__modti3\", &[lhs, rhs], fx.tcx.types.i128))\n+            } else {\n+                Some(fx.easy_call(\"__umodti3\", &[lhs, rhs], fx.tcx.types.u128))\n+            }\n+        }\n+        BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {\n+            assert!(!checked);\n+            return None;\n+        }\n+        BinOp::Shl | BinOp::Shr => {\n+            let is_overflow = if checked {\n+                // rhs >= 128\n+\n+                // FIXME support non 128bit rhs\n+                /*let (rhs_lsb, rhs_msb) = fx.bcx.ins().isplit(rhs_val);\n+                let rhs_msb_gt_0 = fx.bcx.ins().icmp_imm(IntCC::NotEqual, rhs_msb, 0);\n+                let rhs_lsb_ge_128 = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThan, rhs_lsb, 127);\n+                let is_overflow = fx.bcx.ins().bor(rhs_msb_gt_0, rhs_lsb_ge_128);*/\n+                let is_overflow = fx.bcx.ins().bconst(types::B1, false);\n+\n+                Some(fx.bcx.ins().bint(types::I8, is_overflow))\n+            } else {\n+                None\n+            };\n+\n+            // Optimize `val >> 64`, because compiler_builtins uses it to deconstruct an 128bit\n+            // integer into its lsb and msb.\n+            // https://github.com/rust-lang-nursery/compiler-builtins/blob/79a6a1603d5672cbb9187ff41ff4d9b5048ac1cb/src/int/mod.rs#L217\n+            if resolve_value_imm(fx.bcx.func, rhs_val) == Some(64) {\n+                let (lhs_lsb, lhs_msb) = fx.bcx.ins().isplit(lhs_val);\n+                let all_zeros = fx.bcx.ins().iconst(types::I64, 0);\n+                let val = match (bin_op, is_signed) {\n+                    (BinOp::Shr, false) => {\n+                        let val = fx.bcx.ins().iconcat(lhs_msb, all_zeros);\n+                        Some(CValue::by_val(val, fx.layout_of(fx.tcx.types.u128)))\n+                    }\n+                    (BinOp::Shr, true) => {\n+                        let sign = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, lhs_msb, 0);\n+                        let all_ones = fx.bcx.ins().iconst(types::I64, u64::MAX as i64);\n+                        let all_sign_bits = fx.bcx.ins().select(sign, all_zeros, all_ones);\n+\n+                        let val = fx.bcx.ins().iconcat(lhs_msb, all_sign_bits);\n+                        Some(CValue::by_val(val, fx.layout_of(fx.tcx.types.i128)))\n+                    }\n+                    (BinOp::Shl, _) => {\n+                        let val_ty = if is_signed {\n+                            fx.tcx.types.i128\n+                        } else {\n+                            fx.tcx.types.u128\n+                        };\n+                        let val = fx.bcx.ins().iconcat(all_zeros, lhs_lsb);\n+                        Some(CValue::by_val(val, fx.layout_of(val_ty)))\n+                    }\n+                    _ => None,\n+                };\n+                if let Some(val) = val {\n+                    if let Some(is_overflow) = is_overflow {\n+                        let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n+                        let val = val.load_scalar(fx);\n+                        return Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)));\n+                    } else {\n+                        return Some(val);\n+                    }\n+                }\n+            }\n+\n+            let truncated_rhs = clif_intcast(fx, rhs_val, types::I32, false);\n+            let truncated_rhs = CValue::by_val(truncated_rhs, fx.layout_of(fx.tcx.types.u32));\n+            let val = match (bin_op, is_signed) {\n+                (BinOp::Shl, false) => {\n+                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fx.tcx.types.u128)\n+                }\n+                (BinOp::Shl, true) => {\n+                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fx.tcx.types.i128)\n+                }\n+                (BinOp::Shr, false) => {\n+                    fx.easy_call(\"__lshrti3\", &[lhs, truncated_rhs], fx.tcx.types.u128)\n+                }\n+                (BinOp::Shr, true) => {\n+                    fx.easy_call(\"__ashrti3\", &[lhs, truncated_rhs], fx.tcx.types.i128)\n+                }\n+                (_, _) => unreachable!(),\n+            };\n+            if let Some(is_overflow) = is_overflow {\n+                let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n+                let val = val.load_scalar(fx);\n+                Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)))\n+            } else {\n+                Some(val)\n+            }\n+        }\n+    }\n+}"}, {"sha": "13c62add41a3b520bee56d4daac980f0c05a0a97", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "added", "additions": 446, "deletions": 0, "changes": 446, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,446 @@\n+use rustc_index::vec::IndexVec;\n+use rustc_target::abi::{Integer, Primitive};\n+use rustc_target::spec::{HasTargetSpec, Target};\n+\n+use cranelift_codegen::ir::{InstructionData, Opcode, ValueDef};\n+\n+use crate::prelude::*;\n+\n+pub(crate) fn pointer_ty(tcx: TyCtxt<'_>) -> types::Type {\n+    match tcx.data_layout.pointer_size.bits() {\n+        16 => types::I16,\n+        32 => types::I32,\n+        64 => types::I64,\n+        bits => bug!(\"ptr_sized_integer: unknown pointer bit size {}\", bits),\n+    }\n+}\n+\n+pub(crate) fn scalar_to_clif_type(tcx: TyCtxt<'_>, scalar: Scalar) -> Type {\n+    match scalar.value {\n+        Primitive::Int(int, _sign) => match int {\n+            Integer::I8 => types::I8,\n+            Integer::I16 => types::I16,\n+            Integer::I32 => types::I32,\n+            Integer::I64 => types::I64,\n+            Integer::I128 => types::I128,\n+        },\n+        Primitive::F32 => types::F32,\n+        Primitive::F64 => types::F64,\n+        Primitive::Pointer => pointer_ty(tcx),\n+    }\n+}\n+\n+fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Type> {\n+    Some(match ty.kind() {\n+        ty::Bool => types::I8,\n+        ty::Uint(size) => match size {\n+            UintTy::U8 => types::I8,\n+            UintTy::U16 => types::I16,\n+            UintTy::U32 => types::I32,\n+            UintTy::U64 => types::I64,\n+            UintTy::U128 => types::I128,\n+            UintTy::Usize => pointer_ty(tcx),\n+        },\n+        ty::Int(size) => match size {\n+            IntTy::I8 => types::I8,\n+            IntTy::I16 => types::I16,\n+            IntTy::I32 => types::I32,\n+            IntTy::I64 => types::I64,\n+            IntTy::I128 => types::I128,\n+            IntTy::Isize => pointer_ty(tcx),\n+        },\n+        ty::Char => types::I32,\n+        ty::Float(size) => match size {\n+            FloatTy::F32 => types::F32,\n+            FloatTy::F64 => types::F64,\n+        },\n+        ty::FnPtr(_) => pointer_ty(tcx),\n+        ty::RawPtr(TypeAndMut {\n+            ty: pointee_ty,\n+            mutbl: _,\n+        })\n+        | ty::Ref(_, pointee_ty, _) => {\n+            if has_ptr_meta(tcx, pointee_ty) {\n+                return None;\n+            } else {\n+                pointer_ty(tcx)\n+            }\n+        }\n+        ty::Adt(adt_def, _) if adt_def.repr.simd() => {\n+            let (element, count) = match &tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().abi\n+            {\n+                Abi::Vector { element, count } => (element.clone(), *count),\n+                _ => unreachable!(),\n+            };\n+\n+            match scalar_to_clif_type(tcx, element).by(u16::try_from(count).unwrap()) {\n+                // Cranelift currently only implements icmp for 128bit vectors.\n+                Some(vector_ty) if vector_ty.bits() == 128 => vector_ty,\n+                _ => return None,\n+            }\n+        }\n+        ty::Param(_) => bug!(\"ty param {:?}\", ty),\n+        _ => return None,\n+    })\n+}\n+\n+fn clif_pair_type_from_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<(types::Type, types::Type)> {\n+    Some(match ty.kind() {\n+        ty::Tuple(substs) if substs.len() == 2 => {\n+            let mut types = substs.types();\n+            let a = clif_type_from_ty(tcx, types.next().unwrap())?;\n+            let b = clif_type_from_ty(tcx, types.next().unwrap())?;\n+            if a.is_vector() || b.is_vector() {\n+                return None;\n+            }\n+            (a, b)\n+        }\n+        ty::RawPtr(TypeAndMut {\n+            ty: pointee_ty,\n+            mutbl: _,\n+        })\n+        | ty::Ref(_, pointee_ty, _) => {\n+            if has_ptr_meta(tcx, pointee_ty) {\n+                (pointer_ty(tcx), pointer_ty(tcx))\n+            } else {\n+                return None;\n+            }\n+        }\n+        _ => return None,\n+    })\n+}\n+\n+/// Is a pointer to this type a fat ptr?\n+pub(crate) fn has_ptr_meta<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+    let ptr_ty = tcx.mk_ptr(TypeAndMut {\n+        ty,\n+        mutbl: rustc_hir::Mutability::Not,\n+    });\n+    match &tcx\n+        .layout_of(ParamEnv::reveal_all().and(ptr_ty))\n+        .unwrap()\n+        .abi\n+    {\n+        Abi::Scalar(_) => false,\n+        Abi::ScalarPair(_, _) => true,\n+        abi => unreachable!(\"Abi of ptr to {:?} is {:?}???\", ty, abi),\n+    }\n+}\n+\n+pub(crate) fn codegen_icmp_imm(\n+    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    intcc: IntCC,\n+    lhs: Value,\n+    rhs: i128,\n+) -> Value {\n+    let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n+    if lhs_ty == types::I128 {\n+        // FIXME legalize `icmp_imm.i128` in Cranelift\n+\n+        let (lhs_lsb, lhs_msb) = fx.bcx.ins().isplit(lhs);\n+        let (rhs_lsb, rhs_msb) = (rhs as u128 as u64 as i64, (rhs as u128 >> 64) as u64 as i64);\n+\n+        match intcc {\n+            IntCC::Equal => {\n+                let lsb_eq = fx.bcx.ins().icmp_imm(IntCC::Equal, lhs_lsb, rhs_lsb);\n+                let msb_eq = fx.bcx.ins().icmp_imm(IntCC::Equal, lhs_msb, rhs_msb);\n+                fx.bcx.ins().band(lsb_eq, msb_eq)\n+            }\n+            IntCC::NotEqual => {\n+                let lsb_ne = fx.bcx.ins().icmp_imm(IntCC::NotEqual, lhs_lsb, rhs_lsb);\n+                let msb_ne = fx.bcx.ins().icmp_imm(IntCC::NotEqual, lhs_msb, rhs_msb);\n+                fx.bcx.ins().bor(lsb_ne, msb_ne)\n+            }\n+            _ => {\n+                // if msb_eq {\n+                //     lsb_cc\n+                // } else {\n+                //     msb_cc\n+                // }\n+\n+                let msb_eq = fx.bcx.ins().icmp_imm(IntCC::Equal, lhs_msb, rhs_msb);\n+                let lsb_cc = fx.bcx.ins().icmp_imm(intcc, lhs_lsb, rhs_lsb);\n+                let msb_cc = fx.bcx.ins().icmp_imm(intcc, lhs_msb, rhs_msb);\n+\n+                fx.bcx.ins().select(msb_eq, lsb_cc, msb_cc)\n+            }\n+        }\n+    } else {\n+        let rhs = i64::try_from(rhs).expect(\"codegen_icmp_imm rhs out of range for <128bit int\");\n+        fx.bcx.ins().icmp_imm(intcc, lhs, rhs)\n+    }\n+}\n+\n+fn resolve_normal_value_imm(func: &Function, val: Value) -> Option<i64> {\n+    if let ValueDef::Result(inst, 0 /*param*/) = func.dfg.value_def(val) {\n+        if let InstructionData::UnaryImm {\n+            opcode: Opcode::Iconst,\n+            imm,\n+        } = func.dfg[inst]\n+        {\n+            Some(imm.into())\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+fn resolve_128bit_value_imm(func: &Function, val: Value) -> Option<u128> {\n+    let (lsb, msb) = if let ValueDef::Result(inst, 0 /*param*/) = func.dfg.value_def(val) {\n+        if let InstructionData::Binary {\n+            opcode: Opcode::Iconcat,\n+            args: [lsb, msb],\n+        } = func.dfg[inst]\n+        {\n+            (lsb, msb)\n+        } else {\n+            return None;\n+        }\n+    } else {\n+        return None;\n+    };\n+\n+    let lsb = u128::from(resolve_normal_value_imm(func, lsb)? as u64);\n+    let msb = u128::from(resolve_normal_value_imm(func, msb)? as u64);\n+\n+    Some(msb << 64 | lsb)\n+}\n+\n+pub(crate) fn resolve_value_imm(func: &Function, val: Value) -> Option<u128> {\n+    if func.dfg.value_type(val) == types::I128 {\n+        resolve_128bit_value_imm(func, val)\n+    } else {\n+        resolve_normal_value_imm(func, val).map(|imm| u128::from(imm as u64))\n+    }\n+}\n+\n+pub(crate) fn type_min_max_value(\n+    bcx: &mut FunctionBuilder<'_>,\n+    ty: Type,\n+    signed: bool,\n+) -> (Value, Value) {\n+    assert!(ty.is_int());\n+\n+    if ty == types::I128 {\n+        if signed {\n+            let min = i128::MIN as u128;\n+            let min_lsb = bcx.ins().iconst(types::I64, min as u64 as i64);\n+            let min_msb = bcx.ins().iconst(types::I64, (min >> 64) as u64 as i64);\n+            let min = bcx.ins().iconcat(min_lsb, min_msb);\n+\n+            let max = i128::MIN as u128;\n+            let max_lsb = bcx.ins().iconst(types::I64, max as u64 as i64);\n+            let max_msb = bcx.ins().iconst(types::I64, (max >> 64) as u64 as i64);\n+            let max = bcx.ins().iconcat(max_lsb, max_msb);\n+\n+            return (min, max);\n+        } else {\n+            let min_half = bcx.ins().iconst(types::I64, 0);\n+            let min = bcx.ins().iconcat(min_half, min_half);\n+\n+            let max_half = bcx.ins().iconst(types::I64, u64::MAX as i64);\n+            let max = bcx.ins().iconcat(max_half, max_half);\n+\n+            return (min, max);\n+        }\n+    }\n+\n+    let min = match (ty, signed) {\n+        (types::I8, false) | (types::I16, false) | (types::I32, false) | (types::I64, false) => {\n+            0i64\n+        }\n+        (types::I8, true) => i64::from(i8::MIN),\n+        (types::I16, true) => i64::from(i16::MIN),\n+        (types::I32, true) => i64::from(i32::MIN),\n+        (types::I64, true) => i64::MIN,\n+        _ => unreachable!(),\n+    };\n+\n+    let max = match (ty, signed) {\n+        (types::I8, false) => i64::from(u8::MAX),\n+        (types::I16, false) => i64::from(u16::MAX),\n+        (types::I32, false) => i64::from(u32::MAX),\n+        (types::I64, false) => u64::MAX as i64,\n+        (types::I8, true) => i64::from(i8::MAX),\n+        (types::I16, true) => i64::from(i16::MAX),\n+        (types::I32, true) => i64::from(i32::MAX),\n+        (types::I64, true) => i64::MAX,\n+        _ => unreachable!(),\n+    };\n+\n+    let (min, max) = (bcx.ins().iconst(ty, min), bcx.ins().iconst(ty, max));\n+\n+    (min, max)\n+}\n+\n+pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n+    match ty.kind() {\n+        ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..) | ty::Char | ty::Uint(..) | ty::Bool => false,\n+        ty::Int(..) => true,\n+        ty::Float(..) => false, // `signed` is unused for floats\n+        _ => panic!(\"{}\", ty),\n+    }\n+}\n+\n+pub(crate) struct FunctionCx<'clif, 'tcx, M: Module> {\n+    pub(crate) cx: &'clif mut crate::CodegenCx<'tcx, M>,\n+    pub(crate) tcx: TyCtxt<'tcx>,\n+    pub(crate) pointer_type: Type, // Cached from module\n+\n+    pub(crate) instance: Instance<'tcx>,\n+    pub(crate) mir: &'tcx Body<'tcx>,\n+\n+    pub(crate) bcx: FunctionBuilder<'clif>,\n+    pub(crate) block_map: IndexVec<BasicBlock, Block>,\n+    pub(crate) local_map: IndexVec<Local, CPlace<'tcx>>,\n+\n+    /// When `#[track_caller]` is used, the implicit caller location is stored in this variable.\n+    pub(crate) caller_location: Option<CValue<'tcx>>,\n+\n+    /// See [`crate::optimize::code_layout`] for more information.\n+    pub(crate) cold_blocks: EntitySet<Block>,\n+\n+    pub(crate) clif_comments: crate::pretty_clif::CommentWriter,\n+    pub(crate) source_info_set: indexmap::IndexSet<SourceInfo>,\n+\n+    /// This should only be accessed by `CPlace::new_var`.\n+    pub(crate) next_ssa_var: u32,\n+\n+    pub(crate) inline_asm_index: u32,\n+}\n+\n+impl<'tcx, M: Module> LayoutOf for FunctionCx<'_, 'tcx, M> {\n+    type Ty = Ty<'tcx>;\n+    type TyAndLayout = TyAndLayout<'tcx>;\n+\n+    fn layout_of(&self, ty: Ty<'tcx>) -> TyAndLayout<'tcx> {\n+        assert!(!ty.still_further_specializable());\n+        self.tcx\n+            .layout_of(ParamEnv::reveal_all().and(&ty))\n+            .unwrap_or_else(|e| {\n+                if let layout::LayoutError::SizeOverflow(_) = e {\n+                    self.tcx.sess.fatal(&e.to_string())\n+                } else {\n+                    bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+                }\n+            })\n+    }\n+}\n+\n+impl<'tcx, M: Module> layout::HasTyCtxt<'tcx> for FunctionCx<'_, 'tcx, M> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+}\n+\n+impl<'tcx, M: Module> rustc_target::abi::HasDataLayout for FunctionCx<'_, 'tcx, M> {\n+    fn data_layout(&self) -> &rustc_target::abi::TargetDataLayout {\n+        &self.tcx.data_layout\n+    }\n+}\n+\n+impl<'tcx, M: Module> layout::HasParamEnv<'tcx> for FunctionCx<'_, 'tcx, M> {\n+    fn param_env(&self) -> ParamEnv<'tcx> {\n+        ParamEnv::reveal_all()\n+    }\n+}\n+\n+impl<'tcx, M: Module> HasTargetSpec for FunctionCx<'_, 'tcx, M> {\n+    fn target_spec(&self) -> &Target {\n+        &self.tcx.sess.target\n+    }\n+}\n+\n+impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n+    pub(crate) fn monomorphize<T>(&self, value: &T) -> T\n+    where\n+        T: TypeFoldable<'tcx> + Copy,\n+    {\n+        if let Some(substs) = self.instance.substs_for_mir_body() {\n+            self.tcx\n+                .subst_and_normalize_erasing_regions(substs, ty::ParamEnv::reveal_all(), value)\n+        } else {\n+            self.tcx\n+                .normalize_erasing_regions(ty::ParamEnv::reveal_all(), *value)\n+        }\n+    }\n+\n+    pub(crate) fn clif_type(&self, ty: Ty<'tcx>) -> Option<Type> {\n+        clif_type_from_ty(self.tcx, ty)\n+    }\n+\n+    pub(crate) fn clif_pair_type(&self, ty: Ty<'tcx>) -> Option<(Type, Type)> {\n+        clif_pair_type_from_ty(self.tcx, ty)\n+    }\n+\n+    pub(crate) fn get_block(&self, bb: BasicBlock) -> Block {\n+        *self.block_map.get(bb).unwrap()\n+    }\n+\n+    pub(crate) fn get_local_place(&mut self, local: Local) -> CPlace<'tcx> {\n+        *self.local_map.get(local).unwrap_or_else(|| {\n+            panic!(\"Local {:?} doesn't exist\", local);\n+        })\n+    }\n+\n+    pub(crate) fn set_debug_loc(&mut self, source_info: mir::SourceInfo) {\n+        let (index, _) = self.source_info_set.insert_full(source_info);\n+        self.bcx.set_srcloc(SourceLoc::new(index as u32));\n+    }\n+\n+    pub(crate) fn get_caller_location(&mut self, span: Span) -> CValue<'tcx> {\n+        if let Some(loc) = self.caller_location {\n+            // `#[track_caller]` is used; return caller location instead of current location.\n+            return loc;\n+        }\n+\n+        let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n+        let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n+        let const_loc = self.tcx.const_caller_location((\n+            rustc_span::symbol::Symbol::intern(&caller.file.name.to_string()),\n+            caller.line as u32,\n+            caller.col_display as u32 + 1,\n+        ));\n+        crate::constant::trans_const_value(self, const_loc, self.tcx.caller_location_ty())\n+    }\n+\n+    pub(crate) fn triple(&self) -> &target_lexicon::Triple {\n+        self.cx.module.isa().triple()\n+    }\n+\n+    pub(crate) fn anonymous_str(&mut self, prefix: &str, msg: &str) -> Value {\n+        use std::collections::hash_map::DefaultHasher;\n+        use std::hash::{Hash, Hasher};\n+\n+        let mut hasher = DefaultHasher::new();\n+        msg.hash(&mut hasher);\n+        let msg_hash = hasher.finish();\n+        let mut data_ctx = DataContext::new();\n+        data_ctx.define(msg.as_bytes().to_vec().into_boxed_slice());\n+        let msg_id = self\n+            .cx\n+            .module\n+            .declare_data(\n+                &format!(\"__{}_{:08x}\", prefix, msg_hash),\n+                Linkage::Local,\n+                false,\n+                false,\n+            )\n+            .unwrap();\n+\n+        // Ignore DuplicateDefinition error, as the data will be the same\n+        let _ = self.cx.module.define_data(msg_id, &data_ctx);\n+\n+        let local_msg_id = self.cx.module.declare_data_in_func(msg_id, self.bcx.func);\n+        #[cfg(debug_assertions)]\n+        {\n+            self.add_comment(local_msg_id, msg);\n+        }\n+        self.bcx.ins().global_value(self.pointer_type, local_msg_id)\n+    }\n+}"}, {"sha": "1b514958a4809dfec736410a8db1d98c38e2a4d6", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "added", "additions": 476, "deletions": 0, "changes": 476, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,476 @@\n+//! Handling of `static`s, `const`s and promoted allocations\n+\n+use rustc_span::DUMMY_SP;\n+\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::ErrorReported;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::mir::interpret::{\n+    read_target_uint, AllocId, Allocation, ConstValue, ErrorHandled, GlobalAlloc, Pointer, Scalar,\n+};\n+use rustc_middle::ty::{Const, ConstKind};\n+\n+use cranelift_codegen::ir::GlobalValueData;\n+use cranelift_module::*;\n+\n+use crate::prelude::*;\n+\n+#[derive(Default)]\n+pub(crate) struct ConstantCx {\n+    todo: Vec<TodoItem>,\n+    done: FxHashSet<DataId>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum TodoItem {\n+    Alloc(AllocId),\n+    Static(DefId),\n+}\n+\n+impl ConstantCx {\n+    pub(crate) fn finalize(mut self, tcx: TyCtxt<'_>, module: &mut impl Module) {\n+        //println!(\"todo {:?}\", self.todo);\n+        define_all_allocs(tcx, module, &mut self);\n+        //println!(\"done {:?}\", self.done);\n+        self.done.clear();\n+    }\n+}\n+\n+pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+    for constant in &fx.mir.required_consts {\n+        let const_ = fx.monomorphize(&constant.literal);\n+        match const_.val {\n+            ConstKind::Value(_) => {}\n+            ConstKind::Unevaluated(def, ref substs, promoted) => {\n+                if let Err(err) =\n+                    fx.tcx\n+                        .const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n+                {\n+                    match err {\n+                        ErrorHandled::Reported(ErrorReported) | ErrorHandled::Linted => {\n+                            fx.tcx\n+                                .sess\n+                                .span_err(constant.span, \"erroneous constant encountered\");\n+                        }\n+                        ErrorHandled::TooGeneric => {\n+                            span_bug!(\n+                                constant.span,\n+                                \"codgen encountered polymorphic constant: {:?}\",\n+                                err\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+            ConstKind::Param(_)\n+            | ConstKind::Infer(_)\n+            | ConstKind::Bound(_, _)\n+            | ConstKind::Placeholder(_)\n+            | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n+        }\n+    }\n+}\n+\n+pub(crate) fn codegen_static(constants_cx: &mut ConstantCx, def_id: DefId) {\n+    constants_cx.todo.push(TodoItem::Static(def_id));\n+}\n+\n+pub(crate) fn codegen_tls_ref<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    def_id: DefId,\n+    layout: TyAndLayout<'tcx>,\n+) -> CValue<'tcx> {\n+    let data_id = data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    #[cfg(debug_assertions)]\n+    fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n+    let tls_ptr = fx.bcx.ins().tls_value(fx.pointer_type, local_data_id);\n+    CValue::by_val(tls_ptr, layout)\n+}\n+\n+fn codegen_static_ref<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    def_id: DefId,\n+    layout: TyAndLayout<'tcx>,\n+) -> CPlace<'tcx> {\n+    let data_id = data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    #[cfg(debug_assertions)]\n+    fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+    let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n+    assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n+    assert!(\n+        matches!(fx.bcx.func.global_values[local_data_id], GlobalValueData::Symbol { tls: false, ..}),\n+        \"tls static referenced without Rvalue::ThreadLocalRef\"\n+    );\n+    CPlace::for_ptr(crate::pointer::Pointer::new(global_ptr), layout)\n+}\n+\n+pub(crate) fn trans_constant<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    constant: &Constant<'tcx>,\n+) -> CValue<'tcx> {\n+    let const_ = fx.monomorphize(&constant.literal);\n+    let const_val = match const_.val {\n+        ConstKind::Value(const_val) => const_val,\n+        ConstKind::Unevaluated(def, ref substs, promoted) if fx.tcx.is_static(def.did) => {\n+            assert!(substs.is_empty());\n+            assert!(promoted.is_none());\n+\n+            return codegen_static_ref(\n+                fx,\n+                def.did,\n+                fx.layout_of(fx.monomorphize(&constant.literal.ty)),\n+            )\n+            .to_cvalue(fx);\n+        }\n+        ConstKind::Unevaluated(def, ref substs, promoted) => {\n+            match fx\n+                .tcx\n+                .const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n+            {\n+                Ok(const_val) => const_val,\n+                Err(_) => {\n+                    if promoted.is_none() {\n+                        fx.tcx\n+                            .sess\n+                            .span_err(constant.span, \"erroneous constant encountered\");\n+                    }\n+                    return crate::trap::trap_unreachable_ret_value(\n+                        fx,\n+                        fx.layout_of(const_.ty),\n+                        \"erroneous constant encountered\",\n+                    );\n+                }\n+            }\n+        }\n+        ConstKind::Param(_)\n+        | ConstKind::Infer(_)\n+        | ConstKind::Bound(_, _)\n+        | ConstKind::Placeholder(_)\n+        | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n+    };\n+\n+    trans_const_value(fx, const_val, const_.ty)\n+}\n+\n+pub(crate) fn trans_const_value<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    const_val: ConstValue<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> CValue<'tcx> {\n+    let layout = fx.layout_of(ty);\n+    assert!(!layout.is_unsized(), \"sized const value\");\n+\n+    if layout.is_zst() {\n+        return CValue::by_ref(\n+            crate::Pointer::const_addr(fx, i64::try_from(layout.align.pref.bytes()).unwrap()),\n+            layout,\n+        );\n+    }\n+\n+    match const_val {\n+        ConstValue::Scalar(x) => {\n+            if fx.clif_type(layout.ty).is_none() {\n+                let (size, align) = (layout.size, layout.align.pref);\n+                let mut alloc = Allocation::from_bytes(\n+                    std::iter::repeat(0)\n+                        .take(size.bytes_usize())\n+                        .collect::<Vec<u8>>(),\n+                    align,\n+                );\n+                let ptr = Pointer::new(AllocId(!0), Size::ZERO); // The alloc id is never used\n+                alloc.write_scalar(fx, ptr, x.into(), size).unwrap();\n+                let alloc = fx.tcx.intern_const_alloc(alloc);\n+                return CValue::by_ref(pointer_for_allocation(fx, alloc), layout);\n+            }\n+\n+            match x {\n+                Scalar::Raw { data, size } => {\n+                    assert_eq!(u64::from(size), layout.size.bytes());\n+                    return CValue::const_val(fx, layout, data);\n+                }\n+                Scalar::Ptr(ptr) => {\n+                    let alloc_kind = fx.tcx.get_global_alloc(ptr.alloc_id);\n+                    let base_addr = match alloc_kind {\n+                        Some(GlobalAlloc::Memory(alloc)) => {\n+                            fx.cx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n+                            let data_id = data_id_for_alloc_id(\n+                                &mut fx.cx.module,\n+                                ptr.alloc_id,\n+                                alloc.mutability,\n+                            );\n+                            let local_data_id =\n+                                fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                            #[cfg(debug_assertions)]\n+                            fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n+                            fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n+                        }\n+                        Some(GlobalAlloc::Function(instance)) => {\n+                            let func_id =\n+                                crate::abi::import_function(fx.tcx, &mut fx.cx.module, instance);\n+                            let local_func_id =\n+                                fx.cx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n+                            fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n+                        }\n+                        Some(GlobalAlloc::Static(def_id)) => {\n+                            assert!(fx.tcx.is_static(def_id));\n+                            let data_id =\n+                                data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+                            let local_data_id =\n+                                fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                            #[cfg(debug_assertions)]\n+                            fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+                            fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n+                        }\n+                        None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n+                    };\n+                    let val = if ptr.offset.bytes() != 0 {\n+                        fx.bcx\n+                            .ins()\n+                            .iadd_imm(base_addr, i64::try_from(ptr.offset.bytes()).unwrap())\n+                    } else {\n+                        base_addr\n+                    };\n+                    return CValue::by_val(val, layout);\n+                }\n+            }\n+        }\n+        ConstValue::ByRef { alloc, offset } => CValue::by_ref(\n+            pointer_for_allocation(fx, alloc)\n+                .offset_i64(fx, i64::try_from(offset.bytes()).unwrap()),\n+            layout,\n+        ),\n+        ConstValue::Slice { data, start, end } => {\n+            let ptr = pointer_for_allocation(fx, data)\n+                .offset_i64(fx, i64::try_from(start).unwrap())\n+                .get_addr(fx);\n+            let len = fx.bcx.ins().iconst(\n+                fx.pointer_type,\n+                i64::try_from(end.checked_sub(start).unwrap()).unwrap(),\n+            );\n+            CValue::by_val_pair(ptr, len, layout)\n+        }\n+    }\n+}\n+\n+fn pointer_for_allocation<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    alloc: &'tcx Allocation,\n+) -> crate::pointer::Pointer {\n+    let alloc_id = fx.tcx.create_memory_alloc(alloc);\n+    fx.cx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n+    let data_id = data_id_for_alloc_id(&mut fx.cx.module, alloc_id, alloc.mutability);\n+\n+    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    #[cfg(debug_assertions)]\n+    fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n+    let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n+    crate::pointer::Pointer::new(global_ptr)\n+}\n+\n+fn data_id_for_alloc_id(\n+    module: &mut impl Module,\n+    alloc_id: AllocId,\n+    mutability: rustc_hir::Mutability,\n+) -> DataId {\n+    module\n+        .declare_data(\n+            &format!(\"__alloc_{:x}\", alloc_id.0),\n+            Linkage::Local,\n+            mutability == rustc_hir::Mutability::Mut,\n+            false,\n+        )\n+        .unwrap()\n+}\n+\n+fn data_id_for_static(\n+    tcx: TyCtxt<'_>,\n+    module: &mut impl Module,\n+    def_id: DefId,\n+    definition: bool,\n+) -> DataId {\n+    let rlinkage = tcx.codegen_fn_attrs(def_id).linkage;\n+    let linkage = if definition {\n+        crate::linkage::get_static_linkage(tcx, def_id)\n+    } else {\n+        if rlinkage == Some(rustc_middle::mir::mono::Linkage::ExternalWeak)\n+            || rlinkage == Some(rustc_middle::mir::mono::Linkage::WeakAny)\n+        {\n+            Linkage::Preemptible\n+        } else {\n+            Linkage::Import\n+        }\n+    };\n+\n+    let instance = Instance::mono(tcx, def_id).polymorphize(tcx);\n+    let symbol_name = tcx.symbol_name(instance).name;\n+    let ty = instance.ty(tcx, ParamEnv::reveal_all());\n+    let is_mutable = if tcx.is_mutable_static(def_id) {\n+        true\n+    } else {\n+        !ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all())\n+    };\n+    let align = tcx\n+        .layout_of(ParamEnv::reveal_all().and(ty))\n+        .unwrap()\n+        .align\n+        .pref\n+        .bytes();\n+\n+    let attrs = tcx.codegen_fn_attrs(def_id);\n+\n+    let data_id = module\n+        .declare_data(\n+            &*symbol_name,\n+            linkage,\n+            is_mutable,\n+            attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n+        )\n+        .unwrap();\n+\n+    if rlinkage.is_some() {\n+        // Comment copied from https://github.com/rust-lang/rust/blob/45060c2a66dfd667f88bd8b94261b28a58d85bd5/src/librustc_codegen_llvm/consts.rs#L141\n+        // Declare an internal global `extern_with_linkage_foo` which\n+        // is initialized with the address of `foo`.  If `foo` is\n+        // discarded during linking (for example, if `foo` has weak\n+        // linkage and there are no definitions), then\n+        // `extern_with_linkage_foo` will instead be initialized to\n+        // zero.\n+\n+        let ref_name = format!(\"_rust_extern_with_linkage_{}\", symbol_name);\n+        let ref_data_id = module\n+            .declare_data(&ref_name, Linkage::Local, false, false)\n+            .unwrap();\n+        let mut data_ctx = DataContext::new();\n+        data_ctx.set_align(align);\n+        let data = module.declare_data_in_data(data_id, &mut data_ctx);\n+        data_ctx.define(\n+            std::iter::repeat(0)\n+                .take(pointer_ty(tcx).bytes() as usize)\n+                .collect(),\n+        );\n+        data_ctx.write_data_addr(0, data, 0);\n+        match module.define_data(ref_data_id, &data_ctx) {\n+            // Every time the static is referenced there will be another definition of this global,\n+            // so duplicate definitions are expected and allowed.\n+            Err(ModuleError::DuplicateDefinition(_)) => {}\n+            res => res.unwrap(),\n+        }\n+        ref_data_id\n+    } else {\n+        data_id\n+    }\n+}\n+\n+fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut ConstantCx) {\n+    while let Some(todo_item) = cx.todo.pop() {\n+        let (data_id, alloc, section_name) = match todo_item {\n+            TodoItem::Alloc(alloc_id) => {\n+                //println!(\"alloc_id {}\", alloc_id);\n+                let alloc = match tcx.get_global_alloc(alloc_id).unwrap() {\n+                    GlobalAlloc::Memory(alloc) => alloc,\n+                    GlobalAlloc::Function(_) | GlobalAlloc::Static(_) => unreachable!(),\n+                };\n+                let data_id = data_id_for_alloc_id(module, alloc_id, alloc.mutability);\n+                (data_id, alloc, None)\n+            }\n+            TodoItem::Static(def_id) => {\n+                //println!(\"static {:?}\", def_id);\n+\n+                let section_name = tcx\n+                    .codegen_fn_attrs(def_id)\n+                    .link_section\n+                    .map(|s| s.as_str());\n+\n+                let alloc = tcx.eval_static_initializer(def_id).unwrap();\n+\n+                let data_id = data_id_for_static(tcx, module, def_id, true);\n+                (data_id, alloc, section_name)\n+            }\n+        };\n+\n+        //(\"data_id {}\", data_id);\n+        if cx.done.contains(&data_id) {\n+            continue;\n+        }\n+\n+        let mut data_ctx = DataContext::new();\n+        data_ctx.set_align(alloc.align.bytes());\n+\n+        if let Some(section_name) = section_name {\n+            // FIXME set correct segment for Mach-O files\n+            data_ctx.set_segment_section(\"\", &*section_name);\n+        }\n+\n+        let bytes = alloc\n+            .inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len())\n+            .to_vec();\n+        data_ctx.define(bytes.into_boxed_slice());\n+\n+        for &(offset, (_tag, reloc)) in alloc.relocations().iter() {\n+            let addend = {\n+                let endianness = tcx.data_layout.endian;\n+                let offset = offset.bytes() as usize;\n+                let ptr_size = tcx.data_layout.pointer_size;\n+                let bytes = &alloc.inspect_with_uninit_and_ptr_outside_interpreter(\n+                    offset..offset + ptr_size.bytes() as usize,\n+                );\n+                read_target_uint(endianness, bytes).unwrap()\n+            };\n+\n+            let reloc_target_alloc = tcx.get_global_alloc(reloc).unwrap();\n+            let data_id = match reloc_target_alloc {\n+                GlobalAlloc::Function(instance) => {\n+                    assert_eq!(addend, 0);\n+                    let func_id = crate::abi::import_function(tcx, module, instance);\n+                    let local_func_id = module.declare_func_in_data(func_id, &mut data_ctx);\n+                    data_ctx.write_function_addr(offset.bytes() as u32, local_func_id);\n+                    continue;\n+                }\n+                GlobalAlloc::Memory(target_alloc) => {\n+                    cx.todo.push(TodoItem::Alloc(reloc));\n+                    data_id_for_alloc_id(module, reloc, target_alloc.mutability)\n+                }\n+                GlobalAlloc::Static(def_id) => {\n+                    if tcx\n+                        .codegen_fn_attrs(def_id)\n+                        .flags\n+                        .contains(CodegenFnAttrFlags::THREAD_LOCAL)\n+                    {\n+                        tcx.sess.fatal(&format!(\n+                            \"Allocation {:?} contains reference to TLS value {:?}\",\n+                            alloc, def_id\n+                        ));\n+                    }\n+\n+                    // Don't push a `TodoItem::Static` here, as it will cause statics used by\n+                    // multiple crates to be duplicated between them. It isn't necessary anyway,\n+                    // as it will get pushed by `codegen_static` when necessary.\n+                    data_id_for_static(tcx, module, def_id, false)\n+                }\n+            };\n+\n+            let global_value = module.declare_data_in_data(data_id, &mut data_ctx);\n+            data_ctx.write_data_addr(offset.bytes() as u32, global_value, addend as i64);\n+        }\n+\n+        module.define_data(data_id, &data_ctx).unwrap();\n+        cx.done.insert(data_id);\n+    }\n+\n+    assert!(cx.todo.is_empty(), \"{:?}\", cx.todo);\n+}\n+\n+pub(crate) fn mir_operand_get_const_val<'tcx>(\n+    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    operand: &Operand<'tcx>,\n+) -> Option<&'tcx Const<'tcx>> {\n+    match operand {\n+        Operand::Copy(_) | Operand::Move(_) => None,\n+        Operand::Constant(const_) => Some(\n+            fx.monomorphize(&const_.literal)\n+                .eval(fx.tcx, ParamEnv::reveal_all()),\n+        ),\n+    }\n+}"}, {"sha": "cf8fee2b1d17ce7648fe2bed4a25597f1e37463a", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,204 @@\n+//! Write the debuginfo into an object file.\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n+use gimli::write::{Address, AttributeValue, EndianVec, Result, Sections, Writer};\n+use gimli::{RunTimeEndian, SectionId};\n+\n+use crate::backend::WriteDebugInfo;\n+\n+use super::DebugContext;\n+\n+impl DebugContext<'_> {\n+    pub(crate) fn emit<P: WriteDebugInfo>(&mut self, product: &mut P) {\n+        let unit_range_list_id = self.dwarf.unit.ranges.add(self.unit_range_list.clone());\n+        let root = self.dwarf.unit.root();\n+        let root = self.dwarf.unit.get_mut(root);\n+        root.set(\n+            gimli::DW_AT_ranges,\n+            AttributeValue::RangeListRef(unit_range_list_id),\n+        );\n+\n+        let mut sections = Sections::new(WriterRelocate::new(self.endian));\n+        self.dwarf.write(&mut sections).unwrap();\n+\n+        let mut section_map = FxHashMap::default();\n+        let _: Result<()> = sections.for_each_mut(|id, section| {\n+            if !section.writer.slice().is_empty() {\n+                let section_id = product.add_debug_section(id, section.writer.take());\n+                section_map.insert(id, section_id);\n+            }\n+            Ok(())\n+        });\n+\n+        let _: Result<()> = sections.for_each(|id, section| {\n+            if let Some(section_id) = section_map.get(&id) {\n+                for reloc in &section.relocs {\n+                    product.add_debug_reloc(&section_map, section_id, reloc);\n+                }\n+            }\n+            Ok(())\n+        });\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub(crate) struct DebugReloc {\n+    pub(crate) offset: u32,\n+    pub(crate) size: u8,\n+    pub(crate) name: DebugRelocName,\n+    pub(crate) addend: i64,\n+    pub(crate) kind: object::RelocationKind,\n+}\n+\n+#[derive(Clone)]\n+pub(crate) enum DebugRelocName {\n+    Section(SectionId),\n+    Symbol(usize),\n+}\n+\n+/// A [`Writer`] that collects all necessary relocations.\n+#[derive(Clone)]\n+pub(super) struct WriterRelocate {\n+    pub(super) relocs: Vec<DebugReloc>,\n+    pub(super) writer: EndianVec<RunTimeEndian>,\n+}\n+\n+impl WriterRelocate {\n+    pub(super) fn new(endian: RunTimeEndian) -> Self {\n+        WriterRelocate {\n+            relocs: Vec::new(),\n+            writer: EndianVec::new(endian),\n+        }\n+    }\n+\n+    /// Perform the collected relocations to be usable for JIT usage.\n+    #[cfg(feature = \"jit\")]\n+    pub(super) fn relocate_for_jit(\n+        mut self,\n+        jit_product: &cranelift_simplejit::SimpleJITProduct,\n+    ) -> Vec<u8> {\n+        use std::convert::TryInto;\n+\n+        for reloc in self.relocs.drain(..) {\n+            match reloc.name {\n+                super::DebugRelocName::Section(_) => unreachable!(),\n+                super::DebugRelocName::Symbol(sym) => {\n+                    let addr = jit_product\n+                        .lookup_func(cranelift_module::FuncId::from_u32(sym.try_into().unwrap()));\n+                    let val = (addr as u64 as i64 + reloc.addend) as u64;\n+                    self.writer\n+                        .write_udata_at(reloc.offset as usize, val, reloc.size)\n+                        .unwrap();\n+                }\n+            }\n+        }\n+        self.writer.into_vec()\n+    }\n+}\n+\n+impl Writer for WriterRelocate {\n+    type Endian = RunTimeEndian;\n+\n+    fn endian(&self) -> Self::Endian {\n+        self.writer.endian()\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.writer.len()\n+    }\n+\n+    fn write(&mut self, bytes: &[u8]) -> Result<()> {\n+        self.writer.write(bytes)\n+    }\n+\n+    fn write_at(&mut self, offset: usize, bytes: &[u8]) -> Result<()> {\n+        self.writer.write_at(offset, bytes)\n+    }\n+\n+    fn write_address(&mut self, address: Address, size: u8) -> Result<()> {\n+        match address {\n+            Address::Constant(val) => self.write_udata(val, size),\n+            Address::Symbol { symbol, addend } => {\n+                let offset = self.len() as u64;\n+                self.relocs.push(DebugReloc {\n+                    offset: offset as u32,\n+                    size,\n+                    name: DebugRelocName::Symbol(symbol),\n+                    addend: addend as i64,\n+                    kind: object::RelocationKind::Absolute,\n+                });\n+                self.write_udata(0, size)\n+            }\n+        }\n+    }\n+\n+    fn write_offset(&mut self, val: usize, section: SectionId, size: u8) -> Result<()> {\n+        let offset = self.len() as u32;\n+        self.relocs.push(DebugReloc {\n+            offset,\n+            size,\n+            name: DebugRelocName::Section(section),\n+            addend: val as i64,\n+            kind: object::RelocationKind::Absolute,\n+        });\n+        self.write_udata(0, size)\n+    }\n+\n+    fn write_offset_at(\n+        &mut self,\n+        offset: usize,\n+        val: usize,\n+        section: SectionId,\n+        size: u8,\n+    ) -> Result<()> {\n+        self.relocs.push(DebugReloc {\n+            offset: offset as u32,\n+            size,\n+            name: DebugRelocName::Section(section),\n+            addend: val as i64,\n+            kind: object::RelocationKind::Absolute,\n+        });\n+        self.write_udata_at(offset, 0, size)\n+    }\n+\n+    fn write_eh_pointer(&mut self, address: Address, eh_pe: gimli::DwEhPe, size: u8) -> Result<()> {\n+        match address {\n+            // Address::Constant arm copied from gimli\n+            Address::Constant(val) => {\n+                // Indirect doesn't matter here.\n+                let val = match eh_pe.application() {\n+                    gimli::DW_EH_PE_absptr => val,\n+                    gimli::DW_EH_PE_pcrel => {\n+                        // TODO: better handling of sign\n+                        let offset = self.len() as u64;\n+                        offset.wrapping_sub(val)\n+                    }\n+                    _ => {\n+                        return Err(gimli::write::Error::UnsupportedPointerEncoding(eh_pe));\n+                    }\n+                };\n+                self.write_eh_pointer_data(val, eh_pe.format(), size)\n+            }\n+            Address::Symbol { symbol, addend } => match eh_pe.application() {\n+                gimli::DW_EH_PE_pcrel => {\n+                    let size = match eh_pe.format() {\n+                        gimli::DW_EH_PE_sdata4 => 4,\n+                        _ => return Err(gimli::write::Error::UnsupportedPointerEncoding(eh_pe)),\n+                    };\n+                    self.relocs.push(DebugReloc {\n+                        offset: self.len() as u32,\n+                        size,\n+                        name: DebugRelocName::Symbol(symbol),\n+                        addend,\n+                        kind: object::RelocationKind::Relative,\n+                    });\n+                    self.write_udata(0, size)\n+                }\n+                _ => {\n+                    return Err(gimli::write::Error::UnsupportedPointerEncoding(eh_pe));\n+                }\n+            },\n+        }\n+    }\n+}"}, {"sha": "4de848553289603395fa8eee80cc50e7e5532223", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/line_info.rs", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,258 @@\n+//! Line info generation (`.debug_line`)\n+\n+use std::ffi::OsStr;\n+use std::path::{Component, Path};\n+\n+use crate::prelude::*;\n+\n+use rustc_span::{\n+    FileName, Pos, SourceFile, SourceFileAndLine, SourceFileHash, SourceFileHashAlgorithm,\n+};\n+\n+use cranelift_codegen::binemit::CodeOffset;\n+use cranelift_codegen::machinst::MachSrcLoc;\n+\n+use gimli::write::{\n+    Address, AttributeValue, FileId, FileInfo, LineProgram, LineString, LineStringTable,\n+    UnitEntryId,\n+};\n+\n+// OPTIMIZATION: It is cheaper to do this in one pass than using `.parent()` and `.file_name()`.\n+fn split_path_dir_and_file(path: &Path) -> (&Path, &OsStr) {\n+    let mut iter = path.components();\n+    let file_name = match iter.next_back() {\n+        Some(Component::Normal(p)) => p,\n+        component => {\n+            panic!(\n+                \"Path component {:?} of path {} is an invalid filename\",\n+                component,\n+                path.display()\n+            );\n+        }\n+    };\n+    let parent = iter.as_path();\n+    (parent, file_name)\n+}\n+\n+// OPTIMIZATION: Avoid UTF-8 validation on UNIX.\n+fn osstr_as_utf8_bytes(path: &OsStr) -> &[u8] {\n+    #[cfg(unix)]\n+    {\n+        use std::os::unix::ffi::OsStrExt;\n+        return path.as_bytes();\n+    }\n+    #[cfg(not(unix))]\n+    {\n+        return path.to_str().unwrap().as_bytes();\n+    }\n+}\n+\n+pub(crate) const MD5_LEN: usize = 16;\n+\n+pub fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n+    if hash.kind == SourceFileHashAlgorithm::Md5 {\n+        let mut buf = [0u8; MD5_LEN];\n+        buf.copy_from_slice(hash.hash_bytes());\n+        Some(FileInfo {\n+            timestamp: 0,\n+            size: 0,\n+            md5: buf,\n+        })\n+    } else {\n+        None\n+    }\n+}\n+\n+fn line_program_add_file(\n+    line_program: &mut LineProgram,\n+    line_strings: &mut LineStringTable,\n+    file: &SourceFile,\n+) -> FileId {\n+    match &file.name {\n+        FileName::Real(path) => {\n+            let (dir_path, file_name) = split_path_dir_and_file(path.stable_name());\n+            let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n+            let file_name = osstr_as_utf8_bytes(file_name);\n+\n+            let dir_id = if !dir_name.is_empty() {\n+                let dir_name = LineString::new(dir_name, line_program.encoding(), line_strings);\n+                line_program.add_directory(dir_name)\n+            } else {\n+                line_program.default_directory()\n+            };\n+            let file_name = LineString::new(file_name, line_program.encoding(), line_strings);\n+\n+            let info = make_file_info(file.src_hash);\n+\n+            line_program.file_has_md5 &= info.is_some();\n+            line_program.add_file(file_name, dir_id, info)\n+        }\n+        // FIXME give more appropriate file names\n+        filename => {\n+            let dir_id = line_program.default_directory();\n+            let dummy_file_name = LineString::new(\n+                filename.to_string().into_bytes(),\n+                line_program.encoding(),\n+                line_strings,\n+            );\n+            line_program.add_file(dummy_file_name, dir_id, None)\n+        }\n+    }\n+}\n+\n+impl<'tcx> DebugContext<'tcx> {\n+    pub(super) fn emit_location(&mut self, entry_id: UnitEntryId, span: Span) {\n+        let loc = self.tcx.sess.source_map().lookup_char_pos(span.lo());\n+\n+        let file_id = line_program_add_file(\n+            &mut self.dwarf.unit.line_program,\n+            &mut self.dwarf.line_strings,\n+            &loc.file,\n+        );\n+\n+        let entry = self.dwarf.unit.get_mut(entry_id);\n+\n+        entry.set(\n+            gimli::DW_AT_decl_file,\n+            AttributeValue::FileIndex(Some(file_id)),\n+        );\n+        entry.set(\n+            gimli::DW_AT_decl_line,\n+            AttributeValue::Udata(loc.line as u64),\n+        );\n+        // FIXME: probably omit this\n+        entry.set(\n+            gimli::DW_AT_decl_column,\n+            AttributeValue::Udata(loc.col.to_usize() as u64),\n+        );\n+    }\n+\n+    pub(super) fn create_debug_lines(\n+        &mut self,\n+        isa: &dyn cranelift_codegen::isa::TargetIsa,\n+        symbol: usize,\n+        entry_id: UnitEntryId,\n+        context: &Context,\n+        function_span: Span,\n+        source_info_set: &indexmap::IndexSet<SourceInfo>,\n+    ) -> CodeOffset {\n+        let tcx = self.tcx;\n+        let line_program = &mut self.dwarf.unit.line_program;\n+        let func = &context.func;\n+\n+        let line_strings = &mut self.dwarf.line_strings;\n+        let mut last_span = None;\n+        let mut last_file = None;\n+        let mut create_row_for_span = |line_program: &mut LineProgram, span: Span| {\n+            if let Some(last_span) = last_span {\n+                if span == last_span {\n+                    line_program.generate_row();\n+                    return;\n+                }\n+            }\n+            last_span = Some(span);\n+\n+            // Based on https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src/librustc_codegen_ssa/mir/mod.rs#L116-L131\n+            // In order to have a good line stepping behavior in debugger, we overwrite debug\n+            // locations of macro expansions with that of the outermost expansion site\n+            // (unless the crate is being compiled with `-Z debug-macros`).\n+            let span = if !span.from_expansion() || tcx.sess.opts.debugging_opts.debug_macros {\n+                span\n+            } else {\n+                // Walk up the macro expansion chain until we reach a non-expanded span.\n+                // We also stop at the function body level because no line stepping can occur\n+                // at the level above that.\n+                rustc_span::hygiene::walk_chain(span, function_span.ctxt())\n+            };\n+\n+            let (file, line, col) = match tcx.sess.source_map().lookup_line(span.lo()) {\n+                Ok(SourceFileAndLine { sf: file, line }) => {\n+                    let line_pos = file.line_begin_pos(span.lo());\n+\n+                    (\n+                        file,\n+                        u64::try_from(line).unwrap() + 1,\n+                        u64::from((span.lo() - line_pos).to_u32()) + 1,\n+                    )\n+                }\n+                Err(file) => (file, 0, 0),\n+            };\n+\n+            // line_program_add_file is very slow.\n+            // Optimize for the common case of the current file not being changed.\n+            let current_file_changed = if let Some(last_file) = &last_file {\n+                // If the allocations are not equal, then the files may still be equal, but that\n+                // is not a problem, as this is just an optimization.\n+                !rustc_data_structures::sync::Lrc::ptr_eq(last_file, &file)\n+            } else {\n+                true\n+            };\n+            if current_file_changed {\n+                let file_id = line_program_add_file(line_program, line_strings, &file);\n+                line_program.row().file = file_id;\n+                last_file = Some(file.clone());\n+            }\n+\n+            line_program.row().line = line;\n+            line_program.row().column = col;\n+            line_program.generate_row();\n+        };\n+\n+        line_program.begin_sequence(Some(Address::Symbol { symbol, addend: 0 }));\n+\n+        let mut func_end = 0;\n+\n+        if let Some(ref mcr) = &context.mach_compile_result {\n+            for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n+                line_program.row().address_offset = u64::from(start);\n+                if !loc.is_default() {\n+                    let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n+                    create_row_for_span(line_program, source_info.span);\n+                } else {\n+                    create_row_for_span(line_program, function_span);\n+                }\n+                func_end = end;\n+            }\n+\n+            line_program.end_sequence(u64::from(func_end));\n+\n+            func_end = mcr.buffer.total_size();\n+        } else {\n+            let encinfo = isa.encoding_info();\n+            let mut blocks = func.layout.blocks().collect::<Vec<_>>();\n+            blocks.sort_by_key(|block| func.offsets[*block]); // Ensure inst offsets always increase\n+\n+            for block in blocks {\n+                for (offset, inst, size) in func.inst_offsets(block, &encinfo) {\n+                    let srcloc = func.srclocs[inst];\n+                    line_program.row().address_offset = u64::from(offset);\n+                    if !srcloc.is_default() {\n+                        let source_info =\n+                            *source_info_set.get_index(srcloc.bits() as usize).unwrap();\n+                        create_row_for_span(line_program, source_info.span);\n+                    } else {\n+                        create_row_for_span(line_program, function_span);\n+                    }\n+                    func_end = offset + size;\n+                }\n+            }\n+            line_program.end_sequence(u64::from(func_end));\n+        }\n+\n+        assert_ne!(func_end, 0);\n+\n+        let entry = self.dwarf.unit.get_mut(entry_id);\n+        entry.set(\n+            gimli::DW_AT_low_pc,\n+            AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n+        );\n+        entry.set(\n+            gimli::DW_AT_high_pc,\n+            AttributeValue::Udata(u64::from(func_end)),\n+        );\n+\n+        self.emit_location(entry_id, function_span);\n+\n+        func_end\n+    }\n+}"}, {"sha": "cbf9522b1d774752e8ca40910bdd8fe26d28ba97", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "added", "additions": 487, "deletions": 0, "changes": 487, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,487 @@\n+//! Handling of everything related to debuginfo.\n+\n+mod emit;\n+mod line_info;\n+mod unwind;\n+\n+use crate::prelude::*;\n+\n+use rustc_index::vec::IndexVec;\n+\n+use cranelift_codegen::entity::EntityRef;\n+use cranelift_codegen::ir::{StackSlots, ValueLabel, ValueLoc};\n+use cranelift_codegen::isa::TargetIsa;\n+use cranelift_codegen::ValueLocRange;\n+\n+use gimli::write::{\n+    Address, AttributeValue, DwarfUnit, Expression, LineProgram, LineString, Location,\n+    LocationList, Range, RangeList, UnitEntryId,\n+};\n+use gimli::{Encoding, Format, LineEncoding, RunTimeEndian, X86_64};\n+\n+pub(crate) use emit::{DebugReloc, DebugRelocName};\n+pub(crate) use unwind::UnwindContext;\n+\n+fn target_endian(tcx: TyCtxt<'_>) -> RunTimeEndian {\n+    use rustc_target::abi::Endian;\n+\n+    match tcx.data_layout.endian {\n+        Endian::Big => RunTimeEndian::Big,\n+        Endian::Little => RunTimeEndian::Little,\n+    }\n+}\n+\n+pub(crate) struct DebugContext<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    endian: RunTimeEndian,\n+\n+    dwarf: DwarfUnit,\n+    unit_range_list: RangeList,\n+\n+    clif_types: FxHashMap<Type, UnitEntryId>,\n+    types: FxHashMap<Ty<'tcx>, UnitEntryId>,\n+}\n+\n+impl<'tcx> DebugContext<'tcx> {\n+    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa) -> Self {\n+        let encoding = Encoding {\n+            format: Format::Dwarf32,\n+            // TODO: this should be configurable\n+            // macOS doesn't seem to support DWARF > 3\n+            // 5 version is required for md5 file hash\n+            version: if tcx.sess.target.options.is_like_osx {\n+                3\n+            } else {\n+                // FIXME change to version 5 once the gdb and lldb shipping with the latest debian\n+                // support it.\n+                4\n+            },\n+            address_size: isa.frontend_config().pointer_bytes(),\n+        };\n+\n+        let mut dwarf = DwarfUnit::new(encoding);\n+\n+        // FIXME: how to get version when building out of tree?\n+        // Normally this would use option_env!(\"CFG_VERSION\").\n+        let producer = format!(\"cg_clif (rustc {})\", \"unknown version\");\n+        let comp_dir = tcx.sess.working_dir.0.to_string_lossy().into_owned();\n+        let (name, file_info) = match tcx.sess.local_crate_source_file.clone() {\n+            Some(path) => {\n+                let name = path.to_string_lossy().into_owned();\n+                (name, None)\n+            }\n+            None => (tcx.crate_name(LOCAL_CRATE).to_string(), None),\n+        };\n+\n+        let mut line_program = LineProgram::new(\n+            encoding,\n+            LineEncoding::default(),\n+            LineString::new(comp_dir.as_bytes(), encoding, &mut dwarf.line_strings),\n+            LineString::new(name.as_bytes(), encoding, &mut dwarf.line_strings),\n+            file_info,\n+        );\n+        line_program.file_has_md5 = file_info.is_some();\n+\n+        dwarf.unit.line_program = line_program;\n+\n+        {\n+            let name = dwarf.strings.add(name);\n+            let comp_dir = dwarf.strings.add(comp_dir);\n+\n+            let root = dwarf.unit.root();\n+            let root = dwarf.unit.get_mut(root);\n+            root.set(\n+                gimli::DW_AT_producer,\n+                AttributeValue::StringRef(dwarf.strings.add(producer)),\n+            );\n+            root.set(\n+                gimli::DW_AT_language,\n+                AttributeValue::Language(gimli::DW_LANG_Rust),\n+            );\n+            root.set(gimli::DW_AT_name, AttributeValue::StringRef(name));\n+            root.set(gimli::DW_AT_comp_dir, AttributeValue::StringRef(comp_dir));\n+            root.set(\n+                gimli::DW_AT_low_pc,\n+                AttributeValue::Address(Address::Constant(0)),\n+            );\n+        }\n+\n+        DebugContext {\n+            tcx,\n+\n+            endian: target_endian(tcx),\n+\n+            dwarf,\n+            unit_range_list: RangeList(Vec::new()),\n+\n+            clif_types: FxHashMap::default(),\n+            types: FxHashMap::default(),\n+        }\n+    }\n+\n+    fn dwarf_ty_for_clif_ty(&mut self, ty: Type) -> UnitEntryId {\n+        if let Some(type_id) = self.clif_types.get(&ty) {\n+            return *type_id;\n+        }\n+\n+        let new_entry = |dwarf: &mut DwarfUnit, tag| dwarf.unit.add(dwarf.unit.root(), tag);\n+\n+        let primitive = |dwarf: &mut DwarfUnit, ate| {\n+            let type_id = new_entry(dwarf, gimli::DW_TAG_base_type);\n+            let type_entry = dwarf.unit.get_mut(type_id);\n+            type_entry.set(gimli::DW_AT_encoding, AttributeValue::Encoding(ate));\n+            type_id\n+        };\n+\n+        let type_id = if ty.is_bool() {\n+            primitive(&mut self.dwarf, gimli::DW_ATE_boolean)\n+        } else if ty.is_int() {\n+            primitive(&mut self.dwarf, gimli::DW_ATE_address)\n+        } else if ty.is_float() {\n+            primitive(&mut self.dwarf, gimli::DW_ATE_float)\n+        } else {\n+            new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type)\n+        };\n+\n+        let type_entry = self.dwarf.unit.get_mut(type_id);\n+        type_entry.set(\n+            gimli::DW_AT_name,\n+            AttributeValue::String(format!(\"{}\", ty).replace('i', \"u\").into_bytes()),\n+        );\n+        type_entry.set(\n+            gimli::DW_AT_byte_size,\n+            AttributeValue::Udata(u64::from(ty.bytes())),\n+        );\n+\n+        type_id\n+    }\n+\n+    fn dwarf_ty(&mut self, ty: Ty<'tcx>) -> UnitEntryId {\n+        if let Some(type_id) = self.types.get(ty) {\n+            return *type_id;\n+        }\n+\n+        let new_entry = |dwarf: &mut DwarfUnit, tag| dwarf.unit.add(dwarf.unit.root(), tag);\n+\n+        let primitive = |dwarf: &mut DwarfUnit, ate| {\n+            let type_id = new_entry(dwarf, gimli::DW_TAG_base_type);\n+            let type_entry = dwarf.unit.get_mut(type_id);\n+            type_entry.set(gimli::DW_AT_encoding, AttributeValue::Encoding(ate));\n+            type_id\n+        };\n+\n+        let name = format!(\"{}\", ty);\n+        let layout = self.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n+\n+        let type_id = match ty.kind() {\n+            ty::Bool => primitive(&mut self.dwarf, gimli::DW_ATE_boolean),\n+            ty::Char => primitive(&mut self.dwarf, gimli::DW_ATE_UTF),\n+            ty::Uint(_) => primitive(&mut self.dwarf, gimli::DW_ATE_unsigned),\n+            ty::Int(_) => primitive(&mut self.dwarf, gimli::DW_ATE_signed),\n+            ty::Float(_) => primitive(&mut self.dwarf, gimli::DW_ATE_float),\n+            ty::Ref(_, pointee_ty, _mutbl)\n+            | ty::RawPtr(ty::TypeAndMut {\n+                ty: pointee_ty,\n+                mutbl: _mutbl,\n+            }) => {\n+                let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_pointer_type);\n+\n+                // Ensure that type is inserted before recursing to avoid duplicates\n+                self.types.insert(ty, type_id);\n+\n+                let pointee = self.dwarf_ty(pointee_ty);\n+\n+                let type_entry = self.dwarf.unit.get_mut(type_id);\n+\n+                //type_entry.set(gimli::DW_AT_mutable, AttributeValue::Flag(mutbl == rustc_hir::Mutability::Mut));\n+                type_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(pointee));\n+\n+                type_id\n+            }\n+            ty::Adt(adt_def, _substs) if adt_def.is_struct() && !layout.is_unsized() => {\n+                let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type);\n+\n+                // Ensure that type is inserted before recursing to avoid duplicates\n+                self.types.insert(ty, type_id);\n+\n+                let variant = adt_def.non_enum_variant();\n+\n+                for (field_idx, field_def) in variant.fields.iter().enumerate() {\n+                    let field_offset = layout.fields.offset(field_idx);\n+                    let field_layout = layout\n+                        .field(\n+                            &layout::LayoutCx {\n+                                tcx: self.tcx,\n+                                param_env: ParamEnv::reveal_all(),\n+                            },\n+                            field_idx,\n+                        )\n+                        .unwrap();\n+\n+                    let field_type = self.dwarf_ty(field_layout.ty);\n+\n+                    let field_id = self.dwarf.unit.add(type_id, gimli::DW_TAG_member);\n+                    let field_entry = self.dwarf.unit.get_mut(field_id);\n+\n+                    field_entry.set(\n+                        gimli::DW_AT_name,\n+                        AttributeValue::String(field_def.ident.as_str().to_string().into_bytes()),\n+                    );\n+                    field_entry.set(\n+                        gimli::DW_AT_data_member_location,\n+                        AttributeValue::Udata(field_offset.bytes()),\n+                    );\n+                    field_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(field_type));\n+                }\n+\n+                type_id\n+            }\n+            _ => new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type),\n+        };\n+\n+        let type_entry = self.dwarf.unit.get_mut(type_id);\n+\n+        type_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n+        type_entry.set(\n+            gimli::DW_AT_byte_size,\n+            AttributeValue::Udata(layout.size.bytes()),\n+        );\n+\n+        self.types.insert(ty, type_id);\n+\n+        type_id\n+    }\n+\n+    fn define_local(&mut self, scope: UnitEntryId, name: String, ty: Ty<'tcx>) -> UnitEntryId {\n+        let dw_ty = self.dwarf_ty(ty);\n+\n+        let var_id = self.dwarf.unit.add(scope, gimli::DW_TAG_variable);\n+        let var_entry = self.dwarf.unit.get_mut(var_id);\n+\n+        var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n+        var_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(dw_ty));\n+\n+        var_id\n+    }\n+\n+    pub(crate) fn define_function(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        func_id: FuncId,\n+        name: &str,\n+        isa: &dyn TargetIsa,\n+        context: &Context,\n+        source_info_set: &indexmap::IndexSet<SourceInfo>,\n+        local_map: IndexVec<mir::Local, CPlace<'tcx>>,\n+    ) {\n+        let symbol = func_id.as_u32() as usize;\n+        let mir = self.tcx.instance_mir(instance.def);\n+\n+        // FIXME: add to appropriate scope instead of root\n+        let scope = self.dwarf.unit.root();\n+\n+        let entry_id = self.dwarf.unit.add(scope, gimli::DW_TAG_subprogram);\n+        let entry = self.dwarf.unit.get_mut(entry_id);\n+        let name_id = self.dwarf.strings.add(name);\n+        // Gdb requires DW_AT_name. Otherwise the DW_TAG_subprogram is skipped.\n+        entry.set(gimli::DW_AT_name, AttributeValue::StringRef(name_id));\n+        entry.set(\n+            gimli::DW_AT_linkage_name,\n+            AttributeValue::StringRef(name_id),\n+        );\n+\n+        let end =\n+            self.create_debug_lines(isa, symbol, entry_id, context, mir.span, source_info_set);\n+\n+        self.unit_range_list.0.push(Range::StartLength {\n+            begin: Address::Symbol { symbol, addend: 0 },\n+            length: u64::from(end),\n+        });\n+\n+        if isa.get_mach_backend().is_some() {\n+            return; // Not yet implemented for the AArch64 backend.\n+        }\n+\n+        let func_entry = self.dwarf.unit.get_mut(entry_id);\n+        // Gdb requires both DW_AT_low_pc and DW_AT_high_pc. Otherwise the DW_TAG_subprogram is skipped.\n+        func_entry.set(\n+            gimli::DW_AT_low_pc,\n+            AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n+        );\n+        // Using Udata for DW_AT_high_pc requires at least DWARF4\n+        func_entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(end)));\n+\n+        // FIXME Remove once actual debuginfo for locals works.\n+        for (i, (param, &val)) in context\n+            .func\n+            .signature\n+            .params\n+            .iter()\n+            .zip(\n+                context\n+                    .func\n+                    .dfg\n+                    .block_params(context.func.layout.entry_block().unwrap()),\n+            )\n+            .enumerate()\n+        {\n+            use cranelift_codegen::ir::ArgumentPurpose;\n+            let base_name = match param.purpose {\n+                ArgumentPurpose::Normal => \"arg\",\n+                ArgumentPurpose::StructArgument(_) => \"struct_arg\",\n+                ArgumentPurpose::StructReturn => \"sret\",\n+                ArgumentPurpose::Link\n+                | ArgumentPurpose::FramePointer\n+                | ArgumentPurpose::CalleeSaved => continue,\n+                ArgumentPurpose::VMContext\n+                | ArgumentPurpose::SignatureId\n+                | ArgumentPurpose::CallerTLS\n+                | ArgumentPurpose::CalleeTLS\n+                | ArgumentPurpose::StackLimit => unreachable!(),\n+            };\n+            let name = format!(\"{}{}\", base_name, i);\n+\n+            let dw_ty = self.dwarf_ty_for_clif_ty(param.value_type);\n+            let loc =\n+                translate_loc(isa, context.func.locations[val], &context.func.stack_slots).unwrap();\n+\n+            let arg_id = self\n+                .dwarf\n+                .unit\n+                .add(entry_id, gimli::DW_TAG_formal_parameter);\n+            let var_entry = self.dwarf.unit.get_mut(arg_id);\n+\n+            var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n+            var_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(dw_ty));\n+            var_entry.set(gimli::DW_AT_location, AttributeValue::Exprloc(loc));\n+        }\n+\n+        // FIXME make it more reliable and implement scopes before re-enabling this.\n+        if false {\n+            let value_labels_ranges = context.build_value_labels_ranges(isa).unwrap();\n+\n+            for (local, _local_decl) in mir.local_decls.iter_enumerated() {\n+                let ty = self.tcx.subst_and_normalize_erasing_regions(\n+                    instance.substs,\n+                    ty::ParamEnv::reveal_all(),\n+                    &mir.local_decls[local].ty,\n+                );\n+                let var_id = self.define_local(entry_id, format!(\"{:?}\", local), ty);\n+\n+                let location = place_location(\n+                    self,\n+                    isa,\n+                    symbol,\n+                    context,\n+                    &local_map,\n+                    &value_labels_ranges,\n+                    Place {\n+                        local,\n+                        projection: ty::List::empty(),\n+                    },\n+                );\n+\n+                let var_entry = self.dwarf.unit.get_mut(var_id);\n+                var_entry.set(gimli::DW_AT_location, location);\n+            }\n+        }\n+\n+        // FIXME create locals for all entries in mir.var_debug_info\n+    }\n+}\n+\n+fn place_location<'tcx>(\n+    debug_context: &mut DebugContext<'tcx>,\n+    isa: &dyn TargetIsa,\n+    symbol: usize,\n+    context: &Context,\n+    local_map: &IndexVec<mir::Local, CPlace<'tcx>>,\n+    #[allow(rustc::default_hash_types)] value_labels_ranges: &std::collections::HashMap<\n+        ValueLabel,\n+        Vec<ValueLocRange>,\n+    >,\n+    place: Place<'tcx>,\n+) -> AttributeValue {\n+    assert!(place.projection.is_empty()); // FIXME implement them\n+\n+    match local_map[place.local].inner() {\n+        CPlaceInner::Var(_local, var) => {\n+            let value_label = cranelift_codegen::ir::ValueLabel::new(var.index());\n+            if let Some(value_loc_ranges) = value_labels_ranges.get(&value_label) {\n+                let loc_list = LocationList(\n+                    value_loc_ranges\n+                        .iter()\n+                        .map(|value_loc_range| Location::StartEnd {\n+                            begin: Address::Symbol {\n+                                symbol,\n+                                addend: i64::from(value_loc_range.start),\n+                            },\n+                            end: Address::Symbol {\n+                                symbol,\n+                                addend: i64::from(value_loc_range.end),\n+                            },\n+                            data: translate_loc(\n+                                isa,\n+                                value_loc_range.loc,\n+                                &context.func.stack_slots,\n+                            )\n+                            .unwrap(),\n+                        })\n+                        .collect(),\n+                );\n+                let loc_list_id = debug_context.dwarf.unit.locations.add(loc_list);\n+\n+                AttributeValue::LocationListRef(loc_list_id)\n+            } else {\n+                // FIXME set value labels for unused locals\n+\n+                AttributeValue::Exprloc(Expression::new())\n+            }\n+        }\n+        CPlaceInner::VarPair(_, _, _) => {\n+            // FIXME implement this\n+\n+            AttributeValue::Exprloc(Expression::new())\n+        }\n+        CPlaceInner::VarLane(_, _, _) => {\n+            // FIXME implement this\n+\n+            AttributeValue::Exprloc(Expression::new())\n+        }\n+        CPlaceInner::Addr(_, _) => {\n+            // FIXME implement this (used by arguments and returns)\n+\n+            AttributeValue::Exprloc(Expression::new())\n+\n+            // For PointerBase::Stack:\n+            //AttributeValue::Exprloc(translate_loc(ValueLoc::Stack(*stack_slot), &context.func.stack_slots).unwrap())\n+        }\n+    }\n+}\n+\n+// Adapted from https://github.com/CraneStation/wasmtime/blob/5a1845b4caf7a5dba8eda1fef05213a532ed4259/crates/debug/src/transform/expression.rs#L59-L137\n+fn translate_loc(\n+    isa: &dyn TargetIsa,\n+    loc: ValueLoc,\n+    stack_slots: &StackSlots,\n+) -> Option<Expression> {\n+    match loc {\n+        ValueLoc::Reg(reg) => {\n+            let machine_reg = isa.map_dwarf_register(reg).unwrap();\n+            let mut expr = Expression::new();\n+            expr.op_reg(gimli::Register(machine_reg));\n+            Some(expr)\n+        }\n+        ValueLoc::Stack(ss) => {\n+            if let Some(ss_offset) = stack_slots[ss].offset {\n+                let mut expr = Expression::new();\n+                expr.op_breg(X86_64::RBP, i64::from(ss_offset) + 16);\n+                Some(expr)\n+            } else {\n+                None\n+            }\n+        }\n+        _ => None,\n+    }\n+}"}, {"sha": "61ebd931d2f144e778a2d2158bcee3d39881bcca", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/unwind.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,167 @@\n+//! Unwind info generation (`.eh_frame`)\n+\n+use crate::prelude::*;\n+\n+use cranelift_codegen::isa::{unwind::UnwindInfo, TargetIsa};\n+\n+use gimli::write::{Address, CieId, EhFrame, FrameTable, Section};\n+\n+use crate::backend::WriteDebugInfo;\n+\n+pub(crate) struct UnwindContext<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    frame_table: FrameTable,\n+    cie_id: Option<CieId>,\n+}\n+\n+impl<'tcx> UnwindContext<'tcx> {\n+    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa) -> Self {\n+        let mut frame_table = FrameTable::default();\n+\n+        let cie_id = if let Some(mut cie) = isa.create_systemv_cie() {\n+            if isa.flags().is_pic() {\n+                cie.fde_address_encoding =\n+                    gimli::DwEhPe(gimli::DW_EH_PE_pcrel.0 | gimli::DW_EH_PE_sdata4.0);\n+            }\n+            Some(frame_table.add_cie(cie))\n+        } else {\n+            None\n+        };\n+\n+        UnwindContext {\n+            tcx,\n+            frame_table,\n+            cie_id,\n+        }\n+    }\n+\n+    pub(crate) fn add_function(&mut self, func_id: FuncId, context: &Context, isa: &dyn TargetIsa) {\n+        let unwind_info = if let Some(unwind_info) = context.create_unwind_info(isa).unwrap() {\n+            unwind_info\n+        } else {\n+            return;\n+        };\n+\n+        match unwind_info {\n+            UnwindInfo::SystemV(unwind_info) => {\n+                self.frame_table.add_fde(\n+                    self.cie_id.unwrap(),\n+                    unwind_info.to_fde(Address::Symbol {\n+                        symbol: func_id.as_u32() as usize,\n+                        addend: 0,\n+                    }),\n+                );\n+            }\n+            UnwindInfo::WindowsX64(_) => {\n+                // FIXME implement this\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn emit<P: WriteDebugInfo>(self, product: &mut P) {\n+        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n+            self.tcx,\n+        )));\n+        self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n+\n+        if !eh_frame.0.writer.slice().is_empty() {\n+            let id = eh_frame.id();\n+            let section_id = product.add_debug_section(id, eh_frame.0.writer.into_vec());\n+            let mut section_map = FxHashMap::default();\n+            section_map.insert(id, section_id);\n+\n+            for reloc in &eh_frame.0.relocs {\n+                product.add_debug_reloc(&section_map, &section_id, reloc);\n+            }\n+        }\n+    }\n+\n+    #[cfg(feature = \"jit\")]\n+    pub(crate) unsafe fn register_jit(\n+        self,\n+        jit_product: &cranelift_simplejit::SimpleJITProduct,\n+    ) -> Option<UnwindRegistry> {\n+        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n+            self.tcx,\n+        )));\n+        self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n+\n+        if eh_frame.0.writer.slice().is_empty() {\n+            return None;\n+        }\n+\n+        let mut eh_frame = eh_frame.0.relocate_for_jit(jit_product);\n+\n+        // GCC expects a terminating \"empty\" length, so write a 0 length at the end of the table.\n+        eh_frame.extend(&[0, 0, 0, 0]);\n+\n+        let mut registrations = Vec::new();\n+\n+        // =======================================================================\n+        // Everything after this line up to the end of the file is loosly based on\n+        // https://github.com/bytecodealliance/wasmtime/blob/4471a82b0c540ff48960eca6757ccce5b1b5c3e4/crates/jit/src/unwind/systemv.rs\n+        #[cfg(target_os = \"macos\")]\n+        {\n+            // On macOS, `__register_frame` takes a pointer to a single FDE\n+            let start = eh_frame.as_ptr();\n+            let end = start.add(eh_frame.len());\n+            let mut current = start;\n+\n+            // Walk all of the entries in the frame table and register them\n+            while current < end {\n+                let len = std::ptr::read::<u32>(current as *const u32) as usize;\n+\n+                // Skip over the CIE\n+                if current != start {\n+                    __register_frame(current);\n+                    registrations.push(current as usize);\n+                }\n+\n+                // Move to the next table entry (+4 because the length itself is not inclusive)\n+                current = current.add(len + 4);\n+            }\n+        }\n+        #[cfg(not(target_os = \"macos\"))]\n+        {\n+            // On other platforms, `__register_frame` will walk the FDEs until an entry of length 0\n+            let ptr = eh_frame.as_ptr();\n+            __register_frame(ptr);\n+            registrations.push(ptr as usize);\n+        }\n+\n+        Some(UnwindRegistry {\n+            _frame_table: eh_frame,\n+            registrations,\n+        })\n+    }\n+}\n+\n+/// Represents a registry of function unwind information for System V ABI.\n+pub(crate) struct UnwindRegistry {\n+    _frame_table: Vec<u8>,\n+    registrations: Vec<usize>,\n+}\n+\n+extern \"C\" {\n+    // libunwind import\n+    fn __register_frame(fde: *const u8);\n+    fn __deregister_frame(fde: *const u8);\n+}\n+\n+impl Drop for UnwindRegistry {\n+    fn drop(&mut self) {\n+        unsafe {\n+            // libgcc stores the frame entries as a linked list in decreasing sort order\n+            // based on the PC value of the registered entry.\n+            //\n+            // As we store the registrations in increasing order, it would be O(N^2) to\n+            // deregister in that order.\n+            //\n+            // To ensure that we just pop off the first element in the list upon every\n+            // deregistration, walk our list of registrations backwards.\n+            for fde in self.registrations.iter().rev() {\n+                __deregister_frame(*fde as *const _);\n+            }\n+        }\n+    }\n+}"}, {"sha": "d15bc36ad05ef211a09b71c73da79c7164daaee7", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,170 @@\n+//! Handling of enum discriminants\n+//!\n+//! Adapted from https://github.com/rust-lang/rust/blob/d760df5aea483aae041c9a241e7acacf48f75035/src/librustc_codegen_ssa/mir/place.rs\n+\n+use rustc_target::abi::{Int, TagEncoding, Variants};\n+\n+use crate::prelude::*;\n+\n+pub(crate) fn codegen_set_discriminant<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    place: CPlace<'tcx>,\n+    variant_index: VariantIdx,\n+) {\n+    let layout = place.layout();\n+    if layout.for_variant(fx, variant_index).abi.is_uninhabited() {\n+        return;\n+    }\n+    match layout.variants {\n+        Variants::Single { index } => {\n+            assert_eq!(index, variant_index);\n+        }\n+        Variants::Multiple {\n+            tag: _,\n+            tag_field,\n+            tag_encoding: TagEncoding::Direct,\n+            variants: _,\n+        } => {\n+            let ptr = place.place_field(fx, mir::Field::new(tag_field));\n+            let to = layout\n+                .ty\n+                .discriminant_for_variant(fx.tcx, variant_index)\n+                .unwrap()\n+                .val;\n+            let discr = CValue::const_val(fx, ptr.layout(), to);\n+            ptr.write_cvalue(fx, discr);\n+        }\n+        Variants::Multiple {\n+            tag: _,\n+            tag_field,\n+            tag_encoding:\n+                TagEncoding::Niche {\n+                    dataful_variant,\n+                    ref niche_variants,\n+                    niche_start,\n+                },\n+            variants: _,\n+        } => {\n+            if variant_index != dataful_variant {\n+                let niche = place.place_field(fx, mir::Field::new(tag_field));\n+                let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n+                let niche_value = u128::from(niche_value).wrapping_add(niche_start);\n+                let niche_llval = CValue::const_val(fx, niche.layout(), niche_value);\n+                niche.write_cvalue(fx, niche_llval);\n+            }\n+        }\n+    }\n+}\n+\n+pub(crate) fn codegen_get_discriminant<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    value: CValue<'tcx>,\n+    dest_layout: TyAndLayout<'tcx>,\n+) -> CValue<'tcx> {\n+    let layout = value.layout();\n+\n+    if layout.abi == Abi::Uninhabited {\n+        return trap_unreachable_ret_value(\n+            fx,\n+            dest_layout,\n+            \"[panic] Tried to get discriminant for uninhabited type.\",\n+        );\n+    }\n+\n+    let (tag_scalar, tag_field, tag_encoding) = match &layout.variants {\n+        Variants::Single { index } => {\n+            let discr_val = layout\n+                .ty\n+                .discriminant_for_variant(fx.tcx, *index)\n+                .map_or(u128::from(index.as_u32()), |discr| discr.val);\n+            return CValue::const_val(fx, dest_layout, discr_val);\n+        }\n+        Variants::Multiple {\n+            tag,\n+            tag_field,\n+            tag_encoding,\n+            variants: _,\n+        } => (tag, *tag_field, tag_encoding),\n+    };\n+\n+    let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n+\n+    // Read the tag/niche-encoded discriminant from memory.\n+    let tag = value.value_field(fx, mir::Field::new(tag_field));\n+    let tag = tag.load_scalar(fx);\n+\n+    // Decode the discriminant (specifically if it's niche-encoded).\n+    match *tag_encoding {\n+        TagEncoding::Direct => {\n+            let signed = match tag_scalar.value {\n+                Int(_, signed) => signed,\n+                _ => false,\n+            };\n+            let val = clif_intcast(fx, tag, cast_to, signed);\n+            CValue::by_val(val, dest_layout)\n+        }\n+        TagEncoding::Niche {\n+            dataful_variant,\n+            ref niche_variants,\n+            niche_start,\n+        } => {\n+            // Rebase from niche values to discriminants, and check\n+            // whether the result is in range for the niche variants.\n+\n+            // We first compute the \"relative discriminant\" (wrt `niche_variants`),\n+            // that is, if `n = niche_variants.end() - niche_variants.start()`,\n+            // we remap `niche_start..=niche_start + n` (which may wrap around)\n+            // to (non-wrap-around) `0..=n`, to be able to check whether the\n+            // discriminant corresponds to a niche variant with one comparison.\n+            // We also can't go directly to the (variant index) discriminant\n+            // and check that it is in the range `niche_variants`, because\n+            // that might not fit in the same type, on top of needing an extra\n+            // comparison (see also the comment on `let niche_discr`).\n+            let relative_discr = if niche_start == 0 {\n+                tag\n+            } else {\n+                // FIXME handle niche_start > i64::MAX\n+                fx.bcx\n+                    .ins()\n+                    .iadd_imm(tag, -i64::try_from(niche_start).unwrap())\n+            };\n+            let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n+            let is_niche = {\n+                codegen_icmp_imm(\n+                    fx,\n+                    IntCC::UnsignedLessThanOrEqual,\n+                    relative_discr,\n+                    i128::from(relative_max),\n+                )\n+            };\n+\n+            // NOTE(eddyb) this addition needs to be performed on the final\n+            // type, in case the niche itself can't represent all variant\n+            // indices (e.g. `u8` niche with more than `256` variants,\n+            // but enough uninhabited variants so that the remaining variants\n+            // fit in the niche).\n+            // In other words, `niche_variants.end - niche_variants.start`\n+            // is representable in the niche, but `niche_variants.end`\n+            // might not be, in extreme cases.\n+            let niche_discr = {\n+                let relative_discr = if relative_max == 0 {\n+                    // HACK(eddyb) since we have only one niche, we know which\n+                    // one it is, and we can avoid having a dynamic value here.\n+                    fx.bcx.ins().iconst(cast_to, 0)\n+                } else {\n+                    clif_intcast(fx, relative_discr, cast_to, false)\n+                };\n+                fx.bcx\n+                    .ins()\n+                    .iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n+            };\n+\n+            let dataful_variant = fx\n+                .bcx\n+                .ins()\n+                .iconst(cast_to, i64::from(dataful_variant.as_u32()));\n+            let discr = fx.bcx.ins().select(is_niche, niche_discr, dataful_variant);\n+            CValue::by_val(discr, dest_layout)\n+        }\n+    }\n+}"}, {"sha": "ff0b994c9a9f43950302313b310aefea92ed8c9d", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "added", "additions": 450, "deletions": 0, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,450 @@\n+//! The AOT driver uses [`cranelift_object`] to write object files suitable for linking into a\n+//! standalone executable.\n+\n+use std::path::PathBuf;\n+\n+use rustc_codegen_ssa::back::linker::LinkerInfo;\n+use rustc_codegen_ssa::{CodegenResults, CompiledModule, CrateInfo, ModuleKind};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n+use rustc_middle::middle::cstore::EncodedMetadata;\n+use rustc_middle::mir::mono::CodegenUnit;\n+use rustc_session::cgu_reuse_tracker::CguReuse;\n+use rustc_session::config::{DebugInfo, OutputType};\n+\n+use cranelift_object::{ObjectModule, ObjectProduct};\n+\n+use crate::prelude::*;\n+\n+use crate::backend::AddConstructor;\n+\n+fn new_module(tcx: TyCtxt<'_>, name: String) -> ObjectModule {\n+    let module = crate::backend::make_module(tcx.sess, name);\n+    assert_eq!(pointer_ty(tcx), module.target_config().pointer_type());\n+    module\n+}\n+\n+struct ModuleCodegenResult(CompiledModule, Option<(WorkProductId, WorkProduct)>);\n+\n+impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n+    fn hash_stable(&self, _: &mut HCX, _: &mut StableHasher) {\n+        // do nothing\n+    }\n+}\n+\n+fn emit_module(\n+    tcx: TyCtxt<'_>,\n+    name: String,\n+    kind: ModuleKind,\n+    module: ObjectModule,\n+    debug: Option<DebugContext<'_>>,\n+    unwind_context: UnwindContext<'_>,\n+    map_product: impl FnOnce(ObjectProduct) -> ObjectProduct,\n+) -> ModuleCodegenResult {\n+    let mut product = module.finish();\n+\n+    if let Some(mut debug) = debug {\n+        debug.emit(&mut product);\n+    }\n+\n+    unwind_context.emit(&mut product);\n+\n+    let product = map_product(product);\n+\n+    let tmp_file = tcx\n+        .output_filenames(LOCAL_CRATE)\n+        .temp_path(OutputType::Object, Some(&name));\n+    let obj = product.object.write().unwrap();\n+    if let Err(err) = std::fs::write(&tmp_file, obj) {\n+        tcx.sess\n+            .fatal(&format!(\"error writing object file: {}\", err));\n+    }\n+\n+    let work_product = if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() {\n+        None\n+    } else {\n+        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n+            tcx.sess,\n+            &name,\n+            &Some(tmp_file.clone()),\n+        )\n+    };\n+\n+    ModuleCodegenResult(\n+        CompiledModule {\n+            name,\n+            kind,\n+            object: Some(tmp_file),\n+            bytecode: None,\n+        },\n+        work_product,\n+    )\n+}\n+\n+fn reuse_workproduct_for_cgu(\n+    tcx: TyCtxt<'_>,\n+    cgu: &CodegenUnit<'_>,\n+    work_products: &mut FxHashMap<WorkProductId, WorkProduct>,\n+) -> CompiledModule {\n+    let incr_comp_session_dir = tcx.sess.incr_comp_session_dir();\n+    let mut object = None;\n+    let work_product = cgu.work_product(tcx);\n+    if let Some(saved_file) = &work_product.saved_file {\n+        let obj_out = tcx\n+            .output_filenames(LOCAL_CRATE)\n+            .temp_path(OutputType::Object, Some(&cgu.name().as_str()));\n+        object = Some(obj_out.clone());\n+        let source_file = rustc_incremental::in_incr_comp_dir(&incr_comp_session_dir, &saved_file);\n+        if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n+            tcx.sess.err(&format!(\n+                \"unable to copy {} to {}: {}\",\n+                source_file.display(),\n+                obj_out.display(),\n+                err\n+            ));\n+        }\n+    }\n+\n+    work_products.insert(cgu.work_product_id(), work_product);\n+\n+    CompiledModule {\n+        name: cgu.name().to_string(),\n+        kind: ModuleKind::Regular,\n+        object,\n+        bytecode: None,\n+    }\n+}\n+\n+fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodegenResult {\n+    let cgu = tcx.codegen_unit(cgu_name);\n+    let mono_items = cgu.items_in_deterministic_order(tcx);\n+\n+    let mut module = new_module(tcx, cgu_name.as_str().to_string());\n+\n+    // Initialize the global atomic mutex using a constructor for proc-macros.\n+    // FIXME implement atomic instructions in Cranelift.\n+    let mut init_atomics_mutex_from_constructor = None;\n+    if tcx\n+        .sess\n+        .crate_types()\n+        .contains(&rustc_session::config::CrateType::ProcMacro)\n+    {\n+        if mono_items.iter().any(|(mono_item, _)| match mono_item {\n+            rustc_middle::mir::mono::MonoItem::Static(def_id) => tcx\n+                .symbol_name(Instance::mono(tcx, *def_id))\n+                .name\n+                .contains(\"__rustc_proc_macro_decls_\"),\n+            _ => false,\n+        }) {\n+            init_atomics_mutex_from_constructor =\n+                Some(crate::atomic_shim::init_global_lock_constructor(\n+                    &mut module,\n+                    &format!(\"{}_init_atomics_mutex\", cgu_name.as_str()),\n+                ));\n+        }\n+    }\n+\n+    let mut cx = crate::CodegenCx::new(tcx, module, tcx.sess.opts.debuginfo != DebugInfo::None);\n+    super::codegen_mono_items(&mut cx, mono_items);\n+    let (mut module, global_asm, debug, mut unwind_context) =\n+        tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context, false);\n+\n+    let codegen_result = emit_module(\n+        tcx,\n+        cgu.name().as_str().to_string(),\n+        ModuleKind::Regular,\n+        module,\n+        debug,\n+        unwind_context,\n+        |mut product| {\n+            if let Some(func_id) = init_atomics_mutex_from_constructor {\n+                product.add_constructor(func_id);\n+            }\n+\n+            product\n+        },\n+    );\n+\n+    codegen_global_asm(tcx, &cgu.name().as_str(), &global_asm);\n+\n+    codegen_result\n+}\n+\n+pub(super) fn run_aot(\n+    tcx: TyCtxt<'_>,\n+    metadata: EncodedMetadata,\n+    need_metadata_module: bool,\n+) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n+    let mut work_products = FxHashMap::default();\n+\n+    let cgus = if tcx.sess.opts.output_types.should_codegen() {\n+        tcx.collect_and_partition_mono_items(LOCAL_CRATE).1\n+    } else {\n+        // If only `--emit metadata` is used, we shouldn't perform any codegen.\n+        // Also `tcx.collect_and_partition_mono_items` may panic in that case.\n+        &[]\n+    };\n+\n+    if tcx.dep_graph.is_fully_enabled() {\n+        for cgu in &*cgus {\n+            tcx.ensure().codegen_unit(cgu.name());\n+        }\n+    }\n+\n+    let modules = super::time(tcx, \"codegen mono items\", || {\n+        cgus.iter()\n+            .map(|cgu| {\n+                let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n+                tcx.sess\n+                    .cgu_reuse_tracker\n+                    .set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n+\n+                match cgu_reuse {\n+                    _ if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() => {}\n+                    CguReuse::No => {}\n+                    CguReuse::PreLto => {\n+                        return reuse_workproduct_for_cgu(tcx, &*cgu, &mut work_products);\n+                    }\n+                    CguReuse::PostLto => unreachable!(),\n+                }\n+\n+                let dep_node = cgu.codegen_dep_node(tcx);\n+                let (ModuleCodegenResult(module, work_product), _) = tcx.dep_graph.with_task(\n+                    dep_node,\n+                    tcx,\n+                    cgu.name(),\n+                    module_codegen,\n+                    rustc_middle::dep_graph::hash_result,\n+                );\n+\n+                if let Some((id, product)) = work_product {\n+                    work_products.insert(id, product);\n+                }\n+\n+                module\n+            })\n+            .collect::<Vec<_>>()\n+    });\n+\n+    tcx.sess.abort_if_errors();\n+\n+    let mut allocator_module = new_module(tcx, \"allocator_shim\".to_string());\n+    let mut allocator_unwind_context = UnwindContext::new(tcx, allocator_module.isa());\n+    let created_alloc_shim =\n+        crate::allocator::codegen(tcx, &mut allocator_module, &mut allocator_unwind_context);\n+\n+    let allocator_module = if created_alloc_shim {\n+        let ModuleCodegenResult(module, work_product) = emit_module(\n+            tcx,\n+            \"allocator_shim\".to_string(),\n+            ModuleKind::Allocator,\n+            allocator_module,\n+            None,\n+            allocator_unwind_context,\n+            |product| product,\n+        );\n+        if let Some((id, product)) = work_product {\n+            work_products.insert(id, product);\n+        }\n+        Some(module)\n+    } else {\n+        None\n+    };\n+\n+    rustc_incremental::assert_dep_graph(tcx);\n+    rustc_incremental::save_dep_graph(tcx);\n+\n+    let metadata_module = if need_metadata_module {\n+        let _timer = tcx.prof.generic_activity(\"codegen crate metadata\");\n+        let (metadata_cgu_name, tmp_file) = tcx.sess.time(\"write compressed metadata\", || {\n+            use rustc_middle::mir::mono::CodegenUnitNameBuilder;\n+\n+            let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+            let metadata_cgu_name = cgu_name_builder\n+                .build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"metadata\"))\n+                .as_str()\n+                .to_string();\n+\n+            let tmp_file = tcx\n+                .output_filenames(LOCAL_CRATE)\n+                .temp_path(OutputType::Metadata, Some(&metadata_cgu_name));\n+\n+            let obj = crate::backend::with_object(tcx.sess, &metadata_cgu_name, |object| {\n+                crate::metadata::write_metadata(tcx, object);\n+            });\n+\n+            if let Err(err) = std::fs::write(&tmp_file, obj) {\n+                tcx.sess\n+                    .fatal(&format!(\"error writing metadata object file: {}\", err));\n+            }\n+\n+            (metadata_cgu_name, tmp_file)\n+        });\n+\n+        Some(CompiledModule {\n+            name: metadata_cgu_name,\n+            kind: ModuleKind::Metadata,\n+            object: Some(tmp_file),\n+            bytecode: None,\n+        })\n+    } else {\n+        None\n+    };\n+\n+    if tcx.sess.opts.output_types.should_codegen() {\n+        rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n+    }\n+\n+    Box::new((\n+        CodegenResults {\n+            crate_name: tcx.crate_name(LOCAL_CRATE),\n+            modules,\n+            allocator_module,\n+            metadata_module,\n+            metadata,\n+            windows_subsystem: None, // Windows is not yet supported\n+            linker_info: LinkerInfo::new(tcx),\n+            crate_info: CrateInfo::new(tcx),\n+        },\n+        work_products,\n+    ))\n+}\n+\n+fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n+    use std::io::Write;\n+    use std::process::{Command, Stdio};\n+\n+    if global_asm.is_empty() {\n+        return;\n+    }\n+\n+    if cfg!(not(feature = \"inline_asm\"))\n+        || tcx.sess.target.options.is_like_osx\n+        || tcx.sess.target.options.is_like_windows\n+    {\n+        if global_asm.contains(\"__rust_probestack\") {\n+            return;\n+        }\n+\n+        // FIXME fix linker error on macOS\n+        if cfg!(not(feature = \"inline_asm\")) {\n+            tcx.sess.fatal(\n+                \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\",\n+            );\n+        } else {\n+            tcx.sess\n+                .fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n+        }\n+    }\n+\n+    let assembler = crate::toolchain::get_toolchain_binary(tcx.sess, \"as\");\n+    let linker = crate::toolchain::get_toolchain_binary(tcx.sess, \"ld\");\n+\n+    // Remove all LLVM style comments\n+    let global_asm = global_asm\n+        .lines()\n+        .map(|line| {\n+            if let Some(index) = line.find(\"//\") {\n+                &line[0..index]\n+            } else {\n+                line\n+            }\n+        })\n+        .collect::<Vec<_>>()\n+        .join(\"\\n\");\n+\n+    let output_object_file = tcx\n+        .output_filenames(LOCAL_CRATE)\n+        .temp_path(OutputType::Object, Some(cgu_name));\n+\n+    // Assemble `global_asm`\n+    let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n+    let mut child = Command::new(assembler)\n+        .arg(\"-o\")\n+        .arg(&global_asm_object_file)\n+        .stdin(Stdio::piped())\n+        .spawn()\n+        .expect(\"Failed to spawn `as`.\");\n+    child\n+        .stdin\n+        .take()\n+        .unwrap()\n+        .write_all(global_asm.as_bytes())\n+        .unwrap();\n+    let status = child.wait().expect(\"Failed to wait for `as`.\");\n+    if !status.success() {\n+        tcx.sess\n+            .fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n+    }\n+\n+    // Link the global asm and main object file together\n+    let main_object_file = add_file_stem_postfix(output_object_file.clone(), \".main\");\n+    std::fs::rename(&output_object_file, &main_object_file).unwrap();\n+    let status = Command::new(linker)\n+        .arg(\"-r\") // Create a new object file\n+        .arg(\"-o\")\n+        .arg(output_object_file)\n+        .arg(&main_object_file)\n+        .arg(&global_asm_object_file)\n+        .status()\n+        .unwrap();\n+    if !status.success() {\n+        tcx.sess.fatal(&format!(\n+            \"Failed to link `{}` and `{}` together\",\n+            main_object_file.display(),\n+            global_asm_object_file.display(),\n+        ));\n+    }\n+\n+    std::fs::remove_file(global_asm_object_file).unwrap();\n+    std::fs::remove_file(main_object_file).unwrap();\n+}\n+\n+fn add_file_stem_postfix(mut path: PathBuf, postfix: &str) -> PathBuf {\n+    let mut new_filename = path.file_stem().unwrap().to_owned();\n+    new_filename.push(postfix);\n+    if let Some(extension) = path.extension() {\n+        new_filename.push(\".\");\n+        new_filename.push(extension);\n+    }\n+    path.set_file_name(new_filename);\n+    path\n+}\n+\n+// Adapted from https://github.com/rust-lang/rust/blob/303d8aff6092709edd4dbd35b1c88e9aa40bf6d8/src/librustc_codegen_ssa/base.rs#L922-L953\n+fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguReuse {\n+    if !tcx.dep_graph.is_fully_enabled() {\n+        return CguReuse::No;\n+    }\n+\n+    let work_product_id = &cgu.work_product_id();\n+    if tcx\n+        .dep_graph\n+        .previous_work_product(work_product_id)\n+        .is_none()\n+    {\n+        // We don't have anything cached for this CGU. This can happen\n+        // if the CGU did not exist in the previous session.\n+        return CguReuse::No;\n+    }\n+\n+    // Try to mark the CGU as green. If it we can do so, it means that nothing\n+    // affecting the LLVM module has changed and we can re-use a cached version.\n+    // If we compile with any kind of LTO, this means we can re-use the bitcode\n+    // of the Pre-LTO stage (possibly also the Post-LTO version but we'll only\n+    // know that later). If we are not doing LTO, there is only one optimized\n+    // version of each module, so we re-use that.\n+    let dep_node = cgu.codegen_dep_node(tcx);\n+    assert!(\n+        !tcx.dep_graph.dep_node_exists(&dep_node),\n+        \"CompileCodegenUnit dep-node for CGU `{}` already exists before marking.\",\n+        cgu.name()\n+    );\n+\n+    if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n+        CguReuse::PreLto\n+    } else {\n+        CguReuse::No\n+    }\n+}"}, {"sha": "b5bab3d9e1ed10114636d2b7f754222b90b9b160", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,169 @@\n+//! The JIT driver uses [`cranelift_simplejit`] to JIT execute programs without writing any object\n+//! files.\n+\n+use std::ffi::CString;\n+use std::os::raw::{c_char, c_int};\n+\n+use rustc_codegen_ssa::CrateInfo;\n+\n+use cranelift_simplejit::{SimpleJITBuilder, SimpleJITModule};\n+\n+use crate::prelude::*;\n+\n+pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n+    if !tcx.sess.opts.output_types.should_codegen() {\n+        tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`.\");\n+    }\n+\n+    #[cfg(unix)]\n+    unsafe {\n+        // When not using our custom driver rustc will open us without the RTLD_GLOBAL flag, so\n+        // __cg_clif_global_atomic_mutex will not be exported. We fix this by opening ourself again\n+        // as global.\n+        // FIXME remove once atomic_shim is gone\n+\n+        let mut dl_info: libc::Dl_info = std::mem::zeroed();\n+        assert_ne!(\n+            libc::dladdr(run_jit as *const libc::c_void, &mut dl_info),\n+            0\n+        );\n+        assert_ne!(\n+            libc::dlopen(dl_info.dli_fname, libc::RTLD_NOW | libc::RTLD_GLOBAL),\n+            std::ptr::null_mut(),\n+        );\n+    }\n+\n+    let imported_symbols = load_imported_symbols_for_jit(tcx);\n+\n+    let mut jit_builder = SimpleJITBuilder::with_isa(\n+        crate::build_isa(tcx.sess, false),\n+        cranelift_module::default_libcall_names(),\n+    );\n+    jit_builder.symbols(imported_symbols);\n+    let mut jit_module = SimpleJITModule::new(jit_builder);\n+    assert_eq!(pointer_ty(tcx), jit_module.target_config().pointer_type());\n+\n+    let sig = Signature {\n+        params: vec![\n+            AbiParam::new(jit_module.target_config().pointer_type()),\n+            AbiParam::new(jit_module.target_config().pointer_type()),\n+        ],\n+        returns: vec![AbiParam::new(\n+            jit_module.target_config().pointer_type(), /*isize*/\n+        )],\n+        call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n+    };\n+    let main_func_id = jit_module\n+        .declare_function(\"main\", Linkage::Import, &sig)\n+        .unwrap();\n+\n+    let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n+    let mono_items = cgus\n+        .iter()\n+        .map(|cgu| cgu.items_in_deterministic_order(tcx).into_iter())\n+        .flatten()\n+        .collect::<FxHashMap<_, (_, _)>>()\n+        .into_iter()\n+        .collect::<Vec<(_, (_, _))>>();\n+\n+    let mut cx = crate::CodegenCx::new(tcx, jit_module, false);\n+\n+    let (mut jit_module, global_asm, _debug, mut unwind_context) =\n+        super::time(tcx, \"codegen mono items\", || {\n+            super::codegen_mono_items(&mut cx, mono_items);\n+            tcx.sess.time(\"finalize CodegenCx\", || cx.finalize())\n+        });\n+    if !global_asm.is_empty() {\n+        tcx.sess.fatal(\"Global asm is not supported in JIT mode\");\n+    }\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context, true);\n+    crate::allocator::codegen(tcx, &mut jit_module, &mut unwind_context);\n+\n+    tcx.sess.abort_if_errors();\n+\n+    let jit_product = jit_module.finish();\n+\n+    let _unwind_register_guard = unsafe { unwind_context.register_jit(&jit_product) };\n+\n+    let finalized_main: *const u8 = jit_product.lookup_func(main_func_id);\n+\n+    println!(\"Rustc codegen cranelift will JIT run the executable, because --jit was passed\");\n+\n+    let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n+        unsafe { ::std::mem::transmute(finalized_main) };\n+\n+    let args = ::std::env::var(\"CG_CLIF_JIT_ARGS\").unwrap_or_else(|_| String::new());\n+    let args = std::iter::once(&*tcx.crate_name(LOCAL_CRATE).as_str().to_string())\n+        .chain(args.split(\" \"))\n+        .map(|arg| CString::new(arg).unwrap())\n+        .collect::<Vec<_>>();\n+    let mut argv = args.iter().map(|arg| arg.as_ptr()).collect::<Vec<_>>();\n+\n+    // Push a null pointer as a terminating argument. This is required by POSIX and\n+    // useful as some dynamic linkers use it as a marker to jump over.\n+    argv.push(std::ptr::null());\n+\n+    let ret = f(args.len() as c_int, argv.as_ptr());\n+\n+    std::process::exit(ret);\n+}\n+\n+fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n+    use rustc_middle::middle::dependency_format::Linkage;\n+\n+    let mut dylib_paths = Vec::new();\n+\n+    let crate_info = CrateInfo::new(tcx);\n+    let formats = tcx.dependency_formats(LOCAL_CRATE);\n+    let data = &formats\n+        .iter()\n+        .find(|(crate_type, _data)| *crate_type == rustc_session::config::CrateType::Executable)\n+        .unwrap()\n+        .1;\n+    for &(cnum, _) in &crate_info.used_crates_dynamic {\n+        let src = &crate_info.used_crate_source[&cnum];\n+        match data[cnum.as_usize() - 1] {\n+            Linkage::NotLinked | Linkage::IncludedFromDylib => {}\n+            Linkage::Static => {\n+                let name = tcx.crate_name(cnum);\n+                let mut err = tcx\n+                    .sess\n+                    .struct_err(&format!(\"Can't load static lib {}\", name.as_str()));\n+                err.note(\"rustc_codegen_cranelift can only load dylibs in JIT mode.\");\n+                err.emit();\n+            }\n+            Linkage::Dynamic => {\n+                dylib_paths.push(src.dylib.as_ref().unwrap().0.clone());\n+            }\n+        }\n+    }\n+\n+    let mut imported_symbols = Vec::new();\n+    for path in dylib_paths {\n+        use object::Object;\n+        let lib = libloading::Library::new(&path).unwrap();\n+        let obj = std::fs::read(path).unwrap();\n+        let obj = object::File::parse(&obj).unwrap();\n+        imported_symbols.extend(obj.dynamic_symbols().filter_map(|(_idx, symbol)| {\n+            let name = symbol.name().unwrap().to_string();\n+            if name.is_empty() || !symbol.is_global() || symbol.is_undefined() {\n+                return None;\n+            }\n+            let dlsym_name = if cfg!(target_os = \"macos\") {\n+                // On macOS `dlsym` expects the name without leading `_`.\n+                assert!(name.starts_with(\"_\"), \"{:?}\", name);\n+                &name[1..]\n+            } else {\n+                &name\n+            };\n+            let symbol: libloading::Symbol<'_, *const u8> =\n+                unsafe { lib.get(dlsym_name.as_bytes()) }.unwrap();\n+            Some((name, *symbol))\n+        }));\n+        std::mem::forget(lib)\n+    }\n+\n+    tcx.sess.abort_if_errors();\n+\n+    imported_symbols\n+}"}, {"sha": "2fb353ca1628a314da40ef23bfcf016677160793", "filename": "compiler/rustc_codegen_cranelift/src/driver/mod.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,120 @@\n+//! Drivers are responsible for calling [`codegen_mono_items`] and performing any further actions\n+//! like JIT executing or writing object files.\n+\n+use std::any::Any;\n+\n+use rustc_middle::middle::cstore::EncodedMetadata;\n+use rustc_middle::mir::mono::{Linkage as RLinkage, MonoItem, Visibility};\n+\n+use crate::prelude::*;\n+\n+mod aot;\n+#[cfg(feature = \"jit\")]\n+mod jit;\n+\n+pub(crate) fn codegen_crate(\n+    tcx: TyCtxt<'_>,\n+    metadata: EncodedMetadata,\n+    need_metadata_module: bool,\n+    config: crate::BackendConfig,\n+) -> Box<dyn Any> {\n+    tcx.sess.abort_if_errors();\n+\n+    if config.use_jit {\n+        let is_executable = tcx\n+            .sess\n+            .crate_types()\n+            .contains(&rustc_session::config::CrateType::Executable);\n+        if !is_executable {\n+            tcx.sess.fatal(\"can't jit non-executable crate\");\n+        }\n+\n+        #[cfg(feature = \"jit\")]\n+        let _: ! = jit::run_jit(tcx);\n+\n+        #[cfg(not(feature = \"jit\"))]\n+        tcx.sess\n+            .fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+    }\n+\n+    aot::run_aot(tcx, metadata, need_metadata_module)\n+}\n+\n+fn codegen_mono_items<'tcx>(\n+    cx: &mut crate::CodegenCx<'tcx, impl Module>,\n+    mono_items: Vec<(MonoItem<'tcx>, (RLinkage, Visibility))>,\n+) {\n+    cx.tcx.sess.time(\"predefine functions\", || {\n+        for &(mono_item, (linkage, visibility)) in &mono_items {\n+            match mono_item {\n+                MonoItem::Fn(instance) => {\n+                    let (name, sig) = get_function_name_and_sig(\n+                        cx.tcx,\n+                        cx.module.isa().triple(),\n+                        instance,\n+                        false,\n+                    );\n+                    let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n+                    cx.module.declare_function(&name, linkage, &sig).unwrap();\n+                }\n+                MonoItem::Static(_) | MonoItem::GlobalAsm(_) => {}\n+            }\n+        }\n+    });\n+\n+    for (mono_item, (linkage, visibility)) in mono_items {\n+        let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n+        trans_mono_item(cx, mono_item, linkage);\n+    }\n+}\n+\n+fn trans_mono_item<'tcx, M: Module>(\n+    cx: &mut crate::CodegenCx<'tcx, M>,\n+    mono_item: MonoItem<'tcx>,\n+    linkage: Linkage,\n+) {\n+    let tcx = cx.tcx;\n+    match mono_item {\n+        MonoItem::Fn(inst) => {\n+            let _inst_guard =\n+                crate::PrintOnPanic(|| format!(\"{:?} {}\", inst, tcx.symbol_name(inst).name));\n+            debug_assert!(!inst.substs.needs_infer());\n+            tcx.sess\n+                .time(\"codegen fn\", || crate::base::trans_fn(cx, inst, linkage));\n+        }\n+        MonoItem::Static(def_id) => {\n+            crate::constant::codegen_static(&mut cx.constants_cx, def_id);\n+        }\n+        MonoItem::GlobalAsm(hir_id) => {\n+            let item = tcx.hir().expect_item(hir_id);\n+            if let rustc_hir::ItemKind::GlobalAsm(rustc_hir::GlobalAsm { asm }) = item.kind {\n+                cx.global_asm.push_str(&*asm.as_str());\n+                cx.global_asm.push_str(\"\\n\\n\");\n+            } else {\n+                bug!(\"Expected GlobalAsm found {:?}\", item);\n+            }\n+        }\n+    }\n+}\n+\n+fn time<R>(tcx: TyCtxt<'_>, name: &'static str, f: impl FnOnce() -> R) -> R {\n+    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\")\n+        .as_ref()\n+        .map(|val| &**val)\n+        == Ok(\"1\")\n+    {\n+        println!(\"[{:<30}: {}] start\", tcx.crate_name(LOCAL_CRATE), name);\n+        let before = std::time::Instant::now();\n+        let res = tcx.sess.time(name, f);\n+        let after = std::time::Instant::now();\n+        println!(\n+            \"[{:<30}: {}] end time: {:?}\",\n+            tcx.crate_name(LOCAL_CRATE),\n+            name,\n+            after - before\n+        );\n+        res\n+    } else {\n+        tcx.sess.time(name, f)\n+    }\n+}"}, {"sha": "aa2edb2dfd4f7231ddfe99a0370742a64a3654c1", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,293 @@\n+//! Codegen of [`asm!`] invocations.\n+\n+use crate::prelude::*;\n+\n+use std::fmt::Write;\n+\n+use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_middle::mir::InlineAsmOperand;\n+use rustc_target::asm::*;\n+\n+pub(crate) fn codegen_inline_asm<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    _span: Span,\n+    template: &[InlineAsmTemplatePiece],\n+    operands: &[InlineAsmOperand<'tcx>],\n+    options: InlineAsmOptions,\n+) {\n+    // FIXME add .eh_frame unwind info directives\n+\n+    if template.is_empty() {\n+        // Black box\n+        return;\n+    }\n+\n+    let mut slot_size = Size::from_bytes(0);\n+    let mut clobbered_regs = Vec::new();\n+    let mut inputs = Vec::new();\n+    let mut outputs = Vec::new();\n+\n+    let mut new_slot = |reg_class: InlineAsmRegClass| {\n+        let reg_size = reg_class\n+            .supported_types(InlineAsmArch::X86_64)\n+            .iter()\n+            .map(|(ty, _)| ty.size())\n+            .max()\n+            .unwrap();\n+        let align = rustc_target::abi::Align::from_bytes(reg_size.bytes()).unwrap();\n+        slot_size = slot_size.align_to(align);\n+        let offset = slot_size;\n+        slot_size += reg_size;\n+        offset\n+    };\n+\n+    // FIXME overlap input and output slots to save stack space\n+    for operand in operands {\n+        match *operand {\n+            InlineAsmOperand::In { reg, ref value } => {\n+                let reg = expect_reg(reg);\n+                clobbered_regs.push((reg, new_slot(reg.reg_class())));\n+                inputs.push((\n+                    reg,\n+                    new_slot(reg.reg_class()),\n+                    crate::base::trans_operand(fx, value).load_scalar(fx),\n+                ));\n+            }\n+            InlineAsmOperand::Out {\n+                reg,\n+                late: _,\n+                place,\n+            } => {\n+                let reg = expect_reg(reg);\n+                clobbered_regs.push((reg, new_slot(reg.reg_class())));\n+                if let Some(place) = place {\n+                    outputs.push((\n+                        reg,\n+                        new_slot(reg.reg_class()),\n+                        crate::base::trans_place(fx, place),\n+                    ));\n+                }\n+            }\n+            InlineAsmOperand::InOut {\n+                reg,\n+                late: _,\n+                ref in_value,\n+                out_place,\n+            } => {\n+                let reg = expect_reg(reg);\n+                clobbered_regs.push((reg, new_slot(reg.reg_class())));\n+                inputs.push((\n+                    reg,\n+                    new_slot(reg.reg_class()),\n+                    crate::base::trans_operand(fx, in_value).load_scalar(fx),\n+                ));\n+                if let Some(out_place) = out_place {\n+                    outputs.push((\n+                        reg,\n+                        new_slot(reg.reg_class()),\n+                        crate::base::trans_place(fx, out_place),\n+                    ));\n+                }\n+            }\n+            InlineAsmOperand::Const { value: _ } => todo!(),\n+            InlineAsmOperand::SymFn { value: _ } => todo!(),\n+            InlineAsmOperand::SymStatic { def_id: _ } => todo!(),\n+        }\n+    }\n+\n+    let inline_asm_index = fx.inline_asm_index;\n+    fx.inline_asm_index += 1;\n+    let asm_name = format!(\n+        \"{}__inline_asm_{}\",\n+        fx.tcx.symbol_name(fx.instance).name,\n+        inline_asm_index\n+    );\n+\n+    let generated_asm = generate_asm_wrapper(\n+        &asm_name,\n+        InlineAsmArch::X86_64,\n+        options,\n+        template,\n+        clobbered_regs,\n+        &inputs,\n+        &outputs,\n+    );\n+    fx.cx.global_asm.push_str(&generated_asm);\n+\n+    call_inline_asm(fx, &asm_name, slot_size, inputs, outputs);\n+}\n+\n+fn generate_asm_wrapper(\n+    asm_name: &str,\n+    arch: InlineAsmArch,\n+    options: InlineAsmOptions,\n+    template: &[InlineAsmTemplatePiece],\n+    clobbered_regs: Vec<(InlineAsmReg, Size)>,\n+    inputs: &[(InlineAsmReg, Size, Value)],\n+    outputs: &[(InlineAsmReg, Size, CPlace<'_>)],\n+) -> String {\n+    let mut generated_asm = String::new();\n+    writeln!(generated_asm, \".globl {}\", asm_name).unwrap();\n+    writeln!(generated_asm, \".type {},@function\", asm_name).unwrap();\n+    writeln!(\n+        generated_asm,\n+        \".section .text.{},\\\"ax\\\",@progbits\",\n+        asm_name\n+    )\n+    .unwrap();\n+    writeln!(generated_asm, \"{}:\", asm_name).unwrap();\n+\n+    generated_asm.push_str(\".intel_syntax noprefix\\n\");\n+    generated_asm.push_str(\"    push rbp\\n\");\n+    generated_asm.push_str(\"    mov rbp,rdi\\n\");\n+\n+    // Save clobbered registers\n+    if !options.contains(InlineAsmOptions::NORETURN) {\n+        // FIXME skip registers saved by the calling convention\n+        for &(reg, offset) in &clobbered_regs {\n+            save_register(&mut generated_asm, arch, reg, offset);\n+        }\n+    }\n+\n+    // Write input registers\n+    for &(reg, offset, _value) in inputs {\n+        restore_register(&mut generated_asm, arch, reg, offset);\n+    }\n+\n+    if options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+        generated_asm.push_str(\".att_syntax\\n\");\n+    }\n+\n+    // The actual inline asm\n+    for piece in template {\n+        match piece {\n+            InlineAsmTemplatePiece::String(s) => {\n+                generated_asm.push_str(s);\n+            }\n+            InlineAsmTemplatePiece::Placeholder {\n+                operand_idx: _,\n+                modifier: _,\n+                span: _,\n+            } => todo!(),\n+        }\n+    }\n+    generated_asm.push('\\n');\n+\n+    if options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+        generated_asm.push_str(\".intel_syntax noprefix\\n\");\n+    }\n+\n+    if !options.contains(InlineAsmOptions::NORETURN) {\n+        // Read output registers\n+        for &(reg, offset, _place) in outputs {\n+            save_register(&mut generated_asm, arch, reg, offset);\n+        }\n+\n+        // Restore clobbered registers\n+        for &(reg, offset) in clobbered_regs.iter().rev() {\n+            restore_register(&mut generated_asm, arch, reg, offset);\n+        }\n+\n+        generated_asm.push_str(\"    pop rbp\\n\");\n+        generated_asm.push_str(\"    ret\\n\");\n+    } else {\n+        generated_asm.push_str(\"    ud2\\n\");\n+    }\n+\n+    generated_asm.push_str(\".att_syntax\\n\");\n+    writeln!(generated_asm, \".size {name}, .-{name}\", name = asm_name).unwrap();\n+    generated_asm.push_str(\".text\\n\");\n+    generated_asm.push_str(\"\\n\\n\");\n+\n+    generated_asm\n+}\n+\n+fn call_inline_asm<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    asm_name: &str,\n+    slot_size: Size,\n+    inputs: Vec<(InlineAsmReg, Size, Value)>,\n+    outputs: Vec<(InlineAsmReg, Size, CPlace<'tcx>)>,\n+) {\n+    let stack_slot = fx.bcx.func.create_stack_slot(StackSlotData {\n+        kind: StackSlotKind::ExplicitSlot,\n+        offset: None,\n+        size: u32::try_from(slot_size.bytes()).unwrap(),\n+    });\n+    #[cfg(debug_assertions)]\n+    fx.add_comment(stack_slot, \"inline asm scratch slot\");\n+\n+    let inline_asm_func = fx\n+        .cx\n+        .module\n+        .declare_function(\n+            asm_name,\n+            Linkage::Import,\n+            &Signature {\n+                call_conv: CallConv::SystemV,\n+                params: vec![AbiParam::new(fx.pointer_type)],\n+                returns: vec![],\n+            },\n+        )\n+        .unwrap();\n+    let inline_asm_func = fx\n+        .cx\n+        .module\n+        .declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n+    #[cfg(debug_assertions)]\n+    fx.add_comment(inline_asm_func, asm_name);\n+\n+    for (_reg, offset, value) in inputs {\n+        fx.bcx\n+            .ins()\n+            .stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());\n+    }\n+\n+    let stack_slot_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n+    fx.bcx.ins().call(inline_asm_func, &[stack_slot_addr]);\n+\n+    for (_reg, offset, place) in outputs {\n+        let ty = fx.clif_type(place.layout().ty).unwrap();\n+        let value = fx\n+            .bcx\n+            .ins()\n+            .stack_load(ty, stack_slot, i32::try_from(offset.bytes()).unwrap());\n+        place.write_cvalue(fx, CValue::by_val(value, place.layout()));\n+    }\n+}\n+\n+fn expect_reg(reg_or_class: InlineAsmRegOrRegClass) -> InlineAsmReg {\n+    match reg_or_class {\n+        InlineAsmRegOrRegClass::Reg(reg) => reg,\n+        InlineAsmRegOrRegClass::RegClass(class) => unimplemented!(\"{:?}\", class),\n+    }\n+}\n+\n+fn save_register(generated_asm: &mut String, arch: InlineAsmArch, reg: InlineAsmReg, offset: Size) {\n+    match arch {\n+        InlineAsmArch::X86_64 => {\n+            write!(generated_asm, \"    mov [rbp+0x{:x}], \", offset.bytes()).unwrap();\n+            reg.emit(generated_asm, InlineAsmArch::X86_64, None)\n+                .unwrap();\n+            generated_asm.push('\\n');\n+        }\n+        _ => unimplemented!(\"save_register for {:?}\", arch),\n+    }\n+}\n+\n+fn restore_register(\n+    generated_asm: &mut String,\n+    arch: InlineAsmArch,\n+    reg: InlineAsmReg,\n+    offset: Size,\n+) {\n+    match arch {\n+        InlineAsmArch::X86_64 => {\n+            generated_asm.push_str(\"    mov \");\n+            reg.emit(generated_asm, InlineAsmArch::X86_64, None)\n+                .unwrap();\n+            writeln!(generated_asm, \", [rbp+0x{:x}]\", offset.bytes()).unwrap();\n+        }\n+        _ => unimplemented!(\"restore_register for {:?}\", arch),\n+    }\n+}"}, {"sha": "c1a1cdbe4eb7daac6f6c538cbf2aace8762f68bd", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/cpuid.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,93 @@\n+//! Emulation of a subset of the cpuid x86 instruction.\n+\n+use crate::prelude::*;\n+\n+/// Emulates a subset of the cpuid x86 instruction.\n+///\n+/// This emulates an intel cpu with sse and sse2 support, but which doesn't support anything else.\n+pub(crate) fn codegen_cpuid_call<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    leaf: Value,\n+    _subleaf: Value,\n+) -> (Value, Value, Value, Value) {\n+    let leaf_0 = fx.bcx.create_block();\n+    let leaf_1 = fx.bcx.create_block();\n+    let leaf_8000_0000 = fx.bcx.create_block();\n+    let leaf_8000_0001 = fx.bcx.create_block();\n+    let unsupported_leaf = fx.bcx.create_block();\n+\n+    let dest = fx.bcx.create_block();\n+    let eax = fx.bcx.append_block_param(dest, types::I32);\n+    let ebx = fx.bcx.append_block_param(dest, types::I32);\n+    let ecx = fx.bcx.append_block_param(dest, types::I32);\n+    let edx = fx.bcx.append_block_param(dest, types::I32);\n+\n+    let mut switch = cranelift_frontend::Switch::new();\n+    switch.set_entry(0, leaf_0);\n+    switch.set_entry(1, leaf_1);\n+    switch.set_entry(0x8000_0000, leaf_8000_0000);\n+    switch.set_entry(0x8000_0001, leaf_8000_0001);\n+    switch.emit(&mut fx.bcx, leaf, unsupported_leaf);\n+\n+    fx.bcx.switch_to_block(leaf_0);\n+    let max_basic_leaf = fx.bcx.ins().iconst(types::I32, 1);\n+    let vend0 = fx\n+        .bcx\n+        .ins()\n+        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"Genu\")));\n+    let vend2 = fx\n+        .bcx\n+        .ins()\n+        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ineI\")));\n+    let vend1 = fx\n+        .bcx\n+        .ins()\n+        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ntel\")));\n+    fx.bcx\n+        .ins()\n+        .jump(dest, &[max_basic_leaf, vend0, vend1, vend2]);\n+\n+    fx.bcx.switch_to_block(leaf_1);\n+    let cpu_signature = fx.bcx.ins().iconst(types::I32, 0);\n+    let additional_information = fx.bcx.ins().iconst(types::I32, 0);\n+    let ecx_features = fx.bcx.ins().iconst(types::I32, 0);\n+    let edx_features = fx\n+        .bcx\n+        .ins()\n+        .iconst(types::I32, 1 << 25 /* sse */ | 1 << 26 /* sse2 */);\n+    fx.bcx.ins().jump(\n+        dest,\n+        &[\n+            cpu_signature,\n+            additional_information,\n+            ecx_features,\n+            edx_features,\n+        ],\n+    );\n+\n+    fx.bcx.switch_to_block(leaf_8000_0000);\n+    let extended_max_basic_leaf = fx.bcx.ins().iconst(types::I32, 0);\n+    let zero = fx.bcx.ins().iconst(types::I32, 0);\n+    fx.bcx\n+        .ins()\n+        .jump(dest, &[extended_max_basic_leaf, zero, zero, zero]);\n+\n+    fx.bcx.switch_to_block(leaf_8000_0001);\n+    let zero = fx.bcx.ins().iconst(types::I32, 0);\n+    let proc_info_ecx = fx.bcx.ins().iconst(types::I32, 0);\n+    let proc_info_edx = fx.bcx.ins().iconst(types::I32, 0);\n+    fx.bcx\n+        .ins()\n+        .jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n+\n+    fx.bcx.switch_to_block(unsupported_leaf);\n+    crate::trap::trap_unreachable(\n+        fx,\n+        \"__cpuid_count arch intrinsic doesn't yet support specified leaf\",\n+    );\n+\n+    fx.bcx.switch_to_block(dest);\n+    fx.bcx.ins().nop();\n+\n+    (eax, ebx, ecx, edx)\n+}"}, {"sha": "18d86f0c5f959f31805fac9712d9ab5b627b1ff3", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,123 @@\n+//! Emulate LLVM intrinsics\n+\n+use crate::intrinsics::*;\n+use crate::prelude::*;\n+\n+use rustc_middle::ty::subst::SubstsRef;\n+\n+pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    intrinsic: &str,\n+    substs: SubstsRef<'tcx>,\n+    args: &[mir::Operand<'tcx>],\n+    destination: Option<(CPlace<'tcx>, BasicBlock)>,\n+) {\n+    let ret = destination.unwrap().0;\n+\n+    intrinsic_match! {\n+        fx, intrinsic, substs, args,\n+        _ => {\n+            fx.tcx.sess.warn(&format!(\"unsupported llvm intrinsic {}; replacing with trap\", intrinsic));\n+            crate::trap::trap_unimplemented(fx, intrinsic);\n+        };\n+\n+        // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n+        llvm.x86.sse2.pmovmskb.128 | llvm.x86.avx2.pmovmskb | llvm.x86.sse2.movmsk.pd, (c a) {\n+            let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, a.layout());\n+            let lane_ty = fx.clif_type(lane_layout.ty).unwrap();\n+            assert!(lane_count <= 32);\n+\n+            let mut res = fx.bcx.ins().iconst(types::I32, 0);\n+\n+            for lane in (0..lane_count).rev() {\n+                let a_lane = a.value_field(fx, mir::Field::new(lane.try_into().unwrap())).load_scalar(fx);\n+\n+                // cast float to int\n+                let a_lane = match lane_ty {\n+                    types::F32 => fx.bcx.ins().bitcast(types::I32, a_lane),\n+                    types::F64 => fx.bcx.ins().bitcast(types::I64, a_lane),\n+                    _ => a_lane,\n+                };\n+\n+                // extract sign bit of an int\n+                let a_lane_sign = fx.bcx.ins().ushr_imm(a_lane, i64::from(lane_ty.bits() - 1));\n+\n+                // shift sign bit into result\n+                let a_lane_sign = clif_intcast(fx, a_lane_sign, types::I32, false);\n+                res = fx.bcx.ins().ishl_imm(res, 1);\n+                res = fx.bcx.ins().bor(res, a_lane_sign);\n+            }\n+\n+            let res = CValue::by_val(res, fx.layout_of(fx.tcx.types.i32));\n+            ret.write_cvalue(fx, res);\n+        };\n+        llvm.x86.sse2.cmp.ps | llvm.x86.sse2.cmp.pd, (c x, c y, o kind) {\n+            let kind_const = crate::constant::mir_operand_get_const_val(fx, kind).expect(\"llvm.x86.sse2.cmp.* kind not const\");\n+            let flt_cc = match kind_const.val.try_to_bits(Size::from_bytes(1)).expect(&format!(\"kind not scalar: {:?}\", kind_const)) {\n+                0 => FloatCC::Equal,\n+                1 => FloatCC::LessThan,\n+                2 => FloatCC::LessThanOrEqual,\n+                7 => {\n+                    unimplemented!(\"Compares corresponding elements in `a` and `b` to see if neither is `NaN`.\");\n+                }\n+                3 => {\n+                    unimplemented!(\"Compares corresponding elements in `a` and `b` to see if either is `NaN`.\");\n+                }\n+                4 => FloatCC::NotEqual,\n+                5 => {\n+                    unimplemented!(\"not less than\");\n+                }\n+                6 => {\n+                    unimplemented!(\"not less than or equal\");\n+                }\n+                kind => unreachable!(\"kind {:?}\", kind),\n+            };\n+\n+            simd_pair_for_each_lane(fx, x, y, ret, |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.kind() {\n+                    ty::Float(_) => fx.bcx.ins().fcmp(flt_cc, x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n+            });\n+        };\n+        llvm.x86.sse2.psrli.d, (c a, o imm8) {\n+            let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n+            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n+                let res_lane = match imm8.val.try_to_bits(Size::from_bytes(4)).expect(&format!(\"imm8 not scalar: {:?}\", imm8)) {\n+                    imm8 if imm8 < 32 => fx.bcx.ins().ushr_imm(lane, i64::from(imm8 as u8)),\n+                    _ => fx.bcx.ins().iconst(types::I32, 0),\n+                };\n+                CValue::by_val(res_lane, res_lane_layout)\n+            });\n+        };\n+        llvm.x86.sse2.pslli.d, (c a, o imm8) {\n+            let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n+            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n+                let res_lane = match imm8.val.try_to_bits(Size::from_bytes(4)).expect(&format!(\"imm8 not scalar: {:?}\", imm8)) {\n+                    imm8 if imm8 < 32 => fx.bcx.ins().ishl_imm(lane, i64::from(imm8 as u8)),\n+                    _ => fx.bcx.ins().iconst(types::I32, 0),\n+                };\n+                CValue::by_val(res_lane, res_lane_layout)\n+            });\n+        };\n+        llvm.x86.sse2.storeu.dq, (v mem_addr, c a) {\n+            // FIXME correctly handle the unalignment\n+            let dest = CPlace::for_ptr(Pointer::new(mem_addr), a.layout());\n+            dest.write_cvalue(fx, a);\n+        };\n+    }\n+\n+    if let Some((_, dest)) = destination {\n+        let ret_block = fx.get_block(dest);\n+        fx.bcx.ins().jump(ret_block, &[]);\n+    } else {\n+        trap_unreachable(fx, \"[corruption] Diverging intrinsic returned.\");\n+    }\n+}\n+\n+// llvm.x86.avx2.vperm2i128\n+// llvm.x86.ssse3.pshuf.b.128\n+// llvm.x86.avx2.pshuf.b\n+// llvm.x86.avx2.psrli.w\n+// llvm.x86.sse2.psrli.w"}, {"sha": "9a3e4c7b56e9c24629ad2388cecb313450d8a3ac", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "added", "additions": 1099, "deletions": 0, "changes": 1099, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,1099 @@\n+//! Codegen of intrinsics. This includes `extern \"rust-intrinsic\"`, `extern \"platform-intrinsic\"`\n+//! and LLVM intrinsics that have symbol names starting with `llvm.`.\n+\n+mod cpuid;\n+mod llvm;\n+mod simd;\n+\n+pub(crate) use cpuid::codegen_cpuid_call;\n+pub(crate) use llvm::codegen_llvm_intrinsic_call;\n+\n+use crate::prelude::*;\n+\n+macro intrinsic_pat {\n+    (_) => {\n+        _\n+    },\n+    ($name:ident) => {\n+        stringify!($name)\n+    },\n+    ($name:literal) => {\n+        stringify!($name)\n+    },\n+    ($x:ident . $($xs:tt).*) => {\n+        concat!(stringify!($x), \".\", intrinsic_pat!($($xs).*))\n+    }\n+}\n+\n+macro intrinsic_arg {\n+    (o $fx:expr, $arg:ident) => {\n+        $arg\n+    },\n+    (c $fx:expr, $arg:ident) => {\n+        trans_operand($fx, $arg)\n+    },\n+    (v $fx:expr, $arg:ident) => {\n+        trans_operand($fx, $arg).load_scalar($fx)\n+    }\n+}\n+\n+macro intrinsic_substs {\n+    ($substs:expr, $index:expr,) => {},\n+    ($substs:expr, $index:expr, $first:ident $(,$rest:ident)*) => {\n+        let $first = $substs.type_at($index);\n+        intrinsic_substs!($substs, $index+1, $($rest),*);\n+    }\n+}\n+\n+macro intrinsic_match {\n+    ($fx:expr, $intrinsic:expr, $substs:expr, $args:expr,\n+    _ => $unknown:block;\n+    $(\n+        $($($name:tt).*)|+ $(if $cond:expr)?, $(<$($subst:ident),*>)? ($($a:ident $arg:ident),*) $content:block;\n+    )*) => {\n+        let _ = $substs; // Silence warning when substs is unused.\n+        match $intrinsic {\n+            $(\n+                $(intrinsic_pat!($($name).*))|* $(if $cond)? => {\n+                    #[allow(unused_parens, non_snake_case)]\n+                    {\n+                        $(\n+                            intrinsic_substs!($substs, 0, $($subst),*);\n+                        )?\n+                        if let [$($arg),*] = $args {\n+                            let ($($arg,)*) = (\n+                                $(intrinsic_arg!($a $fx, $arg),)*\n+                            );\n+                            #[warn(unused_parens, non_snake_case)]\n+                            {\n+                                $content\n+                            }\n+                        } else {\n+                            bug!(\"wrong number of args for intrinsic {:?}\", $intrinsic);\n+                        }\n+                    }\n+                }\n+            )*\n+            _ => $unknown,\n+        }\n+    }\n+}\n+\n+macro call_intrinsic_match {\n+    ($fx:expr, $intrinsic:expr, $substs:expr, $ret:expr, $destination:expr, $args:expr, $(\n+        $name:ident($($arg:ident),*) -> $ty:ident => $func:ident,\n+    )*) => {\n+        match $intrinsic {\n+            $(\n+                stringify!($name) => {\n+                    assert!($substs.is_noop());\n+                    if let [$(ref $arg),*] = *$args {\n+                        let ($($arg,)*) = (\n+                            $(trans_operand($fx, $arg),)*\n+                        );\n+                        let res = $fx.easy_call(stringify!($func), &[$($arg),*], $fx.tcx.types.$ty);\n+                        $ret.write_cvalue($fx, res);\n+\n+                        if let Some((_, dest)) = $destination {\n+                            let ret_block = $fx.get_block(dest);\n+                            $fx.bcx.ins().jump(ret_block, &[]);\n+                            return;\n+                        } else {\n+                            unreachable!();\n+                        }\n+                    } else {\n+                        bug!(\"wrong number of args for intrinsic {:?}\", $intrinsic);\n+                    }\n+                }\n+            )*\n+            _ => {}\n+        }\n+    }\n+}\n+\n+macro atomic_binop_return_old($fx:expr, $op:ident<$T:ident>($ptr:ident, $src:ident) -> $ret:ident) {\n+    crate::atomic_shim::lock_global_lock($fx);\n+\n+    let clif_ty = $fx.clif_type($T).unwrap();\n+    let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n+    let new = $fx.bcx.ins().$op(old, $src);\n+    $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n+    $ret.write_cvalue($fx, CValue::by_val(old, $fx.layout_of($T)));\n+\n+    crate::atomic_shim::unlock_global_lock($fx);\n+}\n+\n+macro atomic_minmax($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $ret:ident) {\n+    crate::atomic_shim::lock_global_lock($fx);\n+\n+    // Read old\n+    let clif_ty = $fx.clif_type($T).unwrap();\n+    let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n+\n+    // Compare\n+    let is_eq = $fx.bcx.ins().icmp(IntCC::SignedGreaterThan, old, $src);\n+    let new = $fx.bcx.ins().select(is_eq, old, $src);\n+\n+    // Write new\n+    $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n+\n+    let ret_val = CValue::by_val(old, $ret.layout());\n+    $ret.write_cvalue($fx, ret_val);\n+\n+    crate::atomic_shim::unlock_global_lock($fx);\n+}\n+\n+macro validate_atomic_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n+    match $ty.kind() {\n+        ty::Uint(_) | ty::Int(_) => {}\n+        _ => {\n+            $fx.tcx.sess.span_err(\n+                $span,\n+                &format!(\n+                    \"`{}` intrinsic: expected basic integer type, found `{:?}`\",\n+                    $intrinsic, $ty\n+                ),\n+            );\n+            // Prevent verifier error\n+            crate::trap::trap_unreachable($fx, \"compilation should not have succeeded\");\n+            return;\n+        }\n+    }\n+}\n+\n+macro validate_simd_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n+    if !$ty.is_simd() {\n+        $fx.tcx.sess.span_err($span, &format!(\"invalid monomorphization of `{}` intrinsic: expected SIMD input type, found non-SIMD `{}`\", $intrinsic, $ty));\n+        // Prevent verifier error\n+        crate::trap::trap_unreachable($fx, \"compilation should not have succeeded\");\n+        return;\n+    }\n+}\n+\n+fn lane_type_and_count<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    layout: TyAndLayout<'tcx>,\n+) -> (TyAndLayout<'tcx>, u16) {\n+    assert!(layout.ty.is_simd());\n+    let lane_count = match layout.fields {\n+        rustc_target::abi::FieldsShape::Array { stride: _, count } => u16::try_from(count).unwrap(),\n+        _ => unreachable!(\"lane_type_and_count({:?})\", layout),\n+    };\n+    let lane_layout = layout\n+        .field(\n+            &ty::layout::LayoutCx {\n+                tcx,\n+                param_env: ParamEnv::reveal_all(),\n+            },\n+            0,\n+        )\n+        .unwrap();\n+    (lane_layout, lane_count)\n+}\n+\n+pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> Option<Type> {\n+    let (element, count) = match &layout.abi {\n+        Abi::Vector { element, count } => (element.clone(), *count),\n+        _ => unreachable!(),\n+    };\n+\n+    match scalar_to_clif_type(tcx, element).by(u16::try_from(count).unwrap()) {\n+        // Cranelift currently only implements icmp for 128bit vectors.\n+        Some(vector_ty) if vector_ty.bits() == 128 => Some(vector_ty),\n+        _ => None,\n+    }\n+}\n+\n+fn simd_for_each_lane<'tcx, M: Module>(\n+    fx: &mut FunctionCx<'_, 'tcx, M>,\n+    val: CValue<'tcx>,\n+    ret: CPlace<'tcx>,\n+    f: impl Fn(\n+        &mut FunctionCx<'_, 'tcx, M>,\n+        TyAndLayout<'tcx>,\n+        TyAndLayout<'tcx>,\n+        Value,\n+    ) -> CValue<'tcx>,\n+) {\n+    let layout = val.layout();\n+\n+    let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, layout);\n+    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+    assert_eq!(lane_count, ret_lane_count);\n+\n+    for lane_idx in 0..lane_count {\n+        let lane_idx = mir::Field::new(lane_idx.try_into().unwrap());\n+        let lane = val.value_field(fx, lane_idx).load_scalar(fx);\n+\n+        let res_lane = f(fx, lane_layout, ret_lane_layout, lane);\n+\n+        ret.place_field(fx, lane_idx).write_cvalue(fx, res_lane);\n+    }\n+}\n+\n+fn simd_pair_for_each_lane<'tcx, M: Module>(\n+    fx: &mut FunctionCx<'_, 'tcx, M>,\n+    x: CValue<'tcx>,\n+    y: CValue<'tcx>,\n+    ret: CPlace<'tcx>,\n+    f: impl Fn(\n+        &mut FunctionCx<'_, 'tcx, M>,\n+        TyAndLayout<'tcx>,\n+        TyAndLayout<'tcx>,\n+        Value,\n+        Value,\n+    ) -> CValue<'tcx>,\n+) {\n+    assert_eq!(x.layout(), y.layout());\n+    let layout = x.layout();\n+\n+    let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, layout);\n+    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+    assert_eq!(lane_count, ret_lane_count);\n+\n+    for lane in 0..lane_count {\n+        let lane = mir::Field::new(lane.try_into().unwrap());\n+        let x_lane = x.value_field(fx, lane).load_scalar(fx);\n+        let y_lane = y.value_field(fx, lane).load_scalar(fx);\n+\n+        let res_lane = f(fx, lane_layout, ret_lane_layout, x_lane, y_lane);\n+\n+        ret.place_field(fx, lane).write_cvalue(fx, res_lane);\n+    }\n+}\n+\n+fn bool_to_zero_or_max_uint<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    layout: TyAndLayout<'tcx>,\n+    val: Value,\n+) -> CValue<'tcx> {\n+    let ty = fx.clif_type(layout.ty).unwrap();\n+\n+    let int_ty = match ty {\n+        types::F32 => types::I32,\n+        types::F64 => types::I64,\n+        ty => ty,\n+    };\n+\n+    let val = fx.bcx.ins().bint(int_ty, val);\n+    let mut res = fx.bcx.ins().ineg(val);\n+\n+    if ty.is_float() {\n+        res = fx.bcx.ins().bitcast(ty, res);\n+    }\n+\n+    CValue::by_val(res, layout)\n+}\n+\n+macro simd_cmp {\n+    ($fx:expr, $cc:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        let vector_ty = clif_vector_type($fx.tcx, $x.layout());\n+\n+        if let Some(vector_ty) = vector_ty {\n+            let x = $x.load_scalar($fx);\n+            let y = $y.load_scalar($fx);\n+            let val = $fx.bcx.ins().icmp(IntCC::$cc, x, y);\n+\n+            // HACK This depends on the fact that icmp for vectors represents bools as 0 and !0, not 0 and 1.\n+            let val = $fx.bcx.ins().raw_bitcast(vector_ty, val);\n+\n+            $ret.write_cvalue($fx, CValue::by_val(val, $ret.layout()));\n+        } else {\n+            simd_pair_for_each_lane(\n+                $fx,\n+                $x,\n+                $y,\n+                $ret,\n+                |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n+                    let res_lane = match lane_layout.ty.kind() {\n+                        ty::Uint(_) | ty::Int(_) => fx.bcx.ins().icmp(IntCC::$cc, x_lane, y_lane),\n+                        _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                    };\n+                    bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n+                },\n+            );\n+        }\n+    },\n+    ($fx:expr, $cc_u:ident|$cc_s:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        // FIXME use vector icmp when possible\n+        simd_pair_for_each_lane(\n+            $fx,\n+            $x,\n+            $y,\n+            $ret,\n+            |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.kind() {\n+                    ty::Uint(_) => fx.bcx.ins().icmp(IntCC::$cc_u, x_lane, y_lane),\n+                    ty::Int(_) => fx.bcx.ins().icmp(IntCC::$cc_s, x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n+            },\n+        );\n+    },\n+}\n+\n+macro simd_int_binop {\n+    ($fx:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_int_binop!($fx, $op|$op($x, $y) -> $ret);\n+    },\n+    ($fx:expr, $op_u:ident|$op_s:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_pair_for_each_lane(\n+            $fx,\n+            $x,\n+            $y,\n+            $ret,\n+            |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.kind() {\n+                    ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n+                    ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                CValue::by_val(res_lane, ret_lane_layout)\n+            },\n+        );\n+    },\n+}\n+\n+macro simd_int_flt_binop {\n+    ($fx:expr, $op:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_int_flt_binop!($fx, $op|$op|$op_f($x, $y) -> $ret);\n+    },\n+    ($fx:expr, $op_u:ident|$op_s:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_pair_for_each_lane(\n+            $fx,\n+            $x,\n+            $y,\n+            $ret,\n+            |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.kind() {\n+                    ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n+                    ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n+                    ty::Float(_) => fx.bcx.ins().$op_f(x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                CValue::by_val(res_lane, ret_lane_layout)\n+            },\n+        );\n+    },\n+}\n+\n+macro simd_flt_binop($fx:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) {\n+    simd_pair_for_each_lane(\n+        $fx,\n+        $x,\n+        $y,\n+        $ret,\n+        |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.kind() {\n+                ty::Float(_) => fx.bcx.ins().$op(x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n+            CValue::by_val(res_lane, ret_lane_layout)\n+        },\n+    );\n+}\n+\n+pub(crate) fn codegen_intrinsic_call<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    instance: Instance<'tcx>,\n+    args: &[mir::Operand<'tcx>],\n+    destination: Option<(CPlace<'tcx>, BasicBlock)>,\n+    span: Span,\n+) {\n+    let def_id = instance.def_id();\n+    let substs = instance.substs;\n+\n+    let intrinsic = fx.tcx.item_name(def_id).as_str();\n+    let intrinsic = &intrinsic[..];\n+\n+    let ret = match destination {\n+        Some((place, _)) => place,\n+        None => {\n+            // Insert non returning intrinsics here\n+            match intrinsic {\n+                \"abort\" => {\n+                    trap_abort(fx, \"Called intrinsic::abort.\");\n+                }\n+                \"unreachable\" => {\n+                    trap_unreachable(fx, \"[corruption] Called intrinsic::unreachable.\");\n+                }\n+                \"transmute\" => {\n+                    crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", span);\n+                }\n+                _ => unimplemented!(\"unsupported instrinsic {}\", intrinsic),\n+            }\n+            return;\n+        }\n+    };\n+\n+    if intrinsic.starts_with(\"simd_\") {\n+        self::simd::codegen_simd_intrinsic_call(fx, instance, args, ret, span);\n+        let ret_block = fx.get_block(destination.expect(\"SIMD intrinsics don't diverge\").1);\n+        fx.bcx.ins().jump(ret_block, &[]);\n+        return;\n+    }\n+\n+    let usize_layout = fx.layout_of(fx.tcx.types.usize);\n+\n+    call_intrinsic_match! {\n+        fx, intrinsic, substs, ret, destination, args,\n+        expf32(flt) -> f32 => expf,\n+        expf64(flt) -> f64 => exp,\n+        exp2f32(flt) -> f32 => exp2f,\n+        exp2f64(flt) -> f64 => exp2,\n+        sqrtf32(flt) -> f32 => sqrtf,\n+        sqrtf64(flt) -> f64 => sqrt,\n+        powif32(a, x) -> f32 => __powisf2, // compiler-builtins\n+        powif64(a, x) -> f64 => __powidf2, // compiler-builtins\n+        powf32(a, x) -> f32 => powf,\n+        powf64(a, x) -> f64 => pow,\n+        logf32(flt) -> f32 => logf,\n+        logf64(flt) -> f64 => log,\n+        log2f32(flt) -> f32 => log2f,\n+        log2f64(flt) -> f64 => log2,\n+        log10f32(flt) -> f32 => log10f,\n+        log10f64(flt) -> f64 => log10,\n+        fabsf32(flt) -> f32 => fabsf,\n+        fabsf64(flt) -> f64 => fabs,\n+        fmaf32(x, y, z) -> f32 => fmaf,\n+        fmaf64(x, y, z) -> f64 => fma,\n+        copysignf32(x, y) -> f32 => copysignf,\n+        copysignf64(x, y) -> f64 => copysign,\n+\n+        // rounding variants\n+        // FIXME use clif insts\n+        floorf32(flt) -> f32 => floorf,\n+        floorf64(flt) -> f64 => floor,\n+        ceilf32(flt) -> f32 => ceilf,\n+        ceilf64(flt) -> f64 => ceil,\n+        truncf32(flt) -> f32 => truncf,\n+        truncf64(flt) -> f64 => trunc,\n+        roundf32(flt) -> f32 => roundf,\n+        roundf64(flt) -> f64 => round,\n+\n+        // trigonometry\n+        sinf32(flt) -> f32 => sinf,\n+        sinf64(flt) -> f64 => sin,\n+        cosf32(flt) -> f32 => cosf,\n+        cosf64(flt) -> f64 => cos,\n+        tanf32(flt) -> f32 => tanf,\n+        tanf64(flt) -> f64 => tan,\n+    }\n+\n+    intrinsic_match! {\n+        fx, intrinsic, substs, args,\n+        _ => {\n+            fx.tcx.sess.span_fatal(span, &format!(\"unsupported intrinsic {}\", intrinsic));\n+        };\n+\n+        assume, (c _a) {};\n+        likely | unlikely, (c a) {\n+            ret.write_cvalue(fx, a);\n+        };\n+        breakpoint, () {\n+            fx.bcx.ins().debugtrap();\n+        };\n+        copy | copy_nonoverlapping, <elem_ty> (v src, v dst, v count) {\n+            let elem_size: u64 = fx.layout_of(elem_ty).size.bytes();\n+            let elem_size = fx\n+                .bcx\n+                .ins()\n+                .iconst(fx.pointer_type, elem_size as i64);\n+            assert_eq!(args.len(), 3);\n+            let byte_amount = fx.bcx.ins().imul(count, elem_size);\n+\n+            if intrinsic.contains(\"nonoverlapping\") {\n+                // FIXME emit_small_memcpy\n+                fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, byte_amount);\n+            } else {\n+                // FIXME emit_small_memmove\n+                fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n+            }\n+        };\n+        // NOTE: the volatile variants have src and dst swapped\n+        volatile_copy_memory | volatile_copy_nonoverlapping_memory, <elem_ty> (v dst, v src, v count) {\n+            let elem_size: u64 = fx.layout_of(elem_ty).size.bytes();\n+            let elem_size = fx\n+                .bcx\n+                .ins()\n+                .iconst(fx.pointer_type, elem_size as i64);\n+            assert_eq!(args.len(), 3);\n+            let byte_amount = fx.bcx.ins().imul(count, elem_size);\n+\n+            // FIXME make the copy actually volatile when using emit_small_mem{cpy,move}\n+            if intrinsic.contains(\"nonoverlapping\") {\n+                // FIXME emit_small_memcpy\n+                fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, byte_amount);\n+            } else {\n+                // FIXME emit_small_memmove\n+                fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n+            }\n+        };\n+        discriminant_value, (c ptr) {\n+            let pointee_layout = fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n+            let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), pointee_layout);\n+            let discr = crate::discriminant::codegen_get_discriminant(fx, val, ret.layout());\n+            ret.write_cvalue(fx, discr);\n+        };\n+        size_of_val, <T> (c ptr) {\n+            let layout = fx.layout_of(T);\n+            let size = if layout.is_unsized() {\n+                let (_ptr, info) = ptr.load_scalar_pair(fx);\n+                let (size, _align) = crate::unsize::size_and_align_of_dst(fx, layout, info);\n+                size\n+            } else {\n+                fx\n+                    .bcx\n+                    .ins()\n+                    .iconst(fx.pointer_type, layout.size.bytes() as i64)\n+            };\n+            ret.write_cvalue(fx, CValue::by_val(size, usize_layout));\n+        };\n+        min_align_of_val, <T> (c ptr) {\n+            let layout = fx.layout_of(T);\n+            let align = if layout.is_unsized() {\n+                let (_ptr, info) = ptr.load_scalar_pair(fx);\n+                let (_size, align) = crate::unsize::size_and_align_of_dst(fx, layout, info);\n+                align\n+            } else {\n+                fx\n+                    .bcx\n+                    .ins()\n+                    .iconst(fx.pointer_type, layout.align.abi.bytes() as i64)\n+            };\n+            ret.write_cvalue(fx, CValue::by_val(align, usize_layout));\n+        };\n+\n+        _ if intrinsic.starts_with(\"unchecked_\") || intrinsic == \"exact_div\", (c x, c y) {\n+            // FIXME trap on overflow\n+            let bin_op = match intrinsic {\n+                \"unchecked_add\" => BinOp::Add,\n+                \"unchecked_sub\" => BinOp::Sub,\n+                \"unchecked_div\" | \"exact_div\" => BinOp::Div,\n+                \"unchecked_rem\" => BinOp::Rem,\n+                \"unchecked_shl\" => BinOp::Shl,\n+                \"unchecked_shr\" => BinOp::Shr,\n+                _ => unreachable!(\"intrinsic {}\", intrinsic),\n+            };\n+            let res = crate::num::trans_int_binop(fx, bin_op, x, y);\n+            ret.write_cvalue(fx, res);\n+        };\n+        _ if intrinsic.ends_with(\"_with_overflow\"), (c x, c y) {\n+            assert_eq!(x.layout().ty, y.layout().ty);\n+            let bin_op = match intrinsic {\n+                \"add_with_overflow\" => BinOp::Add,\n+                \"sub_with_overflow\" => BinOp::Sub,\n+                \"mul_with_overflow\" => BinOp::Mul,\n+                _ => unreachable!(\"intrinsic {}\", intrinsic),\n+            };\n+\n+            let res = crate::num::trans_checked_int_binop(\n+                fx,\n+                bin_op,\n+                x,\n+                y,\n+            );\n+            ret.write_cvalue(fx, res);\n+        };\n+        _ if intrinsic.starts_with(\"wrapping_\"), (c x, c y) {\n+            assert_eq!(x.layout().ty, y.layout().ty);\n+            let bin_op = match intrinsic {\n+                \"wrapping_add\" => BinOp::Add,\n+                \"wrapping_sub\" => BinOp::Sub,\n+                \"wrapping_mul\" => BinOp::Mul,\n+                _ => unreachable!(\"intrinsic {}\", intrinsic),\n+            };\n+            let res = crate::num::trans_int_binop(\n+                fx,\n+                bin_op,\n+                x,\n+                y,\n+            );\n+            ret.write_cvalue(fx, res);\n+        };\n+        _ if intrinsic.starts_with(\"saturating_\"), <T> (c lhs, c rhs) {\n+            assert_eq!(lhs.layout().ty, rhs.layout().ty);\n+            let bin_op = match intrinsic {\n+                \"saturating_add\" => BinOp::Add,\n+                \"saturating_sub\" => BinOp::Sub,\n+                _ => unreachable!(\"intrinsic {}\", intrinsic),\n+            };\n+\n+            let signed = type_sign(T);\n+\n+            let checked_res = crate::num::trans_checked_int_binop(\n+                fx,\n+                bin_op,\n+                lhs,\n+                rhs,\n+            );\n+\n+            let (val, has_overflow) = checked_res.load_scalar_pair(fx);\n+            let clif_ty = fx.clif_type(T).unwrap();\n+\n+            // `select.i8` is not implemented by Cranelift.\n+            let has_overflow = fx.bcx.ins().uextend(types::I32, has_overflow);\n+\n+            let (min, max) = type_min_max_value(&mut fx.bcx, clif_ty, signed);\n+\n+            let val = match (intrinsic, signed) {\n+                (\"saturating_add\", false) => fx.bcx.ins().select(has_overflow, max, val),\n+                (\"saturating_sub\", false) => fx.bcx.ins().select(has_overflow, min, val),\n+                (\"saturating_add\", true) => {\n+                    let rhs = rhs.load_scalar(fx);\n+                    let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n+                    let sat_val = fx.bcx.ins().select(rhs_ge_zero, max, min);\n+                    fx.bcx.ins().select(has_overflow, sat_val, val)\n+                }\n+                (\"saturating_sub\", true) => {\n+                    let rhs = rhs.load_scalar(fx);\n+                    let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n+                    let sat_val = fx.bcx.ins().select(rhs_ge_zero, min, max);\n+                    fx.bcx.ins().select(has_overflow, sat_val, val)\n+                }\n+                _ => unreachable!(),\n+            };\n+\n+            let res = CValue::by_val(val, fx.layout_of(T));\n+\n+            ret.write_cvalue(fx, res);\n+        };\n+        rotate_left, <T>(v x, v y) {\n+            let layout = fx.layout_of(T);\n+            let res = fx.bcx.ins().rotl(x, y);\n+            ret.write_cvalue(fx, CValue::by_val(res, layout));\n+        };\n+        rotate_right, <T>(v x, v y) {\n+            let layout = fx.layout_of(T);\n+            let res = fx.bcx.ins().rotr(x, y);\n+            ret.write_cvalue(fx, CValue::by_val(res, layout));\n+        };\n+\n+        // The only difference between offset and arith_offset is regarding UB. Because Cranelift\n+        // doesn't have UB both are codegen'ed the same way\n+        offset | arith_offset, (c base, v offset) {\n+            let pointee_ty = base.layout().ty.builtin_deref(true).unwrap().ty;\n+            let pointee_size = fx.layout_of(pointee_ty).size.bytes();\n+            let ptr_diff = fx.bcx.ins().imul_imm(offset, pointee_size as i64);\n+            let base_val = base.load_scalar(fx);\n+            let res = fx.bcx.ins().iadd(base_val, ptr_diff);\n+            ret.write_cvalue(fx, CValue::by_val(res, base.layout()));\n+        };\n+\n+        transmute, (c from) {\n+            ret.write_cvalue_transmute(fx, from);\n+        };\n+        write_bytes | volatile_set_memory, (c dst, v val, v count) {\n+            let pointee_ty = dst.layout().ty.builtin_deref(true).unwrap().ty;\n+            let pointee_size = fx.layout_of(pointee_ty).size.bytes();\n+            let count = fx.bcx.ins().imul_imm(count, pointee_size as i64);\n+            let dst_ptr = dst.load_scalar(fx);\n+            // FIXME make the memset actually volatile when switching to emit_small_memset\n+            // FIXME use emit_small_memset\n+            fx.bcx.call_memset(fx.cx.module.target_config(), dst_ptr, val, count);\n+        };\n+        ctlz | ctlz_nonzero, <T> (v arg) {\n+            // FIXME trap on `ctlz_nonzero` with zero arg.\n+            let res = if T == fx.tcx.types.u128 || T == fx.tcx.types.i128 {\n+                // FIXME verify this algorithm is correct\n+                let (lsb, msb) = fx.bcx.ins().isplit(arg);\n+                let lsb_lz = fx.bcx.ins().clz(lsb);\n+                let msb_lz = fx.bcx.ins().clz(msb);\n+                let msb_is_zero = fx.bcx.ins().icmp_imm(IntCC::Equal, msb, 0);\n+                let lsb_lz_plus_64 = fx.bcx.ins().iadd_imm(lsb_lz, 64);\n+                let res = fx.bcx.ins().select(msb_is_zero, lsb_lz_plus_64, msb_lz);\n+                fx.bcx.ins().uextend(types::I128, res)\n+            } else {\n+                fx.bcx.ins().clz(arg)\n+            };\n+            let res = CValue::by_val(res, fx.layout_of(T));\n+            ret.write_cvalue(fx, res);\n+        };\n+        cttz | cttz_nonzero, <T> (v arg) {\n+            // FIXME trap on `cttz_nonzero` with zero arg.\n+            let res = if T == fx.tcx.types.u128 || T == fx.tcx.types.i128 {\n+                // FIXME verify this algorithm is correct\n+                let (lsb, msb) = fx.bcx.ins().isplit(arg);\n+                let lsb_tz = fx.bcx.ins().ctz(lsb);\n+                let msb_tz = fx.bcx.ins().ctz(msb);\n+                let lsb_is_zero = fx.bcx.ins().icmp_imm(IntCC::Equal, lsb, 0);\n+                let msb_tz_plus_64 = fx.bcx.ins().iadd_imm(msb_tz, 64);\n+                let res = fx.bcx.ins().select(lsb_is_zero, msb_tz_plus_64, lsb_tz);\n+                fx.bcx.ins().uextend(types::I128, res)\n+            } else {\n+                fx.bcx.ins().ctz(arg)\n+            };\n+            let res = CValue::by_val(res, fx.layout_of(T));\n+            ret.write_cvalue(fx, res);\n+        };\n+        ctpop, <T> (v arg) {\n+            let res = fx.bcx.ins().popcnt(arg);\n+            let res = CValue::by_val(res, fx.layout_of(T));\n+            ret.write_cvalue(fx, res);\n+        };\n+        bitreverse, <T> (v arg) {\n+            let res = fx.bcx.ins().bitrev(arg);\n+            let res = CValue::by_val(res, fx.layout_of(T));\n+            ret.write_cvalue(fx, res);\n+        };\n+        bswap, <T> (v arg) {\n+            // FIXME(CraneStation/cranelift#794) add bswap instruction to cranelift\n+            fn swap(bcx: &mut FunctionBuilder<'_>, v: Value) -> Value {\n+                match bcx.func.dfg.value_type(v) {\n+                    types::I8 => v,\n+\n+                    // https://code.woboq.org/gcc/include/bits/byteswap.h.html\n+                    types::I16 => {\n+                        let tmp1 = bcx.ins().ishl_imm(v, 8);\n+                        let n1 = bcx.ins().band_imm(tmp1, 0xFF00);\n+\n+                        let tmp2 = bcx.ins().ushr_imm(v, 8);\n+                        let n2 = bcx.ins().band_imm(tmp2, 0x00FF);\n+\n+                        bcx.ins().bor(n1, n2)\n+                    }\n+                    types::I32 => {\n+                        let tmp1 = bcx.ins().ishl_imm(v, 24);\n+                        let n1 = bcx.ins().band_imm(tmp1, 0xFF00_0000);\n+\n+                        let tmp2 = bcx.ins().ishl_imm(v, 8);\n+                        let n2 = bcx.ins().band_imm(tmp2, 0x00FF_0000);\n+\n+                        let tmp3 = bcx.ins().ushr_imm(v, 8);\n+                        let n3 = bcx.ins().band_imm(tmp3, 0x0000_FF00);\n+\n+                        let tmp4 = bcx.ins().ushr_imm(v, 24);\n+                        let n4 = bcx.ins().band_imm(tmp4, 0x0000_00FF);\n+\n+                        let or_tmp1 = bcx.ins().bor(n1, n2);\n+                        let or_tmp2 = bcx.ins().bor(n3, n4);\n+                        bcx.ins().bor(or_tmp1, or_tmp2)\n+                    }\n+                    types::I64 => {\n+                        let tmp1 = bcx.ins().ishl_imm(v, 56);\n+                        let n1 = bcx.ins().band_imm(tmp1, 0xFF00_0000_0000_0000u64 as i64);\n+\n+                        let tmp2 = bcx.ins().ishl_imm(v, 40);\n+                        let n2 = bcx.ins().band_imm(tmp2, 0x00FF_0000_0000_0000u64 as i64);\n+\n+                        let tmp3 = bcx.ins().ishl_imm(v, 24);\n+                        let n3 = bcx.ins().band_imm(tmp3, 0x0000_FF00_0000_0000u64 as i64);\n+\n+                        let tmp4 = bcx.ins().ishl_imm(v, 8);\n+                        let n4 = bcx.ins().band_imm(tmp4, 0x0000_00FF_0000_0000u64 as i64);\n+\n+                        let tmp5 = bcx.ins().ushr_imm(v, 8);\n+                        let n5 = bcx.ins().band_imm(tmp5, 0x0000_0000_FF00_0000u64 as i64);\n+\n+                        let tmp6 = bcx.ins().ushr_imm(v, 24);\n+                        let n6 = bcx.ins().band_imm(tmp6, 0x0000_0000_00FF_0000u64 as i64);\n+\n+                        let tmp7 = bcx.ins().ushr_imm(v, 40);\n+                        let n7 = bcx.ins().band_imm(tmp7, 0x0000_0000_0000_FF00u64 as i64);\n+\n+                        let tmp8 = bcx.ins().ushr_imm(v, 56);\n+                        let n8 = bcx.ins().band_imm(tmp8, 0x0000_0000_0000_00FFu64 as i64);\n+\n+                        let or_tmp1 = bcx.ins().bor(n1, n2);\n+                        let or_tmp2 = bcx.ins().bor(n3, n4);\n+                        let or_tmp3 = bcx.ins().bor(n5, n6);\n+                        let or_tmp4 = bcx.ins().bor(n7, n8);\n+\n+                        let or_tmp5 = bcx.ins().bor(or_tmp1, or_tmp2);\n+                        let or_tmp6 = bcx.ins().bor(or_tmp3, or_tmp4);\n+                        bcx.ins().bor(or_tmp5, or_tmp6)\n+                    }\n+                    types::I128 => {\n+                        let (lo, hi) = bcx.ins().isplit(v);\n+                        let lo = swap(bcx, lo);\n+                        let hi = swap(bcx, hi);\n+                        bcx.ins().iconcat(hi, lo)\n+                    }\n+                    ty => unreachable!(\"bswap {}\", ty),\n+                }\n+            };\n+            let res = CValue::by_val(swap(&mut fx.bcx, arg), fx.layout_of(T));\n+            ret.write_cvalue(fx, res);\n+        };\n+        assert_inhabited | assert_zero_valid | assert_uninit_valid, <T> () {\n+            let layout = fx.layout_of(T);\n+            if layout.abi.is_uninhabited() {\n+                crate::base::codegen_panic(\n+                    fx,\n+                    &format!(\"attempted to instantiate uninhabited type `{}`\", T),\n+                    span,\n+                );\n+                return;\n+            }\n+\n+            if intrinsic == \"assert_zero_valid\" && !layout.might_permit_raw_init(fx, /*zero:*/ true).unwrap() {\n+                crate::base::codegen_panic(\n+                    fx,\n+                    &format!(\"attempted to zero-initialize type `{}`, which is invalid\", T),\n+                    span,\n+                );\n+                return;\n+            }\n+\n+            if intrinsic == \"assert_uninit_valid\" && !layout.might_permit_raw_init(fx, /*zero:*/ false).unwrap() {\n+                crate::base::codegen_panic(\n+                    fx,\n+                    &format!(\"attempted to leave type `{}` uninitialized, which is invalid\", T),\n+                    span,\n+                );\n+                return;\n+            }\n+        };\n+\n+        volatile_load | unaligned_volatile_load, (c ptr) {\n+            // Cranelift treats loads as volatile by default\n+            // FIXME ignore during stack2reg optimization\n+            // FIXME correctly handle unaligned_volatile_load\n+            let inner_layout =\n+                fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n+            let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), inner_layout);\n+            ret.write_cvalue(fx, val);\n+        };\n+        volatile_store | unaligned_volatile_store, (v ptr, c val) {\n+            // Cranelift treats stores as volatile by default\n+            // FIXME ignore during stack2reg optimization\n+            // FIXME correctly handle unaligned_volatile_store\n+            let dest = CPlace::for_ptr(Pointer::new(ptr), val.layout());\n+            dest.write_cvalue(fx, val);\n+        };\n+\n+        size_of | pref_align_of | min_align_of | needs_drop | type_id | type_name | variant_count, () {\n+            let const_val =\n+                fx.tcx.const_eval_instance(ParamEnv::reveal_all(), instance, None).unwrap();\n+            let val = crate::constant::trans_const_value(\n+                fx,\n+                const_val,\n+                ret.layout().ty,\n+            );\n+            ret.write_cvalue(fx, val);\n+        };\n+\n+        ptr_offset_from, <T> (v ptr, v base) {\n+            let isize_layout = fx.layout_of(fx.tcx.types.isize);\n+\n+            let pointee_size: u64 = fx.layout_of(T).size.bytes();\n+            let diff = fx.bcx.ins().isub(ptr, base);\n+            // FIXME this can be an exact division.\n+            let val = CValue::by_val(fx.bcx.ins().sdiv_imm(diff, pointee_size as i64), isize_layout);\n+            ret.write_cvalue(fx, val);\n+        };\n+\n+        ptr_guaranteed_eq, (c a, c b) {\n+            let val = crate::num::trans_ptr_binop(fx, BinOp::Eq, a, b);\n+            ret.write_cvalue(fx, val);\n+        };\n+\n+        ptr_guaranteed_ne, (c a, c b) {\n+            let val = crate::num::trans_ptr_binop(fx, BinOp::Ne, a, b);\n+            ret.write_cvalue(fx, val);\n+        };\n+\n+        caller_location, () {\n+            let caller_location = fx.get_caller_location(span);\n+            ret.write_cvalue(fx, caller_location);\n+        };\n+\n+        _ if intrinsic.starts_with(\"atomic_fence\"), () {\n+            crate::atomic_shim::lock_global_lock(fx);\n+            crate::atomic_shim::unlock_global_lock(fx);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_singlethreadfence\"), () {\n+            crate::atomic_shim::lock_global_lock(fx);\n+            crate::atomic_shim::unlock_global_lock(fx);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_load\"), (c ptr) {\n+            crate::atomic_shim::lock_global_lock(fx);\n+\n+            let inner_layout =\n+                fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n+            validate_atomic_type!(fx, intrinsic, span, inner_layout.ty);\n+            let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), inner_layout);\n+            ret.write_cvalue(fx, val);\n+\n+            crate::atomic_shim::unlock_global_lock(fx);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_store\"), (v ptr, c val) {\n+            validate_atomic_type!(fx, intrinsic, span, val.layout().ty);\n+\n+            crate::atomic_shim::lock_global_lock(fx);\n+\n+            let dest = CPlace::for_ptr(Pointer::new(ptr), val.layout());\n+            dest.write_cvalue(fx, val);\n+\n+            crate::atomic_shim::unlock_global_lock(fx);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_xchg\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, T);\n+\n+            crate::atomic_shim::lock_global_lock(fx);\n+\n+            // Read old\n+            let clif_ty = fx.clif_type(T).unwrap();\n+            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n+            ret.write_cvalue(fx, CValue::by_val(old, fx.layout_of(T)));\n+\n+            // Write new\n+            let dest = CPlace::for_ptr(Pointer::new(ptr), src.layout());\n+            dest.write_cvalue(fx, src);\n+\n+            crate::atomic_shim::unlock_global_lock(fx);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_cxchg\"), <T> (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+            validate_atomic_type!(fx, intrinsic, span, T);\n+\n+            let test_old = test_old.load_scalar(fx);\n+            let new = new.load_scalar(fx);\n+\n+            crate::atomic_shim::lock_global_lock(fx);\n+\n+            // Read old\n+            let clif_ty = fx.clif_type(T).unwrap();\n+            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n+\n+            // Compare\n+            let is_eq = fx.bcx.ins().icmp(IntCC::Equal, old, test_old);\n+            let new = fx.bcx.ins().select(is_eq, new, old); // Keep old if not equal to test_old\n+\n+            // Write new\n+            fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n+\n+            let ret_val = CValue::by_val_pair(old, fx.bcx.ins().bint(types::I8, is_eq), ret.layout());\n+            ret.write_cvalue(fx, ret_val);\n+\n+            crate::atomic_shim::unlock_global_lock(fx);\n+        };\n+\n+        _ if intrinsic.starts_with(\"atomic_xadd\"), <T> (v ptr, c amount) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let amount = amount.load_scalar(fx);\n+            atomic_binop_return_old! (fx, iadd<T>(ptr, amount) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_xsub\"), <T> (v ptr, c amount) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let amount = amount.load_scalar(fx);\n+            atomic_binop_return_old! (fx, isub<T>(ptr, amount) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_and\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n+            atomic_binop_return_old! (fx, band<T>(ptr, src) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_nand\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, T);\n+\n+            let src = src.load_scalar(fx);\n+\n+            crate::atomic_shim::lock_global_lock(fx);\n+\n+            let clif_ty = fx.clif_type(T).unwrap();\n+            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n+            let and = fx.bcx.ins().band(old, src);\n+            let new = fx.bcx.ins().bnot(and);\n+            fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n+            ret.write_cvalue(fx, CValue::by_val(old, fx.layout_of(T)));\n+\n+            crate::atomic_shim::unlock_global_lock(fx);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_or\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n+            atomic_binop_return_old! (fx, bor<T>(ptr, src) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_xor\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n+            atomic_binop_return_old! (fx, bxor<T>(ptr, src) -> ret);\n+        };\n+\n+        _ if intrinsic.starts_with(\"atomic_max\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n+            atomic_minmax!(fx, IntCC::SignedGreaterThan, <T> (ptr, src) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_umax\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n+            atomic_minmax!(fx, IntCC::UnsignedGreaterThan, <T> (ptr, src) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_min\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n+            atomic_minmax!(fx, IntCC::SignedLessThan, <T> (ptr, src) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_umin\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n+            atomic_minmax!(fx, IntCC::UnsignedLessThan, <T> (ptr, src) -> ret);\n+        };\n+\n+        minnumf32, (v a, v b) {\n+            let val = fx.bcx.ins().fmin(a, b);\n+            let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f32));\n+            ret.write_cvalue(fx, val);\n+        };\n+        minnumf64, (v a, v b) {\n+            let val = fx.bcx.ins().fmin(a, b);\n+            let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f64));\n+            ret.write_cvalue(fx, val);\n+        };\n+        maxnumf32, (v a, v b) {\n+            let val = fx.bcx.ins().fmax(a, b);\n+            let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f32));\n+            ret.write_cvalue(fx, val);\n+        };\n+        maxnumf64, (v a, v b) {\n+            let val = fx.bcx.ins().fmax(a, b);\n+            let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f64));\n+            ret.write_cvalue(fx, val);\n+        };\n+\n+        try, (v f, v data, v _catch_fn) {\n+            // FIXME once unwinding is supported, change this to actually catch panics\n+            let f_sig = fx.bcx.func.import_signature(Signature {\n+                call_conv: CallConv::triple_default(fx.triple()),\n+                params: vec![AbiParam::new(fx.bcx.func.dfg.value_type(data))],\n+                returns: vec![],\n+            });\n+\n+            fx.bcx.ins().call_indirect(f_sig, f, &[data]);\n+\n+            let ret_val = CValue::const_val(fx, ret.layout(), 0);\n+            ret.write_cvalue(fx, ret_val);\n+        };\n+\n+        fadd_fast | fsub_fast | fmul_fast | fdiv_fast | frem_fast, (c x, c y) {\n+            let res = crate::num::trans_float_binop(fx, match intrinsic {\n+                \"fadd_fast\" => BinOp::Add,\n+                \"fsub_fast\" => BinOp::Sub,\n+                \"fmul_fast\" => BinOp::Mul,\n+                \"fdiv_fast\" => BinOp::Div,\n+                \"frem_fast\" => BinOp::Rem,\n+                _ => unreachable!(),\n+            }, x, y);\n+            ret.write_cvalue(fx, res);\n+        };\n+        float_to_int_unchecked, (v f) {\n+            let res = crate::cast::clif_int_or_float_cast(\n+                fx,\n+                f,\n+                false,\n+                fx.clif_type(ret.layout().ty).unwrap(),\n+                type_sign(ret.layout().ty),\n+            );\n+            ret.write_cvalue(fx, CValue::by_val(res, ret.layout()));\n+        };\n+    }\n+\n+    if let Some((_, dest)) = destination {\n+        let ret_block = fx.get_block(dest);\n+        fx.bcx.ins().jump(ret_block, &[]);\n+    } else {\n+        trap_unreachable(fx, \"[corruption] Diverging intrinsic returned.\");\n+    }\n+}"}, {"sha": "b4269f4fafa0b47fbd98672d9eb5eefa23a402f4", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,238 @@\n+//! Codegen `extern \"platform-intrinsic\"` intrinsics.\n+\n+use super::*;\n+use crate::prelude::*;\n+\n+pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    instance: Instance<'tcx>,\n+    args: &[mir::Operand<'tcx>],\n+    ret: CPlace<'tcx>,\n+    span: Span,\n+) {\n+    let def_id = instance.def_id();\n+    let substs = instance.substs;\n+\n+    let intrinsic = fx.tcx.item_name(def_id).as_str();\n+    let intrinsic = &intrinsic[..];\n+\n+    intrinsic_match! {\n+        fx, intrinsic, substs, args,\n+        _ => {\n+            fx.tcx.sess.span_fatal(span, &format!(\"Unknown SIMD intrinsic {}\", intrinsic));\n+        };\n+\n+        simd_cast, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, lane_layout, ret_lane_layout, lane| {\n+                let ret_lane_ty = fx.clif_type(ret_lane_layout.ty).unwrap();\n+\n+                let from_signed = type_sign(lane_layout.ty);\n+                let to_signed = type_sign(ret_lane_layout.ty);\n+\n+                let ret_lane = clif_int_or_float_cast(fx, lane, from_signed, ret_lane_ty, to_signed);\n+                CValue::by_val(ret_lane, ret_lane_layout)\n+            });\n+        };\n+\n+        // FIXME support float comparisons\n+        simd_eq, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_cmp!(fx, Equal(x, y) -> ret);\n+        };\n+        simd_ne, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_cmp!(fx, NotEqual(x, y) -> ret);\n+        };\n+        simd_lt, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_cmp!(fx, UnsignedLessThan|SignedLessThan(x, y) -> ret);\n+        };\n+        simd_le, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_cmp!(fx, UnsignedLessThanOrEqual|SignedLessThanOrEqual(x, y) -> ret);\n+        };\n+        simd_gt, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_cmp!(fx, UnsignedGreaterThan|SignedGreaterThan(x, y) -> ret);\n+        };\n+        simd_ge, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_cmp!(fx, UnsignedGreaterThanOrEqual|SignedGreaterThanOrEqual(x, y) -> ret);\n+        };\n+\n+        // simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U\n+        _ if intrinsic.starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+\n+            let n: u16 = intrinsic[\"simd_shuffle\".len()..].parse().unwrap();\n+\n+            assert_eq!(x.layout(), y.layout());\n+            let layout = x.layout();\n+\n+            let (lane_type, lane_count) = lane_type_and_count(fx.tcx, layout);\n+            let (ret_lane_type, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+\n+            assert_eq!(lane_type, ret_lane_type);\n+            assert_eq!(n, ret_lane_count);\n+\n+            let total_len = lane_count * 2;\n+\n+            let indexes = {\n+                use rustc_middle::mir::interpret::*;\n+                let idx_const = crate::constant::mir_operand_get_const_val(fx, idx).expect(\"simd_shuffle* idx not const\");\n+\n+                let idx_bytes = match idx_const.val {\n+                    ty::ConstKind::Value(ConstValue::ByRef { alloc, offset }) => {\n+                        let ptr = Pointer::new(AllocId(0 /* dummy */), offset);\n+                        let size = Size::from_bytes(4 * u64::from(ret_lane_count) /* size_of([u32; ret_lane_count]) */);\n+                        alloc.get_bytes(fx, ptr, size).unwrap()\n+                    }\n+                    _ => unreachable!(\"{:?}\", idx_const),\n+                };\n+\n+                (0..ret_lane_count).map(|i| {\n+                    let i = usize::try_from(i).unwrap();\n+                    let idx = rustc_middle::mir::interpret::read_target_uint(\n+                        fx.tcx.data_layout.endian,\n+                        &idx_bytes[4*i.. 4*i + 4],\n+                    ).expect(\"read_target_uint\");\n+                    u16::try_from(idx).expect(\"try_from u32\")\n+                }).collect::<Vec<u16>>()\n+            };\n+\n+            for &idx in &indexes {\n+                assert!(idx < total_len, \"idx {} out of range 0..{}\", idx, total_len);\n+            }\n+\n+            for (out_idx, in_idx) in indexes.into_iter().enumerate() {\n+                let in_lane = if in_idx < lane_count {\n+                    x.value_field(fx, mir::Field::new(in_idx.try_into().unwrap()))\n+                } else {\n+                    y.value_field(fx, mir::Field::new((in_idx - lane_count).try_into().unwrap()))\n+                };\n+                let out_lane = ret.place_field(fx, mir::Field::new(out_idx));\n+                out_lane.write_cvalue(fx, in_lane);\n+            }\n+        };\n+\n+        simd_insert, (c base, o idx, c val) {\n+            // FIXME validate\n+            let idx_const = if let Some(idx_const) = crate::constant::mir_operand_get_const_val(fx, idx) {\n+                idx_const\n+            } else {\n+                fx.tcx.sess.span_fatal(\n+                    span,\n+                    \"Index argument for `simd_insert` is not a constant\",\n+                );\n+            };\n+\n+            let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).expect(&format!(\"kind not scalar: {:?}\", idx_const));\n+            let (_lane_type, lane_count) = lane_type_and_count(fx.tcx, base.layout());\n+            if idx >= lane_count.into() {\n+                fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_insert] idx {} >= lane_count {}\", idx, lane_count));\n+            }\n+\n+            ret.write_cvalue(fx, base);\n+            let ret_lane = ret.place_field(fx, mir::Field::new(idx.try_into().unwrap()));\n+            ret_lane.write_cvalue(fx, val);\n+        };\n+\n+        simd_extract, (c v, o idx) {\n+            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n+            let idx_const = if let Some(idx_const) = crate::constant::mir_operand_get_const_val(fx, idx) {\n+                idx_const\n+            } else {\n+                fx.tcx.sess.span_fatal(\n+                    span,\n+                    \"Index argument for `simd_extract` is not a constant\",\n+                );\n+            };\n+\n+            let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).expect(&format!(\"kind not scalar: {:?}\", idx_const));\n+            let (_lane_type, lane_count) = lane_type_and_count(fx.tcx, v.layout());\n+            if idx >= lane_count.into() {\n+                fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count));\n+            }\n+\n+            let ret_lane = v.value_field(fx, mir::Field::new(idx.try_into().unwrap()));\n+            ret.write_cvalue(fx, ret_lane);\n+        };\n+\n+        simd_add, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_int_flt_binop!(fx, iadd|fadd(x, y) -> ret);\n+        };\n+        simd_sub, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_int_flt_binop!(fx, isub|fsub(x, y) -> ret);\n+        };\n+        simd_mul, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_int_flt_binop!(fx, imul|fmul(x, y) -> ret);\n+        };\n+        simd_div, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_int_flt_binop!(fx, udiv|sdiv|fdiv(x, y) -> ret);\n+        };\n+        simd_shl, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_int_binop!(fx, ishl(x, y) -> ret);\n+        };\n+        simd_shr, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_int_binop!(fx, ushr|sshr(x, y) -> ret);\n+        };\n+        simd_and, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_int_binop!(fx, band(x, y) -> ret);\n+        };\n+        simd_or, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_int_binop!(fx, bor(x, y) -> ret);\n+        };\n+        simd_xor, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_int_binop!(fx, bxor(x, y) -> ret);\n+        };\n+\n+        simd_fma, (c a, c b, c c) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            assert_eq!(a.layout(), b.layout());\n+            assert_eq!(a.layout(), c.layout());\n+            let layout = a.layout();\n+\n+            let (_lane_layout, lane_count) = lane_type_and_count(fx.tcx, layout);\n+            let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+            assert_eq!(lane_count, ret_lane_count);\n+\n+            for lane in 0..lane_count {\n+                let lane = mir::Field::new(lane.try_into().unwrap());\n+                let a_lane = a.value_field(fx, lane).load_scalar(fx);\n+                let b_lane = b.value_field(fx, lane).load_scalar(fx);\n+                let c_lane = c.value_field(fx, lane).load_scalar(fx);\n+\n+                let mul_lane = fx.bcx.ins().fmul(a_lane, b_lane);\n+                let res_lane = CValue::by_val(fx.bcx.ins().fadd(mul_lane, c_lane), ret_lane_layout);\n+\n+                ret.place_field(fx, lane).write_cvalue(fx, res_lane);\n+            }\n+        };\n+\n+        simd_fmin, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_flt_binop!(fx, fmin(x, y) -> ret);\n+        };\n+        simd_fmax, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_flt_binop!(fx, fmax(x, y) -> ret);\n+        };\n+\n+        // simd_fabs\n+        // simd_saturating_add\n+        // simd_bitmask\n+        // simd_select\n+        // simd_reduce_add_{,un}ordered\n+        // simd_rem\n+    }\n+}"}, {"sha": "fd00a2e00a6a4457cce0ab897e64b04b6803fb80", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,316 @@\n+#![feature(\n+    rustc_private,\n+    decl_macro,\n+    type_alias_impl_trait,\n+    associated_type_bounds,\n+    never_type,\n+    try_blocks,\n+    hash_drain_filter\n+)]\n+#![warn(rust_2018_idioms)]\n+#![warn(unused_lifetimes)]\n+\n+#[cfg(feature = \"jit\")]\n+extern crate libc;\n+extern crate snap;\n+#[macro_use]\n+extern crate rustc_middle;\n+extern crate rustc_ast;\n+extern crate rustc_codegen_ssa;\n+extern crate rustc_data_structures;\n+extern crate rustc_errors;\n+extern crate rustc_fs_util;\n+extern crate rustc_hir;\n+extern crate rustc_incremental;\n+extern crate rustc_index;\n+extern crate rustc_session;\n+extern crate rustc_span;\n+extern crate rustc_symbol_mangling;\n+extern crate rustc_target;\n+\n+// This prevents duplicating functions and statics that are already part of the host rustc process.\n+#[allow(unused_extern_crates)]\n+extern crate rustc_driver;\n+\n+use std::any::Any;\n+\n+use rustc_codegen_ssa::traits::CodegenBackend;\n+use rustc_codegen_ssa::CodegenResults;\n+use rustc_errors::ErrorReported;\n+use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n+use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoader};\n+use rustc_middle::ty::query::Providers;\n+use rustc_session::config::OutputFilenames;\n+use rustc_session::Session;\n+\n+use cranelift_codegen::settings::{self, Configurable};\n+\n+use crate::constant::ConstantCx;\n+use crate::prelude::*;\n+\n+mod abi;\n+mod allocator;\n+mod analyze;\n+mod archive;\n+mod atomic_shim;\n+mod backend;\n+mod base;\n+mod cast;\n+mod codegen_i128;\n+mod common;\n+mod constant;\n+mod debuginfo;\n+mod discriminant;\n+mod driver;\n+mod inline_asm;\n+mod intrinsics;\n+mod linkage;\n+mod main_shim;\n+mod metadata;\n+mod num;\n+mod optimize;\n+mod pointer;\n+mod pretty_clif;\n+mod toolchain;\n+mod trap;\n+mod unsize;\n+mod value_and_place;\n+mod vtable;\n+\n+mod prelude {\n+    pub(crate) use std::convert::{TryFrom, TryInto};\n+\n+    pub(crate) use rustc_ast::ast::{FloatTy, IntTy, UintTy};\n+    pub(crate) use rustc_span::Span;\n+\n+    pub(crate) use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+    pub(crate) use rustc_middle::bug;\n+    pub(crate) use rustc_middle::mir::{self, *};\n+    pub(crate) use rustc_middle::ty::layout::{self, TyAndLayout};\n+    pub(crate) use rustc_middle::ty::{\n+        self, FnSig, Instance, InstanceDef, ParamEnv, Ty, TyCtxt, TypeAndMut, TypeFoldable,\n+    };\n+    pub(crate) use rustc_target::abi::{Abi, LayoutOf, Scalar, Size, VariantIdx};\n+\n+    pub(crate) use rustc_data_structures::fx::FxHashMap;\n+\n+    pub(crate) use rustc_index::vec::Idx;\n+\n+    pub(crate) use cranelift_codegen::entity::EntitySet;\n+    pub(crate) use cranelift_codegen::ir::condcodes::{FloatCC, IntCC};\n+    pub(crate) use cranelift_codegen::ir::function::Function;\n+    pub(crate) use cranelift_codegen::ir::types;\n+    pub(crate) use cranelift_codegen::ir::{\n+        AbiParam, Block, ExternalName, FuncRef, Inst, InstBuilder, MemFlags, Signature, SourceLoc,\n+        StackSlot, StackSlotData, StackSlotKind, TrapCode, Type, Value,\n+    };\n+    pub(crate) use cranelift_codegen::isa::{self, CallConv};\n+    pub(crate) use cranelift_codegen::Context;\n+    pub(crate) use cranelift_frontend::{FunctionBuilder, FunctionBuilderContext, Variable};\n+    pub(crate) use cranelift_module::{self, DataContext, DataId, FuncId, Linkage, Module};\n+\n+    pub(crate) use crate::abi::*;\n+    pub(crate) use crate::base::{trans_operand, trans_place};\n+    pub(crate) use crate::cast::*;\n+    pub(crate) use crate::common::*;\n+    pub(crate) use crate::debuginfo::{DebugContext, UnwindContext};\n+    pub(crate) use crate::pointer::Pointer;\n+    pub(crate) use crate::trap::*;\n+    pub(crate) use crate::value_and_place::{CPlace, CPlaceInner, CValue};\n+}\n+\n+struct PrintOnPanic<F: Fn() -> String>(F);\n+impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n+    fn drop(&mut self) {\n+        if ::std::thread::panicking() {\n+            println!(\"{}\", (self.0)());\n+        }\n+    }\n+}\n+\n+struct CodegenCx<'tcx, M: Module> {\n+    tcx: TyCtxt<'tcx>,\n+    module: M,\n+    global_asm: String,\n+    constants_cx: ConstantCx,\n+    cached_context: Context,\n+    vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), DataId>,\n+    debug_context: Option<DebugContext<'tcx>>,\n+    unwind_context: UnwindContext<'tcx>,\n+}\n+\n+impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n+    fn new(tcx: TyCtxt<'tcx>, module: M, debug_info: bool) -> Self {\n+        let unwind_context = UnwindContext::new(tcx, module.isa());\n+        let debug_context = if debug_info {\n+            Some(DebugContext::new(tcx, module.isa()))\n+        } else {\n+            None\n+        };\n+        CodegenCx {\n+            tcx,\n+            module,\n+            global_asm: String::new(),\n+            constants_cx: ConstantCx::default(),\n+            cached_context: Context::new(),\n+            vtables: FxHashMap::default(),\n+            debug_context,\n+            unwind_context,\n+        }\n+    }\n+\n+    fn finalize(mut self) -> (M, String, Option<DebugContext<'tcx>>, UnwindContext<'tcx>) {\n+        self.constants_cx.finalize(self.tcx, &mut self.module);\n+        (\n+            self.module,\n+            self.global_asm,\n+            self.debug_context,\n+            self.unwind_context,\n+        )\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct BackendConfig {\n+    pub use_jit: bool,\n+}\n+\n+pub struct CraneliftCodegenBackend {\n+    pub config: BackendConfig,\n+}\n+\n+impl CodegenBackend for CraneliftCodegenBackend {\n+    fn init(&self, sess: &Session) {\n+        if sess.lto() != rustc_session::config::Lto::No && sess.opts.cg.embed_bitcode {\n+            sess.warn(\"LTO is not supported. You may get a linker error.\");\n+        }\n+    }\n+\n+    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync> {\n+        Box::new(crate::metadata::CraneliftMetadataLoader)\n+    }\n+\n+    fn provide(&self, _providers: &mut Providers) {}\n+    fn provide_extern(&self, _providers: &mut Providers) {}\n+\n+    fn target_features(&self, _sess: &Session) -> Vec<rustc_span::Symbol> {\n+        vec![]\n+    }\n+\n+    fn codegen_crate<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        metadata: EncodedMetadata,\n+        need_metadata_module: bool,\n+    ) -> Box<dyn Any> {\n+        let res = driver::codegen_crate(tcx, metadata, need_metadata_module, self.config);\n+\n+        rustc_symbol_mangling::test::report_symbol_names(tcx);\n+\n+        res\n+    }\n+\n+    fn join_codegen(\n+        &self,\n+        ongoing_codegen: Box<dyn Any>,\n+        _sess: &Session,\n+    ) -> Result<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>), ErrorReported> {\n+        Ok(*ongoing_codegen\n+            .downcast::<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)>()\n+            .unwrap())\n+    }\n+\n+    fn link(\n+        &self,\n+        sess: &Session,\n+        codegen_results: CodegenResults,\n+        outputs: &OutputFilenames,\n+    ) -> Result<(), ErrorReported> {\n+        use rustc_codegen_ssa::back::link::link_binary;\n+\n+        let _timer = sess.prof.generic_activity(\"link_crate\");\n+\n+        sess.time(\"linking\", || {\n+            let target_cpu = crate::target_triple(sess).to_string();\n+            link_binary::<crate::archive::ArArchiveBuilder<'_>>(\n+                sess,\n+                &codegen_results,\n+                outputs,\n+                &codegen_results.crate_name.as_str(),\n+                &target_cpu,\n+            );\n+        });\n+\n+        Ok(())\n+    }\n+}\n+\n+fn target_triple(sess: &Session) -> target_lexicon::Triple {\n+    sess.target.llvm_target.parse().unwrap()\n+}\n+\n+fn build_isa(sess: &Session, enable_pic: bool) -> Box<dyn isa::TargetIsa + 'static> {\n+    use target_lexicon::BinaryFormat;\n+\n+    let target_triple = crate::target_triple(sess);\n+\n+    let mut flags_builder = settings::builder();\n+    if enable_pic {\n+        flags_builder.enable(\"is_pic\").unwrap();\n+    } else {\n+        flags_builder.set(\"is_pic\", \"false\").unwrap();\n+    }\n+    flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n+    flags_builder\n+        .set(\n+            \"enable_verifier\",\n+            if cfg!(debug_assertions) {\n+                \"true\"\n+            } else {\n+                \"false\"\n+            },\n+        )\n+        .unwrap();\n+\n+    let tls_model = match target_triple.binary_format {\n+        BinaryFormat::Elf => \"elf_gd\",\n+        BinaryFormat::Macho => \"macho\",\n+        BinaryFormat::Coff => \"coff\",\n+        _ => \"none\",\n+    };\n+    flags_builder.set(\"tls_model\", tls_model).unwrap();\n+\n+    flags_builder.set(\"enable_simd\", \"true\").unwrap();\n+\n+    // FIXME(CraneStation/cranelift#732) fix LICM in presence of jump tables\n+    /*\n+    use rustc_session::config::OptLevel;\n+    match sess.opts.optimize {\n+        OptLevel::No => {\n+            flags_builder.set(\"opt_level\", \"none\").unwrap();\n+        }\n+        OptLevel::Less | OptLevel::Default => {}\n+        OptLevel::Aggressive => {\n+            flags_builder.set(\"opt_level\", \"speed_and_size\").unwrap();\n+        }\n+        OptLevel::Size | OptLevel::SizeMin => {\n+            sess.warn(\"Optimizing for size is not supported. Just ignoring the request\");\n+        }\n+    }*/\n+\n+    let flags = settings::Flags::new(flags_builder);\n+\n+    let mut isa_builder = cranelift_codegen::isa::lookup(target_triple).unwrap();\n+    // Don't use \"haswell\", as it implies `has_lzcnt`.macOS CI is still at Ivy Bridge EP, so `lzcnt`\n+    // is interpreted as `bsr`.\n+    isa_builder.enable(\"nehalem\").unwrap();\n+    isa_builder.finish(flags)\n+}\n+\n+/// This is the entrypoint for a hot plugged rustc_codegen_cranelift\n+#[no_mangle]\n+pub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n+    Box::new(CraneliftCodegenBackend {\n+        config: BackendConfig { use_jit: false },\n+    })\n+}"}, {"sha": "fe5d1d64443630b5e8905ef36ce49f797716aa2b", "filename": "compiler/rustc_codegen_cranelift/src/linkage.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,35 @@\n+use rustc_middle::mir::mono::{Linkage as RLinkage, MonoItem, Visibility};\n+\n+use crate::prelude::*;\n+\n+pub(crate) fn get_clif_linkage(\n+    mono_item: MonoItem<'_>,\n+    linkage: RLinkage,\n+    visibility: Visibility,\n+) -> Linkage {\n+    match (linkage, visibility) {\n+        (RLinkage::External, Visibility::Default) => Linkage::Export,\n+        (RLinkage::Internal, Visibility::Default) => Linkage::Local,\n+        (RLinkage::External, Visibility::Hidden) => Linkage::Hidden,\n+        _ => panic!(\"{:?} = {:?} {:?}\", mono_item, linkage, visibility),\n+    }\n+}\n+\n+pub(crate) fn get_static_linkage(tcx: TyCtxt<'_>, def_id: DefId) -> Linkage {\n+    let fn_attrs = tcx.codegen_fn_attrs(def_id);\n+\n+    if let Some(linkage) = fn_attrs.linkage {\n+        match linkage {\n+            RLinkage::External => Linkage::Export,\n+            RLinkage::Internal => Linkage::Local,\n+            RLinkage::ExternalWeak | RLinkage::WeakAny => Linkage::Preemptible,\n+            _ => panic!(\"{:?}\", linkage),\n+        }\n+    } else {\n+        if tcx.is_reachable_non_generic(def_id) {\n+            Linkage::Export\n+        } else {\n+            Linkage::Hidden\n+        }\n+    }\n+}"}, {"sha": "db34d89fe2be717c5ce9ef1a2965ee10753aa5c9", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,130 @@\n+use rustc_hir::LangItem;\n+use rustc_session::config::EntryFnType;\n+\n+use crate::prelude::*;\n+\n+/// Create the `main` function which will initialize the rust runtime and call\n+/// users main function.\n+pub(crate) fn maybe_create_entry_wrapper(\n+    tcx: TyCtxt<'_>,\n+    module: &mut impl Module,\n+    unwind_context: &mut UnwindContext<'_>,\n+    use_jit: bool,\n+) {\n+    let (main_def_id, use_start_lang_item) = match tcx.entry_fn(LOCAL_CRATE) {\n+        Some((def_id, entry_ty)) => (\n+            def_id.to_def_id(),\n+            match entry_ty {\n+                EntryFnType::Main => true,\n+                EntryFnType::Start => false,\n+            },\n+        ),\n+        None => return,\n+    };\n+\n+    let instance = Instance::mono(tcx, main_def_id).polymorphize(tcx);\n+    if module.get_name(&*tcx.symbol_name(instance).name).is_none() {\n+        return;\n+    }\n+\n+    create_entry_fn(\n+        tcx,\n+        module,\n+        unwind_context,\n+        main_def_id,\n+        use_start_lang_item,\n+        use_jit,\n+    );\n+\n+    fn create_entry_fn(\n+        tcx: TyCtxt<'_>,\n+        m: &mut impl Module,\n+        unwind_context: &mut UnwindContext<'_>,\n+        rust_main_def_id: DefId,\n+        use_start_lang_item: bool,\n+        use_jit: bool,\n+    ) {\n+        let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n+        // Given that `main()` has no arguments,\n+        // then its return type cannot have\n+        // late-bound regions, since late-bound\n+        // regions must appear in the argument\n+        // listing.\n+        let main_ret_ty = tcx.erase_regions(&main_ret_ty.no_bound_vars().unwrap());\n+\n+        let cmain_sig = Signature {\n+            params: vec![\n+                AbiParam::new(m.target_config().pointer_type()),\n+                AbiParam::new(m.target_config().pointer_type()),\n+            ],\n+            returns: vec![AbiParam::new(\n+                m.target_config().pointer_type(), /*isize*/\n+            )],\n+            call_conv: CallConv::triple_default(m.isa().triple()),\n+        };\n+\n+        let cmain_func_id = m\n+            .declare_function(\"main\", Linkage::Export, &cmain_sig)\n+            .unwrap();\n+\n+        let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n+\n+        let (main_name, main_sig) =\n+            get_function_name_and_sig(tcx, m.isa().triple(), instance, false);\n+        let main_func_id = m\n+            .declare_function(&main_name, Linkage::Import, &main_sig)\n+            .unwrap();\n+\n+        let mut ctx = Context::new();\n+        ctx.func = Function::with_name_signature(ExternalName::user(0, 0), cmain_sig.clone());\n+        {\n+            let mut func_ctx = FunctionBuilderContext::new();\n+            let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n+\n+            let block = bcx.create_block();\n+            bcx.switch_to_block(block);\n+            let arg_argc = bcx.append_block_param(block, m.target_config().pointer_type());\n+            let arg_argv = bcx.append_block_param(block, m.target_config().pointer_type());\n+\n+            crate::atomic_shim::init_global_lock(m, &mut bcx, use_jit);\n+\n+            let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n+\n+            let call_inst = if use_start_lang_item {\n+                let start_def_id = tcx.require_lang_item(LangItem::Start, None);\n+                let start_instance = Instance::resolve(\n+                    tcx,\n+                    ParamEnv::reveal_all(),\n+                    start_def_id,\n+                    tcx.intern_substs(&[main_ret_ty.into()]),\n+                )\n+                .unwrap()\n+                .unwrap()\n+                .polymorphize(tcx);\n+                let start_func_id = import_function(tcx, m, start_instance);\n+\n+                let main_val = bcx\n+                    .ins()\n+                    .func_addr(m.target_config().pointer_type(), main_func_ref);\n+\n+                let func_ref = m.declare_func_in_func(start_func_id, &mut bcx.func);\n+                bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv])\n+            } else {\n+                // using user-defined start fn\n+                bcx.ins().call(main_func_ref, &[arg_argc, arg_argv])\n+            };\n+\n+            let result = bcx.inst_results(call_inst)[0];\n+            bcx.ins().return_(&[result]);\n+            bcx.seal_all_blocks();\n+            bcx.finalize();\n+        }\n+        m.define_function(\n+            cmain_func_id,\n+            &mut ctx,\n+            &mut cranelift_codegen::binemit::NullTrapSink {},\n+        )\n+        .unwrap();\n+        unwind_context.add_function(cmain_func_id, &ctx, m.isa());\n+    }\n+}"}, {"sha": "04369bf89fd2d81ac03171bd7ad4ede3ddeba434", "filename": "compiler/rustc_codegen_cranelift/src/metadata.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,108 @@\n+//! Reading and writing of the rustc metadata for rlibs and dylibs\n+\n+use std::convert::TryFrom;\n+use std::fs::File;\n+use std::path::Path;\n+\n+use rustc_codegen_ssa::METADATA_FILENAME;\n+use rustc_data_structures::owning_ref::OwningRef;\n+use rustc_data_structures::rustc_erase_owner;\n+use rustc_data_structures::sync::MetadataRef;\n+use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoader};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::config;\n+use rustc_target::spec::Target;\n+\n+use crate::backend::WriteMetadata;\n+\n+pub(crate) struct CraneliftMetadataLoader;\n+\n+impl MetadataLoader for CraneliftMetadataLoader {\n+    fn get_rlib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n+        let mut archive = ar::Archive::new(File::open(path).map_err(|e| format!(\"{:?}\", e))?);\n+        // Iterate over all entries in the archive:\n+        while let Some(entry_result) = archive.next_entry() {\n+            let mut entry = entry_result.map_err(|e| format!(\"{:?}\", e))?;\n+            if entry.header().identifier() == METADATA_FILENAME.as_bytes() {\n+                let mut buf = Vec::with_capacity(\n+                    usize::try_from(entry.header().size())\n+                        .expect(\"Rlib metadata file too big to load into memory.\"),\n+                );\n+                ::std::io::copy(&mut entry, &mut buf).map_err(|e| format!(\"{:?}\", e))?;\n+                let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n+                return Ok(rustc_erase_owner!(buf.map_owner_box()));\n+            }\n+        }\n+\n+        Err(\"couldn't find metadata entry\".to_string())\n+    }\n+\n+    fn get_dylib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n+        use object::{Object, ObjectSection};\n+        let file = std::fs::read(path).map_err(|e| format!(\"read:{:?}\", e))?;\n+        let file = object::File::parse(&file).map_err(|e| format!(\"parse: {:?}\", e))?;\n+        let buf = file\n+            .section_by_name(\".rustc\")\n+            .ok_or(\"no .rustc section\")?\n+            .data()\n+            .map_err(|e| format!(\"failed to read .rustc section: {:?}\", e))?\n+            .to_owned();\n+        let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n+        Ok(rustc_erase_owner!(buf.map_owner_box()))\n+    }\n+}\n+\n+// Adapted from https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src/librustc_codegen_llvm/base.rs#L47-L112\n+pub(crate) fn write_metadata<P: WriteMetadata>(\n+    tcx: TyCtxt<'_>,\n+    product: &mut P,\n+) -> EncodedMetadata {\n+    use snap::write::FrameEncoder;\n+    use std::io::Write;\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+    enum MetadataKind {\n+        None,\n+        Uncompressed,\n+        Compressed,\n+    }\n+\n+    let kind = tcx\n+        .sess\n+        .crate_types()\n+        .iter()\n+        .map(|ty| match *ty {\n+            config::CrateType::Executable\n+            | config::CrateType::Staticlib\n+            | config::CrateType::Cdylib => MetadataKind::None,\n+\n+            config::CrateType::Rlib => MetadataKind::Uncompressed,\n+\n+            config::CrateType::Dylib | config::CrateType::ProcMacro => MetadataKind::Compressed,\n+        })\n+        .max()\n+        .unwrap_or(MetadataKind::None);\n+\n+    if kind == MetadataKind::None {\n+        return EncodedMetadata::new();\n+    }\n+\n+    let metadata = tcx.encode_metadata();\n+    if kind == MetadataKind::Uncompressed {\n+        return metadata;\n+    }\n+\n+    assert!(kind == MetadataKind::Compressed);\n+    let mut compressed = tcx.metadata_encoding_version();\n+    FrameEncoder::new(&mut compressed)\n+        .write_all(&metadata.raw_data)\n+        .unwrap();\n+\n+    product.add_rustc_section(\n+        rustc_middle::middle::exported_symbols::metadata_symbol_name(tcx),\n+        compressed,\n+        tcx.sess.target.options.is_like_osx,\n+    );\n+\n+    metadata\n+}"}, {"sha": "b37826d71f4e04091152c2298c36bfb1d94bc494", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "added", "additions": 475, "deletions": 0, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,475 @@\n+//! Various operations on integer and floating-point numbers\n+\n+use crate::prelude::*;\n+\n+pub(crate) fn bin_op_to_intcc(bin_op: BinOp, signed: bool) -> Option<IntCC> {\n+    use BinOp::*;\n+    use IntCC::*;\n+    Some(match bin_op {\n+        Eq => Equal,\n+        Lt => {\n+            if signed {\n+                SignedLessThan\n+            } else {\n+                UnsignedLessThan\n+            }\n+        }\n+        Le => {\n+            if signed {\n+                SignedLessThanOrEqual\n+            } else {\n+                UnsignedLessThanOrEqual\n+            }\n+        }\n+        Ne => NotEqual,\n+        Ge => {\n+            if signed {\n+                SignedGreaterThanOrEqual\n+            } else {\n+                UnsignedGreaterThanOrEqual\n+            }\n+        }\n+        Gt => {\n+            if signed {\n+                SignedGreaterThan\n+            } else {\n+                UnsignedGreaterThan\n+            }\n+        }\n+        _ => return None,\n+    })\n+}\n+\n+fn codegen_compare_bin_op<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    bin_op: BinOp,\n+    signed: bool,\n+    lhs: Value,\n+    rhs: Value,\n+) -> CValue<'tcx> {\n+    let intcc = crate::num::bin_op_to_intcc(bin_op, signed).unwrap();\n+    let val = fx.bcx.ins().icmp(intcc, lhs, rhs);\n+    let val = fx.bcx.ins().bint(types::I8, val);\n+    CValue::by_val(val, fx.layout_of(fx.tcx.types.bool))\n+}\n+\n+pub(crate) fn codegen_binop<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    bin_op: BinOp,\n+    in_lhs: CValue<'tcx>,\n+    in_rhs: CValue<'tcx>,\n+) -> CValue<'tcx> {\n+    match bin_op {\n+        BinOp::Eq | BinOp::Lt | BinOp::Le | BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n+            match in_lhs.layout().ty.kind() {\n+                ty::Bool | ty::Uint(_) | ty::Int(_) | ty::Char => {\n+                    let signed = type_sign(in_lhs.layout().ty);\n+                    let lhs = in_lhs.load_scalar(fx);\n+                    let rhs = in_rhs.load_scalar(fx);\n+\n+                    let (lhs, rhs) = if (bin_op == BinOp::Eq || bin_op == BinOp::Ne)\n+                        && (in_lhs.layout().ty.kind() == fx.tcx.types.i8.kind()\n+                            || in_lhs.layout().ty.kind() == fx.tcx.types.i16.kind())\n+                    {\n+                        // FIXME(CraneStation/cranelift#896) icmp_imm.i8/i16 with eq/ne for signed ints is implemented wrong.\n+                        (\n+                            fx.bcx.ins().sextend(types::I32, lhs),\n+                            fx.bcx.ins().sextend(types::I32, rhs),\n+                        )\n+                    } else {\n+                        (lhs, rhs)\n+                    };\n+\n+                    return codegen_compare_bin_op(fx, bin_op, signed, lhs, rhs);\n+                }\n+                _ => {}\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    match in_lhs.layout().ty.kind() {\n+        ty::Bool => crate::num::trans_bool_binop(fx, bin_op, in_lhs, in_rhs),\n+        ty::Uint(_) | ty::Int(_) => crate::num::trans_int_binop(fx, bin_op, in_lhs, in_rhs),\n+        ty::Float(_) => crate::num::trans_float_binop(fx, bin_op, in_lhs, in_rhs),\n+        ty::RawPtr(..) | ty::FnPtr(..) => crate::num::trans_ptr_binop(fx, bin_op, in_lhs, in_rhs),\n+        _ => unreachable!(\n+            \"{:?}({:?}, {:?})\",\n+            bin_op,\n+            in_lhs.layout().ty,\n+            in_rhs.layout().ty\n+        ),\n+    }\n+}\n+\n+pub(crate) fn trans_bool_binop<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    bin_op: BinOp,\n+    in_lhs: CValue<'tcx>,\n+    in_rhs: CValue<'tcx>,\n+) -> CValue<'tcx> {\n+    let lhs = in_lhs.load_scalar(fx);\n+    let rhs = in_rhs.load_scalar(fx);\n+\n+    let b = fx.bcx.ins();\n+    let res = match bin_op {\n+        BinOp::BitXor => b.bxor(lhs, rhs),\n+        BinOp::BitAnd => b.band(lhs, rhs),\n+        BinOp::BitOr => b.bor(lhs, rhs),\n+        // Compare binops handles by `codegen_binop`.\n+        _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs, in_rhs),\n+    };\n+\n+    CValue::by_val(res, fx.layout_of(fx.tcx.types.bool))\n+}\n+\n+pub(crate) fn trans_int_binop<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    bin_op: BinOp,\n+    in_lhs: CValue<'tcx>,\n+    in_rhs: CValue<'tcx>,\n+) -> CValue<'tcx> {\n+    if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n+        assert_eq!(\n+            in_lhs.layout().ty,\n+            in_rhs.layout().ty,\n+            \"int binop requires lhs and rhs of same type\"\n+        );\n+    }\n+\n+    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, false, in_lhs, in_rhs) {\n+        return res;\n+    }\n+\n+    let signed = type_sign(in_lhs.layout().ty);\n+\n+    let lhs = in_lhs.load_scalar(fx);\n+    let rhs = in_rhs.load_scalar(fx);\n+\n+    let b = fx.bcx.ins();\n+    let val = match bin_op {\n+        BinOp::Add => b.iadd(lhs, rhs),\n+        BinOp::Sub => b.isub(lhs, rhs),\n+        BinOp::Mul => b.imul(lhs, rhs),\n+        BinOp::Div => {\n+            if signed {\n+                b.sdiv(lhs, rhs)\n+            } else {\n+                b.udiv(lhs, rhs)\n+            }\n+        }\n+        BinOp::Rem => {\n+            if signed {\n+                b.srem(lhs, rhs)\n+            } else {\n+                b.urem(lhs, rhs)\n+            }\n+        }\n+        BinOp::BitXor => b.bxor(lhs, rhs),\n+        BinOp::BitAnd => b.band(lhs, rhs),\n+        BinOp::BitOr => b.bor(lhs, rhs),\n+        BinOp::Shl => {\n+            let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n+            let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n+            let actual_shift = clif_intcast(fx, actual_shift, types::I8, false);\n+            fx.bcx.ins().ishl(lhs, actual_shift)\n+        }\n+        BinOp::Shr => {\n+            let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n+            let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n+            let actual_shift = clif_intcast(fx, actual_shift, types::I8, false);\n+            if signed {\n+                fx.bcx.ins().sshr(lhs, actual_shift)\n+            } else {\n+                fx.bcx.ins().ushr(lhs, actual_shift)\n+            }\n+        }\n+        // Compare binops handles by `codegen_binop`.\n+        _ => unreachable!(\n+            \"{:?}({:?}, {:?})\",\n+            bin_op,\n+            in_lhs.layout().ty,\n+            in_rhs.layout().ty\n+        ),\n+    };\n+\n+    CValue::by_val(val, in_lhs.layout())\n+}\n+\n+pub(crate) fn trans_checked_int_binop<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    bin_op: BinOp,\n+    in_lhs: CValue<'tcx>,\n+    in_rhs: CValue<'tcx>,\n+) -> CValue<'tcx> {\n+    if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n+        assert_eq!(\n+            in_lhs.layout().ty,\n+            in_rhs.layout().ty,\n+            \"checked int binop requires lhs and rhs of same type\"\n+        );\n+    }\n+\n+    let lhs = in_lhs.load_scalar(fx);\n+    let rhs = in_rhs.load_scalar(fx);\n+\n+    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, true, in_lhs, in_rhs) {\n+        return res;\n+    }\n+\n+    let signed = type_sign(in_lhs.layout().ty);\n+\n+    let (res, has_overflow) = match bin_op {\n+        BinOp::Add => {\n+            /*let (val, c_out) = fx.bcx.ins().iadd_cout(lhs, rhs);\n+            (val, c_out)*/\n+            // FIXME(CraneStation/cranelift#849) legalize iadd_cout for i8 and i16\n+            let val = fx.bcx.ins().iadd(lhs, rhs);\n+            let has_overflow = if !signed {\n+                fx.bcx.ins().icmp(IntCC::UnsignedLessThan, val, lhs)\n+            } else {\n+                let rhs_is_negative = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, rhs, 0);\n+                let slt = fx.bcx.ins().icmp(IntCC::SignedLessThan, val, lhs);\n+                fx.bcx.ins().bxor(rhs_is_negative, slt)\n+            };\n+            (val, has_overflow)\n+        }\n+        BinOp::Sub => {\n+            /*let (val, b_out) = fx.bcx.ins().isub_bout(lhs, rhs);\n+            (val, b_out)*/\n+            // FIXME(CraneStation/cranelift#849) legalize isub_bout for i8 and i16\n+            let val = fx.bcx.ins().isub(lhs, rhs);\n+            let has_overflow = if !signed {\n+                fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, val, lhs)\n+            } else {\n+                let rhs_is_negative = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, rhs, 0);\n+                let sgt = fx.bcx.ins().icmp(IntCC::SignedGreaterThan, val, lhs);\n+                fx.bcx.ins().bxor(rhs_is_negative, sgt)\n+            };\n+            (val, has_overflow)\n+        }\n+        BinOp::Mul => {\n+            let ty = fx.bcx.func.dfg.value_type(lhs);\n+            match ty {\n+                types::I8 | types::I16 | types::I32 if !signed => {\n+                    let lhs = fx.bcx.ins().uextend(ty.double_width().unwrap(), lhs);\n+                    let rhs = fx.bcx.ins().uextend(ty.double_width().unwrap(), rhs);\n+                    let val = fx.bcx.ins().imul(lhs, rhs);\n+                    let has_overflow = fx.bcx.ins().icmp_imm(\n+                        IntCC::UnsignedGreaterThan,\n+                        val,\n+                        (1 << ty.bits()) - 1,\n+                    );\n+                    let val = fx.bcx.ins().ireduce(ty, val);\n+                    (val, has_overflow)\n+                }\n+                types::I8 | types::I16 | types::I32 if signed => {\n+                    let lhs = fx.bcx.ins().sextend(ty.double_width().unwrap(), lhs);\n+                    let rhs = fx.bcx.ins().sextend(ty.double_width().unwrap(), rhs);\n+                    let val = fx.bcx.ins().imul(lhs, rhs);\n+                    let has_underflow =\n+                        fx.bcx\n+                            .ins()\n+                            .icmp_imm(IntCC::SignedLessThan, val, -(1 << (ty.bits() - 1)));\n+                    let has_overflow = fx.bcx.ins().icmp_imm(\n+                        IntCC::SignedGreaterThan,\n+                        val,\n+                        (1 << (ty.bits() - 1)) - 1,\n+                    );\n+                    let val = fx.bcx.ins().ireduce(ty, val);\n+                    (val, fx.bcx.ins().bor(has_underflow, has_overflow))\n+                }\n+                types::I64 => {\n+                    //let val = fx.easy_call(\"__mulodi4\", &[lhs, rhs, overflow_ptr], types::I64);\n+                    let val = fx.bcx.ins().imul(lhs, rhs);\n+                    let has_overflow = if !signed {\n+                        let val_hi = fx.bcx.ins().umulhi(lhs, rhs);\n+                        fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, 0)\n+                    } else {\n+                        let val_hi = fx.bcx.ins().smulhi(lhs, rhs);\n+                        let not_all_zero = fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, 0);\n+                        let not_all_ones = fx.bcx.ins().icmp_imm(\n+                            IntCC::NotEqual,\n+                            val_hi,\n+                            u64::try_from((1u128 << ty.bits()) - 1).unwrap() as i64,\n+                        );\n+                        fx.bcx.ins().band(not_all_zero, not_all_ones)\n+                    };\n+                    (val, has_overflow)\n+                }\n+                types::I128 => {\n+                    unreachable!(\"i128 should have been handled by codegen_i128::maybe_codegen\")\n+                }\n+                _ => unreachable!(\"invalid non-integer type {}\", ty),\n+            }\n+        }\n+        BinOp::Shl => {\n+            let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n+            let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n+            let actual_shift = clif_intcast(fx, actual_shift, types::I8, false);\n+            let val = fx.bcx.ins().ishl(lhs, actual_shift);\n+            let ty = fx.bcx.func.dfg.value_type(val);\n+            let max_shift = i64::from(ty.bits()) - 1;\n+            let has_overflow = fx\n+                .bcx\n+                .ins()\n+                .icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n+            (val, has_overflow)\n+        }\n+        BinOp::Shr => {\n+            let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n+            let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n+            let actual_shift = clif_intcast(fx, actual_shift, types::I8, false);\n+            let val = if !signed {\n+                fx.bcx.ins().ushr(lhs, actual_shift)\n+            } else {\n+                fx.bcx.ins().sshr(lhs, actual_shift)\n+            };\n+            let ty = fx.bcx.func.dfg.value_type(val);\n+            let max_shift = i64::from(ty.bits()) - 1;\n+            let has_overflow = fx\n+                .bcx\n+                .ins()\n+                .icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n+            (val, has_overflow)\n+        }\n+        _ => bug!(\n+            \"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\",\n+            bin_op,\n+            in_lhs,\n+            in_rhs\n+        ),\n+    };\n+\n+    let has_overflow = fx.bcx.ins().bint(types::I8, has_overflow);\n+\n+    // FIXME directly write to result place instead\n+    let out_place = CPlace::new_stack_slot(\n+        fx,\n+        fx.layout_of(\n+            fx.tcx\n+                .mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()),\n+        ),\n+    );\n+    let out_layout = out_place.layout();\n+    out_place.write_cvalue(fx, CValue::by_val_pair(res, has_overflow, out_layout));\n+\n+    out_place.to_cvalue(fx)\n+}\n+\n+pub(crate) fn trans_float_binop<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    bin_op: BinOp,\n+    in_lhs: CValue<'tcx>,\n+    in_rhs: CValue<'tcx>,\n+) -> CValue<'tcx> {\n+    assert_eq!(in_lhs.layout().ty, in_rhs.layout().ty);\n+\n+    let lhs = in_lhs.load_scalar(fx);\n+    let rhs = in_rhs.load_scalar(fx);\n+\n+    let b = fx.bcx.ins();\n+    let res = match bin_op {\n+        BinOp::Add => b.fadd(lhs, rhs),\n+        BinOp::Sub => b.fsub(lhs, rhs),\n+        BinOp::Mul => b.fmul(lhs, rhs),\n+        BinOp::Div => b.fdiv(lhs, rhs),\n+        BinOp::Rem => {\n+            let name = match in_lhs.layout().ty.kind() {\n+                ty::Float(FloatTy::F32) => \"fmodf\",\n+                ty::Float(FloatTy::F64) => \"fmod\",\n+                _ => bug!(),\n+            };\n+            return fx.easy_call(name, &[in_lhs, in_rhs], in_lhs.layout().ty);\n+        }\n+        BinOp::Eq | BinOp::Lt | BinOp::Le | BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n+            let fltcc = match bin_op {\n+                BinOp::Eq => FloatCC::Equal,\n+                BinOp::Lt => FloatCC::LessThan,\n+                BinOp::Le => FloatCC::LessThanOrEqual,\n+                BinOp::Ne => FloatCC::NotEqual,\n+                BinOp::Ge => FloatCC::GreaterThanOrEqual,\n+                BinOp::Gt => FloatCC::GreaterThan,\n+                _ => unreachable!(),\n+            };\n+            let val = fx.bcx.ins().fcmp(fltcc, lhs, rhs);\n+            let val = fx.bcx.ins().bint(types::I8, val);\n+            return CValue::by_val(val, fx.layout_of(fx.tcx.types.bool));\n+        }\n+        _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs, in_rhs),\n+    };\n+\n+    CValue::by_val(res, in_lhs.layout())\n+}\n+\n+pub(crate) fn trans_ptr_binop<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    bin_op: BinOp,\n+    in_lhs: CValue<'tcx>,\n+    in_rhs: CValue<'tcx>,\n+) -> CValue<'tcx> {\n+    let is_thin_ptr = in_lhs\n+        .layout()\n+        .ty\n+        .builtin_deref(true)\n+        .map(|TypeAndMut { ty, mutbl: _ }| !has_ptr_meta(fx.tcx, ty))\n+        .unwrap_or(true);\n+\n+    if is_thin_ptr {\n+        match bin_op {\n+            BinOp::Eq | BinOp::Lt | BinOp::Le | BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n+                let lhs = in_lhs.load_scalar(fx);\n+                let rhs = in_rhs.load_scalar(fx);\n+\n+                return codegen_compare_bin_op(fx, bin_op, false, lhs, rhs);\n+            }\n+            BinOp::Offset => {\n+                let pointee_ty = in_lhs.layout().ty.builtin_deref(true).unwrap().ty;\n+                let (base, offset) = (in_lhs, in_rhs.load_scalar(fx));\n+                let pointee_size = fx.layout_of(pointee_ty).size.bytes();\n+                let ptr_diff = fx.bcx.ins().imul_imm(offset, pointee_size as i64);\n+                let base_val = base.load_scalar(fx);\n+                let res = fx.bcx.ins().iadd(base_val, ptr_diff);\n+                return CValue::by_val(res, base.layout());\n+            }\n+            _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs, in_rhs),\n+        };\n+    } else {\n+        let (lhs_ptr, lhs_extra) = in_lhs.load_scalar_pair(fx);\n+        let (rhs_ptr, rhs_extra) = in_rhs.load_scalar_pair(fx);\n+\n+        let res = match bin_op {\n+            BinOp::Eq => {\n+                let ptr_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_ptr, rhs_ptr);\n+                let extra_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_extra, rhs_extra);\n+                fx.bcx.ins().band(ptr_eq, extra_eq)\n+            }\n+            BinOp::Ne => {\n+                let ptr_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_ptr, rhs_ptr);\n+                let extra_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_extra, rhs_extra);\n+                fx.bcx.ins().bor(ptr_ne, extra_ne)\n+            }\n+            BinOp::Lt | BinOp::Le | BinOp::Ge | BinOp::Gt => {\n+                let ptr_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_ptr, rhs_ptr);\n+\n+                let ptr_cmp =\n+                    fx.bcx\n+                        .ins()\n+                        .icmp(bin_op_to_intcc(bin_op, false).unwrap(), lhs_ptr, rhs_ptr);\n+                let extra_cmp = fx.bcx.ins().icmp(\n+                    bin_op_to_intcc(bin_op, false).unwrap(),\n+                    lhs_extra,\n+                    rhs_extra,\n+                );\n+\n+                fx.bcx.ins().select(ptr_eq, extra_cmp, ptr_cmp)\n+            }\n+            _ => panic!(\"bin_op {:?} on ptr\", bin_op),\n+        };\n+\n+        CValue::by_val(\n+            fx.bcx.ins().bint(types::I8, res),\n+            fx.layout_of(fx.tcx.types.bool),\n+        )\n+    }\n+}"}, {"sha": "f02732014d1e3e44e2bcf63b58edf7e53b145486", "filename": "compiler/rustc_codegen_cranelift/src/optimize/code_layout.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,40 @@\n+//! This optimization moves cold code to the end of the function.\n+//!\n+//! Some code is executed much less often than other code. For example panicking or the\n+//! landingpads for unwinding. By moving this cold code to the end of the function the average\n+//! amount of jumps is reduced and the code locality is improved.\n+//!\n+//! # Undefined behaviour\n+//!\n+//! This optimization doesn't assume anything that isn't already assumed by Cranelift itself.\n+\n+use crate::prelude::*;\n+\n+pub(super) fn optimize_function(ctx: &mut Context, cold_blocks: &EntitySet<Block>) {\n+    // FIXME Move the block in place instead of remove and append once\n+    // bytecodealliance/cranelift#1339 is implemented.\n+\n+    let mut block_insts = FxHashMap::default();\n+    for block in cold_blocks\n+        .keys()\n+        .filter(|&block| cold_blocks.contains(block))\n+    {\n+        let insts = ctx.func.layout.block_insts(block).collect::<Vec<_>>();\n+        for &inst in &insts {\n+            ctx.func.layout.remove_inst(inst);\n+        }\n+        block_insts.insert(block, insts);\n+        ctx.func.layout.remove_block(block);\n+    }\n+\n+    // And then append them at the back again.\n+    for block in cold_blocks\n+        .keys()\n+        .filter(|&block| cold_blocks.contains(block))\n+    {\n+        ctx.func.layout.append_block(block);\n+        for inst in block_insts.remove(&block).unwrap() {\n+            ctx.func.layout.append_inst(inst, block);\n+        }\n+    }\n+}"}, {"sha": "3ce7f8cd9a8315b527dc91bc20dcbacfefe9c588", "filename": "compiler/rustc_codegen_cranelift/src/optimize/mod.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,25 @@\n+//! Various optimizations specific to cg_clif\n+\n+use crate::prelude::*;\n+\n+mod code_layout;\n+pub(crate) mod peephole;\n+mod stack2reg;\n+\n+pub(crate) fn optimize_function<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    instance: Instance<'tcx>,\n+    ctx: &mut Context,\n+    cold_blocks: &EntitySet<Block>,\n+    clif_comments: &mut crate::pretty_clif::CommentWriter,\n+) {\n+    // The code_layout optimization is very cheap.\n+    self::code_layout::optimize_function(ctx, cold_blocks);\n+\n+    if tcx.sess.opts.optimize == rustc_session::config::OptLevel::No {\n+        return; // FIXME classify optimizations over opt levels\n+    }\n+    self::stack2reg::optimize_function(ctx, clif_comments);\n+    crate::pretty_clif::write_clif_file(tcx, \"stack2reg\", None, instance, &ctx, &*clif_comments);\n+    crate::base::verify_func(tcx, &*clif_comments, &ctx.func);\n+}"}, {"sha": "f8e0f3af3d0ad08587559bebef6972e540ea684f", "filename": "compiler/rustc_codegen_cranelift/src/optimize/peephole.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,83 @@\n+//! Peephole optimizations that can be performed while creating clif ir.\n+\n+use cranelift_codegen::ir::{\n+    condcodes::IntCC, types, InstBuilder, InstructionData, Opcode, Value, ValueDef,\n+};\n+use cranelift_frontend::FunctionBuilder;\n+\n+/// If the given value was produced by a `bint` instruction, return it's input, otherwise return the\n+/// given value.\n+pub(crate) fn maybe_unwrap_bint(bcx: &mut FunctionBuilder<'_>, arg: Value) -> Value {\n+    if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n+        match bcx.func.dfg[arg_inst] {\n+            InstructionData::Unary {\n+                opcode: Opcode::Bint,\n+                arg,\n+            } => arg,\n+            _ => arg,\n+        }\n+    } else {\n+        arg\n+    }\n+}\n+\n+/// If the given value was produced by the lowering of `Rvalue::Not` return the input and true,\n+/// otherwise return the given value and false.\n+pub(crate) fn maybe_unwrap_bool_not(bcx: &mut FunctionBuilder<'_>, arg: Value) -> (Value, bool) {\n+    if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n+        match bcx.func.dfg[arg_inst] {\n+            // This is the lowering of `Rvalue::Not`\n+            InstructionData::IntCompareImm {\n+                opcode: Opcode::IcmpImm,\n+                cond: IntCC::Equal,\n+                arg,\n+                imm,\n+            } if imm.bits() == 0 => (arg, true),\n+            _ => (arg, false),\n+        }\n+    } else {\n+        (arg, false)\n+    }\n+}\n+\n+pub(crate) fn make_branchable_value(bcx: &mut FunctionBuilder<'_>, arg: Value) -> Value {\n+    if bcx.func.dfg.value_type(arg).is_bool() {\n+        return arg;\n+    }\n+\n+    (|| {\n+        let arg_inst = if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n+            arg_inst\n+        } else {\n+            return None;\n+        };\n+\n+        match bcx.func.dfg[arg_inst] {\n+            // This is the lowering of Rvalue::Not\n+            InstructionData::Load {\n+                opcode: Opcode::Load,\n+                arg: ptr,\n+                flags,\n+                offset,\n+            } => {\n+                // Using `load.i8 + uextend.i32` would legalize to `uload8 + ireduce.i8 +\n+                // uextend.i32`. Just `uload8` is much faster.\n+                match bcx.func.dfg.ctrl_typevar(arg_inst) {\n+                    types::I8 => Some(bcx.ins().uload8(types::I32, flags, ptr, offset)),\n+                    types::I16 => Some(bcx.ins().uload16(types::I32, flags, ptr, offset)),\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        }\n+    })()\n+    .unwrap_or_else(|| {\n+        match bcx.func.dfg.value_type(arg) {\n+            types::I8 | types::I32 => {\n+                // WORKAROUND for brz.i8 and brnz.i8 not yet being implemented\n+                bcx.ins().uextend(types::I32, arg)\n+            }\n+            _ => arg,\n+        }\n+    })\n+}"}, {"sha": "f368d65f7f8d8adf1d84c899547ab8ed1af20fd9", "filename": "compiler/rustc_codegen_cranelift/src/optimize/stack2reg.rs", "status": "added", "additions": 507, "deletions": 0, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,507 @@\n+//! This optimization replaces stack accesses with SSA variables and removes dead stores when possible.\n+//!\n+//! # Undefined behaviour\n+//!\n+//! This optimization is based on the assumption that stack slots which don't have their address\n+//! leaked through `stack_addr` are only accessed using `stack_load` and `stack_store` in the\n+//! function which has the stack slots. This optimization also assumes that stack slot accesses\n+//! are never out of bounds. If these assumptions are not correct, then this optimization may remove\n+//! `stack_store` instruction incorrectly, or incorrectly use a previously stored value as the value\n+//! being loaded by a `stack_load`.\n+\n+use std::collections::BTreeMap;\n+use std::fmt;\n+use std::ops::Not;\n+\n+use rustc_data_structures::fx::FxHashSet;\n+\n+use cranelift_codegen::cursor::{Cursor, FuncCursor};\n+use cranelift_codegen::ir::immediates::Offset32;\n+use cranelift_codegen::ir::{InstructionData, Opcode, ValueDef};\n+\n+use crate::prelude::*;\n+\n+/// Workaround for `StackSlot` not implementing `Ord`.\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+struct OrdStackSlot(StackSlot);\n+\n+impl fmt::Debug for OrdStackSlot {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?}\", self.0)\n+    }\n+}\n+\n+impl PartialOrd for OrdStackSlot {\n+    fn partial_cmp(&self, rhs: &Self) -> Option<std::cmp::Ordering> {\n+        self.0.as_u32().partial_cmp(&rhs.0.as_u32())\n+    }\n+}\n+\n+impl Ord for OrdStackSlot {\n+    fn cmp(&self, rhs: &Self) -> std::cmp::Ordering {\n+        self.0.as_u32().cmp(&rhs.0.as_u32())\n+    }\n+}\n+\n+#[derive(Debug, Default)]\n+struct StackSlotUsage {\n+    stack_addr: FxHashSet<Inst>,\n+    stack_load: FxHashSet<Inst>,\n+    stack_store: FxHashSet<Inst>,\n+}\n+\n+impl StackSlotUsage {\n+    fn potential_stores_for_load(&self, ctx: &Context, load: Inst) -> Vec<Inst> {\n+        self.stack_store\n+            .iter()\n+            .cloned()\n+            .filter(|&store| {\n+                match spatial_overlap(&ctx.func, store, load) {\n+                    SpatialOverlap::No => false, // Can never be the source of the loaded value.\n+                    SpatialOverlap::Partial | SpatialOverlap::Full => true,\n+                }\n+            })\n+            .filter(|&store| {\n+                match temporal_order(ctx, store, load) {\n+                    TemporalOrder::NeverBefore => false, // Can never be the source of the loaded value.\n+                    TemporalOrder::MaybeBefore | TemporalOrder::DefinitivelyBefore => true,\n+                }\n+            })\n+            .collect::<Vec<Inst>>()\n+    }\n+\n+    fn potential_loads_of_store(&self, ctx: &Context, store: Inst) -> Vec<Inst> {\n+        self.stack_load\n+            .iter()\n+            .cloned()\n+            .filter(|&load| {\n+                match spatial_overlap(&ctx.func, store, load) {\n+                    SpatialOverlap::No => false, // Can never be the source of the loaded value.\n+                    SpatialOverlap::Partial | SpatialOverlap::Full => true,\n+                }\n+            })\n+            .filter(|&load| {\n+                match temporal_order(ctx, store, load) {\n+                    TemporalOrder::NeverBefore => false, // Can never be the source of the loaded value.\n+                    TemporalOrder::MaybeBefore | TemporalOrder::DefinitivelyBefore => true,\n+                }\n+            })\n+            .collect::<Vec<Inst>>()\n+    }\n+\n+    fn remove_unused_stack_addr(func: &mut Function, inst: Inst) {\n+        func.dfg.detach_results(inst);\n+        func.dfg.replace(inst).nop();\n+    }\n+\n+    fn remove_unused_load(func: &mut Function, load: Inst) {\n+        func.dfg.detach_results(load);\n+        func.dfg.replace(load).nop();\n+    }\n+\n+    fn remove_dead_store(&mut self, func: &mut Function, store: Inst) {\n+        func.dfg.replace(store).nop();\n+        self.stack_store.remove(&store);\n+    }\n+\n+    fn change_load_to_alias(&mut self, func: &mut Function, load: Inst, value: Value) {\n+        let loaded_value = func.dfg.inst_results(load)[0];\n+        let loaded_type = func.dfg.value_type(loaded_value);\n+\n+        if func.dfg.value_type(value) == loaded_type {\n+            func.dfg.detach_results(load);\n+            func.dfg.replace(load).nop();\n+            func.dfg.change_to_alias(loaded_value, value);\n+        } else {\n+            func.dfg.replace(load).bitcast(loaded_type, value);\n+        }\n+\n+        self.stack_load.remove(&load);\n+    }\n+}\n+\n+struct OptimizeContext<'a> {\n+    ctx: &'a mut Context,\n+    stack_slot_usage_map: BTreeMap<OrdStackSlot, StackSlotUsage>,\n+}\n+\n+impl<'a> OptimizeContext<'a> {\n+    fn for_context(ctx: &'a mut Context) -> Self {\n+        ctx.flowgraph(); // Compute cfg and domtree.\n+\n+        // Record all stack_addr, stack_load and stack_store instructions.\n+        let mut stack_slot_usage_map = BTreeMap::<OrdStackSlot, StackSlotUsage>::new();\n+\n+        let mut cursor = FuncCursor::new(&mut ctx.func);\n+        while let Some(_block) = cursor.next_block() {\n+            while let Some(inst) = cursor.next_inst() {\n+                match cursor.func.dfg[inst] {\n+                    InstructionData::StackLoad {\n+                        opcode: Opcode::StackAddr,\n+                        stack_slot,\n+                        offset: _,\n+                    } => {\n+                        stack_slot_usage_map\n+                            .entry(OrdStackSlot(stack_slot))\n+                            .or_insert_with(StackSlotUsage::default)\n+                            .stack_addr\n+                            .insert(inst);\n+                    }\n+                    InstructionData::StackLoad {\n+                        opcode: Opcode::StackLoad,\n+                        stack_slot,\n+                        offset: _,\n+                    } => {\n+                        stack_slot_usage_map\n+                            .entry(OrdStackSlot(stack_slot))\n+                            .or_insert_with(StackSlotUsage::default)\n+                            .stack_load\n+                            .insert(inst);\n+                    }\n+                    InstructionData::StackStore {\n+                        opcode: Opcode::StackStore,\n+                        arg: _,\n+                        stack_slot,\n+                        offset: _,\n+                    } => {\n+                        stack_slot_usage_map\n+                            .entry(OrdStackSlot(stack_slot))\n+                            .or_insert_with(StackSlotUsage::default)\n+                            .stack_store\n+                            .insert(inst);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+\n+        OptimizeContext {\n+            ctx,\n+            stack_slot_usage_map,\n+        }\n+    }\n+}\n+\n+pub(super) fn optimize_function(\n+    ctx: &mut Context,\n+    #[cfg_attr(not(debug_assertions), allow(unused_variables))] clif_comments: &mut crate::pretty_clif::CommentWriter,\n+) {\n+    combine_stack_addr_with_load_store(&mut ctx.func);\n+\n+    let mut opt_ctx = OptimizeContext::for_context(ctx);\n+\n+    // FIXME Repeat following instructions until fixpoint.\n+\n+    remove_unused_stack_addr_and_stack_load(&mut opt_ctx);\n+\n+    #[cfg(debug_assertions)]\n+    {\n+        for (&OrdStackSlot(stack_slot), usage) in &opt_ctx.stack_slot_usage_map {\n+            clif_comments.add_comment(stack_slot, format!(\"used by: {:?}\", usage));\n+        }\n+    }\n+\n+    for (stack_slot, users) in opt_ctx.stack_slot_usage_map.iter_mut() {\n+        if users.stack_addr.is_empty().not() {\n+            // Stack addr leaked; there may be unknown loads and stores.\n+            // FIXME use stacked borrows to optimize\n+            continue;\n+        }\n+\n+        for load in users.stack_load.clone().into_iter() {\n+            let potential_stores = users.potential_stores_for_load(&opt_ctx.ctx, load);\n+\n+            #[cfg(debug_assertions)]\n+            for &store in &potential_stores {\n+                clif_comments.add_comment(\n+                    load,\n+                    format!(\n+                        \"Potential store -> load forwarding {} -> {} ({:?}, {:?})\",\n+                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                        opt_ctx.ctx.func.dfg.display_inst(load, None),\n+                        spatial_overlap(&opt_ctx.ctx.func, store, load),\n+                        temporal_order(&opt_ctx.ctx, store, load),\n+                    ),\n+                );\n+            }\n+\n+            match *potential_stores {\n+                [] => {\n+                    #[cfg(debug_assertions)]\n+                    clif_comments.add_comment(load, format!(\"[BUG?] Reading uninitialized memory\"));\n+                }\n+                [store]\n+                    if spatial_overlap(&opt_ctx.ctx.func, store, load) == SpatialOverlap::Full\n+                        && temporal_order(&opt_ctx.ctx, store, load)\n+                            == TemporalOrder::DefinitivelyBefore =>\n+                {\n+                    // Only one store could have been the origin of the value.\n+                    let stored_value = opt_ctx.ctx.func.dfg.inst_args(store)[0];\n+\n+                    #[cfg(debug_assertions)]\n+                    clif_comments\n+                        .add_comment(load, format!(\"Store to load forward {} -> {}\", store, load));\n+\n+                    users.change_load_to_alias(&mut opt_ctx.ctx.func, load, stored_value);\n+                }\n+                _ => {} // FIXME implement this\n+            }\n+        }\n+\n+        for store in users.stack_store.clone().into_iter() {\n+            let potential_loads = users.potential_loads_of_store(&opt_ctx.ctx, store);\n+\n+            #[cfg(debug_assertions)]\n+            for &load in &potential_loads {\n+                clif_comments.add_comment(\n+                    store,\n+                    format!(\n+                        \"Potential load from store {} <- {} ({:?}, {:?})\",\n+                        opt_ctx.ctx.func.dfg.display_inst(load, None),\n+                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                        spatial_overlap(&opt_ctx.ctx.func, store, load),\n+                        temporal_order(&opt_ctx.ctx, store, load),\n+                    ),\n+                );\n+            }\n+\n+            if potential_loads.is_empty() {\n+                // Never loaded; can safely remove all stores and the stack slot.\n+                // FIXME also remove stores when there is always a next store before a load.\n+\n+                #[cfg(debug_assertions)]\n+                clif_comments.add_comment(\n+                    store,\n+                    format!(\n+                        \"Remove dead stack store {} of {}\",\n+                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                        stack_slot.0\n+                    ),\n+                );\n+\n+                users.remove_dead_store(&mut opt_ctx.ctx.func, store);\n+            }\n+        }\n+\n+        if users.stack_store.is_empty() && users.stack_load.is_empty() {\n+            opt_ctx.ctx.func.stack_slots[stack_slot.0].size = 0;\n+        }\n+    }\n+}\n+\n+fn combine_stack_addr_with_load_store(func: &mut Function) {\n+    // Turn load and store into stack_load and stack_store when possible.\n+    let mut cursor = FuncCursor::new(func);\n+    while let Some(_block) = cursor.next_block() {\n+        while let Some(inst) = cursor.next_inst() {\n+            match cursor.func.dfg[inst] {\n+                InstructionData::Load {\n+                    opcode: Opcode::Load,\n+                    arg: addr,\n+                    flags: _,\n+                    offset,\n+                } => {\n+                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128\n+                        || cursor.func.dfg.ctrl_typevar(inst).is_vector()\n+                    {\n+                        continue; // WORKAROUD: stack_load.i128 not yet implemented\n+                    }\n+                    if let Some((stack_slot, stack_addr_offset)) =\n+                        try_get_stack_slot_and_offset_for_addr(cursor.func, addr)\n+                    {\n+                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into())\n+                        {\n+                            let ty = cursor.func.dfg.ctrl_typevar(inst);\n+                            cursor.func.dfg.replace(inst).stack_load(\n+                                ty,\n+                                stack_slot,\n+                                combined_offset,\n+                            );\n+                        }\n+                    }\n+                }\n+                InstructionData::Store {\n+                    opcode: Opcode::Store,\n+                    args: [value, addr],\n+                    flags: _,\n+                    offset,\n+                } => {\n+                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128\n+                        || cursor.func.dfg.ctrl_typevar(inst).is_vector()\n+                    {\n+                        continue; // WORKAROUND: stack_store.i128 not yet implemented\n+                    }\n+                    if let Some((stack_slot, stack_addr_offset)) =\n+                        try_get_stack_slot_and_offset_for_addr(cursor.func, addr)\n+                    {\n+                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into())\n+                        {\n+                            cursor.func.dfg.replace(inst).stack_store(\n+                                value,\n+                                stack_slot,\n+                                combined_offset,\n+                            );\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+}\n+\n+fn remove_unused_stack_addr_and_stack_load(opt_ctx: &mut OptimizeContext<'_>) {\n+    // FIXME incrementally rebuild on each call?\n+    let mut stack_addr_load_insts_users = FxHashMap::<Inst, FxHashSet<Inst>>::default();\n+\n+    let mut cursor = FuncCursor::new(&mut opt_ctx.ctx.func);\n+    while let Some(_block) = cursor.next_block() {\n+        while let Some(inst) = cursor.next_inst() {\n+            for &arg in cursor.func.dfg.inst_args(inst) {\n+                if let ValueDef::Result(arg_origin, 0) = cursor.func.dfg.value_def(arg) {\n+                    match cursor.func.dfg[arg_origin].opcode() {\n+                        Opcode::StackAddr | Opcode::StackLoad => {\n+                            stack_addr_load_insts_users\n+                                .entry(arg_origin)\n+                                .or_insert_with(FxHashSet::default)\n+                                .insert(inst);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[cfg(debug_assertions)]\n+    for inst in stack_addr_load_insts_users.keys() {\n+        let mut is_recorded_stack_addr_or_stack_load = false;\n+        for stack_slot_users in opt_ctx.stack_slot_usage_map.values() {\n+            is_recorded_stack_addr_or_stack_load |= stack_slot_users.stack_addr.contains(inst)\n+                || stack_slot_users.stack_load.contains(inst);\n+        }\n+        assert!(is_recorded_stack_addr_or_stack_load);\n+    }\n+\n+    // Replace all unused stack_addr and stack_load instructions with nop.\n+    let mut func = &mut opt_ctx.ctx.func;\n+\n+    for stack_slot_users in opt_ctx.stack_slot_usage_map.values_mut() {\n+        stack_slot_users\n+            .stack_addr\n+            .drain_filter(|inst| {\n+                stack_addr_load_insts_users\n+                    .get(inst)\n+                    .map(|users| users.is_empty())\n+                    .unwrap_or(true)\n+            })\n+            .for_each(|inst| StackSlotUsage::remove_unused_stack_addr(&mut func, inst));\n+\n+        stack_slot_users\n+            .stack_load\n+            .drain_filter(|inst| {\n+                stack_addr_load_insts_users\n+                    .get(inst)\n+                    .map(|users| users.is_empty())\n+                    .unwrap_or(true)\n+            })\n+            .for_each(|inst| StackSlotUsage::remove_unused_load(&mut func, inst));\n+    }\n+}\n+\n+fn try_get_stack_slot_and_offset_for_addr(\n+    func: &Function,\n+    addr: Value,\n+) -> Option<(StackSlot, Offset32)> {\n+    if let ValueDef::Result(addr_inst, 0) = func.dfg.value_def(addr) {\n+        if let InstructionData::StackLoad {\n+            opcode: Opcode::StackAddr,\n+            stack_slot,\n+            offset,\n+        } = func.dfg[addr_inst]\n+        {\n+            return Some((stack_slot, offset));\n+        }\n+    }\n+    None\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum SpatialOverlap {\n+    No,\n+    Partial,\n+    Full,\n+}\n+\n+fn spatial_overlap(func: &Function, src: Inst, dest: Inst) -> SpatialOverlap {\n+    fn inst_info(func: &Function, inst: Inst) -> (StackSlot, Offset32, u32) {\n+        match func.dfg[inst] {\n+            InstructionData::StackLoad {\n+                opcode: Opcode::StackAddr,\n+                stack_slot,\n+                offset,\n+            }\n+            | InstructionData::StackLoad {\n+                opcode: Opcode::StackLoad,\n+                stack_slot,\n+                offset,\n+            }\n+            | InstructionData::StackStore {\n+                opcode: Opcode::StackStore,\n+                stack_slot,\n+                offset,\n+                arg: _,\n+            } => (stack_slot, offset, func.dfg.ctrl_typevar(inst).bytes()),\n+            _ => unreachable!(\"{:?}\", func.dfg[inst]),\n+        }\n+    }\n+\n+    debug_assert_ne!(src, dest);\n+\n+    let (src_ss, src_offset, src_size) = inst_info(func, src);\n+    let (dest_ss, dest_offset, dest_size) = inst_info(func, dest);\n+\n+    if src_ss != dest_ss {\n+        return SpatialOverlap::No;\n+    }\n+\n+    if src_offset == dest_offset && src_size == dest_size {\n+        return SpatialOverlap::Full;\n+    }\n+\n+    let src_end: i64 = src_offset.try_add_i64(i64::from(src_size)).unwrap().into();\n+    let dest_end: i64 = dest_offset\n+        .try_add_i64(i64::from(dest_size))\n+        .unwrap()\n+        .into();\n+    if src_end <= dest_offset.into() || dest_end <= src_offset.into() {\n+        return SpatialOverlap::No;\n+    }\n+\n+    SpatialOverlap::Partial\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum TemporalOrder {\n+    /// `src` will never be executed before `dest`.\n+    NeverBefore,\n+\n+    /// `src` may be executed before `dest`.\n+    MaybeBefore,\n+\n+    /// `src` will always be executed before `dest`.\n+    /// There may still be other instructions in between.\n+    DefinitivelyBefore,\n+}\n+\n+fn temporal_order(ctx: &Context, src: Inst, dest: Inst) -> TemporalOrder {\n+    debug_assert_ne!(src, dest);\n+\n+    if ctx.domtree.dominates(src, dest, &ctx.func.layout) {\n+        TemporalOrder::DefinitivelyBefore\n+    } else if ctx.domtree.dominates(src, dest, &ctx.func.layout) {\n+        TemporalOrder::NeverBefore\n+    } else {\n+        TemporalOrder::MaybeBefore\n+    }\n+}"}, {"sha": "b2036d7bcd452e5918f4432348368c7271e83898", "filename": "compiler/rustc_codegen_cranelift/src/pointer.rs", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,206 @@\n+//! Defines [`Pointer`] which is used to improve the quality of the generated clif ir for pointer\n+//! operations.\n+\n+use crate::prelude::*;\n+\n+use rustc_target::abi::Align;\n+\n+use cranelift_codegen::ir::immediates::Offset32;\n+\n+/// A pointer pointing either to a certain address, a certain stack slot or nothing.\n+#[derive(Copy, Clone, Debug)]\n+pub(crate) struct Pointer {\n+    base: PointerBase,\n+    offset: Offset32,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub(crate) enum PointerBase {\n+    Addr(Value),\n+    Stack(StackSlot),\n+    Dangling(Align),\n+}\n+\n+impl Pointer {\n+    pub(crate) fn new(addr: Value) -> Self {\n+        Pointer {\n+            base: PointerBase::Addr(addr),\n+            offset: Offset32::new(0),\n+        }\n+    }\n+\n+    pub(crate) fn stack_slot(stack_slot: StackSlot) -> Self {\n+        Pointer {\n+            base: PointerBase::Stack(stack_slot),\n+            offset: Offset32::new(0),\n+        }\n+    }\n+\n+    pub(crate) fn const_addr<'a, 'tcx>(\n+        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n+        addr: i64,\n+    ) -> Self {\n+        let addr = fx.bcx.ins().iconst(fx.pointer_type, addr);\n+        Pointer {\n+            base: PointerBase::Addr(addr),\n+            offset: Offset32::new(0),\n+        }\n+    }\n+\n+    pub(crate) fn dangling(align: Align) -> Self {\n+        Pointer {\n+            base: PointerBase::Dangling(align),\n+            offset: Offset32::new(0),\n+        }\n+    }\n+\n+    #[cfg(debug_assertions)]\n+    pub(crate) fn base_and_offset(self) -> (PointerBase, Offset32) {\n+        (self.base, self.offset)\n+    }\n+\n+    pub(crate) fn get_addr<'a, 'tcx>(self, fx: &mut FunctionCx<'a, 'tcx, impl Module>) -> Value {\n+        match self.base {\n+            PointerBase::Addr(base_addr) => {\n+                let offset: i64 = self.offset.into();\n+                if offset == 0 {\n+                    base_addr\n+                } else {\n+                    fx.bcx.ins().iadd_imm(base_addr, offset)\n+                }\n+            }\n+            PointerBase::Stack(stack_slot) => {\n+                fx.bcx\n+                    .ins()\n+                    .stack_addr(fx.pointer_type, stack_slot, self.offset)\n+            }\n+            PointerBase::Dangling(align) => fx\n+                .bcx\n+                .ins()\n+                .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap()),\n+        }\n+    }\n+\n+    pub(crate) fn offset<'a, 'tcx>(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n+        extra_offset: Offset32,\n+    ) -> Self {\n+        self.offset_i64(fx, extra_offset.into())\n+    }\n+\n+    pub(crate) fn offset_i64<'a, 'tcx>(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n+        extra_offset: i64,\n+    ) -> Self {\n+        if let Some(new_offset) = self.offset.try_add_i64(extra_offset) {\n+            Pointer {\n+                base: self.base,\n+                offset: new_offset,\n+            }\n+        } else {\n+            let base_offset: i64 = self.offset.into();\n+            if let Some(new_offset) = base_offset.checked_add(extra_offset) {\n+                let base_addr = match self.base {\n+                    PointerBase::Addr(addr) => addr,\n+                    PointerBase::Stack(stack_slot) => {\n+                        fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0)\n+                    }\n+                    PointerBase::Dangling(align) => fx\n+                        .bcx\n+                        .ins()\n+                        .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap()),\n+                };\n+                let addr = fx.bcx.ins().iadd_imm(base_addr, new_offset);\n+                Pointer {\n+                    base: PointerBase::Addr(addr),\n+                    offset: Offset32::new(0),\n+                }\n+            } else {\n+                panic!(\n+                    \"self.offset ({}) + extra_offset ({}) not representable in i64\",\n+                    base_offset, extra_offset\n+                );\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn offset_value<'a, 'tcx>(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n+        extra_offset: Value,\n+    ) -> Self {\n+        match self.base {\n+            PointerBase::Addr(addr) => Pointer {\n+                base: PointerBase::Addr(fx.bcx.ins().iadd(addr, extra_offset)),\n+                offset: self.offset,\n+            },\n+            PointerBase::Stack(stack_slot) => {\n+                let base_addr = fx\n+                    .bcx\n+                    .ins()\n+                    .stack_addr(fx.pointer_type, stack_slot, self.offset);\n+                Pointer {\n+                    base: PointerBase::Addr(fx.bcx.ins().iadd(base_addr, extra_offset)),\n+                    offset: Offset32::new(0),\n+                }\n+            }\n+            PointerBase::Dangling(align) => {\n+                let addr = fx\n+                    .bcx\n+                    .ins()\n+                    .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap());\n+                Pointer {\n+                    base: PointerBase::Addr(fx.bcx.ins().iadd(addr, extra_offset)),\n+                    offset: self.offset,\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn load<'a, 'tcx>(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n+        ty: Type,\n+        flags: MemFlags,\n+    ) -> Value {\n+        match self.base {\n+            PointerBase::Addr(base_addr) => fx.bcx.ins().load(ty, flags, base_addr, self.offset),\n+            PointerBase::Stack(stack_slot) => {\n+                if ty == types::I128 || ty.is_vector() {\n+                    // WORKAROUND for stack_load.i128 and stack_load.iXxY not being implemented\n+                    let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n+                    fx.bcx.ins().load(ty, flags, base_addr, self.offset)\n+                } else {\n+                    fx.bcx.ins().stack_load(ty, stack_slot, self.offset)\n+                }\n+            }\n+            PointerBase::Dangling(_align) => unreachable!(),\n+        }\n+    }\n+\n+    pub(crate) fn store<'a, 'tcx>(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n+        value: Value,\n+        flags: MemFlags,\n+    ) {\n+        match self.base {\n+            PointerBase::Addr(base_addr) => {\n+                fx.bcx.ins().store(flags, value, base_addr, self.offset);\n+            }\n+            PointerBase::Stack(stack_slot) => {\n+                let val_ty = fx.bcx.func.dfg.value_type(value);\n+                if val_ty == types::I128 || val_ty.is_vector() {\n+                    // WORKAROUND for stack_store.i128 and stack_store.iXxY not being implemented\n+                    let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n+                    fx.bcx.ins().store(flags, value, base_addr, self.offset);\n+                } else {\n+                    fx.bcx.ins().stack_store(value, stack_slot, self.offset);\n+                }\n+            }\n+            PointerBase::Dangling(_align) => unreachable!(),\n+        }\n+    }\n+}"}, {"sha": "7f8ab953d7199d62b3f53914f50584e11aeb20ab", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,287 @@\n+//! This module provides the [CommentWriter] which makes it possible\n+//! to add comments to the written cranelift ir.\n+//!\n+//! # Example\n+//!\n+//! ```clif\n+//! test compile\n+//! target x86_64\n+//!\n+//! function u0:0(i64, i64, i64) system_v {\n+//! ; symbol _ZN119_$LT$example..IsNotEmpty$u20$as$u20$mini_core..FnOnce$LT$$LP$$RF$$u27$a$u20$$RF$$u27$b$u20$$u5b$u16$u5d$$C$$RP$$GT$$GT$9call_once17he85059d5e6a760a0E\n+//! ; instance Instance { def: Item(DefId(0/0:29 ~ example[8787]::{{impl}}[0]::call_once[0])), substs: [ReErased, ReErased] }\n+//! ; sig ([IsNotEmpty, (&&[u16],)]; c_variadic: false)->(u8, u8)\n+//!\n+//! ; ssa {_2: NOT_SSA, _4: NOT_SSA, _0: NOT_SSA, _3: (empty), _1: NOT_SSA}\n+//! ; msg   loc.idx    param    pass mode            ssa flags  ty\n+//! ; ret    _0      = v0       ByRef                NOT_SSA    (u8, u8)\n+//! ; arg    _1      = v1       ByRef                NOT_SSA    IsNotEmpty\n+//! ; arg    _2.0    = v2       ByVal(types::I64)    NOT_SSA    &&[u16]\n+//!\n+//!     ss0 = explicit_slot 0 ; _1: IsNotEmpty size=0 align=1,8\n+//!     ss1 = explicit_slot 8 ; _2: (&&[u16],) size=8 align=8,8\n+//!     ss2 = explicit_slot 8 ; _4: (&&[u16],) size=8 align=8,8\n+//!     sig0 = (i64, i64, i64) system_v\n+//!     sig1 = (i64, i64, i64) system_v\n+//!     fn0 = colocated u0:6 sig1 ; Instance { def: Item(DefId(0/0:31 ~ example[8787]::{{impl}}[1]::call_mut[0])), substs: [ReErased, ReErased] }\n+//!\n+//! block0(v0: i64, v1: i64, v2: i64):\n+//!     v3 = stack_addr.i64 ss0\n+//!     v4 = stack_addr.i64 ss1\n+//!     store v2, v4\n+//!     v5 = stack_addr.i64 ss2\n+//!     jump block1\n+//!\n+//! block1:\n+//!     nop\n+//! ; _3 = &mut _1\n+//! ; _4 = _2\n+//!     v6 = load.i64 v4\n+//!     store v6, v5\n+//! ;\n+//! ; _0 = const mini_core::FnMut::call_mut(move _3, move _4)\n+//!     v7 = load.i64 v5\n+//!     call fn0(v0, v3, v7)\n+//!     jump block2\n+//!\n+//! block2:\n+//!     nop\n+//! ;\n+//! ; return\n+//!     return\n+//! }\n+//! ```\n+\n+use std::fmt;\n+\n+use cranelift_codegen::{\n+    entity::SecondaryMap,\n+    ir::{entities::AnyEntity, function::DisplayFunctionAnnotations},\n+    write::{FuncWriter, PlainWriter},\n+};\n+\n+use rustc_session::config::OutputType;\n+\n+use crate::prelude::*;\n+\n+#[derive(Debug)]\n+pub(crate) struct CommentWriter {\n+    global_comments: Vec<String>,\n+    entity_comments: FxHashMap<AnyEntity, String>,\n+}\n+\n+impl CommentWriter {\n+    pub(crate) fn new<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n+        let global_comments = if cfg!(debug_assertions) {\n+            vec![\n+                format!(\"symbol {}\", tcx.symbol_name(instance).name),\n+                format!(\"instance {:?}\", instance),\n+                format!(\n+                    \"sig {:?}\",\n+                    tcx.normalize_erasing_late_bound_regions(\n+                        ParamEnv::reveal_all(),\n+                        &crate::abi::fn_sig_for_fn_abi(tcx, instance)\n+                    )\n+                ),\n+                String::new(),\n+            ]\n+        } else {\n+            vec![]\n+        };\n+\n+        CommentWriter {\n+            global_comments,\n+            entity_comments: FxHashMap::default(),\n+        }\n+    }\n+}\n+\n+#[cfg(debug_assertions)]\n+impl CommentWriter {\n+    pub(crate) fn add_global_comment<S: Into<String>>(&mut self, comment: S) {\n+        self.global_comments.push(comment.into());\n+    }\n+\n+    pub(crate) fn add_comment<S: Into<String> + AsRef<str>, E: Into<AnyEntity>>(\n+        &mut self,\n+        entity: E,\n+        comment: S,\n+    ) {\n+        use std::collections::hash_map::Entry;\n+        match self.entity_comments.entry(entity.into()) {\n+            Entry::Occupied(mut occ) => {\n+                occ.get_mut().push('\\n');\n+                occ.get_mut().push_str(comment.as_ref());\n+            }\n+            Entry::Vacant(vac) => {\n+                vac.insert(comment.into());\n+            }\n+        }\n+    }\n+}\n+\n+impl FuncWriter for &'_ CommentWriter {\n+    fn write_preamble(\n+        &mut self,\n+        w: &mut dyn fmt::Write,\n+        func: &Function,\n+        reg_info: Option<&isa::RegInfo>,\n+    ) -> Result<bool, fmt::Error> {\n+        for comment in &self.global_comments {\n+            if !comment.is_empty() {\n+                writeln!(w, \"; {}\", comment)?;\n+            } else {\n+                writeln!(w, \"\")?;\n+            }\n+        }\n+        if !self.global_comments.is_empty() {\n+            writeln!(w, \"\")?;\n+        }\n+\n+        self.super_preamble(w, func, reg_info)\n+    }\n+\n+    fn write_entity_definition(\n+        &mut self,\n+        w: &mut dyn fmt::Write,\n+        _func: &Function,\n+        entity: AnyEntity,\n+        value: &dyn fmt::Display,\n+    ) -> fmt::Result {\n+        write!(w, \"    {} = {}\", entity, value)?;\n+\n+        if let Some(comment) = self.entity_comments.get(&entity) {\n+            writeln!(w, \" ; {}\", comment.replace('\\n', \"\\n; \"))\n+        } else {\n+            writeln!(w, \"\")\n+        }\n+    }\n+\n+    fn write_block_header(\n+        &mut self,\n+        w: &mut dyn fmt::Write,\n+        func: &Function,\n+        isa: Option<&dyn isa::TargetIsa>,\n+        block: Block,\n+        indent: usize,\n+    ) -> fmt::Result {\n+        PlainWriter.write_block_header(w, func, isa, block, indent)\n+    }\n+\n+    fn write_instruction(\n+        &mut self,\n+        w: &mut dyn fmt::Write,\n+        func: &Function,\n+        aliases: &SecondaryMap<Value, Vec<Value>>,\n+        isa: Option<&dyn isa::TargetIsa>,\n+        inst: Inst,\n+        indent: usize,\n+    ) -> fmt::Result {\n+        PlainWriter.write_instruction(w, func, aliases, isa, inst, indent)?;\n+        if let Some(comment) = self.entity_comments.get(&inst.into()) {\n+            writeln!(w, \"; {}\", comment.replace('\\n', \"\\n; \"))?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(debug_assertions)]\n+impl<M: Module> FunctionCx<'_, '_, M> {\n+    pub(crate) fn add_global_comment<S: Into<String>>(&mut self, comment: S) {\n+        self.clif_comments.add_global_comment(comment);\n+    }\n+\n+    pub(crate) fn add_comment<S: Into<String> + AsRef<str>, E: Into<AnyEntity>>(\n+        &mut self,\n+        entity: E,\n+        comment: S,\n+    ) {\n+        self.clif_comments.add_comment(entity, comment);\n+    }\n+}\n+\n+pub(crate) fn write_clif_file<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    postfix: &str,\n+    isa: Option<&dyn cranelift_codegen::isa::TargetIsa>,\n+    instance: Instance<'tcx>,\n+    context: &cranelift_codegen::Context,\n+    mut clif_comments: &CommentWriter,\n+) {\n+    use std::io::Write;\n+\n+    if !cfg!(debug_assertions)\n+        && !tcx\n+            .sess\n+            .opts\n+            .output_types\n+            .contains_key(&OutputType::LlvmAssembly)\n+    {\n+        return;\n+    }\n+\n+    let value_ranges = isa.map(|isa| {\n+        context\n+            .build_value_labels_ranges(isa)\n+            .expect(\"value location ranges\")\n+    });\n+\n+    let clif_output_dir = tcx.output_filenames(LOCAL_CRATE).with_extension(\"clif\");\n+\n+    match std::fs::create_dir(&clif_output_dir) {\n+        Ok(()) => {}\n+        Err(err) if err.kind() == std::io::ErrorKind::AlreadyExists => {}\n+        res @ Err(_) => res.unwrap(),\n+    }\n+\n+    let clif_file_name = clif_output_dir.join(format!(\n+        \"{}.{}.clif\",\n+        tcx.symbol_name(instance).name,\n+        postfix\n+    ));\n+\n+    let mut clif = String::new();\n+    cranelift_codegen::write::decorate_function(\n+        &mut clif_comments,\n+        &mut clif,\n+        &context.func,\n+        &DisplayFunctionAnnotations {\n+            isa: Some(&*crate::build_isa(\n+                tcx.sess, true, /* PIC doesn't matter here */\n+            )),\n+            value_ranges: value_ranges.as_ref(),\n+        },\n+    )\n+    .unwrap();\n+\n+    let res: std::io::Result<()> = try {\n+        let mut file = std::fs::File::create(clif_file_name)?;\n+        let target_triple = crate::target_triple(tcx.sess);\n+        writeln!(file, \"test compile\")?;\n+        writeln!(file, \"set is_pic\")?;\n+        writeln!(file, \"set enable_simd\")?;\n+        writeln!(file, \"target {} haswell\", target_triple)?;\n+        writeln!(file, \"\")?;\n+        file.write_all(clif.as_bytes())?;\n+    };\n+    if let Err(err) = res {\n+        tcx.sess.warn(&format!(\"err writing clif file: {}\", err));\n+    }\n+}\n+\n+impl<M: Module> fmt::Debug for FunctionCx<'_, '_, M> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        writeln!(f, \"{:?}\", self.instance.substs)?;\n+        writeln!(f, \"{:?}\", self.local_map)?;\n+\n+        let mut clif = String::new();\n+        ::cranelift_codegen::write::decorate_function(\n+            &mut &self.clif_comments,\n+            &mut clif,\n+            &self.bcx.func,\n+            &DisplayFunctionAnnotations::default(),\n+        )\n+        .unwrap();\n+        writeln!(f, \"\\n{}\", clif)\n+    }\n+}"}, {"sha": "463afaf7cc50cd66c6b773f1bdc3b65f126f76bd", "filename": "compiler/rustc_codegen_cranelift/src/toolchain.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,125 @@\n+//! Locating various executables part of a C toolchain.\n+\n+use std::path::PathBuf;\n+\n+use rustc_middle::bug;\n+use rustc_session::Session;\n+use rustc_target::spec::LinkerFlavor;\n+\n+/// Tries to infer the path of a binary for the target toolchain from the linker name.\n+pub(crate) fn get_toolchain_binary(sess: &Session, tool: &str) -> PathBuf {\n+    let (mut linker, _linker_flavor) = linker_and_flavor(sess);\n+    let linker_file_name = linker\n+        .file_name()\n+        .and_then(|name| name.to_str())\n+        .unwrap_or_else(|| sess.fatal(\"couldn't extract file name from specified linker\"));\n+\n+    if linker_file_name == \"ld.lld\" {\n+        if tool != \"ld\" {\n+            linker.set_file_name(tool)\n+        }\n+    } else {\n+        let tool_file_name = linker_file_name\n+            .replace(\"ld\", tool)\n+            .replace(\"gcc\", tool)\n+            .replace(\"clang\", tool)\n+            .replace(\"cc\", tool);\n+\n+        linker.set_file_name(tool_file_name)\n+    }\n+\n+    linker\n+}\n+\n+// Adapted from https://github.com/rust-lang/rust/blob/5db778affee7c6600c8e7a177c48282dab3f6292/src/librustc_codegen_ssa/back/link.rs#L848-L931\n+fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n+    fn infer_from(\n+        sess: &Session,\n+        linker: Option<PathBuf>,\n+        flavor: Option<LinkerFlavor>,\n+    ) -> Option<(PathBuf, LinkerFlavor)> {\n+        match (linker, flavor) {\n+            (Some(linker), Some(flavor)) => Some((linker, flavor)),\n+            // only the linker flavor is known; use the default linker for the selected flavor\n+            (None, Some(flavor)) => Some((\n+                PathBuf::from(match flavor {\n+                    LinkerFlavor::Em => {\n+                        if cfg!(windows) {\n+                            \"emcc.bat\"\n+                        } else {\n+                            \"emcc\"\n+                        }\n+                    }\n+                    LinkerFlavor::Gcc => {\n+                        if cfg!(any(target_os = \"solaris\", target_os = \"illumos\")) {\n+                            // On historical Solaris systems, \"cc\" may have\n+                            // been Sun Studio, which is not flag-compatible\n+                            // with \"gcc\".  This history casts a long shadow,\n+                            // and many modern illumos distributions today\n+                            // ship GCC as \"gcc\" without also making it\n+                            // available as \"cc\".\n+                            \"gcc\"\n+                        } else {\n+                            \"cc\"\n+                        }\n+                    }\n+                    LinkerFlavor::Ld => \"ld\",\n+                    LinkerFlavor::Msvc => \"link.exe\",\n+                    LinkerFlavor::Lld(_) => \"lld\",\n+                    LinkerFlavor::PtxLinker => \"rust-ptx-linker\",\n+                }),\n+                flavor,\n+            )),\n+            (Some(linker), None) => {\n+                let stem = linker\n+                    .file_stem()\n+                    .and_then(|stem| stem.to_str())\n+                    .unwrap_or_else(|| {\n+                        sess.fatal(\"couldn't extract file stem from specified linker\")\n+                    });\n+\n+                let flavor = if stem == \"emcc\" {\n+                    LinkerFlavor::Em\n+                } else if stem == \"gcc\"\n+                    || stem.ends_with(\"-gcc\")\n+                    || stem == \"clang\"\n+                    || stem.ends_with(\"-clang\")\n+                {\n+                    LinkerFlavor::Gcc\n+                } else if stem == \"ld\" || stem == \"ld.lld\" || stem.ends_with(\"-ld\") {\n+                    LinkerFlavor::Ld\n+                } else if stem == \"link\" || stem == \"lld-link\" {\n+                    LinkerFlavor::Msvc\n+                } else if stem == \"lld\" || stem == \"rust-lld\" {\n+                    LinkerFlavor::Lld(sess.target.options.lld_flavor)\n+                } else {\n+                    // fall back to the value in the target spec\n+                    sess.target.linker_flavor\n+                };\n+\n+                Some((linker, flavor))\n+            }\n+            (None, None) => None,\n+        }\n+    }\n+\n+    // linker and linker flavor specified via command line have precedence over what the target\n+    // specification specifies\n+    if let Some(ret) = infer_from(\n+        sess,\n+        sess.opts.cg.linker.clone(),\n+        sess.opts.cg.linker_flavor,\n+    ) {\n+        return ret;\n+    }\n+\n+    if let Some(ret) = infer_from(\n+        sess,\n+        sess.target.options.linker.clone().map(PathBuf::from),\n+        Some(sess.target.linker_flavor),\n+    ) {\n+        return ret;\n+    }\n+\n+    bug!(\"Not enough information provided to determine how to invoke the linker\");\n+}"}, {"sha": "37dca77bdbd093e8baa0050099145bfde5a9fd2b", "filename": "compiler/rustc_codegen_cranelift/src/trap.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,70 @@\n+//! Helpers used to print a message and abort in case of certain panics and some detected UB.\n+\n+use crate::prelude::*;\n+\n+fn codegen_print(fx: &mut FunctionCx<'_, '_, impl Module>, msg: &str) {\n+    let puts = fx\n+        .cx\n+        .module\n+        .declare_function(\n+            \"puts\",\n+            Linkage::Import,\n+            &Signature {\n+                call_conv: CallConv::triple_default(fx.triple()),\n+                params: vec![AbiParam::new(pointer_ty(fx.tcx))],\n+                returns: vec![AbiParam::new(types::I32)],\n+            },\n+        )\n+        .unwrap();\n+    let puts = fx.cx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n+    #[cfg(debug_assertions)]\n+    {\n+        fx.add_comment(puts, \"puts\");\n+    }\n+\n+    let symbol_name = fx.tcx.symbol_name(fx.instance);\n+    let real_msg = format!(\"trap at {:?} ({}): {}\\0\", fx.instance, symbol_name, msg);\n+    let msg_ptr = fx.anonymous_str(\"trap\", &real_msg);\n+    fx.bcx.ins().call(puts, &[msg_ptr]);\n+}\n+\n+/// Trap code: user1\n+pub(crate) fn trap_abort(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+    codegen_print(fx, msg.as_ref());\n+    fx.bcx.ins().trap(TrapCode::User(1));\n+}\n+\n+/// Use this for example when a function call should never return. This will fill the current block,\n+/// so you can **not** add instructions to it afterwards.\n+///\n+/// Trap code: user65535\n+pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+    codegen_print(fx, msg.as_ref());\n+    fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n+}\n+\n+/// Like `trap_unreachable` but returns a fake value of the specified type.\n+///\n+/// Trap code: user65535\n+pub(crate) fn trap_unreachable_ret_value<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    dest_layout: TyAndLayout<'tcx>,\n+    msg: impl AsRef<str>,\n+) -> CValue<'tcx> {\n+    codegen_print(fx, msg.as_ref());\n+    let true_ = fx.bcx.ins().iconst(types::I32, 1);\n+    fx.bcx.ins().trapnz(true_, TrapCode::UnreachableCodeReached);\n+    CValue::by_ref(Pointer::const_addr(fx, 0), dest_layout)\n+}\n+\n+/// Use this when something is unimplemented, but `libcore` or `libstd` requires it to codegen.\n+/// Unlike `trap_unreachable` this will not fill the current block, so you **must** add instructions\n+/// to it afterwards.\n+///\n+/// Trap code: user65535\n+pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+    codegen_print(fx, msg.as_ref());\n+    let true_ = fx.bcx.ins().iconst(types::I32, 1);\n+    fx.bcx.ins().trapnz(true_, TrapCode::User(!0));\n+}\n+"}, {"sha": "c77ff5d56ba626859e85d806f1c184ee3e41d712", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,238 @@\n+//! Codegen of the [`PointerCast::Unsize`] operation.\n+//!\n+//! [`PointerCast::Unsize`]: `rustc_middle::ty::adjustment::PointerCast::Unsize`\n+\n+use crate::prelude::*;\n+\n+// Adapted from https://github.com/rust-lang/rust/blob/2a663555ddf36f6b041445894a8c175cd1bc718c/src/librustc_codegen_ssa/base.rs#L159-L307\n+\n+/// Retrieve the information we are losing (making dynamic) in an unsizing\n+/// adjustment.\n+///\n+/// The `old_info` argument is a bit funny. It is intended for use\n+/// in an upcast, where the new vtable for an object will be derived\n+/// from the old one.\n+pub(crate) fn unsized_info<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    source: Ty<'tcx>,\n+    target: Ty<'tcx>,\n+    old_info: Option<Value>,\n+) -> Value {\n+    let (source, target) =\n+        fx.tcx\n+            .struct_lockstep_tails_erasing_lifetimes(source, target, ParamEnv::reveal_all());\n+    match (&source.kind(), &target.kind()) {\n+        (&ty::Array(_, len), &ty::Slice(_)) => fx.bcx.ins().iconst(\n+            fx.pointer_type,\n+            len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64,\n+        ),\n+        (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n+            // For now, upcasts are limited to changes in marker\n+            // traits, and hence never actually require an actual\n+            // change to the vtable.\n+            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n+        }\n+        (_, &ty::Dynamic(ref data, ..)) => {\n+            crate::vtable::get_vtable(fx, fx.layout_of(source), data.principal())\n+        }\n+        _ => bug!(\n+            \"unsized_info: invalid unsizing {:?} -> {:?}\",\n+            source,\n+            target\n+        ),\n+    }\n+}\n+\n+/// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n+fn unsize_thin_ptr<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    src: Value,\n+    src_layout: TyAndLayout<'tcx>,\n+    dst_layout: TyAndLayout<'tcx>,\n+) -> (Value, Value) {\n+    match (&src_layout.ty.kind(), &dst_layout.ty.kind()) {\n+        (&ty::Ref(_, a, _), &ty::Ref(_, b, _))\n+        | (&ty::Ref(_, a, _), &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n+        | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n+            assert!(!fx.layout_of(a).is_unsized());\n+            (src, unsized_info(fx, a, b, None))\n+        }\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+            let (a, b) = (src_layout.ty.boxed_ty(), dst_layout.ty.boxed_ty());\n+            assert!(!fx.layout_of(a).is_unsized());\n+            (src, unsized_info(fx, a, b, None))\n+        }\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n+            assert_eq!(def_a, def_b);\n+\n+            let mut result = None;\n+            for i in 0..src_layout.fields.count() {\n+                let src_f = src_layout.field(fx, i);\n+                assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n+                assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n+                if src_f.is_zst() {\n+                    continue;\n+                }\n+                assert_eq!(src_layout.size, src_f.size);\n+\n+                let dst_f = dst_layout.field(fx, i);\n+                assert_ne!(src_f.ty, dst_f.ty);\n+                assert_eq!(result, None);\n+                result = Some(unsize_thin_ptr(fx, src, src_f, dst_f));\n+            }\n+            result.unwrap()\n+        }\n+        _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n+    }\n+}\n+\n+/// Coerce `src`, which is a reference to a value of type `src_ty`,\n+/// to a value of type `dst_ty` and store the result in `dst`\n+pub(crate) fn coerce_unsized_into<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    src: CValue<'tcx>,\n+    dst: CPlace<'tcx>,\n+) {\n+    let src_ty = src.layout().ty;\n+    let dst_ty = dst.layout().ty;\n+    let mut coerce_ptr = || {\n+        let (base, info) = if fx\n+            .layout_of(src.layout().ty.builtin_deref(true).unwrap().ty)\n+            .is_unsized()\n+        {\n+            // fat-ptr to fat-ptr unsize preserves the vtable\n+            // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n+            src.load_scalar_pair(fx)\n+        } else {\n+            let base = src.load_scalar(fx);\n+            unsize_thin_ptr(fx, base, src.layout(), dst.layout())\n+        };\n+        dst.write_cvalue(fx, CValue::by_val_pair(base, info, dst.layout()));\n+    };\n+    match (&src_ty.kind(), &dst_ty.kind()) {\n+        (&ty::Ref(..), &ty::Ref(..))\n+        | (&ty::Ref(..), &ty::RawPtr(..))\n+        | (&ty::RawPtr(..), &ty::RawPtr(..)) => coerce_ptr(),\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n+            assert_eq!(def_a, def_b);\n+\n+            for i in 0..def_a.variants[VariantIdx::new(0)].fields.len() {\n+                let src_f = src.value_field(fx, mir::Field::new(i));\n+                let dst_f = dst.place_field(fx, mir::Field::new(i));\n+\n+                if dst_f.layout().is_zst() {\n+                    continue;\n+                }\n+\n+                if src_f.layout().ty == dst_f.layout().ty {\n+                    dst_f.write_cvalue(fx, src_f);\n+                } else {\n+                    coerce_unsized_into(fx, src_f, dst_f);\n+                }\n+            }\n+        }\n+        _ => bug!(\n+            \"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n+            src_ty,\n+            dst_ty\n+        ),\n+    }\n+}\n+\n+// Adapted from https://github.com/rust-lang/rust/blob/2a663555ddf36f6b041445894a8c175cd1bc718c/src/librustc_codegen_ssa/glue.rs\n+\n+pub(crate) fn size_and_align_of_dst<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    layout: TyAndLayout<'tcx>,\n+    info: Value,\n+) -> (Value, Value) {\n+    if !layout.is_unsized() {\n+        let size = fx\n+            .bcx\n+            .ins()\n+            .iconst(fx.pointer_type, layout.size.bytes() as i64);\n+        let align = fx\n+            .bcx\n+            .ins()\n+            .iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n+        return (size, align);\n+    }\n+    match layout.ty.kind() {\n+        ty::Dynamic(..) => {\n+            // load size/align from vtable\n+            (\n+                crate::vtable::size_of_obj(fx, info),\n+                crate::vtable::min_align_of_obj(fx, info),\n+            )\n+        }\n+        ty::Slice(_) | ty::Str => {\n+            let unit = layout.field(fx, 0);\n+            // The info in this case is the length of the str, so the size is that\n+            // times the unit size.\n+            (\n+                fx.bcx.ins().imul_imm(info, unit.size.bytes() as i64),\n+                fx.bcx\n+                    .ins()\n+                    .iconst(fx.pointer_type, unit.align.abi.bytes() as i64),\n+            )\n+        }\n+        _ => {\n+            // First get the size of all statically known fields.\n+            // Don't use size_of because it also rounds up to alignment, which we\n+            // want to avoid, as the unsized field's alignment could be smaller.\n+            assert!(!layout.ty.is_simd());\n+\n+            let i = layout.fields.count() - 1;\n+            let sized_size = layout.fields.offset(i).bytes();\n+            let sized_align = layout.align.abi.bytes();\n+            let sized_align = fx.bcx.ins().iconst(fx.pointer_type, sized_align as i64);\n+\n+            // Recurse to get the size of the dynamically sized field (must be\n+            // the last field).\n+            let field_layout = layout.field(fx, i);\n+            let (unsized_size, mut unsized_align) = size_and_align_of_dst(fx, field_layout, info);\n+\n+            // FIXME (#26403, #27023): We should be adding padding\n+            // to `sized_size` (to accommodate the `unsized_align`\n+            // required of the unsized field that follows) before\n+            // summing it with `sized_size`. (Note that since #26403\n+            // is unfixed, we do not yet add the necessary padding\n+            // here. But this is where the add would go.)\n+\n+            // Return the sum of sizes and max of aligns.\n+            let size = fx.bcx.ins().iadd_imm(unsized_size, sized_size as i64);\n+\n+            // Packed types ignore the alignment of their fields.\n+            if let ty::Adt(def, _) = layout.ty.kind() {\n+                if def.repr.packed() {\n+                    unsized_align = sized_align;\n+                }\n+            }\n+\n+            // Choose max of two known alignments (combined value must\n+            // be aligned according to more restrictive of the two).\n+            let cmp = fx\n+                .bcx\n+                .ins()\n+                .icmp(IntCC::UnsignedGreaterThan, sized_align, unsized_align);\n+            let align = fx.bcx.ins().select(cmp, sized_align, unsized_align);\n+\n+            // Issue #27023: must add any necessary padding to `size`\n+            // (to make it a multiple of `align`) before returning it.\n+            //\n+            // Namely, the returned size should be, in C notation:\n+            //\n+            //   `size + ((size & (align-1)) ? align : 0)`\n+            //\n+            // emulated via the semi-standard fast bit trick:\n+            //\n+            //   `(size + (align-1)) & -align`\n+            let addend = fx.bcx.ins().iadd_imm(align, -1);\n+            let add = fx.bcx.ins().iadd(size, addend);\n+            let neg = fx.bcx.ins().ineg(align);\n+            let size = fx.bcx.ins().band(add, neg);\n+\n+            (size, align)\n+        }\n+    }\n+}"}, {"sha": "5d513cb3ea022b8d2d74ab88da7c6b3ed8009f3d", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "added", "additions": 777, "deletions": 0, "changes": 777, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,777 @@\n+//! Definition of [`CValue`] and [`CPlace`]\n+\n+use crate::prelude::*;\n+\n+use cranelift_codegen::entity::EntityRef;\n+use cranelift_codegen::ir::immediates::Offset32;\n+\n+fn codegen_field<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    base: Pointer,\n+    extra: Option<Value>,\n+    layout: TyAndLayout<'tcx>,\n+    field: mir::Field,\n+) -> (Pointer, TyAndLayout<'tcx>) {\n+    let field_offset = layout.fields.offset(field.index());\n+    let field_layout = layout.field(&*fx, field.index());\n+\n+    let simple = |fx: &mut FunctionCx<'_, '_, _>| {\n+        (\n+            base.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap()),\n+            field_layout,\n+        )\n+    };\n+\n+    if let Some(extra) = extra {\n+        if !field_layout.is_unsized() {\n+            return simple(fx);\n+        }\n+        match field_layout.ty.kind() {\n+            ty::Slice(..) | ty::Str | ty::Foreign(..) => return simple(fx),\n+            ty::Adt(def, _) if def.repr.packed() => {\n+                assert_eq!(layout.align.abi.bytes(), 1);\n+                return simple(fx);\n+            }\n+            _ => {\n+                // We have to align the offset for DST's\n+                let unaligned_offset = field_offset.bytes();\n+                let (_, unsized_align) =\n+                    crate::unsize::size_and_align_of_dst(fx, field_layout, extra);\n+\n+                let one = fx.bcx.ins().iconst(pointer_ty(fx.tcx), 1);\n+                let align_sub_1 = fx.bcx.ins().isub(unsized_align, one);\n+                let and_lhs = fx.bcx.ins().iadd_imm(align_sub_1, unaligned_offset as i64);\n+                let zero = fx.bcx.ins().iconst(pointer_ty(fx.tcx), 0);\n+                let and_rhs = fx.bcx.ins().isub(zero, unsized_align);\n+                let offset = fx.bcx.ins().band(and_lhs, and_rhs);\n+\n+                (base.offset_value(fx, offset), field_layout)\n+            }\n+        }\n+    } else {\n+        simple(fx)\n+    }\n+}\n+\n+fn scalar_pair_calculate_b_offset(\n+    tcx: TyCtxt<'_>,\n+    a_scalar: &Scalar,\n+    b_scalar: &Scalar,\n+) -> Offset32 {\n+    let b_offset = a_scalar\n+        .value\n+        .size(&tcx)\n+        .align_to(b_scalar.value.align(&tcx).abi);\n+    Offset32::new(b_offset.bytes().try_into().unwrap())\n+}\n+\n+/// A read-only value\n+#[derive(Debug, Copy, Clone)]\n+pub(crate) struct CValue<'tcx>(CValueInner, TyAndLayout<'tcx>);\n+\n+#[derive(Debug, Copy, Clone)]\n+enum CValueInner {\n+    ByRef(Pointer, Option<Value>),\n+    ByVal(Value),\n+    ByValPair(Value, Value),\n+}\n+\n+impl<'tcx> CValue<'tcx> {\n+    pub(crate) fn by_ref(ptr: Pointer, layout: TyAndLayout<'tcx>) -> CValue<'tcx> {\n+        CValue(CValueInner::ByRef(ptr, None), layout)\n+    }\n+\n+    pub(crate) fn by_ref_unsized(\n+        ptr: Pointer,\n+        meta: Value,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> CValue<'tcx> {\n+        CValue(CValueInner::ByRef(ptr, Some(meta)), layout)\n+    }\n+\n+    pub(crate) fn by_val(value: Value, layout: TyAndLayout<'tcx>) -> CValue<'tcx> {\n+        CValue(CValueInner::ByVal(value), layout)\n+    }\n+\n+    pub(crate) fn by_val_pair(\n+        value: Value,\n+        extra: Value,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> CValue<'tcx> {\n+        CValue(CValueInner::ByValPair(value, extra), layout)\n+    }\n+\n+    pub(crate) fn layout(&self) -> TyAndLayout<'tcx> {\n+        self.1\n+    }\n+\n+    // FIXME remove\n+    pub(crate) fn force_stack(\n+        self,\n+        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    ) -> (Pointer, Option<Value>) {\n+        let layout = self.1;\n+        match self.0 {\n+            CValueInner::ByRef(ptr, meta) => (ptr, meta),\n+            CValueInner::ByVal(_) | CValueInner::ByValPair(_, _) => {\n+                let cplace = CPlace::new_stack_slot(fx, layout);\n+                cplace.write_cvalue(fx, self);\n+                (cplace.to_ptr(), None)\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn try_to_ptr(self) -> Option<(Pointer, Option<Value>)> {\n+        match self.0 {\n+            CValueInner::ByRef(ptr, meta) => Some((ptr, meta)),\n+            CValueInner::ByVal(_) | CValueInner::ByValPair(_, _) => None,\n+        }\n+    }\n+\n+    /// Load a value with layout.abi of scalar\n+    pub(crate) fn load_scalar(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> Value {\n+        let layout = self.1;\n+        match self.0 {\n+            CValueInner::ByRef(ptr, None) => {\n+                let clif_ty = match layout.abi {\n+                    Abi::Scalar(ref scalar) => scalar_to_clif_type(fx.tcx, scalar.clone()),\n+                    Abi::Vector { ref element, count } => {\n+                        scalar_to_clif_type(fx.tcx, element.clone())\n+                            .by(u16::try_from(count).unwrap())\n+                            .unwrap()\n+                    }\n+                    _ => unreachable!(\"{:?}\", layout.ty),\n+                };\n+                let mut flags = MemFlags::new();\n+                flags.set_notrap();\n+                ptr.load(fx, clif_ty, flags)\n+            }\n+            CValueInner::ByVal(value) => value,\n+            CValueInner::ByRef(_, Some(_)) => bug!(\"load_scalar for unsized value not allowed\"),\n+            CValueInner::ByValPair(_, _) => bug!(\"Please use load_scalar_pair for ByValPair\"),\n+        }\n+    }\n+\n+    /// Load a value pair with layout.abi of scalar pair\n+    pub(crate) fn load_scalar_pair(\n+        self,\n+        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    ) -> (Value, Value) {\n+        let layout = self.1;\n+        match self.0 {\n+            CValueInner::ByRef(ptr, None) => {\n+                let (a_scalar, b_scalar) = match &layout.abi {\n+                    Abi::ScalarPair(a, b) => (a, b),\n+                    _ => unreachable!(\"load_scalar_pair({:?})\", self),\n+                };\n+                let b_offset = scalar_pair_calculate_b_offset(fx.tcx, a_scalar, b_scalar);\n+                let clif_ty1 = scalar_to_clif_type(fx.tcx, a_scalar.clone());\n+                let clif_ty2 = scalar_to_clif_type(fx.tcx, b_scalar.clone());\n+                let mut flags = MemFlags::new();\n+                flags.set_notrap();\n+                let val1 = ptr.load(fx, clif_ty1, flags);\n+                let val2 = ptr.offset(fx, b_offset).load(fx, clif_ty2, flags);\n+                (val1, val2)\n+            }\n+            CValueInner::ByRef(_, Some(_)) => {\n+                bug!(\"load_scalar_pair for unsized value not allowed\")\n+            }\n+            CValueInner::ByVal(_) => bug!(\"Please use load_scalar for ByVal\"),\n+            CValueInner::ByValPair(val1, val2) => (val1, val2),\n+        }\n+    }\n+\n+    pub(crate) fn value_field(\n+        self,\n+        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        field: mir::Field,\n+    ) -> CValue<'tcx> {\n+        let layout = self.1;\n+        match self.0 {\n+            CValueInner::ByVal(val) => match layout.abi {\n+                Abi::Vector { element: _, count } => {\n+                    let count = u8::try_from(count).expect(\"SIMD type with more than 255 lanes???\");\n+                    let field = u8::try_from(field.index()).unwrap();\n+                    assert!(field < count);\n+                    let lane = fx.bcx.ins().extractlane(val, field);\n+                    let field_layout = layout.field(&*fx, usize::from(field));\n+                    CValue::by_val(lane, field_layout)\n+                }\n+                _ => unreachable!(\"value_field for ByVal with abi {:?}\", layout.abi),\n+            },\n+            CValueInner::ByValPair(val1, val2) => match layout.abi {\n+                Abi::ScalarPair(_, _) => {\n+                    let val = match field.as_u32() {\n+                        0 => val1,\n+                        1 => val2,\n+                        _ => bug!(\"field should be 0 or 1\"),\n+                    };\n+                    let field_layout = layout.field(&*fx, usize::from(field));\n+                    CValue::by_val(val, field_layout)\n+                }\n+                _ => unreachable!(\"value_field for ByValPair with abi {:?}\", layout.abi),\n+            },\n+            CValueInner::ByRef(ptr, None) => {\n+                let (field_ptr, field_layout) = codegen_field(fx, ptr, None, layout, field);\n+                CValue::by_ref(field_ptr, field_layout)\n+            }\n+            CValueInner::ByRef(_, Some(_)) => todo!(),\n+        }\n+    }\n+\n+    pub(crate) fn unsize_value(\n+        self,\n+        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        dest: CPlace<'tcx>,\n+    ) {\n+        crate::unsize::coerce_unsized_into(fx, self, dest);\n+    }\n+\n+    /// If `ty` is signed, `const_val` must already be sign extended.\n+    pub(crate) fn const_val(\n+        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        layout: TyAndLayout<'tcx>,\n+        const_val: u128,\n+    ) -> CValue<'tcx> {\n+        use cranelift_codegen::ir::immediates::{Ieee32, Ieee64};\n+\n+        let clif_ty = fx.clif_type(layout.ty).unwrap();\n+\n+        match layout.ty.kind() {\n+            ty::Bool => {\n+                assert!(\n+                    const_val == 0 || const_val == 1,\n+                    \"Invalid bool 0x{:032X}\",\n+                    const_val\n+                );\n+            }\n+            _ => {}\n+        }\n+\n+        let val = match layout.ty.kind() {\n+            ty::Uint(UintTy::U128) | ty::Int(IntTy::I128) => {\n+                let lsb = fx.bcx.ins().iconst(types::I64, const_val as u64 as i64);\n+                let msb = fx\n+                    .bcx\n+                    .ins()\n+                    .iconst(types::I64, (const_val >> 64) as u64 as i64);\n+                fx.bcx.ins().iconcat(lsb, msb)\n+            }\n+            ty::Bool | ty::Char | ty::Uint(_) | ty::Int(_) | ty::Ref(..)\n+            | ty::RawPtr(..) => {\n+                fx\n+                    .bcx\n+                    .ins()\n+                    .iconst(clif_ty, u64::try_from(const_val).expect(\"uint\") as i64)\n+            }\n+            ty::Float(FloatTy::F32) => {\n+                fx.bcx.ins().f32const(Ieee32::with_bits(u32::try_from(const_val).unwrap()))\n+            }\n+            ty::Float(FloatTy::F64) => {\n+                fx.bcx.ins().f64const(Ieee64::with_bits(u64::try_from(const_val).unwrap()))\n+            }\n+            _ => panic!(\n+                \"CValue::const_val for non bool/char/float/integer/pointer type {:?} is not allowed\",\n+                layout.ty\n+            ),\n+        };\n+\n+        CValue::by_val(val, layout)\n+    }\n+\n+    pub(crate) fn cast_pointer_to(self, layout: TyAndLayout<'tcx>) -> Self {\n+        assert!(matches!(\n+            self.layout().ty.kind(),\n+            ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)\n+        ));\n+        assert!(matches!(\n+            layout.ty.kind(),\n+            ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)\n+        ));\n+        assert_eq!(self.layout().abi, layout.abi);\n+        CValue(self.0, layout)\n+    }\n+}\n+\n+/// A place where you can write a value to or read a value from\n+#[derive(Debug, Copy, Clone)]\n+pub(crate) struct CPlace<'tcx> {\n+    inner: CPlaceInner,\n+    layout: TyAndLayout<'tcx>,\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+pub(crate) enum CPlaceInner {\n+    Var(Local, Variable),\n+    VarPair(Local, Variable, Variable),\n+    VarLane(Local, Variable, u8),\n+    Addr(Pointer, Option<Value>),\n+}\n+\n+impl<'tcx> CPlace<'tcx> {\n+    pub(crate) fn layout(&self) -> TyAndLayout<'tcx> {\n+        self.layout\n+    }\n+\n+    pub(crate) fn inner(&self) -> &CPlaceInner {\n+        &self.inner\n+    }\n+\n+    pub(crate) fn no_place(layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n+        CPlace {\n+            inner: CPlaceInner::Addr(Pointer::dangling(layout.align.pref), None),\n+            layout,\n+        }\n+    }\n+\n+    pub(crate) fn new_stack_slot(\n+        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> CPlace<'tcx> {\n+        assert!(!layout.is_unsized());\n+        if layout.size.bytes() == 0 {\n+            return CPlace::no_place(layout);\n+        }\n+\n+        let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+            kind: StackSlotKind::ExplicitSlot,\n+            size: layout.size.bytes() as u32,\n+            offset: None,\n+        });\n+        CPlace {\n+            inner: CPlaceInner::Addr(Pointer::stack_slot(stack_slot), None),\n+            layout,\n+        }\n+    }\n+\n+    pub(crate) fn new_var(\n+        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        local: Local,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> CPlace<'tcx> {\n+        let var = Variable::with_u32(fx.next_ssa_var);\n+        fx.next_ssa_var += 1;\n+        fx.bcx.declare_var(var, fx.clif_type(layout.ty).unwrap());\n+        CPlace {\n+            inner: CPlaceInner::Var(local, var),\n+            layout,\n+        }\n+    }\n+\n+    pub(crate) fn new_var_pair(\n+        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        local: Local,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> CPlace<'tcx> {\n+        let var1 = Variable::with_u32(fx.next_ssa_var);\n+        fx.next_ssa_var += 1;\n+        let var2 = Variable::with_u32(fx.next_ssa_var);\n+        fx.next_ssa_var += 1;\n+\n+        let (ty1, ty2) = fx.clif_pair_type(layout.ty).unwrap();\n+        fx.bcx.declare_var(var1, ty1);\n+        fx.bcx.declare_var(var2, ty2);\n+        CPlace {\n+            inner: CPlaceInner::VarPair(local, var1, var2),\n+            layout,\n+        }\n+    }\n+\n+    pub(crate) fn for_ptr(ptr: Pointer, layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n+        CPlace {\n+            inner: CPlaceInner::Addr(ptr, None),\n+            layout,\n+        }\n+    }\n+\n+    pub(crate) fn for_ptr_with_extra(\n+        ptr: Pointer,\n+        extra: Value,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> CPlace<'tcx> {\n+        CPlace {\n+            inner: CPlaceInner::Addr(ptr, Some(extra)),\n+            layout,\n+        }\n+    }\n+\n+    pub(crate) fn to_cvalue(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> CValue<'tcx> {\n+        let layout = self.layout();\n+        match self.inner {\n+            CPlaceInner::Var(_local, var) => {\n+                let val = fx.bcx.use_var(var);\n+                fx.bcx\n+                    .set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                CValue::by_val(val, layout)\n+            }\n+            CPlaceInner::VarPair(_local, var1, var2) => {\n+                let val1 = fx.bcx.use_var(var1);\n+                fx.bcx\n+                    .set_val_label(val1, cranelift_codegen::ir::ValueLabel::new(var1.index()));\n+                let val2 = fx.bcx.use_var(var2);\n+                fx.bcx\n+                    .set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n+                CValue::by_val_pair(val1, val2, layout)\n+            }\n+            CPlaceInner::VarLane(_local, var, lane) => {\n+                let val = fx.bcx.use_var(var);\n+                fx.bcx\n+                    .set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                let val = fx.bcx.ins().extractlane(val, lane);\n+                CValue::by_val(val, layout)\n+            }\n+            CPlaceInner::Addr(ptr, extra) => {\n+                if let Some(extra) = extra {\n+                    CValue::by_ref_unsized(ptr, extra, layout)\n+                } else {\n+                    CValue::by_ref(ptr, layout)\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn to_ptr(self) -> Pointer {\n+        match self.to_ptr_maybe_unsized() {\n+            (ptr, None) => ptr,\n+            (_, Some(_)) => bug!(\"Expected sized cplace, found {:?}\", self),\n+        }\n+    }\n+\n+    pub(crate) fn to_ptr_maybe_unsized(self) -> (Pointer, Option<Value>) {\n+        match self.inner {\n+            CPlaceInner::Addr(ptr, extra) => (ptr, extra),\n+            CPlaceInner::Var(_, _)\n+            | CPlaceInner::VarPair(_, _, _)\n+            | CPlaceInner::VarLane(_, _, _) => bug!(\"Expected CPlace::Addr, found {:?}\", self),\n+        }\n+    }\n+\n+    pub(crate) fn write_cvalue(\n+        self,\n+        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        from: CValue<'tcx>,\n+    ) {\n+        fn assert_assignable<'tcx>(\n+            fx: &FunctionCx<'_, 'tcx, impl Module>,\n+            from_ty: Ty<'tcx>,\n+            to_ty: Ty<'tcx>,\n+        ) {\n+            match (&from_ty.kind(), &to_ty.kind()) {\n+                (ty::Ref(_, a, _), ty::Ref(_, b, _))\n+                | (\n+                    ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n+                    ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n+                ) => {\n+                    assert_assignable(fx, a, b);\n+                }\n+                (ty::FnPtr(_), ty::FnPtr(_)) => {\n+                    let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n+                        ParamEnv::reveal_all(),\n+                        &from_ty.fn_sig(fx.tcx),\n+                    );\n+                    let to_sig = fx.tcx.normalize_erasing_late_bound_regions(\n+                        ParamEnv::reveal_all(),\n+                        &to_ty.fn_sig(fx.tcx),\n+                    );\n+                    assert_eq!(\n+                        from_sig, to_sig,\n+                        \"Can't write fn ptr with incompatible sig {:?} to place with sig {:?}\\n\\n{:#?}\",\n+                        from_sig, to_sig, fx,\n+                    );\n+                    // fn(&T) -> for<'l> fn(&'l T) is allowed\n+                }\n+                (ty::Dynamic(from_traits, _), ty::Dynamic(to_traits, _)) => {\n+                    let from_traits = fx\n+                        .tcx\n+                        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from_traits);\n+                    let to_traits = fx\n+                        .tcx\n+                        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to_traits);\n+                    assert_eq!(\n+                        from_traits, to_traits,\n+                        \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n+                        from_traits, to_traits, fx,\n+                    );\n+                    // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n+                }\n+                _ => {\n+                    assert_eq!(\n+                        from_ty,\n+                        to_ty,\n+                        \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n+                        from_ty,\n+                        to_ty,\n+                        fx,\n+                    );\n+                }\n+            }\n+        }\n+\n+        assert_assignable(fx, from.layout().ty, self.layout().ty);\n+\n+        self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue\");\n+    }\n+\n+    pub(crate) fn write_cvalue_transmute(\n+        self,\n+        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        from: CValue<'tcx>,\n+    ) {\n+        self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue_transmute\");\n+    }\n+\n+    fn write_cvalue_maybe_transmute(\n+        self,\n+        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        from: CValue<'tcx>,\n+        #[cfg_attr(not(debug_assertions), allow(unused_variables))] method: &'static str,\n+    ) {\n+        fn transmute_value<'tcx>(\n+            fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+            var: Variable,\n+            data: Value,\n+            dst_ty: Type,\n+        ) {\n+            let src_ty = fx.bcx.func.dfg.value_type(data);\n+            let data = match (src_ty, dst_ty) {\n+                (_, _) if src_ty == dst_ty => data,\n+\n+                // This is a `write_cvalue_transmute`.\n+                (types::I32, types::F32)\n+                | (types::F32, types::I32)\n+                | (types::I64, types::F64)\n+                | (types::F64, types::I64) => fx.bcx.ins().bitcast(dst_ty, data),\n+                _ if src_ty.is_vector() && dst_ty.is_vector() => {\n+                    fx.bcx.ins().raw_bitcast(dst_ty, data)\n+                }\n+                _ => unreachable!(\"write_cvalue_transmute: {:?} -> {:?}\", src_ty, dst_ty),\n+            };\n+            fx.bcx\n+                .set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+            fx.bcx.def_var(var, data);\n+        }\n+\n+        assert_eq!(self.layout().size, from.layout().size);\n+\n+        #[cfg(debug_assertions)]\n+        {\n+            use cranelift_codegen::cursor::{Cursor, CursorPosition};\n+            let cur_block = match fx.bcx.cursor().position() {\n+                CursorPosition::After(block) => block,\n+                _ => unreachable!(),\n+            };\n+            fx.add_comment(\n+                fx.bcx.func.layout.last_inst(cur_block).unwrap(),\n+                format!(\n+                    \"{}: {:?}: {:?} <- {:?}: {:?}\",\n+                    method,\n+                    self.inner(),\n+                    self.layout().ty,\n+                    from.0,\n+                    from.layout().ty\n+                ),\n+            );\n+        }\n+\n+        let dst_layout = self.layout();\n+        let to_ptr = match self.inner {\n+            CPlaceInner::Var(_local, var) => {\n+                let data = CValue(from.0, dst_layout).load_scalar(fx);\n+                let dst_ty = fx.clif_type(self.layout().ty).unwrap();\n+                transmute_value(fx, var, data, dst_ty);\n+                return;\n+            }\n+            CPlaceInner::VarPair(_local, var1, var2) => {\n+                let (data1, data2) = CValue(from.0, dst_layout).load_scalar_pair(fx);\n+                let (dst_ty1, dst_ty2) = fx.clif_pair_type(self.layout().ty).unwrap();\n+                transmute_value(fx, var1, data1, dst_ty1);\n+                transmute_value(fx, var2, data2, dst_ty2);\n+                return;\n+            }\n+            CPlaceInner::VarLane(_local, var, lane) => {\n+                let data = from.load_scalar(fx);\n+\n+                // First get the old vector\n+                let vector = fx.bcx.use_var(var);\n+                fx.bcx\n+                    .set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+\n+                // Next insert the written lane into the vector\n+                let vector = fx.bcx.ins().insertlane(vector, data, lane);\n+\n+                // Finally write the new vector\n+                fx.bcx\n+                    .set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                fx.bcx.def_var(var, vector);\n+\n+                return;\n+            }\n+            CPlaceInner::Addr(ptr, None) => {\n+                if dst_layout.size == Size::ZERO || dst_layout.abi == Abi::Uninhabited {\n+                    return;\n+                }\n+                ptr\n+            }\n+            CPlaceInner::Addr(_, Some(_)) => bug!(\"Can't write value to unsized place {:?}\", self),\n+        };\n+\n+        let mut flags = MemFlags::new();\n+        flags.set_notrap();\n+        match from.layout().abi {\n+            // FIXME make Abi::Vector work too\n+            Abi::Scalar(_) => {\n+                let val = from.load_scalar(fx);\n+                to_ptr.store(fx, val, flags);\n+                return;\n+            }\n+            Abi::ScalarPair(ref a_scalar, ref b_scalar) => {\n+                let (value, extra) = from.load_scalar_pair(fx);\n+                let b_offset = scalar_pair_calculate_b_offset(fx.tcx, a_scalar, b_scalar);\n+                to_ptr.store(fx, value, flags);\n+                to_ptr.offset(fx, b_offset).store(fx, extra, flags);\n+                return;\n+            }\n+            _ => {}\n+        }\n+\n+        match from.0 {\n+            CValueInner::ByVal(val) => {\n+                to_ptr.store(fx, val, flags);\n+            }\n+            CValueInner::ByValPair(_, _) => {\n+                bug!(\n+                    \"Non ScalarPair abi {:?} for ByValPair CValue\",\n+                    dst_layout.abi\n+                );\n+            }\n+            CValueInner::ByRef(from_ptr, None) => {\n+                let from_addr = from_ptr.get_addr(fx);\n+                let to_addr = to_ptr.get_addr(fx);\n+                let src_layout = from.1;\n+                let size = dst_layout.size.bytes();\n+                let src_align = src_layout.align.abi.bytes() as u8;\n+                let dst_align = dst_layout.align.abi.bytes() as u8;\n+                fx.bcx.emit_small_memory_copy(\n+                    fx.cx.module.target_config(),\n+                    to_addr,\n+                    from_addr,\n+                    size,\n+                    dst_align,\n+                    src_align,\n+                    true,\n+                );\n+            }\n+            CValueInner::ByRef(_, Some(_)) => todo!(),\n+        }\n+    }\n+\n+    pub(crate) fn place_field(\n+        self,\n+        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        field: mir::Field,\n+    ) -> CPlace<'tcx> {\n+        let layout = self.layout();\n+\n+        match self.inner {\n+            CPlaceInner::Var(local, var) => {\n+                if let Abi::Vector { .. } = layout.abi {\n+                    return CPlace {\n+                        inner: CPlaceInner::VarLane(local, var, field.as_u32().try_into().unwrap()),\n+                        layout: layout.field(fx, field.as_u32().try_into().unwrap()),\n+                    };\n+                }\n+            }\n+            CPlaceInner::VarPair(local, var1, var2) => {\n+                let layout = layout.field(&*fx, field.index());\n+\n+                match field.as_u32() {\n+                    0 => {\n+                        return CPlace {\n+                            inner: CPlaceInner::Var(local, var1),\n+                            layout,\n+                        }\n+                    }\n+                    1 => {\n+                        return CPlace {\n+                            inner: CPlaceInner::Var(local, var2),\n+                            layout,\n+                        }\n+                    }\n+                    _ => unreachable!(\"field should be 0 or 1\"),\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        let (base, extra) = self.to_ptr_maybe_unsized();\n+\n+        let (field_ptr, field_layout) = codegen_field(fx, base, extra, layout, field);\n+        if field_layout.is_unsized() {\n+            CPlace::for_ptr_with_extra(field_ptr, extra.unwrap(), field_layout)\n+        } else {\n+            CPlace::for_ptr(field_ptr, field_layout)\n+        }\n+    }\n+\n+    pub(crate) fn place_index(\n+        self,\n+        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        index: Value,\n+    ) -> CPlace<'tcx> {\n+        let (elem_layout, ptr) = match self.layout().ty.kind() {\n+            ty::Array(elem_ty, _) => (fx.layout_of(elem_ty), self.to_ptr()),\n+            ty::Slice(elem_ty) => (fx.layout_of(elem_ty), self.to_ptr_maybe_unsized().0),\n+            _ => bug!(\"place_index({:?})\", self.layout().ty),\n+        };\n+\n+        let offset = fx\n+            .bcx\n+            .ins()\n+            .imul_imm(index, elem_layout.size.bytes() as i64);\n+\n+        CPlace::for_ptr(ptr.offset_value(fx, offset), elem_layout)\n+    }\n+\n+    pub(crate) fn place_deref(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> CPlace<'tcx> {\n+        let inner_layout = fx.layout_of(self.layout().ty.builtin_deref(true).unwrap().ty);\n+        if has_ptr_meta(fx.tcx, inner_layout.ty) {\n+            let (addr, extra) = self.to_cvalue(fx).load_scalar_pair(fx);\n+            CPlace::for_ptr_with_extra(Pointer::new(addr), extra, inner_layout)\n+        } else {\n+            CPlace::for_ptr(\n+                Pointer::new(self.to_cvalue(fx).load_scalar(fx)),\n+                inner_layout,\n+            )\n+        }\n+    }\n+\n+    pub(crate) fn place_ref(\n+        self,\n+        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> CValue<'tcx> {\n+        if has_ptr_meta(fx.tcx, self.layout().ty) {\n+            let (ptr, extra) = self.to_ptr_maybe_unsized();\n+            CValue::by_val_pair(\n+                ptr.get_addr(fx),\n+                extra.expect(\"unsized type without metadata\"),\n+                layout,\n+            )\n+        } else {\n+            CValue::by_val(self.to_ptr().get_addr(fx), layout)\n+        }\n+    }\n+\n+    pub(crate) fn downcast_variant(\n+        self,\n+        fx: &FunctionCx<'_, 'tcx, impl Module>,\n+        variant: VariantIdx,\n+    ) -> Self {\n+        assert!(!self.layout().is_unsized());\n+        let layout = self.layout().for_variant(fx, variant);\n+        CPlace {\n+            inner: self.inner,\n+            layout,\n+        }\n+    }\n+}"}, {"sha": "bb3cf8b3f3a3ad555ad33b7ceb6527d48a09148a", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,194 @@\n+//! Codegen vtables and vtable accesses.\n+//!\n+//! See librustc_codegen_llvm/meth.rs for reference\n+// FIXME dedup this logic between miri, cg_llvm and cg_clif\n+\n+use crate::prelude::*;\n+\n+const DROP_FN_INDEX: usize = 0;\n+const SIZE_INDEX: usize = 1;\n+const ALIGN_INDEX: usize = 2;\n+\n+fn vtable_memflags() -> MemFlags {\n+    let mut flags = MemFlags::trusted(); // A vtable access is always aligned and will never trap.\n+    flags.set_readonly(); // A vtable is always read-only.\n+    flags\n+}\n+\n+pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n+    fx.bcx.ins().load(\n+        pointer_ty(fx.tcx),\n+        vtable_memflags(),\n+        vtable,\n+        (DROP_FN_INDEX * usize_size) as i32,\n+    )\n+}\n+\n+pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n+    fx.bcx.ins().load(\n+        pointer_ty(fx.tcx),\n+        vtable_memflags(),\n+        vtable,\n+        (SIZE_INDEX * usize_size) as i32,\n+    )\n+}\n+\n+pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n+    fx.bcx.ins().load(\n+        pointer_ty(fx.tcx),\n+        vtable_memflags(),\n+        vtable,\n+        (ALIGN_INDEX * usize_size) as i32,\n+    )\n+}\n+\n+pub(crate) fn get_ptr_and_method_ref<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    arg: CValue<'tcx>,\n+    idx: usize,\n+) -> (Value, Value) {\n+    let (ptr, vtable) = if let Abi::ScalarPair(_, _) = arg.layout().abi {\n+        arg.load_scalar_pair(fx)\n+    } else {\n+        let (ptr, vtable) = arg.try_to_ptr().unwrap();\n+        (ptr.get_addr(fx), vtable.unwrap())\n+    };\n+\n+    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes();\n+    let func_ref = fx.bcx.ins().load(\n+        pointer_ty(fx.tcx),\n+        vtable_memflags(),\n+        vtable,\n+        ((idx + 3) * usize_size as usize) as i32,\n+    );\n+    (ptr, func_ref)\n+}\n+\n+pub(crate) fn get_vtable<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    layout: TyAndLayout<'tcx>,\n+    trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n+) -> Value {\n+    let data_id = if let Some(data_id) = fx.cx.vtables.get(&(layout.ty, trait_ref)) {\n+        *data_id\n+    } else {\n+        let data_id = build_vtable(fx, layout, trait_ref);\n+        fx.cx.vtables.insert((layout.ty, trait_ref), data_id);\n+        data_id\n+    };\n+\n+    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n+}\n+\n+fn build_vtable<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    layout: TyAndLayout<'tcx>,\n+    trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n+) -> DataId {\n+    let tcx = fx.tcx;\n+    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n+\n+    let drop_in_place_fn = import_function(\n+        tcx,\n+        &mut fx.cx.module,\n+        Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n+    );\n+\n+    let mut components: Vec<_> = vec![Some(drop_in_place_fn), None, None];\n+\n+    let methods_root;\n+    let methods = if let Some(trait_ref) = trait_ref {\n+        methods_root = tcx.vtable_methods(trait_ref.with_self_ty(tcx, layout.ty));\n+        methods_root.iter()\n+    } else {\n+        (&[]).iter()\n+    };\n+    let methods = methods.cloned().map(|opt_mth| {\n+        opt_mth.map_or(None, |(def_id, substs)| {\n+            Some(import_function(\n+                tcx,\n+                &mut fx.cx.module,\n+                Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs)\n+                    .unwrap()\n+                    .polymorphize(fx.tcx),\n+            ))\n+        })\n+    });\n+    components.extend(methods);\n+\n+    let mut data_ctx = DataContext::new();\n+    let mut data = ::std::iter::repeat(0u8)\n+        .take(components.len() * usize_size)\n+        .collect::<Vec<u8>>()\n+        .into_boxed_slice();\n+\n+    write_usize(fx.tcx, &mut data, SIZE_INDEX, layout.size.bytes());\n+    write_usize(fx.tcx, &mut data, ALIGN_INDEX, layout.align.abi.bytes());\n+    data_ctx.define(data);\n+\n+    for (i, component) in components.into_iter().enumerate() {\n+        if let Some(func_id) = component {\n+            let func_ref = fx.cx.module.declare_func_in_data(func_id, &mut data_ctx);\n+            data_ctx.write_function_addr((i * usize_size) as u32, func_ref);\n+        }\n+    }\n+\n+    data_ctx.set_align(\n+        fx.tcx\n+            .data_layout\n+            .pointer_align\n+            .pref\n+            .bytes()\n+            .try_into()\n+            .unwrap(),\n+    );\n+\n+    let data_id = fx\n+        .cx\n+        .module\n+        .declare_data(\n+            &format!(\n+                \"__vtable.{}.for.{:?}.{}\",\n+                trait_ref\n+                    .as_ref()\n+                    .map(|trait_ref| format!(\"{:?}\", trait_ref.skip_binder()).into())\n+                    .unwrap_or(std::borrow::Cow::Borrowed(\"???\")),\n+                layout.ty,\n+                fx.cx.vtables.len(),\n+            ),\n+            Linkage::Local,\n+            false,\n+            false,\n+        )\n+        .unwrap();\n+\n+    fx.cx.module.define_data(data_id, &data_ctx).unwrap();\n+\n+    data_id\n+}\n+\n+fn write_usize(tcx: TyCtxt<'_>, buf: &mut [u8], idx: usize, num: u64) {\n+    let pointer_size = tcx\n+        .layout_of(ParamEnv::reveal_all().and(tcx.types.usize))\n+        .unwrap()\n+        .size\n+        .bytes() as usize;\n+    let target = &mut buf[idx * pointer_size..(idx + 1) * pointer_size];\n+\n+    match tcx.data_layout.endian {\n+        rustc_target::abi::Endian::Little => match pointer_size {\n+            4 => target.copy_from_slice(&(num as u32).to_le_bytes()),\n+            8 => target.copy_from_slice(&(num as u64).to_le_bytes()),\n+            _ => todo!(\"pointer size {} is not yet supported\", pointer_size),\n+        },\n+        rustc_target::abi::Endian::Big => match pointer_size {\n+            4 => target.copy_from_slice(&(num as u32).to_be_bytes()),\n+            8 => target.copy_from_slice(&(num as u64).to_be_bytes()),\n+            _ => todo!(\"pointer size {} is not yet supported\", pointer_size),\n+        },\n+    }\n+}"}, {"sha": "a1c4d9f28728304bd918579771c84ca54a9045c2", "filename": "compiler/rustc_codegen_cranelift/test.sh", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Ftest.sh?ref=ac4f7deb2f3558d2d923fa6ddcbb7210db9c2d52", "patch": "@@ -0,0 +1,119 @@\n+#!/bin/bash\n+set -e\n+\n+# Build cg_clif\n+export RUSTFLAGS=\"-Zrun_dsymutil=no\"\n+if [[ \"$1\" == \"--release\" ]]; then\n+    export CHANNEL='release'\n+    cargo build --release\n+else\n+    export CHANNEL='debug'\n+    cargo build --bin cg_clif\n+fi\n+\n+# Config\n+source scripts/config.sh\n+export CG_CLIF_INCR_CACHE_DISABLED=1\n+RUSTC=$RUSTC\" \"$RUSTFLAGS\" -L crate=target/out --out-dir target/out -Cdebuginfo=2\"\n+\n+# Cleanup\n+rm -r target/out || true\n+\n+# Perform all tests\n+echo \"[BUILD] mini_core\"\n+$RUSTC example/mini_core.rs --crate-name mini_core --crate-type lib,dylib --target $TARGET_TRIPLE\n+\n+echo \"[BUILD] example\"\n+$RUSTC example/example.rs --crate-type lib --target $TARGET_TRIPLE\n+\n+if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n+    echo \"[JIT] mini_core_hello_world\"\n+    CG_CLIF_JIT_ARGS=\"abc bcd\" $RUSTC --jit example/mini_core_hello_world.rs --cfg jit --target $HOST_TRIPLE\n+else\n+    echo \"[JIT] mini_core_hello_world (skipped)\"\n+fi\n+\n+echo \"[AOT] mini_core_hello_world\"\n+$RUSTC example/mini_core_hello_world.rs --crate-name mini_core_hello_world --crate-type bin -g --target $TARGET_TRIPLE\n+$RUN_WRAPPER ./target/out/mini_core_hello_world abc bcd\n+# (echo \"break set -n main\"; echo \"run\"; sleep 1; echo \"si -c 10\"; sleep 1; echo \"frame variable\") | lldb -- ./target/out/mini_core_hello_world abc bcd\n+\n+echo \"[AOT] arbitrary_self_types_pointers_and_wrappers\"\n+$RUSTC example/arbitrary_self_types_pointers_and_wrappers.rs --crate-name arbitrary_self_types_pointers_and_wrappers --crate-type bin --target $TARGET_TRIPLE\n+$RUN_WRAPPER ./target/out/arbitrary_self_types_pointers_and_wrappers\n+\n+echo \"[BUILD] sysroot\"\n+time ./build_sysroot/build_sysroot.sh --release\n+\n+echo \"[AOT] alloc_example\"\n+$RUSTC example/alloc_example.rs --crate-type bin --target $TARGET_TRIPLE\n+$RUN_WRAPPER ./target/out/alloc_example\n+\n+if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n+    echo \"[JIT] std_example\"\n+    $RUSTC --jit example/std_example.rs --target $HOST_TRIPLE\n+else\n+    echo \"[JIT] std_example (skipped)\"\n+fi\n+\n+echo \"[AOT] dst_field_align\"\n+# FIXME Re-add -Zmir-opt-level=2 once rust-lang/rust#67529 is fixed.\n+$RUSTC example/dst-field-align.rs --crate-name dst_field_align --crate-type bin --target $TARGET_TRIPLE\n+$RUN_WRAPPER ./target/out/dst_field_align || (echo $?; false)\n+\n+echo \"[AOT] std_example\"\n+$RUSTC example/std_example.rs --crate-type bin --target $TARGET_TRIPLE\n+$RUN_WRAPPER ./target/out/std_example arg\n+\n+echo \"[AOT] subslice-patterns-const-eval\"\n+$RUSTC example/subslice-patterns-const-eval.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n+$RUN_WRAPPER ./target/out/subslice-patterns-const-eval\n+\n+echo \"[AOT] track-caller-attribute\"\n+$RUSTC example/track-caller-attribute.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n+$RUN_WRAPPER ./target/out/track-caller-attribute\n+\n+echo \"[AOT] mod_bench\"\n+$RUSTC example/mod_bench.rs --crate-type bin --target $TARGET_TRIPLE\n+$RUN_WRAPPER ./target/out/mod_bench\n+\n+pushd rand\n+rm -r ./target || true\n+../cargo.sh test --workspace\n+popd\n+\n+pushd simple-raytracer\n+if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+    echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n+    hyperfine --runs ${RUN_RUNS:-10} --warmup 1 --prepare \"cargo clean\" \\\n+    \"RUSTC=rustc RUSTFLAGS='' cargo build\" \\\n+    \"../cargo.sh build\"\n+\n+    echo \"[BENCH RUN] ebobby/simple-raytracer\"\n+    cp ./target/debug/main ./raytracer_cg_clif\n+    hyperfine --runs ${RUN_RUNS:-10} ./raytracer_cg_llvm ./raytracer_cg_clif\n+else\n+    echo \"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\"\n+    echo \"[COMPILE] ebobby/simple-raytracer\"\n+    ../cargo.sh build\n+    echo \"[BENCH RUN] ebobby/simple-raytracer (skipped)\"\n+fi\n+popd\n+\n+pushd build_sysroot/sysroot_src/library/core/tests\n+echo \"[TEST] libcore\"\n+rm -r ./target || true\n+../../../../../cargo.sh test\n+popd\n+\n+pushd regex\n+echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n+../cargo.sh clean\n+# Make sure `[codegen mono items] start` doesn't poison the diff\n+../cargo.sh build --example shootout-regex-dna\n+cat examples/regexdna-input.txt | ../cargo.sh run --example shootout-regex-dna | grep -v \"Spawned thread\" > res.txt\n+diff -u res.txt examples/regexdna-output.txt\n+\n+echo \"[TEST] rust-lang/regex tests\"\n+../cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options\n+popd"}]}