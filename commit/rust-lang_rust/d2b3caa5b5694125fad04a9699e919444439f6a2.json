{"sha": "d2b3caa5b5694125fad04a9699e919444439f6a2", "node_id": "C_kwDOAAsO6NoAKGQyYjNjYWE1YjU2OTQxMjVmYWQwNGE5Njk5ZTkxOTQ0NDQzOWY2YTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-30T16:47:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-30T16:47:41Z"}, "message": "Auto merge of #14929 - Veykril:hover-hex, r=Veykril\n\nAdd render configs for memory layout hovers\n\nCloses https://github.com/rust-lang/rust-analyzer/issues/14918", "tree": {"sha": "46d165be01ef2a8cda06ff8802b2c745a7d24314", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46d165be01ef2a8cda06ff8802b2c745a7d24314"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2b3caa5b5694125fad04a9699e919444439f6a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2b3caa5b5694125fad04a9699e919444439f6a2", "html_url": "https://github.com/rust-lang/rust/commit/d2b3caa5b5694125fad04a9699e919444439f6a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2b3caa5b5694125fad04a9699e919444439f6a2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e33c0b4b5e24eb5035520fd582b9c02672b40481", "url": "https://api.github.com/repos/rust-lang/rust/commits/e33c0b4b5e24eb5035520fd582b9c02672b40481", "html_url": "https://github.com/rust-lang/rust/commit/e33c0b4b5e24eb5035520fd582b9c02672b40481"}, {"sha": "3c862507b9ab8154bb9ccf41f7568a4ca69bac93", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c862507b9ab8154bb9ccf41f7568a4ca69bac93", "html_url": "https://github.com/rust-lang/rust/commit/3c862507b9ab8154bb9ccf41f7568a4ca69bac93"}], "stats": {"total": 563, "additions": 400, "deletions": 163}, "files": [{"sha": "eee45b74d94dc5f5679511e86021cc275d20bada", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=d2b3caa5b5694125fad04a9699e919444439f6a2", "patch": "@@ -45,7 +45,7 @@ use hir_def::{\n     hir::{BindingAnnotation, BindingId, ExprOrPatId, LabelId, Pat},\n     item_tree::ItemTreeNode,\n     lang_item::LangItemTarget,\n-    layout::{self, ReprOptions},\n+    layout::{self, ReprOptions, TargetDataLayout},\n     macro_id_to_def_id,\n     nameres::{self, diagnostics::DefDiagnostic, ModuleOrigin},\n     per_ns::PerNs,\n@@ -62,7 +62,7 @@ use hir_ty::{\n     consteval::{try_const_usize, unknown_const_as_generic, ConstEvalError, ConstExt},\n     diagnostics::BodyValidationDiagnostic,\n     display::HexifiedConst,\n-    layout::{Layout as TyLayout, LayoutError, RustcEnumVariantIdx, TagEncoding},\n+    layout::{Layout as TyLayout, RustcEnumVariantIdx, TagEncoding},\n     method_resolution::{self, TyFingerprint},\n     mir::{self, interpret_mir},\n     primitive::UintTy,\n@@ -133,6 +133,7 @@ pub use {\n     },\n     hir_ty::{\n         display::{ClosureStyle, HirDisplay, HirDisplayError, HirWrite},\n+        layout::LayoutError,\n         mir::MirEvalError,\n         PointerCast, Safety,\n     },\n@@ -962,7 +963,8 @@ impl Field {\n     }\n \n     pub fn layout(&self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {\n-        db.layout_of_ty(self.ty(db).ty.clone(), self.parent.module(db).krate().into()).map(Layout)\n+        db.layout_of_ty(self.ty(db).ty.clone(), self.parent.module(db).krate().into())\n+            .map(|layout| Layout(layout, db.target_data_layout(self.krate(db).into()).unwrap()))\n     }\n \n     pub fn parent_def(&self, _db: &dyn HirDatabase) -> VariantDef {\n@@ -1135,23 +1137,8 @@ impl Enum {\n         self.variants(db).iter().any(|v| !matches!(v.kind(db), StructKind::Unit))\n     }\n \n-    pub fn layout(self, db: &dyn HirDatabase) -> Result<(Layout, usize), LayoutError> {\n-        let layout = Adt::from(self).layout(db)?;\n-        let tag_size =\n-            if let layout::Variants::Multiple { tag, tag_encoding, .. } = &layout.0.variants {\n-                match tag_encoding {\n-                    TagEncoding::Direct => {\n-                        let target_data_layout = db\n-                            .target_data_layout(self.module(db).krate().id)\n-                            .ok_or(LayoutError::TargetLayoutNotAvailable)?;\n-                        tag.size(&*target_data_layout).bytes_usize()\n-                    }\n-                    TagEncoding::Niche { .. } => 0,\n-                }\n-            } else {\n-                0\n-            };\n-        Ok((layout, tag_size))\n+    pub fn layout(self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {\n+        Adt::from(self).layout(db)\n     }\n }\n \n@@ -1214,19 +1201,16 @@ impl Variant {\n         db.const_eval_discriminant(self.into())\n     }\n \n-    /// Return layout of the variant and tag size of the parent enum.\n-    pub fn layout(&self, db: &dyn HirDatabase) -> Result<(Layout, usize), LayoutError> {\n+    pub fn layout(&self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {\n         let parent_enum = self.parent_enum(db);\n-        let (parent_layout, tag_size) = parent_enum.layout(db)?;\n-        Ok((\n-            match &parent_layout.0.variants {\n-                layout::Variants::Multiple { variants, .. } => {\n-                    Layout(Arc::new(variants[RustcEnumVariantIdx(self.id)].clone()))\n-                }\n-                _ => parent_layout,\n-            },\n-            tag_size,\n-        ))\n+        let parent_layout = parent_enum.layout(db)?;\n+        Ok(match &parent_layout.0.variants {\n+            layout::Variants::Multiple { variants, .. } => Layout(\n+                Arc::new(variants[RustcEnumVariantIdx(self.id)].clone()),\n+                db.target_data_layout(parent_enum.krate(db).into()).unwrap(),\n+            ),\n+            _ => parent_layout,\n+        })\n     }\n }\n \n@@ -1259,7 +1243,9 @@ impl Adt {\n         if db.generic_params(self.into()).iter().count() != 0 {\n             return Err(LayoutError::HasPlaceholder);\n         }\n-        db.layout_of_adt(self.into(), Substitution::empty(Interner), self.krate(db).id).map(Layout)\n+        let krate = self.krate(db).id;\n+        db.layout_of_adt(self.into(), Substitution::empty(Interner), krate)\n+            .map(|layout| Layout(layout, db.target_data_layout(krate).unwrap()))\n     }\n \n     /// Turns this ADT into a type. Any type parameters of the ADT will be\n@@ -4244,7 +4230,8 @@ impl Type {\n     }\n \n     pub fn layout(&self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {\n-        db.layout_of_ty(self.ty.clone(), self.env.krate).map(Layout)\n+        db.layout_of_ty(self.ty.clone(), self.env.krate)\n+            .map(|layout| Layout(layout, db.target_data_layout(self.env.krate).unwrap()))\n     }\n }\n \n@@ -4356,7 +4343,7 @@ fn closure_source(db: &dyn HirDatabase, closure: ClosureId) -> Option<ast::Closu\n }\n \n #[derive(Clone, Debug, Eq, PartialEq)]\n-pub struct Layout(Arc<TyLayout>);\n+pub struct Layout(Arc<TyLayout>, Arc<TargetDataLayout>);\n \n impl Layout {\n     pub fn size(&self) -> u64 {\n@@ -4367,8 +4354,8 @@ impl Layout {\n         self.0.align.abi.bytes()\n     }\n \n-    pub fn niches(&self, db: &dyn HirDatabase, krate: Crate) -> Option<u128> {\n-        Some(self.0.largest_niche?.available(&*db.target_data_layout(krate.id)?))\n+    pub fn niches(&self) -> Option<u128> {\n+        Some(self.0.largest_niche?.available(&*self.1))\n     }\n \n     pub fn field_offset(&self, idx: usize) -> Option<u64> {\n@@ -4382,6 +4369,19 @@ impl Layout {\n             layout::FieldsShape::Arbitrary { ref offsets, .. } => Some(offsets.get(idx)?.bytes()),\n         }\n     }\n+\n+    pub fn enum_tag_size(&self) -> Option<usize> {\n+        let tag_size =\n+            if let layout::Variants::Multiple { tag, tag_encoding, .. } = &self.0.variants {\n+                match tag_encoding {\n+                    TagEncoding::Direct => tag.size(&*self.1).bytes_usize(),\n+                    TagEncoding::Niche { .. } => 0,\n+                }\n+            } else {\n+                return None;\n+            };\n+        Some(tag_size)\n+    }\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]"}, {"sha": "fe1cb6fce3630de794425904a8258a665da12092", "filename": "crates/ide-assists/src/handlers/convert_named_struct_to_tuple_struct.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs?ref=d2b3caa5b5694125fad04a9699e919444439f6a2", "patch": "@@ -55,7 +55,8 @@ pub(crate) fn convert_named_struct_to_tuple_struct(\n     // XXX: We don't currently provide this assist for struct definitions inside macros, but if we\n     // are to lift this limitation, don't forget to make `edit_struct_def()` consider macro files\n     // too.\n-    let strukt = ctx.find_node_at_offset::<Either<ast::Struct, ast::Variant>>()?;\n+    let name = ctx.find_node_at_offset::<ast::Name>()?;\n+    let strukt = name.syntax().parent().and_then(<Either<ast::Struct, ast::Variant>>::cast)?;\n     let field_list = strukt.as_ref().either(|s| s.field_list(), |v| v.field_list())?;\n     let record_fields = match field_list {\n         ast::FieldList::RecordFieldList(it) => it,"}, {"sha": "017853a4a2023ceb512b24ac33f702a4ae9eca77", "filename": "crates/ide-assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=d2b3caa5b5694125fad04a9699e919444439f6a2", "patch": "@@ -50,7 +50,8 @@ pub(crate) fn convert_tuple_struct_to_named_struct(\n     acc: &mut Assists,\n     ctx: &AssistContext<'_>,\n ) -> Option<()> {\n-    let strukt = ctx.find_node_at_offset::<Either<ast::Struct, ast::Variant>>()?;\n+    let name = ctx.find_node_at_offset::<ast::Name>()?;\n+    let strukt = name.syntax().parent().and_then(<Either<ast::Struct, ast::Variant>>::cast)?;\n     let field_list = strukt.as_ref().either(|s| s.field_list(), |v| v.field_list())?;\n     let tuple_fields = match field_list {\n         ast::FieldList::TupleFieldList(it) => it,"}, {"sha": "344f2bfcce14adb564169250ed67be089fe7158a", "filename": "crates/ide-assists/src/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests.rs?ref=d2b3caa5b5694125fad04a9699e919444439f6a2", "patch": "@@ -273,8 +273,9 @@ fn assist_order_field_struct() {\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Generate a getter method\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Generate a mut getter method\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Generate a setter method\");\n-    assert_eq!(assists.next().expect(\"expected assist\").label, \"Convert to tuple struct\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Add `#[derive]`\");\n+    assert_eq!(assists.next().expect(\"expected assist\").label, \"Generate `new`\");\n+    assert_eq!(assists.next().map(|it| it.label.to_string()), None);\n }\n \n #[test]"}, {"sha": "5ef6ac9480721c92e859b93f62e07113761ee778", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=d2b3caa5b5694125fad04a9699e919444439f6a2", "patch": "@@ -27,12 +27,27 @@ use crate::{\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct HoverConfig {\n     pub links_in_hover: bool,\n-    pub memory_layout: bool,\n+    pub memory_layout: Option<MemoryLayoutHoverConfig>,\n     pub documentation: bool,\n     pub keywords: bool,\n     pub format: HoverDocFormat,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct MemoryLayoutHoverConfig {\n+    pub size: Option<MemoryLayoutHoverRenderKind>,\n+    pub offset: Option<MemoryLayoutHoverRenderKind>,\n+    pub alignment: Option<MemoryLayoutHoverRenderKind>,\n+    pub niches: bool,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum MemoryLayoutHoverRenderKind {\n+    Decimal,\n+    Hexadecimal,\n+    Both,\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum HoverDocFormat {\n     Markdown,"}, {"sha": "1362146413e0d89a98cc2144747d4ad4046681d7", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 145, "deletions": 81, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=d2b3caa5b5694125fad04a9699e919444439f6a2", "patch": "@@ -3,8 +3,8 @@ use std::fmt::Display;\n \n use either::Either;\n use hir::{\n-    Adt, AsAssocItem, AttributeTemplate, CaptureKind, HasAttrs, HasCrate, HasSource, HirDisplay,\n-    Layout, Semantics, TypeInfo,\n+    Adt, AsAssocItem, AttributeTemplate, CaptureKind, HasAttrs, HasSource, HirDisplay, Layout,\n+    LayoutError, Semantics, TypeInfo,\n };\n use ide_db::{\n     base_db::SourceDatabase,\n@@ -27,7 +27,8 @@ use syntax::{\n use crate::{\n     doc_links::{remove_links, rewrite_links},\n     hover::walk_and_push_ty,\n-    HoverAction, HoverConfig, HoverResult, Markup,\n+    HoverAction, HoverConfig, HoverResult, Markup, MemoryLayoutHoverConfig,\n+    MemoryLayoutHoverRenderKind,\n };\n \n pub(super) fn type_info_of(\n@@ -393,32 +394,27 @@ pub(super) fn definition(\n     let mod_path = definition_mod_path(db, &def);\n     let (label, docs) = match def {\n         Definition::Macro(it) => label_and_docs(db, it),\n-        Definition::Field(it) => label_and_layout_info_and_docs(db, it, config, |&it| {\n-            let var_def = it.parent_def(db);\n-            let id = it.index();\n-            let layout = it.layout(db).ok()?;\n-            let offset = match var_def {\n-                hir::VariantDef::Struct(s) => Adt::from(s)\n-                    .layout(db)\n-                    .ok()\n-                    .and_then(|layout| Some(format!(\", offset = {:#X}\", layout.field_offset(id)?))),\n-                _ => None,\n-            };\n-            let niches = niches(db, it, &layout).unwrap_or_default();\n-            Some(format!(\n-                \"size = {:#X}, align = {:#X}{}{niches}\",\n-                layout.size(),\n-                layout.align(),\n-                offset.as_deref().unwrap_or_default()\n-            ))\n-        }),\n+        Definition::Field(it) => label_and_layout_info_and_docs(\n+            db,\n+            it,\n+            config,\n+            |&it| it.layout(db),\n+            |_| {\n+                let var_def = it.parent_def(db);\n+                let id = it.index();\n+                match var_def {\n+                    hir::VariantDef::Struct(s) => {\n+                        Adt::from(s).layout(db).ok().and_then(|layout| layout.field_offset(id))\n+                    }\n+                    _ => None,\n+                }\n+            },\n+        ),\n         Definition::Module(it) => label_and_docs(db, it),\n         Definition::Function(it) => label_and_docs(db, it),\n-        Definition::Adt(it) => label_and_layout_info_and_docs(db, it, config, |&it| {\n-            let layout = it.layout(db).ok()?;\n-            let niches = niches(db, it, &layout).unwrap_or_default();\n-            Some(format!(\"size = {:#X}, align = {:#X}{niches}\", layout.size(), layout.align()))\n-        }),\n+        Definition::Adt(it) => {\n+            label_and_layout_info_and_docs(db, it, config, |&it| it.layout(db), |_| None)\n+        }\n         Definition::Variant(it) => label_value_and_layout_info_and_docs(\n             db,\n             it,\n@@ -435,16 +431,8 @@ pub(super) fn definition(\n                     None\n                 }\n             },\n-            |&it| {\n-                let (layout, tag_size) = it.layout(db).ok()?;\n-                let size = layout.size() as usize - tag_size;\n-                if size == 0 {\n-                    // There is no value in showing layout info for fieldless variants\n-                    return None;\n-                }\n-                let niches = niches(db, it, &layout).unwrap_or_default();\n-                Some(format!(\"size = {:#X}{niches}\", layout.size()))\n-            },\n+            |it| it.layout(db),\n+            |layout| layout.enum_tag_size(),\n         ),\n         Definition::Const(it) => label_value_and_docs(db, it, |it| {\n             let body = it.render_eval(db);\n@@ -470,11 +458,9 @@ pub(super) fn definition(\n         }),\n         Definition::Trait(it) => label_and_docs(db, it),\n         Definition::TraitAlias(it) => label_and_docs(db, it),\n-        Definition::TypeAlias(it) => label_and_layout_info_and_docs(db, it, config, |&it| {\n-            let layout = it.ty(db).layout(db).ok()?;\n-            let niches = niches(db, it, &layout).unwrap_or_default();\n-            Some(format!(\"size = {:#X}, align = {:#X}{niches}\", layout.size(), layout.align(),))\n-        }),\n+        Definition::TypeAlias(it) => {\n+            label_and_layout_info_and_docs(db, it, config, |&it| it.ty(db).layout(db), |_| None)\n+        }\n         Definition::BuiltinType(it) => {\n             return famous_defs\n                 .and_then(|fd| builtin(fd, it))\n@@ -509,10 +495,6 @@ pub(super) fn definition(\n     markup(docs, label, mod_path)\n }\n \n-fn niches(db: &RootDatabase, it: impl HasCrate, layout: &Layout) -> Option<String> {\n-    Some(format!(\", niches = {}\", layout.niches(db, it.krate(db).into())?))\n-}\n-\n fn type_info(\n     sema: &Semantics<'_, RootDatabase>,\n     config: &HoverConfig,\n@@ -557,14 +539,6 @@ fn closure_ty(\n     TypeInfo { original, adjusted }: &TypeInfo,\n ) -> Option<HoverResult> {\n     let c = original.as_closure()?;\n-    let layout = if config.memory_layout {\n-        original\n-            .layout(sema.db)\n-            .map(|x| format!(\" // size = {}, align = {}\", x.size(), x.align()))\n-            .unwrap_or_default()\n-    } else {\n-        String::default()\n-    };\n     let mut captures_rendered = c.captured_items(sema.db)\n         .into_iter()\n         .map(|it| {\n@@ -600,17 +574,23 @@ fn closure_ty(\n     } else {\n         String::new()\n     };\n+    let mut markup = format!(\"```rust\\n{}\", c.display_with_id(sema.db),);\n \n-    let mut res = HoverResult::default();\n-    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n-    res.markup = format!(\n-        \"```rust\\n{}{}\\n{}\\n```{adjusted}\\n\\n## Captures\\n{}\",\n-        c.display_with_id(sema.db),\n-        layout,\n+    if let Some(layout) =\n+        render_memory_layout(config.memory_layout, || original.layout(sema.db), |_| None, |_| None)\n+    {\n+        format_to!(markup, \"{layout}\");\n+    }\n+    format_to!(\n+        markup,\n+        \"\\n{}\\n```{adjusted}\\n\\n## Captures\\n{}\",\n         c.display_with_impl(sema.db),\n         captures_rendered,\n-    )\n-    .into();\n+    );\n+\n+    let mut res = HoverResult::default();\n+    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n+    res.markup = markup.into();\n     Some(res)\n }\n \n@@ -644,48 +624,59 @@ where\n     (label, docs)\n }\n \n-fn label_and_layout_info_and_docs<D, E, V>(\n+fn label_and_layout_info_and_docs<D, E, E2>(\n     db: &RootDatabase,\n     def: D,\n     config: &HoverConfig,\n     layout_extractor: E,\n+    layout_offset_extractor: E2,\n ) -> (String, Option<hir::Documentation>)\n where\n     D: HasAttrs + HirDisplay,\n-    E: Fn(&D) -> Option<V>,\n-    V: Display,\n+    E: Fn(&D) -> Result<Layout, LayoutError>,\n+    E2: Fn(&Layout) -> Option<u64>,\n {\n-    let label = match config.memory_layout.then(|| layout_extractor(&def)).flatten() {\n-        Some(layout) => format!(\"{} // {layout}\", def.display(db)),\n-        _ => def.display(db).to_string(),\n-    };\n+    let mut label = def.display(db).to_string();\n+    if let Some(layout) = render_memory_layout(\n+        config.memory_layout,\n+        || layout_extractor(&def),\n+        layout_offset_extractor,\n+        |_| None,\n+    ) {\n+        format_to!(label, \"{layout}\");\n+    }\n     let docs = def.attrs(db).docs();\n     (label, docs)\n }\n \n-fn label_value_and_layout_info_and_docs<D, E, E2, V, L>(\n+fn label_value_and_layout_info_and_docs<D, E, E2, E3, V>(\n     db: &RootDatabase,\n     def: D,\n     config: &HoverConfig,\n     value_extractor: E,\n     layout_extractor: E2,\n+    layout_tag_extractor: E3,\n ) -> (String, Option<hir::Documentation>)\n where\n     D: HasAttrs + HirDisplay,\n     E: Fn(&D) -> Option<V>,\n-    E2: Fn(&D) -> Option<L>,\n+    E2: Fn(&D) -> Result<Layout, LayoutError>,\n+    E3: Fn(&Layout) -> Option<usize>,\n     V: Display,\n-    L: Display,\n {\n     let value = value_extractor(&def);\n-    let label = match value {\n+    let mut label = match value {\n         Some(value) => format!(\"{} = {value}\", def.display(db)),\n         None => def.display(db).to_string(),\n     };\n-    let label = match config.memory_layout.then(|| layout_extractor(&def)).flatten() {\n-        Some(layout) => format!(\"{} // {layout}\", label),\n-        _ => label,\n-    };\n+    if let Some(layout) = render_memory_layout(\n+        config.memory_layout,\n+        || layout_extractor(&def),\n+        |_| None,\n+        layout_tag_extractor,\n+    ) {\n+        format_to!(label, \"{layout}\");\n+    }\n     let docs = def.attrs(db).docs();\n     (label, docs)\n }\n@@ -769,14 +760,87 @@ fn local(db: &RootDatabase, it: hir::Local, config: &HoverConfig) -> Option<Mark\n         }\n         None => format!(\"{is_mut}self: {ty}\"),\n     };\n-    if config.memory_layout {\n-        if let Ok(layout) = it.ty(db).layout(db) {\n-            format_to!(desc, \" // size = {}, align = {}\", layout.size(), layout.align());\n-        }\n+    if let Some(layout) =\n+        render_memory_layout(config.memory_layout, || it.ty(db).layout(db), |_| None, |_| None)\n+    {\n+        format_to!(desc, \"{layout}\");\n     }\n     markup(None, desc, None)\n }\n \n+fn render_memory_layout(\n+    config: Option<MemoryLayoutHoverConfig>,\n+    layout: impl FnOnce() -> Result<Layout, LayoutError>,\n+    offset: impl FnOnce(&Layout) -> Option<u64>,\n+    tag: impl FnOnce(&Layout) -> Option<usize>,\n+) -> Option<String> {\n+    // field\n+\n+    let config = config?;\n+    let layout = layout().ok()?;\n+\n+    let mut label = String::from(\" // \");\n+\n+    if let Some(render) = config.size {\n+        let size = match tag(&layout) {\n+            Some(tag) => layout.size() as usize - tag,\n+            None => layout.size() as usize,\n+        };\n+        format_to!(label, \"size = \");\n+        match render {\n+            MemoryLayoutHoverRenderKind::Decimal => format_to!(label, \"{size}\"),\n+            MemoryLayoutHoverRenderKind::Hexadecimal => format_to!(label, \"{size:#X}\"),\n+            MemoryLayoutHoverRenderKind::Both if size >= 10 => {\n+                format_to!(label, \"{size} ({size:#X})\")\n+            }\n+            MemoryLayoutHoverRenderKind::Both => format_to!(label, \"{size}\"),\n+        }\n+        format_to!(label, \", \");\n+    }\n+\n+    if let Some(render) = config.alignment {\n+        let align = layout.align();\n+        format_to!(label, \"align = \");\n+        match render {\n+            MemoryLayoutHoverRenderKind::Decimal => format_to!(label, \"{align}\",),\n+            MemoryLayoutHoverRenderKind::Hexadecimal => format_to!(label, \"{align:#X}\",),\n+            MemoryLayoutHoverRenderKind::Both if align >= 10 => {\n+                format_to!(label, \"{align} ({align:#X})\")\n+            }\n+            MemoryLayoutHoverRenderKind::Both => {\n+                format_to!(label, \"{align}\")\n+            }\n+        }\n+        format_to!(label, \", \");\n+    }\n+\n+    if let Some(render) = config.offset {\n+        if let Some(offset) = offset(&layout) {\n+            format_to!(label, \"offset = \");\n+            match render {\n+                MemoryLayoutHoverRenderKind::Decimal => format_to!(label, \"{offset}\"),\n+                MemoryLayoutHoverRenderKind::Hexadecimal => format_to!(label, \"{offset:#X}\"),\n+                MemoryLayoutHoverRenderKind::Both if offset >= 10 => {\n+                    format_to!(label, \"{offset} ({offset:#X})\")\n+                }\n+                MemoryLayoutHoverRenderKind::Both => {\n+                    format_to!(label, \"{offset}\")\n+                }\n+            }\n+            format_to!(label, \", \");\n+        }\n+    }\n+\n+    if config.niches {\n+        if let Some(niches) = layout.niches() {\n+            format_to!(label, \"niches = {niches}, \");\n+        }\n+    }\n+    label.pop(); // ' '\n+    label.pop(); // ','\n+    Some(label)\n+}\n+\n struct KeywordHint {\n     description: String,\n     keyword_mod: String,"}, {"sha": "f2ee79a23e6f3f8ef34b9be111cfd3e392342258", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=d2b3caa5b5694125fad04a9699e919444439f6a2", "patch": "@@ -2,11 +2,18 @@ use expect_test::{expect, Expect};\n use ide_db::base_db::{FileLoader, FileRange};\n use syntax::TextRange;\n \n-use crate::{fixture, HoverConfig, HoverDocFormat};\n+use crate::{\n+    fixture, HoverConfig, HoverDocFormat, MemoryLayoutHoverConfig, MemoryLayoutHoverRenderKind,\n+};\n \n const HOVER_BASE_CONFIG: HoverConfig = HoverConfig {\n     links_in_hover: false,\n-    memory_layout: true,\n+    memory_layout: Some(MemoryLayoutHoverConfig {\n+        size: Some(MemoryLayoutHoverRenderKind::Both),\n+        offset: Some(MemoryLayoutHoverRenderKind::Both),\n+        alignment: Some(MemoryLayoutHoverRenderKind::Both),\n+        niches: true,\n+    }),\n     documentation: true,\n     format: HoverDocFormat::Markdown,\n     keywords: true,\n@@ -62,7 +69,7 @@ fn check_hover_no_memory_layout(ra_fixture: &str, expect: Expect) {\n     let (analysis, position) = fixture::position(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig { memory_layout: false, ..HOVER_BASE_CONFIG },\n+            &HoverConfig { memory_layout: None, ..HOVER_BASE_CONFIG },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n         .unwrap()\n@@ -237,7 +244,7 @@ fn main() {\n         expect![[r#\"\n             *|*\n             ```rust\n-            {closure#0} // size = 8, align = 8\n+            {closure#0} // size = 8, align = 8, niches = 1\n             impl Fn(i32) -> i32\n             ```\n \n@@ -292,7 +299,7 @@ fn main() {\n         expect![[r#\"\n             *|*\n             ```rust\n-            {closure#0} // size = 16, align = 8\n+            {closure#0} // size = 16 (0x10), align = 8, niches = 1\n             impl FnOnce()\n             ```\n \n@@ -320,7 +327,7 @@ fn main() {\n         expect![[r#\"\n             *|*\n             ```rust\n-            {closure#0} // size = 8, align = 8\n+            {closure#0} // size = 8, align = 8, niches = 1\n             impl FnMut()\n             ```\n \n@@ -344,7 +351,7 @@ fn main() {\n \"#,\n         expect![[r#\"\n             ```rust\n-            {closure#0} // size = 8, align = 8\n+            {closure#0} // size = 8, align = 8, niches = 1\n             impl FnOnce() -> S2\n             ```\n             Coerced to: &impl FnOnce() -> S2\n@@ -667,7 +674,7 @@ struct Foo { fiel$0d_a: u8, field_b: i32, field_c: i16 }\n             ```\n \n             ```rust\n-            field_a: u8 // size = 0x1, align = 0x1, offset = 0x4\n+            field_a: u8 // size = 1, align = 1, offset = 4\n             ```\n         \"#]],\n     );\n@@ -692,7 +699,7 @@ fn main() {\n             ```\n \n             ```rust\n-            field_a: u32 // size = 0x4, align = 0x4, offset = 0x0\n+            field_a: u32 // size = 4, align = 4, offset = 0\n             ```\n         \"#]],\n     );\n@@ -714,7 +721,7 @@ fn main() {\n             ```\n \n             ```rust\n-            field_a: u32 // size = 0x4, align = 0x4, offset = 0x0\n+            field_a: u32 // size = 4, align = 4, offset = 0\n             ```\n         \"#]],\n     );\n@@ -1528,7 +1535,7 @@ fn test_hover_function_pointer_show_identifiers() {\n             ```\n \n             ```rust\n-            type foo = fn(a: i32, b: i32) -> i32 // size = 0x8, align = 0x8, niches = 1\n+            type foo = fn(a: i32, b: i32) -> i32 // size = 8, align = 8, niches = 1\n             ```\n         \"#]],\n     );\n@@ -1546,7 +1553,7 @@ fn test_hover_function_pointer_no_identifier() {\n             ```\n \n             ```rust\n-            type foo = fn(i32, i32) -> i32 // size = 0x8, align = 0x8, niches = 1\n+            type foo = fn(i32, i32) -> i32 // size = 8, align = 8, niches = 1\n             ```\n         \"#]],\n     );\n@@ -1674,7 +1681,7 @@ fn foo() { let bar = Ba$0r; }\n             ```\n \n             ```rust\n-            struct Bar // size = 0x0, align = 0x1\n+            struct Bar // size = 0, align = 1\n             ```\n \n             ---\n@@ -1710,7 +1717,7 @@ fn foo() { let bar = Ba$0r; }\n             ```\n \n             ```rust\n-            struct Bar // size = 0x0, align = 0x1\n+            struct Bar // size = 0, align = 1\n             ```\n \n             ---\n@@ -1739,7 +1746,7 @@ fn foo() { let bar = Ba$0r; }\n             ```\n \n             ```rust\n-            struct Bar // size = 0x0, align = 0x1\n+            struct Bar // size = 0, align = 1\n             ```\n \n             ---\n@@ -1767,7 +1774,7 @@ pub struct B$0ar\n             ```\n \n             ```rust\n-            pub struct Bar // size = 0x0, align = 0x1\n+            pub struct Bar // size = 0, align = 1\n             ```\n \n             ---\n@@ -1794,7 +1801,7 @@ pub struct B$0ar\n             ```\n \n             ```rust\n-            pub struct Bar // size = 0x0, align = 0x1\n+            pub struct Bar // size = 0, align = 1\n             ```\n \n             ---\n@@ -1883,7 +1890,7 @@ fn test_hover_layout_of_variant() {\n             ```\n \n             ```rust\n-            Variant1(u8, u16) // size = 0x4\n+            Variant1(u8, u16) // size = 4, align = 2\n             ```\n         \"#]],\n     );\n@@ -1904,7 +1911,7 @@ fn test_hover_layout_of_enum() {\n             ```\n \n             ```rust\n-            enum Foo // size = 0x10, align = 0x8, niches = 254\n+            enum Foo // size = 16 (0x10), align = 8, niches = 254\n             ```\n         \"#]],\n     );\n@@ -3204,7 +3211,7 @@ fn main() {\n             *f*\n \n             ```rust\n-            f: &i32 // size = 8, align = 8\n+            f: &i32 // size = 8, align = 8, niches = 1\n             ```\n             ---\n \n@@ -3213,7 +3220,7 @@ fn main() {\n             ```\n \n             ```rust\n-            f: i32 // size = 0x4, align = 0x4, offset = 0x0\n+            f: i32 // size = 4, align = 4, offset = 0\n             ```\n         \"#]],\n     );\n@@ -3353,7 +3360,7 @@ impl Foo {\n             *self*\n \n             ```rust\n-            self: &Foo // size = 8, align = 8\n+            self: &Foo // size = 8, align = 8, niches = 1\n             ```\n         \"#]],\n     );\n@@ -3758,7 +3765,7 @@ type Fo$0o2 = Foo<2>;\n             ```\n \n             ```rust\n-            type Foo2 = Foo<2> // size = 0x0, align = 0x1\n+            type Foo2 = Foo<2> // size = 0, align = 1\n             ```\n         \"#]],\n     );\n@@ -3800,7 +3807,7 @@ enum E {\n             ```\n \n             ```rust\n-            A = 8\n+            A = 8 // size = 1, align = 1\n             ```\n \n             ---\n@@ -3825,7 +3832,7 @@ enum E {\n             ```\n \n             ```rust\n-            A = 12 (0xC)\n+            A = 12 (0xC) // size = 1, align = 1\n             ```\n \n             ---\n@@ -3851,7 +3858,7 @@ enum E {\n             ```\n \n             ```rust\n-            B = 2\n+            B = 2 // size = 1, align = 1\n             ```\n \n             ---\n@@ -3877,7 +3884,7 @@ enum E {\n             ```\n \n             ```rust\n-            B = 5\n+            B = 5 // size = 1, align = 1\n             ```\n \n             ---\n@@ -4411,7 +4418,7 @@ fn foo(e: E) {\n             ```\n \n             ```rust\n-            A = 3\n+            A = 3 // size = 0, align = 1\n             ```\n \n             ---\n@@ -4433,7 +4440,7 @@ fn main() {\n             *tile4*\n \n             ```rust\n-            let tile4: [u32; 8] // size = 32, align = 4\n+            let tile4: [u32; 8] // size = 32 (0x20), align = 4\n             ```\n         \"#]],\n     );\n@@ -4669,7 +4676,7 @@ pub fn gimme() -> theitem::TheItem {\n             ```\n \n             ```rust\n-            pub struct TheItem // size = 0x0, align = 0x1\n+            pub struct TheItem // size = 0, align = 1\n             ```\n \n             ---\n@@ -4817,7 +4824,7 @@ mod string {\n             ```\n \n             ```rust\n-            struct String // size = 0x0, align = 0x1\n+            struct String // size = 0, align = 1\n             ```\n \n             ---\n@@ -5486,7 +5493,7 @@ foo_macro!(\n             ```\n \n             ```rust\n-            pub struct Foo // size = 0x0, align = 0x1\n+            pub struct Foo // size = 0, align = 1\n             ```\n \n             ---\n@@ -5511,7 +5518,7 @@ pub struct Foo(i32);\n             ```\n \n             ```rust\n-            pub struct Foo // size = 0x4, align = 0x4\n+            pub struct Foo // size = 4, align = 4\n             ```\n \n             ---\n@@ -5610,7 +5617,7 @@ enum Enum {\n             ```\n \n             ```rust\n-            RecordV { field: u32 } // size = 0x4\n+            RecordV { field: u32 } // size = 4, align = 4\n             ```\n         \"#]],\n     );\n@@ -5632,7 +5639,7 @@ enum Enum {\n             ```\n \n             ```rust\n-            field: u32 // size = 0x4, align = 0x4\n+            field: u32 // size = 4, align = 4\n             ```\n         \"#]],\n     );\n@@ -6134,7 +6141,7 @@ fn test() {\n             ```\n \n             ```rust\n-            f: u32 // size = 0x4, align = 0x4, offset = 0x0\n+            f: u32 // size = 4, align = 4, offset = 0\n             ```\n         \"#]],\n     );"}, {"sha": "87e769e423073e39f7449e65d519bf8544dc8a5a", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=d2b3caa5b5694125fad04a9699e919444439f6a2", "patch": "@@ -84,7 +84,10 @@ pub use crate::{\n     file_structure::{StructureNode, StructureNodeKind},\n     folding_ranges::{Fold, FoldKind},\n     highlight_related::{HighlightRelatedConfig, HighlightedRange},\n-    hover::{HoverAction, HoverConfig, HoverDocFormat, HoverGotoTypeData, HoverResult},\n+    hover::{\n+        HoverAction, HoverConfig, HoverDocFormat, HoverGotoTypeData, HoverResult,\n+        MemoryLayoutHoverConfig, MemoryLayoutHoverRenderKind,\n+    },\n     inlay_hints::{\n         AdjustmentHints, AdjustmentHintsMode, ClosureReturnTypeHints, DiscriminantHints, InlayHint,\n         InlayHintLabel, InlayHintLabelPart, InlayHintPosition, InlayHintsConfig, InlayKind,"}, {"sha": "3e3d9f8f85c45f89f77f07eb5558466ac534bcfa", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=d2b3caa5b5694125fad04a9699e919444439f6a2", "patch": "@@ -138,7 +138,7 @@ impl StaticIndex<'_> {\n         });\n         let hover_config = HoverConfig {\n             links_in_hover: true,\n-            memory_layout: true,\n+            memory_layout: None,\n             documentation: true,\n             keywords: true,\n             format: crate::HoverDocFormat::Markdown,"}, {"sha": "6355c620f78026f67c150f92ba28eca23a26a454", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b3caa5b5694125fad04a9699e919444439f6a2/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=d2b3caa5b5694125fad04a9699e919444439f6a2", "patch": "@@ -14,7 +14,7 @@ use flycheck::FlycheckConfig;\n use ide::{\n     AssistConfig, CallableSnippets, CompletionConfig, DiagnosticsConfig, ExprFillDefaultMode,\n     HighlightConfig, HighlightRelatedConfig, HoverConfig, HoverDocFormat, InlayHintsConfig,\n-    JoinLinesConfig, Snippet, SnippetScope,\n+    JoinLinesConfig, MemoryLayoutHoverConfig, MemoryLayoutHoverRenderKind, Snippet, SnippetScope,\n };\n use ide_db::{\n     imports::insert_use::{ImportGranularity, InsertUseConfig, PrefixKind},\n@@ -317,8 +317,16 @@ config_data! {\n         hover_documentation_keywords_enable: bool  = \"true\",\n         /// Use markdown syntax for links on hover.\n         hover_links_enable: bool = \"true\",\n+        /// How to render the align information in a memory layout hover.\n+        hover_memoryLayout_alignment: Option<MemoryLayoutHoverRenderKindDef> = \"\\\"hexadecimal\\\"\",\n         /// Whether to show memory layout data on hover.\n         hover_memoryLayout_enable: bool = \"true\",\n+        /// How to render the niche information in a memory layout hover.\n+        hover_memoryLayout_niches: Option<bool> = \"false\",\n+        /// How to render the offset information in a memory layout hover.\n+        hover_memoryLayout_offset: Option<MemoryLayoutHoverRenderKindDef> = \"\\\"hexadecimal\\\"\",\n+        /// How to render the size information in a memory layout hover.\n+        hover_memoryLayout_size: Option<MemoryLayoutHoverRenderKindDef> = \"\\\"both\\\"\",\n \n         /// Whether to enforce the import granularity setting for all files. If set to false rust-analyzer will try to keep import styles consistent per file.\n         imports_granularity_enforce: bool              = \"false\",\n@@ -1514,9 +1522,19 @@ impl Config {\n     }\n \n     pub fn hover(&self) -> HoverConfig {\n+        let mem_kind = |kind| match kind {\n+            MemoryLayoutHoverRenderKindDef::Both => MemoryLayoutHoverRenderKind::Both,\n+            MemoryLayoutHoverRenderKindDef::Decimal => MemoryLayoutHoverRenderKind::Decimal,\n+            MemoryLayoutHoverRenderKindDef::Hexadecimal => MemoryLayoutHoverRenderKind::Hexadecimal,\n+        };\n         HoverConfig {\n             links_in_hover: self.data.hover_links_enable,\n-            memory_layout: self.data.hover_memoryLayout_enable,\n+            memory_layout: self.data.hover_memoryLayout_enable.then_some(MemoryLayoutHoverConfig {\n+                size: self.data.hover_memoryLayout_size.map(mem_kind),\n+                offset: self.data.hover_memoryLayout_offset.map(mem_kind),\n+                alignment: self.data.hover_memoryLayout_alignment.map(mem_kind),\n+                niches: self.data.hover_memoryLayout_niches.unwrap_or_default(),\n+            }),\n             documentation: self.data.hover_documentation_enable,\n             format: {\n                 let is_markdown = try_or_def!(self\n@@ -1726,6 +1744,9 @@ mod de_unit_v {\n     named_unit_variant!(reborrow);\n     named_unit_variant!(fieldless);\n     named_unit_variant!(with_block);\n+    named_unit_variant!(decimal);\n+    named_unit_variant!(hexadecimal);\n+    named_unit_variant!(both);\n }\n \n #[derive(Deserialize, Debug, Clone, Copy)]\n@@ -1956,6 +1977,18 @@ enum WorkspaceSymbolSearchKindDef {\n     AllSymbols,\n }\n \n+#[derive(Deserialize, Debug, Copy, Clone)]\n+#[serde(rename_all = \"snake_case\")]\n+#[serde(untagged)]\n+pub enum MemoryLayoutHoverRenderKindDef {\n+    #[serde(deserialize_with = \"de_unit_v::decimal\")]\n+    Decimal,\n+    #[serde(deserialize_with = \"de_unit_v::hexadecimal\")]\n+    Hexadecimal,\n+    #[serde(deserialize_with = \"de_unit_v::both\")]\n+    Both,\n+}\n+\n macro_rules! _config_data {\n     (struct $name:ident {\n         $(\n@@ -2038,7 +2071,9 @@ fn get_field<T: DeserializeOwned>(\n                 None\n             }\n         })\n-        .unwrap_or_else(|| serde_json::from_str(default).unwrap())\n+        .unwrap_or_else(|| {\n+            serde_json::from_str(default).unwrap_or_else(|e| panic!(\"{e} on: `{default}`\"))\n+        })\n }\n \n fn schema(fields: &[(&'static str, &'static str, &[&str], &str)]) -> serde_json::Value {\n@@ -2366,6 +2401,22 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 \"`hide`: Shows `...` for every closure type\",\n             ],\n         },\n+        \"Option<MemoryLayoutHoverRenderKindDef>\" => set! {\n+            \"anyOf\": [\n+                {\n+                    \"type\": \"null\"\n+                },\n+                {\n+                    \"type\": \"string\",\n+                    \"enum\": [\"both\", \"decimal\", \"hexadecimal\", ],\n+                    \"enumDescriptions\": [\n+                        \"Render as 12 (0xC)\",\n+                        \"Render as 12\",\n+                        \"Render as 0xC\"\n+                    ],\n+                },\n+            ],\n+        },\n         _ => panic!(\"missing entry for {ty}: {default}\"),\n     }\n "}, {"sha": "ea00c9540ff14dc1da18f44d8062a49d3a0287e6", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2b3caa5b5694125fad04a9699e919444439f6a2/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/d2b3caa5b5694125fad04a9699e919444439f6a2/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=d2b3caa5b5694125fad04a9699e919444439f6a2", "patch": "@@ -428,11 +428,31 @@ Whether to show keyword hover popups. Only applies when\n --\n Use markdown syntax for links on hover.\n --\n+[[rust-analyzer.hover.memoryLayout.alignment]]rust-analyzer.hover.memoryLayout.alignment (default: `\"hexadecimal\"`)::\n++\n+--\n+How to render the align information in a memory layout hover.\n+--\n [[rust-analyzer.hover.memoryLayout.enable]]rust-analyzer.hover.memoryLayout.enable (default: `true`)::\n +\n --\n Whether to show memory layout data on hover.\n --\n+[[rust-analyzer.hover.memoryLayout.niches]]rust-analyzer.hover.memoryLayout.niches (default: `false`)::\n++\n+--\n+How to render the niche information in a memory layout hover.\n+--\n+[[rust-analyzer.hover.memoryLayout.offset]]rust-analyzer.hover.memoryLayout.offset (default: `\"hexadecimal\"`)::\n++\n+--\n+How to render the offset information in a memory layout hover.\n+--\n+[[rust-analyzer.hover.memoryLayout.size]]rust-analyzer.hover.memoryLayout.size (default: `\"both\"`)::\n++\n+--\n+How to render the size information in a memory layout hover.\n+--\n [[rust-analyzer.imports.granularity.enforce]]rust-analyzer.imports.granularity.enforce (default: `false`)::\n +\n --"}, {"sha": "ee1f832d323f77ceed1cf1477ecb1c4e4fdfabb6", "filename": "editors/code/package.json", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d2b3caa5b5694125fad04a9699e919444439f6a2/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/d2b3caa5b5694125fad04a9699e919444439f6a2/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=d2b3caa5b5694125fad04a9699e919444439f6a2", "patch": "@@ -966,11 +966,85 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.hover.memoryLayout.alignment\": {\n+                    \"markdownDescription\": \"How to render the align information in a memory layout hover.\",\n+                    \"default\": \"hexadecimal\",\n+                    \"anyOf\": [\n+                        {\n+                            \"type\": \"null\"\n+                        },\n+                        {\n+                            \"type\": \"string\",\n+                            \"enum\": [\n+                                \"both\",\n+                                \"decimal\",\n+                                \"hexadecimal\"\n+                            ],\n+                            \"enumDescriptions\": [\n+                                \"Render as 12 (0xC)\",\n+                                \"Render as 12\",\n+                                \"Render as 0xC\"\n+                            ]\n+                        }\n+                    ]\n+                },\n                 \"rust-analyzer.hover.memoryLayout.enable\": {\n                     \"markdownDescription\": \"Whether to show memory layout data on hover.\",\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.hover.memoryLayout.niches\": {\n+                    \"markdownDescription\": \"How to render the niche information in a memory layout hover.\",\n+                    \"default\": false,\n+                    \"type\": [\n+                        \"null\",\n+                        \"boolean\"\n+                    ]\n+                },\n+                \"rust-analyzer.hover.memoryLayout.offset\": {\n+                    \"markdownDescription\": \"How to render the offset information in a memory layout hover.\",\n+                    \"default\": \"hexadecimal\",\n+                    \"anyOf\": [\n+                        {\n+                            \"type\": \"null\"\n+                        },\n+                        {\n+                            \"type\": \"string\",\n+                            \"enum\": [\n+                                \"both\",\n+                                \"decimal\",\n+                                \"hexadecimal\"\n+                            ],\n+                            \"enumDescriptions\": [\n+                                \"Render as 12 (0xC)\",\n+                                \"Render as 12\",\n+                                \"Render as 0xC\"\n+                            ]\n+                        }\n+                    ]\n+                },\n+                \"rust-analyzer.hover.memoryLayout.size\": {\n+                    \"markdownDescription\": \"How to render the size information in a memory layout hover.\",\n+                    \"default\": \"both\",\n+                    \"anyOf\": [\n+                        {\n+                            \"type\": \"null\"\n+                        },\n+                        {\n+                            \"type\": \"string\",\n+                            \"enum\": [\n+                                \"both\",\n+                                \"decimal\",\n+                                \"hexadecimal\"\n+                            ],\n+                            \"enumDescriptions\": [\n+                                \"Render as 12 (0xC)\",\n+                                \"Render as 12\",\n+                                \"Render as 0xC\"\n+                            ]\n+                        }\n+                    ]\n+                },\n                 \"rust-analyzer.imports.granularity.enforce\": {\n                     \"markdownDescription\": \"Whether to enforce the import granularity setting for all files. If set to false rust-analyzer will try to keep import styles consistent per file.\",\n                     \"default\": false,"}]}