{"sha": "c7420ddaaa76741d1eebe393406b38ba5596e54a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NDIwZGRhYWE3Njc0MWQxZWViZTM5MzQwNmIzOGJhNTU5NmU1NGE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-24T21:12:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-24T21:12:26Z"}, "message": "Merge #1845\n\n1845: Closure types r=flodiebold a=flodiebold\n\nThis adds types for closures and makes them implement the `Fn` traits (we don't currently care or try to infer `Fn` vs. `FnMut` vs. `FnOnce`; this would require move analysis, I think).\r\n\r\nThis requires some changes in Chalk; one is that we need to know the self type when asked for impls, so we can synthesize `Fn` trait impls for closures; but also there's a problem that prevents us from normalizing the closure output type correctly that I _think_ will be fixed on the Chalk side (basically, we ask too early and try to solve `Normalize(<?1 as FnOnce<(u32,)>>::Output => ?0)` -- note the variable in the self type -- and instead of an ambiguous answer, we get back that it can't be solved, so we don't try again. Niko mentioned he's making all goals where the self type is unconstrained flounder, which I think would mean this would be ambiguous).\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "ff9c2f3c665ef95ebf509dc69ff82d39ec42d176", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff9c2f3c665ef95ebf509dc69ff82d39ec42d176"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7420ddaaa76741d1eebe393406b38ba5596e54a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdioa6CRBK7hj4Ov3rIwAAdHIIADdKXyNi/AndsiO4R5zBo1oF\nDGqXTgpq3EXHC7p5KtErWVCspV/e4vidzWuzmF5WiuqykSFM9uZL9xNxWg8unHmx\nEmTFx/tiYrVaQZBRdHVKPzLwniZybtMtV9wNr//KKb2/5P/1sKAWEo2GJ1Ktdxbz\nfz6cx2zkGT8bZ4VWjIBnTiEwhcEKoJEtNVQsZIA/qb0Zfpilhj6jrKnC2fAHWYop\nGhnao6nU+Exv1W7uMgX2geK5nOo/JBnnqxBHLWeI/vuXa364Tmw9sQBmKrRM6FyT\ndgbdzjoqiKDsmK+YgpjRtx19No1JMf+XInk3CQ18HaI6to7do3sQOXSbWQHpcvo=\n=58gE\n-----END PGP SIGNATURE-----\n", "payload": "tree ff9c2f3c665ef95ebf509dc69ff82d39ec42d176\nparent 36fb3f53d712a11b7e3fc4bbd92094d1c8f19522\nparent 6a8670665032f6103ca14e38ed9106126b20063d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1569359546 +0000\ncommitter GitHub <noreply@github.com> 1569359546 +0000\n\nMerge #1845\n\n1845: Closure types r=flodiebold a=flodiebold\n\nThis adds types for closures and makes them implement the `Fn` traits (we don't currently care or try to infer `Fn` vs. `FnMut` vs. `FnOnce`; this would require move analysis, I think).\r\n\r\nThis requires some changes in Chalk; one is that we need to know the self type when asked for impls, so we can synthesize `Fn` trait impls for closures; but also there's a problem that prevents us from normalizing the closure output type correctly that I _think_ will be fixed on the Chalk side (basically, we ask too early and try to solve `Normalize(<?1 as FnOnce<(u32,)>>::Output => ?0)` -- note the variable in the self type -- and instead of an ambiguous answer, we get back that it can't be solved, so we don't try again. Niko mentioned he's making all goals where the self type is unconstrained flounder, which I think would mean this would be ambiguous).\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7420ddaaa76741d1eebe393406b38ba5596e54a", "html_url": "https://github.com/rust-lang/rust/commit/c7420ddaaa76741d1eebe393406b38ba5596e54a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7420ddaaa76741d1eebe393406b38ba5596e54a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36fb3f53d712a11b7e3fc4bbd92094d1c8f19522", "url": "https://api.github.com/repos/rust-lang/rust/commits/36fb3f53d712a11b7e3fc4bbd92094d1c8f19522", "html_url": "https://github.com/rust-lang/rust/commit/36fb3f53d712a11b7e3fc4bbd92094d1c8f19522"}, {"sha": "6a8670665032f6103ca14e38ed9106126b20063d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a8670665032f6103ca14e38ed9106126b20063d", "html_url": "https://github.com/rust-lang/rust/commit/6a8670665032f6103ca14e38ed9106126b20063d"}], "stats": {"total": 457, "additions": 385, "deletions": 72}, "files": [{"sha": "99c247a0b296e2bef6ba8137692cfddbe7520954", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c7420ddaaa76741d1eebe393406b38ba5596e54a/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7420ddaaa76741d1eebe393406b38ba5596e54a/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=c7420ddaaa76741d1eebe393406b38ba5596e54a", "patch": "@@ -551,6 +551,14 @@ impl DefWithBody {\n             DefWithBody::Static(s) => s.resolver(db),\n         }\n     }\n+\n+    pub(crate) fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n+        match self {\n+            DefWithBody::Const(c) => c.krate(db),\n+            DefWithBody::Function(f) => f.krate(db),\n+            DefWithBody::Static(s) => s.krate(db),\n+        }\n+    }\n }\n \n pub trait HasBody: Copy {\n@@ -671,6 +679,10 @@ impl Function {\n         self.id.module(db)\n     }\n \n+    pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n+        self.module(db).krate(db)\n+    }\n+\n     pub fn name(self, db: &impl HirDatabase) -> Name {\n         self.data(db).name.clone()\n     }\n@@ -745,6 +757,10 @@ impl Const {\n         self.id.module(db)\n     }\n \n+    pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n+        self.module(db).krate(db)\n+    }\n+\n     pub fn data(self, db: &impl HirDatabase) -> Arc<ConstData> {\n         db.const_data(self)\n     }\n@@ -824,6 +840,10 @@ impl Static {\n         self.id.module(db)\n     }\n \n+    pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n+        self.module(db).krate(db)\n+    }\n+\n     pub fn data(self, db: &impl HirDatabase) -> Arc<ConstData> {\n         db.static_data(self)\n     }"}, {"sha": "2b20ae02b08ceac6788fc6c50c655085e1ae890e", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7420ddaaa76741d1eebe393406b38ba5596e54a/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7420ddaaa76741d1eebe393406b38ba5596e54a/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=c7420ddaaa76741d1eebe393406b38ba5596e54a", "patch": "@@ -13,8 +13,8 @@ use crate::{\n     nameres::{CrateDefMap, ImportSourceMap, Namespace, RawItems},\n     traits::TraitData,\n     ty::{\n-        method_resolution::CrateImplBlocks, CallableDef, FnSig, GenericPredicate, InferenceResult,\n-        Substs, Ty, TypableDef, TypeCtor,\n+        method_resolution::CrateImplBlocks, traits::Impl, CallableDef, FnSig, GenericPredicate,\n+        InferenceResult, Substs, Ty, TypableDef, TypeCtor,\n     },\n     type_alias::TypeAliasData,\n     AstIdMap, Const, ConstData, Crate, DefWithBody, Enum, ErasedFileAstId, ExprScopes, FnData,\n@@ -50,7 +50,7 @@ pub trait InternDatabase: SourceDatabase {\n     #[salsa::interned]\n     fn intern_type_ctor(&self, type_ctor: TypeCtor) -> ids::TypeCtorId;\n     #[salsa::interned]\n-    fn intern_impl_block(&self, impl_block: ImplBlock) -> ids::GlobalImplId;\n+    fn intern_impl(&self, impl_: Impl) -> ids::GlobalImplId;\n }\n \n /// This database has access to source code, so queries here are not really"}, {"sha": "e6ecbe1ea7f62921226360f2bcc9dde7b53e9402", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c7420ddaaa76741d1eebe393406b38ba5596e54a/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7420ddaaa76741d1eebe393406b38ba5596e54a/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=c7420ddaaa76741d1eebe393406b38ba5596e54a", "patch": "@@ -16,7 +16,10 @@ use std::ops::Deref;\n use std::sync::Arc;\n use std::{fmt, mem};\n \n-use crate::{db::HirDatabase, type_ref::Mutability, Adt, GenericParams, Name, Trait, TypeAlias};\n+use crate::{\n+    db::HirDatabase, expr::ExprId, type_ref::Mutability, Adt, DefWithBody, GenericParams, Name,\n+    Trait, TypeAlias,\n+};\n use display::{HirDisplay, HirFormatter};\n \n pub(crate) use autoderef::autoderef;\n@@ -100,6 +103,12 @@ pub enum TypeCtor {\n     /// couldn't find a better representation.  In that case, we generate\n     /// an **application type** like `(Iterator::Item)<T>`.\n     AssociatedType(TypeAlias),\n+\n+    /// The type of a specific closure.\n+    ///\n+    /// The closure signature is stored in a `FnPtr` type in the first type\n+    /// parameter.\n+    Closure { def: DefWithBody, expr: ExprId },\n }\n \n /// A nominal type with (maybe 0) type parameters. This might be a primitive\n@@ -481,6 +490,10 @@ impl Ty {\n                     let sig = db.callable_item_signature(def);\n                     Some(sig.subst(&a_ty.parameters))\n                 }\n+                TypeCtor::Closure { .. } => {\n+                    let sig_param = &a_ty.parameters[0];\n+                    sig_param.callable_sig(db)\n+                }\n                 _ => None,\n             },\n             _ => None,\n@@ -720,6 +733,14 @@ impl HirDisplay for ApplicationTy {\n                     write!(f, \">\")?;\n                 }\n             }\n+            TypeCtor::Closure { .. } => {\n+                let sig = self.parameters[0]\n+                    .callable_sig(f.db)\n+                    .expect(\"first closure parameter should contain signature\");\n+                write!(f, \"|\")?;\n+                f.write_joined(sig.params(), \", \")?;\n+                write!(f, \"| -> {}\", sig.ret().display(f.db))?;\n+            }\n         }\n         Ok(())\n     }"}, {"sha": "378d2f829e13a38d0f2aa84c218285954301c93e", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 49, "deletions": 14, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c7420ddaaa76741d1eebe393406b38ba5596e54a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7420ddaaa76741d1eebe393406b38ba5596e54a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=c7420ddaaa76741d1eebe393406b38ba5596e54a", "patch": "@@ -790,11 +790,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n         self.unify(&expected_receiver_ty, &actual_receiver_ty);\n \n-        let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n-        for (arg, param_ty) in args.iter().zip(param_iter) {\n-            let param_ty = self.normalize_associated_types_in(param_ty);\n-            self.infer_expr(*arg, &Expectation::has_type(param_ty));\n-        }\n+        self.check_call_arguments(args, &param_tys);\n         let ret_ty = self.normalize_associated_types_in(ret_ty);\n         ret_ty\n     }\n@@ -885,18 +881,37 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Lambda { body, args, arg_types } => {\n                 assert_eq!(args.len(), arg_types.len());\n \n+                let mut sig_tys = Vec::new();\n+\n                 for (arg_pat, arg_type) in args.iter().zip(arg_types.iter()) {\n                     let expected = if let Some(type_ref) = arg_type {\n                         self.make_ty(type_ref)\n                     } else {\n                         Ty::Unknown\n                     };\n-                    self.infer_pat(*arg_pat, &expected, BindingMode::default());\n+                    let arg_ty = self.infer_pat(*arg_pat, &expected, BindingMode::default());\n+                    sig_tys.push(arg_ty);\n                 }\n \n-                // FIXME: infer lambda type etc.\n-                let _body_ty = self.infer_expr(*body, &Expectation::none());\n-                Ty::Unknown\n+                // add return type\n+                let ret_ty = self.new_type_var();\n+                sig_tys.push(ret_ty.clone());\n+                let sig_ty = Ty::apply(\n+                    TypeCtor::FnPtr { num_args: sig_tys.len() as u16 - 1 },\n+                    sig_tys.into(),\n+                );\n+                let closure_ty = Ty::apply_one(\n+                    TypeCtor::Closure { def: self.body.owner(), expr: tgt_expr },\n+                    sig_ty,\n+                );\n+\n+                // Eagerly try to relate the closure type with the expected\n+                // type, otherwise we often won't have enough information to\n+                // infer the body.\n+                self.coerce(&closure_ty, &expected.ty);\n+\n+                self.infer_expr(*body, &Expectation::has_type(ret_ty));\n+                closure_ty\n             }\n             Expr::Call { callee, args } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n@@ -909,11 +924,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     }\n                 };\n                 self.register_obligations_for_call(&callee_ty);\n-                let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n-                for (arg, param_ty) in args.iter().zip(param_iter) {\n-                    let param_ty = self.normalize_associated_types_in(param_ty);\n-                    self.infer_expr(*arg, &Expectation::has_type(param_ty));\n-                }\n+                self.check_call_arguments(args, &param_tys);\n                 let ret_ty = self.normalize_associated_types_in(ret_ty);\n                 ret_ty\n             }\n@@ -1255,6 +1266,30 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ty\n     }\n \n+    fn check_call_arguments(&mut self, args: &[ExprId], param_tys: &[Ty]) {\n+        // Quoting https://github.com/rust-lang/rust/blob/6ef275e6c3cb1384ec78128eceeb4963ff788dca/src/librustc_typeck/check/mod.rs#L3325 --\n+        // We do this in a pretty awful way: first we type-check any arguments\n+        // that are not closures, then we type-check the closures. This is so\n+        // that we have more information about the types of arguments when we\n+        // type-check the functions. This isn't really the right way to do this.\n+        for &check_closures in &[false, true] {\n+            let param_iter = param_tys.iter().cloned().chain(repeat(Ty::Unknown));\n+            for (&arg, param_ty) in args.iter().zip(param_iter) {\n+                let is_closure = match &self.body[arg] {\n+                    Expr::Lambda { .. } => true,\n+                    _ => false,\n+                };\n+\n+                if is_closure != check_closures {\n+                    continue;\n+                }\n+\n+                let param_ty = self.normalize_associated_types_in(param_ty);\n+                self.infer_expr(arg, &Expectation::has_type(param_ty));\n+            }\n+        }\n+    }\n+\n     fn collect_const(&mut self, data: &ConstData) {\n         self.return_ty = self.make_ty(data.type_ref());\n     }"}, {"sha": "2872cd27babf2139dd58e846cb60bebcbcae3310", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 122, "deletions": 43, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/c7420ddaaa76741d1eebe393406b38ba5596e54a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7420ddaaa76741d1eebe393406b38ba5596e54a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=c7420ddaaa76741d1eebe393406b38ba5596e54a", "patch": "@@ -1077,7 +1077,6 @@ fn test(x: &i32) {\n }\n \"#),\n         @r###\"\n-\n     [9; 10) 'x': &i32\n     [18; 369) '{     ...o_x; }': ()\n     [28; 29) 'y': &i32\n@@ -1107,8 +1106,8 @@ fn test(x: &i32) {\n     [177; 205) '{     ...     }': ()\n     [191; 192) 'h': {unknown}\n     [195; 198) 'val': {unknown}\n-    [215; 221) 'lambda': {unknown}\n-    [224; 256) '|a: u6...b; c }': {unknown}\n+    [215; 221) 'lambda': |u64, u64, i32| -> i32\n+    [224; 256) '|a: u6...b; c }': |u64, u64, i32| -> i32\n     [225; 226) 'a': u64\n     [233; 234) 'b': u64\n     [236; 237) 'c': i32\n@@ -2836,12 +2835,11 @@ fn test() -> u64 {\n }\n \"#),\n         @r###\"\n-\n     [44; 102) '{     ...0(2) }': u64\n     [54; 55) 'a': S\n     [58; 59) 'S': S(fn(u32) -> u64) -> S\n     [58; 68) 'S(|i| 2*i)': S\n-    [60; 67) '|i| 2*i': fn(u32) -> u64\n+    [60; 67) '|i| 2*i': |i32| -> i32\n     [61; 62) 'i': i32\n     [64; 65) '2': i32\n     [64; 67) '2*i': i32\n@@ -3802,13 +3800,13 @@ fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n     [296; 299) 'get': fn get<T>(T) -> <T as Trait>::Type\n     [296; 302) 'get(x)': {unknown}\n     [300; 301) 'x': T\n-    [308; 312) 'get2': fn get2<{unknown}, S<{unknown}>>(T) -> U\n+    [308; 312) 'get2': fn get2<{unknown}, T>(T) -> U\n     [308; 315) 'get2(x)': {unknown}\n     [313; 314) 'x': T\n     [321; 324) 'get': fn get<impl Trait<Type = i64>>(T) -> <T as Trait>::Type\n     [321; 327) 'get(y)': {unknown}\n     [325; 326) 'y': impl Trait<Type = i64>\n-    [333; 337) 'get2': fn get2<{unknown}, S<{unknown}>>(T) -> U\n+    [333; 337) 'get2': fn get2<{unknown}, impl Trait<Type = i64>>(T) -> U\n     [333; 340) 'get2(y)': {unknown}\n     [338; 339) 'y': impl Trait<Type = i64>\n     [346; 349) 'get': fn get<S<u64>>(T) -> <T as Trait>::Type\n@@ -3992,49 +3990,50 @@ fn test<F: FnOnce(u32, u64) -> u128>(f: F) {\n fn closure_1() {\n     assert_snapshot!(\n         infer(r#\"\n+#[lang = \"fn_once\"]\n trait FnOnce<Args> {\n     type Output;\n }\n \n enum Option<T> { Some(T), None }\n impl<T> Option<T> {\n-    fn map<U, F: FnOnce(T) -> U>(self, f: F) -> U {}\n+    fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {}\n }\n \n fn test() {\n-    let x = Option::Some(1i32);\n+    let x = Option::Some(1u32);\n     x.map(|v| v + 1);\n     x.map(|_v| 1u64);\n     let y: Option<i64> = x.map(|_v| 1);\n }\n \"#),\n         @r###\"\n-    [128; 132) 'self': Option<T>\n-    [134; 135) 'f': F\n-    [145; 147) '{}': ()\n-    [161; 280) '{     ... 1); }': ()\n-    [171; 172) 'x': Option<i32>\n-    [175; 187) 'Option::Some': Some<i32>(T) -> Option<T>\n-    [175; 193) 'Option...(1i32)': Option<i32>\n-    [188; 192) '1i32': i32\n-    [199; 200) 'x': Option<i32>\n-    [199; 215) 'x.map(...v + 1)': {unknown}\n-    [205; 214) '|v| v + 1': {unknown}\n-    [206; 207) 'v': {unknown}\n-    [209; 210) 'v': {unknown}\n-    [209; 214) 'v + 1': i32\n-    [213; 214) '1': i32\n-    [221; 222) 'x': Option<i32>\n-    [221; 237) 'x.map(... 1u64)': {unknown}\n-    [227; 236) '|_v| 1u64': {unknown}\n-    [228; 230) '_v': {unknown}\n-    [232; 236) '1u64': u64\n-    [247; 248) 'y': Option<i64>\n-    [264; 265) 'x': Option<i32>\n-    [264; 277) 'x.map(|_v| 1)': Option<i64>\n-    [270; 276) '|_v| 1': {unknown}\n-    [271; 273) '_v': {unknown}\n-    [275; 276) '1': i32\n+    [148; 152) 'self': Option<T>\n+    [154; 155) 'f': F\n+    [173; 175) '{}': ()\n+    [189; 308) '{     ... 1); }': ()\n+    [199; 200) 'x': Option<u32>\n+    [203; 215) 'Option::Some': Some<u32>(T) -> Option<T>\n+    [203; 221) 'Option...(1u32)': Option<u32>\n+    [216; 220) '1u32': u32\n+    [227; 228) 'x': Option<u32>\n+    [227; 243) 'x.map(...v + 1)': Option<u32>\n+    [233; 242) '|v| v + 1': |u32| -> u32\n+    [234; 235) 'v': u32\n+    [237; 238) 'v': u32\n+    [237; 242) 'v + 1': u32\n+    [241; 242) '1': u32\n+    [249; 250) 'x': Option<u32>\n+    [249; 265) 'x.map(... 1u64)': Option<u64>\n+    [255; 264) '|_v| 1u64': |u32| -> u64\n+    [256; 258) '_v': u32\n+    [260; 264) '1u64': u64\n+    [275; 276) 'y': Option<i64>\n+    [292; 293) 'x': Option<u32>\n+    [292; 305) 'x.map(|_v| 1)': Option<i64>\n+    [298; 304) '|_v| 1': |u32| -> i64\n+    [299; 301) '_v': u32\n+    [303; 304) '1': i64\n     \"###\n     );\n }\n@@ -4060,17 +4059,17 @@ fn test<F: FnOnce(u32) -> u64>(f: F) {\n     [85; 86) 'f': F\n     [85; 89) 'f(1)': {unknown}\n     [87; 88) '1': i32\n-    [99; 100) 'g': {unknown}\n-    [103; 112) '|v| v + 1': {unknown}\n-    [104; 105) 'v': {unknown}\n-    [107; 108) 'v': {unknown}\n+    [99; 100) 'g': |u64| -> i32\n+    [103; 112) '|v| v + 1': |u64| -> i32\n+    [104; 105) 'v': u64\n+    [107; 108) 'v': u64\n     [107; 112) 'v + 1': i32\n     [111; 112) '1': i32\n-    [118; 119) 'g': {unknown}\n-    [118; 125) 'g(1u64)': {unknown}\n+    [118; 119) 'g': |u64| -> i32\n+    [118; 125) 'g(1u64)': i32\n     [120; 124) '1u64': u64\n-    [135; 136) 'h': {unknown}\n-    [139; 152) '|v| 1u128 + v': {unknown}\n+    [135; 136) 'h': |u128| -> u128\n+    [139; 152) '|v| 1u128 + v': |u128| -> u128\n     [140; 141) 'v': u128\n     [143; 148) '1u128': u128\n     [143; 152) '1u128 + v': u128\n@@ -4079,6 +4078,86 @@ fn test<F: FnOnce(u32) -> u64>(f: F) {\n     );\n }\n \n+#[test]\n+fn closure_as_argument_inference_order() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+\n+fn foo1<T, U, F: FnOnce(T) -> U>(x: T, f: F) -> U {}\n+fn foo2<T, U, F: FnOnce(T) -> U>(f: F, x: T) -> U {}\n+\n+struct S;\n+impl S {\n+    fn method(self) -> u64;\n+\n+    fn foo1<T, U, F: FnOnce(T) -> U>(self, x: T, f: F) -> U {}\n+    fn foo2<T, U, F: FnOnce(T) -> U>(self, f: F, x: T) -> U {}\n+}\n+\n+fn test() {\n+    let x1 = foo1(S, |s| s.method());\n+    let x2 = foo2(|s| s.method(), S);\n+    let x3 = S.foo1(S, |s| s.method());\n+    let x4 = S.foo2(|s| s.method(), S);\n+}\n+\"#),\n+        @r###\"\n+    [95; 96) 'x': T\n+    [101; 102) 'f': F\n+    [112; 114) '{}': ()\n+    [148; 149) 'f': F\n+    [154; 155) 'x': T\n+    [165; 167) '{}': ()\n+    [202; 206) 'self': S\n+    [254; 258) 'self': S\n+    [260; 261) 'x': T\n+    [266; 267) 'f': F\n+    [277; 279) '{}': ()\n+    [317; 321) 'self': S\n+    [323; 324) 'f': F\n+    [329; 330) 'x': T\n+    [340; 342) '{}': ()\n+    [356; 515) '{     ... S); }': ()\n+    [366; 368) 'x1': u64\n+    [371; 375) 'foo1': fn foo1<S, u64, |S| -> u64>(T, F) -> U\n+    [371; 394) 'foo1(S...hod())': u64\n+    [376; 377) 'S': S\n+    [379; 393) '|s| s.method()': |S| -> u64\n+    [380; 381) 's': S\n+    [383; 384) 's': S\n+    [383; 393) 's.method()': u64\n+    [404; 406) 'x2': u64\n+    [409; 413) 'foo2': fn foo2<S, u64, |S| -> u64>(F, T) -> U\n+    [409; 432) 'foo2(|...(), S)': u64\n+    [414; 428) '|s| s.method()': |S| -> u64\n+    [415; 416) 's': S\n+    [418; 419) 's': S\n+    [418; 428) 's.method()': u64\n+    [430; 431) 'S': S\n+    [442; 444) 'x3': u64\n+    [447; 448) 'S': S\n+    [447; 472) 'S.foo1...hod())': u64\n+    [454; 455) 'S': S\n+    [457; 471) '|s| s.method()': |S| -> u64\n+    [458; 459) 's': S\n+    [461; 462) 's': S\n+    [461; 471) 's.method()': u64\n+    [482; 484) 'x4': u64\n+    [487; 488) 'S': S\n+    [487; 512) 'S.foo2...(), S)': u64\n+    [494; 508) '|s| s.method()': |S| -> u64\n+    [495; 496) 's': S\n+    [498; 499) 's': S\n+    [498; 508) 's.method()': u64\n+    [510; 511) 'S': S\n+    \"###\n+    );\n+}\n+\n #[test]\n fn unselected_projection_in_trait_env_1() {\n     let t = type_at("}, {"sha": "d11dab29403cb5f50122bfab659bb273ab96ab68", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c7420ddaaa76741d1eebe393406b38ba5596e54a/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7420ddaaa76741d1eebe393406b38ba5596e54a/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=c7420ddaaa76741d1eebe393406b38ba5596e54a", "patch": "@@ -9,7 +9,7 @@ use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n-use crate::{db::HirDatabase, Crate, ImplBlock, Trait};\n+use crate::{db::HirDatabase, expr::ExprId, Crate, DefWithBody, ImplBlock, Trait};\n \n use self::chalk::{from_chalk, ToChalk};\n \n@@ -173,6 +173,14 @@ pub(crate) fn trait_solve_query(\n ) -> Option<Solution> {\n     let _p = profile(\"trait_solve_query\");\n     debug!(\"trait_solve_query({})\", goal.value.value.display(db));\n+\n+    if let Obligation::Projection(pred) = &goal.value.value {\n+        if let Ty::Bound(_) = &pred.projection_ty.parameters[0] {\n+            // Hack: don't ask Chalk to normalize with an unknown self type, it'll say that's impossible\n+            return Some(Solution::Ambig(Guidance::Unknown));\n+        }\n+    }\n+\n     let canonical = goal.to_chalk(db).cast();\n     // We currently don't deal with universes (I think / hope they're not yet\n     // relevant for our use cases?)\n@@ -252,3 +260,37 @@ pub enum Guidance {\n     /// There's no useful information to feed back to type inference\n     Unknown,\n }\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub enum FnTrait {\n+    FnOnce,\n+    FnMut,\n+    Fn,\n+}\n+\n+impl FnTrait {\n+    fn lang_item_name(self) -> &'static str {\n+        match self {\n+            FnTrait::FnOnce => \"fn_once\",\n+            FnTrait::FnMut => \"fn_mut\",\n+            FnTrait::Fn => \"fn\",\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ClosureFnTraitImplData {\n+    def: DefWithBody,\n+    expr: ExprId,\n+    fn_trait: FnTrait,\n+}\n+\n+/// An impl. Usually this comes from an impl block, but some built-in types get\n+/// synthetic impls.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum Impl {\n+    /// A normal impl from an impl block.\n+    ImplBlock(ImplBlock),\n+    /// Closure types implement the Fn traits synthetically.\n+    ClosureFnTraitImpl(ClosureFnTraitImplData),\n+}"}, {"sha": "d83706f860376096d16b11a83bb2e6091b1736d5", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 126, "deletions": 10, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/c7420ddaaa76741d1eebe393406b38ba5596e54a/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7420ddaaa76741d1eebe393406b38ba5596e54a/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=c7420ddaaa76741d1eebe393406b38ba5596e54a", "patch": "@@ -12,7 +12,7 @@ use chalk_rust_ir::{AssociatedTyDatum, ImplDatum, StructDatum, TraitDatum};\n use ra_db::salsa::{InternId, InternKey};\n use test_utils::tested_by;\n \n-use super::{Canonical, ChalkContext, Obligation};\n+use super::{Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n     db::HirDatabase,\n     generics::GenericDef,\n@@ -111,7 +111,7 @@ impl ToChalk for Ty {\n             }\n             chalk_ir::Ty::ForAll(_) => unimplemented!(),\n             chalk_ir::Ty::BoundVar(idx) => Ty::Bound(idx as u32),\n-            chalk_ir::Ty::InferenceVar(_iv) => panic!(\"unexpected chalk infer ty\"),\n+            chalk_ir::Ty::InferenceVar(_iv) => Ty::Unknown,\n         }\n     }\n }\n@@ -175,15 +175,15 @@ impl ToChalk for TypeCtor {\n     }\n }\n \n-impl ToChalk for ImplBlock {\n+impl ToChalk for Impl {\n     type Chalk = chalk_ir::ImplId;\n \n     fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ImplId {\n-        db.intern_impl_block(self).into()\n+        db.intern_impl(self).into()\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, impl_id: chalk_ir::ImplId) -> ImplBlock {\n-        db.lookup_intern_impl_block(impl_id.into())\n+    fn from_chalk(db: &impl HirDatabase, impl_id: chalk_ir::ImplId) -> Impl {\n+        db.lookup_intern_impl(impl_id.into())\n     }\n }\n \n@@ -388,19 +388,36 @@ where\n     fn impls_for_trait(\n         &self,\n         trait_id: chalk_ir::TraitId,\n-        _parameters: &[Parameter],\n+        parameters: &[Parameter],\n     ) -> Vec<ImplId> {\n         debug!(\"impls_for_trait {:?}\", trait_id);\n         if trait_id == UNKNOWN_TRAIT {\n             return Vec::new();\n         }\n         let trait_: Trait = from_chalk(self.db, trait_id);\n-        let result: Vec<_> = self\n+        let mut result: Vec<_> = self\n             .db\n             .impls_for_trait(self.krate, trait_)\n             .iter()\n-            .map(|impl_block| impl_block.to_chalk(self.db))\n+            .copied()\n+            .map(Impl::ImplBlock)\n+            .map(|impl_| impl_.to_chalk(self.db))\n             .collect();\n+\n+        let ty: Ty = from_chalk(self.db, parameters[0].assert_ty_ref().clone());\n+        if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Closure { def, expr }, .. }) = ty {\n+            for &fn_trait in\n+                [super::FnTrait::FnOnce, super::FnTrait::FnMut, super::FnTrait::Fn].iter()\n+            {\n+                if let Some(actual_trait) = get_fn_trait(self.db, self.krate, fn_trait) {\n+                    if trait_ == actual_trait {\n+                        let impl_ = super::ClosureFnTraitImplData { def, expr, fn_trait };\n+                        result.push(Impl::ClosureFnTraitImpl(impl_).to_chalk(self.db));\n+                    }\n+                }\n+            }\n+        }\n+\n         debug!(\"impls_for_trait returned {} impls\", result.len());\n         result\n     }\n@@ -571,6 +588,10 @@ pub(crate) fn struct_datum_query(\n                 type_alias.krate(db) != Some(krate),\n             )\n         }\n+        TypeCtor::Closure { def, .. } => {\n+            let upstream = def.krate(db) != Some(krate);\n+            (1, vec![], upstream)\n+        }\n     };\n     let flags = chalk_rust_ir::StructFlags {\n         upstream,\n@@ -598,7 +619,21 @@ pub(crate) fn impl_datum_query(\n ) -> Arc<ImplDatum> {\n     let _p = ra_prof::profile(\"impl_datum\");\n     debug!(\"impl_datum {:?}\", impl_id);\n-    let impl_block: ImplBlock = from_chalk(db, impl_id);\n+    let impl_: Impl = from_chalk(db, impl_id);\n+    match impl_ {\n+        Impl::ImplBlock(impl_block) => impl_block_datum(db, krate, impl_id, impl_block),\n+        Impl::ClosureFnTraitImpl(data) => {\n+            closure_fn_trait_impl_datum(db, krate, impl_id, data).unwrap_or_else(invalid_impl_datum)\n+        }\n+    }\n+}\n+\n+fn impl_block_datum(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    impl_id: ImplId,\n+    impl_block: ImplBlock,\n+) -> Arc<ImplDatum> {\n     let generic_params = impl_block.generic_params(db);\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let trait_ref = impl_block\n@@ -657,6 +692,87 @@ pub(crate) fn impl_datum_query(\n     Arc::new(impl_datum)\n }\n \n+fn invalid_impl_datum() -> Arc<ImplDatum> {\n+    let trait_ref = chalk_ir::TraitRef {\n+        trait_id: UNKNOWN_TRAIT,\n+        parameters: vec![chalk_ir::Ty::BoundVar(0).cast()],\n+    };\n+    let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n+        trait_ref: chalk_rust_ir::PolarizedTraitRef::Positive(trait_ref),\n+        where_clauses: Vec::new(),\n+        associated_ty_values: Vec::new(),\n+        impl_type: chalk_rust_ir::ImplType::External,\n+    };\n+    let impl_datum = ImplDatum { binders: make_binders(impl_datum_bound, 1) };\n+    Arc::new(impl_datum)\n+}\n+\n+fn closure_fn_trait_impl_datum(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    impl_id: ImplId,\n+    data: super::ClosureFnTraitImplData,\n+) -> Option<Arc<ImplDatum>> {\n+    // for some closure |X, Y| -> Z:\n+    // impl<T, U, V> Fn<(T, U)> for closure<fn(T, U) -> V> { Output = V }\n+\n+    let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n+    let trait_ = get_fn_trait(db, krate, data.fn_trait)?; // get corresponding fn trait\n+\n+    let num_args: u16 = match &db.body_hir(data.def)[data.expr] {\n+        crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n+        _ => {\n+            log::warn!(\"closure for closure type {:?} not found\", data);\n+            0\n+        }\n+    };\n+\n+    let arg_ty = Ty::apply(\n+        TypeCtor::Tuple { cardinality: num_args },\n+        (0..num_args).map(|i| Ty::Bound(i.into())).collect::<Vec<_>>().into(),\n+    );\n+    let output_ty = Ty::Bound(num_args.into());\n+    let sig_ty = Ty::apply(\n+        TypeCtor::FnPtr { num_args },\n+        (0..num_args + 1).map(|i| Ty::Bound(i.into())).collect::<Vec<_>>().into(),\n+    );\n+\n+    let self_ty = Ty::apply_one(TypeCtor::Closure { def: data.def, expr: data.expr }, sig_ty);\n+\n+    let trait_ref = TraitRef { trait_, substs: vec![self_ty, arg_ty].into() };\n+\n+    let output_ty_id = fn_once_trait.associated_type_by_name(db, &crate::name::OUTPUT_TYPE)?;\n+\n+    let output_ty_value = chalk_rust_ir::AssociatedTyValue {\n+        associated_ty_id: output_ty_id.to_chalk(db),\n+        impl_id,\n+        value: make_binders(\n+            chalk_rust_ir::AssociatedTyValueBound { ty: output_ty.to_chalk(db) },\n+            0,\n+        ),\n+    };\n+\n+    let impl_type = chalk_rust_ir::ImplType::External;\n+\n+    let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n+        trait_ref: chalk_rust_ir::PolarizedTraitRef::Positive(trait_ref.to_chalk(db)),\n+        where_clauses: Vec::new(),\n+        associated_ty_values: vec![output_ty_value],\n+        impl_type,\n+    };\n+    let impl_datum = ImplDatum { binders: make_binders(impl_datum_bound, num_args as usize + 1) };\n+    Some(Arc::new(impl_datum))\n+}\n+\n+fn get_fn_trait(db: &impl HirDatabase, krate: Crate, fn_trait: super::FnTrait) -> Option<Trait> {\n+    let lang_items = db.lang_items(krate);\n+    let target = lang_items.target(fn_trait.lang_item_name())?;\n+    match target {\n+        crate::lang_item::LangItemTarget::Trait(t) => Some(*t),\n+        _ => None,\n+    }\n+}\n+\n fn id_from_chalk<T: InternKey>(chalk_id: chalk_ir::RawId) -> T {\n     T::from_intern_id(InternId::from(chalk_id.index))\n }"}]}