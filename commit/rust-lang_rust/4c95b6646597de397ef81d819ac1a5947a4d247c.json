{"sha": "4c95b6646597de397ef81d819ac1a5947a4d247c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjOTViNjY0NjU5N2RlMzk3ZWY4MWQ4MTlhYzFhNTk0N2E0ZDI0N2M=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2016-07-26T21:21:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-26T21:21:11Z"}, "message": "Rollup merge of #34609 - ubsan:transmute_docs, r=steveklabnik\n\nAdd more docs - mostly warnings - to std::mem::transmute", "tree": {"sha": "922d88d040fc3d4718d923c86ebf8dba7ee788c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/922d88d040fc3d4718d923c86ebf8dba7ee788c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c95b6646597de397ef81d819ac1a5947a4d247c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c95b6646597de397ef81d819ac1a5947a4d247c", "html_url": "https://github.com/rust-lang/rust/commit/4c95b6646597de397ef81d819ac1a5947a4d247c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c95b6646597de397ef81d819ac1a5947a4d247c/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "493cb979c6c07f42e861d2ab0daff8614faec99a", "url": "https://api.github.com/repos/rust-lang/rust/commits/493cb979c6c07f42e861d2ab0daff8614faec99a", "html_url": "https://github.com/rust-lang/rust/commit/493cb979c6c07f42e861d2ab0daff8614faec99a"}, {"sha": "24f8589bf3d4a198721a5ebe84679817cd1e205b", "url": "https://api.github.com/repos/rust-lang/rust/commits/24f8589bf3d4a198721a5ebe84679817cd1e205b", "html_url": "https://github.com/rust-lang/rust/commit/24f8589bf3d4a198721a5ebe84679817cd1e205b"}], "stats": {"total": 193, "additions": 188, "deletions": 5}, "files": [{"sha": "c645608dda7902ed3189dbe7ad6af7b948fdf1b4", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 188, "deletions": 5, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/4c95b6646597de397ef81d819ac1a5947a4d247c/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c95b6646597de397ef81d819ac1a5947a4d247c/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=4c95b6646597de397ef81d819ac1a5947a4d247c", "patch": "@@ -277,17 +277,200 @@ extern \"rust-intrinsic\" {\n     /// Moves a value out of scope without running drop glue.\n     pub fn forget<T>(_: T) -> ();\n \n-    /// Unsafely transforms a value of one type into a value of another type.\n+    /// Reinterprets the bits of a value of one type as another type; both types\n+    /// must have the same size. Neither the original, nor the result, may be an\n+    /// [invalid value] (../../nomicon/meet-safe-and-unsafe.html).\n     ///\n-    /// Both types must have the same size.\n+    /// `transmute` is semantically equivalent to a bitwise move of one type\n+    /// into another. It copies the bits from the destination type into the\n+    /// source type, then forgets the original. It's equivalent to C's `memcpy`\n+    /// under the hood, just like `transmute_copy`.\n+    ///\n+    /// `transmute` is incredibly unsafe. There are a vast number of ways to\n+    /// cause undefined behavior with this function. `transmute` should be\n+    /// the absolute last resort.\n+    ///\n+    /// The [nomicon](../../nomicon/transmutes.html) has additional\n+    /// documentation.\n     ///\n     /// # Examples\n     ///\n+    /// There are a few things that `transmute` is really useful for.\n+    ///\n+    /// Getting the bitpattern of a floating point type (or, more generally,\n+    /// type punning, when `T` and `U` aren't pointers):\n+    ///\n     /// ```\n-    /// use std::mem;\n+    /// let bitpattern = unsafe {\n+    ///     std::mem::transmute::<f32, u32>(1.0)\n+    /// };\n+    /// assert_eq!(bitpattern, 0x3F800000);\n+    /// ```\n+    ///\n+    /// Turning a pointer into a function pointer:\n+    ///\n+    /// ```\n+    /// fn foo() -> i32 {\n+    ///     0\n+    /// }\n+    /// let pointer = foo as *const ();\n+    /// let function = unsafe {\n+    ///     std::mem::transmute::<*const (), fn() -> i32>(pointer)\n+    /// };\n+    /// assert_eq!(function(), 0);\n+    /// ```\n+    ///\n+    /// Extending a lifetime, or shortening an invariant lifetime; this is\n+    /// advanced, very unsafe rust:\n+    ///\n+    /// ```\n+    /// struct R<'a>(&'a i32);\n+    /// unsafe fn extend_lifetime<'b>(r: R<'b>) -> R<'static> {\n+    ///     std::mem::transmute::<R<'b>, R<'static>>(r)\n+    /// }\n+    ///\n+    /// unsafe fn shorten_invariant_lifetime<'b, 'c>(r: &'b mut R<'static>)\n+    ///                                              -> &'b mut R<'c> {\n+    ///     std::mem::transmute::<&'b mut R<'static>, &'b mut R<'c>>(r)\n+    /// }\n+    /// ```\n+    ///\n+    /// # Alternatives\n+    ///\n+    /// However, many uses of `transmute` can be achieved through other means.\n+    /// `transmute` can transform any type into any other, with just the caveat\n+    /// that they're the same size, and often interesting results occur. Below\n+    /// are common applications of `transmute` which can be replaced with safe\n+    /// applications of `as`:\n     ///\n-    /// let array: &[u8] = unsafe { mem::transmute(\"Rust\") };\n-    /// assert_eq!(array, [82, 117, 115, 116]);\n+    /// Turning a pointer into a `usize`:\n+    ///\n+    /// ```\n+    /// let ptr = &0;\n+    /// let ptr_num_transmute = unsafe {\n+    ///     std::mem::transmute::<&i32, usize>(ptr)\n+    /// };\n+    /// // Use an `as` cast instead\n+    /// let ptr_num_cast = ptr as *const i32 as usize;\n+    /// ```\n+    ///\n+    /// Turning a `*mut T` into an `&mut T`:\n+    ///\n+    /// ```\n+    /// let ptr: *mut i32 = &mut 0;\n+    /// let ref_transmuted = unsafe {\n+    ///     std::mem::transmute::<*mut i32, &mut i32>(ptr)\n+    /// };\n+    /// // Use a reborrow instead\n+    /// let ref_casted = unsafe { &mut *ptr };\n+    /// ```\n+    ///\n+    /// Turning an `&mut T` into an `&mut U`:\n+    ///\n+    /// ```\n+    /// let ptr = &mut 0;\n+    /// let val_transmuted = unsafe {\n+    ///     std::mem::transmute::<&mut i32, &mut u32>(ptr)\n+    /// };\n+    /// // Now, put together `as` and reborrowing - note the chaining of `as`\n+    /// // `as` is not transitive\n+    /// let val_casts = unsafe { &mut *(ptr as *mut i32 as *mut u32) };\n+    /// ```\n+    ///\n+    /// Turning an `&str` into an `&[u8]`:\n+    ///\n+    /// ```\n+    /// // this is not a good way to do this.\n+    /// let slice = unsafe { std::mem::transmute::<&str, &[u8]>(\"Rust\") };\n+    /// assert_eq!(slice, &[82, 117, 115, 116]);\n+    /// // You could use `str::as_bytes`\n+    /// let slice = \"Rust\".as_bytes();\n+    /// assert_eq!(slice, &[82, 117, 115, 116]);\n+    /// // Or, just use a byte string, if you have control over the string\n+    /// // literal\n+    /// assert_eq!(b\"Rust\", &[82, 117, 115, 116]);\n+    /// ```\n+    ///\n+    /// Turning a `Vec<&T>` into a `Vec<Option<&T>>`:\n+    ///\n+    /// ```\n+    /// let store = [0, 1, 2, 3];\n+    /// let mut v_orig = store.iter().collect::<Vec<&i32>>();\n+    /// // Using transmute: this is Undefined Behavior, and a bad idea.\n+    /// // However, it is no-copy.\n+    /// let v_transmuted = unsafe {\n+    ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(\n+    ///         v_orig.clone())\n+    /// };\n+    /// // This is the suggested, safe way.\n+    /// // It does copy the entire Vector, though, into a new array.\n+    /// let v_collected = v_orig.clone()\n+    ///                         .into_iter()\n+    ///                         .map(|r| Some(r))\n+    ///                         .collect::<Vec<Option<&i32>>>();\n+    /// // The no-copy, unsafe way, still using transmute, but not UB.\n+    /// // This is equivalent to the original, but safer, and reuses the\n+    /// // same Vec internals. Therefore the new inner type must have the\n+    /// // exact same size, and the same or lesser alignment, as the old\n+    /// // type. The same caveats exist for this method as transmute, for\n+    /// // the original inner type (`&i32`) to the converted inner type\n+    /// // (`Option<&i32>`), so read the nomicon pages linked above.\n+    /// let v_from_raw = unsafe {\n+    ///     Vec::from_raw_parts(v_orig.as_mut_ptr(),\n+    ///                         v_orig.len(),\n+    ///                         v_orig.capacity())\n+    /// };\n+    /// std::mem::forget(v_orig);\n+    /// ```\n+    ///\n+    /// Implementing `split_at_mut`:\n+    ///\n+    /// ```\n+    /// use std::{slice, mem};\n+    /// // There are multiple ways to do this; and there are multiple problems\n+    /// // with the following, transmute, way.\n+    /// fn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\n+    ///                              -> (&mut [T], &mut [T]) {\n+    ///     let len = slice.len();\n+    ///     assert!(mid <= len);\n+    ///     unsafe {\n+    ///         let slice2 = mem::transmute::<&mut [T], &mut [T]>(slice);\n+    ///         // first: transmute is not typesafe; all it checks is that T and\n+    ///         // U are of the same size. Second, right here, you have two\n+    ///         // mutable references pointing to the same memory.\n+    ///         (&mut slice[0..mid], &mut slice2[mid..len])\n+    ///     }\n+    /// }\n+    /// // This gets rid of the typesafety problems; `&mut *` will *only* give\n+    /// // you an `&mut T` from an `&mut T` or `*mut T`.\n+    /// fn split_at_mut_casts<T>(slice: &mut [T], mid: usize)\n+    ///                          -> (&mut [T], &mut [T]) {\n+    ///     let len = slice.len();\n+    ///     assert!(mid <= len);\n+    ///     unsafe {\n+    ///         let slice2 = &mut *(slice as *mut [T]);\n+    ///         // however, you still have two mutable references pointing to\n+    ///         // the same memory.\n+    ///         (&mut slice[0..mid], &mut slice2[mid..len])\n+    ///     }\n+    /// }\n+    /// // This is how the standard library does it. This is the best method, if\n+    /// // you need to do something like this\n+    /// fn split_at_stdlib<T>(slice: &mut [T], mid: usize)\n+    ///                       -> (&mut [T], &mut [T]) {\n+    ///     let len = slice.len();\n+    ///     assert!(mid <= len);\n+    ///     unsafe {\n+    ///         let ptr = slice.as_mut_ptr();\n+    ///         // This now has three mutable references pointing at the same\n+    ///         // memory. `slice`, the rvalue ret.0, and the rvalue ret.1.\n+    ///         // `slice` is never used after `let ptr = ...`, and so one can\n+    ///         // treat it as \"dead\", and therefore, you only have two real\n+    ///         // mutable slices.\n+    ///         (slice::from_raw_parts_mut(ptr, mid),\n+    ///          slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n+    ///     }\n+    /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn transmute<T, U>(e: T) -> U;"}]}