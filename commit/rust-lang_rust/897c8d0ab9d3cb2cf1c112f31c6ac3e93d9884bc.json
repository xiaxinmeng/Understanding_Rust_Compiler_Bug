{"sha": "897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc", "node_id": "C_kwDOAAsO6NoAKDg5N2M4ZDBhYjlkM2NiMmNmMWMxMTJmMzFjNmFjM2U5M2Q5ODg0YmM", "commit": {"author": {"name": "Alex Saveau", "email": "saveau.alexandre@gmail.com", "date": "2022-02-13T23:04:11Z"}, "committer": {"name": "Alex Saveau", "email": "saveau.alexandre@gmail.com", "date": "2022-02-17T02:34:17Z"}, "message": "Add debug asserts to validate NUL terminator in c strings\n\nSigned-off-by: Alex Saveau <saveau.alexandre@gmail.com>", "tree": {"sha": "c5225865d65254954293e18fd5fd9f3a0e4c66cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5225865d65254954293e18fd5fd9f3a0e4c66cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYIAB0WIQTBcJf70cgSZQv+KO8/jVsW6xadSAUCYg20KQAKCRA/jVsW6xad\nSGx+AQDBuNxaDh1DRw7KHFRqE5zC/SvayNtZ5ykhQta8jZoXgAEAzR8Zu+5kHus5\ngXqo6ANPWVbYWv+OnGej0mU0Y6C6DAA=\n=B8lj\n-----END PGP SIGNATURE-----", "payload": "tree c5225865d65254954293e18fd5fd9f3a0e4c66cc\nparent 1e12aef3fab243407f9d71ba9956cb2a1bf105d5\nauthor Alex Saveau <saveau.alexandre@gmail.com> 1644793451 -0800\ncommitter Alex Saveau <saveau.alexandre@gmail.com> 1645065257 -0800\n\nAdd debug asserts to validate NUL terminator in c strings\n\nSigned-off-by: Alex Saveau <saveau.alexandre@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc", "html_url": "https://github.com/rust-lang/rust/commit/897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc/comments", "author": {"login": "SUPERCILEX", "id": 9490724, "node_id": "MDQ6VXNlcjk0OTA3MjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/9490724?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SUPERCILEX", "html_url": "https://github.com/SUPERCILEX", "followers_url": "https://api.github.com/users/SUPERCILEX/followers", "following_url": "https://api.github.com/users/SUPERCILEX/following{/other_user}", "gists_url": "https://api.github.com/users/SUPERCILEX/gists{/gist_id}", "starred_url": "https://api.github.com/users/SUPERCILEX/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SUPERCILEX/subscriptions", "organizations_url": "https://api.github.com/users/SUPERCILEX/orgs", "repos_url": "https://api.github.com/users/SUPERCILEX/repos", "events_url": "https://api.github.com/users/SUPERCILEX/events{/privacy}", "received_events_url": "https://api.github.com/users/SUPERCILEX/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SUPERCILEX", "id": 9490724, "node_id": "MDQ6VXNlcjk0OTA3MjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/9490724?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SUPERCILEX", "html_url": "https://github.com/SUPERCILEX", "followers_url": "https://api.github.com/users/SUPERCILEX/followers", "following_url": "https://api.github.com/users/SUPERCILEX/following{/other_user}", "gists_url": "https://api.github.com/users/SUPERCILEX/gists{/gist_id}", "starred_url": "https://api.github.com/users/SUPERCILEX/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SUPERCILEX/subscriptions", "organizations_url": "https://api.github.com/users/SUPERCILEX/orgs", "repos_url": "https://api.github.com/users/SUPERCILEX/repos", "events_url": "https://api.github.com/users/SUPERCILEX/events{/privacy}", "received_events_url": "https://api.github.com/users/SUPERCILEX/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e12aef3fab243407f9d71ba9956cb2a1bf105d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e12aef3fab243407f9d71ba9956cb2a1bf105d5", "html_url": "https://github.com/rust-lang/rust/commit/1e12aef3fab243407f9d71ba9956cb2a1bf105d5"}], "stats": {"total": 49, "additions": 29, "deletions": 20}, "files": [{"sha": "b52cc97504a2462cb6176cfbf61f6bb7c942c947", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc", "patch": "@@ -382,7 +382,7 @@ impl CString {\n                 let bytes: Vec<u8> = self.into();\n                 match memchr::memchr(0, &bytes) {\n                     Some(i) => Err(NulError(i, bytes)),\n-                    None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n+                    None => Ok(unsafe { CString::_from_vec_unchecked(bytes) }),\n                 }\n             }\n         }\n@@ -405,7 +405,7 @@ impl CString {\n             // This allows better optimizations if lto enabled.\n             match memchr::memchr(0, bytes) {\n                 Some(i) => Err(NulError(i, buffer)),\n-                None => Ok(unsafe { CString::from_vec_unchecked(buffer) }),\n+                None => Ok(unsafe { CString::_from_vec_unchecked(buffer) }),\n             }\n         }\n \n@@ -451,10 +451,15 @@ impl CString {\n     /// ```\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString {\n+    pub unsafe fn from_vec_unchecked(v: Vec<u8>) -> Self {\n+        debug_assert!(memchr::memchr(0, &v).is_none());\n+        unsafe { Self::_from_vec_unchecked(v) }\n+    }\n+\n+    unsafe fn _from_vec_unchecked(mut v: Vec<u8>) -> Self {\n         v.reserve_exact(1);\n         v.push(0);\n-        CString { inner: v.into_boxed_slice() }\n+        Self { inner: v.into_boxed_slice() }\n     }\n \n     /// Retakes ownership of a `CString` that was transferred to C via\n@@ -578,7 +583,7 @@ impl CString {\n     pub fn into_string(self) -> Result<String, IntoStringError> {\n         String::from_utf8(self.into_bytes()).map_err(|e| IntoStringError {\n             error: e.utf8_error(),\n-            inner: unsafe { CString::from_vec_unchecked(e.into_bytes()) },\n+            inner: unsafe { Self::_from_vec_unchecked(e.into_bytes()) },\n         })\n     }\n \n@@ -735,6 +740,11 @@ impl CString {\n     #[must_use]\n     #[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n     pub unsafe fn from_vec_with_nul_unchecked(v: Vec<u8>) -> Self {\n+        debug_assert!(memchr::memchr(0, &v).unwrap() + 1 == v.len());\n+        unsafe { Self::_from_vec_with_nul_unchecked(v) }\n+    }\n+\n+    unsafe fn _from_vec_with_nul_unchecked(v: Vec<u8>) -> Self {\n         Self { inner: v.into_boxed_slice() }\n     }\n \n@@ -778,7 +788,7 @@ impl CString {\n             Some(nul_pos) if nul_pos + 1 == v.len() => {\n                 // SAFETY: We know there is only one nul byte, at the end\n                 // of the vec.\n-                Ok(unsafe { Self::from_vec_with_nul_unchecked(v) })\n+                Ok(unsafe { Self::_from_vec_with_nul_unchecked(v) })\n             }\n             Some(nul_pos) => Err(FromVecWithNulError {\n                 error_kind: FromBytesWithNulErrorKind::InteriorNul(nul_pos),\n@@ -811,7 +821,7 @@ impl ops::Deref for CString {\n \n     #[inline]\n     fn deref(&self) -> &CStr {\n-        unsafe { CStr::from_bytes_with_nul_unchecked(self.as_bytes_with_nul()) }\n+        unsafe { CStr::_from_bytes_with_nul_unchecked(self.as_bytes_with_nul()) }\n     }\n }\n \n@@ -922,7 +932,7 @@ impl From<Vec<NonZeroU8>> for CString {\n             };\n             // SAFETY: `v` cannot contain null bytes, given the type-level\n             // invariant of `NonZeroU8`.\n-            CString::from_vec_unchecked(v)\n+            Self::_from_vec_unchecked(v)\n         }\n     }\n }\n@@ -1215,7 +1225,7 @@ impl CStr {\n         unsafe {\n             let len = sys::strlen(ptr);\n             let ptr = ptr as *const u8;\n-            CStr::from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n+            Self::_from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n         }\n     }\n \n@@ -1258,7 +1268,7 @@ impl CStr {\n             Some(nul_pos) if nul_pos + 1 == bytes.len() => {\n                 // SAFETY: We know there is only one nul byte, at the end\n                 // of the byte slice.\n-                Ok(unsafe { Self::from_bytes_with_nul_unchecked(bytes) })\n+                Ok(unsafe { Self::_from_bytes_with_nul_unchecked(bytes) })\n             }\n             Some(nul_pos) => Err(FromBytesWithNulError::interior_nul(nul_pos)),\n             None => Err(FromBytesWithNulError::not_nul_terminated()),\n@@ -1287,12 +1297,19 @@ impl CStr {\n     #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n     #[rustc_const_stable(feature = \"const_cstr_unchecked\", since = \"1.59.0\")]\n     pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n+        // We're in a const fn, so this is the best we can do\n+        debug_assert!(!bytes.is_empty() && bytes[bytes.len() - 1] == 0);\n+        unsafe { Self::_from_bytes_with_nul_unchecked(bytes) }\n+    }\n+\n+    #[inline]\n+    const unsafe fn _from_bytes_with_nul_unchecked(bytes: &[u8]) -> &Self {\n         // SAFETY: Casting to CStr is safe because its internal representation\n         // is a [u8] too (safe only inside std).\n         // Dereferencing the obtained pointer is safe because it comes from a\n         // reference. Making a reference is then safe because its lifetime\n         // is bound by the lifetime of the given `bytes`.\n-        unsafe { &*(bytes as *const [u8] as *const CStr) }\n+        unsafe { &*(bytes as *const [u8] as *const Self) }\n     }\n \n     /// Returns the inner pointer to this C string.\n@@ -1555,7 +1572,7 @@ impl ops::Index<ops::RangeFrom<usize>> for CStr {\n         // byte, since otherwise we could get an empty string that doesn't end\n         // in a null.\n         if index.start < bytes.len() {\n-            unsafe { CStr::from_bytes_with_nul_unchecked(&bytes[index.start..]) }\n+            unsafe { CStr::_from_bytes_with_nul_unchecked(&bytes[index.start..]) }\n         } else {\n             panic!(\n                 \"index out of bounds: the len is {} but the index is {}\","}, {"sha": "00ba5460821ff356601febf2f8d13452725e0bb7", "filename": "library/std/src/ffi/c_str/tests.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs?ref=897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc", "patch": "@@ -32,14 +32,6 @@ fn build_with_zero2() {\n     assert!(CString::new(vec![0]).is_err());\n }\n \n-#[test]\n-fn build_with_zero3() {\n-    unsafe {\n-        let s = CString::from_vec_unchecked(vec![0]);\n-        assert_eq!(s.as_bytes(), b\"\\0\");\n-    }\n-}\n-\n #[test]\n fn formatted() {\n     let s = CString::new(&b\"abc\\x01\\x02\\n\\xE2\\x80\\xA6\\xFF\"[..]).unwrap();"}]}