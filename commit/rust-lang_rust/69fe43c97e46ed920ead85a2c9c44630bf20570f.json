{"sha": "69fe43c97e46ed920ead85a2c9c44630bf20570f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ZmU0M2M5N2U0NmVkOTIwZWFkODVhMmM5YzQ0NjMwYmYyMDU3MGY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-07-16T14:18:55Z"}, "committer": {"name": "Sean Griffin", "email": "sean@seantheprogrammer.com", "date": "2018-03-01T15:04:26Z"}, "message": "have `probe()` return `TypeVariableValue`", "tree": {"sha": "2df6e95b30b09a53557c3378c274c0f571bcbfd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2df6e95b30b09a53557c3378c274c0f571bcbfd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69fe43c97e46ed920ead85a2c9c44630bf20570f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69fe43c97e46ed920ead85a2c9c44630bf20570f", "html_url": "https://github.com/rust-lang/rust/commit/69fe43c97e46ed920ead85a2c9c44630bf20570f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69fe43c97e46ed920ead85a2c9c44630bf20570f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sgrif", "id": 1529387, "node_id": "MDQ6VXNlcjE1MjkzODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1529387?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgrif", "html_url": "https://github.com/sgrif", "followers_url": "https://api.github.com/users/sgrif/followers", "following_url": "https://api.github.com/users/sgrif/following{/other_user}", "gists_url": "https://api.github.com/users/sgrif/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgrif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgrif/subscriptions", "organizations_url": "https://api.github.com/users/sgrif/orgs", "repos_url": "https://api.github.com/users/sgrif/repos", "events_url": "https://api.github.com/users/sgrif/events{/privacy}", "received_events_url": "https://api.github.com/users/sgrif/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccd92c2a4e5ed634bbbd6d3a5bd491c47b80f642", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd92c2a4e5ed634bbbd6d3a5bd491c47b80f642", "html_url": "https://github.com/rust-lang/rust/commit/ccd92c2a4e5ed634bbbd6d3a5bd491c47b80f642"}], "stats": {"total": 81, "additions": 46, "deletions": 35}, "files": [{"sha": "44a848d3cc6e3a60348329b124abbc75fc6c5e1b", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69fe43c97e46ed920ead85a2c9c44630bf20570f/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe43c97e46ed920ead85a2c9c44630bf20570f/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=69fe43c97e46ed920ead85a2c9c44630bf20570f", "patch": "@@ -34,10 +34,10 @@\n \n use super::equate::Equate;\n use super::glb::Glb;\n+use super::{InferCtxt, MiscVariable, TypeTrace};\n use super::lub::Lub;\n use super::sub::Sub;\n-use super::InferCtxt;\n-use super::{MiscVariable, TypeTrace};\n+use super::type_variable::TypeVariableValue;\n \n use hir::def_id::DefId;\n use ty::{IntType, UintType};\n@@ -194,7 +194,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n         use self::RelationDir::*;\n \n         // Get the actual variable that b_vid has been inferred to\n-        debug_assert!(self.infcx.type_variables.borrow_mut().probe(b_vid).is_none());\n+        debug_assert!(self.infcx.type_variables.borrow_mut().probe(b_vid).is_unknown());\n \n         debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\", a_ty, dir, b_vid);\n \n@@ -403,11 +403,11 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                     return Err(TypeError::CyclicTy(self.root_ty));\n                 } else {\n                     match variables.probe(vid) {\n-                        Some(u) => {\n+                        TypeVariableValue::Known { value: u } => {\n                             drop(variables);\n                             self.relate(&u, &u)\n                         }\n-                        None => {\n+                        TypeVariableValue::Unknown { .. } => {\n                             match self.ambient_variance {\n                                 // Invariant: no need to make a fresh type variable.\n                                 ty::Invariant => return Ok(t),"}, {"sha": "ee0921f4b07ae6487b7675c666f0917f05245992", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69fe43c97e46ed920ead85a2c9c44630bf20570f/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe43c97e46ed920ead85a2c9c44630bf20570f/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=69fe43c97e46ed920ead85a2c9c44630bf20570f", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n \n         match t.sty {\n             ty::TyInfer(ty::TyVar(v)) => {\n-                let opt_ty = self.infcx.type_variables.borrow_mut().probe(v);\n+                let opt_ty = self.infcx.type_variables.borrow_mut().probe(v).known();\n                 self.freshen(\n                     opt_ty,\n                     ty::TyVar(v),"}, {"sha": "961dd70a4685204b927909c1738f9f3463b73b6b", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69fe43c97e46ed920ead85a2c9c44630bf20570f/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe43c97e46ed920ead85a2c9c44630bf20570f/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=69fe43c97e46ed920ead85a2c9c44630bf20570f", "patch": "@@ -131,7 +131,9 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n                         // variables to their binding anyhow, we know\n                         // that it is unbound, so we can just return\n                         // it.\n-                        debug_assert!(self.infcx.type_variables.borrow_mut().probe(vid).is_none());\n+                        debug_assert!(self.infcx.type_variables.borrow_mut()\n+                                      .probe(vid)\n+                                      .is_unknown());\n                         ty\n                     }\n "}, {"sha": "9b856f94c56159ab0755f2526eafee302705df38", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/69fe43c97e46ed920ead85a2c9c44630bf20570f/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe43c97e46ed920ead85a2c9c44630bf20570f/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=69fe43c97e46ed920ead85a2c9c44630bf20570f", "patch": "@@ -1259,9 +1259,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // so this recursion should always be of very limited\n                 // depth.\n                 self.type_variables.borrow_mut()\n-                    .probe(v)\n-                    .map(|t| self.shallow_resolve(t))\n-                    .unwrap_or(typ)\n+                                   .probe(v)\n+                                   .known()\n+                                   .map(|t| self.shallow_resolve(t))\n+                                   .unwrap_or(typ)\n             }\n \n             ty::TyInfer(ty::IntVar(v)) => {"}, {"sha": "9b9e9fa0015fa12013c1a85bb6d39b04a1d66c97", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/69fe43c97e46ed920ead85a2c9c44630bf20570f/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe43c97e46ed920ead85a2c9c44630bf20570f/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=69fe43c97e46ed920ead85a2c9c44630bf20570f", "patch": "@@ -78,12 +78,28 @@ struct TypeVariableData {\n     diverging: bool\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-enum TypeVariableValue<'tcx> {\n+#[derive(Copy, Clone, Debug)]\n+pub enum TypeVariableValue<'tcx> {\n     Known { value: Ty<'tcx> },\n     Unknown,\n }\n \n+impl<'tcx> TypeVariableValue<'tcx> {\n+    pub fn known(&self) -> Option<Ty<'tcx>> {\n+        match *self {\n+            TypeVariableValue::Unknown { .. } => None,\n+            TypeVariableValue::Known { value } => Some(value),\n+        }\n+    }\n+\n+    pub fn is_unknown(&self) -> bool {\n+        match *self {\n+            TypeVariableValue::Unknown { .. } => true,\n+            TypeVariableValue::Known { .. } => false,\n+        }\n+    }\n+}\n+\n pub struct Snapshot<'tcx> {\n     /// number of variables at the time of the snapshot\n     num_vars: usize,\n@@ -124,8 +140,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///\n     /// Precondition: neither `a` nor `b` are known.\n     pub fn equate(&mut self, a: ty::TyVid, b: ty::TyVid) {\n-        debug_assert!(self.probe(a).is_none());\n-        debug_assert!(self.probe(b).is_none());\n+        debug_assert!(self.probe(a).is_unknown());\n+        debug_assert!(self.probe(b).is_unknown());\n         self.eq_relations.union(a, b);\n         self.sub_relations.union(a, b);\n     }\n@@ -134,8 +150,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///\n     /// Precondition: neither `a` nor `b` are known.\n     pub fn sub(&mut self, a: ty::TyVid, b: ty::TyVid) {\n-        debug_assert!(self.probe(a).is_none());\n-        debug_assert!(self.probe(b).is_none());\n+        debug_assert!(self.probe(a).is_unknown());\n+        debug_assert!(self.probe(b).is_unknown());\n         self.sub_relations.union(a, b);\n     }\n \n@@ -144,8 +160,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// Precondition: `vid` must not have been previously instantiated.\n     pub fn instantiate(&mut self, vid: ty::TyVid, ty: Ty<'tcx>) {\n         let vid = self.root_var(vid);\n-        debug_assert!(self.probe(vid).is_none());\n-        debug_assert!(self.eq_relations.probe_value(vid) == TypeVariableValue::Unknown,\n+        debug_assert!(self.probe(vid).is_unknown());\n+        debug_assert!(self.eq_relations.probe_value(vid).is_unknown(),\n                       \"instantiating type variable `{:?}` twice: new-value = {:?}, old-value={:?}\",\n                       vid, ty, self.eq_relations.probe_value(vid));\n         self.eq_relations.union_value(vid, TypeVariableValue::Known { value: ty });\n@@ -211,12 +227,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n \n     /// Retrieves the type to which `vid` has been instantiated, if\n     /// any.\n-    pub fn probe(&mut self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n-        let vid = self.root_var(vid);\n-        match self.eq_relations.probe_value(vid) {\n-            TypeVariableValue::Unknown => None,\n-            TypeVariableValue::Known { value } => Some(value)\n-        }\n+    pub fn probe(&mut self, vid: ty::TyVid) -> TypeVariableValue<'tcx> {\n+        self.eq_relations.probe_value(vid)\n     }\n \n     /// If `t` is a type-inference variable, and it has been\n@@ -226,8 +238,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         match t.sty {\n             ty::TyInfer(ty::TyVar(v)) => {\n                 match self.probe(v) {\n-                    None => t,\n-                    Some(u) => u\n+                    TypeVariableValue::Unknown { .. } => t,\n+                    TypeVariableValue::Known { value } => value,\n                 }\n             }\n             _ => t,\n@@ -313,12 +325,9 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         // use the less efficient algorithm for now.\n         let mut escaping_types = Vec::with_capacity(snapshot.num_vars);\n         escaping_types.extend(\n-            (0..snapshot.num_vars) // for all variables that pre-exist the snapshot...\n+            (0..snapshot.num_vars) // for all variables that pre-exist the snapshot, collect..\n                 .map(|i| ty::TyVid { index: i as u32 })\n-                .filter_map(|vid| match self.eq_relations.probe_value(vid) {\n-                    TypeVariableValue::Unknown => None,\n-                    TypeVariableValue::Known { value } => Some(value),\n-                })); // ...collect what types they've been instantiated with.\n+                .filter_map(|vid| self.probe(vid).known())); // ..types they are instantiated with.\n         debug!(\"types_escaping_snapshot = {:?}\", escaping_types);\n         escaping_types\n     }\n@@ -329,10 +338,9 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         (0..self.var_data.len())\n             .filter_map(|i| {\n                 let vid = ty::TyVid { index: i as u32 };\n-                if self.probe(vid).is_some() {\n-                    None\n-                } else {\n-                    Some(vid)\n+                match self.probe(vid) {\n+                    TypeVariableValue::Unknown { .. } => Some(vid),\n+                    TypeVariableValue::Known { .. } => None,\n                 }\n             })\n             .collect()"}]}