{"sha": "2c998aa8bb463f21fd164e2c701f891f5d5660d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjOTk4YWE4YmI0NjNmMjFmZDE2NGUyYzcwMWY4OTFmNWQ1NjYwZDA=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-04-05T00:31:32Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-04-11T21:34:01Z"}, "message": "review comments", "tree": {"sha": "277a384eba243f1a27a0549ceb6bf18396816955", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/277a384eba243f1a27a0549ceb6bf18396816955"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c998aa8bb463f21fd164e2c701f891f5d5660d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c998aa8bb463f21fd164e2c701f891f5d5660d0", "html_url": "https://github.com/rust-lang/rust/commit/2c998aa8bb463f21fd164e2c701f891f5d5660d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c998aa8bb463f21fd164e2c701f891f5d5660d0/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d83cc8331adb0098bad1d6f1863b0f612c6f2c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d83cc8331adb0098bad1d6f1863b0f612c6f2c3", "html_url": "https://github.com/rust-lang/rust/commit/9d83cc8331adb0098bad1d6f1863b0f612c6f2c3"}], "stats": {"total": 270, "additions": 140, "deletions": 130}, "files": [{"sha": "fb82a50cd16ef75f921d2dbc2ae8c66221d1d615", "filename": "src/librustc_trait_selection/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c998aa8bb463f21fd164e2c701f891f5d5660d0/src%2Flibrustc_trait_selection%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c998aa8bb463f21fd164e2c701f891f5d5660d0/src%2Flibrustc_trait_selection%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Flib.rs?ref=2c998aa8bb463f21fd164e2c701f891f5d5660d0", "patch": "@@ -16,6 +16,7 @@\n #![feature(in_band_lifetimes)]\n #![feature(crate_visibility_modifier)]\n #![feature(or_patterns)]\n+#![feature(str_strip)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "fb70ae53a4fe2c0f355f52f7f62b7f414bacdca2", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 139, "deletions": 130, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/2c998aa8bb463f21fd164e2c701f891f5d5660d0/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c998aa8bb463f21fd164e2c701f891f5d5660d0/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=2c998aa8bb463f21fd164e2c701f891f5d5660d0", "patch": "@@ -148,6 +148,126 @@ pub trait InferCtxtExt<'tcx> {\n     fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>);\n }\n \n+fn predicate_constraint(generics: &hir::Generics<'_>, pred: String) -> (Span, String) {\n+    (\n+        generics.where_clause.span_for_predicates_or_empty_place().shrink_to_hi(),\n+        format!(\n+            \"{} {} \",\n+            if !generics.where_clause.predicates.is_empty() { \",\" } else { \" where\" },\n+            pred,\n+        ),\n+    )\n+}\n+\n+/// Type parameter needs more bounds. The trivial case is `T` `where T: Bound`, but\n+/// it can also be an `impl Trait` param that needs to be decomposed to a type\n+/// param for cleaner code.\n+fn suggest_restriction(\n+    generics: &hir::Generics<'_>,\n+    msg: &str,\n+    err: &mut DiagnosticBuilder<'_>,\n+    fn_sig: Option<&hir::FnSig<'_>>,\n+    projection: Option<&ty::ProjectionTy<'_>>,\n+    trait_ref: &ty::PolyTraitRef<'_>,\n+) {\n+    let span = generics.where_clause.span_for_predicates_or_empty_place();\n+    if !span.from_expansion() && span.desugaring_kind().is_none() {\n+        // Given `fn foo(t: impl Trait)` where `Trait` requires assoc type `A`...\n+        if let Some((name, fn_sig)) = fn_sig.and_then(|sig| {\n+            projection.and_then(|p| {\n+                // Shenanigans to get the `Trait` from the `impl Trait`.\n+                match p.self_ty().kind {\n+                    ty::Param(param) => {\n+                        // `fn foo(t: impl Trait)`\n+                        //                 ^^^^^ get this string\n+                        param\n+                            .name\n+                            .as_str()\n+                            .strip_prefix(\"impl\")\n+                            .map(|s| (s.trim_start().to_string(), sig))\n+                    }\n+                    _ => None,\n+                }\n+            })\n+        }) {\n+            // We know we have an `impl Trait` that doesn't satisfy a required projection.\n+\n+            // Find all of the ocurrences of `impl Trait` for `Trait` in the function arguments'\n+            // types. There should be at least one, but there might be *more* than one. In that\n+            // case we could just ignore it and try to identify which one needs the restriction,\n+            // but instead we choose to suggest replacing all instances of `impl Trait` with `T`\n+            // where `T: Trait`.\n+            let mut ty_spans = vec![];\n+            let impl_name = format!(\"impl {}\", name);\n+            for input in fn_sig.decl.inputs {\n+                if let hir::TyKind::Path(hir::QPath::Resolved(\n+                    None,\n+                    hir::Path { segments: [segment], .. },\n+                )) = input.kind\n+                {\n+                    if segment.ident.as_str() == impl_name.as_str() {\n+                        // `fn foo(t: impl Trait)`\n+                        //            ^^^^^^^^^^ get this to suggest\n+                        //                       `T` instead\n+\n+                        // There might be more than one `impl Trait`.\n+                        ty_spans.push(input.span);\n+                    }\n+                }\n+            }\n+\n+            // The type param `T: Trait` we will suggest to introduce.\n+            let type_param = format!(\"{}: {}\", \"T\", name);\n+\n+            // FIXME: modify the `trait_ref` instead of string shenanigans.\n+            // Turn `<impl Trait as Foo>::Bar: Qux` into `<T as Foo>::Bar: Qux`.\n+            let pred = trait_ref.without_const().to_predicate().to_string();\n+            let pred = pred.replace(&impl_name, \"T\");\n+            let mut sugg = vec![\n+                match generics\n+                    .params\n+                    .iter()\n+                    .filter(|p| match p.kind {\n+                        hir::GenericParamKind::Type {\n+                            synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                            ..\n+                        } => false,\n+                        _ => true,\n+                    })\n+                    .last()\n+                {\n+                    // `fn foo(t: impl Trait)`\n+                    //        ^ suggest `<T: Trait>` here\n+                    None => (generics.span, format!(\"<{}>\", type_param)),\n+                    // `fn foo<A>(t: impl Trait)`\n+                    //        ^^^ suggest `<A, T: Trait>` here\n+                    Some(param) => (param.span.shrink_to_hi(), format!(\", {}\", type_param)),\n+                },\n+                // `fn foo(t: impl Trait)`\n+                //                       ^ suggest `where <T as Trait>::A: Bound`\n+                predicate_constraint(generics, pred),\n+            ];\n+            sugg.extend(ty_spans.into_iter().map(|s| (s, \"T\".to_string())));\n+\n+            // Suggest `fn foo<T: Trait>(t: T) where <T as Trait>::A: Bound`.\n+            err.multipart_suggestion(\n+                \"introduce a type parameter with a trait bound instead of using \\\n+                    `impl Trait`\",\n+                sugg,\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            // Trivial case: `T` needs an extra bound: `T: Bound`.\n+            let (sp, s) = predicate_constraint(\n+                generics,\n+                trait_ref.without_const().to_predicate().to_string(),\n+            );\n+            let appl = Applicability::MachineApplicable;\n+            err.span_suggestion(sp, &format!(\"consider further restricting {}\", msg), s, appl);\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n@@ -162,143 +282,18 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             _ => return,\n         };\n \n-        let suggest_restriction =\n-            |generics: &hir::Generics<'_>,\n-             msg,\n-             err: &mut DiagnosticBuilder<'_>,\n-             fn_sig: Option<&hir::FnSig<'_>>| {\n-                // Type parameter needs more bounds. The trivial case is `T` `where T: Bound`, but\n-                // it can also be an `impl Trait` param that needs to be decomposed to a type\n-                // param for cleaner code.\n-                let span = generics.where_clause.span_for_predicates_or_empty_place();\n-                if !span.from_expansion() && span.desugaring_kind().is_none() {\n-                    // Given `fn foo(t: impl Trait)` where `Trait` requires assoc type `A`...\n-                    if let Some((name, fn_sig)) = fn_sig.and_then(|sig| {\n-                        projection.and_then(|p| {\n-                            // Shenanigans to get the `Trait` from the `impl Trait`.\n-                            match p.self_ty().kind {\n-                                ty::Param(param) if param.name.as_str().starts_with(\"impl \") => {\n-                                    let n = param.name.as_str();\n-                                    // `fn foo(t: impl Trait)`\n-                                    //                 ^^^^^ get this string\n-                                    n.split_whitespace()\n-                                        .skip(1)\n-                                        .next()\n-                                        .map(|n| (n.to_string(), sig))\n-                                }\n-                                _ => None,\n-                            }\n-                        })\n-                    }) {\n-                        // FIXME: Cleanup.\n-                        let mut ty_spans = vec![];\n-                        let impl_name = format!(\"impl {}\", name);\n-                        for i in fn_sig.decl.inputs {\n-                            if let hir::TyKind::Path(hir::QPath::Resolved(None, path)) = i.kind {\n-                                match path.segments {\n-                                    [segment] if segment.ident.to_string() == impl_name => {\n-                                        // `fn foo(t: impl Trait)`\n-                                        //            ^^^^^^^^^^ get this to suggest\n-                                        //                       `T` instead\n-\n-                                        // There might be more than one `impl Trait`.\n-                                        ty_spans.push(i.span);\n-                                    }\n-                                    _ => {}\n-                                }\n-                            }\n-                        }\n-\n-                        let type_param = format!(\"{}: {}\", \"T\", name);\n-                        // FIXME: modify the `trait_ref` instead of string shenanigans.\n-                        // Turn `<impl Trait as Foo>::Bar: Qux` into `<T as Foo>::Bar: Qux`.\n-                        let pred = trait_ref.without_const().to_predicate().to_string();\n-                        let pred = pred.replace(&impl_name, \"T\");\n-                        let mut sugg = vec![\n-                            match generics\n-                                .params\n-                                .iter()\n-                                .filter(|p| match p.kind {\n-                                    hir::GenericParamKind::Type {\n-                                        synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                                        ..\n-                                    } => false,\n-                                    _ => true,\n-                                })\n-                                .last()\n-                            {\n-                                // `fn foo(t: impl Trait)`\n-                                //        ^ suggest `<T: Trait>` here\n-                                None => (generics.span, format!(\"<{}>\", type_param)),\n-                                Some(param) => {\n-                                    (param.span.shrink_to_hi(), format!(\", {}\", type_param))\n-                                }\n-                            },\n-                            (\n-                                // `fn foo(t: impl Trait)`\n-                                //                       ^ suggest `where <T as Trait>::A: Bound`\n-                                generics\n-                                    .where_clause\n-                                    .span_for_predicates_or_empty_place()\n-                                    .shrink_to_hi(),\n-                                format!(\n-                                    \"{} {} \",\n-                                    if !generics.where_clause.predicates.is_empty() {\n-                                        \",\"\n-                                    } else {\n-                                        \" where\"\n-                                    },\n-                                    pred,\n-                                ),\n-                            ),\n-                        ];\n-                        sugg.extend(ty_spans.into_iter().map(|s| (s, \"T\".to_string())));\n-                        // Suggest `fn foo<T: Trait>(t: T) where <T as Trait>::A: Bound`.\n-                        err.multipart_suggestion(\n-                            \"introduce a type parameter with a trait bound instead of using \\\n-                             `impl Trait`\",\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        // Trivial case: `T` needs an extra bound.\n-                        err.span_suggestion(\n-                            generics\n-                                .where_clause\n-                                .span_for_predicates_or_empty_place()\n-                                .shrink_to_hi(),\n-                            &format!(\"consider further restricting {}\", msg),\n-                            format!(\n-                                \"{} {} \",\n-                                if !generics.where_clause.predicates.is_empty() {\n-                                    \",\"\n-                                } else {\n-                                    \" where\"\n-                                },\n-                                trait_ref.without_const().to_predicate(),\n-                            ),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                }\n-            };\n-\n         // FIXME: Add check for trait bound that is already present, particularly `?Sized` so we\n         //        don't suggest `T: Sized + ?Sized`.\n         let mut hir_id = body_id;\n         while let Some(node) = self.tcx.hir().find(hir_id) {\n-            debug!(\n-                \"suggest_restricting_param_bound {:?} {:?} {:?} {:?}\",\n-                trait_ref, self_ty.kind, projection, node\n-            );\n             match node {\n                 hir::Node::TraitItem(hir::TraitItem {\n                     generics,\n                     kind: hir::TraitItemKind::Fn(..),\n                     ..\n                 }) if param_ty && self_ty == self.tcx.types.self_param => {\n                     // Restricting `Self` for a single method.\n-                    suggest_restriction(&generics, \"`Self`\", err, None);\n+                    suggest_restriction(&generics, \"`Self`\", err, None, projection, trait_ref);\n                     return;\n                 }\n \n@@ -315,16 +310,30 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 | hir::Node::Item(hir::Item {\n                     kind: hir::ItemKind::Fn(fn_sig, generics, _), ..\n                 }) if projection.is_some() => {\n-                    // Missing associated type bound.\n-                    suggest_restriction(&generics, \"the associated type\", err, Some(fn_sig));\n+                    // Missing restriction on associated type of type parameter (unmet projection).\n+                    suggest_restriction(\n+                        &generics,\n+                        \"the associated type\",\n+                        err,\n+                        Some(fn_sig),\n+                        projection,\n+                        trait_ref,\n+                    );\n                     return;\n                 }\n                 hir::Node::Item(\n                     hir::Item { kind: hir::ItemKind::Trait(_, _, generics, _, _), .. }\n                     | hir::Item { kind: hir::ItemKind::Impl { generics, .. }, .. },\n                 ) if projection.is_some() => {\n-                    // Missing associated type bound.\n-                    suggest_restriction(&generics, \"the associated type\", err, None);\n+                    // Missing restriction on associated type of type parameter (unmet projection).\n+                    suggest_restriction(\n+                        &generics,\n+                        \"the associated type\",\n+                        err,\n+                        None,\n+                        projection,\n+                        trait_ref,\n+                    );\n                     return;\n                 }\n "}]}