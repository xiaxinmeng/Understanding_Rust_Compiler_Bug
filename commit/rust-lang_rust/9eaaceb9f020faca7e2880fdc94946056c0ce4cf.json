{"sha": "9eaaceb9f020faca7e2880fdc94946056c0ce4cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYWFjZWI5ZjAyMGZhY2E3ZTI4ODBmZGM5NDk0NjA1NmMwY2U0Y2Y=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-31T23:57:37Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-31T23:58:23Z"}, "message": "doc: Update the tutorial", "tree": {"sha": "418038089da67aa49658394bc79a107ed053a4e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/418038089da67aa49658394bc79a107ed053a4e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eaaceb9f020faca7e2880fdc94946056c0ce4cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eaaceb9f020faca7e2880fdc94946056c0ce4cf", "html_url": "https://github.com/rust-lang/rust/commit/9eaaceb9f020faca7e2880fdc94946056c0ce4cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eaaceb9f020faca7e2880fdc94946056c0ce4cf/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "329281ebcc3a6e007b33607b7376602a7a6e11ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/329281ebcc3a6e007b33607b7376602a7a6e11ec", "html_url": "https://github.com/rust-lang/rust/commit/329281ebcc3a6e007b33607b7376602a7a6e11ec"}], "stats": {"total": 621, "additions": 180, "deletions": 441}, "files": [{"sha": "0fc56f135c9581cf12510cbe4fbc5ab0b00de0bc", "filename": "doc/tutorial.md", "status": "modified", "additions": 180, "deletions": 441, "changes": 621, "blob_url": "https://github.com/rust-lang/rust/blob/9eaaceb9f020faca7e2880fdc94946056c0ce4cf/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/9eaaceb9f020faca7e2880fdc94946056c0ce4cf/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=9eaaceb9f020faca7e2880fdc94946056c0ce4cf", "patch": "@@ -69,61 +69,6 @@ C. As will become clear in the rest of this tutorial, it goes in quite\n a different direction, with efficient, strongly-typed and memory-safe\n support for many high-level idioms.\n \n-Here's a parallel game of rock, paper, scissors to whet your appetite.\n-\n-~~~~\n-use std;\n-\n-import pipes::PortSet;\n-import task::spawn;\n-import iter::repeat;\n-import rand::{seeded_rng, seed};\n-import uint::range;\n-import io::println;\n-\n-fn main() {\n-    // Open a channel to receive game results\n-    let result_from_game = PortSet();\n-    let times = 10;\n-    let player1 = ~\"graydon\";\n-    let player2 = ~\"patrick\";\n-\n-    for repeat(times) {\n-        // Start another task to play the game\n-        let result = result_from_game.chan();\n-        do spawn |copy player1, copy player2| {\n-            let outcome = play_game(player1, player2);\n-            result.send(outcome);\n-        }\n-    }\n-\n-    // Report the results as the games complete\n-    for range(0, times) |round| {\n-        let winner = result_from_game.recv();\n-        println(fmt!(\"%s wins round #%u\", winner, round));\n-    }\n-\n-    fn play_game(player1: ~str, player2: ~str) -> ~str {\n-\n-        // Our rock/paper/scissors types\n-        enum gesture {\n-            rock, paper, scissors\n-        }\n-\n-        let rng = seeded_rng(seed());\n-        // A small inline function for picking an RPS gesture\n-        let pick = || (~[rock, paper, scissors])[rng.gen_uint() % 3];\n-\n-        // Pick two gestures and decide the result\n-        match (pick(), pick()) {\n-            (rock, scissors) | (paper, rock) | (scissors, paper) => copy player1,\n-            (scissors, rock) | (rock, paper) | (paper, scissors) => copy player2,\n-            _ => ~\"tie\"\n-        }\n-    }\n-}\n-~~~~\n-\n ## Conventions\n \n Throughout the tutorial, words that indicate language keywords or\n@@ -207,8 +152,8 @@ Rust program files are, by convention, given the extension `.rs`. Say\n we have a file `hello.rs` containing this program:\n \n ~~~~\n-fn main(args: ~[~str]) {\n-    io::println(~\"hello world from '\" + args[0] + ~\"'!\");\n+fn main() {\n+    io::println(\"hello world!\");\n }\n ~~~~\n \n@@ -221,7 +166,7 @@ If you modify the program to make it invalid (for example, by changing\n \n ~~~~ {.notrust}\n hello.rs:2:4: 2:16 error: unresolved name: io::print_it\n-hello.rs:2     io::print_it(~\"hello world from '\" + args[0] + ~\"'!\");\n+hello.rs:2     io::print_it(\"hello world!\");\n                ^~~~~~~~~~~~\n ~~~~\n \n@@ -237,7 +182,7 @@ declaration to appear at the top level of the file\u2014all statements must\n live inside a function.\n \n Rust programs can also be compiled as libraries, and included in other\n-programs. The `use std` directive that appears at the top of a lot of\n+programs. The `extern mod std` directive that appears at the top of a lot of\n examples imports the [standard library][std]. This is described in more\n detail [later on](#modules-and-crates).\n \n@@ -262,65 +207,71 @@ difference to be aware of is that the bodies of `if` statements and of\n `while` loops *have* to be wrapped in brackets. Single-statement,\n bracket-less bodies are not allowed.\n \n-If the verbosity of that bothers you, consider the fact that this\n-allows you to omit the parentheses around the condition in `if`,\n-`while`, and similar constructs. This will save you two characters\n-every time. As a bonus, you no longer have to spend any mental energy\n-on deciding whether you need to add braces or not, or on adding them\n-after the fact when adding a statement to an `if` branch.\n-\n Accounting for these differences, the surface syntax of Rust\n statements and expressions is C-like. Function calls are written\n `myfunc(arg1, arg2)`, operators have mostly the same name and\n precedence that they have in C, comments look the same, and constructs\n like `if` and `while` are available:\n \n ~~~~\n-# fn call_a_function(_a: int) {}\n+# fn it_works() {}\n+# fn abort() {}\n fn main() {\n-    if 1 < 2 {\n-        while false { call_a_function(10 * 4); }\n-    } else if 4 < 3 || 3 < 4 {\n-        // Comments are C++-style too\n-    } else {\n-        /* Multi-line comment syntax */\n+    while true {\n+        /* Ensure that basic math works. */\n+        if 2*20 > 30 {\n+            // Everything is OK.\n+            it_works();\n+        } else {\n+            abort();\n+        }\n+        break;\n     }\n }\n ~~~~\n \n ## Expression syntax\n \n Though it isn't apparent in all code, there is a fundamental\n-difference between Rust's syntax and the predecessors in this family\n-of languages. A lot of things that are statements in C are expressions\n-in Rust. This allows for useless things like this (which passes\n-nil\u2014the void type\u2014to a function):\n-\n-~~~~\n-# fn a_function(_a: ()) {}\n-a_function(while false {});\n+difference between Rust's syntax and its predecessors in this family\n+of languages. Many constructs that are statements in C are expressions\n+in Rust. This allows Rust to be more expressive. For example, you might\n+write a piece of code like this:\n+\n+~~~~\n+# let item = \"salad\";\n+let price;\n+if item == \"salad\" {\n+    price = 3.50;\n+} else if item == \"muffin\" {\n+    price = 2.25;\n+} else {\n+    price = 2.00;\n+}\n ~~~~\n \n-But also useful things like this:\n+But, in Rust, you don't have to repeat the name `price`:\n \n ~~~~\n-# fn the_stars_align() -> bool { false }\n-# fn something_else() -> bool { true }\n-let x = if the_stars_align() { 4 }\n-        else if something_else() { 3 }\n-        else { 0 };\n+# let item = \"salad\";\n+let price = if item == \"salad\" { 3.50 }\n+            else if item == \"muffin\" { 2.25 }\n+            else { 2.00 };\n ~~~~\n \n-This piece of code will bind the variable `x` to a value depending on\n-the conditions. Note the condition bodies, which look like `{\n-expression }`. The lack of a semicolon after the last statement in a\n-braced block gives the whole block the value of that last expression.\n-If the branches of the `if` had looked like `{ 4; }`, the above\n-example would simply assign nil (void) to `x`. But without the\n-semicolon, each branch has a different value, and `x` gets the value\n-of the branch that was taken.\n+Both pieces of code are exactly equivalent\u2014they assign a value to `price`\n+depending on the condition that holds. Note that the semicolons are omitted\n+from the second snippet. This is important; the lack of a semicolon after the\n+last statement in a braced block gives the whole block the value of that last\n+expression.\n+\n+Put another way, the semicolon in Rust *ignores the value of an expression*.\n+Thus, if the branches of the `if` had looked like `{ 4; }`, the above example\n+would simply assign nil (void) to `price`. But without the semicolon, each\n+branch has a different value, and `price` gets the value of the branch that\n+was taken.\n \n-This also works for function bodies. This function returns a boolean:\n+This feature also works for function bodies. This function returns a boolean:\n \n ~~~~\n fn is_four(x: int) -> bool { x == 4 }\n@@ -341,9 +292,12 @@ like the `let x = ...` example above.\n \n ## Identifiers\n \n-Rust identifiers must start with an alphabetic character or an\n-underscore, and after that may contain any alphanumeric character, and\n-more underscores.\n+Rust identifiers follow the same rules as C; they start with an alphabetic\n+character or an underscore, and after that may contain any sequence of\n+alphabetic characters, numbers, or underscores. The preferred style is to\n+begin function, variable, and module names with a lowercase letter, using\n+underscores where they help readability, while beginning types with a capital\n+letter.\n \n The double-colon (`::`) is used as a module separator, so\n `io::println` means 'the thing named `println` in the module\n@@ -365,20 +319,19 @@ a local variable that can be reassigned.  Global constants can be\n defined with `const`:\n \n ~~~~\n-use std;\n-const repeat: uint = 5u;\n+const repeat: int = 5;\n fn main() {\n-    let hi = ~\"Hi!\";\n-    let mut count = 0u;\n+    let hi = \"Hi!\";\n+    let mut count = 0;\n     while count < repeat {\n         io::println(hi);\n-        count += 1u;\n+        count += 1;\n     }\n }\n ~~~~\n \n-Local variables may shadow earlier declarations, causing the\n-previous variable to go out of scope.\n+Local variables may shadow earlier declarations, making the earlier variables\n+inaccessible.\n \n ~~~~\n let my_favorite_value: float = 57.8;\n@@ -403,10 +356,10 @@ annotation:\n \n ~~~~\n // The type of this vector will be inferred based on its use.\n-let x = ~[];\n+let x = [];\n # vec::map(x, fn&(&&_y:int) -> int { _y });\n-// Explicitly say this is a vector of integers.\n-let y: ~[int] = ~[];\n+// Explicitly say this is a vector of zero integers.\n+let y: [int * 0] = [];\n ~~~~\n \n The basic types are written like this:\n@@ -429,49 +382,58 @@ The basic types are written like this:\n `u8`, `u16`, `u32`, `u64`\n   : Unsigned integers with a specific size.\n \n-`f32`, `f64`\n-  : Floating-point types.\n-\n `float`\n-  : The largest floating-point type efficiently supported on the target machine.\n+  : The largest floating-point type efficiently supported on the target\n+    machine.\n \n-`char`\n-  : A character is a 32-bit Unicode code point.\n+`f32`, `f64`\n+  : Floating-point types with a specific size.\n \n-`~str`\n-  : String type. A string contains a UTF-8 encoded sequence of characters.\n+`char`\n+  : A Unicode character (32 bits).\n \n These can be combined in composite types, which will be described in\n more detail later on (the `T`s here stand for any other type):\n \n-`~[T]`\n-  : Vector type.\n+`[T * N]`\n+  : Vector (like an array in other languages) with N elements.\n \n-`~[mut T]`\n-  : Mutable vector type.\n+`[mut T * N]`\n+  : Mutable vector with N elements.\n \n `(T1, T2)`\n   : Tuple type. Any arity above 1 is supported.\n \n-`{field1: T1, field2: T2}`\n-  : Record type.\n+`@T`, `~T`, `&T`\n+  : Pointer types.\n+\n+The size of some types can vary when your program runs. Because of this, you\n+don't manipulate them only by pointer, never directly. For instance, you \n+can't refer to a string (`str`); instead you refer to a pointer to a string\n+(`@str`, `~str`, or `&str`). These *dynamically-sized* types const of:\n \n-`fn(arg1: T1, arg2: T2) -> T3`, `fn@()`, `fn~()`, `fn&()`\n+`fn(arg1: T1, arg2: T2) -> T3`\n   : Function types.\n \n-`@T`, `~T`, `*T`\n-  : Pointer types.\n+`str`\n+  : String type. A string contains a UTF-8 encoded sequence of characters.\n+\n+`[T]`\n+  : Vector with unknown size (also called a slice).\n+\n+`[mut T]`\n+  : Mutable vector with unknown size.\n \n Types can be given names with `type` declarations:\n \n ~~~~\n-type monster_size = uint;\n+type MonsterSize = uint;\n ~~~~\n \n-This will provide a synonym, `monster_size`, for unsigned integers. It\n-will not actually create a new type\u2014`monster_size` and `uint` can be\n-used interchangeably, and using one where the other is expected is not\n-a type error. Read about [single-variant enums](#single_variant_enum)\n+This will provide a synonym, `MonsterSize`, for unsigned integers. It will not\n+actually create a new, incompatible type\u2014`MonsterSize` and `uint` can be used\n+interchangeably, and using one where the other is expected is not a type\n+error. Read about [single-variant enums](#single_variant_enum)\n further on if you need to create a type name that's not just a\n synonym.\n \n@@ -482,107 +444,46 @@ binary (`0b10010000`) base.\n \n If you write an integer literal without a suffix (`3`, `-500`, etc.),\n the Rust compiler will try to infer its type based on type annotations\n-and function signatures in the surrounding program.  For example, here\n-the type of `x` is inferred to be `u16` because it is passed to a\n-function that takes a `u16` argument:\n-\n-~~~~\n-let x = 3;\n-\n-fn identity_u16(n: u16) -> u16 { n }\n-\n-identity_u16(x);\n-~~~~\n-\n-On the other hand, if the program gives conflicting information about\n-what the type of the unsuffixed literal should be, you'll get an error\n-message.\n-\n-~~~~{.xfail-test}\n-let x = 3;\n-let y: i32 = 3;\n-\n-fn identity_u8(n: u8) -> u8 { n }\n-fn identity_u16(n: u16) -> u16 { n }\n+and function signatures in the surrounding program. In the absence of any type\n+annotations at all, Rust will assume that an unsuffixed integer literal has\n+type `int`. It's also possible to avoid any type ambiguity by writing integer\n+literals with a suffix. For example:\n \n-identity_u8(x);  // after this, `x` is assumed to have type `u8`\n-identity_u16(x); // raises a type error (expected `u16` but found `u8`)\n-identity_u16(y); // raises a type error (expected `u16` but found `i32`)\n ~~~~\n-\n-In the absence of any type annotations at all, Rust will assume that\n-an unsuffixed integer literal has type `int`.\n-\n+let x = 50;\n+log(error, x); // x is an int\n+let y = 100u;\n+log(error, y); // y is an uint\n ~~~~\n-let n = 50;\n-log(error, n); // n is an int\n-~~~~\n-\n-It's also possible to avoid any type ambiguity by writing integer\n-literals with a suffix.  The suffixes `i` and `u` are for the types\n-`int` and `uint`, respectively: the literal `-3i` has type `int`,\n-while `127u` has type `uint`.  For the fixed-size integer types, just\n-suffix the literal with the type name: `255u8`, `50i64`, etc.\n \n Note that, in Rust, no implicit conversion between integer types\n happens. If you are adding one to a variable of type `uint`, saying\n `+= 1u8` will give you a type error.\n \n Floating point numbers are written `0.0`, `1e6`, or `2.1e-4`. Without\n-a suffix, the literal is assumed to be of type `float`. Suffixes `f32`\n-and `f64` can be used to create literals of a specific type. The\n-suffix `f` can be used to write `float` literals without a dot or\n-exponent: `3f`.\n+a suffix, the literal is assumed to be of type `float`. Suffixes `f` (32-bit)\n+and `l` (64-bit) can be used to create literals of a specific type.\n \n ## Other literals\n \n The nil literal is written just like the type: `()`. The keywords\n `true` and `false` produce the boolean literals.\n \n-Character literals are written between single quotes, as in `'x'`. You\n-may put non-ascii characters between single quotes (your source files\n-should be encoded as UTF-8). Rust understands a number of\n-character escapes, using the backslash character:\n-\n-`\\n`\n-  : A newline (Unicode character 10).\n-\n-`\\r`\n-  : A carriage return (13).\n-\n-`\\t`\n-  : A tab character (9).\n-\n-`\\\\`, `\\'`, `\\\"`\n-  : Simply escapes the following character.\n-\n-`\\xHH`, `\\uHHHH`, `\\UHHHHHHHH`\n-  : Unicode escapes, where the `H` characters are the hexadecimal digits that\n-    form the character code.\n+Character literals are written between single quotes, as in `'x'`. Just as in\n+C, Rust understands a number of character escapes, using the backslash\n+character, `\\n`, `\\r`, and `\\t` being the most common.\n \n String literals allow the same escape sequences. They are written\n-between double quotes (`~\"hello\"`). Rust strings may contain newlines.\n-When a newline is preceded by a backslash, it, and all white space\n-following it, will not appear in the resulting string literal. So\n-this is equivalent to `~\"abc\"`:\n-\n-~~~~\n-let s = ~\"a\\\n-         b\\\n-         c\";\n-~~~~\n+between double quotes (`\"hello\"`). Rust strings may contain newlines.\n \n ## Operators\n \n Rust's set of operators contains very few surprises. Binary arithmetic\n is done with `*`, `/`, `%`, `+`, and `-` (multiply, divide, remainder,\n-plus, minus). `-` is also a unary prefix operator that does negation.\n+plus, minus). `-` is also a unary prefix operator that does negation. As in C,\n+the bit operators `>>`, `<<`, `&`, `|`, and `^` are supported.\n \n-Binary shifting is done with `>>` (shift right), and `<<` (shift\n-left). Shift right is arithmetic if the value is signed and logical if\n-the value is unsigned. Logical bitwise operators are `&`, `|`, and `^`\n-(and, or, and exclusive or), and unary `!` for bitwise negation (or\n-boolean negation when applied to a boolean value).\n+Note that, if applied an integer value, `!` inverts all the bits.\n \n The comparison operators are the traditional `==`, `!=`, `<`, `>`,\n `<=`, and `>=`. Short-circuiting (lazy) boolean operators are written\n@@ -605,46 +506,13 @@ the logical bitwise operators have higher precedence \u2014 in C, `x & 2 > 0`\n comes out as `x & (2 > 0)`, in Rust, it means `(x & 2) > 0`, which is\n more likely to be what you expect (unless you are a C veteran).\n \n-## Attributes\n-\n-Every definition can be annotated with attributes. Attributes are meta\n-information that can serve a variety of purposes. One of those is\n-conditional compilation:\n-\n-~~~~\n-#[cfg(windows)]\n-fn register_win_service() { /* ... */ }\n-~~~~\n-\n-This will cause the function to vanish without a trace during\n-compilation on a non-Windows platform, much like `#ifdef` in C.\n-\n-Attributes are always wrapped in hash-braces (`#[attr]`). Inside the\n-braces, a small minilanguage is supported, whose interpretation\n-depends on the attribute that's being used. The simplest form is a\n-plain name (as in `#[test]`, which is used by the [built-in test\n-framework](#testing)). A name-value pair can be provided using an `=`\n-character followed by a literal (as in `#[license = \"BSD\"]`, which is\n-a valid way to annotate a Rust program as being released under a\n-BSD-style license). Finally, you can have a name followed by a\n-comma-separated list of nested attributes, as in this\n-[crate](#modules-and-crates) metadata declaration:\n-\n-~~~~ {.ignore}\n-#[link(name = \"std\",\n-       vers = \"0.1\",\n-       url = \"http://rust-lang.org/src/std\")];\n-~~~~\n-\n-An attribute without a semicolon following it applies to the\n-definition that follows it. When terminated with a semicolon, it\n-applies to the module or crate in which it appears.\n-\n ## Syntax extensions\n \n-The compiler defines a few built-in syntax extensions. The most useful\n-one is `fmt!`, a sprintf-style text formatter that is expanded\n-at compile time.\n+*Syntax extensions* are special syntax that is not built into the language,\n+but are instead provided by the libraries. To make it clear when a syntax\n+extension is being used, their names all end with `!`. The standard library\n+defines a few syntax extensions. The most useful one is `fmt!`, a\n+`sprintf`-style text formatter that is expanded at compile time.\n \n ~~~~\n io::println(fmt!(\"%s is %d\", ~\"the answer\", 42));\n@@ -656,16 +524,7 @@ don't match the types of the arguments.\n \n [pf]: http://en.cppreference.com/w/cpp/io/c/fprintf\n \n-All syntax extensions look like `extension_name!`. Another built-in one is\n-`env!`, which will look up its argument as an environment variable at\n-compile-time.\n-\n-~~~~\n-io::println(env!(\"PATH\"));\n-~~~~\n-\n-It is possible for the user to define new syntax extensions, within certain\n-limits. These are called [macros](#macros).\n+You can define your own syntax extensions via macros.\n \n # Control structures\n \n@@ -694,41 +553,35 @@ end of the block:\n fn signum(x: int) -> int {\n     if x < 0 { -1 }\n     else if x > 0 { 1 }\n-    else { return 0; }\n+    else { return 0 }\n }\n ~~~~\n \n-The `return` and its semicolon could have been left out without\n-changing the meaning of this function, but it illustrates that you\n-will not get a type error in this case, although the last arm doesn't\n-have type `int`, because control doesn't reach the end of that arm\n-(`return` is jumping out of the function).\n-\n ## Pattern matching\n \n Rust's `match` construct is a generalized, cleaned-up version of C's\n-`switch` construct. You provide it with a value and a number of arms,\n-each labelled with a pattern, and it will execute the arm that matches\n-the value.\n+`switch` construct. You provide it with a value and a number of *arms*,\n+each labelled with a pattern, and the code will attempt to match each pattern\n+in order. For the first one that matches, the arm is executed.\n \n ~~~~\n # let my_number = 1;\n match my_number {\n-  0       => io::println(~\"zero\"),\n-  1 | 2   => io::println(~\"one or two\"),\n-  3 to 10 => io::println(~\"three to ten\"),\n-  _       => io::println(~\"something else\")\n+  0     => io::println(\"zero\"),\n+  1 | 2 => io::println(\"one or two\"),\n+  3..10 => io::println(\"three to ten\"),\n+  _     => io::println(\"something else\")\n }\n ~~~~\n \n There is no 'falling through' between arms, as in C\u2014only one arm is\n executed, and it doesn't have to explicitly `break` out of the\n construct when it is finished.\n \n-The part to the left of each arm is called the pattern. Literals are\n-valid patterns, and will match only their own value. The pipe operator\n+The part to the left of the arrow `=>` is called the *pattern*. Literals are\n+valid patterns and will match only their own value. The pipe operator\n (`|`) can be used to assign multiple patterns to a single arm. Ranges\n-of numeric literal patterns can be expressed with `to`. The underscore\n+of numeric literal patterns can be expressed with `..`. The underscore\n (`_`) is a wildcard pattern that matches everything.\n \n The patterns in an match arm are followed by a fat arrow, `=>`, then an\n@@ -740,10 +593,10 @@ commas are optional.\n # let my_number = 1;\n match my_number {\n   0 => {\n-    io::println(~\"zero\")\n+    io::println(\"zero\")\n   }\n   _ => {\n-    io::println(~\"something else\")\n+    io::println(\"something else\")\n   }\n }\n ~~~\n@@ -758,10 +611,11 @@ you use the matching to get at the contents of data types. Remember\n that `(float, float)` is a tuple of two floats:\n \n ~~~~\n-fn angle(vec: (float, float)) -> float {\n-    match vec {\n-      (0f, y) if y < 0f => 1.5 * float::consts::pi,\n-      (0f, y) => 0.5 * float::consts::pi,\n+use float::consts::pi;\n+fn angle(vector: (float, float)) -> float {\n+    match vector {\n+      (0f, y) if y < 0f => 1.5 * pi,\n+      (0f, y) => 0.5 * pi,\n       (x, y) => float::atan(y / x)\n     }\n }\n@@ -828,88 +682,6 @@ For more involved iteration, such as going over the elements of a\n collection, Rust uses higher-order functions. We'll come back to those\n in a moment.\n \n-## Failure\n-\n-The `fail` keyword causes the current [task](#tasks) to fail. You use\n-it to indicate unexpected failure, much like you'd use `abort` in a\n-C program or a fatal exception in a C++ program.\n-\n-There is no way for the current task to resume execution after\n-failure; failure is nonrecoverable. It is, however, possible for\n-*another* task to handle the failure, allowing the program to continue\n-running.\n-\n-`fail` takes an optional argument specifying the reason for the\n-failure. It must have type `~str`.\n-\n-In addition to the `fail` statement, the following circumstances cause\n-task failure:\n-\n-* Accessing an out-of-bounds element of a vector.\n-\n-* An assertion failure.\n-\n-* Integer division by zero.\n-\n-* Running out of memory.\n-\n-## Assertions\n-\n-The keyword `assert`, followed by an expression with boolean type,\n-will check that the given expression results in `true`, and cause a\n-failure otherwise. It is typically used to double-check things that\n-*should* hold at a certain point in a program. `assert` statements are\n-always active; there is no way to build Rust code with assertions\n-disabled.\n-\n-~~~~\n-let mut x = 100;\n-while (x > 10) { x -= 10; }\n-assert x == 10;\n-~~~~\n-\n-## Logging\n-\n-Rust has a built-in logging mechanism, using the `log` statement.\n-Logging is polymorphic\u2014any type of value can be logged, and the\n-runtime will do its best to output a textual representation of the\n-value.\n-\n-~~~~\n-log(warn, ~\"hi\");\n-log(error, (1, ~[2.5, -1.8]));\n-~~~~\n-\n-The first argument is the log level (levels `debug`, `info`, `warn`,\n-and `error` are predefined), and the second is the value to log. By\n-default, you *will not* see the output of that first log statement,\n-which has `warn` level. The environment variable `RUST_LOG` controls\n-which log level is used. It can contain a comma-separated list of\n-paths for modules that should be logged. For example, running `rustc`\n-with `RUST_LOG=rustc::front::attr` will turn on logging in its\n-attribute parser. If you compile a program named `foo.rs`, its\n-top-level module will be called `foo`, and you can set `RUST_LOG` to\n-`foo` to enable `warn`, `info` and `debug` logging for the module.\n-\n-Turned-off `log` statements impose minimal overhead on the code that\n-contains them, because the arguments to `log` are evaluated lazily.\n-So except in code that needs to be really, really fast,\n-you should feel free to scatter around debug logging statements, and\n-leave them in.\n-\n-Three macros that combine text-formatting (as with `fmt!`) and logging\n-are available. These take a string and any number of format arguments,\n-and will log the formatted string:\n-\n-~~~~\n-# fn get_error_string() -> ~str { ~\"boo\" }\n-warn!(\"only %d seconds remaining\", 10);\n-error!(\"fatal: %s\", get_error_string());\n-~~~~\n-\n-Because the macros `debug!`, `warn!`, and `error!` expand to calls to `log`,\n-their arguments are also lazily evaluated.\n-\n # Functions\n \n Like all other static declarations, such as `type`, functions can be\n@@ -921,8 +693,12 @@ with the `fn` keyword, the type of arguments are specified following\n colons and the return type follows the arrow.\n \n ~~~~\n-fn int_to_str(i: int) -> ~str {\n-    return ~\"tube sock\";\n+fn repeat(string: &str, count: int) -> ~str {\n+    let mut result = ~\"\";\n+    for count.times {\n+        result += string;\n+    }\n+    return result;\n }\n ~~~~\n \n@@ -967,116 +743,79 @@ In Rust, these are annotated with the pseudo-return type '`!`':\n fn dead_end() -> ! { fail }\n ~~~~\n \n-This helps the compiler avoid spurious error messages. For example,\n-the following code would be a type error if `dead_end` would be\n-expected to return.\n-\n-~~~~\n-# fn can_go_left() -> bool { true }\n-# fn can_go_right() -> bool { true }\n-# enum dir { left, right }\n-# fn dead_end() -> ! { fail; }\n-let dir = if can_go_left() { left }\n-          else if can_go_right() { right }\n-          else { dead_end(); };\n-~~~~\n+Using `!` in your code instead of making up a return type helps the compiler\n+avoid spurious error messages.\n \n # Basic datatypes\n \n-The core datatypes of Rust are structural records, enums (tagged\n-unions, algebraic data types), and tuples. They are immutable\n-by default.\n+The core datatypes of Rust are structs, enums (tagged unions, algebraic data\n+types), and tuples. They are immutable by default.\n \n ~~~~\n-type point = {x: float, y: float};\n+struct Point { x: float, y: float }\n \n-enum shape {\n-    circle(point, float),\n-    rectangle(point, point)\n+enum Shape {\n+    Circle(Point, float),\n+    Rectangle(Point, Point)\n }\n ~~~~\n \n-## Records\n+## Structs\n \n-Rust record types are written `{field1: T1, field2: T2 [, ...]}`,\n-where `T1`, `T2`, ... denote types.  Record literals are written in\n-the same way, but with expressions instead of types. They are quite\n-similar to C structs, and even laid out the same way in memory (so you\n-can read from a Rust struct in C, and vice-versa). The dot operator is\n-used to access record fields (`mypoint.x`).\n-\n-Fields that you want to mutate must be explicitly marked `mut`.\n-\n-~~~~\n-type stack = {content: ~[int], mut head: uint};\n-~~~~\n+Rust struct types must be declared before they are used using the `struct`\n+syntax: `struct Name { field1: T1, field2: T2 [, ...] }`, where `T1`, `T2`,\n+... denote types. To construct a struct, use the same syntax, but leave off\n+the `struct`; for example: `Point { x: 1.0, y: 2.0 }`.\n \n-With such a type, you can do `mystack.head += 1u`. If `mut` were\n-omitted from the type, such an assignment would result in a type\n-error.\n+Structs are quite similar to C structs and are even laid out the same way in\n+memory (so you can read from a Rust struct in C, and vice-versa). The dot\n+operator is used to access struct fields (`mypoint.x`).\n \n-To create a new record based on the value of an existing record\n-you construct it using the `with` keyword:\n+Fields that you want to mutate must be explicitly marked `mut`.\n \n ~~~~\n-# impl {x:float, y:float} : core::cmp::Eq {\n-#   pure fn eq(&&other: {x:float, y:float}) -> bool {\n-#       self.x == other.x && self.y == other.y\n-#   }\n-# }\n-\n-let oldpoint = {x: 10f, y: 20f};\n-let newpoint = {x: 0f with oldpoint};\n-assert newpoint == {x: 0f, y: 20f};\n+struct Stack {\n+    content: ~[int],\n+    mut head: uint\n+}\n ~~~~\n \n-This will create a new record, copying all the fields from `oldpoint`\n-into it, except for the ones that are explicitly set in the literal.\n-\n-Rust record types are *structural*. This means that `{x: float, y:\n-float}` is not just a way to define a new type, but is the actual name\n-of the type. Record types can be used without first defining them. If\n-module A defines `type point = {x: float, y: float}`, and module B,\n-without knowing anything about A, defines a function that returns an\n-`{x: float, y: float}`, you can use that return value as a `point` in\n-module A. (Remember that `type` defines an additional name for a type,\n-not an actual new type.)\n+With a value of such a type, you can do `mystack.head += 1`. If `mut` were\n+omitted from the type, such an assignment would result in a type error.\n \n-## Record patterns\n-\n-Records can be destructured in `match` patterns. The basic syntax is\n-`{fieldname: pattern, ...}`, but the pattern for a field can be\n-omitted as a shorthand for simply binding the variable with the same\n-name as the field.\n+## Struct patterns\n \n+Structs can be destructured in `match` patterns. The basic syntax is\n+`Name {fieldname: pattern, ...}`:\n ~~~~\n-# let mypoint = {x: 0f, y: 0f};\n+# struct Point { x: float, y: float }\n+# let mypoint = Point { x: 0.0, y: 0.0 };\n match mypoint {\n-    {x: 0f, y: y_name} => { /* Provide sub-patterns for fields */ }\n-    {x, y}             => { /* Simply bind the fields */ }\n+    Point { x: 0.0, y: y } => { io::println(y.to_str());                    }\n+    Point { x: x, y: y }   => { io::println(x.to_str() + \" \" + y.to_str()); }\n }\n ~~~~\n \n-The field names of a record do not have to appear in a pattern in the\n-same order they appear in the type. When you are not interested in all\n-the fields of a record, a record pattern may end with `, _` (as in\n-`{field1, _}`) to indicate that you're ignoring all other fields.\n+In general, the field names of a struct do not have to appear in the same\n+order they appear in the type. When you are not interested in all\n+the fields of a struct, a struct pattern may end with `, _` (as in\n+`Name {field1, _}`) to indicate that you're ignoring all other fields.\n \n ## Enums\n \n Enums are datatypes that have several alternate representations. For\n example, consider the type shown earlier:\n \n ~~~~\n-# type point = {x: float, y: float};\n-enum shape {\n-    circle(point, float),\n-    rectangle(point, point)\n+# struct Point { x: float, y: float }\n+enum Shape {\n+    Circle(Point, float),\n+    Rectangle(Point, Point)\n }\n ~~~~\n \n-A value of this type is either a circle, in which case it contains a\n-point record and a float, or a rectangle, in which case it contains\n+A value of this type is either a Circle, in which case it contains a\n+point struct and a float, or a Rectangle, in which case it contains\n two point records. The run-time representation of such a value\n includes an identifier of the actual form that it holds, much like the\n 'tagged union' pattern in C, but with better ergonomics."}]}