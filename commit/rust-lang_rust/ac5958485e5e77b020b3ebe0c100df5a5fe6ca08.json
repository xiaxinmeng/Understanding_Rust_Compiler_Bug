{"sha": "ac5958485e5e77b020b3ebe0c100df5a5fe6ca08", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNTk1ODQ4NWU1ZTc3YjAyMGIzZWJlMGMxMDBkZjVhNWZlNmNhMDg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-05T02:55:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-05T02:55:56Z"}, "message": "Merge #7535\n\n7535: Extract function assist r=cpud36 a=cpud36\n\nThis PR adds `extract function/method` assist. closes #5409.\r\n\r\n# Supported features\r\nAssist should support extracting from expressions(`1`, `2 + 2`, `loop { }`) and from a series of statements, e.g.:\r\n```rust\r\nfoo();\r\n$0bar();\r\nbaz();$0\r\nquix();\r\n```\r\nAssist also supports extracting parameters, like:\r\n```rust\r\nfn foo() -> i32 {\r\n  let n = 1;\r\n  $0n + 1$0\r\n}\r\n\r\n// -\r\nfn foo() -> i32 {\r\n  let n = 1;\r\n  fun_name(n)\r\n}\r\n\r\nfn fun_name(n: i32) -> i32 {\r\n  n + 1\r\n}\r\n```\r\n\r\nExtracting methods also generally works.\r\n\r\nAssist allows referencing outer variables, both mutably and immutably, and handles handles access to variables local to extracted function:\r\n```rust\r\nfn foo() {\r\n  let mut n = 1;\r\n  let mut m = 2;\r\n  let mut moved_v = Vec::new();\r\n  let mut ref_mut_v = Vec::new();\r\n  $0\r\n  n += 1;\r\n  let k = 1;\r\n  moved_v.push(n);\r\n  let r = &mut m;\r\n  ref_mut_v.push(*r);\r\n  let h = 3;\r\n  $0\r\n  n = ref_mut_v.len() + k;\r\n  n -= h + m;\r\n}\r\n\r\n// -\r\nfn foo() {\r\n  let mut n = 1;\r\n  let mut m = 2;\r\n  let mut moved_v = Vec::new();\r\n  let mut ref_mut_v = Vec::new();\r\n \r\n  let (k, h) =  fun_name(&mut n, moved_v, &mut m, &mut ref_mut_v);\r\n\r\n  n = ref_mut_v.len() + k;\r\n  n -= h + m;\r\n}\r\n\r\nfn fun_name(n: &mut i32, mut moved_v: Vec<i32>, m: &mut i32, ref_mut_v: &mut Vec<i32>) -> (i32, i32) {\r\n  *n += 1;\r\n  let k = 1;\r\n  moved_v.push(*n);\r\n  let r = m;\r\n  ref_mut_v.push(*r);\r\n  let h = 3;\r\n  (k, h)\r\n}\r\n```\r\n\r\nSo we handle both input and output paramters\r\n\r\n# Showcase\r\n\r\n![extract_cursor_in_range_3](https://user-images.githubusercontent.com/4218373/106980190-c9870800-6770-11eb-83d9-3d36b2550ff6.gif)\r\n![fill_match_arms_discard_wildcard](https://user-images.githubusercontent.com/4218373/106980197-cbe96200-6770-11eb-96b0-14c27894fac0.gif)\r\n![ide_db_helpers_handle_kind](https://user-images.githubusercontent.com/4218373/106980201-cdb32580-6770-11eb-9e6e-6ac8155d65ac.gif)\r\n![ide_db_imports_location_local_query](https://user-images.githubusercontent.com/4218373/106980205-cf7ce900-6770-11eb-8516-653c8fcca807.gif)\r\n\r\n# Working with non-`Copy` types\r\n\r\nConsider the following example:\r\n```rust\r\nfn foo() {\r\n  let v = Vec::new();\r\n  $0\r\n  let n = v.len();\r\n  $0\r\n  let is_empty = v.is_empty();\r\n}\r\n```\r\n`v` must be a parameter to extracted function. \r\nThe question is, what type should it have.\r\nIt could be `v: Vec<i32>`, or `v: &Vec<i32>`. \r\nThe former is incorrect for `Vec<i32>`, but the later is silly for `i32`.\r\n\r\nTo resolve this we need to know if the type implements `Copy` trait.\r\n\r\nI didn't find any api available from assists to query this. \r\n`hir_ty::method_resolution::implements` seems relevant, but is isn't publicly re-exported from `hir`.\r\n\r\n# Star(`*`) token and pointer dereference\r\n\r\nIf I understand correctly, in order to create expression like `*p`, one should use `ast::make::expr_prefix(T![*], ...)`, which\r\nin turn calls `token(T![*])`.\r\n\r\n`token` does not have star in `tokens::SOURCE_FILE`, so this panics.\r\nI had to add `*` to `SOURCE_FILE` to make it work.\r\n\r\nCorrect me if this is not intended way to do this.\r\n\r\n# Lowering access `value -> mut ref -> shared ref`\r\n\r\nConsider the following example:\r\n```rust\r\nfn foo() {\r\n  let v = Vec::new();\r\n  $0 let n = v.len(); $0\r\n}\r\n```\r\n`v` is not used after extracted function body, so both `v: &Vec<i32>` and `v: Vec<i32>` would work.\r\nCurrently the later would be chosen.\r\n\r\nWe can however check the body of extracted function and conclude that `v: &Vec<i32>` is sufficient.\r\nUsing `v: &Vec<i32>`(that is a minimal required access level) might be a better default.\r\nI am unsure.\r\n\r\n# Cleanup\r\nThe assist seems to be reasonably handling most of common cases.\r\nIf there are no concerns with code it produces(i.e. with test cases), I will start cleaning up\r\n\r\n[edit]\r\nadded showcase\r\n\n\nCo-authored-by: Vladyslav Katasonov <cpud47@gmail.com>", "tree": {"sha": "fd76eca27628f746269d3d7478226d88e595e3aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd76eca27628f746269d3d7478226d88e595e3aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac5958485e5e77b020b3ebe0c100df5a5fe6ca08", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgHLO8CRBK7hj4Ov3rIwAAdHIIAJAnscsq/WYr/TR5JoWGAs9P\nrSDg0DsbJjkOjkLND0NbjYq5uZtTDSPMpRD4doP4uAU2VkRoEG891jTpDTTFXc/v\niBTcjM5cu/kNxmiY/Cwsu4CDRlUMkT2H8H/jQUXCOHUw+Nr/o0BohPReaK0BkeP3\n+ZD/u0ZDgynC/73awA/kXWxNzATr3FyCCwm7kcgJmxR3aee7XMC71c/y/hj0eFza\nzYKSh9YvV/4Dh/qfBVH6EqrQJG1zFRNGafLIbwF9zMtx3jdADqz8ZYt9dOYP/uwE\n+y4CkwKAY9iZW32GuuvWGLG0vPjUNyDUXLw4dqUrbB2+ljjUlVY9wvJN0+qUy6s=\n=a3H7\n-----END PGP SIGNATURE-----\n", "payload": "tree fd76eca27628f746269d3d7478226d88e595e3aa\nparent 842033b15055eba9aabfc730468cd076a30a5f29\nparent 7eaa3e56a01e9a275129c76817232559b0e20f2b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1612493756 +0000\ncommitter GitHub <noreply@github.com> 1612493756 +0000\n\nMerge #7535\n\n7535: Extract function assist r=cpud36 a=cpud36\n\nThis PR adds `extract function/method` assist. closes #5409.\r\n\r\n# Supported features\r\nAssist should support extracting from expressions(`1`, `2 + 2`, `loop { }`) and from a series of statements, e.g.:\r\n```rust\r\nfoo();\r\n$0bar();\r\nbaz();$0\r\nquix();\r\n```\r\nAssist also supports extracting parameters, like:\r\n```rust\r\nfn foo() -> i32 {\r\n  let n = 1;\r\n  $0n + 1$0\r\n}\r\n\r\n// -\r\nfn foo() -> i32 {\r\n  let n = 1;\r\n  fun_name(n)\r\n}\r\n\r\nfn fun_name(n: i32) -> i32 {\r\n  n + 1\r\n}\r\n```\r\n\r\nExtracting methods also generally works.\r\n\r\nAssist allows referencing outer variables, both mutably and immutably, and handles handles access to variables local to extracted function:\r\n```rust\r\nfn foo() {\r\n  let mut n = 1;\r\n  let mut m = 2;\r\n  let mut moved_v = Vec::new();\r\n  let mut ref_mut_v = Vec::new();\r\n  $0\r\n  n += 1;\r\n  let k = 1;\r\n  moved_v.push(n);\r\n  let r = &mut m;\r\n  ref_mut_v.push(*r);\r\n  let h = 3;\r\n  $0\r\n  n = ref_mut_v.len() + k;\r\n  n -= h + m;\r\n}\r\n\r\n// -\r\nfn foo() {\r\n  let mut n = 1;\r\n  let mut m = 2;\r\n  let mut moved_v = Vec::new();\r\n  let mut ref_mut_v = Vec::new();\r\n \r\n  let (k, h) =  fun_name(&mut n, moved_v, &mut m, &mut ref_mut_v);\r\n\r\n  n = ref_mut_v.len() + k;\r\n  n -= h + m;\r\n}\r\n\r\nfn fun_name(n: &mut i32, mut moved_v: Vec<i32>, m: &mut i32, ref_mut_v: &mut Vec<i32>) -> (i32, i32) {\r\n  *n += 1;\r\n  let k = 1;\r\n  moved_v.push(*n);\r\n  let r = m;\r\n  ref_mut_v.push(*r);\r\n  let h = 3;\r\n  (k, h)\r\n}\r\n```\r\n\r\nSo we handle both input and output paramters\r\n\r\n# Showcase\r\n\r\n![extract_cursor_in_range_3](https://user-images.githubusercontent.com/4218373/106980190-c9870800-6770-11eb-83d9-3d36b2550ff6.gif)\r\n![fill_match_arms_discard_wildcard](https://user-images.githubusercontent.com/4218373/106980197-cbe96200-6770-11eb-96b0-14c27894fac0.gif)\r\n![ide_db_helpers_handle_kind](https://user-images.githubusercontent.com/4218373/106980201-cdb32580-6770-11eb-9e6e-6ac8155d65ac.gif)\r\n![ide_db_imports_location_local_query](https://user-images.githubusercontent.com/4218373/106980205-cf7ce900-6770-11eb-8516-653c8fcca807.gif)\r\n\r\n# Working with non-`Copy` types\r\n\r\nConsider the following example:\r\n```rust\r\nfn foo() {\r\n  let v = Vec::new();\r\n  $0\r\n  let n = v.len();\r\n  $0\r\n  let is_empty = v.is_empty();\r\n}\r\n```\r\n`v` must be a parameter to extracted function. \r\nThe question is, what type should it have.\r\nIt could be `v: Vec<i32>`, or `v: &Vec<i32>`. \r\nThe former is incorrect for `Vec<i32>`, but the later is silly for `i32`.\r\n\r\nTo resolve this we need to know if the type implements `Copy` trait.\r\n\r\nI didn't find any api available from assists to query this. \r\n`hir_ty::method_resolution::implements` seems relevant, but is isn't publicly re-exported from `hir`.\r\n\r\n# Star(`*`) token and pointer dereference\r\n\r\nIf I understand correctly, in order to create expression like `*p`, one should use `ast::make::expr_prefix(T![*], ...)`, which\r\nin turn calls `token(T![*])`.\r\n\r\n`token` does not have star in `tokens::SOURCE_FILE`, so this panics.\r\nI had to add `*` to `SOURCE_FILE` to make it work.\r\n\r\nCorrect me if this is not intended way to do this.\r\n\r\n# Lowering access `value -> mut ref -> shared ref`\r\n\r\nConsider the following example:\r\n```rust\r\nfn foo() {\r\n  let v = Vec::new();\r\n  $0 let n = v.len(); $0\r\n}\r\n```\r\n`v` is not used after extracted function body, so both `v: &Vec<i32>` and `v: Vec<i32>` would work.\r\nCurrently the later would be chosen.\r\n\r\nWe can however check the body of extracted function and conclude that `v: &Vec<i32>` is sufficient.\r\nUsing `v: &Vec<i32>`(that is a minimal required access level) might be a better default.\r\nI am unsure.\r\n\r\n# Cleanup\r\nThe assist seems to be reasonably handling most of common cases.\r\nIf there are no concerns with code it produces(i.e. with test cases), I will start cleaning up\r\n\r\n[edit]\r\nadded showcase\r\n\n\nCo-authored-by: Vladyslav Katasonov <cpud47@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac5958485e5e77b020b3ebe0c100df5a5fe6ca08", "html_url": "https://github.com/rust-lang/rust/commit/ac5958485e5e77b020b3ebe0c100df5a5fe6ca08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac5958485e5e77b020b3ebe0c100df5a5fe6ca08/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "842033b15055eba9aabfc730468cd076a30a5f29", "url": "https://api.github.com/repos/rust-lang/rust/commits/842033b15055eba9aabfc730468cd076a30a5f29", "html_url": "https://github.com/rust-lang/rust/commit/842033b15055eba9aabfc730468cd076a30a5f29"}, {"sha": "7eaa3e56a01e9a275129c76817232559b0e20f2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7eaa3e56a01e9a275129c76817232559b0e20f2b", "html_url": "https://github.com/rust-lang/rust/commit/7eaa3e56a01e9a275129c76817232559b0e20f2b"}], "stats": {"total": 2190, "additions": 2189, "deletions": 1}, "files": [{"sha": "d876eabca9b797a5a602feb83cde3954f2bdf64c", "filename": "crates/assists/src/handlers/extract_function.rs", "status": "added", "additions": 2159, "deletions": 0, "changes": 2159, "blob_url": "https://github.com/rust-lang/rust/blob/ac5958485e5e77b020b3ebe0c100df5a5fe6ca08/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5958485e5e77b020b3ebe0c100df5a5fe6ca08/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=ac5958485e5e77b020b3ebe0c100df5a5fe6ca08", "patch": "@@ -0,0 +1,2159 @@\n+use either::Either;\n+use hir::{HirDisplay, Local};\n+use ide_db::{\n+    defs::{Definition, NameRefClass},\n+    search::{FileReference, ReferenceAccess, SearchScope},\n+};\n+use itertools::Itertools;\n+use stdx::format_to;\n+use syntax::{\n+    algo::SyntaxRewriter,\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        AstNode,\n+    },\n+    AstToken, Direction, SyntaxElement,\n+    SyntaxKind::{self, BLOCK_EXPR, BREAK_EXPR, COMMENT, PATH_EXPR, RETURN_EXPR},\n+    SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, T,\n+};\n+use test_utils::mark;\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n+\n+// Assist: extract_function\n+//\n+// Extracts selected statements into new function.\n+//\n+// ```\n+// fn main() {\n+//     let n = 1;\n+//     $0let m = n + 2;\n+//     let k = m + n;$0\n+//     let g = 3;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let n = 1;\n+//     fun_name(n);\n+//     let g = 3;\n+// }\n+//\n+// fn $0fun_name(n: i32) {\n+//     let m = n + 2;\n+//     let k = m + n;\n+// }\n+// ```\n+pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    if ctx.frange.range.is_empty() {\n+        return None;\n+    }\n+\n+    let node = ctx.covering_element();\n+    if node.kind() == COMMENT {\n+        mark::hit!(extract_function_in_comment_is_not_applicable);\n+        return None;\n+    }\n+\n+    let node = element_to_node(node);\n+\n+    let body = extraction_target(&node, ctx.frange.range)?;\n+\n+    let vars_used_in_body = vars_used_in_body(ctx, &body);\n+    let self_param = self_param_from_usages(ctx, &body, &vars_used_in_body);\n+\n+    let anchor = if self_param.is_some() { Anchor::Method } else { Anchor::Freestanding };\n+    let insert_after = scope_for_fn_insertion(&body, anchor)?;\n+    let module = ctx.sema.scope(&insert_after).module()?;\n+\n+    let vars_defined_in_body_and_outlive = vars_defined_in_body_and_outlive(ctx, &body);\n+    let ret_ty = body_return_ty(ctx, &body)?;\n+\n+    // FIXME: we compute variables that outlive here just to check `never!` condition\n+    //        this requires traversing whole `body` (cheap) and finding all references (expensive)\n+    //        maybe we can move this check to `edit` closure somehow?\n+    if stdx::never!(!vars_defined_in_body_and_outlive.is_empty() && !ret_ty.is_unit()) {\n+        // We should not have variables that outlive body if we have expression block\n+        return None;\n+    }\n+\n+    let target_range = match &body {\n+        FunctionBody::Expr(expr) => expr.syntax().text_range(),\n+        FunctionBody::Span { .. } => ctx.frange.range,\n+    };\n+\n+    acc.add(\n+        AssistId(\"extract_function\", crate::AssistKind::RefactorExtract),\n+        \"Extract into function\",\n+        target_range,\n+        move |builder| {\n+            let params = extracted_function_params(ctx, &body, &vars_used_in_body);\n+\n+            let fun = Function {\n+                name: \"fun_name\".to_string(),\n+                self_param: self_param.map(|(_, pat)| pat),\n+                params,\n+                ret_ty,\n+                body,\n+                vars_defined_in_body_and_outlive,\n+            };\n+\n+            builder.replace(target_range, format_replacement(ctx, &fun));\n+\n+            let new_indent = IndentLevel::from_node(&insert_after);\n+            let old_indent = fun.body.indent_level();\n+\n+            let fn_def = format_function(ctx, module, &fun, old_indent, new_indent);\n+            let insert_offset = insert_after.text_range().end();\n+            builder.insert(insert_offset, fn_def);\n+        },\n+    )\n+}\n+\n+#[derive(Debug)]\n+struct Function {\n+    name: String,\n+    self_param: Option<ast::SelfParam>,\n+    params: Vec<Param>,\n+    ret_ty: RetType,\n+    body: FunctionBody,\n+    vars_defined_in_body_and_outlive: Vec<Local>,\n+}\n+\n+#[derive(Debug)]\n+struct Param {\n+    var: Local,\n+    ty: hir::Type,\n+    has_usages_afterwards: bool,\n+    has_mut_inside_body: bool,\n+    is_copy: bool,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum ParamKind {\n+    Value,\n+    MutValue,\n+    SharedRef,\n+    MutRef,\n+}\n+\n+impl ParamKind {\n+    fn is_ref(&self) -> bool {\n+        matches!(self, ParamKind::SharedRef | ParamKind::MutRef)\n+    }\n+}\n+\n+impl Param {\n+    fn kind(&self) -> ParamKind {\n+        match (self.has_usages_afterwards, self.has_mut_inside_body, self.is_copy) {\n+            (true, true, _) => ParamKind::MutRef,\n+            (true, false, false) => ParamKind::SharedRef,\n+            (false, true, _) => ParamKind::MutValue,\n+            (true, false, true) | (false, false, _) => ParamKind::Value,\n+        }\n+    }\n+\n+    fn value_prefix(&self) -> &'static str {\n+        match self.kind() {\n+            ParamKind::Value | ParamKind::MutValue => \"\",\n+            ParamKind::SharedRef => \"&\",\n+            ParamKind::MutRef => \"&mut \",\n+        }\n+    }\n+\n+    fn type_prefix(&self) -> &'static str {\n+        match self.kind() {\n+            ParamKind::Value | ParamKind::MutValue => \"\",\n+            ParamKind::SharedRef => \"&\",\n+            ParamKind::MutRef => \"&mut \",\n+        }\n+    }\n+\n+    fn mut_pattern(&self) -> &'static str {\n+        match self.kind() {\n+            ParamKind::MutValue => \"mut \",\n+            _ => \"\",\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum RetType {\n+    Expr(hir::Type),\n+    Stmt,\n+}\n+\n+impl RetType {\n+    fn is_unit(&self) -> bool {\n+        match self {\n+            RetType::Expr(ty) => ty.is_unit(),\n+            RetType::Stmt => true,\n+        }\n+    }\n+\n+    fn as_fn_ret(&self) -> Option<&hir::Type> {\n+        match self {\n+            RetType::Stmt => None,\n+            RetType::Expr(ty) if ty.is_unit() => None,\n+            RetType::Expr(ty) => Some(ty),\n+        }\n+    }\n+}\n+\n+/// Semantically same as `ast::Expr`, but preserves identity when using only part of the Block\n+#[derive(Debug)]\n+enum FunctionBody {\n+    Expr(ast::Expr),\n+    Span { elements: Vec<SyntaxElement>, leading_indent: String },\n+}\n+\n+impl FunctionBody {\n+    fn from_whole_node(node: SyntaxNode) -> Option<Self> {\n+        match node.kind() {\n+            PATH_EXPR => None,\n+            BREAK_EXPR => ast::BreakExpr::cast(node).and_then(|e| e.expr()).map(Self::Expr),\n+            RETURN_EXPR => ast::ReturnExpr::cast(node).and_then(|e| e.expr()).map(Self::Expr),\n+            BLOCK_EXPR => ast::BlockExpr::cast(node)\n+                .filter(|it| it.is_standalone())\n+                .map(Into::into)\n+                .map(Self::Expr),\n+            _ => ast::Expr::cast(node).map(Self::Expr),\n+        }\n+    }\n+\n+    fn from_range(node: &SyntaxNode, range: TextRange) -> Option<FunctionBody> {\n+        let mut first = node.token_at_offset(range.start()).left_biased()?;\n+        let last = node.token_at_offset(range.end()).right_biased()?;\n+\n+        let mut leading_indent = String::new();\n+\n+        let leading_trivia = first\n+            .siblings_with_tokens(Direction::Prev)\n+            .skip(1)\n+            .take_while(|e| e.kind() == SyntaxKind::WHITESPACE && e.as_token().is_some());\n+\n+        for e in leading_trivia {\n+            let token = e.as_token().unwrap();\n+            let text = token.text();\n+            match text.rfind('\\n') {\n+                Some(pos) => {\n+                    leading_indent = text[pos..].to_owned();\n+                    break;\n+                }\n+                None => first = token.clone(),\n+            }\n+        }\n+\n+        let mut elements: Vec<_> = first\n+            .siblings_with_tokens(Direction::Next)\n+            .take_while(|e| e.as_token() != Some(&last))\n+            .collect();\n+\n+        if !(last.kind() == SyntaxKind::WHITESPACE && last.text().lines().count() <= 2) {\n+            elements.push(last.into());\n+        }\n+\n+        Some(FunctionBody::Span { elements, leading_indent })\n+    }\n+\n+    fn indent_level(&self) -> IndentLevel {\n+        match &self {\n+            FunctionBody::Expr(expr) => IndentLevel::from_node(expr.syntax()),\n+            FunctionBody::Span { elements, .. } => elements\n+                .iter()\n+                .filter_map(SyntaxElement::as_node)\n+                .map(IndentLevel::from_node)\n+                .min_by_key(|level| level.0)\n+                .expect(\"body must contain at least one node\"),\n+        }\n+    }\n+\n+    fn tail_expr(&self) -> Option<ast::Expr> {\n+        match &self {\n+            FunctionBody::Expr(expr) => Some(expr.clone()),\n+            FunctionBody::Span { elements, .. } => {\n+                elements.iter().rev().find_map(|e| e.as_node()).cloned().and_then(ast::Expr::cast)\n+            }\n+        }\n+    }\n+\n+    fn descendants(&self) -> impl Iterator<Item = SyntaxNode> + '_ {\n+        match self {\n+            FunctionBody::Expr(expr) => Either::Right(expr.syntax().descendants()),\n+            FunctionBody::Span { elements, .. } => Either::Left(\n+                elements\n+                    .iter()\n+                    .filter_map(SyntaxElement::as_node)\n+                    .flat_map(SyntaxNode::descendants),\n+            ),\n+        }\n+    }\n+\n+    fn text_range(&self) -> TextRange {\n+        match self {\n+            FunctionBody::Expr(expr) => expr.syntax().text_range(),\n+            FunctionBody::Span { elements, .. } => TextRange::new(\n+                elements.first().unwrap().text_range().start(),\n+                elements.last().unwrap().text_range().end(),\n+            ),\n+        }\n+    }\n+\n+    fn contains_range(&self, range: TextRange) -> bool {\n+        self.text_range().contains_range(range)\n+    }\n+\n+    fn preceedes_range(&self, range: TextRange) -> bool {\n+        self.text_range().end() <= range.start()\n+    }\n+\n+    fn contains_node(&self, node: &SyntaxNode) -> bool {\n+        self.contains_range(node.text_range())\n+    }\n+}\n+\n+impl HasTokenAtOffset for FunctionBody {\n+    fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken> {\n+        match self {\n+            FunctionBody::Expr(expr) => expr.syntax().token_at_offset(offset),\n+            FunctionBody::Span { elements, .. } => {\n+                stdx::always!(self.text_range().contains(offset));\n+                let mut iter = elements\n+                    .iter()\n+                    .filter(|element| element.text_range().contains_inclusive(offset));\n+                let element1 = iter.next().expect(\"offset does not fall into body\");\n+                let element2 = iter.next();\n+                stdx::always!(iter.next().is_none(), \"> 2 tokens at offset\");\n+                let t1 = match element1 {\n+                    syntax::NodeOrToken::Node(node) => node.token_at_offset(offset),\n+                    syntax::NodeOrToken::Token(token) => TokenAtOffset::Single(token.clone()),\n+                };\n+                let t2 = element2.map(|e| match e {\n+                    syntax::NodeOrToken::Node(node) => node.token_at_offset(offset),\n+                    syntax::NodeOrToken::Token(token) => TokenAtOffset::Single(token.clone()),\n+                });\n+\n+                match t2 {\n+                    Some(t2) => match (t1.clone().right_biased(), t2.clone().left_biased()) {\n+                        (Some(e1), Some(e2)) => TokenAtOffset::Between(e1, e2),\n+                        (Some(_), None) => t1,\n+                        (None, _) => t2,\n+                    },\n+                    None => t1,\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// node or token's parent\n+fn element_to_node(node: SyntaxElement) -> SyntaxNode {\n+    match node {\n+        syntax::NodeOrToken::Node(n) => n,\n+        syntax::NodeOrToken::Token(t) => t.parent(),\n+    }\n+}\n+\n+/// Try to guess what user wants to extract\n+///\n+/// We have basically have two cases:\n+/// * We want whole node, like `loop {}`, `2 + 2`, `{ let n = 1; }` exprs.\n+///   Then we can use `ast::Expr`\n+/// * We want a few statements for a block. E.g.\n+///   ```rust,no_run\n+///   fn foo() -> i32 {\n+///     let m = 1;\n+///     $0\n+///     let n = 2;\n+///     let k = 3;\n+///     k + n\n+///     $0\n+///   }\n+///   ```\n+///\n+fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<FunctionBody> {\n+    // we have selected exactly the expr node\n+    // wrap it before anything else\n+    if node.text_range() == selection_range {\n+        let body = FunctionBody::from_whole_node(node.clone());\n+        if body.is_some() {\n+            return body;\n+        }\n+    }\n+\n+    // we have selected a few statements in a block\n+    // so covering_element returns the whole block\n+    if node.kind() == BLOCK_EXPR {\n+        let body = FunctionBody::from_range(&node, selection_range);\n+        if body.is_some() {\n+            return body;\n+        }\n+    }\n+\n+    // we have selected single statement\n+    // `from_whole_node` failed because (let) statement is not and expression\n+    // so we try to expand covering_element to parent and repeat the previous\n+    if let Some(parent) = node.parent() {\n+        if parent.kind() == BLOCK_EXPR {\n+            let body = FunctionBody::from_range(&parent, selection_range);\n+            if body.is_some() {\n+                return body;\n+            }\n+        }\n+    }\n+\n+    // select the closest containing expr (both ifs are used)\n+    std::iter::once(node.clone()).chain(node.ancestors()).find_map(FunctionBody::from_whole_node)\n+}\n+\n+/// list local variables that are referenced in `body`\n+fn vars_used_in_body(ctx: &AssistContext, body: &FunctionBody) -> Vec<Local> {\n+    // FIXME: currently usages inside macros are not found\n+    body.descendants()\n+        .filter_map(ast::NameRef::cast)\n+        .filter_map(|name_ref| NameRefClass::classify(&ctx.sema, &name_ref))\n+        .map(|name_kind| name_kind.referenced(ctx.db()))\n+        .filter_map(|definition| match definition {\n+            Definition::Local(local) => Some(local),\n+            _ => None,\n+        })\n+        .unique()\n+        .collect()\n+}\n+\n+/// find `self` param, that was not defined inside `body`\n+///\n+/// It should skip `self` params from impls inside `body`\n+fn self_param_from_usages(\n+    ctx: &AssistContext,\n+    body: &FunctionBody,\n+    vars_used_in_body: &[Local],\n+) -> Option<(Local, ast::SelfParam)> {\n+    let mut iter = vars_used_in_body\n+        .iter()\n+        .filter(|var| var.is_self(ctx.db()))\n+        .map(|var| (var, var.source(ctx.db())))\n+        .filter(|(_, src)| is_defined_before(ctx, body, src))\n+        .filter_map(|(&node, src)| match src.value {\n+            Either::Right(it) => Some((node, it)),\n+            Either::Left(_) => {\n+                stdx::never!(false, \"Local::is_self returned true, but source is IdentPat\");\n+                None\n+            }\n+        });\n+\n+    let self_param = iter.next();\n+    stdx::always!(\n+        iter.next().is_none(),\n+        \"body references two different self params, both defined outside\"\n+    );\n+\n+    self_param\n+}\n+\n+/// find variables that should be extracted as params\n+///\n+/// Computes additional info that affects param type and mutability\n+fn extracted_function_params(\n+    ctx: &AssistContext,\n+    body: &FunctionBody,\n+    vars_used_in_body: &[Local],\n+) -> Vec<Param> {\n+    vars_used_in_body\n+        .iter()\n+        .filter(|var| !var.is_self(ctx.db()))\n+        .map(|node| (node, node.source(ctx.db())))\n+        .filter(|(_, src)| is_defined_before(ctx, body, src))\n+        .filter_map(|(&node, src)| {\n+            if src.value.is_left() {\n+                Some(node)\n+            } else {\n+                stdx::never!(false, \"Local::is_self returned false, but source is SelfParam\");\n+                None\n+            }\n+        })\n+        .map(|var| {\n+            let usages = LocalUsages::find(ctx, var);\n+            let ty = var.ty(ctx.db());\n+            let is_copy = ty.is_copy(ctx.db());\n+            Param {\n+                var,\n+                ty,\n+                has_usages_afterwards: has_usages_after_body(&usages, body),\n+                has_mut_inside_body: has_exclusive_usages(ctx, &usages, body),\n+                is_copy,\n+            }\n+        })\n+        .collect()\n+}\n+\n+fn has_usages_after_body(usages: &LocalUsages, body: &FunctionBody) -> bool {\n+    usages.iter().any(|reference| body.preceedes_range(reference.range))\n+}\n+\n+/// checks if relevant var is used with `&mut` access inside body\n+fn has_exclusive_usages(ctx: &AssistContext, usages: &LocalUsages, body: &FunctionBody) -> bool {\n+    usages\n+        .iter()\n+        .filter(|reference| body.contains_range(reference.range))\n+        .any(|reference| reference_is_exclusive(reference, body, ctx))\n+}\n+\n+/// checks if this reference requires `&mut` access inside body\n+fn reference_is_exclusive(\n+    reference: &FileReference,\n+    body: &FunctionBody,\n+    ctx: &AssistContext,\n+) -> bool {\n+    // we directly modify variable with set: `n = 0`, `n += 1`\n+    if reference.access == Some(ReferenceAccess::Write) {\n+        return true;\n+    }\n+\n+    // we take `&mut` reference to variable: `&mut v`\n+    let path = match path_element_of_reference(body, reference) {\n+        Some(path) => path,\n+        None => return false,\n+    };\n+\n+    expr_require_exclusive_access(ctx, &path).unwrap_or(false)\n+}\n+\n+/// checks if this expr requires `&mut` access, recurses on field access\n+fn expr_require_exclusive_access(ctx: &AssistContext, expr: &ast::Expr) -> Option<bool> {\n+    let parent = expr.syntax().parent()?;\n+\n+    if let Some(bin_expr) = ast::BinExpr::cast(parent.clone()) {\n+        if bin_expr.op_kind()?.is_assignment() {\n+            return Some(bin_expr.lhs()?.syntax() == expr.syntax());\n+        }\n+        return Some(false);\n+    }\n+\n+    if let Some(ref_expr) = ast::RefExpr::cast(parent.clone()) {\n+        return Some(ref_expr.mut_token().is_some());\n+    }\n+\n+    if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n+        let func = ctx.sema.resolve_method_call(&method_call)?;\n+        let self_param = func.self_param(ctx.db())?;\n+        let access = self_param.access(ctx.db());\n+\n+        return Some(matches!(access, hir::Access::Exclusive));\n+    }\n+\n+    if let Some(field) = ast::FieldExpr::cast(parent) {\n+        return expr_require_exclusive_access(ctx, &field.into());\n+    }\n+\n+    Some(false)\n+}\n+\n+/// Container of local varaible usages\n+///\n+/// Semanticall same as `UsageSearchResult`, but provides more convenient interface\n+struct LocalUsages(ide_db::search::UsageSearchResult);\n+\n+impl LocalUsages {\n+    fn find(ctx: &AssistContext, var: Local) -> Self {\n+        Self(\n+            Definition::Local(var)\n+                .usages(&ctx.sema)\n+                .in_scope(SearchScope::single_file(ctx.frange.file_id))\n+                .all(),\n+        )\n+    }\n+\n+    fn iter(&self) -> impl Iterator<Item = &FileReference> + '_ {\n+        self.0.iter().flat_map(|(_, rs)| rs.iter())\n+    }\n+}\n+\n+trait HasTokenAtOffset {\n+    fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken>;\n+}\n+\n+impl HasTokenAtOffset for SyntaxNode {\n+    fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken> {\n+        SyntaxNode::token_at_offset(&self, offset)\n+    }\n+}\n+\n+/// find relevant `ast::PathExpr` for reference\n+///\n+/// # Preconditions\n+///\n+/// `node` must cover `reference`, that is `node.text_range().contains_range(reference.range)`\n+fn path_element_of_reference(\n+    node: &dyn HasTokenAtOffset,\n+    reference: &FileReference,\n+) -> Option<ast::Expr> {\n+    let token = node.token_at_offset(reference.range.start()).right_biased().or_else(|| {\n+        stdx::never!(false, \"cannot find token at variable usage: {:?}\", reference);\n+        None\n+    })?;\n+    let path = token.ancestors().find_map(ast::Expr::cast).or_else(|| {\n+        stdx::never!(false, \"cannot find path parent of variable usage: {:?}\", token);\n+        None\n+    })?;\n+    stdx::always!(matches!(path, ast::Expr::PathExpr(_)));\n+    Some(path)\n+}\n+\n+/// list local variables defined inside `body`\n+fn vars_defined_in_body(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n+    // FIXME: this doesn't work well with macros\n+    //        see https://github.com/rust-analyzer/rust-analyzer/pull/7535#discussion_r570048550\n+    body.descendants()\n+        .filter_map(ast::IdentPat::cast)\n+        .filter_map(|let_stmt| ctx.sema.to_def(&let_stmt))\n+        .unique()\n+        .collect()\n+}\n+\n+/// list local variables defined inside `body` that should be returned from extracted function\n+fn vars_defined_in_body_and_outlive(ctx: &AssistContext, body: &FunctionBody) -> Vec<Local> {\n+    let mut vars_defined_in_body = vars_defined_in_body(&body, ctx);\n+    vars_defined_in_body.retain(|var| var_outlives_body(ctx, body, var));\n+    vars_defined_in_body\n+}\n+\n+/// checks if the relevant local was defined before(outside of) body\n+fn is_defined_before(\n+    ctx: &AssistContext,\n+    body: &FunctionBody,\n+    src: &hir::InFile<Either<ast::IdentPat, ast::SelfParam>>,\n+) -> bool {\n+    src.file_id.original_file(ctx.db()) == ctx.frange.file_id\n+        && !body.contains_node(&either_syntax(&src.value))\n+}\n+\n+fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n+    match value {\n+        Either::Left(pat) => pat.syntax(),\n+        Either::Right(it) => it.syntax(),\n+    }\n+}\n+\n+/// checks if local variable is used after(outside of) body\n+fn var_outlives_body(ctx: &AssistContext, body: &FunctionBody, var: &Local) -> bool {\n+    let usages = Definition::Local(*var)\n+        .usages(&ctx.sema)\n+        .in_scope(SearchScope::single_file(ctx.frange.file_id))\n+        .all();\n+    let mut usages = usages.iter().flat_map(|(_, rs)| rs.iter());\n+\n+    usages.any(|reference| body.preceedes_range(reference.range))\n+}\n+\n+fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n+    match body.tail_expr() {\n+        Some(expr) => {\n+            let ty = ctx.sema.type_of_expr(&expr)?;\n+            Some(RetType::Expr(ty))\n+        }\n+        None => Some(RetType::Stmt),\n+    }\n+}\n+/// Where to put extracted function definition\n+#[derive(Debug)]\n+enum Anchor {\n+    /// Extract free function and put right after current top-level function\n+    Freestanding,\n+    /// Extract method and put right after current function in the impl-block\n+    Method,\n+}\n+\n+/// find where to put extracted function definition\n+///\n+/// Function should be put right after returned node\n+fn scope_for_fn_insertion(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNode> {\n+    match body {\n+        FunctionBody::Expr(e) => scope_for_fn_insertion_node(e.syntax(), anchor),\n+        FunctionBody::Span { elements, .. } => {\n+            let node = elements.iter().find_map(|e| e.as_node())?;\n+            scope_for_fn_insertion_node(&node, anchor)\n+        }\n+    }\n+}\n+\n+fn scope_for_fn_insertion_node(node: &SyntaxNode, anchor: Anchor) -> Option<SyntaxNode> {\n+    let mut ancestors = node.ancestors().peekable();\n+    let mut last_ancestor = None;\n+    while let Some(next_ancestor) = ancestors.next() {\n+        match next_ancestor.kind() {\n+            SyntaxKind::SOURCE_FILE => break,\n+            SyntaxKind::ITEM_LIST => {\n+                if !matches!(anchor, Anchor::Freestanding) {\n+                    continue;\n+                }\n+                if ancestors.peek().map(SyntaxNode::kind) == Some(SyntaxKind::MODULE) {\n+                    break;\n+                }\n+            }\n+            SyntaxKind::ASSOC_ITEM_LIST => {\n+                if !matches!(anchor, Anchor::Method) {\n+                    continue;\n+                }\n+                if ancestors.peek().map(SyntaxNode::kind) == Some(SyntaxKind::IMPL) {\n+                    break;\n+                }\n+            }\n+            _ => {}\n+        }\n+        last_ancestor = Some(next_ancestor);\n+    }\n+    last_ancestor\n+}\n+\n+fn format_replacement(ctx: &AssistContext, fun: &Function) -> String {\n+    let mut buf = String::new();\n+\n+    match fun.vars_defined_in_body_and_outlive.as_slice() {\n+        [] => {}\n+        [var] => format_to!(buf, \"let {} = \", var.name(ctx.db()).unwrap()),\n+        [v0, vs @ ..] => {\n+            buf.push_str(\"let (\");\n+            format_to!(buf, \"{}\", v0.name(ctx.db()).unwrap());\n+            for var in vs {\n+                format_to!(buf, \", {}\", var.name(ctx.db()).unwrap());\n+            }\n+            buf.push_str(\") = \");\n+        }\n+    }\n+\n+    if fun.self_param.is_some() {\n+        format_to!(buf, \"self.\");\n+    }\n+    format_to!(buf, \"{}(\", fun.name);\n+    format_arg_list_to(&mut buf, fun, ctx);\n+    format_to!(buf, \")\");\n+\n+    if fun.ret_ty.is_unit() {\n+        format_to!(buf, \";\");\n+    }\n+\n+    buf\n+}\n+\n+fn format_arg_list_to(buf: &mut String, fun: &Function, ctx: &AssistContext) {\n+    let mut it = fun.params.iter();\n+    if let Some(param) = it.next() {\n+        format_arg_to(buf, ctx, param);\n+    }\n+    for param in it {\n+        buf.push_str(\", \");\n+        format_arg_to(buf, ctx, param);\n+    }\n+}\n+\n+fn format_arg_to(buf: &mut String, ctx: &AssistContext, param: &Param) {\n+    format_to!(buf, \"{}{}\", param.value_prefix(), param.var.name(ctx.db()).unwrap());\n+}\n+\n+fn format_function(\n+    ctx: &AssistContext,\n+    module: hir::Module,\n+    fun: &Function,\n+    old_indent: IndentLevel,\n+    new_indent: IndentLevel,\n+) -> String {\n+    let mut fn_def = String::new();\n+    format_to!(fn_def, \"\\n\\n{}fn $0{}(\", new_indent, fun.name);\n+    format_function_param_list_to(&mut fn_def, ctx, module, fun);\n+    fn_def.push(')');\n+    format_function_ret_to(&mut fn_def, ctx, module, fun);\n+    fn_def.push_str(\" {\");\n+    format_function_body_to(&mut fn_def, ctx, old_indent, new_indent, fun);\n+    format_to!(fn_def, \"{}}}\", new_indent);\n+\n+    fn_def\n+}\n+\n+fn format_function_param_list_to(\n+    fn_def: &mut String,\n+    ctx: &AssistContext,\n+    module: hir::Module,\n+    fun: &Function,\n+) {\n+    let mut it = fun.params.iter();\n+    if let Some(self_param) = &fun.self_param {\n+        format_to!(fn_def, \"{}\", self_param);\n+    } else if let Some(param) = it.next() {\n+        format_param_to(fn_def, ctx, module, param);\n+    }\n+    for param in it {\n+        fn_def.push_str(\", \");\n+        format_param_to(fn_def, ctx, module, param);\n+    }\n+}\n+\n+fn format_param_to(fn_def: &mut String, ctx: &AssistContext, module: hir::Module, param: &Param) {\n+    format_to!(\n+        fn_def,\n+        \"{}{}: {}{}\",\n+        param.mut_pattern(),\n+        param.var.name(ctx.db()).unwrap(),\n+        param.type_prefix(),\n+        format_type(&param.ty, ctx, module)\n+    );\n+}\n+\n+fn format_function_ret_to(\n+    fn_def: &mut String,\n+    ctx: &AssistContext,\n+    module: hir::Module,\n+    fun: &Function,\n+) {\n+    if let Some(ty) = fun.ret_ty.as_fn_ret() {\n+        format_to!(fn_def, \" -> {}\", format_type(ty, ctx, module));\n+    } else {\n+        match fun.vars_defined_in_body_and_outlive.as_slice() {\n+            [] => {}\n+            [var] => {\n+                format_to!(fn_def, \" -> {}\", format_type(&var.ty(ctx.db()), ctx, module));\n+            }\n+            [v0, vs @ ..] => {\n+                format_to!(fn_def, \" -> ({}\", format_type(&v0.ty(ctx.db()), ctx, module));\n+                for var in vs {\n+                    format_to!(fn_def, \", {}\", format_type(&var.ty(ctx.db()), ctx, module));\n+                }\n+                fn_def.push(')');\n+            }\n+        }\n+    }\n+}\n+\n+fn format_function_body_to(\n+    fn_def: &mut String,\n+    ctx: &AssistContext,\n+    old_indent: IndentLevel,\n+    new_indent: IndentLevel,\n+    fun: &Function,\n+) {\n+    match &fun.body {\n+        FunctionBody::Expr(expr) => {\n+            fn_def.push('\\n');\n+            let expr = expr.dedent(old_indent).indent(new_indent + 1);\n+            let expr = fix_param_usages(ctx, &fun.params, expr.syntax());\n+            format_to!(fn_def, \"{}{}\", new_indent + 1, expr);\n+            fn_def.push('\\n');\n+        }\n+        FunctionBody::Span { elements, leading_indent } => {\n+            format_to!(fn_def, \"{}\", leading_indent);\n+            let new_indent_str = format!(\"\\n{}\", new_indent + 1);\n+            for mut element in elements {\n+                let new_ws;\n+                if let Some(ws) = element.as_token().cloned().and_then(ast::Whitespace::cast) {\n+                    let text = ws.syntax().text();\n+                    if text.contains('\\n') {\n+                        let new_text = text.replace(&format!(\"\\n{}\", old_indent), &new_indent_str);\n+                        new_ws = ast::make::tokens::whitespace(&new_text).into();\n+                        element = &new_ws;\n+                    }\n+                }\n+\n+                match element {\n+                    syntax::NodeOrToken::Node(node) => {\n+                        format_to!(fn_def, \"{}\", fix_param_usages(ctx, &fun.params, node));\n+                    }\n+                    syntax::NodeOrToken::Token(token) => {\n+                        format_to!(fn_def, \"{}\", token);\n+                    }\n+                }\n+            }\n+            if !fn_def.ends_with('\\n') {\n+                fn_def.push('\\n');\n+            }\n+        }\n+    }\n+\n+    match fun.vars_defined_in_body_and_outlive.as_slice() {\n+        [] => {}\n+        [var] => format_to!(fn_def, \"{}{}\\n\", new_indent + 1, var.name(ctx.db()).unwrap()),\n+        [v0, vs @ ..] => {\n+            format_to!(fn_def, \"{}({}\", new_indent + 1, v0.name(ctx.db()).unwrap());\n+            for var in vs {\n+                format_to!(fn_def, \", {}\", var.name(ctx.db()).unwrap());\n+            }\n+            fn_def.push_str(\")\\n\");\n+        }\n+    }\n+}\n+\n+fn format_type(ty: &hir::Type, ctx: &AssistContext, module: hir::Module) -> String {\n+    ty.display_source_code(ctx.db(), module.into()).ok().unwrap_or_else(|| \"()\".to_string())\n+}\n+\n+/// change all usages to account for added `&`/`&mut` for some params\n+fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode) -> SyntaxNode {\n+    let mut rewriter = SyntaxRewriter::default();\n+    for param in params {\n+        if !param.kind().is_ref() {\n+            continue;\n+        }\n+\n+        let usages = LocalUsages::find(ctx, param.var);\n+        let usages = usages\n+            .iter()\n+            .filter(|reference| syntax.text_range().contains_range(reference.range))\n+            .filter_map(|reference| path_element_of_reference(syntax, reference));\n+        for path in usages {\n+            match path.syntax().ancestors().skip(1).find_map(ast::Expr::cast) {\n+                Some(ast::Expr::MethodCallExpr(_)) | Some(ast::Expr::FieldExpr(_)) => {\n+                    // do nothing\n+                }\n+                Some(ast::Expr::RefExpr(node))\n+                    if param.kind() == ParamKind::MutRef && node.mut_token().is_some() =>\n+                {\n+                    rewriter.replace_ast(&node.clone().into(), &node.expr().unwrap());\n+                }\n+                Some(ast::Expr::RefExpr(node))\n+                    if param.kind() == ParamKind::SharedRef && node.mut_token().is_none() =>\n+                {\n+                    rewriter.replace_ast(&node.clone().into(), &node.expr().unwrap());\n+                }\n+                Some(_) | None => {\n+                    rewriter.replace_ast(&path, &ast::make::expr_prefix(T![*], path.clone()));\n+                }\n+            };\n+        }\n+    }\n+\n+    rewriter.rewrite(syntax)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn no_args_from_binary_expr() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    foo($01 + 1$0);\n+}\"#,\n+            r#\"\n+fn foo() {\n+    foo(fun_name());\n+}\n+\n+fn $0fun_name() -> i32 {\n+    1 + 1\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_from_binary_expr_in_module() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+mod bar {\n+    fn foo() {\n+        foo($01 + 1$0);\n+    }\n+}\"#,\n+            r#\"\n+mod bar {\n+    fn foo() {\n+        foo(fun_name());\n+    }\n+\n+    fn $0fun_name() -> i32 {\n+        1 + 1\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_from_binary_expr_indented() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    $0{ 1 + 1 }$0;\n+}\"#,\n+            r#\"\n+fn foo() {\n+    fun_name();\n+}\n+\n+fn $0fun_name() -> i32 {\n+    { 1 + 1 }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_from_stmt_with_last_expr() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() -> i32 {\n+    let k = 1;\n+    $0let m = 1;\n+    m + 1$0\n+}\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    let k = 1;\n+    fun_name()\n+}\n+\n+fn $0fun_name() -> i32 {\n+    let m = 1;\n+    m + 1\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_from_stmt_unit() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    let k = 3;\n+    $0let m = 1;\n+    let n = m + 1;$0\n+    let g = 5;\n+}\"#,\n+            r#\"\n+fn foo() {\n+    let k = 3;\n+    fun_name();\n+    let g = 5;\n+}\n+\n+fn $0fun_name() {\n+    let m = 1;\n+    let n = m + 1;\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_if() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    $0if true { }$0\n+}\"#,\n+            r#\"\n+fn foo() {\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    if true { }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_if_else() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() -> i32 {\n+    $0if true { 1 } else { 2 }$0\n+}\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    fun_name()\n+}\n+\n+fn $0fun_name() -> i32 {\n+    if true { 1 } else { 2 }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_if_let_else() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() -> i32 {\n+    $0if let true = false { 1 } else { 2 }$0\n+}\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    fun_name()\n+}\n+\n+fn $0fun_name() -> i32 {\n+    if let true = false { 1 } else { 2 }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_match() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() -> i32 {\n+    $0match true {\n+        true => 1,\n+        false => 2,\n+    }$0\n+}\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    fun_name()\n+}\n+\n+fn $0fun_name() -> i32 {\n+    match true {\n+        true => 1,\n+        false => 2,\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_while() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    $0while true { }$0\n+}\"#,\n+            r#\"\n+fn foo() {\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    while true { }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_for() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    $0for v in &[0, 1] { }$0\n+}\"#,\n+            r#\"\n+fn foo() {\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    for v in &[0, 1] { }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_from_loop_unit() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    $0loop {\n+        let m = 1;\n+    }$0\n+}\"#,\n+            r#\"\n+fn foo() {\n+    fun_name()\n+}\n+\n+fn $0fun_name() -> ! {\n+    loop {\n+        let m = 1;\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_from_loop_with_return() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    let v = $0loop {\n+        let m = 1;\n+        break m;\n+    }$0;\n+}\"#,\n+            r#\"\n+fn foo() {\n+    let v = fun_name();\n+}\n+\n+fn $0fun_name() -> i32 {\n+    loop {\n+        let m = 1;\n+        break m;\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_args_from_match() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    let v: i32 = $0match Some(1) {\n+        Some(x) => x,\n+        None => 0,\n+    }$0;\n+}\"#,\n+            r#\"\n+fn foo() {\n+    let v: i32 = fun_name();\n+}\n+\n+fn $0fun_name() -> i32 {\n+    match Some(1) {\n+        Some(x) => x,\n+        None => 0,\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn argument_form_expr() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    $0n+2$0\n+}\",\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    fun_name(n)\n+}\n+\n+fn $0fun_name(n: u32) -> u32 {\n+    n+2\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn argument_used_twice_form_expr() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    $0n+n$0\n+}\",\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    fun_name(n)\n+}\n+\n+fn $0fun_name(n: u32) -> u32 {\n+    n+n\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn two_arguments_form_expr() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    let m = 3;\n+    $0n+n*m$0\n+}\",\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    let m = 3;\n+    fun_name(n, m)\n+}\n+\n+fn $0fun_name(n: u32, m: u32) -> u32 {\n+    n+n*m\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn argument_and_locals() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    $0let m = 1;\n+    n + m$0\n+}\",\n+            r\"\n+fn foo() -> u32 {\n+    let n = 2;\n+    fun_name(n)\n+}\n+\n+fn $0fun_name(n: u32) -> u32 {\n+    let m = 1;\n+    n + m\n+}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn in_comment_is_not_applicable() {\n+        mark::check!(extract_function_in_comment_is_not_applicable);\n+        check_assist_not_applicable(extract_function, r\"fn main() { 1 + /* $0comment$0 */ 1; }\");\n+    }\n+\n+    #[test]\n+    fn part_of_expr_stmt() {\n+        check_assist(\n+            extract_function,\n+            \"\n+fn foo() {\n+    $01$0 + 1;\n+}\",\n+            \"\n+fn foo() {\n+    fun_name() + 1;\n+}\n+\n+fn $0fun_name() -> i32 {\n+    1\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn function_expr() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    $0bar(1 + 1)$0\n+}\"#,\n+            r#\"\n+fn foo() {\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    bar(1 + 1)\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_from_nested() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        true => ($02 + 2$0, true)\n+        _ => (0, false)\n+    };\n+}\",\n+            r\"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        true => (fun_name(), true)\n+        _ => (0, false)\n+    };\n+}\n+\n+fn $0fun_name() -> i32 {\n+    2 + 2\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn param_from_closure() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn main() {\n+    let lambda = |x: u32| $0x * 2$0;\n+}\",\n+            r\"\n+fn main() {\n+    let lambda = |x: u32| fun_name(x);\n+}\n+\n+fn $0fun_name(x: u32) -> u32 {\n+    x * 2\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_return_stmt() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() -> u32 {\n+    $0return 2 + 2$0;\n+}\",\n+            r\"\n+fn foo() -> u32 {\n+    return fun_name();\n+}\n+\n+fn $0fun_name() -> u32 {\n+    2 + 2\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_add_extra_whitespace() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() -> u32 {\n+\n+\n+    $0return 2 + 2$0;\n+}\",\n+            r\"\n+fn foo() -> u32 {\n+\n+\n+    return fun_name();\n+}\n+\n+fn $0fun_name() -> u32 {\n+    2 + 2\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn break_stmt() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn main() {\n+    let result = loop {\n+        $0break 2 + 2$0;\n+    };\n+}\",\n+            r\"\n+fn main() {\n+    let result = loop {\n+        break fun_name();\n+    };\n+}\n+\n+fn $0fun_name() -> i32 {\n+    2 + 2\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_cast() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn main() {\n+    let v = $00f32 as u32$0;\n+}\",\n+            r\"\n+fn main() {\n+    let v = fun_name();\n+}\n+\n+fn $0fun_name() -> u32 {\n+    0f32 as u32\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn return_not_applicable() {\n+        check_assist_not_applicable(extract_function, r\"fn foo() { $0return$0; } \");\n+    }\n+\n+    #[test]\n+    fn method_to_freestanding() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct S;\n+\n+impl S {\n+    fn foo(&self) -> i32 {\n+        $01+1$0\n+    }\n+}\",\n+            r\"\n+struct S;\n+\n+impl S {\n+    fn foo(&self) -> i32 {\n+        fun_name()\n+    }\n+}\n+\n+fn $0fun_name() -> i32 {\n+    1+1\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn method_with_reference() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct S { f: i32 };\n+\n+impl S {\n+    fn foo(&self) -> i32 {\n+        $01+self.f$0\n+    }\n+}\",\n+            r\"\n+struct S { f: i32 };\n+\n+impl S {\n+    fn foo(&self) -> i32 {\n+        self.fun_name()\n+    }\n+\n+    fn $0fun_name(&self) -> i32 {\n+        1+self.f\n+    }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn method_with_mut() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct S { f: i32 };\n+\n+impl S {\n+    fn foo(&mut self) {\n+        $0self.f += 1;$0\n+    }\n+}\",\n+            r\"\n+struct S { f: i32 };\n+\n+impl S {\n+    fn foo(&mut self) {\n+        self.fun_name();\n+    }\n+\n+    fn $0fun_name(&mut self) {\n+        self.f += 1;\n+    }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn variable_defined_inside_and_used_after_no_ret() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    $0let k = n * n;$0\n+    let m = k + 1;\n+}\",\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    let k = fun_name(n);\n+    let m = k + 1;\n+}\n+\n+fn $0fun_name(n: i32) -> i32 {\n+    let k = n * n;\n+    k\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn two_variables_defined_inside_and_used_after_no_ret() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    $0let k = n * n;\n+    let m = k + 2;$0\n+    let h = k + m;\n+}\",\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    let (k, m) = fun_name(n);\n+    let h = k + m;\n+}\n+\n+fn $0fun_name(n: i32) -> (i32, i32) {\n+    let k = n * n;\n+    let m = k + 2;\n+    (k, m)\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn nontrivial_patterns_define_variables() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct Counter(i32);\n+fn foo() {\n+    $0let Counter(n) = Counter(0);$0\n+    let m = n;\n+}\",\n+            r\"\n+struct Counter(i32);\n+fn foo() {\n+    let n = fun_name();\n+    let m = n;\n+}\n+\n+fn $0fun_name() -> i32 {\n+    let Counter(n) = Counter(0);\n+    n\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_with_two_fields_pattern_define_variables() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct Counter { n: i32, m: i32 };\n+fn foo() {\n+    $0let Counter { n, m: k } = Counter { n: 1, m: 2 };$0\n+    let h = n + k;\n+}\",\n+            r\"\n+struct Counter { n: i32, m: i32 };\n+fn foo() {\n+    let (n, k) = fun_name();\n+    let h = n + k;\n+}\n+\n+fn $0fun_name() -> (i32, i32) {\n+    let Counter { n, m: k } = Counter { n: 1, m: 2 };\n+    (n, k)\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_var_from_outer_scope() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    $0n += 1;$0\n+    let m = n + 1;\n+}\",\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(&mut n);\n+    let m = n + 1;\n+}\n+\n+fn $0fun_name(n: &mut i32) {\n+    *n += 1;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_field_from_outer_scope() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct C { n: i32 }\n+fn foo() {\n+    let mut c = C { n: 0 };\n+    $0c.n += 1;$0\n+    let m = c.n + 1;\n+}\",\n+            r\"\n+struct C { n: i32 }\n+fn foo() {\n+    let mut c = C { n: 0 };\n+    fun_name(&mut c);\n+    let m = c.n + 1;\n+}\n+\n+fn $0fun_name(c: &mut C) {\n+    c.n += 1;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_nested_field_from_outer_scope() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct P { n: i32}\n+struct C { p: P }\n+fn foo() {\n+    let mut c = C { p: P { n: 0 } };\n+    let mut v = C { p: P { n: 0 } };\n+    let u = C { p: P { n: 0 } };\n+    $0c.p.n += u.p.n;\n+    let r = &mut v.p.n;$0\n+    let m = c.p.n + v.p.n + u.p.n;\n+}\",\n+            r\"\n+struct P { n: i32}\n+struct C { p: P }\n+fn foo() {\n+    let mut c = C { p: P { n: 0 } };\n+    let mut v = C { p: P { n: 0 } };\n+    let u = C { p: P { n: 0 } };\n+    fun_name(&mut c, &u, &mut v);\n+    let m = c.p.n + v.p.n + u.p.n;\n+}\n+\n+fn $0fun_name(c: &mut C, u: &C, v: &mut C) {\n+    c.p.n += u.p.n;\n+    let r = &mut v.p.n;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_param_many_usages_stmt() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn bar(k: i32) {}\n+trait I: Copy {\n+    fn succ(&self) -> Self;\n+    fn inc(&mut self) -> Self { let v = self.succ(); *self = v; v }\n+}\n+impl I for i32 {\n+    fn succ(&self) -> Self { *self + 1 }\n+}\n+fn foo() {\n+    let mut n = 1;\n+    $0n += n;\n+    bar(n);\n+    bar(n+1);\n+    bar(n*n);\n+    bar(&n);\n+    n.inc();\n+    let v = &mut n;\n+    *v = v.succ();\n+    n.succ();$0\n+    let m = n + 1;\n+}\",\n+            r\"\n+fn bar(k: i32) {}\n+trait I: Copy {\n+    fn succ(&self) -> Self;\n+    fn inc(&mut self) -> Self { let v = self.succ(); *self = v; v }\n+}\n+impl I for i32 {\n+    fn succ(&self) -> Self { *self + 1 }\n+}\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(&mut n);\n+    let m = n + 1;\n+}\n+\n+fn $0fun_name(n: &mut i32) {\n+    *n += *n;\n+    bar(*n);\n+    bar(*n+1);\n+    bar(*n**n);\n+    bar(&*n);\n+    n.inc();\n+    let v = n;\n+    *v = v.succ();\n+    n.succ();\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_param_many_usages_expr() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn bar(k: i32) {}\n+trait I: Copy {\n+    fn succ(&self) -> Self;\n+    fn inc(&mut self) -> Self { let v = self.succ(); *self = v; v }\n+}\n+impl I for i32 {\n+    fn succ(&self) -> Self { *self + 1 }\n+}\n+fn foo() {\n+    let mut n = 1;\n+    $0{\n+        n += n;\n+        bar(n);\n+        bar(n+1);\n+        bar(n*n);\n+        bar(&n);\n+        n.inc();\n+        let v = &mut n;\n+        *v = v.succ();\n+        n.succ();\n+    }$0\n+    let m = n + 1;\n+}\",\n+            r\"\n+fn bar(k: i32) {}\n+trait I: Copy {\n+    fn succ(&self) -> Self;\n+    fn inc(&mut self) -> Self { let v = self.succ(); *self = v; v }\n+}\n+impl I for i32 {\n+    fn succ(&self) -> Self { *self + 1 }\n+}\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(&mut n);\n+    let m = n + 1;\n+}\n+\n+fn $0fun_name(n: &mut i32) {\n+    {\n+        *n += *n;\n+        bar(*n);\n+        bar(*n+1);\n+        bar(*n**n);\n+        bar(&*n);\n+        n.inc();\n+        let v = n;\n+        *v = v.succ();\n+        n.succ();\n+    }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_param_by_value() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    $0n += 1;$0\n+}\",\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(n);\n+}\n+\n+fn $0fun_name(mut n: i32) {\n+    n += 1;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_param_because_of_mut_ref() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    $0let v = &mut n;\n+    *v += 1;$0\n+    let k = n;\n+}\",\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(&mut n);\n+    let k = n;\n+}\n+\n+fn $0fun_name(n: &mut i32) {\n+    let v = n;\n+    *v += 1;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_param_by_value_because_of_mut_ref() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    $0let v = &mut n;\n+    *v += 1;$0\n+}\",\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(n);\n+}\n+\n+fn $0fun_name(mut n: i32) {\n+    let v = &mut n;\n+    *v += 1;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_method_call() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+trait I {\n+    fn inc(&mut self);\n+}\n+impl I for i32 {\n+    fn inc(&mut self) { *self += 1 }\n+}\n+fn foo() {\n+    let mut n = 1;\n+    $0n.inc();$0\n+}\",\n+            r\"\n+trait I {\n+    fn inc(&mut self);\n+}\n+impl I for i32 {\n+    fn inc(&mut self) { *self += 1 }\n+}\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(n);\n+}\n+\n+fn $0fun_name(mut n: i32) {\n+    n.inc();\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn shared_method_call() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+trait I {\n+    fn succ(&self);\n+}\n+impl I for i32 {\n+    fn succ(&self) { *self + 1 }\n+}\n+fn foo() {\n+    let mut n = 1;\n+    $0n.succ();$0\n+}\",\n+            r\"\n+trait I {\n+    fn succ(&self);\n+}\n+impl I for i32 {\n+    fn succ(&self) { *self + 1 }\n+}\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(n);\n+}\n+\n+fn $0fun_name(n: i32) {\n+    n.succ();\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_method_call_with_other_receiver() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+trait I {\n+    fn inc(&mut self, n: i32);\n+}\n+impl I for i32 {\n+    fn inc(&mut self, n: i32) { *self += n }\n+}\n+fn foo() {\n+    let mut n = 1;\n+    $0let mut m = 2;\n+    m.inc(n);$0\n+}\",\n+            r\"\n+trait I {\n+    fn inc(&mut self, n: i32);\n+}\n+impl I for i32 {\n+    fn inc(&mut self, n: i32) { *self += n }\n+}\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(n);\n+}\n+\n+fn $0fun_name(n: i32) {\n+    let mut m = 2;\n+    m.inc(n);\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn non_copy_without_usages_after() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct Counter(i32);\n+fn foo() {\n+    let c = Counter(0);\n+    $0let n = c.0;$0\n+}\",\n+            r\"\n+struct Counter(i32);\n+fn foo() {\n+    let c = Counter(0);\n+    fun_name(c);\n+}\n+\n+fn $0fun_name(c: Counter) {\n+    let n = c.0;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn non_copy_used_after() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct Counter(i32);\n+fn foo() {\n+    let c = Counter(0);\n+    $0let n = c.0;$0\n+    let m = c.0;\n+}\",\n+            r\"\n+struct Counter(i32);\n+fn foo() {\n+    let c = Counter(0);\n+    fun_name(&c);\n+    let m = c.0;\n+}\n+\n+fn $0fun_name(c: &Counter) {\n+    let n = c.0;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn indented_stmts() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    if true {\n+        loop {\n+            $0let n = 1;\n+            let m = 2;$0\n+        }\n+    }\n+}\",\n+            r\"\n+fn foo() {\n+    if true {\n+        loop {\n+            fun_name();\n+        }\n+    }\n+}\n+\n+fn $0fun_name() {\n+    let n = 1;\n+    let m = 2;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn indented_stmts_inside_mod() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+mod bar {\n+    fn foo() {\n+        if true {\n+            loop {\n+                $0let n = 1;\n+                let m = 2;$0\n+            }\n+        }\n+    }\n+}\",\n+            r\"\n+mod bar {\n+    fn foo() {\n+        if true {\n+            loop {\n+                fun_name();\n+            }\n+        }\n+    }\n+\n+    fn $0fun_name() {\n+        let n = 1;\n+        let m = 2;\n+    }\n+}\",\n+        );\n+    }\n+}"}, {"sha": "062a902ab0f6453bce30784e845c481831e8cfe6", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac5958485e5e77b020b3ebe0c100df5a5fe6ca08/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5958485e5e77b020b3ebe0c100df5a5fe6ca08/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=ac5958485e5e77b020b3ebe0c100df5a5fe6ca08", "patch": "@@ -117,6 +117,7 @@ mod handlers {\n     mod convert_integer_literal;\n     mod early_return;\n     mod expand_glob_import;\n+    mod extract_function;\n     mod extract_struct_from_enum_variant;\n     mod extract_variable;\n     mod fill_match_arms;\n@@ -174,6 +175,7 @@ mod handlers {\n             early_return::convert_to_guarded_return,\n             expand_glob_import::expand_glob_import,\n             move_module_to_file::move_module_to_file,\n+            extract_function::extract_function,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,\n             extract_variable::extract_variable,\n             fill_match_arms::fill_match_arms,"}, {"sha": "e84f208a3844c4a5702762f359391f1c1d18fd4e", "filename": "crates/assists/src/tests/generated.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac5958485e5e77b020b3ebe0c100df5a5fe6ca08/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5958485e5e77b020b3ebe0c100df5a5fe6ca08/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=ac5958485e5e77b020b3ebe0c100df5a5fe6ca08", "patch": "@@ -256,6 +256,33 @@ fn qux(bar: Bar, baz: Baz) {}\n     )\n }\n \n+#[test]\n+fn doctest_extract_function() {\n+    check_doc_test(\n+        \"extract_function\",\n+        r#####\"\n+fn main() {\n+    let n = 1;\n+    $0let m = n + 2;\n+    let k = m + n;$0\n+    let g = 3;\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    let n = 1;\n+    fun_name(n);\n+    let g = 3;\n+}\n+\n+fn $0fun_name(n: i32) {\n+    let m = n + 2;\n+    let k = m + n;\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_extract_struct_from_enum_variant() {\n     check_doc_test("}, {"sha": "1da5a125ed376cdbb4df813fff3176b70f70a7b0", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac5958485e5e77b020b3ebe0c100df5a5fe6ca08/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5958485e5e77b020b3ebe0c100df5a5fe6ca08/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=ac5958485e5e77b020b3ebe0c100df5a5fe6ca08", "patch": "@@ -487,7 +487,7 @@ pub mod tokens {\n     use crate::{ast, AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken};\n \n     pub(super) static SOURCE_FILE: Lazy<Parse<SourceFile>> =\n-        Lazy::new(|| SourceFile::parse(\"const C: <()>::Item = (1 != 1, 2 == 2, !true)\\n;\\n\\n\"));\n+        Lazy::new(|| SourceFile::parse(\"const C: <()>::Item = (1 != 1, 2 == 2, !true, *p)\\n;\\n\\n\"));\n \n     pub fn single_space() -> SyntaxToken {\n         SOURCE_FILE"}]}