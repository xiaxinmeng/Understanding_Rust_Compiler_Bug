{"sha": "1fd4c3bb400b85a87cb415b4c0c9b3c573b66fd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmZDRjM2JiNDAwYjg1YTg3Y2I0MTViNGMwYzliM2M1NzNiNjZmZDU=", "commit": {"author": {"name": "Clinton Ryan", "email": "clint.ryan3@gmail.com", "date": "2014-01-08T02:15:14Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-01-08T05:30:17Z"}, "message": "Fixed code snippets", "tree": {"sha": "8134bb5f880cdaebe6f5842788788e46826d4810", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8134bb5f880cdaebe6f5842788788e46826d4810"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fd4c3bb400b85a87cb415b4c0c9b3c573b66fd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fd4c3bb400b85a87cb415b4c0c9b3c573b66fd5", "html_url": "https://github.com/rust-lang/rust/commit/1fd4c3bb400b85a87cb415b4c0c9b3c573b66fd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fd4c3bb400b85a87cb415b4c0c9b3c573b66fd5/comments", "author": null, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cfce50b24cecaa04fae94cbc06ef97a0a9f3958", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cfce50b24cecaa04fae94cbc06ef97a0a9f3958", "html_url": "https://github.com/rust-lang/rust/commit/7cfce50b24cecaa04fae94cbc06ef97a0a9f3958"}], "stats": {"total": 30, "additions": 15, "deletions": 15}, "files": [{"sha": "57a0b773d433ac3434dfd70dc74920e5e672ca27", "filename": "doc/guide-pointers.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1fd4c3bb400b85a87cb415b4c0c9b3c573b66fd5/doc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/1fd4c3bb400b85a87cb415b4c0c9b3c573b66fd5/doc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-pointers.md?ref=1fd4c3bb400b85a87cb415b4c0c9b3c573b66fd5", "patch": "@@ -21,7 +21,7 @@ fn succ(x: &int) -> int { *x + 1 }\n \n So I wrote this code to try it out:\n \n-~~~rust {.xfail-test}\n+~~~rust{.xfail-test}\n fn main() {\n     let number = 5;\n     let succ_number = succ(number);\n@@ -73,7 +73,7 @@ However.\n Here are the use-cases for pointers. I've prefixed them with the name of the\n pointer that satisfies that use-case:\n \n-1. Owned: ~Trait must be a pointer, becuase you don't know the size of the\n+1. Owned: ~Trait must be a pointer, because you don't know the size of the\n object, so indirection is mandatory.\n 2. Owned: You need a recursive data structure. These can be infinite sized, so\n indirection is mandatory.\n@@ -85,18 +85,18 @@ common, such as C++, please read \"A note...\" below.\n or impossible. This is only often useful when a program is very large or very\n complicated. Using a managed pointer will activate Rust's garbage collection\n mechanism.\n-5: Reference: You're writing a function, and you need a pointer, but you don't\n+5. Reference: You're writing a function, and you need a pointer, but you don't\n care about its ownership. If you make the argument a reference, callers\n can send in whatever kind they want.\n \n-Five exceptions. That's it. Otherwise, you shouldn't need them. Be skeptical\n+Five exceptions. That's it. Otherwise, you shouldn't need them. Be sceptical\n of pointers in Rust: use them for a deliberate purpose, not just to make the\n compiler happy.\n \n ## A note for those proficient in pointers\n \n If you're coming to Rust from a language like C or C++, you may be used to\n-passing things by reference, or passing things by pointer. In some langauges,\n+passing things by reference, or passing things by pointer. In some languages,\n like Java, you can't even have objects without a pointer to them. Therefore, if\n you were writing this Rust code:\n \n@@ -150,7 +150,7 @@ fn main() {\n }\n ~~~\n \n-But won't this be inefficent? Well, that's a complicated question, but it's\n+But won't this be inefficient? Well, that's a complicated question, but it's\n important to know that Rust, like C and C++, store aggregate data types\n 'unboxed,' whereas languages like Java and Ruby store these types as 'boxed.'\n For smaller structs, this way will be more efficient. For larger ones, it may\n@@ -173,7 +173,7 @@ These two properties make for three use cases.\n \n ## References to Traits\n \n-Traits must be referenced through a pointer, becuase the struct that implements\n+Traits must be referenced through a pointer, because the struct that implements\n the trait may be a different size than a different struct that implements the\n trait. Therefore, unboxed traits don't make any sense, and aren't allowed.\n \n@@ -199,7 +199,7 @@ This prints:\n Cons(1, ~Cons(2, ~Cons(3, ~Nil)))\n ~~~\n \n-The inner lists _must_ be an owned pointer, becuase we can't know how many\n+The inner lists _must_ be an owned pointer, because we can't know how many\n elements are in the list. Without knowing the length, we don't know the size,\n and therefore require the indirection that pointers offer.\n \n@@ -261,7 +261,7 @@ program is very large and complicated.\n \n For example, let's say you're using an owned pointer, and you want to do this:\n \n-~~~rust {.xfail-test}\n+~~~rust{.xfail-test}\n struct Point {\n     x: int,\n     y: int,\n@@ -315,7 +315,7 @@ managed pointers:\n 1. They activate Rust's garbage collector. Other pointer types don't share this\n drawback.\n 2. You cannot pass this data to another task. Shared ownership across\n-concurrency boundaries is the source of endless pain in other langauges, so\n+concurrency boundaries is the source of endless pain in other languages, so\n Rust does not let you do this.\n \n # References\n@@ -355,7 +355,7 @@ takes in two references, but we give it a managed and unique pointer. Of\n course, if this were a real program, we wouldn't have any of these pointers,\n they're just there to demonstrate the concepts.\n \n-So how is this hard? Well, because we're igorning ownership, the compiler needs\n+So how is this hard? Well, because we're ignoring ownership, the compiler needs\n to take great care to make sure that everything is safe. Despite their complete\n safety, a reference's representation at runtime is the same as that of\n an ordinary pointer in a C program. They introduce zero overhead. The compiler\n@@ -365,14 +365,14 @@ This theory is called 'region pointers,' and involve a concept called\n 'lifetimes'. Here's the simple explanation: would you expect this code to\n compile?\n \n-~~~rust {.xfail-test}\n+~~~rust{.xfail-test}\n fn main() {\n     println(x.to_str());\n     let x = 5;\n }\n ~~~\n \n-Probably not. That's becuase you know that the name `x` is valid from where\n+Probably not. That's because you know that the name `x` is valid from where\n it's declared to when it goes out of scope. In this case, that's the end of\n the `main` function. So you know this code will cause an error. We call this\n duration a 'lifetime'. Let's try a more complex example:\n@@ -394,7 +394,7 @@ Here, we're borrowing a pointer to `x` inside of the `if`. The compiler, however\n is able to determine that that pointer will go out of scope without `x` being\n mutated, and therefore, lets us pass. This wouldn't work:\n \n-~~~rust {.xfail-test}\n+~~~rust{.xfail-test}\n fn main() {\n     let mut x = ~5;\n     if *x < 10 {\n@@ -427,7 +427,7 @@ great detail, so if you want the full details, check that out.\n \n # Returning Pointers\n \n-We've talked a lot about funtions that accept various kinds of pointers, but\n+We've talked a lot about functions that accept various kinds of pointers, but\n what about returning them? Here's the rule of thumb: only return a unique or\n managed pointer if you were given one in the first place.\n "}]}