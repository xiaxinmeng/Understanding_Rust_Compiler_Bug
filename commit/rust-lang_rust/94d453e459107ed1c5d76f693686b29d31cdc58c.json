{"sha": "94d453e459107ed1c5d76f693686b29d31cdc58c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ZDQ1M2U0NTkxMDdlZDFjNWQ3NmY2OTM2ODZiMjlkMzFjZGM1OGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-13T23:17:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-13T23:17:21Z"}, "message": "auto merge of #12248 : alexcrichton/rust/rollup, r=alexcrichton\n\nThis passed `make check` locally, so hopefully it passes on bors!", "tree": {"sha": "b586a7c785fa57253b3ba1bcaaee5ae1ea167411", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b586a7c785fa57253b3ba1bcaaee5ae1ea167411"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94d453e459107ed1c5d76f693686b29d31cdc58c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94d453e459107ed1c5d76f693686b29d31cdc58c", "html_url": "https://github.com/rust-lang/rust/commit/94d453e459107ed1c5d76f693686b29d31cdc58c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94d453e459107ed1c5d76f693686b29d31cdc58c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfb87f10ec7d41d0e7f8c68fbb908fc195517d41", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfb87f10ec7d41d0e7f8c68fbb908fc195517d41", "html_url": "https://github.com/rust-lang/rust/commit/cfb87f10ec7d41d0e7f8c68fbb908fc195517d41"}, {"sha": "640b22852f59e4505cedfd02c01cc343d5ec0d9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/640b22852f59e4505cedfd02c01cc343d5ec0d9e", "html_url": "https://github.com/rust-lang/rust/commit/640b22852f59e4505cedfd02c01cc343d5ec0d9e"}], "stats": {"total": 1049, "additions": 651, "deletions": 398}, "files": [{"sha": "ef1701a61e80b8502c5b99f24db8c8507166ef7e", "filename": "Makefile.in", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -125,10 +125,7 @@ ifdef TRACE\n   CFG_RUSTC_FLAGS += -Z trace\n endif\n ifdef CFG_DISABLE_RPATH\n-# NOTE: make this CFG_RUSTC_FLAGS after stage0 snapshot\n-RUSTFLAGS_STAGE1 += -C no-rpath\n-RUSTFLAGS_STAGE2 += -C no-rpath\n-RUSTFLAGS_STAGE3 += -C no-rpath\n+CFG_RUSTC_FLAGS += -C no-rpath\n endif\n \n # The executables crated during this compilation process have no need to include\n@@ -140,8 +137,7 @@ endif\n # snapshot will be generated with a statically linked rustc so we only have to\n # worry about the distribution of one file (with its native dynamic\n # dependencies)\n-#\n-# NOTE: after a snapshot (stage0), put this on stage0 as well\n+RUSTFLAGS_STAGE0 += -C prefer-dynamic\n RUSTFLAGS_STAGE1 += -C prefer-dynamic\n \n # platform-specific auto-configuration"}, {"sha": "aea263c9619874971ddfd10de1b431d53caadeff", "filename": "mk/dist.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -12,7 +12,7 @@ PKG_ICO = $(S)src/etc/pkg/rust-logo.ico\n PKG_EXE = $(PKG_DIR)-install.exe\n endif\n \n-PKG_GITMODULES := $(S)src/libuv $(S)src/llvm $(S)src/gyp\n+PKG_GITMODULES := $(S)src/libuv $(S)src/llvm $(S)src/gyp $(S)src/compiler-rt\n \n PKG_FILES := \\\n     $(S)COPYRIGHT                              \\"}, {"sha": "a8ad51409d9161036e0cfad26633ece020daa8f2", "filename": "mk/tests.mk", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -333,21 +333,22 @@ $(foreach host,$(CFG_HOST), \\\n \n define TEST_RUNNER\n \n-# If NO_REBUILD is set then break the dependencies on extra so we can\n-# test crates without rebuilding std and extra first\n+# If NO_REBUILD is set then break the dependencies on everything but\n+# the source files so we can test crates without rebuilding any of the\n+# parent crates.\n ifeq ($(NO_REBUILD),)\n-STDTESTDEP_$(1)_$(2)_$(3)_$(4) = $$(SREQ$(1)_T_$(2)_H_$(3)) \\\n+TESTDEP_$(1)_$(2)_$(3)_$(4) = $$(SREQ$(1)_T_$(2)_H_$(3)) \\\n \t\t\t    $$(foreach crate,$$(TARGET_CRATES),\\\n-\t\t\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(crate))\n+\t\t\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(crate)) \\\n+\t\t\t\t$$(CRATE_FULLDEPS_$(1)_T_$(2)_H_$(3)_$(4))\n else\n-STDTESTDEP_$(1)_$(2)_$(3)_$(4) =\n+TESTDEP_$(1)_$(2)_$(3)_$(4) = $$(RSINPUTS_$(4))\n endif\n \n $(3)/stage$(1)/test/$(4)test-$(2)$$(X_$(2)): CFG_COMPILER = $(2)\n $(3)/stage$(1)/test/$(4)test-$(2)$$(X_$(2)):\t\t\t\t\\\n-\t\t$$(CRATEFILE_$(4))\t\t\t\t\t\\\n-\t\t$$(CRATE_FULLDEPS_$(1)_T_$(2)_H_$(3)_$(4))\t\t\\\n-\t\t$$(STDTESTDEP_$(1)_$(2)_$(3)_$(4))\n+\t\t$$(CRATEFILE_$(4)) \\\n+\t\t$$(TESTDEP_$(1)_$(2)_$(3)_$(4))\n \t@$$(call E, oxidize: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\t\\\n \t\t-L \"$$(RT_OUTPUT_DIR_$(2))\"\t\t\\\n@@ -684,13 +685,22 @@ $(foreach host,$(CFG_HOST), \\\n \n define DEF_CRATE_DOC_TEST\n \n+# If NO_REBUILD is set then break the dependencies on everything but\n+# the source files so we can test crate documentation without\n+# rebuilding any of the parent crates.\n+ifeq ($(NO_REBUILD),)\n+DOCTESTDEP_$(1)_$(2)_$(3)_$(4) = \\\n+\t$$(TEST_SREQ$(1)_T_$(2)_H_$(3))\t\t\t\t\\\n+\t$$(CRATE_FULLDEPS_$(1)_T_$(2)_H_$(3)_$(4))\t\t\\\n+\t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3))\n+else\n+DOCTESTDEP_$(1)_$(2)_$(3)_$(4) = $$(RSINPUTS_$(4))\n+endif\n+\n check-stage$(1)-T-$(2)-H-$(3)-doc-$(4)-exec: $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-$(4))\n \n ifeq ($(2),$$(CFG_BUILD))\n-$$(call TEST_OK_FILE,$(1),$(2),$(3),doc-$(4)):\t\t\t\t\\\n-\t        $$(TEST_SREQ$(1)_T_$(2)_H_$(3))\t\t\t\t\\\n-\t\t$$(CRATE_FULLDEPS_$(1)_T_$(2)_H_$(3)_$(4))\t\t\\\n-\t\t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3))\n+$$(call TEST_OK_FILE,$(1),$(2),$(3),doc-$(4)): $$(DOCTESTDEP_$(1)_$(2)_$(3)_$(4))\n \t@$$(call E, run doc-$(4) [$(2)])\n \t$$(Q)$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) --test \\\n \t    $$(CRATEFILE_$(4)) --test-args \"$$(TESTARGS)\" && touch $$@"}, {"sha": "053a8612694ab399aff710291f4f3af61e05d1f7", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -195,7 +195,7 @@ impl<T: Send> Unique<T> {\n     pub fn new(value: T) -> Unique<T> {\n         unsafe {\n             let ptr = malloc(std::mem::size_of::<T>() as size_t) as *mut T;\n-            assert!(!ptr::is_null(ptr));\n+            assert!(!ptr.is_null());\n             // `*ptr` is uninitialized, and `*ptr = value` would attempt to destroy it\n             // move_val_init moves a value into this memory without\n             // attempting to drop the original value."}, {"sha": "fe0fd8bd84d5c4f916ba6806a64a26bffd535291", "filename": "src/doc/rust.md", "status": "modified", "additions": 74, "deletions": 10, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -1725,31 +1725,95 @@ mod bar {\n pub type int8_t = i8;\n ~~~~\n \n-> **Note:** In future versions of Rust, user-provided extensions to the compiler will be able to interpret attributes.\n-> When this facility is provided, the compiler will distinguish between language-reserved and user-available attributes.\n+> **Note:** In future versions of Rust, user-provided extensions to the compiler\n+> will be able to interpret attributes.  When this facility is provided, the\n+> compiler will distinguish between language-reserved and user-available\n+> attributes.\n \n-At present, only the Rust compiler interprets attributes, so all attribute\n-names are effectively reserved. Some significant attributes include:\n+At present, only the Rust compiler interprets attributes, so all attribute names\n+are effectively reserved. Some significant attributes include:\n \n * The `doc` attribute, for documenting code in-place.\n-* The `cfg` attribute, for conditional-compilation by build-configuration.\n+* The `cfg` attribute, for conditional-compilation by build-configuration (see\n+  [Conditional compilation](#conditional-compilation)).\n * The `crate_id` attribute, for describing the package ID of a crate.\n * The `lang` attribute, for custom definitions of traits and functions that are\n   known to the Rust compiler (see [Language items](#language-items)).\n * The `link` attribute, for describing linkage metadata for a extern blocks.\n * The `test` attribute, for marking functions as unit tests.\n * The `allow`, `warn`, `forbid`, and `deny` attributes, for\n   controlling lint checks (see [Lint check attributes](#lint-check-attributes)).\n-* The `deriving` attribute, for automatically generating\n-  implementations of certain traits.\n+* The `deriving` attribute, for automatically generating implementations of\n+  certain traits.\n * The `inline` attribute, for expanding functions at caller location (see\n   [Inline attributes](#inline-attributes)).\n-* The `static_assert` attribute, for asserting that a static bool is true at compiletime\n-* The `thread_local` attribute, for defining a `static mut` as a thread-local. Note that this is\n-  only a low-level building block, and is not local to a *task*, nor does it provide safety.\n+* The `static_assert` attribute, for asserting that a static bool is true at\n+  compiletime.\n+* The `thread_local` attribute, for defining a `static mut` as a thread-local.\n+  Note that this is only a low-level building block, and is not local to a\n+  *task*, nor does it provide safety.\n \n Other attributes may be added or removed during development of the language.\n \n+### Conditional compilation\n+\n+Sometimes one wants to have different compiler outputs from the same code,\n+depending on build target, such as targeted operating system, or to enable\n+release builds.\n+\n+There are two kinds of configuration options, one that is either defined or not\n+(`#[cfg(foo)]`), and the other that contains a string that can be checked\n+against (`#[cfg(bar = \"baz\")]` (currently only compiler-defined configuration\n+options can have the latter form).\n+\n+~~~~\n+// The function is only included in the build when compiling for OSX\n+#[cfg(target_os = \"macos\")]\n+fn macos_only() {\n+  // ...\n+}\n+\n+// This function is only included when either foo or bar is defined\n+#[cfg(foo)]\n+#[cfg(bar)]\n+fn needs_foo_or_bar() {\n+  // ...\n+}\n+\n+// This function is only included when compiling for a unixish OS with a 32-bit\n+// architecture\n+#[cfg(unix, target_word_size = \"32\")]\n+fn on_32bit_unix() {\n+  // ...\n+}\n+~~~~\n+\n+This illustrates some conditional compilation can be achieved using the\n+`#[cfg(...)]` attribute. Note that `#[cfg(foo, bar)]` is a condition that needs\n+both `foo` and `bar` to be defined while `#[cfg(foo)] #[cfg(bar)]` only needs\n+one of `foo` and `bar` to be defined (this resembles in the disjunctive normal\n+form). Additionally, one can reverse a condition by enclosing it in a\n+`not(...)`, like e. g. `#[cfg(not(target_os = \"win32\"))]`.\n+\n+To pass a configuration option which triggers a `#[cfg(identifier)]` one can use\n+`rustc --cfg identifier`. In addition to that, the following configurations are\n+pre-defined by the compiler:\n+\n+ * `target_arch = \"...\"`. Target CPU architecture, such as `\"x86\"`, `\"x86_64\"`\n+   `\"mips\"`, or `\"arm\"`.\n+ * `target_endian = \"...\"`. Endianness of the target CPU, either `\"little\"` or\n+   `\"big\"`.\n+ * `target_family = \"...\"`. Operating system family of the target, e. g.\n+   `\"unix\"` or `\"windows\"`. The value of this configuration option is defined as\n+   a configuration itself, like `unix` or `windows`.\n+ * `target_os = \"...\"`. Operating system of the target, examples include\n+   `\"win32\"`, `\"macos\"`, `\"linux\"`, `\"android\"` or `\"freebsd\"`.\n+ * `target_word_size = \"...\"`. Target word size in bits. This is set to `\"32\"`\n+   for 32-bit CPU targets, and likewise set to `\"64\"` for 64-bit CPU targets.\n+ * `test`. Only set in test builds (`rustc --test`).\n+ * `unix`. See `target_family`.\n+ * `windows`. See `target_family`.\n+\n ### Lint check attributes\n \n A lint check names a potentially undesirable coding pattern, such as"}, {"sha": "b41af9eb05430f19cbcc72c8fae978b5d069a01c", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -34,7 +34,6 @@ use std::cast;\n use std::cell::{Cell, RefCell};\n use std::mem;\n use std::num;\n-use std::ptr;\n use std::kinds::marker;\n use std::rc::Rc;\n use std::rt::global_heap;\n@@ -144,7 +143,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n     let fill = chunk.fill.get();\n \n     while idx < fill {\n-        let tydesc_data: *uint = transmute(ptr::offset(buf, idx as int));\n+        let tydesc_data: *uint = transmute(buf.offset(idx as int));\n         let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n         let (size, align) = ((*tydesc).size, (*tydesc).align);\n \n@@ -155,7 +154,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n         //debug!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n         //       start, size, align, is_done);\n         if is_done {\n-            ((*tydesc).drop_glue)(ptr::offset(buf, start as int) as *i8);\n+            ((*tydesc).drop_glue)(buf.offset(start as int) as *i8);\n         }\n \n         // Find where the next tydesc lives\n@@ -261,7 +260,7 @@ impl Arena {\n             //       start, n_bytes, align, head.fill);\n \n             let buf = self.head.as_ptr();\n-            return (ptr::offset(buf, tydesc_start as int), ptr::offset(buf, start as int));\n+            return (buf.offset(tydesc_start as int), buf.offset(start as int));\n         }\n     }\n "}, {"sha": "fec5b105c4b1893f4c9f406210511f606b85f983", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -119,7 +119,7 @@ impl <T> CVec<T> {\n     pub fn get<'a>(&'a self, ofs: uint) -> &'a T {\n         assert!(ofs < self.len);\n         unsafe {\n-            &*ptr::mut_offset(self.base, ofs as int)\n+            &*self.base.offset(ofs as int)\n         }\n     }\n \n@@ -131,7 +131,7 @@ impl <T> CVec<T> {\n     pub fn get_mut<'a>(&'a mut self, ofs: uint) -> &'a mut T {\n         assert!(ofs < self.len);\n         unsafe {\n-            &mut *ptr::mut_offset(self.base, ofs as int)\n+            &mut *self.base.offset(ofs as int)\n         }\n     }\n "}, {"sha": "c630ac096f622ad578cec3399723567274c59064", "filename": "src/libextra/lib.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibextra%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibextra%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flib.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -35,20 +35,10 @@ Rust extras are part of the standard Rust distribution.\n #[deny(missing_doc)];\n \n extern mod sync;\n-#[cfg(not(stage0))]\n extern mod serialize;\n \n extern mod collections;\n \n-#[cfg(stage0)]\n-pub mod serialize {\n-    #[allow(missing_doc)];\n-    // Temp re-export until after a snapshot\n-    extern mod serialize = \"serialize\";\n-    pub use self::serialize::{Encoder, Decoder, Encodable, Decodable,\n-                                   EncoderHelpers, DecoderHelpers};\n-}\n-\n // Utility modules\n \n pub mod c_vec;\n@@ -59,11 +49,9 @@ pub mod url;\n pub mod json;\n pub mod tempfile;\n pub mod time;\n-pub mod base64;\n pub mod workcache;\n pub mod enum_set;\n pub mod stats;\n-pub mod hex;\n \n #[cfg(unicode)]\n mod unicode;"}, {"sha": "8f632ae639dcca61f11e728fb0f330f476e6537a", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -784,11 +784,12 @@ impl BigUint {\n         if n_bits == 0 || self.data.is_empty() { return (*self).clone(); }\n \n         let mut borrow = 0;\n-        let mut shifted = ~[];\n+        let mut shifted_rev = vec::with_capacity(self.data.len());\n         for elem in self.data.rev_iter() {\n-            shifted = ~[(*elem >> n_bits) | borrow] + shifted;\n+            shifted_rev.push((*elem >> n_bits) | borrow);\n             borrow = *elem << (BigDigit::bits - n_bits);\n         }\n+        let shifted = { shifted_rev.reverse(); shifted_rev };\n         return BigUint::new(shifted);\n     }\n \n@@ -2637,4 +2638,15 @@ mod bench {\n             fib.to_str();\n         });\n     }\n+\n+    #[bench]\n+    fn shr(bh: &mut BenchHarness) {\n+        let n = { let one : BigUint = One::one(); one << 1000 };\n+        bh.iter(|| {\n+            let mut m = n.clone();\n+            for _ in range(0, 10) {\n+                m = m >> 1;\n+            }\n+        })\n+    }\n }"}, {"sha": "957ca3b46c9d1f4f2fd413ed9f256022e82d17e9", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -34,7 +34,7 @@ use std::run;\n use std::str;\n use std::io;\n use std::io::fs;\n-use extra::hex::ToHex;\n+use serialize::hex::ToHex;\n use extra::tempfile::TempDir;\n use syntax::abi;\n use syntax::ast;"}, {"sha": "70b93a9813535842c5791b7e16697395b18a3102", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -30,7 +30,6 @@ use std::io;\n use std::num;\n use std::option;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n-use std::ptr;\n use std::str;\n use std::vec;\n use flate;\n@@ -340,7 +339,7 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Option<MetadataBlob> {\n                 });\n                 if !version_ok { return None; }\n \n-                let cvbuf1 = ptr::offset(cvbuf, vlen as int);\n+                let cvbuf1 = cvbuf.offset(vlen as int);\n                 debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n                 vec::raw::buf_as_slice(cvbuf1, csz-vlen, |bytes| {"}, {"sha": "b8d16f9bb8006d761ea7ba62801496141d676ccd", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -21,7 +21,6 @@ use std::cast;\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ulonglong, c_char};\n use syntax::codemap::Span;\n-use std::ptr::is_not_null;\n \n pub struct Builder<'a> {\n     llbuilder: BuilderRef,\n@@ -492,7 +491,7 @@ impl<'a> Builder<'a> {\n         debug!(\"Store {} -> {}\",\n                self.ccx.tn.val_to_str(val),\n                self.ccx.tn.val_to_str(ptr));\n-        assert!(is_not_null(self.llbuilder));\n+        assert!(self.llbuilder.is_not_null());\n         self.count_insn(\"store\");\n         unsafe {\n             llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n@@ -503,7 +502,7 @@ impl<'a> Builder<'a> {\n         debug!(\"Store {} -> {}\",\n                self.ccx.tn.val_to_str(val),\n                self.ccx.tn.val_to_str(ptr));\n-        assert!(is_not_null(self.llbuilder));\n+        assert!(self.llbuilder.is_not_null());\n         self.count_insn(\"store.volatile\");\n         unsafe {\n             let insn = llvm::LLVMBuildStore(self.llbuilder, val, ptr);"}, {"sha": "68511362f5ffcb59df459d09b45365451ba9189c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -3035,6 +3035,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                     if type_is_c_like_enum(fcx, expr.span, t_e) && t_1_is_trivial {\n                         // casts from C-like enums are allowed\n                     } else if t_1_is_char {\n+                        let te = fcx.infcx().resolve_type_vars_if_possible(te);\n                         if ty::get(te).sty != ty::ty_uint(ast::TyU8) {\n                             fcx.type_error_message(expr.span, |actual| {\n                                 format!(\"only `u8` can be cast as `char`, not `{}`\", actual)"}, {"sha": "940cebf78471ee6b9c6d96b7ed4807fb1319e4ad", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -16,7 +16,7 @@ use std::iter::range_step;\n use std::num::Zero;\n use std::vec;\n use std::vec::bytes::{MutableByteVector, copy_memory};\n-use extra::hex::ToHex;\n+use serialize::hex::ToHex;\n \n /// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n /// format.\n@@ -529,7 +529,7 @@ mod tests {\n     use std::vec;\n     use std::rand::isaac::IsaacRng;\n     use std::rand::Rng;\n-    use extra::hex::FromHex;\n+    use serialize::hex::FromHex;\n \n     // A normal addition - no overflow occurs\n     #[test]"}, {"sha": "eb0b4597e30077778b936dd88ea450e235cff4ee", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -342,7 +342,9 @@ impl Clean<Item> for ast::Method {\n             _ => self.decl.inputs.slice_from(1)\n         };\n         let decl = FnDecl {\n-            inputs: inputs.iter().map(|x| x.clean()).collect(),\n+            inputs: Arguments {\n+                values: inputs.iter().map(|x| x.clean()).collect(),\n+            },\n             output: (self.decl.output.clean()),\n             cf: self.decl.cf.clean(),\n             attrs: ~[]\n@@ -378,7 +380,9 @@ impl Clean<Item> for ast::TypeMethod {\n             _ => self.decl.inputs.slice_from(1)\n         };\n         let decl = FnDecl {\n-            inputs: inputs.iter().map(|x| x.clean()).collect(),\n+            inputs: Arguments {\n+                values: inputs.iter().map(|x| x.clean()).collect(),\n+            },\n             output: (self.decl.output.clean()),\n             cf: self.decl.cf.clean(),\n             attrs: ~[]\n@@ -472,16 +476,23 @@ impl Clean<ClosureDecl> for ast::ClosureTy {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct FnDecl {\n-    inputs: ~[Argument],\n+    inputs: Arguments,\n     output: Type,\n     cf: RetStyle,\n     attrs: ~[Attribute]\n }\n \n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Arguments {\n+    values: ~[Argument],\n+}\n+\n impl Clean<FnDecl> for ast::FnDecl {\n     fn clean(&self) -> FnDecl {\n         FnDecl {\n-            inputs: self.inputs.iter().map(|x| x.clean()).collect(),\n+            inputs: Arguments {\n+                values: self.inputs.iter().map(|x| x.clean()).collect(),\n+            },\n             output: (self.output.clean()),\n             cf: self.cf.clean(),\n             attrs: ~[]"}, {"sha": "3e5afc399b962749a4128f80bd2ca751e71fd953", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -404,6 +404,19 @@ impl fmt::Show for clean::Type {\n     }\n }\n \n+impl fmt::Show for clean::Arguments {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for (i, input) in self.values.iter().enumerate() {\n+            if i > 0 { if_ok!(write!(f.buf, \", \")); }\n+            if input.name.len() > 0 {\n+                if_ok!(write!(f.buf, \"{}: \", input.name));\n+            }\n+            if_ok!(write!(f.buf, \"{}\", input.type_));\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl fmt::Show for clean::FnDecl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f.buf, \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n@@ -413,20 +426,6 @@ impl fmt::Show for clean::FnDecl {\n     }\n }\n \n-impl fmt::Show for ~[clean::Argument] {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let mut args = ~\"\";\n-        for (i, input) in self.iter().enumerate() {\n-            if i > 0 { args.push_str(\", \"); }\n-            if input.name.len() > 0 {\n-                args.push_str(format!(\"{}: \", input.name));\n-            }\n-            args.push_str(format!(\"{}\", input.type_));\n-        }\n-        f.buf.write(args.as_bytes())\n-    }\n-}\n-\n impl<'a> fmt::Show for Method<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Method(selfty, d) = *self;\n@@ -448,7 +447,7 @@ impl<'a> fmt::Show for Method<'a> {\n                 args.push_str(\"&amp;self\");\n             }\n         }\n-        for (i, input) in d.inputs.iter().enumerate() {\n+        for (i, input) in d.inputs.values.iter().enumerate() {\n             if i > 0 || args.len() > 0 { args.push_str(\", \"); }\n             if input.name.len() > 0 {\n                 args.push_str(format!(\"{}: \", input.name));"}, {"sha": "b71dbe05ad2b665a6b8f74057a4c08290df6cb6e", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -426,7 +426,7 @@ mod test {\n         unsafe {\n             let base = transmute::<*u8, *mut u8>(buf.base);\n             (*base) = 1;\n-            (*ptr::mut_offset(base, 1)) = 2;\n+            (*base.offset(1)) = 2;\n         }\n \n         assert!(slice[0] == 1);"}, {"sha": "c22eefdb3302076bf5777251a3069c3f7a016639", "filename": "src/libserialize/base64.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -63,8 +63,8 @@ impl<'a> ToBase64 for &'a [u8] {\n      * # Example\n      *\n      * ```rust\n-     * extern mod extra;\n-     * use extra::base64::{ToBase64, STANDARD};\n+     * extern mod serialize;\n+     * use serialize::base64::{ToBase64, STANDARD};\n      *\n      * fn main () {\n      *     let str = [52,32].to_base64(STANDARD);\n@@ -189,8 +189,8 @@ impl<'a> FromBase64 for &'a str {\n      * This converts a string literal to base64 and back.\n      *\n      * ```rust\n-     * extern mod extra;\n-     * use extra::base64::{ToBase64, FromBase64, STANDARD};\n+     * extern mod serialize;\n+     * use serialize::base64::{ToBase64, FromBase64, STANDARD};\n      * use std::str;\n      *\n      * fn main () {\n@@ -261,8 +261,8 @@ impl<'a> FromBase64 for &'a str {\n \n #[cfg(test)]\n mod test {\n-    use test::BenchHarness;\n-    use base64::*;\n+    use extra::test::BenchHarness;\n+    use base64::{Config, FromBase64, ToBase64, STANDARD, URL_SAFE};\n \n     #[test]\n     fn test_to_base64_basic() {", "previous_filename": "src/libextra/base64.rs"}, {"sha": "3d57a32a830b2c867162c9ca85c6ae8dadb96bf9", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -131,7 +131,6 @@ pub mod reader {\n     }\n \n     pub fn vuint_at(data: &[u8], start: uint) -> Res {\n-        use std::ptr::offset;\n         use std::mem::from_be32;\n \n         if data.len() - start < 4 {\n@@ -163,7 +162,7 @@ pub mod reader {\n \n         unsafe {\n             let (ptr, _): (*u8, uint) = transmute(data);\n-            let ptr = offset(ptr, start as int);\n+            let ptr = ptr.offset(start as int);\n             let ptr: *i32 = transmute(ptr);\n             let val = from_be32(*ptr) as u32;\n "}, {"sha": "409bf4af809928a430e86d2bc479f3a7a90a18c5", "filename": "src/libserialize/hex.rs", "status": "renamed", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -28,7 +28,8 @@ impl<'a> ToHex for &'a [u8] {\n      * # Example\n      *\n      * ```rust\n-     * use extra::hex::ToHex;\n+     * extern mod serialize;\n+     * use serialize::hex::ToHex;\n      *\n      * fn main () {\n      *     let str = [52,32].to_hex();\n@@ -88,7 +89,8 @@ impl<'a> FromHex for &'a str {\n      * This converts a string literal to hexadecimal and back.\n      *\n      * ```rust\n-     * use extra::hex::{FromHex, ToHex};\n+     * extern mod serialize;\n+     * use serialize::hex::{FromHex, ToHex};\n      * use std::str;\n      *\n      * fn main () {\n@@ -137,8 +139,8 @@ impl<'a> FromHex for &'a str {\n \n #[cfg(test)]\n mod tests {\n-    use test::BenchHarness;\n-    use hex::*;\n+    use extra::test::BenchHarness;\n+    use hex::{FromHex, ToHex};\n \n     #[test]\n     pub fn test_to_hex() {", "previous_filename": "src/libextra/hex.rs"}, {"sha": "3b71b2237b17661df9333bbc88bb1909724d3998", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -30,4 +30,8 @@ pub use self::serialize::{Decoder, Encoder, Decodable, Encodable,\n     DecoderHelpers, EncoderHelpers};\n \n mod serialize;\n+\n+pub mod base64;\n pub mod ebml;\n+pub mod hex;\n+"}, {"sha": "3f14db14882ec54a271aef7733a16af2df4dd88b", "filename": "src/libstd/any.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fany.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -21,6 +21,7 @@\n //! extension traits (`*Ext`) for the full details.\n \n use cast::transmute;\n+use fmt;\n use option::{Option, Some, None};\n use result::{Result, Ok, Err};\n use to_str::ToStr;\n@@ -158,6 +159,18 @@ impl<'a> ToStr for &'a Any {\n     fn to_str(&self) -> ~str { ~\"&Any\" }\n }\n \n+impl fmt::Show for ~Any {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"~Any\")\n+    }\n+}\n+\n+impl<'a> fmt::Show for &'a Any {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"&Any\")\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n@@ -377,4 +390,17 @@ mod tests {\n         assert!(a.move::<~Test>().is_err());\n         assert!(b.move::<~uint>().is_err());\n     }\n+\n+    #[test]\n+    fn test_show() {\n+        let a = ~8u as ~Any;\n+        let b = ~Test as ~Any;\n+        assert_eq!(format!(\"{}\", a), ~\"~Any\");\n+        assert_eq!(format!(\"{}\", b), ~\"~Any\");\n+\n+        let a = &8u as &Any;\n+        let b = &Test as &Any;\n+        assert_eq!(format!(\"{}\", a), ~\"&Any\");\n+        assert_eq!(format!(\"{}\", b), ~\"&Any\");\n+    }\n }"}, {"sha": "651d364dd1b9702e191354cdb8e6d4eeb017ea2f", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -17,6 +17,7 @@ use str::StrSlice;\n use str::OwnedStr;\n use container::Container;\n use cast;\n+use fmt;\n use iter::Iterator;\n use vec::{ImmutableVector, MutableVector, Vector};\n use to_bytes::IterBytes;\n@@ -134,6 +135,12 @@ impl ToStr for Ascii {\n     }\n }\n \n+impl<'a> fmt::Show for Ascii {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        (self.chr as char).fmt(f)\n+    }\n+}\n+\n /// Trait for converting into an ascii type.\n pub trait AsciiCast<T> {\n     /// Convert to an ascii type, fail on non-ASCII input.\n@@ -698,5 +705,9 @@ mod tests {\n         assert_eq!(s, ~\"t\");\n     }\n \n-\n+    #[test]\n+    fn test_show() {\n+        let c = Ascii { chr: 't' as u8 };\n+        assert_eq!(format!(\"{}\", c), ~\"t\");\n+    }\n }"}, {"sha": "fe332a60efa4468ec3f37ef8e1df608323114be9", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -310,7 +310,7 @@ impl<'a> ToCStr for &'a [u8] {\n         let buf = malloc_raw(self_len + 1);\n \n         ptr::copy_memory(buf, self.as_ptr(), self_len);\n-        *ptr::mut_offset(buf, self_len as int) = 0;\n+        *buf.offset(self_len as int) = 0;\n \n         CString::new(buf as *libc::c_char, true)\n     }\n@@ -368,7 +368,7 @@ impl<'a> Iterator<libc::c_char> for CChars<'a> {\n         if ch == 0 {\n             None\n         } else {\n-            self.ptr = unsafe { ptr::offset(self.ptr, 1) };\n+            self.ptr = unsafe { self.ptr.offset(1) };\n             Some(ch)\n         }\n     }\n@@ -429,18 +429,18 @@ mod tests {\n     fn test_str_to_c_str() {\n         \"\".to_c_str().with_ref(|buf| {\n             unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 0);\n+                assert_eq!(*buf.offset(0), 0);\n             }\n         });\n \n         \"hello\".to_c_str().with_ref(|buf| {\n             unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 2), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 3), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 5), 0);\n+                assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n+                assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n+                assert_eq!(*buf.offset(2), 'l' as libc::c_char);\n+                assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n+                assert_eq!(*buf.offset(4), 'o' as libc::c_char);\n+                assert_eq!(*buf.offset(5), 0);\n             }\n         })\n     }\n@@ -450,28 +450,28 @@ mod tests {\n         let b: &[u8] = [];\n         b.to_c_str().with_ref(|buf| {\n             unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 0);\n+                assert_eq!(*buf.offset(0), 0);\n             }\n         });\n \n         let _ = bytes!(\"hello\").to_c_str().with_ref(|buf| {\n             unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 2), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 3), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 5), 0);\n+                assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n+                assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n+                assert_eq!(*buf.offset(2), 'l' as libc::c_char);\n+                assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n+                assert_eq!(*buf.offset(4), 'o' as libc::c_char);\n+                assert_eq!(*buf.offset(5), 0);\n             }\n         });\n \n         let _ = bytes!(\"foo\", 0xff).to_c_str().with_ref(|buf| {\n             unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 'f' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 1), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 2), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 3), 0xff as i8);\n-                assert_eq!(*ptr::offset(buf, 4), 0);\n+                assert_eq!(*buf.offset(0), 'f' as libc::c_char);\n+                assert_eq!(*buf.offset(1), 'o' as libc::c_char);\n+                assert_eq!(*buf.offset(2), 'o' as libc::c_char);\n+                assert_eq!(*buf.offset(3), 0xff as i8);\n+                assert_eq!(*buf.offset(4), 0);\n             }\n         });\n     }\n@@ -634,16 +634,15 @@ mod bench {\n     use extra::test::BenchHarness;\n     use libc;\n     use prelude::*;\n-    use ptr;\n \n     #[inline]\n     fn check(s: &str, c_str: *libc::c_char) {\n         let s_buf = s.as_ptr();\n         for i in range(0, s.len()) {\n             unsafe {\n                 assert_eq!(\n-                    *ptr::offset(s_buf, i as int) as libc::c_char,\n-                    *ptr::offset(c_str, i as int));\n+                    *s_buf.offset(i as int) as libc::c_char,\n+                    *c_str.offset(i as int));\n             }\n         }\n     }"}, {"sha": "dd43d8e2971a83a5332d1b1a5ed8ad38f79357f9", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -57,53 +57,6 @@ fn debug_mem() -> bool {\n }\n \n /// Destroys all managed memory (i.e. @ boxes) held by the current task.\n-#[cfg(stage0)]\n-pub unsafe fn annihilate() {\n-    use rt::local_heap::local_free;\n-\n-    let mut n_total_boxes = 0u;\n-\n-    // Pass 1: Make all boxes immortal.\n-    //\n-    // In this pass, nothing gets freed, so it does not matter whether\n-    // we read the next field before or after the callback.\n-    each_live_alloc(true, |alloc| {\n-        n_total_boxes += 1;\n-        (*alloc).ref_count = RC_IMMORTAL;\n-        true\n-    });\n-\n-    // Pass 2: Drop all boxes.\n-    //\n-    // In this pass, unique-managed boxes may get freed, but not\n-    // managed boxes, so we must read the `next` field *after* the\n-    // callback, as the original value may have been freed.\n-    each_live_alloc(false, |alloc| {\n-        let tydesc = (*alloc).type_desc;\n-        let data = &(*alloc).data as *();\n-        ((*tydesc).drop_glue)(data as *i8);\n-        true\n-    });\n-\n-    // Pass 3: Free all boxes.\n-    //\n-    // In this pass, managed boxes may get freed (but not\n-    // unique-managed boxes, though I think that none of those are\n-    // left), so we must read the `next` field before, since it will\n-    // not be valid after.\n-    each_live_alloc(true, |alloc| {\n-        local_free(alloc as *u8);\n-        true\n-    });\n-\n-    if debug_mem() {\n-        // We do logging here w/o allocation.\n-        debug!(\"total boxes annihilated: {}\", n_total_boxes);\n-    }\n-}\n-\n-/// Destroys all managed memory (i.e. @ boxes) held by the current task.\n-#[cfg(not(stage0))]\n pub unsafe fn annihilate() {\n     use rt::local_heap::local_free;\n "}, {"sha": "e41fa60aa42e6c4c79d02ae8fa9329c37cf6e857", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 106, "deletions": 14, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -60,21 +60,17 @@ use uint;\n \n macro_rules! select {\n     (\n-        $name1:pat = $port1:ident.$meth1:ident() => $code1:expr,\n-        $($name:pat = $port:ident.$meth:ident() => $code:expr),*\n+        $($name:pat = $port:ident.$meth:ident() => $code:expr),+\n     ) => ({\n         use std::comm::Select;\n         let sel = Select::new();\n-        let mut $port1 = sel.handle(&$port1);\n-        $( let mut $port = sel.handle(&$port); )*\n+        $( let mut $port = sel.handle(&$port); )+\n         unsafe {\n-            $port1.add();\n-            $( $port.add(); )*\n+            $( $port.add(); )+\n         }\n         let ret = sel.wait();\n-        if ret == $port1.id { let $name1 = $port1.$meth1(); $code1 }\n-        $( else if ret == $port.id { let $name = $port.$meth(); $code } )*\n-        else { unreachable!() }\n+        $( if ret == $port.id() { let $name = $port.$meth(); $code } else )+\n+        { unreachable!() }\n     })\n }\n \n@@ -94,7 +90,7 @@ pub struct Select {\n pub struct Handle<'port, T> {\n     /// The ID of this handle, used to compare against the return value of\n     /// `Select::wait()`\n-    id: uint,\n+    priv id: uint,\n     priv selector: &'port Select,\n     priv next: *mut Handle<'static, ()>,\n     priv prev: *mut Handle<'static, ()>,\n@@ -150,11 +146,16 @@ impl Select {\n \n     /// Waits for an event on this port set. The returned valus is *not* and\n     /// index, but rather an id. This id can be queried against any active\n-    /// `Handle` structures (each one has a public `id` field). The handle with\n+    /// `Handle` structures (each one has an `id` method). The handle with\n     /// the matching `id` will have some sort of event available on it. The\n     /// event could either be that data is available or the corresponding\n     /// channel has been closed.\n     pub fn wait(&self) -> uint {\n+        self.wait2(false)\n+    }\n+\n+    /// Helper method for skipping the preflight checks during testing\n+    fn wait2(&self, do_preflight_checks: bool) -> uint {\n         // Note that this is currently an inefficient implementation. We in\n         // theory have knowledge about all ports in the set ahead of time, so\n         // this method shouldn't really have to iterate over all of them yet\n@@ -179,7 +180,7 @@ impl Select {\n             let mut amt = 0;\n             for p in self.iter() {\n                 amt += 1;\n-                if (*p).packet.can_recv() {\n+                if do_preflight_checks && (*p).packet.can_recv() {\n                     return (*p).id;\n                 }\n             }\n@@ -242,6 +243,10 @@ impl Select {\n }\n \n impl<'port, T: Send> Handle<'port, T> {\n+    /// Retrieve the id of this handle.\n+    #[inline]\n+    pub fn id(&self) -> uint { self.id }\n+\n     /// Receive a value on the underlying port. Has the same semantics as\n     /// `Port.recv`\n     pub fn recv(&mut self) -> T { self.port.recv() }\n@@ -355,7 +360,7 @@ mod test {\n         )\n         drop(c2);\n         select! (\n-            bar = p2.recv_opt() => { assert_eq!(bar, None); },\n+            bar = p2.recv_opt() => { assert_eq!(bar, None); }\n         )\n     })\n \n@@ -507,7 +512,7 @@ mod test {\n         let (p2, c2) = Chan::<()>::new();\n         let (p, c) = Chan::new();\n         spawn(proc() {\n-            let mut s = Select::new();\n+            let s = Select::new();\n             let mut h1 = s.handle(&p1);\n             let mut h2 = s.handle(&p2);\n             unsafe { h2.add(); }\n@@ -521,4 +526,91 @@ mod test {\n         c2.send(());\n         p.recv();\n     })\n+\n+    test!(fn preflight1() {\n+        let (p, c) = Chan::new();\n+        c.send(());\n+        select!(\n+            () = p.recv() => {}\n+        )\n+    })\n+\n+    test!(fn preflight2() {\n+        let (p, c) = Chan::new();\n+        c.send(());\n+        c.send(());\n+        select!(\n+            () = p.recv() => {}\n+        )\n+    })\n+\n+    test!(fn preflight3() {\n+        let (p, c) = Chan::new();\n+        drop(c.clone());\n+        c.send(());\n+        select!(\n+            () = p.recv() => {}\n+        )\n+    })\n+\n+    test!(fn preflight4() {\n+        let (p, c) = Chan::new();\n+        c.send(());\n+        let s = Select::new();\n+        let mut h = s.handle(&p);\n+        unsafe { h.add(); }\n+        assert_eq!(s.wait2(false), h.id);\n+    })\n+\n+    test!(fn preflight5() {\n+        let (p, c) = Chan::new();\n+        c.send(());\n+        c.send(());\n+        let s = Select::new();\n+        let mut h = s.handle(&p);\n+        unsafe { h.add(); }\n+        assert_eq!(s.wait2(false), h.id);\n+    })\n+\n+    test!(fn preflight6() {\n+        let (p, c) = Chan::new();\n+        drop(c.clone());\n+        c.send(());\n+        let s = Select::new();\n+        let mut h = s.handle(&p);\n+        unsafe { h.add(); }\n+        assert_eq!(s.wait2(false), h.id);\n+    })\n+\n+    test!(fn preflight7() {\n+        let (p, c) = Chan::<()>::new();\n+        drop(c);\n+        let s = Select::new();\n+        let mut h = s.handle(&p);\n+        unsafe { h.add(); }\n+        assert_eq!(s.wait2(false), h.id);\n+    })\n+\n+    test!(fn preflight8() {\n+        let (p, c) = Chan::new();\n+        c.send(());\n+        drop(c);\n+        p.recv();\n+        let s = Select::new();\n+        let mut h = s.handle(&p);\n+        unsafe { h.add(); }\n+        assert_eq!(s.wait2(false), h.id);\n+    })\n+\n+    test!(fn preflight9() {\n+        let (p, c) = Chan::new();\n+        drop(c.clone());\n+        c.send(());\n+        drop(c);\n+        p.recv();\n+        let s = Select::new();\n+        let mut h = s.handle(&p);\n+        unsafe { h.add(); }\n+        assert_eq!(s.wait2(false), h.id);\n+    })\n }"}, {"sha": "77bf2d7a68d36be4c5f6734656043fa68f7f1c1a", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -398,6 +398,17 @@ impl<T: Send> Packet<T> {\n         cnt == DISCONNECTED || cnt - self.steals > 0\n     }\n \n+    // increment the count on the channel (used for selection)\n+    fn bump(&mut self, amt: int) -> int {\n+        match self.cnt.fetch_add(amt, atomics::SeqCst) {\n+            DISCONNECTED => {\n+                self.cnt.store(DISCONNECTED, atomics::SeqCst);\n+                DISCONNECTED\n+            }\n+            n => n\n+        }\n+    }\n+\n     // Inserts the blocked task for selection on this port, returning it back if\n     // the port already has data on it.\n     //\n@@ -408,8 +419,8 @@ impl<T: Send> Packet<T> {\n         match self.decrement(task) {\n             Ok(()) => Ok(()),\n             Err(task) => {\n-                let prev = self.cnt.fetch_add(1, atomics::SeqCst);\n-                assert!(prev >= 0);\n+                let prev = self.bump(1);\n+                assert!(prev == DISCONNECTED || prev >= 0);\n                 return Err(task);\n             }\n         }\n@@ -440,11 +451,10 @@ impl<T: Send> Packet<T> {\n             let cnt = self.cnt.load(atomics::SeqCst);\n             if cnt < 0 && cnt != DISCONNECTED {-cnt} else {0}\n         };\n-        let prev = self.cnt.fetch_add(steals + 1, atomics::SeqCst);\n+        let prev = self.bump(steals + 1);\n \n         if prev == DISCONNECTED {\n             assert_eq!(self.to_wake.load(atomics::SeqCst), 0);\n-            self.cnt.store(DISCONNECTED, atomics::SeqCst);\n             true\n         } else {\n             let cur = prev + steals + 1;"}, {"sha": "9c972a3771c1af9c5d9bdef3586acc5a2f20f311", "filename": "src/libstd/comm/stream.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fstream.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -333,6 +333,17 @@ impl<T: Send> Packet<T> {\n         }\n     }\n \n+    // increment the count on the channel (used for selection)\n+    fn bump(&mut self, amt: int) -> int {\n+        match self.cnt.fetch_add(amt, atomics::SeqCst) {\n+            DISCONNECTED => {\n+                self.cnt.store(DISCONNECTED, atomics::SeqCst);\n+                DISCONNECTED\n+            }\n+            n => n\n+        }\n+    }\n+\n     // Attempts to start selecting on this port. Like a oneshot, this can fail\n     // immediately because of an upgrade.\n     pub fn start_selection(&mut self, task: BlockedTask) -> SelectionResult<T> {\n@@ -351,8 +362,8 @@ impl<T: Send> Packet<T> {\n                 };\n                 // Undo our decrement above, and we should be guaranteed that the\n                 // previous value is positive because we're not going to sleep\n-                let prev = self.cnt.fetch_add(1, atomics::SeqCst);\n-                assert!(prev >= 0);\n+                let prev = self.bump(1);\n+                assert!(prev == DISCONNECTED || prev >= 0);\n                 return ret;\n             }\n         }\n@@ -384,13 +395,12 @@ impl<T: Send> Packet<T> {\n         // and in the stream case we can have at most one steal, so just assume\n         // that we had one steal.\n         let steals = 1;\n-        let prev = self.cnt.fetch_add(steals + 1, atomics::SeqCst);\n+        let prev = self.bump(steals + 1);\n \n         // If we were previously disconnected, then we know for sure that there\n         // is no task in to_wake, so just keep going\n         let has_data = if prev == DISCONNECTED {\n             assert_eq!(self.to_wake.load(atomics::SeqCst), 0);\n-            self.cnt.store(DISCONNECTED, atomics::SeqCst);\n             true // there is data, that data is that we're disconnected\n         } else {\n             let cur = prev + steals + 1;"}, {"sha": "c49294a095f292d4cf05e556c7c72b9ff4eab5f3", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -56,6 +56,7 @@ use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use clone::Clone;\n use cmp::{Eq, Equiv};\n use default::Default;\n+#[cfg(not(stage0))] use fmt;\n use hash::Hash;\n use iter;\n use iter::{Iterator, FromIterator, Extendable};\n@@ -65,6 +66,7 @@ use num;\n use option::{None, Option, Some};\n use rand::Rng;\n use rand;\n+#[cfg(not(stage0))] use result::{Ok, Err};\n use vec::{ImmutableVector, MutableVector, OwnedVector, Items, MutItems};\n use vec_ng;\n use vec_ng::Vec;\n@@ -595,6 +597,23 @@ impl<K:Hash + Eq + Clone,V:Clone> Clone for HashMap<K,V> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<A: fmt::Show + Hash + Eq, B: fmt::Show> fmt::Show for HashMap<A, B> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if_ok!(write!(f.buf, r\"\\{\"))\n+        let mut first = true;\n+        for (key, value) in self.iter() {\n+            if first {\n+                first = false;\n+            } else {\n+                if_ok!(write!(f.buf, \", \"));\n+            }\n+            if_ok!(write!(f.buf, \"{}: {}\", *key, *value));\n+        }\n+        write!(f.buf, r\"\\}\")\n+    }\n+}\n+\n /// HashMap iterator\n #[deriving(Clone)]\n pub struct Entries<'a, K, V> {\n@@ -857,6 +876,23 @@ impl<T:Hash + Eq + Clone> Clone for HashSet<T> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<A: fmt::Show + Hash + Eq> fmt::Show for HashSet<A> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if_ok!(write!(f.buf, r\"\\{\"))\n+        let mut first = true;\n+        for x in self.iter() {\n+            if first {\n+                first = false;\n+            } else {\n+                if_ok!(write!(f.buf, \", \"));\n+            }\n+            if_ok!(write!(f.buf, \"{}\", *x));\n+        }\n+        write!(f.buf, r\"\\}\")\n+    }\n+}\n+\n impl<K: Eq + Hash> FromIterator<K> for HashSet<K> {\n     fn from_iterator<T: Iterator<K>>(iter: &mut T) -> HashSet<K> {\n         let (lower, _) = iter.size_hint();\n@@ -890,6 +926,7 @@ pub type SetAlgebraItems<'a, T> =\n mod test_map {\n     use prelude::*;\n     use super::*;\n+    use fmt;\n \n     #[test]\n     fn test_create_capacity_zero() {\n@@ -1121,6 +1158,30 @@ mod test_map {\n             assert_eq!(map.find(&k), Some(&v));\n         }\n     }\n+\n+    struct ShowableStruct {\n+        value: int,\n+    }\n+\n+    impl fmt::Show for ShowableStruct {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            write!(f.buf, r\"s{}\", self.value)\n+        }\n+    }\n+\n+    #[test]\n+    fn test_show() {\n+        let mut table: HashMap<int, ShowableStruct> = HashMap::new();\n+        let empty: HashMap<int, ShowableStruct> = HashMap::new();\n+\n+        table.insert(3, ShowableStruct { value: 4 });\n+        table.insert(1, ShowableStruct { value: 2 });\n+\n+        let table_str = format!(\"{}\", table);\n+\n+        assert!(table_str == ~\"{1: s2, 3: s4}\" || table_str == ~\"{3: s4, 1: s2}\");\n+        assert_eq!(format!(\"{}\", empty), ~\"{}\");\n+    }\n }\n \n #[cfg(test)]\n@@ -1346,4 +1407,18 @@ mod test_set {\n \n         assert_eq!(s1, s2);\n     }\n+\n+    #[test]\n+    fn test_show() {\n+        let mut set: HashSet<int> = HashSet::new();\n+        let empty: HashSet<int> = HashSet::new();\n+\n+        set.insert(1);\n+        set.insert(2);\n+\n+        let set_str = format!(\"{}\", set);\n+\n+        assert!(set_str == ~\"{1, 2}\" || set_str == ~\"{2, 1}\");\n+        assert_eq!(format!(\"{}\", empty), ~\"{}\");\n+    }\n }"}, {"sha": "da4697d0e48804491a51e8801058a6044bac11b7", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -18,6 +18,7 @@ use iter::Iterator;\n use option::Option;\n use io::Reader;\n use vec::{OwnedVector, ImmutableVector};\n+use ptr::RawPtr;\n \n /// An iterator that reads a single byte on each iteration,\n /// until `.read_byte()` returns `None`.\n@@ -104,7 +105,7 @@ pub fn u64_from_be_bytes(data: &[u8],\n                          start: uint,\n                          size: uint)\n                       -> u64 {\n-    use ptr::{copy_nonoverlapping_memory, offset, mut_offset};\n+    use ptr::{copy_nonoverlapping_memory};\n     use mem::from_be64;\n     use vec::MutableVector;\n \n@@ -116,9 +117,9 @@ pub fn u64_from_be_bytes(data: &[u8],\n \n     let mut buf = [0u8, ..8];\n     unsafe {\n-        let ptr = offset(data.as_ptr(), start as int);\n+        let ptr = data.as_ptr().offset(start as int);\n         let out = buf.as_mut_ptr();\n-        copy_nonoverlapping_memory(mut_offset(out, (8 - size) as int), ptr, size);\n+        copy_nonoverlapping_memory(out.offset((8 - size) as int), ptr, size);\n         from_be64(*(out as *i64)) as u64\n     }\n }"}, {"sha": "14ae7c9900c4693651ee87cefe8bba317d259e8d", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -145,16 +145,18 @@ macro_rules! format(\n \n #[macro_export]\n macro_rules! write(\n-    ($dst:expr, $($arg:tt)*) => (\n-        format_args!(|args| { ::std::fmt::write($dst, args) }, $($arg)*)\n-    )\n+    ($dst:expr, $($arg:tt)*) => ({\n+        let dst: &mut ::std::io::Writer = $dst;\n+        format_args!(|args| { ::std::fmt::write(dst, args) }, $($arg)*)\n+    })\n )\n \n #[macro_export]\n macro_rules! writeln(\n-    ($dst:expr, $($arg:tt)*) => (\n-        format_args!(|args| { ::std::fmt::writeln($dst, args) }, $($arg)*)\n-    )\n+    ($dst:expr, $($arg:tt)*) => ({\n+        let dst: &mut ::std::io::Writer = $dst;\n+        format_args!(|args| { ::std::fmt::writeln(dst, args) }, $($arg)*)\n+    })\n )\n \n #[macro_export]"}, {"sha": "2ba6f7d4fd64d93fa45c48cb8753269b5d9151e9", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 9, "deletions": 34, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -21,23 +21,6 @@ use unstable::intrinsics;\n \n #[cfg(not(test))] use cmp::{Eq, Ord};\n \n-/// Calculate the offset from a pointer.\n-/// The `count` argument is in units of T; e.g. a `count` of 3\n-/// represents a pointer offset of `3 * sizeof::<T>()` bytes.\n-#[inline]\n-pub unsafe fn offset<T>(ptr: *T, count: int) -> *T {\n-    intrinsics::offset(ptr, count)\n-}\n-\n-/// Calculate the offset from a mut pointer. The count *must* be in bounds or\n-/// otherwise the loads of this address are undefined.\n-/// The `count` argument is in units of T; e.g. a `count` of 3\n-/// represents a pointer offset of `3 * sizeof::<T>()` bytes.\n-#[inline]\n-pub unsafe fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n-    intrinsics::offset(ptr as *T, count) as *mut T\n-}\n-\n /// Return the offset of the first null pointer in `buf`.\n #[inline]\n pub unsafe fn buf_len<T>(buf: **T) -> uint {\n@@ -63,7 +46,7 @@ impl<T> Clone for *mut T {\n pub unsafe fn position<T>(buf: *T, f: |&T| -> bool) -> uint {\n     let mut i = 0;\n     loop {\n-        if f(&(*offset(buf, i as int))) { return i; }\n+        if f(&(*buf.offset(i as int))) { return i; }\n         else { i += 1; }\n     }\n }\n@@ -76,14 +59,6 @@ pub fn null<T>() -> *T { 0 as *T }\n #[inline]\n pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n \n-/// Returns true if the pointer is equal to the null pointer.\n-#[inline]\n-pub fn is_null<T,P:RawPtr<T>>(ptr: P) -> bool { ptr.is_null() }\n-\n-/// Returns true if the pointer is not equal to the null pointer.\n-#[inline]\n-pub fn is_not_null<T,P:RawPtr<T>>(ptr: P) -> bool { ptr.is_not_null() }\n-\n /**\n  * Copies data from one location to another.\n  *\n@@ -206,7 +181,7 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n     }\n     //let start_ptr = *arr;\n     for e in range(0, len) {\n-        let n = offset(arr, e as int);\n+        let n = arr.offset(e as int);\n         cb(*n);\n     }\n     debug!(\"array_each_with_len: after iterate\");\n@@ -278,7 +253,7 @@ impl<T> RawPtr<T> for *T {\n     /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n     /// the object, or one-byte-past-the-end.\n     #[inline]\n-    unsafe fn offset(self, count: int) -> *T { offset(self, count) }\n+    unsafe fn offset(self, count: int) -> *T { intrinsics::offset(self, count) }\n }\n \n /// Extension methods for mutable pointers\n@@ -323,7 +298,7 @@ impl<T> RawPtr<T> for *mut T {\n     /// This method should be preferred over `offset` when the guarantee can be\n     /// satisfied, to enable better optimization.\n     #[inline]\n-    unsafe fn offset(self, count: int) -> *mut T { mut_offset(self, count) }\n+    unsafe fn offset(self, count: int) -> *mut T { intrinsics::offset(self as *T, count) as *mut T }\n }\n \n // Equality for pointers\n@@ -478,14 +453,14 @@ pub mod ptr_tests {\n             let v0 = ~[32000u16, 32001u16, 32002u16];\n             let mut v1 = ~[0u16, 0u16, 0u16];\n \n-            copy_memory(mut_offset(v1.as_mut_ptr(), 1),\n-                        offset(v0.as_ptr(), 1), 1);\n+            copy_memory(v1.as_mut_ptr().offset(1),\n+                        v0.as_ptr().offset(1), 1);\n             assert!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n             copy_memory(v1.as_mut_ptr(),\n-                        offset(v0.as_ptr(), 2), 1);\n+                        v0.as_ptr().offset(2), 1);\n             assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n                      v1[2] == 0u16));\n-            copy_memory(mut_offset(v1.as_mut_ptr(), 2),\n+            copy_memory(v1.as_mut_ptr().offset(2),\n                         v0.as_ptr(), 1u);\n             assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n                      v1[2] == 32000u16));\n@@ -525,7 +500,7 @@ pub mod ptr_tests {\n         assert!(p.is_null());\n         assert!(!p.is_not_null());\n \n-        let q = unsafe { offset(p, 1) };\n+        let q = unsafe { p.offset(1) };\n         assert!(!q.is_null());\n         assert!(q.is_not_null());\n "}, {"sha": "f88da60ae9b7971a219783371273635ad6e5a1a8", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -441,11 +441,4 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         self.align_to::<&'static u8>();\n         true\n     }\n-\n-    // NOTE Remove after next snapshot.\n-    #[cfg(stage0)]\n-    fn visit_type(&mut self) -> bool {\n-        if ! self.inner.visit_type() { return false; }\n-        true\n-    }\n }"}, {"sha": "58c00177b90165578dd5f0bf23000352ee355125", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -23,6 +23,7 @@ use io;\n use iter::Iterator;\n use option::{Some, None, Option};\n use ptr;\n+use ptr::RawPtr;\n use reflect;\n use reflect::{MovePtr, align};\n use result::{Ok, Err};\n@@ -221,7 +222,7 @@ impl<'a> ReprVisitor<'a> {\n                 if_ok!(self, self.writer.write(\", \".as_bytes()));\n             }\n             self.visit_ptr_inner(p as *u8, inner);\n-            p = align(unsafe { ptr::offset(p, sz as int) as uint }, al) as *u8;\n+            p = align(unsafe { p.offset(sz as int) as uint }, al) as *u8;\n             left -= dec;\n         }\n         if_ok!(self, self.writer.write([']' as u8]));\n@@ -601,10 +602,6 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_param(&mut self, _i: uint) -> bool { true }\n     fn visit_self(&mut self) -> bool { true }\n-\n-    // NOTE Remove after next snapshot.\n-    #[cfg(stage0)]\n-    fn visit_type(&mut self) -> bool { true }\n }\n \n pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {"}, {"sha": "4bce16706ee60c3235c710a598daf281cfe4378b", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -10,8 +10,6 @@\n \n use libc::{c_void, size_t, free, malloc, realloc};\n use ptr::{RawPtr, mut_null};\n-#[cfg(stage0)]\n-use unstable::intrinsics::TyDesc;\n use unstable::intrinsics::abort;\n use unstable::raw;\n use mem::size_of;\n@@ -75,40 +73,14 @@ pub unsafe fn exchange_malloc(size: uint) -> *u8 {\n }\n \n // FIXME: #7496\n-#[cfg(not(test), stage0)]\n-#[lang=\"closure_exchange_malloc\"]\n-#[inline]\n-pub unsafe fn closure_exchange_malloc_(td: *u8, size: uint) -> *u8 {\n-    closure_exchange_malloc(td, size)\n-}\n-\n-// FIXME: #7496\n-#[cfg(not(test), not(stage0))]\n+#[cfg(not(test))]\n #[lang=\"closure_exchange_malloc\"]\n #[inline]\n pub unsafe fn closure_exchange_malloc_(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n     closure_exchange_malloc(drop_glue, size, align)\n }\n \n #[inline]\n-#[cfg(stage0)]\n-pub unsafe fn closure_exchange_malloc(td: *u8, size: uint) -> *u8 {\n-    let td = td as *TyDesc;\n-    let size = size;\n-\n-    assert!(td.is_not_null());\n-\n-    let total_size = get_box_size(size, (*td).align);\n-    let p = malloc_raw(total_size);\n-\n-    let alloc = p as *mut raw::Box<()>;\n-    (*alloc).type_desc = td;\n-\n-    alloc as *u8\n-}\n-\n-#[inline]\n-#[cfg(not(stage0))]\n pub unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n     let total_size = get_box_size(size, align);\n     let p = malloc_raw(total_size);"}, {"sha": "023f712d3a08ad1d9f5150b1de4a9a5ff4b8921e", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -21,8 +21,6 @@ use rt::env;\n use rt::global_heap;\n use rt::local::Local;\n use rt::task::Task;\n-#[cfg(stage0)]\n-use unstable::intrinsics::TyDesc;\n use unstable::raw;\n use vec::ImmutableVector;\n \n@@ -61,29 +59,6 @@ impl LocalHeap {\n     }\n \n     #[inline]\n-    #[cfg(stage0)]\n-    pub fn alloc(&mut self, td: *TyDesc, size: uint) -> *mut Box {\n-        let total_size = global_heap::get_box_size(size, unsafe { (*td).align });\n-        let alloc = self.memory_region.malloc(total_size);\n-        {\n-            // Make sure that we can't use `mybox` outside of this scope\n-            let mybox: &mut Box = unsafe { cast::transmute(alloc) };\n-            // Clear out this box, and move it to the front of the live\n-            // allocations list\n-            mybox.type_desc = td;\n-            mybox.ref_count = 1;\n-            mybox.prev = ptr::mut_null();\n-            mybox.next = self.live_allocs;\n-            if !self.live_allocs.is_null() {\n-                unsafe { (*self.live_allocs).prev = alloc; }\n-            }\n-            self.live_allocs = alloc;\n-        }\n-        return alloc;\n-    }\n-\n-    #[inline]\n-    #[cfg(not(stage0))]\n     pub fn alloc(&mut self, drop_glue: fn(*mut u8), size: uint, align: uint) -> *mut Box {\n         let total_size = global_heap::get_box_size(size, align);\n         let alloc = self.memory_region.malloc(total_size);\n@@ -126,41 +101,6 @@ impl LocalHeap {\n     }\n \n     #[inline]\n-    #[cfg(stage0)]\n-    pub fn free(&mut self, alloc: *mut Box) {\n-        {\n-            // Make sure that we can't use `mybox` outside of this scope\n-            let mybox: &mut Box = unsafe { cast::transmute(alloc) };\n-            assert!(!mybox.type_desc.is_null());\n-\n-            // Unlink it from the linked list\n-            if !mybox.prev.is_null() {\n-                unsafe { (*mybox.prev).next = mybox.next; }\n-            }\n-            if !mybox.next.is_null() {\n-                unsafe { (*mybox.next).prev = mybox.prev; }\n-            }\n-            if self.live_allocs == alloc {\n-                self.live_allocs = mybox.next;\n-            }\n-\n-            // Destroy the box memory-wise\n-            if self.poison_on_free {\n-                unsafe {\n-                    let ptr: *mut u8 = cast::transmute(&mybox.data);\n-                    ptr::set_memory(ptr, 0xab, (*mybox.type_desc).size);\n-                }\n-            }\n-            mybox.prev = ptr::mut_null();\n-            mybox.next = ptr::mut_null();\n-            mybox.type_desc = ptr::null();\n-        }\n-\n-        self.memory_region.free(alloc);\n-    }\n-\n-    #[inline]\n-    #[cfg(not(stage0))]\n     pub fn free(&mut self, alloc: *mut Box) {\n         {\n             // Make sure that we can't use `mybox` outside of this scope\n@@ -339,20 +279,6 @@ impl Drop for MemoryRegion {\n }\n \n #[inline]\n-#[cfg(stage0)]\n-pub unsafe fn local_malloc(td: *u8, size: uint) -> *u8 {\n-    // FIXME: Unsafe borrow for speed. Lame.\n-    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n-    match task {\n-        Some(task) => {\n-            (*task).heap.alloc(td as *TyDesc, size) as *u8\n-        }\n-        None => rtabort!(\"local malloc outside of task\")\n-    }\n-}\n-\n-#[inline]\n-#[cfg(not(stage0))]\n pub unsafe fn local_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n     // FIXME: Unsafe borrow for speed. Lame.\n     let task: Option<*mut Task> = Local::try_unsafe_borrow();"}, {"sha": "0d263d94ccf0f26992fff841b83c63de0c51d0d2", "filename": "src/libstd/str.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -1242,7 +1242,7 @@ pub mod raw {\n         let mut i = 0;\n         while *curr != 0 {\n             i += 1;\n-            curr = ptr::offset(buf, i);\n+            curr = buf.offset(i);\n         }\n         from_buf_len(buf as *u8, i as uint)\n     }\n@@ -1272,7 +1272,7 @@ pub mod raw {\n         let mut len = 0u;\n         while *curr != 0u8 {\n             len += 1u;\n-            curr = ptr::offset(s, len as int);\n+            curr = s.offset(len as int);\n         }\n         let v = Slice { data: s, len: len };\n         assert!(is_utf8(::cast::transmute(v)));\n@@ -2921,7 +2921,6 @@ impl Default for ~str {\n mod tests {\n     use iter::AdditiveIterator;\n     use prelude::*;\n-    use ptr;\n     use str::*;\n \n     #[test]\n@@ -3549,11 +3548,11 @@ mod tests {\n     fn test_as_ptr() {\n         let buf = \"hello\".as_ptr();\n         unsafe {\n-            assert_eq!(*ptr::offset(buf, 0), 'h' as u8);\n-            assert_eq!(*ptr::offset(buf, 1), 'e' as u8);\n-            assert_eq!(*ptr::offset(buf, 2), 'l' as u8);\n-            assert_eq!(*ptr::offset(buf, 3), 'l' as u8);\n-            assert_eq!(*ptr::offset(buf, 4), 'o' as u8);\n+            assert_eq!(*buf.offset(0), 'h' as u8);\n+            assert_eq!(*buf.offset(1), 'e' as u8);\n+            assert_eq!(*buf.offset(2), 'l' as u8);\n+            assert_eq!(*buf.offset(3), 'l' as u8);\n+            assert_eq!(*buf.offset(4), 'o' as u8);\n         }\n     }\n \n@@ -4164,13 +4163,15 @@ mod tests {\n         assert_eq!(s.len(), 5);\n         assert_eq!(s.as_slice(), \"abcde\");\n         assert_eq!(s.to_str(), ~\"abcde\");\n+        assert_eq!(format!(\"{}\", s), ~\"abcde\");\n         assert!(s.lt(&Owned(~\"bcdef\")));\n         assert_eq!(Slice(\"\"), Default::default());\n \n         let o = Owned(~\"abcde\");\n         assert_eq!(o.len(), 5);\n         assert_eq!(o.as_slice(), \"abcde\");\n         assert_eq!(o.to_str(), ~\"abcde\");\n+        assert_eq!(format!(\"{}\", o), ~\"abcde\");\n         assert!(o.lt(&Slice(\"bcdef\")));\n         assert_eq!(Owned(~\"\"), Default::default());\n "}, {"sha": "b23dafbca697062e602dc4b800e91cea13ecf920", "filename": "src/libstd/unit.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funit.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -14,6 +14,7 @@\n use default::Default;\n #[cfg(not(test))]\n use cmp::{Eq, Equal, Ord, Ordering, TotalEq, TotalOrd};\n+use fmt;\n \n #[cfg(not(test))]\n impl Eq for () {\n@@ -46,3 +47,9 @@ impl Default for () {\n     #[inline]\n     fn default() -> () { () }\n }\n+\n+impl fmt::Show for () {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"()\")\n+    }\n+}"}, {"sha": "c983d82563caf7000a44aae32f074d1c70f378dc", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -160,10 +160,6 @@ pub trait TyVisitor {\n     fn visit_trait(&mut self, name: &str) -> bool;\n     fn visit_param(&mut self, i: uint) -> bool;\n     fn visit_self(&mut self) -> bool;\n-\n-    // NOTE Remove after next snapshot.\n-    #[cfg(stage0)]\n-    fn visit_type(&mut self) -> bool;\n }\n \n extern \"rust-intrinsic\" {"}, {"sha": "4648f149a9fed92c287939d30f67c5e02cce9a5f", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -27,14 +27,6 @@ pub fn fail_bounds_check(file: *u8, line: uint, index: uint, len: uint) -> ! {\n }\n \n #[lang=\"malloc\"]\n-#[cfg(stage0)]\n-#[inline]\n-pub unsafe fn local_malloc(td: *u8, size: uint) -> *u8 {\n-    ::rt::local_heap::local_malloc(td, size)\n-}\n-\n-#[lang=\"malloc\"]\n-#[cfg(not(stage0))]\n #[inline]\n pub unsafe fn local_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n     ::rt::local_heap::local_malloc(drop_glue, size, align)"}, {"sha": "87547997798f5f1049107c46033fbc2a7c0aa70c", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -9,21 +9,8 @@\n // except according to those terms.\n \n use cast;\n-#[cfg(stage0)]\n-use unstable::intrinsics::TyDesc;\n \n /// The representation of a Rust managed box\n-#[cfg(stage0)]\n-pub struct Box<T> {\n-    ref_count: uint,\n-    type_desc: *TyDesc,\n-    prev: *mut Box<T>,\n-    next: *mut Box<T>,\n-    data: T\n-}\n-\n-/// The representation of a Rust managed box\n-#[cfg(not(stage0))]\n pub struct Box<T> {\n     ref_count: uint,\n     drop_glue: fn(ptr: *mut u8),"}, {"sha": "c67b19933d37fe352d09177988ae2f892747534a", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 53, "deletions": 10, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -108,13 +108,15 @@ use container::{Container, Mutable};\n use cmp::{Eq, TotalOrd, Ordering, Less, Equal, Greater};\n use cmp;\n use default::Default;\n+#[cfg(not(stage0))] use fmt;\n use iter::*;\n use num::{Integer, CheckedAdd, Saturating, checked_next_power_of_two};\n use option::{None, Option, Some};\n use ptr::to_unsafe_ptr;\n use ptr;\n use ptr::RawPtr;\n use rt::global_heap::{malloc_raw, realloc_raw, exchange_free};\n+#[cfg(not(stage0))] use result::{Ok, Err};\n use mem;\n use mem::size_of;\n use kinds::marker;\n@@ -137,7 +139,7 @@ pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> ~[T] {\n             &mut i, (),\n             |i, ()| while *i < n_elts {\n                 mem::move_val_init(\n-                    &mut(*ptr::mut_offset(p, *i as int)),\n+                    &mut(*p.offset(*i as int)),\n                     op(*i));\n                 *i += 1u;\n             },\n@@ -165,7 +167,7 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n             &mut i, (),\n             |i, ()| while *i < n_elts {\n                 mem::move_val_init(\n-                    &mut(*ptr::mut_offset(p, *i as int)),\n+                    &mut(*p.offset(*i as int)),\n                     t.clone());\n                 *i += 1u;\n             },\n@@ -1495,7 +1497,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             let fill = (**repr).fill;\n             (**repr).fill += mem::nonzero_size_of::<T>();\n             let p = to_unsafe_ptr(&((**repr).data));\n-            let p = ptr::offset(p, fill as int) as *mut T;\n+            let p = p.offset(fill as int) as *mut T;\n             mem::move_val_init(&mut(*p), t);\n         }\n     }\n@@ -1509,7 +1511,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         unsafe { // Note: infallible.\n             let self_p = self.as_mut_ptr();\n             let rhs_p = rhs.as_ptr();\n-            ptr::copy_memory(ptr::mut_offset(self_p, self_len as int), rhs_p, rhs_len);\n+            ptr::copy_memory(self_p.offset(self_len as int), rhs_p, rhs_len);\n             self.set_len(new_len);\n             rhs.set_len(0);\n         }\n@@ -1796,11 +1798,11 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n             let mut w = 1;\n \n             while r < ln {\n-                let p_r = ptr::mut_offset(p, r as int);\n-                let p_wm1 = ptr::mut_offset(p, (w - 1) as int);\n+                let p_r = p.offset(r as int);\n+                let p_wm1 = p.offset((w - 1) as int);\n                 if *p_r != *p_wm1 {\n                     if r != w {\n-                        let p_w = ptr::mut_offset(p_wm1, 1);\n+                        let p_w = p_wm1.offset(1);\n                         mem::swap(&mut *p_r, &mut *p_w);\n                     }\n                     w += 1;\n@@ -2383,7 +2385,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n \n     #[inline]\n     unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {\n-        cast::transmute(ptr::mut_offset(self.repr().data as *mut T, index as int))\n+        cast::transmute((self.repr().data as *mut T).offset(index as int))\n     }\n \n     #[inline]\n@@ -2484,6 +2486,7 @@ pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n pub mod raw {\n     use cast;\n     use ptr;\n+    use ptr::RawPtr;\n     use vec::{with_capacity, MutableVector, OwnedVector};\n     use unstable::raw::Slice;\n \n@@ -2542,7 +2545,7 @@ pub mod raw {\n     pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> *T {\n         if slice.len == 0 { fail!(\"shift on empty slice\"); }\n         let head: *T = slice.data;\n-        slice.data = ptr::offset(slice.data, 1);\n+        slice.data = slice.data.offset(1);\n         slice.len -= 1;\n         head\n     }\n@@ -2554,7 +2557,7 @@ pub mod raw {\n      */\n     pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> *T {\n         if slice.len == 0 { fail!(\"pop on empty slice\"); }\n-        let tail: *T = ptr::offset(slice.data, (slice.len - 1) as int);\n+        let tail: *T = slice.data.offset((slice.len - 1) as int);\n         slice.len -= 1;\n         tail\n     }\n@@ -2640,6 +2643,30 @@ impl<A: DeepClone> DeepClone for ~[A] {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'a, T: fmt::Show> fmt::Show for &'a [T] {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if_ok!(write!(f.buf, \"[\"));\n+        let mut is_first = true;\n+        for x in self.iter() {\n+            if is_first {\n+                is_first = false;\n+            } else {\n+                if_ok!(write!(f.buf, \", \"));\n+            }\n+            if_ok!(write!(f.buf, \"{}\", *x))\n+        }\n+        write!(f.buf, \"]\")\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<T: fmt::Show> fmt::Show for ~[T] {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.as_slice().fmt(f)\n+    }\n+}\n+\n // This works because every lifetime is a sub-lifetime of 'static\n impl<'a, A> Default for &'a [A] {\n     fn default() -> &'a [A] { &'a [] }\n@@ -4049,6 +4076,22 @@ mod tests {\n         assert_eq!(values, [1,4,3,2,5]);\n     }\n \n+    #[test]\n+    fn test_show() {\n+        macro_rules! test_show_vec(\n+            ($x:expr, $x_str:expr) => ({\n+                let (x, x_str) = ($x, $x_str);\n+                assert_eq!(format!(\"{}\", x), x_str);\n+                assert_eq!(format!(\"{}\", x.as_slice()), x_str);\n+            })\n+        )\n+        let empty: ~[int] = ~[];\n+        test_show_vec!(empty, ~\"[]\");\n+        test_show_vec!(~[1], ~\"[1]\");\n+        test_show_vec!(~[1, 2, 3], ~\"[1, 2, 3]\");\n+        test_show_vec!(~[~[], ~[1u], ~[1u, 1u]], ~\"[[], [1], [1, 1]]\");\n+    }\n+\n     #[test]\n     fn test_vec_default() {\n         use default::Default;"}, {"sha": "25ba45021b3fa0364bb9571ec92aa5f87e556727", "filename": "src/libstd/vec_ng.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fvec_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibstd%2Fvec_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec_ng.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -22,7 +22,8 @@ use cast::{forget, transmute};\n use rt::global_heap::{malloc_raw, realloc_raw};\n use vec::{ImmutableVector, Items, MutableVector};\n use unstable::raw::Slice;\n-use ptr::{offset, read_ptr};\n+use ptr::read_ptr;\n+use ptr::RawPtr;\n use libc::{free, c_void};\n \n pub struct Vec<T> {\n@@ -135,7 +136,7 @@ impl<T> Vec<T> {\n         }\n \n         unsafe {\n-            let end = offset(self.ptr as *T, self.len as int) as *mut T;\n+            let end = (self.ptr as *T).offset(self.len as int) as *mut T;\n             move_val_init(&mut *end, value);\n             self.len += 1;\n         }"}, {"sha": "02c3a1b985be3cea98e34ef3433045dd2d78c7ae", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -20,7 +20,6 @@ use parse::token::{InternedString, intern, str_to_ident};\n use util::small_vector::SmallVector;\n \n use std::hashmap::HashMap;\n-use std::unstable::dynamic_lib::DynamicLibrary;\n \n // new-style macro! tt code:\n //\n@@ -143,16 +142,13 @@ pub struct BlockInfo {\n     macros_escape : bool,\n     // what are the pending renames?\n     pending_renames : RenameList,\n-    // references for crates loaded in this scope\n-    macro_crates: ~[DynamicLibrary],\n }\n \n impl BlockInfo {\n     pub fn new() -> BlockInfo {\n         BlockInfo {\n             macros_escape: false,\n             pending_renames: ~[],\n-            macro_crates: ~[],\n         }\n     }\n }\n@@ -551,10 +547,6 @@ impl SyntaxEnv {\n         self.find_escape_frame().map.insert(k, v);\n     }\n \n-    pub fn insert_macro_crate(&mut self, lib: DynamicLibrary) {\n-        self.find_escape_frame().info.macro_crates.push(lib);\n-    }\n-\n     pub fn info<'a>(&'a mut self) -> &'a mut BlockInfo {\n         &mut self.chain[self.chain.len()-1].info\n     }"}, {"sha": "d79c4cbc96a9be1a596df35310cd2a49300cc85f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -28,6 +28,7 @@ use visit;\n use visit::Visitor;\n use util::small_vector::SmallVector;\n \n+use std::cast;\n use std::vec;\n use std::unstable::dynamic_lib::DynamicLibrary;\n use std::os;\n@@ -469,9 +470,12 @@ fn load_extern_macros(crate: &ast::ViewItem, fld: &mut MacroExpander) {\n             };\n             fld.extsbox.insert(name, extension);\n         });\n-    }\n \n-    fld.extsbox.insert_macro_crate(lib);\n+        // Intentionally leak the dynamic library. We can't ever unload it\n+        // since the library can do things that will outlive the expansion\n+        // phase (e.g. make an @-box cycle or launch a task).\n+        cast::forget(lib);\n+    }\n }\n \n // expand a stmt"}, {"sha": "2db884fdb6436d2df391db5fdab3c688924638bb", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -1,3 +1,11 @@\n+S 2014-02-12 c62f6ce\n+  freebsd-x86_64 737a423c5f803119ff5a692eac432fa9d0c595a8\n+  linux-i386 a7e90e27e8b6a3fa79ddc15f0ed217ccbade875d\n+  linux-x86_64 8f5fdf9f07b2afbc55d8d8c06c60aeb532b5ea83\n+  macos-i386 57bb225f45bc57fef4c34552a2d5814ab4913087\n+  macos-x86_64 d37b62478aa1c1dd1babb19d1df494d2aaf59c4c\n+  winnt-i386 2c5c5f7228140cd79f120201805504a9e07ad245\n+\n S 2014-02-03 346d378\n   freebsd-x86_64 d369c1a83a2be6eb42bd0e550a1adc38ffed0804\n   linux-i386 a6d4ab441f5b285d7aecbb940fa733526b413f34"}, {"sha": "eecbb325630d352c1c59d5fec5fcffe42cc88a8b", "filename": "src/test/auxiliary/macro_crate_outlive_expansion_phase.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Ftest%2Fauxiliary%2Fmacro_crate_outlive_expansion_phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Ftest%2Fauxiliary%2Fmacro_crate_outlive_expansion_phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_outlive_expansion_phase.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+\n+#[feature(macro_registrar)];\n+\n+extern mod syntax;\n+\n+use std::any::Any;\n+use std::local_data;\n+use syntax::ast::Name;\n+use syntax::ext::base::SyntaxExtension;\n+\n+struct Foo {\n+    foo: int\n+}\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {}\n+}\n+\n+#[macro_registrar]\n+pub fn registrar(_: |Name, SyntaxExtension|) {\n+    local_data_key!(foo: ~Any);\n+    local_data::set(foo, ~Foo { foo: 10 } as ~Any);\n+}\n+"}, {"sha": "a71cc465e88dc6b3b08510e94ff8a5f74e12fab1", "filename": "src/test/run-pass-fulldeps/macro-crate-outlive-expansion-phase.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-outlive-expansion-phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-outlive-expansion-phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-outlive-expansion-phase.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_outlive_expansion_phase.rs\n+// ignore-stage1\n+// ignore-fast\n+// ignore-android\n+\n+#[feature(phase)];\n+\n+#[phase(syntax)]\n+extern mod macro_crate_outlive_expansion_phase;\n+\n+pub fn main() {}"}, {"sha": "55bac0a0e078ced1c1e64f225761d2159d009d1b", "filename": "src/test/run-pass/colorful-write-macros.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(unused_must_use, dead_code)];\n+\n+use std::io::MemWriter;\n+\n+struct Foo<'a> {\n+    writer: &'a mut Writer,\n+    other: &'a str,\n+}\n+\n+fn borrowing_writer_from_struct_and_formatting_struct_field(foo: Foo) {\n+    write!(foo.writer, \"{}\", foo.other);\n+}\n+\n+pub fn main() {\n+    let mut w = MemWriter::new();\n+    write!(&mut w as &mut Writer, \"\");\n+    write!(&mut w, \"\"); // should coerce\n+}"}, {"sha": "240a134221d3473c2ff08b69d982c04f21797516", "filename": "src/test/run-pass/issue-9918.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Ftest%2Frun-pass%2Fissue-9918.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d453e459107ed1c5d76f693686b29d31cdc58c/src%2Ftest%2Frun-pass%2Fissue-9918.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9918.rs?ref=94d453e459107ed1c5d76f693686b29d31cdc58c", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    assert_eq!((0 + 0u8) as char, '\\0');\n+}"}]}