{"sha": "b7071b2353199cd438f15dd3068a9d64d3fab93c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MDcxYjIzNTMxOTljZDQzOGYxNWRkMzA2OGE5ZDY0ZDNmYWI5M2M=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-01-06T20:50:02Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-01-11T20:49:47Z"}, "message": "resolve: Simplify collection of traits in scope", "tree": {"sha": "7765a81bd8f924190090cc2c7e35cfd9af747c76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7765a81bd8f924190090cc2c7e35cfd9af747c76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7071b2353199cd438f15dd3068a9d64d3fab93c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7071b2353199cd438f15dd3068a9d64d3fab93c", "html_url": "https://github.com/rust-lang/rust/commit/b7071b2353199cd438f15dd3068a9d64d3fab93c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7071b2353199cd438f15dd3068a9d64d3fab93c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6526e5c772f2da07db745c94ca6bb0a591a39ba4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6526e5c772f2da07db745c94ca6bb0a591a39ba4", "html_url": "https://github.com/rust-lang/rust/commit/6526e5c772f2da07db745c94ca6bb0a591a39ba4"}], "stats": {"total": 300, "additions": 139, "deletions": 161}, "files": [{"sha": "4ab14c158d337835fce8661db6534596602e17d3", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7071b2353199cd438f15dd3068a9d64d3fab93c/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7071b2353199cd438f15dd3068a9d64d3fab93c/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=b7071b2353199cd438f15dd3068a9d64d3fab93c", "patch": "@@ -115,7 +115,7 @@ impl<'a> Resolver<'a> {\n         self.get_module(parent_id)\n     }\n \n-    crate fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n+    pub fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n         // If this is a local module, it will be in `module_map`, no need to recalculate it.\n         if let Some(def_id) = def_id.as_local() {\n             return self.module_map[&def_id];"}, {"sha": "025bb24dfe86e7d98ba5a0713287a7cd2b4e95b1", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b7071b2353199cd438f15dd3068a9d64d3fab93c/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7071b2353199cd438f15dd3068a9d64d3fab93c/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=b7071b2353199cd438f15dd3068a9d64d3fab93c", "patch": "@@ -14,7 +14,6 @@ use crate::{ResolutionError, Resolver, Segment, UseError};\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::*;\n-use rustc_ast::{unwrap_or, walk_list};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::DiagnosticId;\n@@ -1911,7 +1910,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // it needs to be added to the trait map.\n                 if ns == ValueNS {\n                     let item_name = path.last().unwrap().ident;\n-                    let traits = self.get_traits_containing_item(item_name, ns);\n+                    let traits = self.traits_in_scope(item_name, ns);\n                     self.r.trait_map.insert(id, traits);\n                 }\n \n@@ -2372,12 +2371,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.get_traits_containing_item(ident, ValueNS);\n+                let traits = self.traits_in_scope(ident, ValueNS);\n                 self.r.trait_map.insert(expr.id, traits);\n             }\n             ExprKind::MethodCall(ref segment, ..) => {\n                 debug!(\"(recording candidate traits for expr) recording traits for {}\", expr.id);\n-                let traits = self.get_traits_containing_item(segment.ident, ValueNS);\n+                let traits = self.traits_in_scope(segment.ident, ValueNS);\n                 self.r.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n@@ -2386,64 +2385,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n     }\n \n-    fn get_traits_containing_item(\n-        &mut self,\n-        mut ident: Ident,\n-        ns: Namespace,\n-    ) -> Vec<TraitCandidate> {\n-        debug!(\"(getting traits containing item) looking for '{}'\", ident.name);\n-\n-        let mut found_traits = Vec::new();\n-        // Look for the current trait.\n-        if let Some((module, _)) = self.current_trait_ref {\n-            if self\n-                .r\n-                .resolve_ident_in_module(\n-                    ModuleOrUniformRoot::Module(module),\n-                    ident,\n-                    ns,\n-                    &self.parent_scope,\n-                    false,\n-                    module.span,\n-                )\n-                .is_ok()\n-            {\n-                let def_id = module.def_id().unwrap();\n-                found_traits.push(TraitCandidate { def_id, import_ids: smallvec![] });\n-            }\n-        }\n-\n-        ident.span = ident.span.normalize_to_macros_2_0();\n-        let mut search_module = self.parent_scope.module;\n-        loop {\n-            self.r.get_traits_in_module_containing_item(\n-                ident,\n-                ns,\n-                search_module,\n-                &mut found_traits,\n-                &self.parent_scope,\n-            );\n-            let mut span_data = ident.span.data();\n-            search_module = unwrap_or!(\n-                self.r.hygienic_lexical_parent(search_module, &mut span_data.ctxt),\n-                break\n-            );\n-            ident.span = span_data.span();\n-        }\n-\n-        if let Some(prelude) = self.r.prelude {\n-            if !search_module.no_implicit_prelude {\n-                self.r.get_traits_in_module_containing_item(\n-                    ident,\n-                    ns,\n-                    prelude,\n-                    &mut found_traits,\n-                    &self.parent_scope,\n-                );\n-            }\n-        }\n-\n-        found_traits\n+    fn traits_in_scope(&mut self, ident: Ident, ns: Namespace) -> Vec<TraitCandidate> {\n+        self.r.traits_in_scope(\n+            self.current_trait_ref.as_ref().map(|(module, _)| *module),\n+            &self.parent_scope,\n+            ident.span.ctxt(),\n+            Some((ident.name, ns)),\n+        )\n     }\n }\n "}, {"sha": "fa2b9b823a7be7e0d40112b7042110aba5229b86", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 63, "deletions": 64, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/b7071b2353199cd438f15dd3068a9d64d3fab93c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7071b2353199cd438f15dd3068a9d64d3fab93c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=b7071b2353199cd438f15dd3068a9d64d3fab93c", "patch": "@@ -44,9 +44,9 @@ use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::hir::exports::ExportMap;\n use rustc_middle::middle::cstore::{CrateStore, MetadataLoaderDyn};\n+use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, ResolverOutputs};\n-use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::Session;\n@@ -1477,49 +1477,76 @@ impl<'a> Resolver<'a> {\n         self.crate_loader.postprocess(krate);\n     }\n \n-    fn get_traits_in_module_containing_item(\n+    pub fn traits_in_scope(\n+        &mut self,\n+        current_trait: Option<Module<'a>>,\n+        parent_scope: &ParentScope<'a>,\n+        ctxt: SyntaxContext,\n+        assoc_item: Option<(Symbol, Namespace)>,\n+    ) -> Vec<TraitCandidate> {\n+        let mut found_traits = Vec::new();\n+\n+        if let Some(module) = current_trait {\n+            if self.trait_may_have_item(Some(module), assoc_item) {\n+                let def_id = module.def_id().unwrap();\n+                found_traits.push(TraitCandidate { def_id, import_ids: smallvec![] });\n+            }\n+        }\n+\n+        self.visit_scopes(ScopeSet::All(TypeNS, false), parent_scope, ctxt, |this, scope, _, _| {\n+            match scope {\n+                Scope::Module(module) => {\n+                    this.traits_in_module(module, assoc_item, &mut found_traits);\n+                }\n+                Scope::StdLibPrelude => {\n+                    if let Some(module) = this.prelude {\n+                        this.traits_in_module(module, assoc_item, &mut found_traits);\n+                    }\n+                }\n+                Scope::ExternPrelude | Scope::ToolPrelude | Scope::BuiltinTypes => {}\n+                _ => unreachable!(),\n+            }\n+            None::<()>\n+        });\n+\n+        found_traits\n+    }\n+\n+    fn traits_in_module(\n         &mut self,\n-        ident: Ident,\n-        ns: Namespace,\n         module: Module<'a>,\n+        assoc_item: Option<(Symbol, Namespace)>,\n         found_traits: &mut Vec<TraitCandidate>,\n-        parent_scope: &ParentScope<'a>,\n     ) {\n-        assert!(ns == TypeNS || ns == ValueNS);\n         module.ensure_traits(self);\n         let traits = module.traits.borrow();\n+        for (trait_name, trait_binding) in traits.as_ref().unwrap().iter() {\n+            if self.trait_may_have_item(trait_binding.module(), assoc_item) {\n+                let def_id = trait_binding.res().def_id();\n+                let import_ids = self.find_transitive_imports(&trait_binding.kind, *trait_name);\n+                found_traits.push(TraitCandidate { def_id, import_ids });\n+            }\n+        }\n+    }\n \n-        for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-            // Traits have pseudo-modules that can be used to search for the given ident.\n-            if let Some(module) = binding.module() {\n-                let mut ident = ident;\n-                if ident.span.glob_adjust(module.expansion, binding.span).is_none() {\n-                    continue;\n-                }\n-                if self\n-                    .resolve_ident_in_module_unadjusted(\n-                        ModuleOrUniformRoot::Module(module),\n-                        ident,\n-                        ns,\n-                        parent_scope,\n-                        false,\n-                        module.span,\n-                    )\n-                    .is_ok()\n-                {\n-                    let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n-                    let trait_def_id = module.def_id().unwrap();\n-                    found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n-                }\n-            } else if let Res::Def(DefKind::TraitAlias, _) = binding.res() {\n-                // For now, just treat all trait aliases as possible candidates, since we don't\n-                // know if the ident is somewhere in the transitive bounds.\n-                let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n-                let trait_def_id = binding.res().def_id();\n-                found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n-            } else {\n-                bug!(\"candidate is not trait or trait alias?\")\n+    // List of traits in scope is pruned on best effort basis. We reject traits not having an\n+    // associated item with the given name and namespace (if specified). This is a conservative\n+    // optimization, proper hygienic type-based resolution of associated items is done in typeck.\n+    // We don't reject trait aliases (`trait_module == None`) because we don't have access to their\n+    // associated items.\n+    fn trait_may_have_item(\n+        &mut self,\n+        trait_module: Option<Module<'a>>,\n+        assoc_item: Option<(Symbol, Namespace)>,\n+    ) -> bool {\n+        match (trait_module, assoc_item) {\n+            (Some(trait_module), Some((name, ns))) => {\n+                self.resolutions(trait_module).borrow().iter().any(|resolution| {\n+                    let (&BindingKey { ident: assoc_ident, ns: assoc_ns, .. }, _) = resolution;\n+                    assoc_ns == ns && assoc_ident.name == name\n+                })\n             }\n+            _ => true,\n         }\n     }\n \n@@ -3227,34 +3254,6 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    /// This is equivalent to `get_traits_in_module_containing_item`, but without filtering by the associated item.\n-    ///\n-    /// This is used by rustdoc for intra-doc links.\n-    pub fn traits_in_scope(&mut self, module_id: DefId) -> Vec<TraitCandidate> {\n-        let module = self.get_module(module_id);\n-        module.ensure_traits(self);\n-        let traits = module.traits.borrow();\n-        let to_candidate =\n-            |this: &mut Self, &(trait_name, binding): &(Ident, &NameBinding<'_>)| TraitCandidate {\n-                def_id: binding.res().def_id(),\n-                import_ids: this.find_transitive_imports(&binding.kind, trait_name),\n-            };\n-\n-        let mut candidates: Vec<_> =\n-            traits.as_ref().unwrap().iter().map(|x| to_candidate(self, x)).collect();\n-\n-        if let Some(prelude) = self.prelude {\n-            if !module.no_implicit_prelude {\n-                prelude.ensure_traits(self);\n-                candidates.extend(\n-                    prelude.traits.borrow().as_ref().unwrap().iter().map(|x| to_candidate(self, x)),\n-                );\n-            }\n-        }\n-\n-        candidates\n-    }\n-\n     /// Rustdoc uses this to resolve things in a recoverable way. `ResolutionError<'a>`\n     /// isn't something that can be returned because it can't be made to live that long,\n     /// and also it's a private type. Fortunately rustdoc doesn't need to know the error,"}, {"sha": "4b5eb4850a3f3a73a50abd32d7c255064c74510f", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b7071b2353199cd438f15dd3068a9d64d3fab93c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7071b2353199cd438f15dd3068a9d64d3fab93c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=b7071b2353199cd438f15dd3068a9d64d3fab93c", "patch": "@@ -19,7 +19,7 @@ use rustc_session::lint::{\n     builtin::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS},\n     Lint,\n };\n-use rustc_span::hygiene::MacroKind;\n+use rustc_span::hygiene::{MacroKind, SyntaxContext};\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n@@ -770,7 +770,12 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n     let mut cache = cx.module_trait_cache.borrow_mut();\n     let in_scope_traits = cache.entry(module).or_insert_with(|| {\n         cx.enter_resolver(|resolver| {\n-            resolver.traits_in_scope(module).into_iter().map(|candidate| candidate.def_id).collect()\n+            let parent_scope = &ParentScope::module(resolver.get_module(module), resolver);\n+            resolver\n+                .traits_in_scope(None, parent_scope, SyntaxContext::root(), None)\n+                .into_iter()\n+                .map(|candidate| candidate.def_id)\n+                .collect()\n         })\n     });\n "}, {"sha": "548bb226b713cf7479b74b044e637eba479e5686", "filename": "src/test/ui/hygiene/traits-in-scope.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b7071b2353199cd438f15dd3068a9d64d3fab93c/src%2Ftest%2Fui%2Fhygiene%2Ftraits-in-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7071b2353199cd438f15dd3068a9d64d3fab93c/src%2Ftest%2Fui%2Fhygiene%2Ftraits-in-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ftraits-in-scope.rs?ref=b7071b2353199cd438f15dd3068a9d64d3fab93c", "patch": "@@ -0,0 +1,53 @@\n+// Macros with def-site hygiene still bring traits into scope.\n+// It is not clear whether this is desirable behavior or not.\n+// It is also not clear how to prevent it if it is not desirable.\n+\n+// check-pass\n+\n+#![feature(decl_macro)]\n+#![feature(trait_alias)]\n+\n+mod traits {\n+    pub trait Trait1 {\n+        fn simple_import(&self) {}\n+    }\n+    pub trait Trait2 {\n+        fn renamed_import(&self) {}\n+    }\n+    pub trait Trait3 {\n+        fn underscore_import(&self) {}\n+    }\n+    pub trait Trait4 {\n+        fn trait_alias(&self) {}\n+    }\n+\n+    impl Trait1 for () {}\n+    impl Trait2 for () {}\n+    impl Trait3 for () {}\n+    impl Trait4 for () {}\n+}\n+\n+macro m1() {\n+    use traits::Trait1;\n+}\n+macro m2() {\n+    use traits::Trait2 as Alias;\n+}\n+macro m3() {\n+    use traits::Trait3 as _;\n+}\n+macro m4() {\n+    trait Alias = traits::Trait4;\n+}\n+\n+fn main() {\n+    m1!();\n+    m2!();\n+    m3!();\n+    m4!();\n+\n+    ().simple_import();\n+    ().renamed_import();\n+    ().underscore_import();\n+    ().trait_alias();\n+}"}, {"sha": "c4db65245386f6641c8b6e156d22ba395b14f60a", "filename": "src/test/ui/underscore-imports/hygiene.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7071b2353199cd438f15dd3068a9d64d3fab93c/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7071b2353199cd438f15dd3068a9d64d3fab93c/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs?ref=b7071b2353199cd438f15dd3068a9d64d3fab93c", "patch": "@@ -1,13 +1,13 @@\n-// Make sure that underscore imports have the same hygiene considerations as\n-// other imports.\n+// Make sure that underscore imports have the same hygiene considerations as other imports.\n+\n+// check-pass\n \n #![feature(decl_macro)]\n \n mod x {\n     pub use std::ops::Deref as _;\n }\n \n-\n macro glob_import() {\n     pub use crate::x::*;\n }\n@@ -35,6 +35,6 @@ fn main() {\n     use crate::z::*;\n     glob_import!();\n     underscore_import!();\n-    (&()).deref();              //~ ERROR no method named `deref`\n-    (&mut ()).deref_mut();      //~ ERROR no method named `deref_mut`\n+    (&()).deref();\n+    (&mut ()).deref_mut();\n }"}, {"sha": "2983613786038ec12c506d3085c3e29d4392ac3b", "filename": "src/test/ui/underscore-imports/hygiene.stderr", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6526e5c772f2da07db745c94ca6bb0a591a39ba4/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6526e5c772f2da07db745c94ca6bb0a591a39ba4/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr?ref=6526e5c772f2da07db745c94ca6bb0a591a39ba4", "patch": "@@ -1,27 +0,0 @@\n-error[E0599]: no method named `deref` found for reference `&()` in the current scope\n-  --> $DIR/hygiene.rs:38:11\n-   |\n-LL |     (&()).deref();\n-   |           ^^^^^ method not found in `&()`\n-   |\n-   = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n-   |\n-LL | use std::ops::Deref;\n-   |\n-\n-error[E0599]: no method named `deref_mut` found for mutable reference `&mut ()` in the current scope\n-  --> $DIR/hygiene.rs:39:15\n-   |\n-LL |     (&mut ()).deref_mut();\n-   |               ^^^^^^^^^ method not found in `&mut ()`\n-   |\n-   = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n-   |\n-LL | use std::ops::DerefMut;\n-   |\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0599`."}]}