{"sha": "cc34dbb84090f74c84037afb269003f13aa46b78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMzRkYmI4NDA5MGY3NGM4NDAzN2FmYjI2OTAwM2YxM2FhNDZiNzg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-11T03:59:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-12T17:46:31Z"}, "message": "Expose whether event loops have active I/O\n\nThe green scheduler can optimize its runtime based on this by deciding to not go\nto sleep in epoll() if there is no active I/O and there is a task to be stolen.\n\nThis is implemented for librustuv by keeping a count of the number of tasks\nwhich are currently homed. If a task is homed, and then performs a blocking I/O\noperation, the count will be nonzero while the task is blocked. The homing count\nis intentionally 0 when there are I/O handles, but no handles currently blocked.\nThe reason for this is that epoll() would only be used to wake up the scheduler\nanyway.\n\nThe crux of this change was to have a `HomingMissile` contain a mutable borrowed\nreference back to the `HomeHandle`. The rest of the change was just dealing with\nthis fallout. This reference is used to decrement the homed handle count in a\nHomingMissile's destructor.\n\nAlso note that the count maintained is not atomic because all of its\nincrements/decrements/reads are all on the same I/O thread.", "tree": {"sha": "5c23a0f081b5206c2582e8064109da8ac6c5649c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c23a0f081b5206c2582e8064109da8ac6c5649c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc34dbb84090f74c84037afb269003f13aa46b78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc34dbb84090f74c84037afb269003f13aa46b78", "html_url": "https://github.com/rust-lang/rust/commit/cc34dbb84090f74c84037afb269003f13aa46b78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc34dbb84090f74c84037afb269003f13aa46b78/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d5c52d8a1d9cc5750aadfbb707584466083ef47", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d5c52d8a1d9cc5750aadfbb707584466083ef47", "html_url": "https://github.com/rust-lang/rust/commit/1d5c52d8a1d9cc5750aadfbb707584466083ef47"}], "stats": {"total": 85, "additions": 60, "deletions": 25}, "files": [{"sha": "5bccf05f7b3f6ed4f661dd1173fcb433fdcc6c22", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=cc34dbb84090f74c84037afb269003f13aa46b78", "patch": "@@ -158,6 +158,8 @@ impl EventLoop for BasicLoop {\n     }\n \n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> { None }\n+\n+    fn has_active_io(&self) -> bool { false }\n }\n \n struct BasicRemote {"}, {"sha": "5d6af2969b8b3ba21434ed72f589e26bd103e234", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=cc34dbb84090f74c84037afb269003f13aa46b78", "patch": "@@ -86,7 +86,7 @@ impl GetAddrInfoRequest {\n                 req.defuse(); // uv callback now owns this request\n                 let mut cx = Ctx { slot: None, status: 0, addrinfo: None };\n \n-                wait_until_woken_after(&mut cx.slot, || {\n+                wait_until_woken_after(&mut cx.slot, loop_, || {\n                     req.set_data(&cx);\n                 });\n "}, {"sha": "e66452041a5315fec507cbac63528d10a5e6a302", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=cc34dbb84090f74c84037afb269003f13aa46b78", "patch": "@@ -304,7 +304,8 @@ fn execute(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n         0 => {\n             req.fired = true;\n             let mut slot = None;\n-            wait_until_woken_after(&mut slot, || {\n+            let loop_ = unsafe { uvll::get_loop_from_fs_req(req.req) };\n+            wait_until_woken_after(&mut slot, &Loop::wrap(loop_), || {\n                 unsafe { uvll::set_data_for_req(req.req, &slot) }\n             });\n             match req.get_result() {"}, {"sha": "d5e643febe35a02611619907d31e89433c4a8f9c", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=cc34dbb84090f74c84037afb269003f13aa46b78", "patch": "@@ -47,7 +47,7 @@ via `close` and `delete` methods.\n use std::cast;\n use std::io;\n use std::io::IoError;\n-use std::libc::c_int;\n+use std::libc::{c_int, c_void};\n use std::ptr::null;\n use std::ptr;\n use std::rt::local::Local;\n@@ -95,6 +95,10 @@ pub mod stream;\n pub trait UvHandle<T> {\n     fn uv_handle(&self) -> *T;\n \n+    fn uv_loop(&self) -> Loop {\n+        Loop::wrap(unsafe { uvll::get_loop_for_uv_handle(self.uv_handle()) })\n+    }\n+\n     // FIXME(#8888) dummy self\n     fn alloc(_: Option<Self>, ty: uvll::uv_handle_type) -> *T {\n         unsafe {\n@@ -136,7 +140,7 @@ pub trait UvHandle<T> {\n             uvll::uv_close(self.uv_handle() as *uvll::uv_handle_t, close_cb);\n             uvll::set_data_for_uv_handle(self.uv_handle(), ptr::null::<()>());\n \n-            wait_until_woken_after(&mut slot, || {\n+            wait_until_woken_after(&mut slot, &self.uv_loop(), || {\n                 uvll::set_data_for_uv_handle(self.uv_handle(), &slot);\n             })\n         }\n@@ -195,16 +199,20 @@ impl Drop for ForbidUnwind {\n     }\n }\n \n-fn wait_until_woken_after(slot: *mut Option<BlockedTask>, f: ||) {\n+fn wait_until_woken_after(slot: *mut Option<BlockedTask>,\n+                          loop_: &Loop,\n+                          f: ||) {\n     let _f = ForbidUnwind::new(\"wait_until_woken_after\");\n     unsafe {\n         assert!((*slot).is_none());\n         let task: ~Task = Local::take();\n+        loop_.modify_blockers(1);\n         task.deschedule(1, |task| {\n             *slot = Some(task);\n             f();\n             Ok(())\n         });\n+        loop_.modify_blockers(-1);\n     }\n }\n \n@@ -273,6 +281,7 @@ impl Loop {\n     pub fn new() -> Loop {\n         let handle = unsafe { uvll::loop_new() };\n         assert!(handle.is_not_null());\n+        unsafe { uvll::set_data_for_uv_loop(handle, 0 as *c_void) }\n         Loop::wrap(handle)\n     }\n \n@@ -285,6 +294,19 @@ impl Loop {\n     pub fn close(&mut self) {\n         unsafe { uvll::uv_loop_delete(self.handle) };\n     }\n+\n+    // The 'data' field of the uv_loop_t is used to count the number of tasks\n+    // that are currently blocked waiting for I/O to complete.\n+    fn modify_blockers(&self, amt: uint) {\n+        unsafe {\n+            let cur = uvll::get_data_for_uv_loop(self.handle) as uint;\n+            uvll::set_data_for_uv_loop(self.handle, (cur + amt) as *c_void)\n+        }\n+    }\n+\n+    fn get_blockers(&self) -> uint {\n+        unsafe { uvll::get_data_for_uv_loop(self.handle) as uint }\n+    }\n }\n \n // FIXME: Need to define the error constants like EOF so they can be"}, {"sha": "a091829f297e86b4435eb06c0683d5e2c2b4f6d1", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=cc34dbb84090f74c84037afb269003f13aa46b78", "patch": "@@ -216,7 +216,7 @@ impl TcpWatcher {\n             0 => {\n                 req.defuse(); // uv callback now owns this request\n                 let mut cx = Ctx { status: 0, task: None };\n-                wait_until_woken_after(&mut cx.task, || {\n+                wait_until_woken_after(&mut cx.task, &io.loop_, || {\n                     req.set_data(&cx);\n                 });\n                 match cx.status {\n@@ -498,6 +498,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             buf: Option<Buf>,\n             result: Option<(ssize_t, Option<ip::SocketAddr>)>,\n         }\n+        let loop_ = self.uv_loop();\n         let m = self.fire_homing_missile();\n         let _g = self.read_access.grant(m);\n \n@@ -511,7 +512,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                     result: None,\n                 };\n                 let handle = self.handle;\n-                wait_until_woken_after(&mut cx.task, || {\n+                wait_until_woken_after(&mut cx.task, &loop_, || {\n                     unsafe { uvll::set_data_for_uv_handle(handle, &cx) }\n                 });\n                 match cx.result.take_unwrap() {\n@@ -571,6 +572,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         struct Ctx { task: Option<BlockedTask>, result: c_int }\n \n         let m = self.fire_homing_missile();\n+        let loop_ = self.uv_loop();\n         let _g = self.write_access.grant(m);\n \n         let mut req = Request::new(uvll::UV_UDP_SEND);\n@@ -586,7 +588,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             0 => {\n                 req.defuse(); // uv callback now owns this request\n                 let mut cx = Ctx { task: None, result: 0 };\n-                wait_until_woken_after(&mut cx.task, || {\n+                wait_until_woken_after(&mut cx.task, &loop_, || {\n                     req.set_data(&cx);\n                 });\n                 match cx.result {"}, {"sha": "24ac17700cc2748148b2426964ee041367d6ecc2", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=cc34dbb84090f74c84037afb269003f13aa46b78", "patch": "@@ -92,7 +92,7 @@ impl PipeWatcher {\n         let mut req = Request::new(uvll::UV_CONNECT);\n         let pipe = PipeWatcher::new(io, false);\n \n-        wait_until_woken_after(&mut cx.task, || {\n+        wait_until_woken_after(&mut cx.task, &io.loop_, || {\n             unsafe {\n                 uvll::uv_pipe_connect(req.handle,\n                                       pipe.handle(),"}, {"sha": "e1f94d8c4df5a2bd99576d93d9b58f4be7d8aecc", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=cc34dbb84090f74c84037afb269003f13aa46b78", "patch": "@@ -211,7 +211,7 @@ impl RtioProcess for Process {\n                 // If there's no exit code previously listed, then the\n                 // process's exit callback has yet to be invoked. We just\n                 // need to deschedule ourselves and wait to be reawoken.\n-                wait_until_woken_after(&mut self.to_wake, || {});\n+                wait_until_woken_after(&mut self.to_wake, &self.uv_loop(), || {});\n                 assert!(self.exit_status.is_some());\n             }\n         }"}, {"sha": "f7bf2f051eb90c5029176b0e29f40bc3ebad3169", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=cc34dbb84090f74c84037afb269003f13aa46b78", "patch": "@@ -13,6 +13,7 @@ use std::libc::{c_int, size_t, ssize_t};\n use std::ptr;\n use std::rt::task::BlockedTask;\n \n+use Loop;\n use super::{UvError, Buf, slice_to_uv_buf, Request, wait_until_woken_after,\n             ForbidUnwind, wakeup};\n use uvll;\n@@ -87,7 +88,8 @@ impl StreamWatcher {\n             uvll::uv_read_start(self.handle, alloc_cb, read_cb)\n         } {\n             0 => {\n-                wait_until_woken_after(&mut rcx.task, || {});\n+                let loop_ = unsafe { uvll::get_loop_for_uv_handle(self.handle) };\n+                wait_until_woken_after(&mut rcx.task, &Loop::wrap(loop_), || {});\n                 match rcx.result {\n                     n if n < 0 => Err(UvError(n as c_int)),\n                     n => Ok(n as uint),\n@@ -121,7 +123,8 @@ impl StreamWatcher {\n                 let mut wcx = WriteContext { result: 0, task: None, };\n                 req.defuse(); // uv callback now owns this request\n \n-                wait_until_woken_after(&mut wcx.task, || {\n+                let loop_ = unsafe { uvll::get_loop_for_uv_handle(self.handle) };\n+                wait_until_woken_after(&mut wcx.task, &Loop::wrap(loop_), || {\n                     req.set_data(&wcx);\n                 });\n                 self.last_write_req = Some(Request::wrap(req.handle));"}, {"sha": "8c80cc991450483d12653697db01562130ca7d00", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=cc34dbb84090f74c84037afb269003f13aa46b78", "patch": "@@ -9,25 +9,25 @@\n // except according to those terms.\n \n use std::libc::c_int;\n-use std::mem::replace;\n-use std::rt::local::Local;\n+use std::mem;\n use std::rt::rtio::RtioTimer;\n-use std::rt::task::{BlockedTask, Task};\n+use std::rt::task::BlockedTask;\n \n use homing::{HomeHandle, HomingIO};\n-use super::{UvHandle, ForbidUnwind, ForbidSwitch};\n+use super::{UvHandle, ForbidUnwind, ForbidSwitch, wait_until_woken_after};\n use uvio::UvIoFactory;\n use uvll;\n \n pub struct TimerWatcher {\n     handle: *uvll::uv_timer_t,\n     home: HomeHandle,\n     action: Option<NextAction>,\n+    blocker: Option<BlockedTask>,\n     id: uint, // see comments in timer_cb\n }\n \n pub enum NextAction {\n-    WakeTask(BlockedTask),\n+    WakeTask,\n     SendOnce(Chan<()>),\n     SendMany(Chan<()>, uint),\n }\n@@ -41,6 +41,7 @@ impl TimerWatcher {\n         let me = ~TimerWatcher {\n             handle: handle,\n             action: None,\n+            blocker: None,\n             home: io.make_handle(),\n             id: 0,\n         };\n@@ -76,7 +77,7 @@ impl RtioTimer for TimerWatcher {\n         let missile = self.fire_homing_missile();\n         self.id += 1;\n         self.stop();\n-        let _missile = match replace(&mut self.action, None) {\n+        let _missile = match mem::replace(&mut self.action, None) {\n             None => missile, // no need to do a homing dance\n             Some(action) => {\n                 drop(missile);      // un-home ourself\n@@ -89,11 +90,9 @@ impl RtioTimer for TimerWatcher {\n         // started, then we need to call stop on the timer.\n         let _f = ForbidUnwind::new(\"timer\");\n \n-        let task: ~Task = Local::take();\n-        task.deschedule(1, |task| {\n-            self.action = Some(WakeTask(task));\n+        self.action = Some(WakeTask);\n+        wait_until_woken_after(&mut self.blocker, &self.uv_loop(), || {\n             self.start(msecs, 0);\n-            Ok(())\n         });\n         self.stop();\n     }\n@@ -108,7 +107,7 @@ impl RtioTimer for TimerWatcher {\n             self.id += 1;\n             self.stop();\n             self.start(msecs, 0);\n-            replace(&mut self.action, Some(SendOnce(chan)))\n+            mem::replace(&mut self.action, Some(SendOnce(chan)))\n         };\n \n         return port;\n@@ -124,7 +123,7 @@ impl RtioTimer for TimerWatcher {\n             self.id += 1;\n             self.stop();\n             self.start(msecs, msecs);\n-            replace(&mut self.action, Some(SendMany(chan, self.id)))\n+            mem::replace(&mut self.action, Some(SendMany(chan, self.id)))\n         };\n \n         return port;\n@@ -137,7 +136,8 @@ extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n     let timer: &mut TimerWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n \n     match timer.action.take_unwrap() {\n-        WakeTask(task) => {\n+        WakeTask => {\n+            let task = timer.blocker.take_unwrap();\n             let _ = task.wake().map(|t| t.reawaken());\n         }\n         SendOnce(chan) => { let _ = chan.try_send(()); }"}, {"sha": "14406cb2a6a0146b6f3d21d699fb0b739f615100", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=cc34dbb84090f74c84037afb269003f13aa46b78", "patch": "@@ -99,6 +99,10 @@ impl rtio::EventLoop for UvEventLoop {\n         let factory = &mut self.uvio as &mut rtio::IoFactory;\n         Some(factory)\n     }\n+\n+    fn has_active_io(&self) -> bool {\n+        self.uvio.loop_.get_blockers() > 0\n+    }\n }\n \n #[cfg(not(test))]"}, {"sha": "5573f8ec02eb3c17e457a22cf57336958f1139cd", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc34dbb84090f74c84037afb269003f13aa46b78/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=cc34dbb84090f74c84037afb269003f13aa46b78", "patch": "@@ -41,6 +41,7 @@ pub trait EventLoop {\n \n     /// The asynchronous I/O services. Not all event loops may provide one.\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory>;\n+    fn has_active_io(&self) -> bool;\n }\n \n pub trait RemoteCallback {"}]}