{"sha": "f1d3086492db10deaa3268952792e93ad09ecec0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZDMwODY0OTJkYjEwZGVhYTMyNjg5NTI3OTJlOTNhZDA5ZWNlYzA=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-05-17T15:36:26Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-05-17T15:36:26Z"}, "message": "Merge commit 'e214ea82ad0a751563acf67e1cd9279cf302db3a' into clippyup", "tree": {"sha": "afcbe3fb36c937b9dade83ce3644367e157c38dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afcbe3fb36c937b9dade83ce3644367e157c38dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1d3086492db10deaa3268952792e93ad09ecec0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1d3086492db10deaa3268952792e93ad09ecec0", "html_url": "https://github.com/rust-lang/rust/commit/f1d3086492db10deaa3268952792e93ad09ecec0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1d3086492db10deaa3268952792e93ad09ecec0/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bba1b758916d012a09463c4aade5750cd482f80", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bba1b758916d012a09463c4aade5750cd482f80", "html_url": "https://github.com/rust-lang/rust/commit/8bba1b758916d012a09463c4aade5750cd482f80"}], "stats": {"total": 2872, "additions": 1770, "deletions": 1102}, "files": [{"sha": "583c32ca9e032ed67f6cf333bcbcc8c107936d58", "filename": "CHANGELOG.md", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -198,7 +198,7 @@ Released 2020-03-12\n \n ### Suggestion Improvements\n \n-* [`option_map_unwrap_or`] [#4634](https://github.com/rust-lang/rust-clippy/pull/4634)\n+* `option_map_unwrap_or` [#4634](https://github.com/rust-lang/rust-clippy/pull/4634)\n * [`wildcard_enum_match_arm`] [#4934](https://github.com/rust-lang/rust-clippy/pull/4934)\n * [`cognitive_complexity`] [#4935](https://github.com/rust-lang/rust-clippy/pull/4935)\n * [`decimal_literal_representation`] [#4956](https://github.com/rust-lang/rust-clippy/pull/4956)\n@@ -282,8 +282,8 @@ Released 2019-12-19\n   * [`panic`] [#4657](https://github.com/rust-lang/rust-clippy/pull/4657)\n   * [`unreachable`] [#4657](https://github.com/rust-lang/rust-clippy/pull/4657)\n   * [`todo`] [#4657](https://github.com/rust-lang/rust-clippy/pull/4657)\n-  * [`option_expect_used`] [#4657](https://github.com/rust-lang/rust-clippy/pull/4657)\n-  * [`result_expect_used`] [#4657](https://github.com/rust-lang/rust-clippy/pull/4657)\n+  * `option_expect_used` [#4657](https://github.com/rust-lang/rust-clippy/pull/4657)\n+  * `result_expect_used` [#4657](https://github.com/rust-lang/rust-clippy/pull/4657)\n * Move `redundant_clone` to perf group [#4509](https://github.com/rust-lang/rust-clippy/pull/4509)\n * Move `manual_mul_add` to nursery group [#4736](https://github.com/rust-lang/rust-clippy/pull/4736)\n * Expand `unit_cmp` to also work with `assert_eq!`, `debug_assert_eq!`, `assert_ne!` and `debug_assert_ne!` [#4613](https://github.com/rust-lang/rust-clippy/pull/4613)\n@@ -315,7 +315,7 @@ Released 2019-11-07\n   * [`missing_safety_doc`] [#4535](https://github.com/rust-lang/rust-clippy/pull/4535)\n   * [`mem_replace_with_uninit`] [#4511](https://github.com/rust-lang/rust-clippy/pull/4511)\n   * [`suspicious_map`] [#4394](https://github.com/rust-lang/rust-clippy/pull/4394)\n-  * [`option_and_then_some`] [#4386](https://github.com/rust-lang/rust-clippy/pull/4386)\n+  * `option_and_then_some` [#4386](https://github.com/rust-lang/rust-clippy/pull/4386)\n   * [`manual_saturating_arithmetic`] [#4498](https://github.com/rust-lang/rust-clippy/pull/4498)\n * Deprecate `unused_collect` lint. This is fully covered by rustc's `#[must_use]` on `collect` [#4348](https://github.com/rust-lang/rust-clippy/pull/4348)\n * Move `type_repetition_in_bounds` to pedantic group [#4403](https://github.com/rust-lang/rust-clippy/pull/4403)\n@@ -395,7 +395,7 @@ Released 2019-08-15\n * Fix false positive in [`useless_attribute`] [#4107](https://github.com/rust-lang/rust-clippy/pull/4107)\n * Fix incorrect suggestion for [`float_cmp`] [#4214](https://github.com/rust-lang/rust-clippy/pull/4214)\n * Add suggestions for [`print_with_newline`] and [`write_with_newline`] [#4136](https://github.com/rust-lang/rust-clippy/pull/4136)\n-* Improve suggestions for [`option_map_unwrap_or_else`] and [`result_map_unwrap_or_else`] [#4164](https://github.com/rust-lang/rust-clippy/pull/4164)\n+* Improve suggestions for `option_map_unwrap_or_else` and `result_map_unwrap_or_else` [#4164](https://github.com/rust-lang/rust-clippy/pull/4164)\n * Improve suggestions for [`non_ascii_literal`] [#4119](https://github.com/rust-lang/rust-clippy/pull/4119)\n * Improve diagnostics for [`let_and_return`] [#4137](https://github.com/rust-lang/rust-clippy/pull/4137)\n * Improve diagnostics for [`trivially_copy_pass_by_ref`] [#4071](https://github.com/rust-lang/rust-clippy/pull/4071)\n@@ -448,7 +448,7 @@ Released 2019-05-20\n * Fix false positive in [`needless_range_loop`] pertaining to structs without a `.iter()`\n * Fix false positive in [`bool_comparison`] pertaining to non-bool types\n * Fix false positive in [`redundant_closure`] pertaining to differences in borrows\n-* Fix false positive in [`option_map_unwrap_or`] on non-copy types\n+* Fix false positive in `option_map_unwrap_or` on non-copy types\n * Fix false positives in [`missing_const_for_fn`] pertaining to macros and trait method impls\n * Fix false positive in [`needless_pass_by_value`] pertaining to procedural macros\n * Fix false positive in [`needless_continue`] pertaining to loop labels\n@@ -794,7 +794,7 @@ Released 2018-09-13\n \n ## 0.0.169\n * Rustup to *rustc 1.23.0-nightly (3b82e4c74 2017-11-05)*\n-* New lints: [`just_underscores_and_digits`], [`result_map_unwrap_or_else`], [`transmute_bytes_to_str`]\n+* New lints: [`just_underscores_and_digits`], `result_map_unwrap_or_else`, [`transmute_bytes_to_str`]\n \n ## 0.0.168\n * Rustup to *rustc 1.23.0-nightly (f0fe716db 2017-10-30)*\n@@ -805,7 +805,7 @@ Released 2018-09-13\n \n ## 0.0.166\n * Rustup to *rustc 1.22.0-nightly (b7960878b 2017-10-18)*\n-* New lints: [`explicit_write`], [`identity_conversion`], [`implicit_hasher`], [`invalid_ref`], [`option_map_or_none`],\n+* New lints: [`explicit_write`], `identity_conversion`, [`implicit_hasher`], [`invalid_ref`], [`option_map_or_none`],\n   [`range_minus_one`], [`range_plus_one`], [`transmute_int_to_bool`], [`transmute_int_to_char`],\n   [`transmute_int_to_float`]\n \n@@ -1068,7 +1068,7 @@ Released 2018-09-13\n \n ## 0.0.93 \u2014 2016-10-03\n * Rustup to *rustc 1.14.0-nightly (144af3e97 2016-10-02)*\n-* [`option_map_unwrap_or`] and [`option_map_unwrap_or_else`] are now\n+* `option_map_unwrap_or` and `option_map_unwrap_or_else` are now\n   allowed by default.\n * New lint: [`explicit_into_iter_loop`]\n \n@@ -1087,8 +1087,8 @@ Released 2018-09-13\n ## 0.0.88 \u2014 2016-09-04\n * Rustup to *rustc 1.13.0-nightly (70598e04f 2016-09-03)*\n * The following lints are not new but were only usable through the `clippy`\n-  lint groups: [`filter_next`], [`for_loop_over_option`],\n-  [`for_loop_over_result`] and [`match_overlapping_arm`]. You should now be\n+  lint groups: [`filter_next`], `for_loop_over_option`,\n+  `for_loop_over_result` and [`match_overlapping_arm`]. You should now be\n   able to `#[allow/deny]` them individually and they are available directly\n   through `cargo clippy`.\n \n@@ -1273,9 +1273,9 @@ Released 2018-09-13\n [`assign_ops`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_ops\n [`await_holding_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_lock\n [`bad_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n+[`bind_instead_of_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#bind_instead_of_map\n [`blacklisted_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name\n-[`block_in_if_condition_expr`]: https://rust-lang.github.io/rust-clippy/master/index.html#block_in_if_condition_expr\n-[`block_in_if_condition_stmt`]: https://rust-lang.github.io/rust-clippy/master/index.html#block_in_if_condition_stmt\n+[`blocks_in_if_conditions`]: https://rust-lang.github.io/rust-clippy/master/index.html#blocks_in_if_conditions\n [`bool_comparison`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison\n [`borrow_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrow_interior_mutable_const\n [`borrowed_box`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrowed_box\n@@ -1338,6 +1338,7 @@ Released 2018-09-13\n [`excessive_precision`]: https://rust-lang.github.io/rust-clippy/master/index.html#excessive_precision\n [`exit`]: https://rust-lang.github.io/rust-clippy/master/index.html#exit\n [`expect_fun_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#expect_fun_call\n+[`expect_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#expect_used\n [`expl_impl_clone_on_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#expl_impl_clone_on_copy\n [`explicit_counter_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_counter_loop\n [`explicit_deref_methods`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_deref_methods\n@@ -1361,14 +1362,12 @@ Released 2018-09-13\n [`fn_to_numeric_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_to_numeric_cast\n [`fn_to_numeric_cast_with_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_to_numeric_cast_with_truncation\n [`for_kv_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_kv_map\n-[`for_loop_over_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_loop_over_option\n-[`for_loop_over_result`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_loop_over_result\n+[`for_loops_over_fallibles`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_loops_over_fallibles\n [`forget_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_copy\n [`forget_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_ref\n [`future_not_send`]: https://rust-lang.github.io/rust-clippy/master/index.html#future_not_send\n [`get_last_with_len`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_last_with_len\n [`get_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_unwrap\n-[`identity_conversion`]: https://rust-lang.github.io/rust-clippy/master/index.html#identity_conversion\n [`identity_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#identity_op\n [`if_let_mutex`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_let_mutex\n [`if_let_redundant_pattern_matching`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_let_redundant_pattern_matching\n@@ -1431,6 +1430,7 @@ Released 2018-09-13\n [`map_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_clone\n [`map_entry`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_entry\n [`map_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_flatten\n+[`map_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_unwrap_or\n [`match_as_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_as_ref\n [`match_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_bool\n [`match_on_vec_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_on_vec_items\n@@ -1494,16 +1494,11 @@ Released 2018-09-13\n [`not_unsafe_ptr_arg_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#not_unsafe_ptr_arg_deref\n [`ok_expect`]: https://rust-lang.github.io/rust-clippy/master/index.html#ok_expect\n [`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref\n-[`option_and_then_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_and_then_some\n [`option_as_ref_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref\n [`option_env_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_env_unwrap\n-[`option_expect_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_expect_used\n [`option_map_or_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_or_none\n [`option_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unit_fn\n-[`option_map_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unwrap_or\n-[`option_map_unwrap_or_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unwrap_or_else\n [`option_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_option\n-[`option_unwrap_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_unwrap_used\n [`or_fun_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#or_fun_call\n [`out_of_bounds_indexing`]: https://rust-lang.github.io/rust-clippy/master/index.html#out_of_bounds_indexing\n [`overflow_check_conditional`]: https://rust-lang.github.io/rust-clippy/master/index.html#overflow_check_conditional\n@@ -1540,12 +1535,9 @@ Released 2018-09-13\n [`regex_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#regex_macro\n [`replace_consts`]: https://rust-lang.github.io/rust-clippy/master/index.html#replace_consts\n [`rest_pat_in_fully_bound_structs`]: https://rust-lang.github.io/rust-clippy/master/index.html#rest_pat_in_fully_bound_structs\n-[`result_expect_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_expect_used\n [`result_map_or_into_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_or_into_option\n [`result_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_unit_fn\n-[`result_map_unwrap_or_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_unwrap_or_else\n-[`result_unwrap_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_unwrap_used\n-[`reverse_range_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#reverse_range_loop\n+[`reversed_empty_ranges`]: https://rust-lang.github.io/rust-clippy/master/index.html#reversed_empty_ranges\n [`same_functions_in_if_condition`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_functions_in_if_condition\n [`search_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#search_is_some\n [`serde_api_misuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#serde_api_misuse\n@@ -1625,11 +1617,13 @@ Released 2018-09-13\n [`unused_label`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_label\n [`unused_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_self\n [`unused_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit\n+[`unwrap_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_used\n [`use_debug`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_debug\n [`use_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_self\n [`used_underscore_binding`]: https://rust-lang.github.io/rust-clippy/master/index.html#used_underscore_binding\n [`useless_asref`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_asref\n [`useless_attribute`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_attribute\n+[`useless_conversion`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_conversion\n [`useless_format`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_format\n [`useless_let_if_seq`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_let_if_seq\n [`useless_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_transmute"}, {"sha": "8fa9b05ca32972224f8595da2fa34b92c309f55e", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "renamed", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -8,43 +8,40 @@ use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for `if` conditions that use blocks to contain an\n-    /// expression.\n+    /// **What it does:** Checks for `if` conditions that use blocks containing an\n+    /// expression, statements or conditions that use closures with blocks.\n     ///\n-    /// **Why is this bad?** It isn't really Rust style, same as using parentheses\n-    /// to contain expressions.\n+    /// **Why is this bad?** Style, using blocks in the condition makes it hard to read.\n     ///\n     /// **Known problems:** None.\n     ///\n-    /// **Example:**\n+    /// **Examples:**\n     /// ```rust\n+    /// // Bad\n     /// if { true } { /* ... */ }\n+    ///\n+    /// // Good\n+    /// if true { /* ... */ }\n     /// ```\n-    pub BLOCK_IN_IF_CONDITION_EXPR,\n-    style,\n-    \"braces that can be eliminated in conditions, e.g., `if { true } ...`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for `if` conditions that use blocks containing\n-    /// statements, or conditions that use closures with blocks.\n     ///\n-    /// **Why is this bad?** Using blocks in the condition makes it hard to read.\n+    /// // or\n     ///\n-    /// **Known problems:** None.\n+    /// ```rust\n+    /// # fn somefunc() -> bool { true };\n     ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// if { let x = somefunc(); x } {}\n-    /// // or\n-    /// if somefunc(|x| { x == 47 }) {}\n+    /// // Bad\n+    /// if { let x = somefunc(); x } { /* ... */ }\n+    ///\n+    /// // Good\n+    /// let res = { let x = somefunc(); x };\n+    /// if res { /* ... */ }\n     /// ```\n-    pub BLOCK_IN_IF_CONDITION_STMT,\n+    pub BLOCKS_IN_IF_CONDITIONS,\n     style,\n-    \"complex blocks in conditions, e.g., `if { let x = true; x } ...`\"\n+    \"useless or complex blocks that can be eliminated in conditions\"\n }\n \n-declare_lint_pass!(BlockInIfCondition => [BLOCK_IN_IF_CONDITION_EXPR, BLOCK_IN_IF_CONDITION_STMT]);\n+declare_lint_pass!(BlocksInIfConditions => [BLOCKS_IN_IF_CONDITIONS]);\n \n struct ExVisitor<'a, 'tcx> {\n     found_block: Option<&'tcx Expr<'tcx>>,\n@@ -72,9 +69,9 @@ impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n \n const BRACED_EXPR_MESSAGE: &str = \"omit braces around single expression condition\";\n const COMPLEX_BLOCK_MESSAGE: &str = \"in an `if` condition, avoid complex blocks or closures with blocks; \\\n-                                     instead, move the block or closure higher and bind it with a `let`\";\n+                                    instead, move the block or closure higher and bind it with a `let`\";\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlocksInIfConditions {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n@@ -92,7 +89,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                             let mut applicability = Applicability::MachineApplicable;\n                             span_lint_and_sugg(\n                                 cx,\n-                                BLOCK_IN_IF_CONDITION_EXPR,\n+                                BLOCKS_IN_IF_CONDITIONS,\n                                 cond.span,\n                                 BRACED_EXPR_MESSAGE,\n                                 \"try\",\n@@ -118,7 +115,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                         let mut applicability = Applicability::MachineApplicable;\n                         span_lint_and_sugg(\n                             cx,\n-                            BLOCK_IN_IF_CONDITION_STMT,\n+                            BLOCKS_IN_IF_CONDITIONS,\n                             expr.span.with_hi(cond.span.hi()),\n                             COMPLEX_BLOCK_MESSAGE,\n                             \"try\",\n@@ -140,7 +137,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                 let mut visitor = ExVisitor { found_block: None, cx };\n                 walk_expr(&mut visitor, cond);\n                 if let Some(block) = visitor.found_block {\n-                    span_lint(cx, BLOCK_IN_IF_CONDITION_STMT, block.span, COMPLEX_BLOCK_MESSAGE);\n+                    span_lint(cx, BLOCKS_IN_IF_CONDITIONS, block.span, COMPLEX_BLOCK_MESSAGE);\n                 }\n             }\n         }", "previous_filename": "clippy_lints/src/block_in_if_condition.rs"}, {"sha": "90c00ad098ffe53a5a6ecc6d0e6c776b99b58483", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -3,7 +3,7 @@ use crate::utils::{\n     span_lint_and_sugg, walk_ptrs_ty,\n };\n use if_chain::if_chain;\n-use rustc_ast::ast::{UintTy};\n+use rustc_ast::ast::UintTy;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};"}, {"sha": "93e29edcaa58fead1be38d9718804bd9d4892f84", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -81,12 +81,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ComparisonChain {\n \n                 // Check that both sets of operands are equal\n                 let mut spanless_eq = SpanlessEq::new(cx);\n-                if (!spanless_eq.eq_expr(lhs1, lhs2) || !spanless_eq.eq_expr(rhs1, rhs2))\n-                    && (!spanless_eq.eq_expr(lhs1, rhs2) || !spanless_eq.eq_expr(rhs1, lhs2))\n-                {\n+                let same_fixed_operands = spanless_eq.eq_expr(lhs1, lhs2) && spanless_eq.eq_expr(rhs1, rhs2);\n+                let same_transposed_operands = spanless_eq.eq_expr(lhs1, rhs2) && spanless_eq.eq_expr(rhs1, lhs2);\n+\n+                if !same_fixed_operands && !same_transposed_operands {\n                     return;\n                 }\n \n+                // Check that if the operation is the same, either it's not `==` or the operands are transposed\n+                if kind1.node == kind2.node {\n+                    if kind1.node == BinOpKind::Eq {\n+                        return;\n+                    }\n+                    if !same_transposed_operands {\n+                        return;\n+                    }\n+                }\n+\n                 // Check that the type being compared implements `core::cmp::Ord`\n                 let ty = cx.tables.expr_ty(lhs1);\n                 let is_ord = get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]));"}, {"sha": "4e1c1f131405f39011b78660d6551e24b521718f", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                                     let rsnip = snippet(cx, r.span, \"...\").to_string();\n                                     multispan_sugg(\n                                         diag,\n-                                        \"use the values directly\".to_string(),\n+                                        \"use the values directly\",\n                                         vec![(left.span, lsnip), (right.span, rsnip)],\n                                     );\n                                 },"}, {"sha": "78e07d25f67c573cf122a36039ac487312149dd8", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,4 +1,5 @@\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use if_chain::if_chain;\n+use rustc_hir::{BinOp, BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -32,7 +33,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n         if e.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.kind {\n+        if let ExprKind::Binary(cmp, ref left, ref right) = e.kind {\n+            if is_allowed(cx, cmp, left, right) {\n+                return;\n+            }\n             match cmp.node {\n                 BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n                     check(cx, left, 0, e.span, right.span);\n@@ -54,6 +58,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n     }\n }\n \n+fn is_allowed(cx: &LateContext<'_, '_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+    // `1 << 0` is a common pattern in bit manipulation code\n+    if_chain! {\n+        if let BinOpKind::Shl = cmp.node;\n+        if let Some(Constant::Int(0)) = constant_simple(cx, cx.tables, right);\n+        if let Some(Constant::Int(1)) = constant_simple(cx, cx.tables, left);\n+        then {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}\n+\n #[allow(clippy::cast_possible_wrap)]\n fn check(cx: &LateContext<'_, '_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables, e) {"}, {"sha": "d7bf8a1476817c28892be2a3033f120fb2585301", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -50,7 +50,7 @@ declare_clippy_lint! {\n     /// };\n     /// ```\n     pub USELESS_LET_IF_SEQ,\n-    style,\n+    nursery,\n     \"unidiomatic `let mut` declaration followed by initialization in `if`\"\n }\n "}, {"sha": "e0787ac0887e4fde54a7c8e77a6bfa80b42bb8a2", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -180,7 +180,7 @@ mod attrs;\n mod await_holding_lock;\n mod bit_mask;\n mod blacklisted_name;\n-mod block_in_if_condition;\n+mod blocks_in_if_conditions;\n mod booleans;\n mod bytecount;\n mod cargo_common_metadata;\n@@ -221,7 +221,6 @@ mod formatting;\n mod functions;\n mod future_not_send;\n mod get_last_with_len;\n-mod identity_conversion;\n mod identity_op;\n mod if_let_mutex;\n mod if_let_some_result;\n@@ -324,6 +323,7 @@ mod unused_io_amount;\n mod unused_self;\n mod unwrap;\n mod use_self;\n+mod useless_conversion;\n mod vec;\n mod verbose_file_reads;\n mod wildcard_dependencies;\n@@ -507,8 +507,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &bit_mask::INEFFECTIVE_BIT_MASK,\n         &bit_mask::VERBOSE_BIT_MASK,\n         &blacklisted_name::BLACKLISTED_NAME,\n-        &block_in_if_condition::BLOCK_IN_IF_CONDITION_EXPR,\n-        &block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT,\n+        &blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS,\n         &booleans::LOGIC_BUG,\n         &booleans::NONMINIMAL_BOOL,\n         &bytecount::NAIVE_BYTECOUNT,\n@@ -578,7 +577,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &functions::TOO_MANY_LINES,\n         &future_not_send::FUTURE_NOT_SEND,\n         &get_last_with_len::GET_LAST_WITH_LEN,\n-        &identity_conversion::IDENTITY_CONVERSION,\n         &identity_op::IDENTITY_OP,\n         &if_let_mutex::IF_LET_MUTEX,\n         &if_let_some_result::IF_LET_SOME_RESULT,\n@@ -616,15 +614,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &loops::EXPLICIT_INTO_ITER_LOOP,\n         &loops::EXPLICIT_ITER_LOOP,\n         &loops::FOR_KV_MAP,\n-        &loops::FOR_LOOP_OVER_OPTION,\n-        &loops::FOR_LOOP_OVER_RESULT,\n+        &loops::FOR_LOOPS_OVER_FALLIBLES,\n         &loops::ITER_NEXT_LOOP,\n         &loops::MANUAL_MEMCPY,\n         &loops::MUT_RANGE_BOUND,\n         &loops::NEEDLESS_COLLECT,\n         &loops::NEEDLESS_RANGE_LOOP,\n         &loops::NEVER_LOOP,\n-        &loops::REVERSE_RANGE_LOOP,\n         &loops::WHILE_IMMUTABLE_CONDITION,\n         &loops::WHILE_LET_LOOP,\n         &loops::WHILE_LET_ON_ITERATOR,\n@@ -653,12 +649,14 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &mem_replace::MEM_REPLACE_OPTION_WITH_NONE,\n         &mem_replace::MEM_REPLACE_WITH_DEFAULT,\n         &mem_replace::MEM_REPLACE_WITH_UNINIT,\n+        &methods::BIND_INSTEAD_OF_MAP,\n         &methods::CHARS_LAST_CMP,\n         &methods::CHARS_NEXT_CMP,\n         &methods::CLONE_DOUBLE_REF,\n         &methods::CLONE_ON_COPY,\n         &methods::CLONE_ON_REF_PTR,\n         &methods::EXPECT_FUN_CALL,\n+        &methods::EXPECT_USED,\n         &methods::FILETYPE_IS_FILE,\n         &methods::FILTER_MAP,\n         &methods::FILTER_MAP_NEXT,\n@@ -675,20 +673,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::ITER_SKIP_NEXT,\n         &methods::MANUAL_SATURATING_ARITHMETIC,\n         &methods::MAP_FLATTEN,\n+        &methods::MAP_UNWRAP_OR,\n         &methods::NEW_RET_NO_SELF,\n         &methods::OK_EXPECT,\n-        &methods::OPTION_AND_THEN_SOME,\n         &methods::OPTION_AS_REF_DEREF,\n-        &methods::OPTION_EXPECT_USED,\n         &methods::OPTION_MAP_OR_NONE,\n-        &methods::OPTION_MAP_UNWRAP_OR,\n-        &methods::OPTION_MAP_UNWRAP_OR_ELSE,\n-        &methods::OPTION_UNWRAP_USED,\n         &methods::OR_FUN_CALL,\n-        &methods::RESULT_EXPECT_USED,\n         &methods::RESULT_MAP_OR_INTO_OPTION,\n-        &methods::RESULT_MAP_UNWRAP_OR_ELSE,\n-        &methods::RESULT_UNWRAP_USED,\n         &methods::SEARCH_IS_SOME,\n         &methods::SHOULD_IMPLEMENT_TRAIT,\n         &methods::SINGLE_CHAR_PATTERN,\n@@ -699,6 +690,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::UNINIT_ASSUMED_INIT,\n         &methods::UNNECESSARY_FILTER_MAP,\n         &methods::UNNECESSARY_FOLD,\n+        &methods::UNWRAP_USED,\n         &methods::USELESS_ASREF,\n         &methods::WRONG_PUB_SELF_CONVENTION,\n         &methods::WRONG_SELF_CONVENTION,\n@@ -770,6 +762,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &ranges::RANGE_MINUS_ONE,\n         &ranges::RANGE_PLUS_ONE,\n         &ranges::RANGE_ZIP_WITH_LEN,\n+        &ranges::REVERSED_EMPTY_RANGES,\n         &redundant_clone::REDUNDANT_CLONE,\n         &redundant_field_names::REDUNDANT_FIELD_NAMES,\n         &redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING,\n@@ -849,6 +842,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &unwrap::PANICKING_UNWRAP,\n         &unwrap::UNNECESSARY_UNWRAP,\n         &use_self::USE_SELF,\n+        &useless_conversion::USELESS_CONVERSION,\n         &utils::internal_lints::CLIPPY_LINTS_INTERNAL,\n         &utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS,\n         &utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n@@ -900,7 +894,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box mut_reference::UnnecessaryMutPassed);\n     store.register_late_pass(|| box len_zero::LenZero);\n     store.register_late_pass(|| box attrs::Attributes);\n-    store.register_late_pass(|| box block_in_if_condition::BlockInIfCondition);\n+    store.register_late_pass(|| box blocks_in_if_conditions::BlocksInIfConditions);\n     store.register_late_pass(|| box unicode::Unicode);\n     store.register_late_pass(|| box strings::StringAdd);\n     store.register_late_pass(|| box implicit_return::ImplicitReturn);\n@@ -986,7 +980,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box bytecount::ByteCount);\n     store.register_late_pass(|| box infinite_iter::InfiniteIter);\n     store.register_late_pass(|| box inline_fn_without_body::InlineFnWithoutBody);\n-    store.register_late_pass(|| box identity_conversion::IdentityConversion::default());\n+    store.register_late_pass(|| box useless_conversion::UselessConversion::default());\n     store.register_late_pass(|| box types::ImplicitHasher);\n     store.register_late_pass(|| box fallible_impl_from::FallibleImplFrom);\n     store.register_late_pass(|| box types::UnitArg);\n@@ -1090,12 +1084,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&matches::WILDCARD_ENUM_MATCH_ARM),\n         LintId::of(&mem_forget::MEM_FORGET),\n         LintId::of(&methods::CLONE_ON_REF_PTR),\n+        LintId::of(&methods::EXPECT_USED),\n         LintId::of(&methods::FILETYPE_IS_FILE),\n         LintId::of(&methods::GET_UNWRAP),\n-        LintId::of(&methods::OPTION_EXPECT_USED),\n-        LintId::of(&methods::OPTION_UNWRAP_USED),\n-        LintId::of(&methods::RESULT_EXPECT_USED),\n-        LintId::of(&methods::RESULT_UNWRAP_USED),\n+        LintId::of(&methods::UNWRAP_USED),\n         LintId::of(&methods::WRONG_PUB_SELF_CONVENTION),\n         LintId::of(&misc::FLOAT_CMP_CONST),\n         LintId::of(&misc_early::UNNEEDED_FIELD_PATTERN),\n@@ -1153,9 +1145,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::FIND_MAP),\n         LintId::of(&methods::INEFFICIENT_TO_STRING),\n         LintId::of(&methods::MAP_FLATTEN),\n-        LintId::of(&methods::OPTION_MAP_UNWRAP_OR),\n-        LintId::of(&methods::OPTION_MAP_UNWRAP_OR_ELSE),\n-        LintId::of(&methods::RESULT_MAP_UNWRAP_OR_ELSE),\n+        LintId::of(&methods::MAP_UNWRAP_OR),\n         LintId::of(&misc::USED_UNDERSCORE_BINDING),\n         LintId::of(&misc_early::UNSEPARATED_LITERAL_SUFFIX),\n         LintId::of(&mut_mut::MUT_MUT),\n@@ -1209,8 +1199,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&bit_mask::INEFFECTIVE_BIT_MASK),\n         LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n-        LintId::of(&block_in_if_condition::BLOCK_IN_IF_CONDITION_EXPR),\n-        LintId::of(&block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT),\n+        LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n         LintId::of(&booleans::LOGIC_BUG),\n         LintId::of(&booleans::NONMINIMAL_BOOL),\n         LintId::of(&bytecount::NAIVE_BYTECOUNT),\n@@ -1252,7 +1241,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&functions::NOT_UNSAFE_PTR_ARG_DEREF),\n         LintId::of(&functions::TOO_MANY_ARGUMENTS),\n         LintId::of(&get_last_with_len::GET_LAST_WITH_LEN),\n-        LintId::of(&identity_conversion::IDENTITY_CONVERSION),\n         LintId::of(&identity_op::IDENTITY_OP),\n         LintId::of(&if_let_mutex::IF_LET_MUTEX),\n         LintId::of(&if_let_some_result::IF_LET_SOME_RESULT),\n@@ -1266,7 +1254,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&large_enum_variant::LARGE_ENUM_VARIANT),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n-        LintId::of(&let_if_seq::USELESS_LET_IF_SEQ),\n         LintId::of(&let_underscore::LET_UNDERSCORE_LOCK),\n         LintId::of(&lifetimes::EXTRA_UNUSED_LIFETIMES),\n         LintId::of(&lifetimes::NEEDLESS_LIFETIMES),\n@@ -1275,15 +1262,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::EMPTY_LOOP),\n         LintId::of(&loops::EXPLICIT_COUNTER_LOOP),\n         LintId::of(&loops::FOR_KV_MAP),\n-        LintId::of(&loops::FOR_LOOP_OVER_OPTION),\n-        LintId::of(&loops::FOR_LOOP_OVER_RESULT),\n+        LintId::of(&loops::FOR_LOOPS_OVER_FALLIBLES),\n         LintId::of(&loops::ITER_NEXT_LOOP),\n         LintId::of(&loops::MANUAL_MEMCPY),\n         LintId::of(&loops::MUT_RANGE_BOUND),\n         LintId::of(&loops::NEEDLESS_COLLECT),\n         LintId::of(&loops::NEEDLESS_RANGE_LOOP),\n         LintId::of(&loops::NEVER_LOOP),\n-        LintId::of(&loops::REVERSE_RANGE_LOOP),\n         LintId::of(&loops::WHILE_IMMUTABLE_CONDITION),\n         LintId::of(&loops::WHILE_LET_LOOP),\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n@@ -1305,6 +1290,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&mem_replace::MEM_REPLACE_OPTION_WITH_NONE),\n         LintId::of(&mem_replace::MEM_REPLACE_WITH_DEFAULT),\n         LintId::of(&mem_replace::MEM_REPLACE_WITH_UNINIT),\n+        LintId::of(&methods::BIND_INSTEAD_OF_MAP),\n         LintId::of(&methods::CHARS_LAST_CMP),\n         LintId::of(&methods::CHARS_NEXT_CMP),\n         LintId::of(&methods::CLONE_DOUBLE_REF),\n@@ -1321,7 +1307,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::MANUAL_SATURATING_ARITHMETIC),\n         LintId::of(&methods::NEW_RET_NO_SELF),\n         LintId::of(&methods::OK_EXPECT),\n-        LintId::of(&methods::OPTION_AND_THEN_SOME),\n         LintId::of(&methods::OPTION_AS_REF_DEREF),\n         LintId::of(&methods::OPTION_MAP_OR_NONE),\n         LintId::of(&methods::OR_FUN_CALL),\n@@ -1384,6 +1369,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&question_mark::QUESTION_MARK),\n         LintId::of(&ranges::RANGE_MINUS_ONE),\n         LintId::of(&ranges::RANGE_ZIP_WITH_LEN),\n+        LintId::of(&ranges::REVERSED_EMPTY_RANGES),\n         LintId::of(&redundant_clone::REDUNDANT_CLONE),\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n         LintId::of(&redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING),\n@@ -1440,6 +1426,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&unused_io_amount::UNUSED_IO_AMOUNT),\n         LintId::of(&unwrap::PANICKING_UNWRAP),\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n+        LintId::of(&useless_conversion::USELESS_CONVERSION),\n         LintId::of(&vec::USELESS_VEC),\n         LintId::of(&write::PRINTLN_EMPTY_STRING),\n         LintId::of(&write::PRINT_LITERAL),\n@@ -1456,8 +1443,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&attrs::UNKNOWN_CLIPPY_LINTS),\n         LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n-        LintId::of(&block_in_if_condition::BLOCK_IN_IF_CONDITION_EXPR),\n-        LintId::of(&block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT),\n+        LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n         LintId::of(&doc::MISSING_SAFETY_DOC),\n@@ -1476,7 +1462,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n-        LintId::of(&let_if_seq::USELESS_LET_IF_SEQ),\n         LintId::of(&literal_representation::INCONSISTENT_DIGIT_GROUPING),\n         LintId::of(&loops::EMPTY_LOOP),\n         LintId::of(&loops::FOR_KV_MAP),\n@@ -1561,7 +1546,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&format::USELESS_FORMAT),\n         LintId::of(&functions::TOO_MANY_ARGUMENTS),\n         LintId::of(&get_last_with_len::GET_LAST_WITH_LEN),\n-        LintId::of(&identity_conversion::IDENTITY_CONVERSION),\n         LintId::of(&identity_op::IDENTITY_OP),\n         LintId::of(&int_plus_one::INT_PLUS_ONE),\n         LintId::of(&lifetimes::EXTRA_UNUSED_LIFETIMES),\n@@ -1574,10 +1558,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&matches::MATCH_AS_REF),\n         LintId::of(&matches::MATCH_SINGLE_BINDING),\n         LintId::of(&matches::WILDCARD_IN_OR_PATTERNS),\n+        LintId::of(&methods::BIND_INSTEAD_OF_MAP),\n         LintId::of(&methods::CLONE_ON_COPY),\n         LintId::of(&methods::FILTER_NEXT),\n         LintId::of(&methods::FLAT_MAP_IDENTITY),\n-        LintId::of(&methods::OPTION_AND_THEN_SOME),\n         LintId::of(&methods::OPTION_AS_REF_DEREF),\n         LintId::of(&methods::SEARCH_IS_SOME),\n         LintId::of(&methods::SKIP_WHILE_NEXT),\n@@ -1620,6 +1604,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::UNNECESSARY_CAST),\n         LintId::of(&types::VEC_BOX),\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n+        LintId::of(&useless_conversion::USELESS_CONVERSION),\n         LintId::of(&zero_div_zero::ZERO_DIVIDED_BY_ZERO),\n     ]);\n \n@@ -1652,11 +1637,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&inline_fn_without_body::INLINE_FN_WITHOUT_BODY),\n         LintId::of(&let_underscore::LET_UNDERSCORE_LOCK),\n         LintId::of(&literal_representation::MISTYPED_LITERAL_SUFFIXES),\n-        LintId::of(&loops::FOR_LOOP_OVER_OPTION),\n-        LintId::of(&loops::FOR_LOOP_OVER_RESULT),\n+        LintId::of(&loops::FOR_LOOPS_OVER_FALLIBLES),\n         LintId::of(&loops::ITER_NEXT_LOOP),\n         LintId::of(&loops::NEVER_LOOP),\n-        LintId::of(&loops::REVERSE_RANGE_LOOP),\n         LintId::of(&loops::WHILE_IMMUTABLE_CONDITION),\n         LintId::of(&mem_discriminant::MEM_DISCRIMINANT_NON_ENUM),\n         LintId::of(&mem_replace::MEM_REPLACE_WITH_UNINIT),\n@@ -1675,6 +1658,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&open_options::NONSENSICAL_OPEN_OPTIONS),\n         LintId::of(&option_env_unwrap::OPTION_ENV_UNWRAP),\n         LintId::of(&ptr::MUT_FROM_REF),\n+        LintId::of(&ranges::REVERSED_EMPTY_RANGES),\n         LintId::of(&regex::INVALID_REGEX),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n@@ -1728,6 +1712,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&floating_point_arithmetic::IMPRECISE_FLOPS),\n         LintId::of(&floating_point_arithmetic::SUBOPTIMAL_FLOPS),\n         LintId::of(&future_not_send::FUTURE_NOT_SEND),\n+        LintId::of(&let_if_seq::USELESS_LET_IF_SEQ),\n         LintId::of(&missing_const_for_fn::MISSING_CONST_FOR_FN),\n         LintId::of(&mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n         LintId::of(&mutex_atomic::MUTEX_INTEGER),\n@@ -1785,6 +1770,10 @@ fn register_removed_non_tool_lints(store: &mut rustc_lint::LintStore) {\n         \"unsafe_vector_initialization\",\n         \"the replacement suggested by this lint had substantially different behavior\",\n     );\n+    store.register_removed(\n+        \"reverse_range_loop\",\n+        \"this lint is now included in reversed_empty_ranges\",\n+    );\n }\n \n /// Register renamed lints.\n@@ -1795,6 +1784,19 @@ pub fn register_renamed(ls: &mut rustc_lint::LintStore) {\n     ls.register_renamed(\"clippy::new_without_default_derive\", \"clippy::new_without_default\");\n     ls.register_renamed(\"clippy::cyclomatic_complexity\", \"clippy::cognitive_complexity\");\n     ls.register_renamed(\"clippy::const_static_lifetime\", \"clippy::redundant_static_lifetimes\");\n+    ls.register_renamed(\"clippy::option_and_then_some\", \"clippy::bind_instead_of_map\");\n+    ls.register_renamed(\"clippy::block_in_if_condition_expr\", \"clippy::blocks_in_if_conditions\");\n+    ls.register_renamed(\"clippy::block_in_if_condition_stmt\", \"clippy::blocks_in_if_conditions\");\n+    ls.register_renamed(\"clippy::option_map_unwrap_or\", \"clippy::map_unwrap_or\");\n+    ls.register_renamed(\"clippy::option_map_unwrap_or_else\", \"clippy::map_unwrap_or\");\n+    ls.register_renamed(\"clippy::result_map_unwrap_or_else\", \"clippy::map_unwrap_or\");\n+    ls.register_renamed(\"clippy::option_unwrap_used\", \"clippy::unwrap_used\");\n+    ls.register_renamed(\"clippy::result_unwrap_used\", \"clippy::unwrap_used\");\n+    ls.register_renamed(\"clippy::option_expect_used\", \"clippy::expect_used\");\n+    ls.register_renamed(\"clippy::result_expect_used\", \"clippy::expect_used\");\n+    ls.register_renamed(\"clippy::for_loop_over_option\", \"clippy::for_loops_over_fallibles\");\n+    ls.register_renamed(\"clippy::for_loop_over_result\", \"clippy::for_loops_over_fallibles\");\n+    ls.register_renamed(\"clippy::identity_conversion\", \"clippy::useless_conversion\");\n }\n \n // only exists to let the dogfood integration test works."}, {"sha": "84e8a010738cfb9cf9f3307667aadefac106a668", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 32, "deletions": 140, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant, Constant};\n+use crate::consts::constant;\n use crate::reexport::Name;\n use crate::utils::paths;\n use crate::utils::usage::{is_unused, mutated_variables};\n@@ -8,7 +8,7 @@ use crate::utils::{\n     multispan_sugg, snippet, snippet_opt, snippet_with_applicability, span_lint, span_lint_and_help,\n     span_lint_and_sugg, span_lint_and_then, SpanlessEq,\n };\n-use crate::utils::{is_type_diagnostic_item, qpath_res, same_tys, sext, sugg};\n+use crate::utils::{is_type_diagnostic_item, qpath_res, same_tys, sugg};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -168,55 +168,46 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for `for` loops over `Option` values.\n+    /// **What it does:** Checks for `for` loops over `Option` or `Result` values.\n     ///\n     /// **Why is this bad?** Readability. This is more clearly expressed as an `if\n     /// let`.\n     ///\n     /// **Known problems:** None.\n     ///\n     /// **Example:**\n-    /// ```ignore\n-    /// for x in option {\n-    ///     ..\n+    /// ```rust\n+    /// # let opt = Some(1);\n+    ///\n+    /// // Bad\n+    /// for x in opt {\n+    ///     // ..\n     /// }\n-    /// ```\n     ///\n-    /// This should be\n-    /// ```ignore\n-    /// if let Some(x) = option {\n-    ///     ..\n+    /// // Good\n+    /// if let Some(x) = opt {\n+    ///     // ..\n     /// }\n     /// ```\n-    pub FOR_LOOP_OVER_OPTION,\n-    correctness,\n-    \"for-looping over an `Option`, which is more clearly expressed as an `if let`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for `for` loops over `Result` values.\n     ///\n-    /// **Why is this bad?** Readability. This is more clearly expressed as an `if\n-    /// let`.\n+    /// // or\n     ///\n-    /// **Known problems:** None.\n+    /// ```rust\n+    /// # let res: Result<i32, std::io::Error> = Ok(1);\n     ///\n-    /// **Example:**\n-    /// ```ignore\n-    /// for x in result {\n-    ///     ..\n+    /// // Bad\n+    /// for x in &res {\n+    ///     // ..\n     /// }\n-    /// ```\n     ///\n-    /// This should be\n-    /// ```ignore\n-    /// if let Ok(x) = result {\n-    ///     ..\n+    /// // Good\n+    /// if let Ok(x) = res {\n+    ///     // ..\n     /// }\n     /// ```\n-    pub FOR_LOOP_OVER_RESULT,\n+    pub FOR_LOOPS_OVER_FALLIBLES,\n     correctness,\n-    \"for-looping over a `Result`, which is more clearly expressed as an `if let`\"\n+    \"for-looping over an `Option` or a `Result`, which is more clearly expressed as an `if let`\"\n }\n \n declare_clippy_lint! {\n@@ -270,30 +261,6 @@ declare_clippy_lint! {\n     \"collecting an iterator when collect is not needed\"\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for loops over ranges `x..y` where both `x` and `y`\n-    /// are constant and `x` is greater or equal to `y`, unless the range is\n-    /// reversed or has a negative `.step_by(_)`.\n-    ///\n-    /// **Why is it bad?** Such loops will either be skipped or loop until\n-    /// wrap-around (in debug code, this may `panic!()`). Both options are probably\n-    /// not intended.\n-    ///\n-    /// **Known problems:** The lint cannot catch loops over dynamically defined\n-    /// ranges. Doing this would require simulating all possible inputs and code\n-    /// paths through the program, which would be complex and error-prone.\n-    ///\n-    /// **Example:**\n-    /// ```ignore\n-    /// for x in 5..10 - 5 {\n-    ///     ..\n-    /// } // oops, stray `-`\n-    /// ```\n-    pub REVERSE_RANGE_LOOP,\n-    correctness,\n-    \"iteration over an empty range, such as `10..0` or `5..5`\"\n-}\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks `for` loops over slices with an explicit counter\n     /// and suggests the use of `.enumerate()`.\n@@ -459,11 +426,9 @@ declare_lint_pass!(Loops => [\n     EXPLICIT_ITER_LOOP,\n     EXPLICIT_INTO_ITER_LOOP,\n     ITER_NEXT_LOOP,\n-    FOR_LOOP_OVER_RESULT,\n-    FOR_LOOP_OVER_OPTION,\n+    FOR_LOOPS_OVER_FALLIBLES,\n     WHILE_LET_LOOP,\n     NEEDLESS_COLLECT,\n-    REVERSE_RANGE_LOOP,\n     EXPLICIT_COUNTER_LOOP,\n     EMPTY_LOOP,\n     WHILE_LET_ON_ITERATOR,\n@@ -761,7 +726,6 @@ fn check_for_loop<'a, 'tcx>(\n     expr: &'tcx Expr<'_>,\n ) {\n     check_for_loop_range(cx, pat, arg, body, expr);\n-    check_for_loop_reverse_range(cx, arg, expr);\n     check_for_loop_arg(cx, pat, arg, expr);\n     check_for_loop_explicit_counter(cx, pat, arg, body, expr);\n     check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n@@ -1170,7 +1134,7 @@ fn check_for_loop_range<'a, 'tcx>(\n                         |diag| {\n                             multispan_sugg(\n                                 diag,\n-                                \"consider using an iterator\".to_string(),\n+                                \"consider using an iterator\",\n                                 vec![\n                                     (pat.span, format!(\"({}, <item>)\", ident.name)),\n                                     (\n@@ -1199,7 +1163,7 @@ fn check_for_loop_range<'a, 'tcx>(\n                         |diag| {\n                             multispan_sugg(\n                                 diag,\n-                                \"consider using an iterator\".to_string(),\n+                                \"consider using an iterator\",\n                                 vec![(pat.span, \"<item>\".to_string()), (arg.span, repl)],\n                             );\n                         },\n@@ -1248,78 +1212,6 @@ fn is_end_eq_array_len<'tcx>(\n     false\n }\n \n-fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) {\n-    // if this for loop is iterating over a two-sided range...\n-    if let Some(higher::Range {\n-        start: Some(start),\n-        end: Some(end),\n-        limits,\n-    }) = higher::range(cx, arg)\n-    {\n-        // ...and both sides are compile-time constant integers...\n-        if let Some((start_idx, _)) = constant(cx, cx.tables, start) {\n-            if let Some((end_idx, _)) = constant(cx, cx.tables, end) {\n-                // ...and the start index is greater than the end index,\n-                // this loop will never run. This is often confusing for developers\n-                // who think that this will iterate from the larger value to the\n-                // smaller value.\n-                let ty = cx.tables.expr_ty(start);\n-                let (sup, eq) = match (start_idx, end_idx) {\n-                    (Constant::Int(start_idx), Constant::Int(end_idx)) => (\n-                        match ty.kind {\n-                            ty::Int(ity) => sext(cx.tcx, start_idx, ity) > sext(cx.tcx, end_idx, ity),\n-                            ty::Uint(_) => start_idx > end_idx,\n-                            _ => false,\n-                        },\n-                        start_idx == end_idx,\n-                    ),\n-                    _ => (false, false),\n-                };\n-\n-                if sup {\n-                    let start_snippet = snippet(cx, start.span, \"_\");\n-                    let end_snippet = snippet(cx, end.span, \"_\");\n-                    let dots = if limits == ast::RangeLimits::Closed {\n-                        \"..=\"\n-                    } else {\n-                        \"..\"\n-                    };\n-\n-                    span_lint_and_then(\n-                        cx,\n-                        REVERSE_RANGE_LOOP,\n-                        expr.span,\n-                        \"this range is empty so this for loop will never run\",\n-                        |diag| {\n-                            diag.span_suggestion(\n-                                arg.span,\n-                                \"consider using the following if you are attempting to iterate over this \\\n-                                 range in reverse\",\n-                                format!(\n-                                    \"({end}{dots}{start}).rev()\",\n-                                    end = end_snippet,\n-                                    dots = dots,\n-                                    start = start_snippet\n-                                ),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        },\n-                    );\n-                } else if eq && limits != ast::RangeLimits::Closed {\n-                    // if they are equal, it's also problematic - this loop\n-                    // will never run.\n-                    span_lint(\n-                        cx,\n-                        REVERSE_RANGE_LOOP,\n-                        expr.span,\n-                        \"this range is empty so this for loop will never run\",\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr<'_>], arg: &Expr<'_>, method_name: &str) {\n     let mut applicability = Applicability::MachineApplicable;\n     let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n@@ -1381,7 +1273,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>, e\n                     ITER_NEXT_LOOP,\n                     expr.span,\n                     \"you are iterating over `Iterator::next()` which is an Option; this will compile but is \\\n-                     probably not what you want\",\n+                    probably not what you want\",\n                 );\n                 next_loop_linted = true;\n             }\n@@ -1398,11 +1290,11 @@ fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     if is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n         span_lint_and_help(\n             cx,\n-            FOR_LOOP_OVER_OPTION,\n+            FOR_LOOPS_OVER_FALLIBLES,\n             arg.span,\n             &format!(\n                 \"for loop over `{0}`, which is an `Option`. This is more readably written as an \\\n-                 `if let` statement.\",\n+                `if let` statement.\",\n                 snippet(cx, arg.span, \"_\")\n             ),\n             None,\n@@ -1415,11 +1307,11 @@ fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     } else if is_type_diagnostic_item(cx, ty, sym!(result_type)) {\n         span_lint_and_help(\n             cx,\n-            FOR_LOOP_OVER_RESULT,\n+            FOR_LOOPS_OVER_FALLIBLES,\n             arg.span,\n             &format!(\n                 \"for loop over `{0}`, which is a `Result`. This is more readably written as an \\\n-                 `if let` statement.\",\n+                `if let` statement.\",\n                 snippet(cx, arg.span, \"_\")\n             ),\n             None,\n@@ -1570,7 +1462,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n                         let map = sugg::Sugg::hir(cx, arg, \"map\");\n                         multispan_sugg(\n                             diag,\n-                            \"use the corresponding method\".into(),\n+                            \"use the corresponding method\",\n                             vec![\n                                 (pat_span, snippet(cx, new_pat_span, kind).into_owned()),\n                                 (arg_span, format!(\"{}.{}s{}()\", map.maybe_par(), kind, mutbl)),"}, {"sha": "d5adf6b0f0dcbb33271eb97d872c288df2315846", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -9,8 +9,8 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::Mutability;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `iterator.map(|x| x.clone())` and suggests"}, {"sha": "bbf14374a1f7f0c741fd2336e20900be5e386cf1", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -820,7 +820,7 @@ fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>\n \n         span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n             if !expr.span.from_expansion() {\n-                multispan_sugg(diag, msg.to_owned(), suggs);\n+                multispan_sugg(diag, msg, suggs);\n             }\n         });\n     }"}, {"sha": "32e86637569ed3c642be6d766abcefe1e3fc9bb4", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -0,0 +1,309 @@\n+use super::{contains_return, BIND_INSTEAD_OF_MAP};\n+use crate::utils::{\n+    in_macro, match_qpath, match_type, method_calls, multispan_sugg_with_applicability, paths, remove_blocks, snippet,\n+    snippet_with_macro_callsite, span_lint_and_sugg, span_lint_and_then,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{self, Visitor};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_span::Span;\n+\n+pub(crate) struct OptionAndThenSome;\n+impl BindInsteadOfMap for OptionAndThenSome {\n+    const TYPE_NAME: &'static str = \"Option\";\n+    const TYPE_QPATH: &'static [&'static str] = &paths::OPTION;\n+\n+    const BAD_METHOD_NAME: &'static str = \"and_then\";\n+    const BAD_VARIANT_NAME: &'static str = \"Some\";\n+    const BAD_VARIANT_QPATH: &'static [&'static str] = &paths::OPTION_SOME;\n+\n+    const GOOD_METHOD_NAME: &'static str = \"map\";\n+}\n+\n+pub(crate) struct ResultAndThenOk;\n+impl BindInsteadOfMap for ResultAndThenOk {\n+    const TYPE_NAME: &'static str = \"Result\";\n+    const TYPE_QPATH: &'static [&'static str] = &paths::RESULT;\n+\n+    const BAD_METHOD_NAME: &'static str = \"and_then\";\n+    const BAD_VARIANT_NAME: &'static str = \"Ok\";\n+    const BAD_VARIANT_QPATH: &'static [&'static str] = &paths::RESULT_OK;\n+\n+    const GOOD_METHOD_NAME: &'static str = \"map\";\n+}\n+\n+pub(crate) struct ResultOrElseErrInfo;\n+impl BindInsteadOfMap for ResultOrElseErrInfo {\n+    const TYPE_NAME: &'static str = \"Result\";\n+    const TYPE_QPATH: &'static [&'static str] = &paths::RESULT;\n+\n+    const BAD_METHOD_NAME: &'static str = \"or_else\";\n+    const BAD_VARIANT_NAME: &'static str = \"Err\";\n+    const BAD_VARIANT_QPATH: &'static [&'static str] = &paths::RESULT_ERR;\n+\n+    const GOOD_METHOD_NAME: &'static str = \"map_err\";\n+}\n+\n+pub(crate) trait BindInsteadOfMap {\n+    const TYPE_NAME: &'static str;\n+    const TYPE_QPATH: &'static [&'static str];\n+\n+    const BAD_METHOD_NAME: &'static str;\n+    const BAD_VARIANT_NAME: &'static str;\n+    const BAD_VARIANT_QPATH: &'static [&'static str];\n+\n+    const GOOD_METHOD_NAME: &'static str;\n+\n+    fn no_op_msg() -> String {\n+        format!(\n+            \"using `{}.{}({})`, which is a no-op\",\n+            Self::TYPE_NAME,\n+            Self::BAD_METHOD_NAME,\n+            Self::BAD_VARIANT_NAME\n+        )\n+    }\n+\n+    fn lint_msg() -> String {\n+        format!(\n+            \"using `{}.{}(|x| {}(y))`, which is more succinctly expressed as `{}(|x| y)`\",\n+            Self::TYPE_NAME,\n+            Self::BAD_METHOD_NAME,\n+            Self::BAD_VARIANT_NAME,\n+            Self::GOOD_METHOD_NAME\n+        )\n+    }\n+\n+    fn lint_closure_autofixable(\n+        cx: &LateContext<'_, '_>,\n+        expr: &hir::Expr<'_>,\n+        args: &[hir::Expr<'_>],\n+        closure_expr: &hir::Expr<'_>,\n+        closure_args_span: Span,\n+    ) -> bool {\n+        if_chain! {\n+            if let hir::ExprKind::Call(ref some_expr, ref some_args) = closure_expr.kind;\n+            if let hir::ExprKind::Path(ref qpath) = some_expr.kind;\n+            if match_qpath(qpath, Self::BAD_VARIANT_QPATH);\n+            if some_args.len() == 1;\n+            then {\n+                let inner_expr = &some_args[0];\n+\n+                if contains_return(inner_expr) {\n+                    return false;\n+                }\n+\n+                let some_inner_snip = if inner_expr.span.from_expansion() {\n+                    snippet_with_macro_callsite(cx, inner_expr.span, \"_\")\n+                } else {\n+                    snippet(cx, inner_expr.span, \"_\")\n+                };\n+\n+                let closure_args_snip = snippet(cx, closure_args_span, \"..\");\n+                let option_snip = snippet(cx, args[0].span, \"..\");\n+                let note = format!(\"{}.{}({} {})\", option_snip, Self::GOOD_METHOD_NAME, closure_args_snip, some_inner_snip);\n+                span_lint_and_sugg(\n+                    cx,\n+                    BIND_INSTEAD_OF_MAP,\n+                    expr.span,\n+                    Self::lint_msg().as_ref(),\n+                    \"try this\",\n+                    note,\n+                    Applicability::MachineApplicable,\n+                );\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n+    fn lint_closure(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, closure_expr: &hir::Expr<'_>) {\n+        let mut suggs = Vec::new();\n+        let can_sugg = find_all_ret_expressions(cx, closure_expr, |ret_expr| {\n+            if_chain! {\n+                if !in_macro(ret_expr.span);\n+                if let hir::ExprKind::Call(ref func_path, ref args) = ret_expr.kind;\n+                if let hir::ExprKind::Path(ref qpath) = func_path.kind;\n+                if match_qpath(qpath, Self::BAD_VARIANT_QPATH);\n+                if args.len() == 1;\n+                if !contains_return(&args[0]);\n+                then {\n+                    suggs.push((ret_expr.span, args[0].span.source_callsite()));\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        });\n+\n+        if can_sugg {\n+            span_lint_and_then(cx, BIND_INSTEAD_OF_MAP, expr.span, Self::lint_msg().as_ref(), |diag| {\n+                multispan_sugg_with_applicability(\n+                    diag,\n+                    \"try this\",\n+                    Applicability::MachineApplicable,\n+                    std::iter::once((*method_calls(expr, 1).2.get(0).unwrap(), Self::GOOD_METHOD_NAME.into())).chain(\n+                        suggs\n+                            .into_iter()\n+                            .map(|(span1, span2)| (span1, snippet(cx, span2, \"_\").into())),\n+                    ),\n+                )\n+            });\n+        }\n+    }\n+\n+    /// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n+    fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+        if !match_type(cx, cx.tables.expr_ty(&args[0]), Self::TYPE_QPATH) {\n+            return;\n+        }\n+\n+        match args[1].kind {\n+            hir::ExprKind::Closure(_, _, body_id, closure_args_span, _) => {\n+                let closure_body = cx.tcx.hir().body(body_id);\n+                let closure_expr = remove_blocks(&closure_body.value);\n+\n+                if !Self::lint_closure_autofixable(cx, expr, args, closure_expr, closure_args_span) {\n+                    Self::lint_closure(cx, expr, closure_expr);\n+                }\n+            },\n+            // `_.and_then(Some)` case, which is no-op.\n+            hir::ExprKind::Path(ref qpath) if match_qpath(qpath, Self::BAD_VARIANT_QPATH) => {\n+                span_lint_and_sugg(\n+                    cx,\n+                    BIND_INSTEAD_OF_MAP,\n+                    expr.span,\n+                    Self::no_op_msg().as_ref(),\n+                    \"use the expression directly\",\n+                    snippet(cx, args[0].span, \"..\").into(),\n+                    Applicability::MachineApplicable,\n+                );\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+/// returns `true` if expr contains match expr desugared from try\n+fn contains_try(expr: &hir::Expr<'_>) -> bool {\n+    struct TryFinder {\n+        found: bool,\n+    }\n+\n+    impl<'hir> intravisit::Visitor<'hir> for TryFinder {\n+        type Map = Map<'hir>;\n+\n+        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+\n+        fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n+            if self.found {\n+                return;\n+            }\n+            match expr.kind {\n+                hir::ExprKind::Match(_, _, hir::MatchSource::TryDesugar) => self.found = true,\n+                _ => intravisit::walk_expr(self, expr),\n+            }\n+        }\n+    }\n+\n+    let mut visitor = TryFinder { found: false };\n+    visitor.visit_expr(expr);\n+    visitor.found\n+}\n+\n+fn find_all_ret_expressions<'hir, F>(_cx: &LateContext<'_, '_>, expr: &'hir hir::Expr<'hir>, callback: F) -> bool\n+where\n+    F: FnMut(&'hir hir::Expr<'hir>) -> bool,\n+{\n+    struct RetFinder<F> {\n+        in_stmt: bool,\n+        failed: bool,\n+        cb: F,\n+    }\n+\n+    struct WithStmtGuarg<'a, F> {\n+        val: &'a mut RetFinder<F>,\n+        prev_in_stmt: bool,\n+    }\n+\n+    impl<F> RetFinder<F> {\n+        fn inside_stmt(&mut self, in_stmt: bool) -> WithStmtGuarg<'_, F> {\n+            let prev_in_stmt = std::mem::replace(&mut self.in_stmt, in_stmt);\n+            WithStmtGuarg {\n+                val: self,\n+                prev_in_stmt,\n+            }\n+        }\n+    }\n+\n+    impl<F> std::ops::Deref for WithStmtGuarg<'_, F> {\n+        type Target = RetFinder<F>;\n+\n+        fn deref(&self) -> &Self::Target {\n+            self.val\n+        }\n+    }\n+\n+    impl<F> std::ops::DerefMut for WithStmtGuarg<'_, F> {\n+        fn deref_mut(&mut self) -> &mut Self::Target {\n+            self.val\n+        }\n+    }\n+\n+    impl<F> Drop for WithStmtGuarg<'_, F> {\n+        fn drop(&mut self) {\n+            self.val.in_stmt = self.prev_in_stmt;\n+        }\n+    }\n+\n+    impl<'hir, F: FnMut(&'hir hir::Expr<'hir>) -> bool> intravisit::Visitor<'hir> for RetFinder<F> {\n+        type Map = Map<'hir>;\n+\n+        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+\n+        fn visit_stmt(&mut self, stmt: &'hir hir::Stmt<'_>) {\n+            intravisit::walk_stmt(&mut *self.inside_stmt(true), stmt)\n+        }\n+\n+        fn visit_expr(&mut self, expr: &'hir hir::Expr<'_>) {\n+            if self.failed {\n+                return;\n+            }\n+            if self.in_stmt {\n+                match expr.kind {\n+                    hir::ExprKind::Ret(Some(expr)) => self.inside_stmt(false).visit_expr(expr),\n+                    _ => intravisit::walk_expr(self, expr),\n+                }\n+            } else {\n+                match expr.kind {\n+                    hir::ExprKind::Match(cond, arms, _) => {\n+                        self.inside_stmt(true).visit_expr(cond);\n+                        for arm in arms {\n+                            self.visit_expr(arm.body);\n+                        }\n+                    },\n+                    hir::ExprKind::Block(..) => intravisit::walk_expr(self, expr),\n+                    hir::ExprKind::Ret(Some(expr)) => self.visit_expr(expr),\n+                    _ => self.failed |= !(self.cb)(expr),\n+                }\n+            }\n+        }\n+    }\n+\n+    !contains_try(expr) && {\n+        let mut ret_finder = RetFinder {\n+            in_stmt: false,\n+            failed: false,\n+            cb: callback,\n+        };\n+        ret_finder.visit_expr(expr);\n+        !ret_finder.failed\n+    }\n+}"}, {"sha": "626427c15ecf52b2e47c7c3f77ccada601afbc7b", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 100, "deletions": 223, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,3 +1,4 @@\n+mod bind_instead_of_map;\n mod inefficient_to_string;\n mod manual_saturating_arithmetic;\n mod option_map_unwrap_or;\n@@ -7,6 +8,7 @@ use std::borrow::Cow;\n use std::fmt;\n use std::iter;\n \n+use bind_instead_of_map::BindInsteadOfMap;\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n@@ -33,40 +35,15 @@ use crate::utils::{\n };\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for `.unwrap()` calls on `Option`s.\n+    /// **What it does:** Checks for `.unwrap()` calls on `Option`s and on `Result`s.\n     ///\n-    /// **Why is this bad?** Usually it is better to handle the `None` case, or to\n-    /// at least call `.expect(_)` with a more helpful message. Still, for a lot of\n+    /// **Why is this bad?** It is better to handle the `None` or `Err` case,\n+    /// or at least call `.expect(_)` with a more helpful message. Still, for a lot of\n     /// quick-and-dirty code, `unwrap` is a good choice, which is why this lint is\n     /// `Allow` by default.\n     ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// Using unwrap on an `Option`:\n-    ///\n-    /// ```rust\n-    /// let opt = Some(1);\n-    /// opt.unwrap();\n-    /// ```\n-    ///\n-    /// Better:\n-    ///\n-    /// ```rust\n-    /// let opt = Some(1);\n-    /// opt.expect(\"more helpful message\");\n-    /// ```\n-    pub OPTION_UNWRAP_USED,\n-    restriction,\n-    \"using `Option.unwrap()`, which should at least get a better message using `expect()`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for `.unwrap()` calls on `Result`s.\n-    ///\n-    /// **Why is this bad?** `result.unwrap()` will let the thread panic on `Err`\n-    /// values. Normally, you want to implement more sophisticated error handling,\n+    /// `result.unwrap()` will let the thread panic on `Err` values.\n+    /// Normally, you want to implement more sophisticated error handling,\n     /// and propagate errors upwards with `?` operator.\n     ///\n     /// Even if you want to panic on errors, not all `Error`s implement good\n@@ -75,81 +52,73 @@ declare_clippy_lint! {\n     ///\n     /// **Known problems:** None.\n     ///\n-    /// **Example:**\n-    /// Using unwrap on an `Result`:\n-    ///\n+    /// **Examples:**\n     /// ```rust\n-    /// let res: Result<usize, ()> = Ok(1);\n-    /// res.unwrap();\n+    /// # let opt = Some(1);\n+    ///\n+    /// // Bad\n+    /// opt.unwrap();\n+    ///\n+    /// // Good\n+    /// opt.expect(\"more helpful message\");\n     /// ```\n     ///\n-    /// Better:\n+    /// // or\n     ///\n     /// ```rust\n-    /// let res: Result<usize, ()> = Ok(1);\n+    /// # let res: Result<usize, ()> = Ok(1);\n+    ///\n+    /// // Bad\n+    /// res.unwrap();\n+    ///\n+    /// // Good\n     /// res.expect(\"more helpful message\");\n     /// ```\n-    pub RESULT_UNWRAP_USED,\n+    pub UNWRAP_USED,\n     restriction,\n-    \"using `Result.unwrap()`, which might be better handled\"\n+    \"using `.unwrap()` on `Result` or `Option`, which should at least get a better message using `expect()`\"\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for `.expect()` calls on `Option`s.\n+    /// **What it does:** Checks for `.expect()` calls on `Option`s and `Result`s.\n     ///\n-    /// **Why is this bad?** Usually it is better to handle the `None` case. Still,\n-    ///  for a lot of quick-and-dirty code, `expect` is a good choice, which is why\n-    ///  this lint is `Allow` by default.\n+    /// **Why is this bad?** Usually it is better to handle the `None` or `Err` case.\n+    /// Still, for a lot of quick-and-dirty code, `expect` is a good choice, which is why\n+    /// this lint is `Allow` by default.\n     ///\n-    /// **Known problems:** None.\n+    /// `result.expect()` will let the thread panic on `Err`\n+    /// values. Normally, you want to implement more sophisticated error handling,\n+    /// and propagate errors upwards with `?` operator.\n     ///\n-    /// **Example:**\n+    /// **Known problems:** None.\n     ///\n-    /// Using expect on an `Option`:\n+    /// **Examples:**\n+    /// ```rust,ignore\n+    /// # let opt = Some(1);\n     ///\n-    /// ```rust\n-    /// let opt = Some(1);\n+    /// // Bad\n     /// opt.expect(\"one\");\n-    /// ```\n     ///\n-    /// Better:\n-    ///\n-    /// ```rust,ignore\n+    /// // Good\n     /// let opt = Some(1);\n     /// opt?;\n     /// ```\n-    pub OPTION_EXPECT_USED,\n-    restriction,\n-    \"using `Option.expect()`, which might be better handled\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for `.expect()` calls on `Result`s.\n     ///\n-    /// **Why is this bad?** `result.expect()` will let the thread panic on `Err`\n-    /// values. Normally, you want to implement more sophisticated error handling,\n-    /// and propagate errors upwards with `?` operator.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// Using expect on an `Result`:\n+    /// // or\n     ///\n     /// ```rust\n-    /// let res: Result<usize, ()> = Ok(1);\n-    /// res.expect(\"one\");\n-    /// ```\n+    /// # let res: Result<usize, ()> = Ok(1);\n     ///\n-    /// Better:\n+    /// // Bad\n+    /// res.expect(\"one\");\n     ///\n-    /// ```rust\n-    /// let res: Result<usize, ()> = Ok(1);\n+    /// // Good\n     /// res?;\n     /// # Ok::<(), ()>(())\n     /// ```\n-    pub RESULT_EXPECT_USED,\n+    pub EXPECT_USED,\n     restriction,\n-    \"using `Result.expect()`, which might be better handled\"\n+    \"using `.expect()` on `Result` or `Option`, which might be better handled\"\n }\n \n declare_clippy_lint! {\n@@ -257,59 +226,40 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for usage of `_.map(_).unwrap_or(_)`.\n+    /// **What it does:** Checks for usage of `option.map(_).unwrap_or(_)` or `option.map(_).unwrap_or_else(_)` or\n+    /// `result.map(_).unwrap_or_else(_)`.\n     ///\n-    /// **Why is this bad?** Readability, this can be written more concisely as\n-    /// `_.map_or(_, _)`.\n+    /// **Why is this bad?** Readability, these can be written more concisely (resp.) as\n+    /// `option.map_or(_, _)`, `option.map_or_else(_, _)` and `result.map_or_else(_, _)`.\n     ///\n     /// **Known problems:** The order of the arguments is not in execution order\n     ///\n-    /// **Example:**\n+    /// **Examples:**\n     /// ```rust\n     /// # let x = Some(1);\n-    /// x.map(|a| a + 1).unwrap_or(0);\n-    /// ```\n-    pub OPTION_MAP_UNWRAP_OR,\n-    pedantic,\n-    \"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for usage of `_.map(_).unwrap_or_else(_)`.\n-    ///\n-    /// **Why is this bad?** Readability, this can be written more concisely as\n-    /// `_.map_or_else(_, _)`.\n     ///\n-    /// **Known problems:** The order of the arguments is not in execution order.\n+    /// // Bad\n+    /// x.map(|a| a + 1).unwrap_or(0);\n     ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # let x = Some(1);\n-    /// # fn some_function() -> usize { 1 }\n-    /// x.map(|a| a + 1).unwrap_or_else(some_function);\n+    /// // Good\n+    /// x.map_or(0, |a| a + 1);\n     /// ```\n-    pub OPTION_MAP_UNWRAP_OR_ELSE,\n-    pedantic,\n-    \"using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for usage of `result.map(_).unwrap_or_else(_)`.\n     ///\n-    /// **Why is this bad?** Readability, this can be written more concisely as\n-    /// `result.map_or_else(_, _)`.\n+    /// // or\n     ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n     /// ```rust\n     /// # let x: Result<usize, ()> = Ok(1);\n     /// # fn some_function(foo: ()) -> usize { 1 }\n+    ///\n+    /// // Bad\n     /// x.map(|a| a + 1).unwrap_or_else(some_function);\n+    ///\n+    /// // Good\n+    /// x.map_or_else(some_function, |a| a + 1);\n     /// ```\n-    pub RESULT_MAP_UNWRAP_OR_ELSE,\n+    pub MAP_UNWRAP_OR,\n     pedantic,\n-    \"using `Result.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `.map_or_else(g, f)`\"\n+    \"using `.map(f).unwrap_or(a)` or `.map(f).unwrap_or_else(func)`, which are more succinctly expressed as `map_or(a, f)` or `map_or_else(a, f)`\"\n }\n \n declare_clippy_lint! {\n@@ -358,27 +308,34 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for usage of `_.and_then(|x| Some(y))`.\n+    /// **What it does:** Checks for usage of `_.and_then(|x| Some(y))`, `_.and_then(|x| Ok(y))` or\n+    /// `_.or_else(|x| Err(y))`.\n     ///\n     /// **Why is this bad?** Readability, this can be written more concisely as\n-    /// `_.map(|x| y)`.\n+    /// `_.map(|x| y)` or `_.map_err(|x| y)`.\n     ///\n     /// **Known problems:** None\n     ///\n     /// **Example:**\n     ///\n     /// ```rust\n-    /// let x = Some(\"foo\");\n-    /// let _ = x.and_then(|s| Some(s.len()));\n+    /// # fn opt() -> Option<&'static str> { Some(\"42\") }\n+    /// # fn res() -> Result<&'static str, &'static str> { Ok(\"42\") }\n+    /// let _ = opt().and_then(|s| Some(s.len()));\n+    /// let _ = res().and_then(|s| if s.len() == 42 { Ok(10) } else { Ok(20) });\n+    /// let _ = res().or_else(|s| if s.len() == 42 { Err(10) } else { Err(20) });\n     /// ```\n     ///\n     /// The correct use would be:\n     ///\n     /// ```rust\n-    /// let x = Some(\"foo\");\n-    /// let _ = x.map(|s| s.len());\n+    /// # fn opt() -> Option<&'static str> { Some(\"42\") }\n+    /// # fn res() -> Result<&'static str, &'static str> { Ok(\"42\") }\n+    /// let _ = opt().map(|s| s.len());\n+    /// let _ = res().map(|s| if s.len() == 42 { 10 } else { 20 });\n+    /// let _ = res().map_err(|s| if s.len() == 42 { 10 } else { 20 });\n     /// ```\n-    pub OPTION_AND_THEN_SOME,\n+    pub BIND_INSTEAD_OF_MAP,\n     complexity,\n     \"using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\"\n }\n@@ -1286,20 +1243,16 @@ declare_clippy_lint! {\n }\n \n declare_lint_pass!(Methods => [\n-    OPTION_UNWRAP_USED,\n-    RESULT_UNWRAP_USED,\n-    OPTION_EXPECT_USED,\n-    RESULT_EXPECT_USED,\n+    UNWRAP_USED,\n+    EXPECT_USED,\n     SHOULD_IMPLEMENT_TRAIT,\n     WRONG_SELF_CONVENTION,\n     WRONG_PUB_SELF_CONVENTION,\n     OK_EXPECT,\n-    OPTION_MAP_UNWRAP_OR,\n-    OPTION_MAP_UNWRAP_OR_ELSE,\n-    RESULT_MAP_UNWRAP_OR_ELSE,\n+    MAP_UNWRAP_OR,\n     RESULT_MAP_OR_INTO_OPTION,\n     OPTION_MAP_OR_NONE,\n-    OPTION_AND_THEN_SOME,\n+    BIND_INSTEAD_OF_MAP,\n     OR_FUN_CALL,\n     EXPECT_FUN_CALL,\n     CHARS_NEXT_CMP,\n@@ -1358,7 +1311,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n             [\"unwrap_or_else\", \"map\"] => lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n-            [\"and_then\", ..] => lint_option_and_then_some(cx, expr, arg_lists[0]),\n+            [\"and_then\", ..] => {\n+                bind_instead_of_map::OptionAndThenSome::lint(cx, expr, arg_lists[0]);\n+                bind_instead_of_map::ResultAndThenOk::lint(cx, expr, arg_lists[0]);\n+            },\n+            [\"or_else\", ..] => {\n+                bind_instead_of_map::ResultOrElseErrInfo::lint(cx, expr, arg_lists[0]);\n+            },\n             [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n             [\"next\", \"skip_while\"] => lint_skip_while_next(cx, expr, arg_lists[1]),\n             [\"map\", \"filter\"] => lint_filter_map(cx, expr, arg_lists[1], arg_lists[0]),\n@@ -1503,9 +1462,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                             cx,\n                             lint,\n                             first_arg.pat.span,\n-                            &format!(\n-                               \"methods called `{}` usually take {}; consider choosing a less \\\n-                                 ambiguous name\",\n+                            &format!(\"methods called `{}` usually take {}; consider choosing a less ambiguous name\",\n                                 conv,\n                                 &self_kinds\n                                     .iter()\n@@ -1678,7 +1635,7 @@ fn lint_or_fun_call<'a, 'tcx>(\n             let self_ty = cx.tables.expr_ty(self_expr);\n \n             if let Some(&(_, fn_has_arguments, poss, suffix)) =\n-                   know_types.iter().find(|&&i| match_type(cx, self_ty, i.0));\n+                know_types.iter().find(|&&i| match_type(cx, self_ty, i.0));\n \n             if poss.contains(&name);\n \n@@ -1931,7 +1888,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, arg: &hir:\n                 CLONE_DOUBLE_REF,\n                 expr.span,\n                 \"using `clone` on a double-reference; \\\n-                 this will copy the reference instead of cloning the inner type\",\n+                this will copy the reference instead of cloning the inner type\",\n                 |diag| {\n                     if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n                         let mut ty = innermost;\n@@ -2121,7 +2078,7 @@ fn lint_iter_cloned_collect<'a, 'tcx>(\n                 ITER_CLONED_COLLECT,\n                 to_replace,\n                 \"called `iter().cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n-                 more readable\",\n+                more readable\",\n                 \"try\",\n                 \".to_vec()\".to_string(),\n                 Applicability::MachineApplicable,\n@@ -2420,9 +2377,9 @@ fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, unwrap_args: &[hi\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&unwrap_args[0]));\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n-        Some((OPTION_UNWRAP_USED, \"an Option\", \"None\"))\n+        Some((UNWRAP_USED, \"an Option\", \"None\"))\n     } else if is_type_diagnostic_item(cx, obj_ty, sym!(result_type)) {\n-        Some((RESULT_UNWRAP_USED, \"a Result\", \"Err\"))\n+        Some((UNWRAP_USED, \"a Result\", \"Err\"))\n     } else {\n         None\n     };\n@@ -2436,7 +2393,7 @@ fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, unwrap_args: &[hi\n             None,\n             &format!(\n                 \"if you don't want to handle the `{}` case gracefully, consider \\\n-                 using `expect()` to provide a better panic message\",\n+                using `expect()` to provide a better panic message\",\n                 none_value,\n             ),\n         );\n@@ -2448,9 +2405,9 @@ fn lint_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, expect_args: &[hi\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&expect_args[0]));\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n-        Some((OPTION_EXPECT_USED, \"an Option\", \"None\"))\n+        Some((EXPECT_USED, \"an Option\", \"None\"))\n     } else if is_type_diagnostic_item(cx, obj_ty, sym!(result_type)) {\n-        Some((RESULT_EXPECT_USED, \"a Result\", \"Err\"))\n+        Some((EXPECT_USED, \"a Result\", \"Err\"))\n     } else {\n         None\n     };\n@@ -2494,7 +2451,7 @@ fn lint_map_flatten<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<\n     // lint if caller of `.map().flatten()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `map(..).flatten()` on an `Iterator`. \\\n-                   This is more succinctly expressed by calling `.flat_map(..)`\";\n+                    This is more succinctly expressed by calling `.flat_map(..)`\";\n         let self_snippet = snippet(cx, map_args[0].span, \"..\");\n         let func_snippet = snippet(cx, map_args[1].span, \"..\");\n         let hint = format!(\"{0}.flat_map({1})\", self_snippet, func_snippet);\n@@ -2555,10 +2512,10 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n         // lint message\n         let msg = if is_option {\n             \"called `map(f).unwrap_or_else(g)` on an `Option` value. This can be done more directly by calling \\\n-             `map_or_else(g, f)` instead\"\n+            `map_or_else(g, f)` instead\"\n         } else {\n             \"called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling \\\n-             `.map_or_else(g, f)` instead\"\n+            `.map_or_else(g, f)` instead\"\n         };\n         // get snippets for args to map() and unwrap_or_else()\n         let map_snippet = snippet(cx, map_args[1].span, \"..\");\n@@ -2570,11 +2527,7 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n         if same_span && !multiline {\n             span_lint_and_note(\n                 cx,\n-                if is_option {\n-                    OPTION_MAP_UNWRAP_OR_ELSE\n-                } else {\n-                    RESULT_MAP_UNWRAP_OR_ELSE\n-                },\n+                MAP_UNWRAP_OR,\n                 expr.span,\n                 msg,\n                 None,\n@@ -2584,16 +2537,7 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n                 ),\n             );\n         } else if same_span && multiline {\n-            span_lint(\n-                cx,\n-                if is_option {\n-                    OPTION_MAP_UNWRAP_OR_ELSE\n-                } else {\n-                    RESULT_MAP_UNWRAP_OR_ELSE\n-                },\n-                expr.span,\n-                msg,\n-            );\n+            span_lint(cx, MAP_UNWRAP_OR, expr.span, msg);\n         };\n     }\n }\n@@ -2672,73 +2616,6 @@ fn lint_map_or_none<'a, 'tcx>(\n     );\n }\n \n-/// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n-fn lint_option_and_then_some(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    const LINT_MSG: &str = \"using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\";\n-    const NO_OP_MSG: &str = \"using `Option.and_then(Some)`, which is a no-op\";\n-\n-    let ty = cx.tables.expr_ty(&args[0]);\n-    if !is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n-        return;\n-    }\n-\n-    match args[1].kind {\n-        hir::ExprKind::Closure(_, _, body_id, closure_args_span, _) => {\n-            let closure_body = cx.tcx.hir().body(body_id);\n-            let closure_expr = remove_blocks(&closure_body.value);\n-            if_chain! {\n-                if let hir::ExprKind::Call(ref some_expr, ref some_args) = closure_expr.kind;\n-                if let hir::ExprKind::Path(ref qpath) = some_expr.kind;\n-                if match_qpath(qpath, &paths::OPTION_SOME);\n-                if some_args.len() == 1;\n-                then {\n-                    let inner_expr = &some_args[0];\n-\n-                    if contains_return(inner_expr) {\n-                        return;\n-                    }\n-\n-                    let some_inner_snip = if inner_expr.span.from_expansion() {\n-                        snippet_with_macro_callsite(cx, inner_expr.span, \"_\")\n-                    } else {\n-                        snippet(cx, inner_expr.span, \"_\")\n-                    };\n-\n-                    let closure_args_snip = snippet(cx, closure_args_span, \"..\");\n-                    let option_snip = snippet(cx, args[0].span, \"..\");\n-                    let note = format!(\"{}.map({} {})\", option_snip, closure_args_snip, some_inner_snip);\n-                    span_lint_and_sugg(\n-                        cx,\n-                        OPTION_AND_THEN_SOME,\n-                        expr.span,\n-                        LINT_MSG,\n-                        \"try this\",\n-                        note,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        },\n-        // `_.and_then(Some)` case, which is no-op.\n-        hir::ExprKind::Path(ref qpath) => {\n-            if match_qpath(qpath, &paths::OPTION_SOME) {\n-                let option_snip = snippet(cx, args[0].span, \"..\");\n-                let note = format!(\"{}\", option_snip);\n-                span_lint_and_sugg(\n-                    cx,\n-                    OPTION_AND_THEN_SOME,\n-                    expr.span,\n-                    NO_OP_MSG,\n-                    \"use the expression directly\",\n-                    note,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        },\n-        _ => {},\n-    }\n-}\n-\n /// lint use of `filter().next()` for `Iterators`\n fn lint_filter_next<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,"}, {"sha": "20c60ef33189dc45f41ffa9f421b369a2648af00", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::hir::map::Map;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n \n-use super::OPTION_MAP_UNWRAP_OR;\n+use super::MAP_UNWRAP_OR;\n \n /// lint use of `map().unwrap_or()` for `Option`s\n pub(super) fn lint<'a, 'tcx>(\n@@ -62,11 +62,11 @@ pub(super) fn lint<'a, 'tcx>(\n         };\n         let msg = &format!(\n             \"called `map(f).unwrap_or({})` on an `Option` value. \\\n-             This can be done more directly by calling `{}` instead\",\n+            This can be done more directly by calling `{}` instead\",\n             arg, suggest\n         );\n \n-        span_lint_and_then(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, |diag| {\n+        span_lint_and_then(cx, MAP_UNWRAP_OR, expr.span, msg, |diag| {\n             let map_arg_span = map_args[1].span;\n \n             let mut suggestion = vec!["}, {"sha": "ed48ab548978c67811c7056c949e38007ca41743", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                             );\n                             spans.sort_by_key(|&(span, _)| span);\n                         }\n-                        multispan_sugg(diag, \"consider taking a reference instead\".to_string(), spans);\n+                        multispan_sugg(diag, \"consider taking a reference instead\", spans);\n                     };\n \n                     span_lint_and_then("}, {"sha": "83c6faac04149f344ea4916f50e05d437f7411e4", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 110, "deletions": 2, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,14 +1,17 @@\n+use crate::consts::{constant, Constant};\n use if_chain::if_chain;\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Spanned;\n+use std::cmp::Ordering;\n \n use crate::utils::sugg::Sugg;\n+use crate::utils::{get_parent_expr, is_integer_const, snippet, snippet_opt, span_lint, span_lint_and_then};\n use crate::utils::{higher, SpanlessEq};\n-use crate::utils::{is_integer_const, snippet, snippet_opt, span_lint, span_lint_and_then};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for zipping a collection with the range of\n@@ -84,10 +87,44 @@ declare_clippy_lint! {\n     \"`x..=(y-1)` reads better as `x..y`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for range expressions `x..y` where both `x` and `y`\n+    /// are constant and `x` is greater or equal to `y`.\n+    ///\n+    /// **Why is this bad?** Empty ranges yield no values so iterating them is a no-op.\n+    /// Moreover, trying to use a reversed range to index a slice will panic at run-time.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,no_run\n+    /// fn main() {\n+    ///     (10..=0).for_each(|x| println!(\"{}\", x));\n+    ///\n+    ///     let arr = [1, 2, 3, 4, 5];\n+    ///     let sub = &arr[3..1];\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn main() {\n+    ///     (0..=10).rev().for_each(|x| println!(\"{}\", x));\n+    ///\n+    ///     let arr = [1, 2, 3, 4, 5];\n+    ///     let sub = &arr[1..3];\n+    /// }\n+    /// ```\n+    pub REVERSED_EMPTY_RANGES,\n+    correctness,\n+    \"reversing the limits of range expressions, resulting in empty ranges\"\n+}\n+\n declare_lint_pass!(Ranges => [\n     RANGE_ZIP_WITH_LEN,\n     RANGE_PLUS_ONE,\n-    RANGE_MINUS_ONE\n+    RANGE_MINUS_ONE,\n+    REVERSED_EMPTY_RANGES,\n ]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ranges {\n@@ -124,6 +161,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ranges {\n \n         check_exclusive_range_plus_one(cx, expr);\n         check_inclusive_range_minus_one(cx, expr);\n+        check_reversed_empty_range(cx, expr);\n     }\n }\n \n@@ -202,6 +240,76 @@ fn check_inclusive_range_minus_one(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     }\n }\n \n+fn check_reversed_empty_range(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    fn inside_indexing_expr(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+        matches!(\n+            get_parent_expr(cx, expr),\n+            Some(Expr {\n+                kind: ExprKind::Index(..),\n+                ..\n+            })\n+        )\n+    }\n+\n+    fn is_empty_range(limits: RangeLimits, ordering: Ordering) -> bool {\n+        match limits {\n+            RangeLimits::HalfOpen => ordering != Ordering::Less,\n+            RangeLimits::Closed => ordering == Ordering::Greater,\n+        }\n+    }\n+\n+    if_chain! {\n+        if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(cx, expr);\n+        let ty = cx.tables.expr_ty(start);\n+        if let ty::Int(_) | ty::Uint(_) = ty.kind;\n+        if let Some((start_idx, _)) = constant(cx, cx.tables, start);\n+        if let Some((end_idx, _)) = constant(cx, cx.tables, end);\n+        if let Some(ordering) = Constant::partial_cmp(cx.tcx, ty, &start_idx, &end_idx);\n+        if is_empty_range(limits, ordering);\n+        then {\n+            if inside_indexing_expr(cx, expr) {\n+                let (reason, outcome) = if ordering == Ordering::Equal {\n+                    (\"empty\", \"always yield an empty slice\")\n+                } else {\n+                    (\"reversed\", \"panic at run-time\")\n+                };\n+\n+                span_lint(\n+                    cx,\n+                    REVERSED_EMPTY_RANGES,\n+                    expr.span,\n+                    &format!(\"this range is {} and using it to index a slice will {}\", reason, outcome),\n+                );\n+            } else {\n+                span_lint_and_then(\n+                    cx,\n+                    REVERSED_EMPTY_RANGES,\n+                    expr.span,\n+                    \"this range is empty so it will yield no values\",\n+                    |diag| {\n+                        if ordering != Ordering::Equal {\n+                            let start_snippet = snippet(cx, start.span, \"_\");\n+                            let end_snippet = snippet(cx, end.span, \"_\");\n+                            let dots = match limits {\n+                                RangeLimits::HalfOpen => \"..\",\n+                                RangeLimits::Closed => \"..=\"\n+                            };\n+\n+                            diag.span_suggestion(\n+                                expr.span,\n+                                \"consider using the following if you are attempting to iterate over this \\\n+                                 range in reverse\",\n+                                format!(\"({}{}{}).rev()\", end_snippet, dots, start_snippet),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}\n+\n fn y_plus_one<'t>(cx: &LateContext<'_, '_>, expr: &'t Expr<'_>) -> Option<&'t Expr<'t>> {\n     match expr.kind {\n         ExprKind::Binary("}, {"sha": "35464f629c3646e1e3031eb82844e676c1e92eea", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 42, "deletions": 22, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -248,28 +248,7 @@ impl EarlyLintPass for Return {\n             if let ast::TyKind::Tup(ref vals) = ty.kind;\n             if vals.is_empty() && !ty.span.from_expansion() && get_def(span) == get_def(ty.span);\n             then {\n-                let (rspan, appl) = if let Ok(fn_source) =\n-                        cx.sess().source_map()\n-                                 .span_to_snippet(span.with_hi(ty.span.hi())) {\n-                    if let Some(rpos) = fn_source.rfind(\"->\") {\n-                        #[allow(clippy::cast_possible_truncation)]\n-                        (ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n-                            Applicability::MachineApplicable)\n-                    } else {\n-                        (ty.span, Applicability::MaybeIncorrect)\n-                    }\n-                } else {\n-                    (ty.span, Applicability::MaybeIncorrect)\n-                };\n-                span_lint_and_sugg(\n-                    cx,\n-                    UNUSED_UNIT,\n-                    rspan,\n-                    \"unneeded unit return type\",\n-                    \"remove the `-> ()`\",\n-                    String::new(),\n-                    appl,\n-                );\n+                lint_unneeded_unit_return(cx, ty, span);\n             }\n         }\n     }\n@@ -313,6 +292,22 @@ impl EarlyLintPass for Return {\n             _ => (),\n         }\n     }\n+\n+    fn check_poly_trait_ref(&mut self, cx: &EarlyContext<'_>, poly: &ast::PolyTraitRef, _: &ast::TraitBoundModifier) {\n+        let segments = &poly.trait_ref.path.segments;\n+\n+        if_chain! {\n+            if segments.len() == 1;\n+            if [\"Fn\", \"FnMut\", \"FnOnce\"].contains(&&*segments[0].ident.name.as_str());\n+            if let Some(args) = &segments[0].args;\n+            if let ast::GenericArgs::Parenthesized(generic_args) = &**args;\n+            if let ast::FnRetTy::Ty(ty) = &generic_args.output;\n+            if ty.kind.is_unit();\n+            then {\n+                lint_unneeded_unit_return(cx, ty, generic_args.span);\n+            }\n+        }\n+    }\n }\n \n fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n@@ -337,3 +332,28 @@ fn is_unit_expr(expr: &ast::Expr) -> bool {\n         false\n     }\n }\n+\n+fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n+    let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n+        if let Some(rpos) = fn_source.rfind(\"->\") {\n+            #[allow(clippy::cast_possible_truncation)]\n+            (\n+                ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n+                Applicability::MachineApplicable,\n+            )\n+        } else {\n+            (ty.span, Applicability::MaybeIncorrect)\n+        }\n+    } else {\n+        (ty.span, Applicability::MaybeIncorrect)\n+    };\n+    span_lint_and_sugg(\n+        cx,\n+        UNUSED_UNIT,\n+        ret_span,\n+        \"unneeded unit return type\",\n+        \"remove the `-> ()`\",\n+        String::new(),\n+        appl,\n+    );\n+}"}, {"sha": "6ed9ff22e466482bd7d473cea7f40992e3d3ad02", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -2206,7 +2206,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n \n             multispan_sugg(\n                 diag,\n-                \"consider adding a type parameter\".to_string(),\n+                \"consider adding a type parameter\",\n                 vec![\n                     (\n                         generics_suggestion_span,\n@@ -2230,7 +2230,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n             );\n \n             if !vis.suggestions.is_empty() {\n-                multispan_sugg(diag, \"...and use generic constructor\".into(), vis.suggestions);\n+                multispan_sugg(diag, \"...and use generic constructor\", vis.suggestions);\n             }\n         }\n "}, {"sha": "8b971e7064b52d9137298169e778a57b23ea7f7e", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::{BinOpKind, Body, Expr, ExprKind, FnDecl, HirId, Path, QPath, UnO\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::Ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n \n@@ -90,6 +91,14 @@ fn collect_unwrap_info<'a, 'tcx>(\n     branch: &'tcx Expr<'_>,\n     invert: bool,\n ) -> Vec<UnwrapInfo<'tcx>> {\n+    fn is_relevant_option_call(cx: &LateContext<'_, '_>, ty: Ty<'_>, method_name: &str) -> bool {\n+        is_type_diagnostic_item(cx, ty, sym!(option_type)) && [\"is_some\", \"is_none\"].contains(&method_name)\n+    }\n+\n+    fn is_relevant_result_call(cx: &LateContext<'_, '_>, ty: Ty<'_>, method_name: &str) -> bool {\n+        is_type_diagnostic_item(cx, ty, sym!(result_type)) && [\"is_ok\", \"is_err\"].contains(&method_name)\n+    }\n+\n     if let ExprKind::Binary(op, left, right) = &expr.kind {\n         match (invert, op.node) {\n             (false, BinOpKind::And) | (false, BinOpKind::BitAnd) | (true, BinOpKind::Or) | (true, BinOpKind::BitOr) => {\n@@ -106,9 +115,8 @@ fn collect_unwrap_info<'a, 'tcx>(\n             if let ExprKind::MethodCall(method_name, _, args) = &expr.kind;\n             if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].kind;\n             let ty = cx.tables.expr_ty(&args[0]);\n-            if is_type_diagnostic_item(cx, ty, sym!(option_type)) || is_type_diagnostic_item(cx, ty, sym!(result_type));\n             let name = method_name.ident.as_str();\n-            if [\"is_some\", \"is_none\", \"is_ok\", \"is_err\"].contains(&&*name);\n+            if is_relevant_option_call(cx, ty, &name) || is_relevant_result_call(cx, ty, &name);\n             then {\n                 assert!(args.len() == 1);\n                 let unwrappable = match name.as_ref() {"}, {"sha": "95921518986bcb464581a61ca20b7680e9094ede", "filename": "clippy_lints/src/useless_conversion.rs", "status": "renamed", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -7,30 +7,36 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for always-identical `Into`/`From`/`IntoIter` conversions.\n+    /// **What it does:** Checks for `Into`/`From`/`IntoIter` calls that useless converts\n+    /// to the same type as caller.\n     ///\n     /// **Why is this bad?** Redundant code.\n     ///\n     /// **Known problems:** None.\n     ///\n     /// **Example:**\n+    ///\n     /// ```rust\n+    /// // Bad\n     /// // format!() returns a `String`\n     /// let s: String = format!(\"hello\").into();\n+    ///\n+    /// // Good\n+    /// let s: String = format!(\"hello\");\n     /// ```\n-    pub IDENTITY_CONVERSION,\n+    pub USELESS_CONVERSION,\n     complexity,\n-    \"using always-identical `Into`/`From`/`IntoIter` conversions\"\n+    \"calls to `Into`/`From`/`IntoIter` that performs useless conversions to the same type\"\n }\n \n #[derive(Default)]\n-pub struct IdentityConversion {\n+pub struct UselessConversion {\n     try_desugar_arm: Vec<HirId>,\n }\n \n-impl_lint_pass!(IdentityConversion => [IDENTITY_CONVERSION]);\n+impl_lint_pass!(UselessConversion => [USELESS_CONVERSION]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if e.span.from_expansion() {\n             return;\n@@ -60,9 +66,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n \n                         span_lint_and_sugg(\n                             cx,\n-                            IDENTITY_CONVERSION,\n+                            USELESS_CONVERSION,\n                             e.span,\n-                            \"identical conversion\",\n+                            \"useless conversion\",\n                             \"consider removing `.into()`\",\n                             sugg,\n                             Applicability::MachineApplicable, // snippet\n@@ -76,9 +82,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n                         let sugg = snippet(cx, args[0].span, \"<expr>\").into_owned();\n                         span_lint_and_sugg(\n                             cx,\n-                            IDENTITY_CONVERSION,\n+                            USELESS_CONVERSION,\n                             e.span,\n-                            \"identical conversion\",\n+                            \"useless conversion\",\n                             \"consider removing `.into_iter()`\",\n                             sugg,\n                             Applicability::MachineApplicable, // snippet\n@@ -99,9 +105,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n                                     format!(\"consider removing `{}()`\", snippet(cx, path.span, \"From::from\"));\n                                 span_lint_and_sugg(\n                                     cx,\n-                                    IDENTITY_CONVERSION,\n+                                    USELESS_CONVERSION,\n                                     e.span,\n-                                    \"identical conversion\",\n+                                    \"useless conversion\",\n                                     &sugg_msg,\n                                     sugg,\n                                     Applicability::MachineApplicable, // snippet", "previous_filename": "clippy_lints/src/identity_conversion.rs"}, {"sha": "f6d87c8532e430357b22a54b825c580fe1f0dc31", "filename": "clippy_lints/src/utils/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,6 +1,6 @@\n //! Clippy wrappers around rustc's diagnostic functions.\n \n-use rustc_errors::{Applicability, CodeSuggestion, DiagnosticBuilder, Substitution, SubstitutionPart, SuggestionStyle};\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::HirId;\n use rustc_lint::{LateContext, Lint, LintContext};\n use rustc_span::source_map::{MultiSpan, Span};\n@@ -198,20 +198,20 @@ pub fn span_lint_and_sugg<'a, T: LintContext>(\n /// appear once per\n /// replacement. In human-readable format though, it only appears once before\n /// the whole suggestion.\n-pub fn multispan_sugg<I>(diag: &mut DiagnosticBuilder<'_>, help_msg: String, sugg: I)\n+pub fn multispan_sugg<I>(diag: &mut DiagnosticBuilder<'_>, help_msg: &str, sugg: I)\n where\n     I: IntoIterator<Item = (Span, String)>,\n {\n-    let sugg = CodeSuggestion {\n-        substitutions: vec![Substitution {\n-            parts: sugg\n-                .into_iter()\n-                .map(|(span, snippet)| SubstitutionPart { snippet, span })\n-                .collect(),\n-        }],\n-        msg: help_msg,\n-        style: SuggestionStyle::ShowCode,\n-        applicability: Applicability::Unspecified,\n-    };\n-    diag.suggestions.push(sugg);\n+    multispan_sugg_with_applicability(diag, help_msg, Applicability::Unspecified, sugg)\n+}\n+\n+pub fn multispan_sugg_with_applicability<I>(\n+    diag: &mut DiagnosticBuilder<'_>,\n+    help_msg: &str,\n+    applicability: Applicability,\n+    sugg: I,\n+) where\n+    I: IntoIterator<Item = (Span, String)>,\n+{\n+    diag.multipart_suggestion(help_msg, sugg.into_iter().collect(), applicability);\n }"}, {"sha": "904d948ad29ed17244faf871f2c8a75d474db8ad", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -77,8 +77,8 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n }\n \n pub struct UsedVisitor {\n-    pub var: Symbol,    // var to look for\n-    pub used: bool,     // has the var been used otherwise?\n+    pub var: Symbol, // var to look for\n+    pub used: bool,  // has the var been used otherwise?\n }\n \n impl<'tcx> Visitor<'tcx> for UsedVisitor {"}, {"sha": "d3a7e24937f95e865ff81cd7ae31ec6d994a8026", "filename": "src/driver.rs", "status": "modified", "additions": 110, "deletions": 112, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -295,121 +295,119 @@ fn toolchain_path(home: Option<String>, toolchain: Option<String>) -> Option<Pat\n pub fn main() {\n     rustc_driver::init_rustc_env_logger();\n     lazy_static::initialize(&ICE_HOOK);\n-    exit(\n-        rustc_driver::catch_with_exit_code(move || {\n-            let mut orig_args: Vec<String> = env::args().collect();\n-\n-            if orig_args.iter().any(|a| a == \"--version\" || a == \"-V\") {\n-                let version_info = rustc_tools_util::get_version_info!();\n-                println!(\"{}\", version_info);\n-                exit(0);\n-            }\n+    exit(rustc_driver::catch_with_exit_code(move || {\n+        let mut orig_args: Vec<String> = env::args().collect();\n \n-            // Get the sysroot, looking from most specific to this invocation to the least:\n-            // - command line\n-            // - runtime environment\n-            //    - SYSROOT\n-            //    - RUSTUP_HOME, MULTIRUST_HOME, RUSTUP_TOOLCHAIN, MULTIRUST_TOOLCHAIN\n-            // - sysroot from rustc in the path\n-            // - compile-time environment\n-            //    - SYSROOT\n-            //    - RUSTUP_HOME, MULTIRUST_HOME, RUSTUP_TOOLCHAIN, MULTIRUST_TOOLCHAIN\n-            let sys_root_arg = arg_value(&orig_args, \"--sysroot\", |_| true);\n-            let have_sys_root_arg = sys_root_arg.is_some();\n-            let sys_root = sys_root_arg\n-                .map(PathBuf::from)\n-                .or_else(|| std::env::var(\"SYSROOT\").ok().map(PathBuf::from))\n-                .or_else(|| {\n-                    let home = std::env::var(\"RUSTUP_HOME\")\n-                        .or_else(|_| std::env::var(\"MULTIRUST_HOME\"))\n-                        .ok();\n-                    let toolchain = std::env::var(\"RUSTUP_TOOLCHAIN\")\n-                        .or_else(|_| std::env::var(\"MULTIRUST_TOOLCHAIN\"))\n-                        .ok();\n-                    toolchain_path(home, toolchain)\n-                })\n-                .or_else(|| {\n-                    Command::new(\"rustc\")\n-                        .arg(\"--print\")\n-                        .arg(\"sysroot\")\n-                        .output()\n-                        .ok()\n-                        .and_then(|out| String::from_utf8(out.stdout).ok())\n-                        .map(|s| PathBuf::from(s.trim()))\n-                })\n-                .or_else(|| option_env!(\"SYSROOT\").map(PathBuf::from))\n-                .or_else(|| {\n-                    let home = option_env!(\"RUSTUP_HOME\")\n-                        .or(option_env!(\"MULTIRUST_HOME\"))\n-                        .map(ToString::to_string);\n-                    let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\")\n-                        .or(option_env!(\"MULTIRUST_TOOLCHAIN\"))\n-                        .map(ToString::to_string);\n-                    toolchain_path(home, toolchain)\n-                })\n-                .map(|pb| pb.to_string_lossy().to_string())\n-                .expect(\"need to specify SYSROOT env var during clippy compilation, or use rustup or multirust\");\n-\n-            // Setting RUSTC_WRAPPER causes Cargo to pass 'rustc' as the first argument.\n-            // We're invoking the compiler programmatically, so we ignore this/\n-            let wrapper_mode = orig_args.get(1).map(Path::new).and_then(Path::file_stem) == Some(\"rustc\".as_ref());\n-\n-            if wrapper_mode {\n-                // we still want to be able to invoke it normally though\n-                orig_args.remove(1);\n-            }\n+        if orig_args.iter().any(|a| a == \"--version\" || a == \"-V\") {\n+            let version_info = rustc_tools_util::get_version_info!();\n+            println!(\"{}\", version_info);\n+            exit(0);\n+        }\n \n-            if !wrapper_mode && (orig_args.iter().any(|a| a == \"--help\" || a == \"-h\") || orig_args.len() == 1) {\n-                display_help();\n-                exit(0);\n-            }\n+        // Get the sysroot, looking from most specific to this invocation to the least:\n+        // - command line\n+        // - runtime environment\n+        //    - SYSROOT\n+        //    - RUSTUP_HOME, MULTIRUST_HOME, RUSTUP_TOOLCHAIN, MULTIRUST_TOOLCHAIN\n+        // - sysroot from rustc in the path\n+        // - compile-time environment\n+        //    - SYSROOT\n+        //    - RUSTUP_HOME, MULTIRUST_HOME, RUSTUP_TOOLCHAIN, MULTIRUST_TOOLCHAIN\n+        let sys_root_arg = arg_value(&orig_args, \"--sysroot\", |_| true);\n+        let have_sys_root_arg = sys_root_arg.is_some();\n+        let sys_root = sys_root_arg\n+            .map(PathBuf::from)\n+            .or_else(|| std::env::var(\"SYSROOT\").ok().map(PathBuf::from))\n+            .or_else(|| {\n+                let home = std::env::var(\"RUSTUP_HOME\")\n+                    .or_else(|_| std::env::var(\"MULTIRUST_HOME\"))\n+                    .ok();\n+                let toolchain = std::env::var(\"RUSTUP_TOOLCHAIN\")\n+                    .or_else(|_| std::env::var(\"MULTIRUST_TOOLCHAIN\"))\n+                    .ok();\n+                toolchain_path(home, toolchain)\n+            })\n+            .or_else(|| {\n+                Command::new(\"rustc\")\n+                    .arg(\"--print\")\n+                    .arg(\"sysroot\")\n+                    .output()\n+                    .ok()\n+                    .and_then(|out| String::from_utf8(out.stdout).ok())\n+                    .map(|s| PathBuf::from(s.trim()))\n+            })\n+            .or_else(|| option_env!(\"SYSROOT\").map(PathBuf::from))\n+            .or_else(|| {\n+                let home = option_env!(\"RUSTUP_HOME\")\n+                    .or(option_env!(\"MULTIRUST_HOME\"))\n+                    .map(ToString::to_string);\n+                let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\")\n+                    .or(option_env!(\"MULTIRUST_TOOLCHAIN\"))\n+                    .map(ToString::to_string);\n+                toolchain_path(home, toolchain)\n+            })\n+            .map(|pb| pb.to_string_lossy().to_string())\n+            .expect(\"need to specify SYSROOT env var during clippy compilation, or use rustup or multirust\");\n \n-            let should_describe_lints = || {\n-                let args: Vec<_> = env::args().collect();\n-                args.windows(2).any(|args| {\n-                    args[1] == \"help\"\n-                        && match args[0].as_str() {\n-                            \"-W\" | \"-A\" | \"-D\" | \"-F\" => true,\n-                            _ => false,\n-                        }\n-                })\n-            };\n-\n-            if !wrapper_mode && should_describe_lints() {\n-                describe_lints();\n-                exit(0);\n-            }\n+        // Setting RUSTC_WRAPPER causes Cargo to pass 'rustc' as the first argument.\n+        // We're invoking the compiler programmatically, so we ignore this/\n+        let wrapper_mode = orig_args.get(1).map(Path::new).and_then(Path::file_stem) == Some(\"rustc\".as_ref());\n+\n+        if wrapper_mode {\n+            // we still want to be able to invoke it normally though\n+            orig_args.remove(1);\n+        }\n+\n+        if !wrapper_mode && (orig_args.iter().any(|a| a == \"--help\" || a == \"-h\") || orig_args.len() == 1) {\n+            display_help();\n+            exit(0);\n+        }\n+\n+        let should_describe_lints = || {\n+            let args: Vec<_> = env::args().collect();\n+            args.windows(2).any(|args| {\n+                args[1] == \"help\"\n+                    && match args[0].as_str() {\n+                        \"-W\" | \"-A\" | \"-D\" | \"-F\" => true,\n+                        _ => false,\n+                    }\n+            })\n+        };\n \n-            // this conditional check for the --sysroot flag is there so users can call\n-            // `clippy_driver` directly\n-            // without having to pass --sysroot or anything\n-            let mut args: Vec<String> = orig_args.clone();\n-            if !have_sys_root_arg {\n-                args.extend(vec![\"--sysroot\".into(), sys_root]);\n-            };\n-\n-            // this check ensures that dependencies are built but not linted and the final\n-            // crate is linted but not built\n-            let clippy_enabled = env::var(\"CLIPPY_TESTS\").map_or(false, |val| val == \"true\")\n-                || arg_value(&orig_args, \"--cap-lints\", |val| val == \"allow\").is_none();\n-\n-            if clippy_enabled {\n-                args.extend(vec![\"--cfg\".into(), r#\"feature=\"cargo-clippy\"\"#.into()]);\n-                if let Ok(extra_args) = env::var(\"CLIPPY_ARGS\") {\n-                    args.extend(extra_args.split(\"__CLIPPY_HACKERY__\").filter_map(|s| {\n-                        if s.is_empty() {\n-                            None\n-                        } else {\n-                            Some(s.to_string())\n-                        }\n-                    }));\n-                }\n+        if !wrapper_mode && should_describe_lints() {\n+            describe_lints();\n+            exit(0);\n+        }\n+\n+        // this conditional check for the --sysroot flag is there so users can call\n+        // `clippy_driver` directly\n+        // without having to pass --sysroot or anything\n+        let mut args: Vec<String> = orig_args.clone();\n+        if !have_sys_root_arg {\n+            args.extend(vec![\"--sysroot\".into(), sys_root]);\n+        };\n+\n+        // this check ensures that dependencies are built but not linted and the final\n+        // crate is linted but not built\n+        let clippy_enabled = env::var(\"CLIPPY_TESTS\").map_or(false, |val| val == \"true\")\n+            || arg_value(&orig_args, \"--cap-lints\", |val| val == \"allow\").is_none();\n+\n+        if clippy_enabled {\n+            args.extend(vec![\"--cfg\".into(), r#\"feature=\"cargo-clippy\"\"#.into()]);\n+            if let Ok(extra_args) = env::var(\"CLIPPY_ARGS\") {\n+                args.extend(extra_args.split(\"__CLIPPY_HACKERY__\").filter_map(|s| {\n+                    if s.is_empty() {\n+                        None\n+                    } else {\n+                        Some(s.to_string())\n+                    }\n+                }));\n             }\n-            let mut clippy = ClippyCallbacks;\n-            let mut default = DefaultCallbacks;\n-            let callbacks: &mut (dyn rustc_driver::Callbacks + Send) =\n-                if clippy_enabled { &mut clippy } else { &mut default };\n-            rustc_driver::run_compiler(&args, callbacks, None, None)\n-        })\n-    )\n+        }\n+        let mut clippy = ClippyCallbacks;\n+        let mut default = DefaultCallbacks;\n+        let callbacks: &mut (dyn rustc_driver::Callbacks + Send) =\n+            if clippy_enabled { &mut clippy } else { &mut default };\n+        rustc_driver::run_compiler(&args, callbacks, None, None)\n+    }))\n }"}, {"sha": "9457a64f9c6b96e48048d6118c9f731f0a4056a8", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 44, "deletions": 86, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -67,25 +67,25 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         module: \"bit_mask\",\n     },\n     Lint {\n-        name: \"blacklisted_name\",\n-        group: \"style\",\n-        desc: \"usage of a blacklisted/placeholder name\",\n+        name: \"bind_instead_of_map\",\n+        group: \"complexity\",\n+        desc: \"using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\",\n         deprecation: None,\n-        module: \"blacklisted_name\",\n+        module: \"methods\",\n     },\n     Lint {\n-        name: \"block_in_if_condition_expr\",\n+        name: \"blacklisted_name\",\n         group: \"style\",\n-        desc: \"braces that can be eliminated in conditions, e.g., `if { true } ...`\",\n+        desc: \"usage of a blacklisted/placeholder name\",\n         deprecation: None,\n-        module: \"block_in_if_condition\",\n+        module: \"blacklisted_name\",\n     },\n     Lint {\n-        name: \"block_in_if_condition_stmt\",\n+        name: \"blocks_in_if_conditions\",\n         group: \"style\",\n-        desc: \"complex blocks in conditions, e.g., `if { let x = true; x } ...`\",\n+        desc: \"useless or complex blocks that can be eliminated in conditions\",\n         deprecation: None,\n-        module: \"block_in_if_condition\",\n+        module: \"blocks_in_if_conditions\",\n     },\n     Lint {\n         name: \"bool_comparison\",\n@@ -521,6 +521,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"expect_used\",\n+        group: \"restriction\",\n+        desc: \"using `.expect()` on `Result` or `Option`, which might be better handled\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n     Lint {\n         name: \"expl_impl_clone_on_copy\",\n         group: \"pedantic\",\n@@ -676,16 +683,9 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         module: \"loops\",\n     },\n     Lint {\n-        name: \"for_loop_over_option\",\n-        group: \"correctness\",\n-        desc: \"for-looping over an `Option`, which is more clearly expressed as an `if let`\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"for_loop_over_result\",\n+        name: \"for_loops_over_fallibles\",\n         group: \"correctness\",\n-        desc: \"for-looping over a `Result`, which is more clearly expressed as an `if let`\",\n+        desc: \"for-looping over an `Option` or a `Result`, which is more clearly expressed as an `if let`\",\n         deprecation: None,\n         module: \"loops\",\n     },\n@@ -724,13 +724,6 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n-    Lint {\n-        name: \"identity_conversion\",\n-        group: \"complexity\",\n-        desc: \"using always-identical `Into`/`From`/`IntoIter` conversions\",\n-        deprecation: None,\n-        module: \"identity_conversion\",\n-    },\n     Lint {\n         name: \"identity_op\",\n         group: \"complexity\",\n@@ -1144,6 +1137,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"map_unwrap_or\",\n+        group: \"pedantic\",\n+        desc: \"using `.map(f).unwrap_or(a)` or `.map(f).unwrap_or_else(func)`, which are more succinctly expressed as `map_or(a, f)` or `map_or_else(a, f)`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n     Lint {\n         name: \"match_as_ref\",\n         group: \"complexity\",\n@@ -1578,13 +1578,6 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"eq_op\",\n     },\n-    Lint {\n-        name: \"option_and_then_some\",\n-        group: \"complexity\",\n-        desc: \"using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n     Lint {\n         name: \"option_as_ref_deref\",\n         group: \"complexity\",\n@@ -1599,13 +1592,6 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"option_env_unwrap\",\n     },\n-    Lint {\n-        name: \"option_expect_used\",\n-        group: \"restriction\",\n-        desc: \"using `Option.expect()`, which might be better handled\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n     Lint {\n         name: \"option_map_or_none\",\n         group: \"style\",\n@@ -1620,34 +1606,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"map_unit_fn\",\n     },\n-    Lint {\n-        name: \"option_map_unwrap_or\",\n-        group: \"pedantic\",\n-        desc: \"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"option_map_unwrap_or_else\",\n-        group: \"pedantic\",\n-        desc: \"using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n     Lint {\n         name: \"option_option\",\n         group: \"pedantic\",\n         desc: \"usage of `Option<Option<T>>`\",\n         deprecation: None,\n         module: \"types\",\n     },\n-    Lint {\n-        name: \"option_unwrap_used\",\n-        group: \"restriction\",\n-        desc: \"using `Option.unwrap()`, which should at least get a better message using `expect()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n     Lint {\n         name: \"or_fun_call\",\n         group: \"perf\",\n@@ -1886,13 +1851,6 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"matches\",\n     },\n-    Lint {\n-        name: \"result_expect_used\",\n-        group: \"restriction\",\n-        desc: \"using `Result.expect()`, which might be better handled\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n     Lint {\n         name: \"result_map_or_into_option\",\n         group: \"style\",\n@@ -1908,25 +1866,11 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         module: \"map_unit_fn\",\n     },\n     Lint {\n-        name: \"result_map_unwrap_or_else\",\n-        group: \"pedantic\",\n-        desc: \"using `Result.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `.map_or_else(g, f)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"result_unwrap_used\",\n-        group: \"restriction\",\n-        desc: \"using `Result.unwrap()`, which might be better handled\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"reverse_range_loop\",\n+        name: \"reversed_empty_ranges\",\n         group: \"correctness\",\n-        desc: \"iteration over an empty range, such as `10..0` or `5..5`\",\n+        desc: \"reversing the limits of range expressions, resulting in empty ranges\",\n         deprecation: None,\n-        module: \"loops\",\n+        module: \"ranges\",\n     },\n     Lint {\n         name: \"same_functions_in_if_condition\",\n@@ -2425,6 +2369,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"returns\",\n     },\n+    Lint {\n+        name: \"unwrap_used\",\n+        group: \"restriction\",\n+        desc: \"using `.unwrap()` on `Result` or `Option`, which should at least get a better message using `expect()`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n     Lint {\n         name: \"use_debug\",\n         group: \"restriction\",\n@@ -2460,6 +2411,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"attrs\",\n     },\n+    Lint {\n+        name: \"useless_conversion\",\n+        group: \"complexity\",\n+        desc: \"calls to `Into`/`From`/`IntoIter` that performs useless conversions to the same type\",\n+        deprecation: None,\n+        module: \"useless_conversion\",\n+    },\n     Lint {\n         name: \"useless_format\",\n         group: \"complexity\",\n@@ -2469,7 +2427,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     },\n     Lint {\n         name: \"useless_let_if_seq\",\n-        group: \"style\",\n+        group: \"nursery\",\n         desc: \"unidiomatic `let mut` declaration followed by initialization in `if`\",\n         deprecation: None,\n         module: \"let_if_seq\","}, {"sha": "5815550d7a6a1e04d4f4ba489693ca849dacb1b9", "filename": "tests/ui/bind_instead_of_map.fixed", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fbind_instead_of_map.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fbind_instead_of_map.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbind_instead_of_map.fixed?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![deny(clippy::option_and_then_some)]\n+#![deny(clippy::bind_instead_of_map)]\n \n // need a main anyway, use it get rid of unused warnings too\n pub fn main() {\n@@ -12,7 +12,7 @@ pub fn main() {\n \n     // Different type\n     let x: Result<u32, &str> = Ok(1);\n-    let _ = x.and_then(Ok);\n+    let _ = x;\n }\n \n pub fn foo() -> Option<String> {", "previous_filename": "tests/ui/option_and_then_some.fixed"}, {"sha": "623b100a4ce7ea14ab2249f94b64b159e947e536", "filename": "tests/ui/bind_instead_of_map.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbind_instead_of_map.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![deny(clippy::option_and_then_some)]\n+#![deny(clippy::bind_instead_of_map)]\n \n // need a main anyway, use it get rid of unused warnings too\n pub fn main() {", "previous_filename": "tests/ui/option_and_then_some.rs"}, {"sha": "24c6b7f9ef32b08a2f660bcf7e20b6922b530ab8", "filename": "tests/ui/bind_instead_of_map.stderr", "status": "renamed", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fbind_instead_of_map.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fbind_instead_of_map.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbind_instead_of_map.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,20 +1,26 @@\n error: using `Option.and_then(Some)`, which is a no-op\n-  --> $DIR/option_and_then_some.rs:8:13\n+  --> $DIR/bind_instead_of_map.rs:8:13\n    |\n LL |     let _ = x.and_then(Some);\n    |             ^^^^^^^^^^^^^^^^ help: use the expression directly: `x`\n    |\n note: the lint level is defined here\n-  --> $DIR/option_and_then_some.rs:2:9\n+  --> $DIR/bind_instead_of_map.rs:2:9\n    |\n-LL | #![deny(clippy::option_and_then_some)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #![deny(clippy::bind_instead_of_map)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\n-  --> $DIR/option_and_then_some.rs:9:13\n+  --> $DIR/bind_instead_of_map.rs:9:13\n    |\n LL |     let _ = x.and_then(|o| Some(o + 1));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `x.map(|o| o + 1)`\n \n-error: aborting due to 2 previous errors\n+error: using `Result.and_then(Ok)`, which is a no-op\n+  --> $DIR/bind_instead_of_map.rs:15:13\n+   |\n+LL |     let _ = x.and_then(Ok);\n+   |             ^^^^^^^^^^^^^^ help: use the expression directly: `x`\n+\n+error: aborting due to 3 previous errors\n ", "previous_filename": "tests/ui/option_and_then_some.stderr"}, {"sha": "91d9d11e3c11056ced998350542ce7e9cf745a74", "filename": "tests/ui/bind_instead_of_map_multipart.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fbind_instead_of_map_multipart.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fbind_instead_of_map_multipart.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbind_instead_of_map_multipart.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -0,0 +1,61 @@\n+#![deny(clippy::bind_instead_of_map)]\n+#![allow(clippy::blocks_in_if_conditions)]\n+\n+pub fn main() {\n+    let _ = Some(\"42\").and_then(|s| if s.len() < 42 { Some(0) } else { Some(s.len()) });\n+    let _ = Some(\"42\").and_then(|s| if s.len() < 42 { None } else { Some(s.len()) });\n+\n+    let _ = Ok::<_, ()>(\"42\").and_then(|s| if s.len() < 42 { Ok(0) } else { Ok(s.len()) });\n+    let _ = Ok::<_, ()>(\"42\").and_then(|s| if s.len() < 42 { Err(()) } else { Ok(s.len()) });\n+\n+    let _ = Err::<(), _>(\"42\").or_else(|s| if s.len() < 42 { Err(s.len() + 20) } else { Err(s.len()) });\n+    let _ = Err::<(), _>(\"42\").or_else(|s| if s.len() < 42 { Ok(()) } else { Err(s.len()) });\n+\n+    hard_example();\n+    macro_example();\n+}\n+\n+fn hard_example() {\n+    Some(\"42\").and_then(|s| {\n+        if {\n+            if s == \"43\" {\n+                return Some(43);\n+            }\n+            s == \"42\"\n+        } {\n+            return Some(45);\n+        }\n+        match s.len() {\n+            10 => Some(2),\n+            20 => {\n+                if foo() {\n+                    return {\n+                        if foo() {\n+                            return Some(20);\n+                        }\n+                        println!(\"foo\");\n+                        Some(3)\n+                    };\n+                }\n+                Some(20)\n+            },\n+            40 => Some(30),\n+            _ => Some(1),\n+        }\n+    });\n+}\n+\n+fn foo() -> bool {\n+    true\n+}\n+\n+macro_rules! m {\n+    () => {\n+        Some(10)\n+    };\n+}\n+\n+fn macro_example() {\n+    let _ = Some(\"\").and_then(|s| if s.len() == 20 { m!() } else { Some(20) });\n+    let _ = Some(\"\").and_then(|s| if s.len() == 20 { Some(m!()) } else { Some(Some(20)) });\n+}"}, {"sha": "50ce2f4051e008df976e2ed16b743f2d4d174d40", "filename": "tests/ui/bind_instead_of_map_multipart.stderr", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fbind_instead_of_map_multipart.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fbind_instead_of_map_multipart.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbind_instead_of_map_multipart.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -0,0 +1,73 @@\n+error: using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\n+  --> $DIR/bind_instead_of_map_multipart.rs:5:13\n+   |\n+LL |     let _ = Some(\"42\").and_then(|s| if s.len() < 42 { Some(0) } else { Some(s.len()) });\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/bind_instead_of_map_multipart.rs:1:9\n+   |\n+LL | #![deny(clippy::bind_instead_of_map)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try this\n+   |\n+LL |     let _ = Some(\"42\").map(|s| if s.len() < 42 { 0 } else { s.len() });\n+   |                        ^^^                       ^          ^^^^^^^\n+\n+error: using `Result.and_then(|x| Ok(y))`, which is more succinctly expressed as `map(|x| y)`\n+  --> $DIR/bind_instead_of_map_multipart.rs:8:13\n+   |\n+LL |     let _ = Ok::<_, ()>(\"42\").and_then(|s| if s.len() < 42 { Ok(0) } else { Ok(s.len()) });\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     let _ = Ok::<_, ()>(\"42\").map(|s| if s.len() < 42 { 0 } else { s.len() });\n+   |                               ^^^                       ^          ^^^^^^^\n+\n+error: using `Result.or_else(|x| Err(y))`, which is more succinctly expressed as `map_err(|x| y)`\n+  --> $DIR/bind_instead_of_map_multipart.rs:11:13\n+   |\n+LL |     let _ = Err::<(), _>(\"42\").or_else(|s| if s.len() < 42 { Err(s.len() + 20) } else { Err(s.len()) });\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     let _ = Err::<(), _>(\"42\").map_err(|s| if s.len() < 42 { s.len() + 20 } else { s.len() });\n+   |                                ^^^^^^^                       ^^^^^^^^^^^^          ^^^^^^^\n+\n+error: using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\n+  --> $DIR/bind_instead_of_map_multipart.rs:19:5\n+   |\n+LL | /     Some(\"42\").and_then(|s| {\n+LL | |         if {\n+LL | |             if s == \"43\" {\n+LL | |                 return Some(43);\n+...  |\n+LL | |         }\n+LL | |     });\n+   | |______^\n+   |\n+help: try this\n+   |\n+LL |     Some(\"42\").map(|s| {\n+LL |         if {\n+LL |             if s == \"43\" {\n+LL |                 return 43;\n+LL |             }\n+LL |             s == \"42\"\n+ ...\n+\n+error: using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\n+  --> $DIR/bind_instead_of_map_multipart.rs:60:13\n+   |\n+LL |     let _ = Some(\"\").and_then(|s| if s.len() == 20 { Some(m!()) } else { Some(Some(20)) });\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     let _ = Some(\"\").map(|s| if s.len() == 20 { m!() } else { Some(20) });\n+   |                      ^^^                        ^^^^          ^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "14562c4d32c12996c3b56073ed602e0ed7dd0ba3", "filename": "tests/ui/blocks_in_if_conditions.fixed", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fblocks_in_if_conditions.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fblocks_in_if_conditions.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblocks_in_if_conditions.fixed?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,6 +1,5 @@\n // run-rustfix\n-#![warn(clippy::block_in_if_condition_expr)]\n-#![warn(clippy::block_in_if_condition_stmt)]\n+#![warn(clippy::blocks_in_if_conditions)]\n #![allow(unused, clippy::let_and_return)]\n #![warn(clippy::nonminimal_bool)]\n \n@@ -64,10 +63,10 @@ fn block_in_assert() {\n     let opt = Some(42);\n     assert!(opt\n         .as_ref()\n-        .and_then(|val| {\n+        .map(|val| {\n             let mut v = val * 2;\n             v -= 1;\n-            Some(v * 3)\n+            v * 3\n         })\n         .is_some());\n }", "previous_filename": "tests/ui/block_in_if_condition.fixed"}, {"sha": "bda87650f6da2c4c2537169099da12c13a220e3e", "filename": "tests/ui/blocks_in_if_conditions.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblocks_in_if_conditions.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,6 +1,5 @@\n // run-rustfix\n-#![warn(clippy::block_in_if_condition_expr)]\n-#![warn(clippy::block_in_if_condition_stmt)]\n+#![warn(clippy::blocks_in_if_conditions)]\n #![allow(unused, clippy::let_and_return)]\n #![warn(clippy::nonminimal_bool)]\n \n@@ -64,10 +63,10 @@ fn block_in_assert() {\n     let opt = Some(42);\n     assert!(opt\n         .as_ref()\n-        .and_then(|val| {\n+        .map(|val| {\n             let mut v = val * 2;\n             v -= 1;\n-            Some(v * 3)\n+            v * 3\n         })\n         .is_some());\n }", "previous_filename": "tests/ui/block_in_if_condition.rs"}, {"sha": "9bdddc8e15248bb3a6a53c37875c37bb7d9a4321", "filename": "tests/ui/blocks_in_if_conditions.stderr", "status": "renamed", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fblocks_in_if_conditions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fblocks_in_if_conditions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblocks_in_if_conditions.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,13 +1,13 @@\n error: in an `if` condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a `let`\n-  --> $DIR/block_in_if_condition.rs:27:5\n+  --> $DIR/blocks_in_if_conditions.rs:26:5\n    |\n LL | /     if {\n LL | |         let x = 3;\n LL | |         x == 3\n LL | |     } {\n    | |_____^\n    |\n-   = note: `-D clippy::block-in-if-condition-stmt` implied by `-D warnings`\n+   = note: `-D clippy::blocks-in-if-conditions` implied by `-D warnings`\n help: try\n    |\n LL |     let res = {\n@@ -17,15 +17,13 @@ LL |     }; if res {\n    |\n \n error: omit braces around single expression condition\n-  --> $DIR/block_in_if_condition.rs:38:8\n+  --> $DIR/blocks_in_if_conditions.rs:37:8\n    |\n LL |     if { true } {\n    |        ^^^^^^^^ help: try: `true`\n-   |\n-   = note: `-D clippy::block-in-if-condition-expr` implied by `-D warnings`\n \n error: this boolean expression can be simplified\n-  --> $DIR/block_in_if_condition.rs:47:8\n+  --> $DIR/blocks_in_if_conditions.rs:46:8\n    |\n LL |     if true && x == 3 {\n    |        ^^^^^^^^^^^^^^ help: try: `x == 3`", "previous_filename": "tests/ui/block_in_if_condition.stderr"}, {"sha": "acbabfa20d737495708db8f9cc1380a24e9349c5", "filename": "tests/ui/blocks_in_if_conditions_closure.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fblocks_in_if_conditions_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fblocks_in_if_conditions_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblocks_in_if_conditions_closure.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,5 +1,4 @@\n-#![warn(clippy::block_in_if_condition_expr)]\n-#![warn(clippy::block_in_if_condition_stmt)]\n+#![warn(clippy::blocks_in_if_conditions)]\n #![allow(unused, clippy::let_and_return)]\n \n fn predicate<F: FnOnce(T) -> bool, T>(pfn: F, val: T) -> bool {\n@@ -10,7 +9,7 @@ fn pred_test() {\n     let v = 3;\n     let sky = \"blue\";\n     // This is a sneaky case, where the block isn't directly in the condition,\n-    // but is actually nside a closure that the condition is using.\n+    // but is actually inside a closure that the condition is using.\n     // The same principle applies -- add some extra expressions to make sure\n     // linter isn't confused by them.\n     if v == 3", "previous_filename": "tests/ui/block_in_if_condition_closure.rs"}, {"sha": "941d604dd5f9118fcf8ea93d2a2ad0e7f1bce0a5", "filename": "tests/ui/blocks_in_if_conditions_closure.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fblocks_in_if_conditions_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fblocks_in_if_conditions_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblocks_in_if_conditions_closure.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,5 +1,5 @@\n error: in an `if` condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a `let`\n-  --> $DIR/block_in_if_condition_closure.rs:19:17\n+  --> $DIR/blocks_in_if_conditions_closure.rs:18:17\n    |\n LL |               |x| {\n    |  _________________^\n@@ -8,10 +8,10 @@ LL | |                 x == target\n LL | |             },\n    | |_____________^\n    |\n-   = note: `-D clippy::block-in-if-condition-stmt` implied by `-D warnings`\n+   = note: `-D clippy::blocks-in-if-conditions` implied by `-D warnings`\n \n error: in an `if` condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a `let`\n-  --> $DIR/block_in_if_condition_closure.rs:28:13\n+  --> $DIR/blocks_in_if_conditions_closure.rs:27:13\n    |\n LL |           |x| {\n    |  _____________^", "previous_filename": "tests/ui/block_in_if_condition_closure.stderr"}, {"sha": "3b03f8c7dfe7c71f6642646d2543a719ce3cbb4f", "filename": "tests/ui/comparison_chain.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcomparison_chain.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -137,4 +137,70 @@ fn h<T: Ord>(x: T, y: T, z: T) {\n     }\n }\n \n+// The following uses should be ignored\n+mod issue_5212 {\n+    use super::{a, b, c};\n+    fn foo() -> u8 {\n+        21\n+    }\n+\n+    fn same_operation_equals() {\n+        // operands are fixed\n+\n+        if foo() == 42 {\n+            a()\n+        } else if foo() == 42 {\n+            b()\n+        }\n+\n+        if foo() == 42 {\n+            a()\n+        } else if foo() == 42 {\n+            b()\n+        } else {\n+            c()\n+        }\n+\n+        // operands are transposed\n+\n+        if foo() == 42 {\n+            a()\n+        } else if 42 == foo() {\n+            b()\n+        }\n+    }\n+\n+    fn same_operation_not_equals() {\n+        // operands are fixed\n+\n+        if foo() > 42 {\n+            a()\n+        } else if foo() > 42 {\n+            b()\n+        }\n+\n+        if foo() > 42 {\n+            a()\n+        } else if foo() > 42 {\n+            b()\n+        } else {\n+            c()\n+        }\n+\n+        if foo() < 42 {\n+            a()\n+        } else if foo() < 42 {\n+            b()\n+        }\n+\n+        if foo() < 42 {\n+            a()\n+        } else if foo() < 42 {\n+            b()\n+        } else {\n+            c()\n+        }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "e1842c73f0e316807f80249bb5869bff51422bf9", "filename": "tests/ui/crashes/ice-5579.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fcrashes%2Fice-5579.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fcrashes%2Fice-5579.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-5579.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -0,0 +1,17 @@\n+trait IsErr {\n+    fn is_err(&self, err: &str) -> bool;\n+}\n+\n+impl<T> IsErr for Option<T> {\n+    fn is_err(&self, _err: &str) -> bool {\n+        true\n+    }\n+}\n+\n+fn main() {\n+    let t = Some(1);\n+\n+    if t.is_err(\"\") {\n+        t.unwrap();\n+    }\n+}"}, {"sha": "1073acf6f0cd66b51c33588bfa7296e1a9364a57", "filename": "tests/ui/expect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fexpect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fexpect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,4 +1,4 @@\n-#![warn(clippy::option_expect_used, clippy::result_expect_used)]\n+#![warn(clippy::expect_used)]\n \n fn expect_option() {\n     let opt = Some(0);"}, {"sha": "9d3fc7df15cc7a9de6f73efca2de52e3f4a93a3c", "filename": "tests/ui/expect.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fexpect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fexpect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -4,7 +4,7 @@ error: used `expect()` on `an Option` value\n LL |     let _ = opt.expect(\"\");\n    |             ^^^^^^^^^^^^^^\n    |\n-   = note: `-D clippy::option-expect-used` implied by `-D warnings`\n+   = note: `-D clippy::expect-used` implied by `-D warnings`\n    = help: if this value is an `None`, it will panic\n \n error: used `expect()` on `a Result` value\n@@ -13,7 +13,6 @@ error: used `expect()` on `a Result` value\n LL |     let _ = res.expect(\"\");\n    |             ^^^^^^^^^^^^^^\n    |\n-   = note: `-D clippy::result-expect-used` implied by `-D warnings`\n    = help: if this value is an `Err`, it will panic\n \n error: aborting due to 2 previous errors"}, {"sha": "249a88a0b3982cdccb57fa64418d5831d54c9c33", "filename": "tests/ui/for_loop_fixable.fixed", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Ffor_loop_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Ffor_loop_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_fixable.fixed?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -21,7 +21,6 @@ impl Unrelated {\n     clippy::explicit_iter_loop,\n     clippy::explicit_into_iter_loop,\n     clippy::iter_next_loop,\n-    clippy::reverse_range_loop,\n     clippy::for_kv_map\n )]\n #[allow(\n@@ -32,61 +31,8 @@ impl Unrelated {\n )]\n #[allow(clippy::many_single_char_names, unused_variables)]\n fn main() {\n-    const MAX_LEN: usize = 42;\n     let mut vec = vec![1, 2, 3, 4];\n \n-    for i in (0..10).rev() {\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in (0..=10).rev() {\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in (0..MAX_LEN).rev() {\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in 5..=5 {\n-        // not an error, this is the range with only one element \u201c5\u201d\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in 0..10 {\n-        // not an error, the start index is less than the end index\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in -10..0 {\n-        // not an error\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in (10..0).map(|x| x * 2) {\n-        // not an error, it can't be known what arbitrary methods do to a range\n-        println!(\"{}\", i);\n-    }\n-\n-    // testing that the empty range lint folds constants\n-    for i in (5 + 4..10).rev() {\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in ((3 - 1)..(5 + 2)).rev() {\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in (2 * 2)..(2 * 3) {\n-        // no error, 4..6 is fine\n-        println!(\"{}\", i);\n-    }\n-\n-    let x = 42;\n-    for i in x..10 {\n-        // no error, not constant-foldable\n-        println!(\"{}\", i);\n-    }\n-\n     // See #601\n     for i in 0..10 {\n         // no error, id_col does not exist outside the loop"}, {"sha": "306d85a6351e107f6a7e6bbb0b8c70d9843a4a93", "filename": "tests/ui/for_loop_fixable.rs", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Ffor_loop_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Ffor_loop_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_fixable.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -21,7 +21,6 @@ impl Unrelated {\n     clippy::explicit_iter_loop,\n     clippy::explicit_into_iter_loop,\n     clippy::iter_next_loop,\n-    clippy::reverse_range_loop,\n     clippy::for_kv_map\n )]\n #[allow(\n@@ -32,61 +31,8 @@ impl Unrelated {\n )]\n #[allow(clippy::many_single_char_names, unused_variables)]\n fn main() {\n-    const MAX_LEN: usize = 42;\n     let mut vec = vec![1, 2, 3, 4];\n \n-    for i in 10..0 {\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in 10..=0 {\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in MAX_LEN..0 {\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in 5..=5 {\n-        // not an error, this is the range with only one element \u201c5\u201d\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in 0..10 {\n-        // not an error, the start index is less than the end index\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in -10..0 {\n-        // not an error\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in (10..0).map(|x| x * 2) {\n-        // not an error, it can't be known what arbitrary methods do to a range\n-        println!(\"{}\", i);\n-    }\n-\n-    // testing that the empty range lint folds constants\n-    for i in 10..5 + 4 {\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in (5 + 2)..(3 - 1) {\n-        println!(\"{}\", i);\n-    }\n-\n-    for i in (2 * 2)..(2 * 3) {\n-        // no error, 4..6 is fine\n-        println!(\"{}\", i);\n-    }\n-\n-    let x = 42;\n-    for i in x..10 {\n-        // no error, not constant-foldable\n-        println!(\"{}\", i);\n-    }\n-\n     // See #601\n     for i in 0..10 {\n         // no error, id_col does not exist outside the loop"}, {"sha": "ddfe66d675f91efbc8f070116c570ef9eda5a496", "filename": "tests/ui/for_loop_fixable.stderr", "status": "modified", "additions": 16, "deletions": 72, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Ffor_loop_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Ffor_loop_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_fixable.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,152 +1,96 @@\n-error: this range is empty so this for loop will never run\n-  --> $DIR/for_loop_fixable.rs:38:14\n-   |\n-LL |     for i in 10..0 {\n-   |              ^^^^^\n-   |\n-   = note: `-D clippy::reverse-range-loop` implied by `-D warnings`\n-help: consider using the following if you are attempting to iterate over this range in reverse\n-   |\n-LL |     for i in (0..10).rev() {\n-   |              ^^^^^^^^^^^^^\n-\n-error: this range is empty so this for loop will never run\n-  --> $DIR/for_loop_fixable.rs:42:14\n-   |\n-LL |     for i in 10..=0 {\n-   |              ^^^^^^\n-   |\n-help: consider using the following if you are attempting to iterate over this range in reverse\n-   |\n-LL |     for i in (0..=10).rev() {\n-   |              ^^^^^^^^^^^^^^\n-\n-error: this range is empty so this for loop will never run\n-  --> $DIR/for_loop_fixable.rs:46:14\n-   |\n-LL |     for i in MAX_LEN..0 {\n-   |              ^^^^^^^^^^\n-   |\n-help: consider using the following if you are attempting to iterate over this range in reverse\n-   |\n-LL |     for i in (0..MAX_LEN).rev() {\n-   |              ^^^^^^^^^^^^^^^^^^\n-\n-error: this range is empty so this for loop will never run\n-  --> $DIR/for_loop_fixable.rs:71:14\n-   |\n-LL |     for i in 10..5 + 4 {\n-   |              ^^^^^^^^^\n-   |\n-help: consider using the following if you are attempting to iterate over this range in reverse\n-   |\n-LL |     for i in (5 + 4..10).rev() {\n-   |              ^^^^^^^^^^^^^^^^^\n-\n-error: this range is empty so this for loop will never run\n-  --> $DIR/for_loop_fixable.rs:75:14\n-   |\n-LL |     for i in (5 + 2)..(3 - 1) {\n-   |              ^^^^^^^^^^^^^^^^\n-   |\n-help: consider using the following if you are attempting to iterate over this range in reverse\n-   |\n-LL |     for i in ((3 - 1)..(5 + 2)).rev() {\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:97:15\n+  --> $DIR/for_loop_fixable.rs:43:15\n    |\n LL |     for _v in vec.iter() {}\n    |               ^^^^^^^^^^ help: to write this more concisely, try: `&vec`\n    |\n    = note: `-D clippy::explicit-iter-loop` implied by `-D warnings`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:99:15\n+  --> $DIR/for_loop_fixable.rs:45:15\n    |\n LL |     for _v in vec.iter_mut() {}\n    |               ^^^^^^^^^^^^^^ help: to write this more concisely, try: `&mut vec`\n \n error: it is more concise to loop over containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:102:15\n+  --> $DIR/for_loop_fixable.rs:48:15\n    |\n LL |     for _v in out_vec.into_iter() {}\n    |               ^^^^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `out_vec`\n    |\n    = note: `-D clippy::explicit-into-iter-loop` implied by `-D warnings`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:107:15\n+  --> $DIR/for_loop_fixable.rs:53:15\n    |\n LL |     for _v in [1, 2, 3].iter() {}\n    |               ^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `&[1, 2, 3]`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:111:15\n+  --> $DIR/for_loop_fixable.rs:57:15\n    |\n LL |     for _v in [0; 32].iter() {}\n    |               ^^^^^^^^^^^^^^ help: to write this more concisely, try: `&[0; 32]`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:116:15\n+  --> $DIR/for_loop_fixable.rs:62:15\n    |\n LL |     for _v in ll.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&ll`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:119:15\n+  --> $DIR/for_loop_fixable.rs:65:15\n    |\n LL |     for _v in vd.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&vd`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:122:15\n+  --> $DIR/for_loop_fixable.rs:68:15\n    |\n LL |     for _v in bh.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&bh`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:125:15\n+  --> $DIR/for_loop_fixable.rs:71:15\n    |\n LL |     for _v in hm.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&hm`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:128:15\n+  --> $DIR/for_loop_fixable.rs:74:15\n    |\n LL |     for _v in bt.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&bt`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:131:15\n+  --> $DIR/for_loop_fixable.rs:77:15\n    |\n LL |     for _v in hs.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&hs`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:134:15\n+  --> $DIR/for_loop_fixable.rs:80:15\n    |\n LL |     for _v in bs.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&bs`\n \n error: it is more concise to loop over containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:309:18\n+  --> $DIR/for_loop_fixable.rs:255:18\n    |\n LL |         for i in iterator.into_iter() {\n    |                  ^^^^^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `iterator`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:329:18\n+  --> $DIR/for_loop_fixable.rs:275:18\n    |\n LL |         for _ in t.into_iter() {}\n    |                  ^^^^^^^^^^^^^ help: to write this more concisely, try: `&t`\n \n error: it is more concise to loop over containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:331:18\n+  --> $DIR/for_loop_fixable.rs:277:18\n    |\n LL |         for _ in r.into_iter() {}\n    |                  ^^^^^^^^^^^^^ help: to write this more concisely, try: `r`\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 15 previous errors\n "}, {"sha": "e73536052f0f5bf597dd9154b4209984d87c54a7", "filename": "tests/ui/for_loop_unfixable.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Ffor_loop_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Ffor_loop_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_unfixable.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -5,7 +5,6 @@\n     clippy::explicit_iter_loop,\n     clippy::explicit_into_iter_loop,\n     clippy::iter_next_loop,\n-    clippy::reverse_range_loop,\n     clippy::for_kv_map\n )]\n #[allow(\n@@ -16,25 +15,8 @@\n     unused,\n     dead_code\n )]\n-#[allow(clippy::many_single_char_names, unused_variables)]\n fn main() {\n-    for i in 5..5 {\n-        println!(\"{}\", i);\n-    }\n-\n     let vec = vec![1, 2, 3, 4];\n \n     for _v in vec.iter().next() {}\n-\n-    for i in (5 + 2)..(8 - 1) {\n-        println!(\"{}\", i);\n-    }\n-\n-    const ZERO: usize = 0;\n-\n-    for i in ZERO..vec.len() {\n-        if f(&vec[i], &vec[i]) {\n-            panic!(\"at the disco\");\n-        }\n-    }\n }"}, {"sha": "1c9287b6acbb328d5b2335a797acb4a1c903a478", "filename": "tests/ui/for_loop_unfixable.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Ffor_loop_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Ffor_loop_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_unfixable.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,9 +1,10 @@\n-error[E0425]: cannot find function `f` in this scope\n-  --> $DIR/for_loop_unfixable.rs:36:12\n+error: you are iterating over `Iterator::next()` which is an Option; this will compile but is probably not what you want\n+  --> $DIR/for_loop_unfixable.rs:21:15\n    |\n-LL |         if f(&vec[i], &vec[i]) {\n-   |            ^ help: a local variable with a similar name exists: `i`\n+LL |     for _v in vec.iter().next() {}\n+   |               ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::iter-next-loop` implied by `-D warnings`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0425`."}, {"sha": "1b9dde87cd5a2ab05460badc2374fc5d947449cf", "filename": "tests/ui/for_loops_over_fallibles.rs", "status": "renamed", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Ffor_loops_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Ffor_loops_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loops_over_fallibles.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,18 +1,16 @@\n-#![warn(clippy::for_loop_over_option, clippy::for_loop_over_result)]\n+#![warn(clippy::for_loops_over_fallibles)]\n \n-/// Tests for_loop_over_result and for_loop_over_option\n-\n-fn for_loop_over_option_and_result() {\n+fn for_loops_over_fallibles() {\n     let option = Some(1);\n     let result = option.ok_or(\"x not found\");\n     let v = vec![0, 1, 2];\n \n-    // check FOR_LOOP_OVER_OPTION lint\n+    // check over an `Option`\n     for x in option {\n         println!(\"{}\", x);\n     }\n \n-    // check FOR_LOOP_OVER_RESULT lint\n+    // check over a `Result`\n     for x in result {\n         println!(\"{}\", x);\n     }", "previous_filename": "tests/ui/for_loop_over_option_result.rs"}, {"sha": "bef228d4b93afbcaaff12e6cab7537ca068af694", "filename": "tests/ui/for_loops_over_fallibles.stderr", "status": "renamed", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Ffor_loops_over_fallibles.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Ffor_loops_over_fallibles.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loops_over_fallibles.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,55 +1,54 @@\n error: for loop over `option`, which is an `Option`. This is more readably written as an `if let` statement.\n-  --> $DIR/for_loop_over_option_result.rs:11:14\n+  --> $DIR/for_loops_over_fallibles.rs:9:14\n    |\n LL |     for x in option {\n    |              ^^^^^^\n    |\n-   = note: `-D clippy::for-loop-over-option` implied by `-D warnings`\n+   = note: `-D clippy::for-loops-over-fallibles` implied by `-D warnings`\n    = help: consider replacing `for x in option` with `if let Some(x) = option`\n \n error: for loop over `result`, which is a `Result`. This is more readably written as an `if let` statement.\n-  --> $DIR/for_loop_over_option_result.rs:16:14\n+  --> $DIR/for_loops_over_fallibles.rs:14:14\n    |\n LL |     for x in result {\n    |              ^^^^^^\n    |\n-   = note: `-D clippy::for-loop-over-result` implied by `-D warnings`\n    = help: consider replacing `for x in result` with `if let Ok(x) = result`\n \n error: for loop over `option.ok_or(\"x not found\")`, which is a `Result`. This is more readably written as an `if let` statement.\n-  --> $DIR/for_loop_over_option_result.rs:20:14\n+  --> $DIR/for_loops_over_fallibles.rs:18:14\n    |\n LL |     for x in option.ok_or(\"x not found\") {\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider replacing `for x in option.ok_or(\"x not found\")` with `if let Ok(x) = option.ok_or(\"x not found\")`\n \n error: you are iterating over `Iterator::next()` which is an Option; this will compile but is probably not what you want\n-  --> $DIR/for_loop_over_option_result.rs:26:14\n+  --> $DIR/for_loops_over_fallibles.rs:24:14\n    |\n LL |     for x in v.iter().next() {\n    |              ^^^^^^^^^^^^^^^\n    |\n    = note: `#[deny(clippy::iter_next_loop)]` on by default\n \n error: for loop over `v.iter().next().and(Some(0))`, which is an `Option`. This is more readably written as an `if let` statement.\n-  --> $DIR/for_loop_over_option_result.rs:31:14\n+  --> $DIR/for_loops_over_fallibles.rs:29:14\n    |\n LL |     for x in v.iter().next().and(Some(0)) {\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider replacing `for x in v.iter().next().and(Some(0))` with `if let Some(x) = v.iter().next().and(Some(0))`\n \n error: for loop over `v.iter().next().ok_or(\"x not found\")`, which is a `Result`. This is more readably written as an `if let` statement.\n-  --> $DIR/for_loop_over_option_result.rs:35:14\n+  --> $DIR/for_loops_over_fallibles.rs:33:14\n    |\n LL |     for x in v.iter().next().ok_or(\"x not found\") {\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider replacing `for x in v.iter().next().ok_or(\"x not found\")` with `if let Ok(x) = v.iter().next().ok_or(\"x not found\")`\n \n error: this loop never actually loops\n-  --> $DIR/for_loop_over_option_result.rs:47:5\n+  --> $DIR/for_loops_over_fallibles.rs:45:5\n    |\n LL | /     while let Some(x) = option {\n LL | |         println!(\"{}\", x);\n@@ -60,7 +59,7 @@ LL | |     }\n    = note: `#[deny(clippy::never_loop)]` on by default\n \n error: this loop never actually loops\n-  --> $DIR/for_loop_over_option_result.rs:53:5\n+  --> $DIR/for_loops_over_fallibles.rs:51:5\n    |\n LL | /     while let Ok(x) = result {\n LL | |         println!(\"{}\", x);", "previous_filename": "tests/ui/for_loop_over_option_result.stderr"}, {"sha": "ceaacaaf6bd706618ecac1133af2b63d9d261595", "filename": "tests/ui/identity_op.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fidentity_op.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -33,4 +33,9 @@ fn main() {\n \n     let u: u8 = 0;\n     u & 255;\n+\n+    1 << 0; // no error, this case is allowed, see issue 3430\n+    42 << 0;\n+    1 >> 0;\n+    42 >> 0;\n }"}, {"sha": "d8d44a74f9ab0fb05c1b19f7566eb2be6ad3e7be", "filename": "tests/ui/identity_op.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fidentity_op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fidentity_op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fidentity_op.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -48,5 +48,23 @@ error: the operation is ineffective. Consider reducing it to `u`\n LL |     u & 255;\n    |     ^^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: the operation is ineffective. Consider reducing it to `42`\n+  --> $DIR/identity_op.rs:38:5\n+   |\n+LL |     42 << 0;\n+   |     ^^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `1`\n+  --> $DIR/identity_op.rs:39:5\n+   |\n+LL |     1 >> 0;\n+   |     ^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `42`\n+  --> $DIR/identity_op.rs:40:5\n+   |\n+LL |     42 >> 0;\n+   |     ^^^^^^^\n+\n+error: aborting due to 11 previous errors\n "}, {"sha": "859765d08a70bbb83d313b53f608cd23d07aff4b", "filename": "tests/ui/implicit_saturating_sub.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fimplicit_saturating_sub.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fimplicit_saturating_sub.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_saturating_sub.fixed?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -29,8 +29,8 @@ fn main() {\n     // Lint\n     u_16 = u_16.saturating_sub(1);\n \n-    let mut end_32: u32 = 7000;\n-    let mut start_32: u32 = 7010;\n+    let mut end_32: u32 = 7010;\n+    let mut start_32: u32 = 7000;\n \n     let mut u_32: u32 = end_32 - start_32;\n "}, {"sha": "24cb216e79bf3715d00ffcd57f4e2aef9d421bf2", "filename": "tests/ui/implicit_saturating_sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_saturating_sub.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -35,8 +35,8 @@ fn main() {\n         u_16 -= 1;\n     }\n \n-    let mut end_32: u32 = 7000;\n-    let mut start_32: u32 = 7010;\n+    let mut end_32: u32 = 7010;\n+    let mut start_32: u32 = 7000;\n \n     let mut u_32: u32 = end_32 - start_32;\n "}, {"sha": "0083f94798fe4b2c650998d439f05cda4e7b0d0c", "filename": "tests/ui/manual_memcpy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -104,7 +104,7 @@ pub fn manual_copy(src: &[i32], dst: &mut [i32], dst2: &mut [i32]) {\n         dst[i - 0] = src[i];\n     }\n \n-    #[allow(clippy::reverse_range_loop)]\n+    #[allow(clippy::reversed_empty_ranges)]\n     for i in 0..0 {\n         dst[i] = src[i];\n     }"}, {"sha": "585944032e70d73bf6d144d580169b39ebbd1ea1", "filename": "tests/ui/map_unwrap_or.rs", "status": "renamed", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fmap_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fmap_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_unwrap_or.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,21 +1,18 @@\n // FIXME: Add \"run-rustfix\" once it's supported for multipart suggestions\n // aux-build:option_helpers.rs\n \n-#![warn(clippy::option_map_unwrap_or, clippy::option_map_unwrap_or_else)]\n+#![warn(clippy::map_unwrap_or)]\n \n #[macro_use]\n extern crate option_helpers;\n \n use std::collections::HashMap;\n \n-/// Checks implementation of the following lints:\n-/// * `OPTION_MAP_UNWRAP_OR`\n-/// * `OPTION_MAP_UNWRAP_OR_ELSE`\n #[rustfmt::skip]\n fn option_methods() {\n     let opt = Some(1);\n \n-    // Check `OPTION_MAP_UNWRAP_OR`.\n+    // Check for `option.map(_).unwrap_or(_)` use.\n     // Single line case.\n     let _ = opt.map(|x| x + 1)\n         // Should lint even though this call is on a separate line.\n@@ -49,7 +46,7 @@ fn option_methods() {\n     let id: String = \"identifier\".to_string();\n     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n \n-    // Check OPTION_MAP_UNWRAP_OR_ELSE\n+    // Check for `option.map(_).unwrap_or_else(_)` use.\n     // single line case\n     let _ = opt.map(|x| x + 1)\n         // Should lint even though this call is on a separate line.\n@@ -83,6 +80,20 @@ fn option_methods() {\n     }\n }\n \n+fn result_methods() {\n+    let res: Result<i32, ()> = Ok(1);\n+\n+    // Check for `result.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n+                                                      // multi line cases\n+    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n+    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n+    // macro case\n+    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|e| 0); // should not lint\n+}\n+\n fn main() {\n     option_methods();\n+    result_methods();\n }", "previous_filename": "tests/ui/option_map_unwrap_or.rs"}, {"sha": "b62080a073f352dc0760d2b63318ecc27cf86b9a", "filename": "tests/ui/map_unwrap_or.stderr", "status": "renamed", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fmap_unwrap_or.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fmap_unwrap_or.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_unwrap_or.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,20 +1,20 @@\n error: called `map(f).unwrap_or(a)` on an `Option` value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/option_map_unwrap_or.rs:20:13\n+  --> $DIR/map_unwrap_or.rs:17:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n LL | |         // Should lint even though this call is on a separate line.\n LL | |         .unwrap_or(0);\n    | |_____________________^\n    |\n-   = note: `-D clippy::option-map-unwrap-or` implied by `-D warnings`\n+   = note: `-D clippy::map-unwrap-or` implied by `-D warnings`\n help: use `map_or(a, f)` instead\n    |\n LL |     let _ = opt.map_or(0, |x| x + 1);\n    |                 ^^^^^^ ^^          --\n \n error: called `map(f).unwrap_or(a)` on an `Option` value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/option_map_unwrap_or.rs:24:13\n+  --> $DIR/map_unwrap_or.rs:21:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -32,7 +32,7 @@ LL |     );\n    |\n \n error: called `map(f).unwrap_or(a)` on an `Option` value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/option_map_unwrap_or.rs:28:13\n+  --> $DIR/map_unwrap_or.rs:25:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -49,7 +49,7 @@ LL |         }, |x| x + 1);\n    |\n \n error: called `map(f).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/option_map_unwrap_or.rs:33:13\n+  --> $DIR/map_unwrap_or.rs:30:13\n    |\n LL |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -60,7 +60,7 @@ LL |     let _ = opt.and_then(|x| Some(x + 1));\n    |                 ^^^^^^^^                --\n \n error: called `map(f).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/option_map_unwrap_or.rs:35:13\n+  --> $DIR/map_unwrap_or.rs:32:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -78,7 +78,7 @@ LL |     );\n    |\n \n error: called `map(f).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/option_map_unwrap_or.rs:39:13\n+  --> $DIR/map_unwrap_or.rs:36:13\n    |\n LL |       let _ = opt\n    |  _____________^\n@@ -92,7 +92,7 @@ LL |         .and_then(|x| Some(x + 1));\n    |          ^^^^^^^^                --\n \n error: called `map(f).unwrap_or(a)` on an `Option` value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/option_map_unwrap_or.rs:50:13\n+  --> $DIR/map_unwrap_or.rs:47:13\n    |\n LL |     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -103,19 +103,18 @@ LL |     let _ = Some(\"prefix\").map_or(id, |p| format!(\"{}.\", p));\n    |                            ^^^^^^ ^^^                      --\n \n error: called `map(f).unwrap_or_else(g)` on an `Option` value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/option_map_unwrap_or.rs:54:13\n+  --> $DIR/map_unwrap_or.rs:51:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n LL | |         // Should lint even though this call is on a separate line.\n LL | |         .unwrap_or_else(|| 0);\n    | |_____________________________^\n    |\n-   = note: `-D clippy::option-map-unwrap-or-else` implied by `-D warnings`\n    = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n \n error: called `map(f).unwrap_or_else(g)` on an `Option` value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/option_map_unwrap_or.rs:58:13\n+  --> $DIR/map_unwrap_or.rs:55:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -125,7 +124,7 @@ LL | |     ).unwrap_or_else(|| 0);\n    | |__________________________^\n \n error: called `map(f).unwrap_or_else(g)` on an `Option` value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/option_map_unwrap_or.rs:62:13\n+  --> $DIR/map_unwrap_or.rs:59:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -134,5 +133,29 @@ LL | |             0\n LL | |         );\n    | |_________^\n \n-error: aborting due to 10 previous errors\n+error: called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling `.map_or_else(g, f)` instead\n+  --> $DIR/map_unwrap_or.rs:88:13\n+   |\n+LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `map_or_else(|e| 0, |x| x + 1)`\n+\n+error: called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling `.map_or_else(g, f)` instead\n+  --> $DIR/map_unwrap_or.rs:90:13\n+   |\n+LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `map_or_else(|e| 0, |x| x + 1)`\n+\n+error: called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling `.map_or_else(g, f)` instead\n+  --> $DIR/map_unwrap_or.rs:91:13\n+   |\n+LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `map_or_else(|e| 0, |x| x + 1)`\n+\n+error: aborting due to 13 previous errors\n ", "previous_filename": "tests/ui/option_map_unwrap_or.stderr"}, {"sha": "d80c3c7c1b7225664a91e95254005e748d919c9a", "filename": "tests/ui/option_map_or_none.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Foption_map_or_none.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Foption_map_or_none.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_or_none.fixed?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(clippy::option_and_then_some)]\n+#![allow(clippy::bind_instead_of_map)]\n \n fn main() {\n     let opt = Some(1);"}, {"sha": "629842419e546d1af1e57ffe1c8062797a46f04d", "filename": "tests/ui/option_map_or_none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_or_none.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(clippy::option_and_then_some)]\n+#![allow(clippy::bind_instead_of_map)]\n \n fn main() {\n     let opt = Some(1);"}, {"sha": "40751bfebe6c926e602eafbae9e9662aefdf32d2", "filename": "tests/ui/result_map_unwrap_or_else.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8bba1b758916d012a09463c4aade5750cd482f80/tests%2Fui%2Fresult_map_unwrap_or_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bba1b758916d012a09463c4aade5750cd482f80/tests%2Fui%2Fresult_map_unwrap_or_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_map_unwrap_or_else.rs?ref=8bba1b758916d012a09463c4aade5750cd482f80", "patch": "@@ -1,23 +0,0 @@\n-// aux-build:option_helpers.rs\n-\n-//! Checks implementation of `RESULT_MAP_UNWRAP_OR_ELSE`\n-\n-#![warn(clippy::result_map_unwrap_or_else)]\n-\n-#[macro_use]\n-extern crate option_helpers;\n-\n-fn result_methods() {\n-    let res: Result<i32, ()> = Ok(1);\n-\n-    // Check RESULT_MAP_UNWRAP_OR_ELSE\n-    // single line case\n-    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n-                                                      // multi line cases\n-    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n-    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n-    // macro case\n-    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|e| 0); // should not lint\n-}\n-\n-fn main() {}"}, {"sha": "ec7bc8f12414f05258c2e0feb2336cd289c3e5f6", "filename": "tests/ui/result_map_unwrap_or_else.stderr", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8bba1b758916d012a09463c4aade5750cd482f80/tests%2Fui%2Fresult_map_unwrap_or_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8bba1b758916d012a09463c4aade5750cd482f80/tests%2Fui%2Fresult_map_unwrap_or_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_map_unwrap_or_else.stderr?ref=8bba1b758916d012a09463c4aade5750cd482f80", "patch": "@@ -1,27 +0,0 @@\n-error: called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling `.map_or_else(g, f)` instead\n-  --> $DIR/result_map_unwrap_or_else.rs:15:13\n-   |\n-LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::result-map-unwrap-or-else` implied by `-D warnings`\n-   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `map_or_else(|e| 0, |x| x + 1)`\n-\n-error: called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling `.map_or_else(g, f)` instead\n-  --> $DIR/result_map_unwrap_or_else.rs:17:13\n-   |\n-LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `map_or_else(|e| 0, |x| x + 1)`\n-\n-error: called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling `.map_or_else(g, f)` instead\n-  --> $DIR/result_map_unwrap_or_else.rs:18:13\n-   |\n-LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `map_or_else(|e| 0, |x| x + 1)`\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "ee2cbc3cf540eb1309ced9d7a3caee6720047611", "filename": "tests/ui/reversed_empty_ranges_fixable.fixed", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_fixable.fixed?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -0,0 +1,24 @@\n+// run-rustfix\n+#![warn(clippy::reversed_empty_ranges)]\n+\n+const ANSWER: i32 = 42;\n+\n+fn main() {\n+    (21..=42).rev().for_each(|x| println!(\"{}\", x));\n+    let _ = (21..ANSWER).rev().filter(|x| x % 2 == 0).take(10).collect::<Vec<_>>();\n+\n+    for _ in (-42..=-21).rev() {}\n+    for _ in (21u32..42u32).rev() {}\n+\n+    // These should be ignored as they are not empty ranges:\n+\n+    (21..=42).for_each(|x| println!(\"{}\", x));\n+    (21..42).for_each(|x| println!(\"{}\", x));\n+\n+    let arr = [1, 2, 3, 4, 5];\n+    let _ = &arr[1..=3];\n+    let _ = &arr[1..3];\n+\n+    for _ in 21..=42 {}\n+    for _ in 21..42 {}\n+}"}, {"sha": "6ed5ca6daa0e8fd537e8b7e0635234dbb6f491cb", "filename": "tests/ui/reversed_empty_ranges_fixable.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_fixable.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -0,0 +1,24 @@\n+// run-rustfix\n+#![warn(clippy::reversed_empty_ranges)]\n+\n+const ANSWER: i32 = 42;\n+\n+fn main() {\n+    (42..=21).for_each(|x| println!(\"{}\", x));\n+    let _ = (ANSWER..21).filter(|x| x % 2 == 0).take(10).collect::<Vec<_>>();\n+\n+    for _ in -21..=-42 {}\n+    for _ in 42u32..21u32 {}\n+\n+    // These should be ignored as they are not empty ranges:\n+\n+    (21..=42).for_each(|x| println!(\"{}\", x));\n+    (21..42).for_each(|x| println!(\"{}\", x));\n+\n+    let arr = [1, 2, 3, 4, 5];\n+    let _ = &arr[1..=3];\n+    let _ = &arr[1..3];\n+\n+    for _ in 21..=42 {}\n+    for _ in 21..42 {}\n+}"}, {"sha": "97933b8ff851530496f750deb848bb0a87668e1d", "filename": "tests/ui/reversed_empty_ranges_fixable.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_fixable.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -0,0 +1,47 @@\n+error: this range is empty so it will yield no values\n+  --> $DIR/reversed_empty_ranges_fixable.rs:7:5\n+   |\n+LL |     (42..=21).for_each(|x| println!(\"{}\", x));\n+   |     ^^^^^^^^^\n+   |\n+   = note: `-D clippy::reversed-empty-ranges` implied by `-D warnings`\n+help: consider using the following if you are attempting to iterate over this range in reverse\n+   |\n+LL |     (21..=42).rev().for_each(|x| println!(\"{}\", x));\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: this range is empty so it will yield no values\n+  --> $DIR/reversed_empty_ranges_fixable.rs:8:13\n+   |\n+LL |     let _ = (ANSWER..21).filter(|x| x % 2 == 0).take(10).collect::<Vec<_>>();\n+   |             ^^^^^^^^^^^^\n+   |\n+help: consider using the following if you are attempting to iterate over this range in reverse\n+   |\n+LL |     let _ = (21..ANSWER).rev().filter(|x| x % 2 == 0).take(10).collect::<Vec<_>>();\n+   |             ^^^^^^^^^^^^^^^^^^\n+\n+error: this range is empty so it will yield no values\n+  --> $DIR/reversed_empty_ranges_fixable.rs:10:14\n+   |\n+LL |     for _ in -21..=-42 {}\n+   |              ^^^^^^^^^\n+   |\n+help: consider using the following if you are attempting to iterate over this range in reverse\n+   |\n+LL |     for _ in (-42..=-21).rev() {}\n+   |              ^^^^^^^^^^^^^^^^^\n+\n+error: this range is empty so it will yield no values\n+  --> $DIR/reversed_empty_ranges_fixable.rs:11:14\n+   |\n+LL |     for _ in 42u32..21u32 {}\n+   |              ^^^^^^^^^^^^\n+   |\n+help: consider using the following if you are attempting to iterate over this range in reverse\n+   |\n+LL |     for _ in (21u32..42u32).rev() {}\n+   |              ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "f1503ed6d12f9437302a1fd16b08e865766506ff", "filename": "tests/ui/reversed_empty_ranges_loops_fixable.fixed", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_loops_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_loops_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_loops_fixable.fixed?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -0,0 +1,57 @@\n+// run-rustfix\n+#![warn(clippy::reversed_empty_ranges)]\n+\n+fn main() {\n+    const MAX_LEN: usize = 42;\n+\n+    for i in (0..10).rev() {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in (0..=10).rev() {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in (0..MAX_LEN).rev() {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in 5..=5 {\n+        // not an error, this is the range with only one element \u201c5\u201d\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in 0..10 {\n+        // not an error, the start index is less than the end index\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in -10..0 {\n+        // not an error\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in (0..10).rev().map(|x| x * 2) {\n+        println!(\"{}\", i);\n+    }\n+\n+    // testing that the empty range lint folds constants\n+    for i in (5 + 4..10).rev() {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in ((3 - 1)..(5 + 2)).rev() {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in (2 * 2)..(2 * 3) {\n+        // no error, 4..6 is fine\n+        println!(\"{}\", i);\n+    }\n+\n+    let x = 42;\n+    for i in x..10 {\n+        // no error, not constant-foldable\n+        println!(\"{}\", i);\n+    }\n+}"}, {"sha": "a733788dc22c1a2bf852644569375ec7ec1ea449", "filename": "tests/ui/reversed_empty_ranges_loops_fixable.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_loops_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_loops_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_loops_fixable.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -0,0 +1,57 @@\n+// run-rustfix\n+#![warn(clippy::reversed_empty_ranges)]\n+\n+fn main() {\n+    const MAX_LEN: usize = 42;\n+\n+    for i in 10..0 {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in 10..=0 {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in MAX_LEN..0 {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in 5..=5 {\n+        // not an error, this is the range with only one element \u201c5\u201d\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in 0..10 {\n+        // not an error, the start index is less than the end index\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in -10..0 {\n+        // not an error\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in (10..0).map(|x| x * 2) {\n+        println!(\"{}\", i);\n+    }\n+\n+    // testing that the empty range lint folds constants\n+    for i in 10..5 + 4 {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in (5 + 2)..(3 - 1) {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in (2 * 2)..(2 * 3) {\n+        // no error, 4..6 is fine\n+        println!(\"{}\", i);\n+    }\n+\n+    let x = 42;\n+    for i in x..10 {\n+        // no error, not constant-foldable\n+        println!(\"{}\", i);\n+    }\n+}"}, {"sha": "e89e040a0ff9e0ae5f3b49e2eaf00f85bebf556b", "filename": "tests/ui/reversed_empty_ranges_loops_fixable.stderr", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_loops_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_loops_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_loops_fixable.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -0,0 +1,69 @@\n+error: this range is empty so it will yield no values\n+  --> $DIR/reversed_empty_ranges_loops_fixable.rs:7:14\n+   |\n+LL |     for i in 10..0 {\n+   |              ^^^^^\n+   |\n+   = note: `-D clippy::reversed-empty-ranges` implied by `-D warnings`\n+help: consider using the following if you are attempting to iterate over this range in reverse\n+   |\n+LL |     for i in (0..10).rev() {\n+   |              ^^^^^^^^^^^^^\n+\n+error: this range is empty so it will yield no values\n+  --> $DIR/reversed_empty_ranges_loops_fixable.rs:11:14\n+   |\n+LL |     for i in 10..=0 {\n+   |              ^^^^^^\n+   |\n+help: consider using the following if you are attempting to iterate over this range in reverse\n+   |\n+LL |     for i in (0..=10).rev() {\n+   |              ^^^^^^^^^^^^^^\n+\n+error: this range is empty so it will yield no values\n+  --> $DIR/reversed_empty_ranges_loops_fixable.rs:15:14\n+   |\n+LL |     for i in MAX_LEN..0 {\n+   |              ^^^^^^^^^^\n+   |\n+help: consider using the following if you are attempting to iterate over this range in reverse\n+   |\n+LL |     for i in (0..MAX_LEN).rev() {\n+   |              ^^^^^^^^^^^^^^^^^^\n+\n+error: this range is empty so it will yield no values\n+  --> $DIR/reversed_empty_ranges_loops_fixable.rs:34:14\n+   |\n+LL |     for i in (10..0).map(|x| x * 2) {\n+   |              ^^^^^^^\n+   |\n+help: consider using the following if you are attempting to iterate over this range in reverse\n+   |\n+LL |     for i in (0..10).rev().map(|x| x * 2) {\n+   |              ^^^^^^^^^^^^^\n+\n+error: this range is empty so it will yield no values\n+  --> $DIR/reversed_empty_ranges_loops_fixable.rs:39:14\n+   |\n+LL |     for i in 10..5 + 4 {\n+   |              ^^^^^^^^^\n+   |\n+help: consider using the following if you are attempting to iterate over this range in reverse\n+   |\n+LL |     for i in (5 + 4..10).rev() {\n+   |              ^^^^^^^^^^^^^^^^^\n+\n+error: this range is empty so it will yield no values\n+  --> $DIR/reversed_empty_ranges_loops_fixable.rs:43:14\n+   |\n+LL |     for i in (5 + 2)..(3 - 1) {\n+   |              ^^^^^^^^^^^^^^^^\n+   |\n+help: consider using the following if you are attempting to iterate over this range in reverse\n+   |\n+LL |     for i in ((3 - 1)..(5 + 2)).rev() {\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "c4c572244168b70fdae81f1c115674b0617e740c", "filename": "tests/ui/reversed_empty_ranges_loops_unfixable.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_loops_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_loops_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_loops_unfixable.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -0,0 +1,11 @@\n+#![warn(clippy::reversed_empty_ranges)]\n+\n+fn main() {\n+    for i in 5..5 {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in (5 + 2)..(8 - 1) {\n+        println!(\"{}\", i);\n+    }\n+}"}, {"sha": "30095d20cfd41154df5eca93c924ab3578ca83b5", "filename": "tests/ui/reversed_empty_ranges_loops_unfixable.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_loops_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_loops_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_loops_unfixable.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -0,0 +1,16 @@\n+error: this range is empty so it will yield no values\n+  --> $DIR/reversed_empty_ranges_loops_unfixable.rs:4:14\n+   |\n+LL |     for i in 5..5 {\n+   |              ^^^^\n+   |\n+   = note: `-D clippy::reversed-empty-ranges` implied by `-D warnings`\n+\n+error: this range is empty so it will yield no values\n+  --> $DIR/reversed_empty_ranges_loops_unfixable.rs:8:14\n+   |\n+LL |     for i in (5 + 2)..(8 - 1) {\n+   |              ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "c9ca4c476683101ccd049f1ede61d4526025f1b2", "filename": "tests/ui/reversed_empty_ranges_unfixable.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_unfixable.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -0,0 +1,15 @@\n+#![warn(clippy::reversed_empty_ranges)]\n+\n+const ANSWER: i32 = 42;\n+const SOME_NUM: usize = 3;\n+\n+fn main() {\n+    let _ = (42 + 10..42 + 10).map(|x| x / 2).find(|&x| x == 21);\n+\n+    let arr = [1, 2, 3, 4, 5];\n+    let _ = &arr[3usize..=1usize];\n+    let _ = &arr[SOME_NUM..1];\n+    let _ = &arr[3..3];\n+\n+    for _ in ANSWER..ANSWER {}\n+}"}, {"sha": "12e5483ecdfff05e6d5869cbe51ea8b0038b72d4", "filename": "tests/ui/reversed_empty_ranges_unfixable.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Freversed_empty_ranges_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_unfixable.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -0,0 +1,34 @@\n+error: this range is empty so it will yield no values\n+  --> $DIR/reversed_empty_ranges_unfixable.rs:7:13\n+   |\n+LL |     let _ = (42 + 10..42 + 10).map(|x| x / 2).find(|&x| x == 21);\n+   |             ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::reversed-empty-ranges` implied by `-D warnings`\n+\n+error: this range is reversed and using it to index a slice will panic at run-time\n+  --> $DIR/reversed_empty_ranges_unfixable.rs:10:18\n+   |\n+LL |     let _ = &arr[3usize..=1usize];\n+   |                  ^^^^^^^^^^^^^^^\n+\n+error: this range is reversed and using it to index a slice will panic at run-time\n+  --> $DIR/reversed_empty_ranges_unfixable.rs:11:18\n+   |\n+LL |     let _ = &arr[SOME_NUM..1];\n+   |                  ^^^^^^^^^^^\n+\n+error: this range is empty and using it to index a slice will always yield an empty slice\n+  --> $DIR/reversed_empty_ranges_unfixable.rs:12:18\n+   |\n+LL |     let _ = &arr[3..3];\n+   |                  ^^^^\n+\n+error: this range is empty so it will yield no values\n+  --> $DIR/reversed_empty_ranges_unfixable.rs:14:14\n+   |\n+LL |     for _ in ANSWER..ANSWER {}\n+   |              ^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "07f2791786d7f48711378386377019c698b33af4", "filename": "tests/ui/unused_unit.fixed", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Funused_unit.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Funused_unit.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_unit.fixed?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -14,11 +14,10 @@\n \n struct Unitter;\n impl Unitter {\n-    // try to disorient the lint with multiple unit returns and newlines\n     #[allow(clippy::no_effect)]\n-    pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) \n-    where G: Fn() -> () {\n-        let _y: &dyn Fn() -> () = &f;\n+    pub fn get_unit<F: Fn() , G>(&self, f: F, _g: G) \n+    where G: Fn()  {\n+        let _y: &dyn Fn()  = &f;\n         (); // this should not lint, as it's not in return type position\n     }\n }\n@@ -30,6 +29,20 @@ impl Into<()> for Unitter {\n     }\n }\n \n+trait Trait {\n+    fn redundant<F: FnOnce() , G, H>(&self, _f: F, _g: G, _h: H)\n+    where\n+        G: FnMut() ,\n+        H: Fn() ;\n+}\n+\n+impl Trait for Unitter {\n+    fn redundant<F: FnOnce() , G, H>(&self, _f: F, _g: G, _h: H)\n+    where\n+        G: FnMut() ,\n+        H: Fn()  {}\n+}\n+\n fn return_unit()  {  }\n \n #[allow(clippy::needless_return)]"}, {"sha": "e2c6afb020f5887dc175b3f8a832fb8293173637", "filename": "tests/ui/unused_unit.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_unit.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -14,10 +14,8 @@\n \n struct Unitter;\n impl Unitter {\n-    // try to disorient the lint with multiple unit returns and newlines\n     #[allow(clippy::no_effect)]\n-    pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) ->\n-        ()\n+    pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) -> ()\n     where G: Fn() -> () {\n         let _y: &dyn Fn() -> () = &f;\n         (); // this should not lint, as it's not in return type position\n@@ -31,6 +29,20 @@ impl Into<()> for Unitter {\n     }\n }\n \n+trait Trait {\n+    fn redundant<F: FnOnce() -> (), G, H>(&self, _f: F, _g: G, _h: H)\n+    where\n+        G: FnMut() -> (),\n+        H: Fn() -> ();\n+}\n+\n+impl Trait for Unitter {\n+    fn redundant<F: FnOnce() -> (), G, H>(&self, _f: F, _g: G, _h: H)\n+    where\n+        G: FnMut() -> (),\n+        H: Fn() -> () {}\n+}\n+\n fn return_unit() -> () { () }\n \n #[allow(clippy::needless_return)]"}, {"sha": "81e6738e6bf67b8cdec71e21fc20b5027cfe19b4", "filename": "tests/ui/unused_unit.stderr", "status": "modified", "additions": 64, "deletions": 12, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Funused_unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Funused_unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_unit.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,10 +1,8 @@\n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:19:59\n+  --> $DIR/unused_unit.rs:18:29\n    |\n-LL |       pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) ->\n-   |  ___________________________________________________________^\n-LL | |         ()\n-   | |__________^ help: remove the `-> ()`\n+LL |     pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) -> ()\n+   |                             ^^^^^ help: remove the `-> ()`\n    |\n note: the lint level is defined here\n   --> $DIR/unused_unit.rs:12:9\n@@ -13,40 +11,94 @@ LL | #![deny(clippy::unused_unit)]\n    |         ^^^^^^^^^^^^^^^^^^^\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:29:19\n+  --> $DIR/unused_unit.rs:19:19\n+   |\n+LL |     where G: Fn() -> () {\n+   |                   ^^^^^ help: remove the `-> ()`\n+\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:18:59\n+   |\n+LL |     pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) -> ()\n+   |                                                           ^^^^^ help: remove the `-> ()`\n+\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:20:27\n+   |\n+LL |         let _y: &dyn Fn() -> () = &f;\n+   |                           ^^^^^ help: remove the `-> ()`\n+\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:27:19\n    |\n LL |     fn into(self) -> () {\n    |                   ^^^^^ help: remove the `-> ()`\n \n error: unneeded unit expression\n-  --> $DIR/unused_unit.rs:30:9\n+  --> $DIR/unused_unit.rs:28:9\n    |\n LL |         ()\n    |         ^^ help: remove the final `()`\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:34:18\n+  --> $DIR/unused_unit.rs:33:30\n+   |\n+LL |     fn redundant<F: FnOnce() -> (), G, H>(&self, _f: F, _g: G, _h: H)\n+   |                              ^^^^^ help: remove the `-> ()`\n+\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:35:20\n+   |\n+LL |         G: FnMut() -> (),\n+   |                    ^^^^^ help: remove the `-> ()`\n+\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:36:17\n+   |\n+LL |         H: Fn() -> ();\n+   |                 ^^^^^ help: remove the `-> ()`\n+\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:40:30\n+   |\n+LL |     fn redundant<F: FnOnce() -> (), G, H>(&self, _f: F, _g: G, _h: H)\n+   |                              ^^^^^ help: remove the `-> ()`\n+\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:42:20\n+   |\n+LL |         G: FnMut() -> (),\n+   |                    ^^^^^ help: remove the `-> ()`\n+\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:43:17\n+   |\n+LL |         H: Fn() -> () {}\n+   |                 ^^^^^ help: remove the `-> ()`\n+\n+error: unneeded unit return type\n+  --> $DIR/unused_unit.rs:46:18\n    |\n LL | fn return_unit() -> () { () }\n    |                  ^^^^^ help: remove the `-> ()`\n \n error: unneeded unit expression\n-  --> $DIR/unused_unit.rs:34:26\n+  --> $DIR/unused_unit.rs:46:26\n    |\n LL | fn return_unit() -> () { () }\n    |                          ^^ help: remove the final `()`\n \n error: unneeded `()`\n-  --> $DIR/unused_unit.rs:44:14\n+  --> $DIR/unused_unit.rs:56:14\n    |\n LL |         break();\n    |              ^^ help: remove the `()`\n \n error: unneeded `()`\n-  --> $DIR/unused_unit.rs:46:11\n+  --> $DIR/unused_unit.rs:58:11\n    |\n LL |     return();\n    |           ^^ help: remove the `()`\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "a4a3cd1d37977d3dcb16181db4ad8c20a54ffaab", "filename": "tests/ui/unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funwrap.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,4 +1,4 @@\n-#![warn(clippy::option_unwrap_used, clippy::result_unwrap_used)]\n+#![warn(clippy::unwrap_used)]\n \n fn unwrap_option() {\n     let opt = Some(0);"}, {"sha": "4f0858005f6e7f140cd0c69bcea3c9111e82b673", "filename": "tests/ui/unwrap.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Funwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Funwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funwrap.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -4,7 +4,7 @@ error: used `unwrap()` on `an Option` value\n LL |     let _ = opt.unwrap();\n    |             ^^^^^^^^^^^^\n    |\n-   = note: `-D clippy::option-unwrap-used` implied by `-D warnings`\n+   = note: `-D clippy::unwrap-used` implied by `-D warnings`\n    = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n \n error: used `unwrap()` on `a Result` value\n@@ -13,7 +13,6 @@ error: used `unwrap()` on `a Result` value\n LL |     let _ = res.unwrap();\n    |             ^^^^^^^^^^^^\n    |\n-   = note: `-D clippy::result-unwrap-used` implied by `-D warnings`\n    = help: if you don't want to handle the `Err` case gracefully, consider using `expect()` to provide a better panic message\n \n error: aborting due to 2 previous errors"}, {"sha": "fdd4bc581f305a21281c8d6da8e642cc54dbf455", "filename": "tests/ui/useless_conversion.fixed", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fuseless_conversion.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fuseless_conversion.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_conversion.fixed?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![deny(clippy::identity_conversion)]\n+#![deny(clippy::useless_conversion)]\n \n fn test_generic<T: Copy>(val: T) -> T {\n     let _ = val;\n@@ -41,7 +41,7 @@ fn main() {\n     let _: String = \"foo\".into();\n     let _: String = From::from(\"foo\");\n     let _ = String::from(\"foo\");\n-    #[allow(clippy::identity_conversion)]\n+    #[allow(clippy::useless_conversion)]\n     {\n         let _: String = \"foo\".into();\n         let _ = String::from(\"foo\");", "previous_filename": "tests/ui/identity_conversion.fixed"}, {"sha": "4cae745e7c0211f2a886c21760451f459192fd59", "filename": "tests/ui/useless_conversion.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_conversion.rs?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![deny(clippy::identity_conversion)]\n+#![deny(clippy::useless_conversion)]\n \n fn test_generic<T: Copy>(val: T) -> T {\n     let _ = T::from(val);\n@@ -41,7 +41,7 @@ fn main() {\n     let _: String = \"foo\".into();\n     let _: String = From::from(\"foo\");\n     let _ = String::from(\"foo\");\n-    #[allow(clippy::identity_conversion)]\n+    #[allow(clippy::useless_conversion)]\n     {\n         let _: String = \"foo\".into();\n         let _ = String::from(\"foo\");", "previous_filename": "tests/ui/identity_conversion.rs"}, {"sha": "7df3507edfd9ebb25f2af54cb6f6885836e9ad5e", "filename": "tests/ui/useless_conversion.stderr", "status": "renamed", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fuseless_conversion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d3086492db10deaa3268952792e93ad09ecec0/tests%2Fui%2Fuseless_conversion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_conversion.stderr?ref=f1d3086492db10deaa3268952792e93ad09ecec0", "patch": "@@ -1,65 +1,65 @@\n-error: identical conversion\n-  --> $DIR/identity_conversion.rs:6:13\n+error: useless conversion\n+  --> $DIR/useless_conversion.rs:6:13\n    |\n LL |     let _ = T::from(val);\n    |             ^^^^^^^^^^^^ help: consider removing `T::from()`: `val`\n    |\n note: the lint level is defined here\n-  --> $DIR/identity_conversion.rs:3:9\n+  --> $DIR/useless_conversion.rs:3:9\n    |\n-LL | #![deny(clippy::identity_conversion)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #![deny(clippy::useless_conversion)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: identical conversion\n-  --> $DIR/identity_conversion.rs:7:5\n+error: useless conversion\n+  --> $DIR/useless_conversion.rs:7:5\n    |\n LL |     val.into()\n    |     ^^^^^^^^^^ help: consider removing `.into()`: `val`\n \n-error: identical conversion\n-  --> $DIR/identity_conversion.rs:19:22\n+error: useless conversion\n+  --> $DIR/useless_conversion.rs:19:22\n    |\n LL |         let _: i32 = 0i32.into();\n    |                      ^^^^^^^^^^^ help: consider removing `.into()`: `0i32`\n \n-error: identical conversion\n-  --> $DIR/identity_conversion.rs:51:21\n+error: useless conversion\n+  --> $DIR/useless_conversion.rs:51:21\n    |\n LL |     let _: String = \"foo\".to_string().into();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into()`: `\"foo\".to_string()`\n \n-error: identical conversion\n-  --> $DIR/identity_conversion.rs:52:21\n+error: useless conversion\n+  --> $DIR/useless_conversion.rs:52:21\n    |\n LL |     let _: String = From::from(\"foo\".to_string());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `From::from()`: `\"foo\".to_string()`\n \n-error: identical conversion\n-  --> $DIR/identity_conversion.rs:53:13\n+error: useless conversion\n+  --> $DIR/useless_conversion.rs:53:13\n    |\n LL |     let _ = String::from(\"foo\".to_string());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `String::from()`: `\"foo\".to_string()`\n \n-error: identical conversion\n-  --> $DIR/identity_conversion.rs:54:13\n+error: useless conversion\n+  --> $DIR/useless_conversion.rs:54:13\n    |\n LL |     let _ = String::from(format!(\"A: {:04}\", 123));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `String::from()`: `format!(\"A: {:04}\", 123)`\n \n-error: identical conversion\n-  --> $DIR/identity_conversion.rs:55:13\n+error: useless conversion\n+  --> $DIR/useless_conversion.rs:55:13\n    |\n LL |     let _ = \"\".lines().into_iter();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into_iter()`: `\"\".lines()`\n \n-error: identical conversion\n-  --> $DIR/identity_conversion.rs:56:13\n+error: useless conversion\n+  --> $DIR/useless_conversion.rs:56:13\n    |\n LL |     let _ = vec![1, 2, 3].into_iter().into_iter();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into_iter()`: `vec![1, 2, 3].into_iter()`\n \n-error: identical conversion\n-  --> $DIR/identity_conversion.rs:57:21\n+error: useless conversion\n+  --> $DIR/useless_conversion.rs:57:21\n    |\n LL |     let _: String = format!(\"Hello {}\", \"world\").into();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into()`: `format!(\"Hello {}\", \"world\")`", "previous_filename": "tests/ui/identity_conversion.stderr"}]}