{"sha": "b9da2b372fb14c339779eeee02c9bb7468effc6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ZGEyYjM3MmZiMTRjMzM5Nzc5ZWVlZTAyYzliYjc0NjhlZmZjNmQ=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-11-12T18:16:46Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-11-12T18:17:42Z"}, "message": "Factor out match usefulness computation in `check_match`\n\nThis make `_match` a lot more self-contained", "tree": {"sha": "e5036fa2342ee622c9fb2f20c0d454ae9fc0ed5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5036fa2342ee622c9fb2f20c0d454ae9fc0ed5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9da2b372fb14c339779eeee02c9bb7468effc6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9da2b372fb14c339779eeee02c9bb7468effc6d", "html_url": "https://github.com/rust-lang/rust/commit/b9da2b372fb14c339779eeee02c9bb7468effc6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9da2b372fb14c339779eeee02c9bb7468effc6d/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5a7ec0929dc438a78716585ceff827d51c8a32f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5a7ec0929dc438a78716585ceff827d51c8a32f", "html_url": "https://github.com/rust-lang/rust/commit/d5a7ec0929dc438a78716585ceff827d51c8a32f"}], "stats": {"total": 196, "additions": 118, "deletions": 78}, "files": [{"sha": "bec9b099e3831d73c095247d711811899c19d5b3", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 70, "deletions": 9, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b9da2b372fb14c339779eeee02c9bb7468effc6d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9da2b372fb14c339779eeee02c9bb7468effc6d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=b9da2b372fb14c339779eeee02c9bb7468effc6d", "patch": "@@ -364,14 +364,14 @@ impl<'tcx> Pat<'tcx> {\n /// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n /// works well.\n #[derive(Debug, Clone)]\n-crate struct PatStack<'p, 'tcx> {\n+struct PatStack<'p, 'tcx> {\n     pats: SmallVec<[&'p Pat<'tcx>; 2]>,\n     /// Cache for the constructor of the head\n     head_ctor: OnceCell<Constructor<'tcx>>,\n }\n \n impl<'p, 'tcx> PatStack<'p, 'tcx> {\n-    crate fn from_pattern(pat: &'p Pat<'tcx>) -> Self {\n+    fn from_pattern(pat: &'p Pat<'tcx>) -> Self {\n         Self::from_vec(smallvec![pat])\n     }\n \n@@ -455,17 +455,17 @@ impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n \n /// A 2D matrix.\n #[derive(Clone, PartialEq)]\n-crate struct Matrix<'p, 'tcx> {\n+struct Matrix<'p, 'tcx> {\n     patterns: Vec<PatStack<'p, 'tcx>>,\n }\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n-    crate fn empty() -> Self {\n+    fn empty() -> Self {\n         Matrix { patterns: vec![] }\n     }\n \n     /// Pushes a new row to the matrix. If the row starts with an or-pattern, this expands it.\n-    crate fn push(&mut self, row: PatStack<'p, 'tcx>) {\n+    fn push(&mut self, row: PatStack<'p, 'tcx>) {\n         if let Some(rows) = row.expand_or_pat() {\n             for row in rows {\n                 // We recursively expand the or-patterns of the new rows.\n@@ -588,7 +588,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     }\n \n     /// Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n-    crate fn is_foreign_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n+    fn is_foreign_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.kind() {\n             ty::Adt(def, ..) => {\n                 def.is_enum() && def.is_variant_list_non_exhaustive() && !def.did.is_local()\n@@ -1439,7 +1439,7 @@ impl<'tcx> Usefulness<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug)]\n-crate enum WitnessPreference {\n+enum WitnessPreference {\n     ConstructWitness,\n     LeaveOutWitness,\n }\n@@ -1495,7 +1495,8 @@ struct PatCtxt<'a, 'p, 'tcx> {\n crate struct Witness<'tcx>(Vec<Pat<'tcx>>);\n \n impl<'tcx> Witness<'tcx> {\n-    crate fn single_pattern(self) -> Pat<'tcx> {\n+    /// Asserts that the witness contains a single pattern, and returns it.\n+    fn single_pattern(self) -> Pat<'tcx> {\n         assert_eq!(self.0.len(), 1);\n         self.0.into_iter().next().unwrap()\n     }\n@@ -2092,7 +2093,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n /// `is_under_guard` is used to inform if the pattern has a guard. If it\n /// has one it must not be inserted into the matrix. This shouldn't be\n /// relied on for soundness.\n-crate fn is_useful<'p, 'tcx>(\n+fn is_useful<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n     v: &PatStack<'p, 'tcx>,\n@@ -2289,3 +2290,63 @@ fn pat_constructor<'p, 'tcx>(\n         PatKind::Or { .. } => bug!(\"Or-pattern should have been expanded earlier on.\"),\n     }\n }\n+\n+/// The arm of a match expression.\n+#[derive(Clone, Copy)]\n+crate struct MatchArm<'p, 'tcx> {\n+    /// The pattern must have been lowered through `MatchVisitor::lower_pattern`.\n+    crate pat: &'p super::Pat<'tcx>,\n+    crate hir_id: HirId,\n+    crate has_guard: bool,\n+}\n+\n+/// The output of checking a match for exhaustiveness and arm reachability.\n+crate struct UsefulnessReport<'p, 'tcx> {\n+    /// For each arm of the input, whether that arm is reachable after the arms above it.\n+    crate arm_usefulness: Vec<(MatchArm<'p, 'tcx>, Usefulness<'tcx>)>,\n+    /// If the match is exhaustive, this is empty. If not, this contains witnesses for the lack of\n+    /// exhaustiveness.\n+    crate non_exhaustiveness_witnesses: Vec<super::Pat<'tcx>>,\n+}\n+\n+/// The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which\n+/// of its arms are reachable.\n+///\n+/// Note: the input patterns must have been lowered through `MatchVisitor::lower_pattern`.\n+crate fn compute_match_usefulness<'p, 'tcx>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n+    arms: &[MatchArm<'p, 'tcx>],\n+    scrut_hir_id: HirId,\n+    scrut_ty: Ty<'tcx>,\n+) -> UsefulnessReport<'p, 'tcx> {\n+    let mut matrix = Matrix::empty();\n+    let arm_usefulness: Vec<_> = arms\n+        .iter()\n+        .copied()\n+        .map(|arm| {\n+            let v = PatStack::from_pattern(arm.pat);\n+            let usefulness =\n+                is_useful(cx, &matrix, &v, LeaveOutWitness, arm.hir_id, arm.has_guard, true);\n+            if !arm.has_guard {\n+                matrix.push(v);\n+            }\n+            (arm, usefulness)\n+        })\n+        .collect();\n+\n+    let wild_pattern = cx.pattern_arena.alloc(super::Pat::wildcard_from_ty(scrut_ty));\n+    let v = PatStack::from_pattern(wild_pattern);\n+    let usefulness = is_useful(cx, &matrix, &v, ConstructWitness, scrut_hir_id, false, true);\n+    let non_exhaustiveness_witnesses = match usefulness {\n+        NotUseful => vec![], // Wildcard pattern isn't useful, so the match is exhaustive.\n+        UsefulWithWitness(pats) => {\n+            if pats.is_empty() {\n+                bug!(\"Exhaustiveness check returned no witnesses\")\n+            } else {\n+                pats.into_iter().map(|w| w.single_pattern()).collect()\n+            }\n+        }\n+        Useful(_) => bug!(),\n+    };\n+    UsefulnessReport { arm_usefulness, non_exhaustiveness_witnesses }\n+}"}, {"sha": "9a447d9a6aec351298a3b86c9c1636101f071312", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 48, "deletions": 69, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/b9da2b372fb14c339779eeee02c9bb7468effc6d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9da2b372fb14c339779eeee02c9bb7468effc6d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=b9da2b372fb14c339779eeee02c9bb7468effc6d", "patch": "@@ -1,6 +1,7 @@\n use super::_match::Usefulness::*;\n-use super::_match::WitnessPreference::*;\n-use super::_match::{expand_pattern, is_useful, MatchCheckCtxt, Matrix, PatStack};\n+use super::_match::{\n+    compute_match_usefulness, expand_pattern, MatchArm, MatchCheckCtxt, UsefulnessReport,\n+};\n use super::{PatCtxt, PatKind, PatternError};\n \n use rustc_arena::TypedArena;\n@@ -169,39 +170,50 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n         let mut have_errors = false;\n \n-        let inlined_arms: Vec<_> = arms\n+        let arms: Vec<_> = arms\n             .iter()\n-            .map(|hir::Arm { pat, guard, .. }| {\n-                (self.lower_pattern(&mut cx, pat, &mut have_errors).0, pat.hir_id, guard.is_some())\n+            .map(|hir::Arm { pat, guard, .. }| MatchArm {\n+                pat: self.lower_pattern(&mut cx, pat, &mut have_errors).0,\n+                hir_id: pat.hir_id,\n+                has_guard: guard.is_some(),\n             })\n             .collect();\n \n-        // Bail out early if inlining failed.\n+        // Bail out early if lowering failed.\n         if have_errors {\n             return;\n         }\n \n-        // Fourth, check for unreachable arms.\n-        let matrix = check_arms(&mut cx, &inlined_arms, source);\n+        let scrut_ty = self.typeck_results.expr_ty_adjusted(scrut);\n+        let report = compute_match_usefulness(&cx, &arms, scrut.hir_id, scrut_ty);\n+\n+        // Report unreachable arms.\n+        report_arm_reachability(&cx, &report, source);\n \n-        // Fifth, check if the match is exhaustive.\n+        // Check if the match is exhaustive.\n         // Note: An empty match isn't the same as an empty matrix for diagnostics purposes,\n         // since an empty matrix can occur when there are arms, if those arms all have guards.\n-        let scrut_ty = self.typeck_results.expr_ty_adjusted(scrut);\n-        let is_empty_match = inlined_arms.is_empty();\n-        check_exhaustive(&mut cx, scrut_ty, scrut.span, &matrix, scrut.hir_id, is_empty_match);\n+        let is_empty_match = arms.is_empty();\n+        let witnesses = report.non_exhaustiveness_witnesses;\n+        if !witnesses.is_empty() {\n+            non_exhaustive_match(&cx, scrut_ty, scrut.span, witnesses, is_empty_match);\n+        }\n     }\n \n     fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let mut cx = self.new_cx(pat.hir_id);\n \n         let (pattern, pattern_ty) = self.lower_pattern(&mut cx, pat, &mut false);\n-        let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(pattern)].into_iter().collect();\n-\n-        let witnesses = match check_not_useful(&mut cx, pattern_ty, &pats, pat.hir_id) {\n-            Ok(_) => return,\n-            Err(err) => err,\n-        };\n+        let arms = vec![MatchArm { pat: pattern, hir_id: pat.hir_id, has_guard: false }];\n+        let report = compute_match_usefulness(&cx, &arms, pat.hir_id, pattern_ty);\n+\n+        // Note: we ignore whether the pattern is unreachable (i.e. whether the type is empty). We\n+        // only care about exhaustiveness here.\n+        let witnesses = report.non_exhaustiveness_witnesses;\n+        if witnesses.is_empty() {\n+            // The pattern is irrefutable.\n+            return;\n+        }\n \n         let joined_patterns = joined_uncovered_patterns(&witnesses);\n         let mut err = struct_span_err!(\n@@ -354,17 +366,15 @@ fn irrefutable_let_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, source: hir::\n     });\n }\n \n-/// Check for unreachable patterns.\n-fn check_arms<'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-    arms: &[(&'p super::Pat<'tcx>, HirId, bool)],\n+/// Report unreachable arms, if any.\n+fn report_arm_reachability<'p, 'tcx>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n+    report: &UsefulnessReport<'p, 'tcx>,\n     source: hir::MatchSource,\n-) -> Matrix<'p, 'tcx> {\n-    let mut seen = Matrix::empty();\n+) {\n     let mut catchall = None;\n-    for (arm_index, (pat, id, has_guard)) in arms.iter().copied().enumerate() {\n-        let v = PatStack::from_pattern(pat);\n-        match is_useful(cx, &seen, &v, LeaveOutWitness, id, has_guard, true) {\n+    for (arm_index, (arm, is_useful)) in report.arm_usefulness.iter().enumerate() {\n+        match is_useful {\n             NotUseful => {\n                 match source {\n                     hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => bug!(),\n@@ -373,15 +383,15 @@ fn check_arms<'p, 'tcx>(\n                         // Check which arm we're on.\n                         match arm_index {\n                             // The arm with the user-specified pattern.\n-                            0 => unreachable_pattern(cx.tcx, pat.span, id, None),\n+                            0 => unreachable_pattern(cx.tcx, arm.pat.span, arm.hir_id, None),\n                             // The arm with the wildcard pattern.\n-                            1 => irrefutable_let_pattern(cx.tcx, pat.span, id, source),\n+                            1 => irrefutable_let_pattern(cx.tcx, arm.pat.span, arm.hir_id, source),\n                             _ => bug!(),\n                         }\n                     }\n \n                     hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n-                        unreachable_pattern(cx.tcx, pat.span, id, catchall);\n+                        unreachable_pattern(cx.tcx, arm.pat.span, arm.hir_id, catchall);\n                     }\n \n                     // Unreachable patterns in try and await expressions occur when one of\n@@ -392,60 +402,29 @@ fn check_arms<'p, 'tcx>(\n             Useful(unreachables) if unreachables.is_empty() => {}\n             // The arm is reachable, but contains unreachable subpatterns (from or-patterns).\n             Useful(unreachables) => {\n-                let mut unreachables: Vec<_> = unreachables.into_iter().flatten().collect();\n+                let mut unreachables: Vec<_> = unreachables.iter().flatten().copied().collect();\n                 // Emit lints in the order in which they occur in the file.\n                 unreachables.sort_unstable();\n                 for span in unreachables {\n-                    unreachable_pattern(cx.tcx, span, id, None);\n+                    unreachable_pattern(cx.tcx, span, arm.hir_id, None);\n                 }\n             }\n             UsefulWithWitness(_) => bug!(),\n         }\n-        if !has_guard {\n-            seen.push(v);\n-            if catchall.is_none() && pat_is_catchall(pat) {\n-                catchall = Some(pat.span);\n-            }\n+        if !arm.has_guard && catchall.is_none() && pat_is_catchall(arm.pat) {\n+            catchall = Some(arm.pat.span);\n         }\n     }\n-    seen\n }\n \n-fn check_not_useful<'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-    ty: Ty<'tcx>,\n-    matrix: &Matrix<'p, 'tcx>,\n-    hir_id: HirId,\n-) -> Result<(), Vec<super::Pat<'tcx>>> {\n-    let wild_pattern = cx.pattern_arena.alloc(super::Pat::wildcard_from_ty(ty));\n-    let v = PatStack::from_pattern(wild_pattern);\n-\n-    // false is given for `is_under_guard` argument due to the wildcard\n-    // pattern not having a guard\n-    match is_useful(cx, matrix, &v, ConstructWitness, hir_id, false, true) {\n-        NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n-        UsefulWithWitness(pats) => Err(if pats.is_empty() {\n-            bug!(\"Exhaustiveness check returned no witnesses\")\n-        } else {\n-            pats.into_iter().map(|w| w.single_pattern()).collect()\n-        }),\n-        Useful(_) => bug!(),\n-    }\n-}\n-\n-fn check_exhaustive<'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+/// Report that a match is not exhaustive.\n+fn non_exhaustive_match<'p, 'tcx>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n-    matrix: &Matrix<'p, 'tcx>,\n-    hir_id: HirId,\n+    witnesses: Vec<super::Pat<'tcx>>,\n     is_empty_match: bool,\n ) {\n-    let witnesses = match check_not_useful(cx, scrut_ty, matrix, hir_id) {\n-        Ok(_) => return,\n-        Err(err) => err,\n-    };\n-\n     let non_empty_enum = match scrut_ty.kind() {\n         ty::Adt(def, _) => def.is_enum() && !def.variants.is_empty(),\n         _ => false,"}]}