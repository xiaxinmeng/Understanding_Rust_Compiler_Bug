{"sha": "9664c57e60ec5662b3e8b063324d9ab7879d5570", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NjRjNTdlNjBlYzU2NjJiM2U4YjA2MzMyNGQ5YWI3ODc5ZDU1NzA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-13T21:52:14Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-13T21:54:37Z"}, "message": "Make hygiene private to hir", "tree": {"sha": "a62d88ce37b64507b708f8cdc86c8ff3602a42bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a62d88ce37b64507b708f8cdc86c8ff3602a42bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9664c57e60ec5662b3e8b063324d9ab7879d5570", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9664c57e60ec5662b3e8b063324d9ab7879d5570", "html_url": "https://github.com/rust-lang/rust/commit/9664c57e60ec5662b3e8b063324d9ab7879d5570", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9664c57e60ec5662b3e8b063324d9ab7879d5570/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9930ef253634465e2fe25b47b469e4c3bbcf6df1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9930ef253634465e2fe25b47b469e4c3bbcf6df1", "html_url": "https://github.com/rust-lang/rust/commit/9930ef253634465e2fe25b47b469e4c3bbcf6df1"}], "stats": {"total": 55, "additions": 39, "deletions": 16}, "files": [{"sha": "5dc3ae3b19ecb6865f3f8d681332f70997210505", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9664c57e60ec5662b3e8b063324d9ab7879d5570/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9664c57e60ec5662b3e8b063324d9ab7879d5570/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=9664c57e60ec5662b3e8b063324d9ab7879d5570", "patch": "@@ -883,6 +883,13 @@ where\n }\n \n impl AssocItem {\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n+        match self {\n+            AssocItem::Function(it) => Some(it.name(db)),\n+            AssocItem::Const(it) => it.name(db),\n+            AssocItem::TypeAlias(it) => Some(it.name(db)),\n+        }\n+    }\n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n         match self {\n             AssocItem::Function(f) => f.module(db),"}, {"sha": "4ae2bd0855b59216f34b23bd1e96326da28109a6", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9664c57e60ec5662b3e8b063324d9ab7879d5570/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9664c57e60ec5662b3e8b063324d9ab7879d5570/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=9664c57e60ec5662b3e8b063324d9ab7879d5570", "patch": "@@ -52,8 +52,12 @@ pub use hir_def::{\n     type_ref::{Mutability, TypeRef},\n };\n pub use hir_expand::{\n-    hygiene::Hygiene, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc,\n-    MacroDefId, /* FIXME */\n+    name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc, /* FIXME */ MacroDefId,\n     MacroFile, Origin,\n };\n pub use hir_ty::display::HirDisplay;\n+\n+// These are negative re-exports: pub using these names is forbidden, they\n+// should remain private to hir internals.\n+#[allow(unused)]\n+use hir_expand::hygiene::Hygiene;"}, {"sha": "d8beac98a6e4aefa42e8631693a353c506e2854c", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9664c57e60ec5662b3e8b063324d9ab7879d5570/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9664c57e60ec5662b3e8b063324d9ab7879d5570/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=9664c57e60ec5662b3e8b063324d9ab7879d5570", "patch": "@@ -502,18 +502,19 @@ impl<'db> SemanticsImpl<'db> {\n     fn scope(&self, node: &SyntaxNode) -> SemanticsScope<'db> {\n         let node = self.find_file(node.clone());\n         let resolver = self.analyze2(node.as_ref(), None).resolver;\n-        SemanticsScope { db: self.db, resolver }\n+        SemanticsScope { db: self.db, file_id: node.file_id, resolver }\n     }\n \n     fn scope_at_offset(&self, node: &SyntaxNode, offset: TextSize) -> SemanticsScope<'db> {\n         let node = self.find_file(node.clone());\n         let resolver = self.analyze2(node.as_ref(), Some(offset)).resolver;\n-        SemanticsScope { db: self.db, resolver }\n+        SemanticsScope { db: self.db, file_id: node.file_id, resolver }\n     }\n \n     fn scope_for_def(&self, def: Trait) -> SemanticsScope<'db> {\n+        let file_id = self.db.lookup_intern_trait(def.id).id.file_id;\n         let resolver = def.id.resolver(self.db.upcast());\n-        SemanticsScope { db: self.db, resolver }\n+        SemanticsScope { db: self.db, file_id, resolver }\n     }\n \n     fn analyze(&self, node: &SyntaxNode) -> SourceAnalyzer {\n@@ -709,6 +710,7 @@ fn find_root(node: &SyntaxNode) -> SyntaxNode {\n #[derive(Debug)]\n pub struct SemanticsScope<'a> {\n     pub db: &'a dyn HirDatabase,\n+    file_id: HirFileId,\n     resolver: Resolver,\n }\n \n@@ -752,6 +754,14 @@ impl<'a> SemanticsScope<'a> {\n         })\n     }\n \n+    /// Resolve a path as-if it was written at the given scope. This is\n+    /// necessary a heuristic, as it doesn't take hygiene into account.\n+    pub fn resolve_hypothetical(&self, path: &ast::Path) -> Option<PathResolution> {\n+        let hygiene = Hygiene::new(self.db.upcast(), self.file_id);\n+        let path = Path::from_src(path.clone(), &hygiene)?;\n+        self.resolve_hir_path(&path)\n+    }\n+\n     pub fn resolve_hir_path(&self, path: &Path) -> Option<PathResolution> {\n         resolve_hir_path(self.db, &self.resolver, path)\n     }"}, {"sha": "4441fb426a0c300f075a24aae192085dad87bb2b", "filename": "crates/ssr/src/resolving.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9664c57e60ec5662b3e8b063324d9ab7879d5570/crates%2Fssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9664c57e60ec5662b3e8b063324d9ab7879d5570/crates%2Fssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Fresolving.rs?ref=9664c57e60ec5662b3e8b063324d9ab7879d5570", "patch": "@@ -10,7 +10,6 @@ use test_utils::mark;\n \n pub(crate) struct ResolutionScope<'db> {\n     scope: hir::SemanticsScope<'db>,\n-    hygiene: hir::Hygiene,\n     node: SyntaxNode,\n }\n \n@@ -201,11 +200,7 @@ impl<'db> ResolutionScope<'db> {\n             .unwrap_or_else(|| file.syntax().clone());\n         let node = pick_node_for_resolution(node);\n         let scope = sema.scope(&node);\n-        ResolutionScope {\n-            scope,\n-            hygiene: hir::Hygiene::new(sema.db, resolve_context.file_id.into()),\n-            node,\n-        }\n+        ResolutionScope { scope, node }\n     }\n \n     /// Returns the function in which SSR was invoked, if any.\n@@ -214,24 +209,31 @@ impl<'db> ResolutionScope<'db> {\n     }\n \n     fn resolve_path(&self, path: &ast::Path) -> Option<hir::PathResolution> {\n-        let hir_path = hir::Path::from_src(path.clone(), &self.hygiene)?;\n         // First try resolving the whole path. This will work for things like\n         // `std::collections::HashMap`, but will fail for things like\n         // `std::collections::HashMap::new`.\n-        if let Some(resolution) = self.scope.resolve_hir_path(&hir_path) {\n+        if let Some(resolution) = self.scope.resolve_hypothetical(&path) {\n             return Some(resolution);\n         }\n         // Resolution failed, try resolving the qualifier (e.g. `std::collections::HashMap` and if\n         // that succeeds, then iterate through the candidates on the resolved type with the provided\n         // name.\n-        let resolved_qualifier = self.scope.resolve_hir_path_qualifier(&hir_path.qualifier()?)?;\n+        let resolved_qualifier = self.scope.resolve_hypothetical(&path.qualifier()?)?;\n         if let hir::PathResolution::Def(hir::ModuleDef::Adt(adt)) = resolved_qualifier {\n+            let name = path.segment()?.name_ref()?;\n             adt.ty(self.scope.db).iterate_path_candidates(\n                 self.scope.db,\n                 self.scope.module()?.krate(),\n                 &self.scope.traits_in_scope(),\n-                Some(hir_path.segments().last()?.name),\n-                |_ty, assoc_item| Some(hir::PathResolution::AssocItem(assoc_item)),\n+                None,\n+                |_ty, assoc_item| {\n+                    let item_name = assoc_item.name(self.scope.db)?;\n+                    if item_name.to_string().as_str() == name.text().as_str() {\n+                        Some(hir::PathResolution::AssocItem(assoc_item))\n+                    } else {\n+                        None\n+                    }\n+                },\n             )\n         } else {\n             None"}]}