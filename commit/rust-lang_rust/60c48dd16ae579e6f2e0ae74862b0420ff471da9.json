{"sha": "60c48dd16ae579e6f2e0ae74862b0420ff471da9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYzQ4ZGQxNmFlNTc5ZTZmMmUwYWU3NDg2MmIwNDIwZmY0NzFkYTk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-01-14T15:10:19Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-01-14T15:10:19Z"}, "message": "syntax: Disambiguate generics and qualified paths", "tree": {"sha": "eb068aeaec05dc394ca14ec455096b00624f9294", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb068aeaec05dc394ca14ec455096b00624f9294"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60c48dd16ae579e6f2e0ae74862b0420ff471da9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60c48dd16ae579e6f2e0ae74862b0420ff471da9", "html_url": "https://github.com/rust-lang/rust/commit/60c48dd16ae579e6f2e0ae74862b0420ff471da9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60c48dd16ae579e6f2e0ae74862b0420ff471da9/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d19e4c4a8507da7e35d0de2b196c48e6621de1f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d19e4c4a8507da7e35d0de2b196c48e6621de1f9", "html_url": "https://github.com/rust-lang/rust/commit/d19e4c4a8507da7e35d0de2b196c48e6621de1f9"}], "stats": {"total": 72, "additions": 54, "deletions": 18}, "files": [{"sha": "e7565d357397cbce0f1a91eed9bb00d6db582e9a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/60c48dd16ae579e6f2e0ae74862b0420ff471da9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c48dd16ae579e6f2e0ae74862b0420ff471da9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=60c48dd16ae579e6f2e0ae74862b0420ff471da9", "patch": "@@ -4772,21 +4772,13 @@ impl<'a> Parser<'a> {\n         }\n         let lo = self.prev_span;\n \n-        // This is a temporary future proofing.\n-        //\n         // We are considering adding generics to the `where` keyword as an alternative higher-rank\n         // parameter syntax (as in `where<'a>` or `where<T>`. To avoid that being a breaking\n-        // change, for now we refuse to parse `where < (ident | lifetime) (> | , | :)`.\n-        if token::Lt == self.token {\n-            let ident_or_lifetime = self.look_ahead(1, |t| t.is_ident() || t.is_lifetime());\n-            if ident_or_lifetime {\n-                let gt_comma_or_colon = self.look_ahead(2, |t| {\n-                    *t == token::Gt || *t == token::Comma || *t == token::Colon\n-                });\n-                if gt_comma_or_colon {\n-                    self.span_err(self.span, \"syntax `where<T>` is reserved for future use\");\n-                }\n-            }\n+        // change we parse those generics now, but report an error.\n+        if self.choose_generics_over_qpath() {\n+            let generics = self.parse_generics()?;\n+            self.span_err(generics.span,\n+                          \"generic parameters on `where` clauses are reserved for future use\");\n         }\n \n         loop {\n@@ -5348,6 +5340,29 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn choose_generics_over_qpath(&self) -> bool {\n+        // There's an ambiguity between generic parameters and qualified paths in impls.\n+        // If we see `<` it may start both, so we have to inspect some following tokens.\n+        // The following combinations can only start generics,\n+        // but not qualified paths (with one exception):\n+        //     `<` `>` - empty generic parameters\n+        //     `<` `#` - generic parameters with attributes\n+        //     `<` (LIFETIME|IDENT) `>` - single generic parameter\n+        //     `<` (LIFETIME|IDENT) `,` - first generic parameter in a list\n+        //     `<` (LIFETIME|IDENT) `:` - generic parameter with bounds\n+        //     `<` (LIFETIME|IDENT) `=` - generic parameter with a default\n+        // The only truly ambiguous case is\n+        //     `<` IDENT `>` `::` IDENT ...\n+        // we disambiguate it in favor of generics (`impl<T> ::absolute::Path<T> { ... }`)\n+        // because this is what almost always expected in practice, qualified paths in impls\n+        // (`impl <Type>::AssocTy { ... }`) aren't even allowed by type checker at the moment.\n+        self.token == token::Lt &&\n+            (self.look_ahead(1, |t| t == &token::Pound || t == &token::Gt) ||\n+             self.look_ahead(1, |t| t.is_lifetime() || t.is_ident()) &&\n+                self.look_ahead(2, |t| t == &token::Gt || t == &token::Comma ||\n+                                       t == &token::Colon || t == &token::Eq))\n+    }\n+\n     fn parse_impl_body(&mut self) -> PResult<'a, (Vec<ImplItem>, Vec<Attribute>)> {\n         self.expect(&token::OpenDelim(token::Brace))?;\n         let attrs = self.parse_inner_attributes()?;\n@@ -5378,8 +5393,11 @@ impl<'a> Parser<'a> {\n     fn parse_item_impl(&mut self, unsafety: Unsafety, defaultness: Defaultness)\n                        -> PResult<'a, ItemInfo> {\n         // First, parse generic parameters if necessary.\n-        // FIXME: Disambiguate generic parameters and qualified paths (`impl <A as B>::C {}`).\n-        let mut generics = self.parse_generics()?;\n+        let mut generics = if self.choose_generics_over_qpath() {\n+            self.parse_generics()?\n+        } else {\n+            ast::Generics::default()\n+        };\n \n         // Disambiguate `impl !Trait for Type { ... }` and `impl ! { ... }` for the never type.\n         let polarity = if self.check(&token::Not) && self.look_ahead(1, |t| t.can_begin_type()) {"}, {"sha": "480406054adb52d11b2ec3cf75472604b48f384c", "filename": "src/test/compile-fail/private-in-public-ill-formed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60c48dd16ae579e6f2e0ae74862b0420ff471da9/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-ill-formed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c48dd16ae579e6f2e0ae74862b0420ff471da9/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-ill-formed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-ill-formed.rs?ref=60c48dd16ae579e6f2e0ae74862b0420ff471da9", "patch": "@@ -21,7 +21,7 @@ mod aliases_pub {\n         type AssocAlias = m::Pub3;\n     }\n \n-    impl (<Priv as PrivTr>::AssocAlias) { //~ ERROR no base type found for inherent implementation\n+    impl <Priv as PrivTr>::AssocAlias { //~ ERROR no base type found for inherent implementation\n         pub fn f(arg: Priv) {} // private type `aliases_pub::Priv` in public interface\n     }\n }\n@@ -37,7 +37,7 @@ mod aliases_priv {\n         type AssocAlias = Priv3;\n     }\n \n-    impl (<Priv as PrivTr>::AssocAlias) { //~ ERROR no base type found for inherent implementation\n+    impl <Priv as PrivTr>::AssocAlias { //~ ERROR no base type found for inherent implementation\n         pub fn f(arg: Priv) {} // OK\n     }\n }"}, {"sha": "48dd888b2e530d92b93c8716e72b963005724e14", "filename": "src/test/parse-fail/impl-qpath.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/60c48dd16ae579e6f2e0ae74862b0420ff471da9/src%2Ftest%2Fparse-fail%2Fimpl-qpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c48dd16ae579e6f2e0ae74862b0420ff471da9/src%2Ftest%2Fparse-fail%2Fimpl-qpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fimpl-qpath.rs?ref=60c48dd16ae579e6f2e0ae74862b0420ff471da9", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+impl <*const u8>::AssocTy {} // OK\n+impl <Type as Trait>::AssocTy {} // OK\n+impl <'a + Trait>::AssocTy {} // OK\n+impl <<Type>::AssocTy>::AssocTy {} // OK\n+\n+FAIL //~ ERROR"}, {"sha": "2948619ccd07dce770b2837074a565c22b74d557", "filename": "src/test/parse-fail/where_with_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60c48dd16ae579e6f2e0ae74862b0420ff471da9/src%2Ftest%2Fparse-fail%2Fwhere_with_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c48dd16ae579e6f2e0ae74862b0420ff471da9/src%2Ftest%2Fparse-fail%2Fwhere_with_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fwhere_with_bound.rs?ref=60c48dd16ae579e6f2e0ae74862b0420ff471da9", "patch": "@@ -11,6 +11,6 @@\n // compile-flags: -Z parse-only\n \n fn foo<T>() where <T>::Item: ToString, T: Iterator { }\n-               //~^ syntax `where<T>` is reserved for future use\n+//~^ ERROR generic parameters on `where` clauses are reserved for future use\n \n fn main() {}"}]}