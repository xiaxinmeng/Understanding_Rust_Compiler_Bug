{"sha": "2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "node_id": "C_kwDOAAsO6NoAKDJmOGQ4MDQwMTY2YTczMGQwZGE3YmJhMGYyODY0ZjBlZjdmZjYzNjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-19T06:40:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-19T06:40:38Z"}, "message": "Auto merge of #104600 - Dylan-DPC:rollup-glw1e8b, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #104001 (Improve generating Custom entry function)\n - #104411 (nll: correctly deal with bivariance)\n - #104528 (Properly link `{Once,Lazy}{Cell,Lock}` in docs)\n - #104553 (Improve accuracy of asinh and acosh)\n - #104554 (Use `ErrorGuaranteed::unchecked_claim_error_was_emitted` less)\n - #104566 (couple of clippy::perf fixes)\n - #104575 (deduplicate tests)\n - #104580 (diagnostics: only show one suggestion for method -> assoc fn)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b3c1cb60370e9195576083b367a68464deebf57d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3c1cb60370e9195576083b367a68464deebf57d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "html_url": "https://github.com/rust-lang/rust/commit/2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "becc24a23aed2639db3b78acd93ec6d553898583", "url": "https://api.github.com/repos/rust-lang/rust/commits/becc24a23aed2639db3b78acd93ec6d553898583", "html_url": "https://github.com/rust-lang/rust/commit/becc24a23aed2639db3b78acd93ec6d553898583"}, {"sha": "3cf3a65a719e29bc5aac8a3a3be8a21f3162acf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cf3a65a719e29bc5aac8a3a3be8a21f3162acf2", "html_url": "https://github.com/rust-lang/rust/commit/3cf3a65a719e29bc5aac8a3a3be8a21f3162acf2"}], "stats": {"total": 901, "additions": 563, "deletions": 338}, "files": [{"sha": "163170a1d1aa0cfda50cdf3a44854d6ac9a1129f", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -19,7 +19,7 @@ extern crate tracing;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::vec_map::VecMap;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::ChunkedBitSet;\n@@ -192,13 +192,13 @@ fn do_mir_borrowck<'tcx>(\n         }\n     }\n \n-    let mut errors = error::BorrowckErrors::new();\n+    let mut errors = error::BorrowckErrors::new(infcx.tcx);\n \n     // Gather the upvars of a closure, if any.\n     let tables = tcx.typeck_opt_const_arg(def);\n-    if let Some(ErrorGuaranteed { .. }) = tables.tainted_by_errors {\n-        infcx.set_tainted_by_errors();\n-        errors.set_tainted_by_errors();\n+    if let Some(e) = tables.tainted_by_errors {\n+        infcx.set_tainted_by_errors(e);\n+        errors.set_tainted_by_errors(e);\n     }\n     let upvars: Vec<_> = tables\n         .closure_min_captures_flattened(def.did)\n@@ -2260,6 +2260,7 @@ mod error {\n     use super::*;\n \n     pub struct BorrowckErrors<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n         /// This field keeps track of move errors that are to be reported for given move indices.\n         ///\n         /// There are situations where many errors can be reported for a single move out (see #53807)\n@@ -2282,28 +2283,33 @@ mod error {\n         tainted_by_errors: Option<ErrorGuaranteed>,\n     }\n \n-    impl BorrowckErrors<'_> {\n-        pub fn new() -> Self {\n+    impl<'tcx> BorrowckErrors<'tcx> {\n+        pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n             BorrowckErrors {\n+                tcx,\n                 buffered_move_errors: BTreeMap::new(),\n                 buffered: Default::default(),\n                 tainted_by_errors: None,\n             }\n         }\n \n-        // FIXME(eddyb) this is a suboptimal API because `tainted_by_errors` is\n-        // set before any emission actually happens (weakening the guarantee).\n         pub fn buffer_error(&mut self, t: DiagnosticBuilder<'_, ErrorGuaranteed>) {\n-            self.tainted_by_errors = Some(ErrorGuaranteed::unchecked_claim_error_was_emitted());\n+            if let None = self.tainted_by_errors {\n+                self.tainted_by_errors = Some(\n+                    self.tcx\n+                        .sess\n+                        .delay_span_bug(t.span.clone(), \"diagnostic buffered but not emitted\"),\n+                )\n+            }\n             t.buffer(&mut self.buffered);\n         }\n \n         pub fn buffer_non_error_diag(&mut self, t: DiagnosticBuilder<'_, ()>) {\n             t.buffer(&mut self.buffered);\n         }\n \n-        pub fn set_tainted_by_errors(&mut self) {\n-            self.tainted_by_errors = Some(ErrorGuaranteed::unchecked_claim_error_was_emitted());\n+        pub fn set_tainted_by_errors(&mut self, e: ErrorGuaranteed) {\n+            self.tainted_by_errors = Some(e);\n         }\n     }\n "}, {"sha": "4a12e1b1b92e0f22b180dc566f47f9db2bd989b0", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -303,7 +303,10 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n \n     if !nll_errors.is_empty() {\n         // Suppress unhelpful extra errors in `infer_opaque_types`.\n-        infcx.set_tainted_by_errors();\n+        infcx.set_tainted_by_errors(infcx.tcx.sess.delay_span_bug(\n+            body.span,\n+            \"`compute_regions` tainted `infcx` with errors but did not emit any errors\",\n+        ));\n     }\n \n     let remapped_opaque_tys = regioncx.infer_opaque_types(&infcx, opaque_type_values);"}, {"sha": "b9885952a893c55741e6e057f9c703f7adf45353", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -219,8 +219,8 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         instantiated_ty: OpaqueHiddenType<'tcx>,\n         origin: OpaqueTyOrigin,\n     ) -> Ty<'tcx> {\n-        if self.is_tainted_by_errors() {\n-            return self.tcx.ty_error();\n+        if let Some(e) = self.tainted_by_errors() {\n+            return self.tcx.ty_error_with_guaranteed(e);\n         }\n \n         let definition_ty = instantiated_ty"}, {"sha": "1e22537c2ba42ac27202012738cf55ce004042b7", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -22,7 +22,19 @@ fn clif_sig_from_fn_abi<'tcx>(\n     default_call_conv: CallConv,\n     fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n ) -> Signature {\n-    let call_conv = match fn_abi.conv {\n+    let call_conv = conv_to_call_conv(fn_abi.conv, default_call_conv);\n+\n+    let inputs = fn_abi.args.iter().map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter()).flatten();\n+\n+    let (return_ptr, returns) = fn_abi.ret.get_abi_return(tcx);\n+    // Sometimes the first param is an pointer to the place where the return value needs to be stored.\n+    let params: Vec<_> = return_ptr.into_iter().chain(inputs).collect();\n+\n+    Signature { params, returns, call_conv }\n+}\n+\n+pub(crate) fn conv_to_call_conv(c: Conv, default_call_conv: CallConv) -> CallConv {\n+    match c {\n         Conv::Rust | Conv::C => default_call_conv,\n         Conv::RustCold => CallConv::Cold,\n         Conv::X86_64SysV => CallConv::SystemV,\n@@ -38,15 +50,8 @@ fn clif_sig_from_fn_abi<'tcx>(\n         | Conv::X86VectorCall\n         | Conv::AmdGpuKernel\n         | Conv::AvrInterrupt\n-        | Conv::AvrNonBlockingInterrupt => todo!(\"{:?}\", fn_abi.conv),\n-    };\n-    let inputs = fn_abi.args.iter().map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter()).flatten();\n-\n-    let (return_ptr, returns) = fn_abi.ret.get_abi_return(tcx);\n-    // Sometimes the first param is an pointer to the place where the return value needs to be stored.\n-    let params: Vec<_> = return_ptr.into_iter().chain(inputs).collect();\n-\n-    Signature { params, returns, call_conv }\n+        | Conv::AvrNonBlockingInterrupt => todo!(\"{:?}\", c),\n+    }\n }\n \n pub(crate) fn get_function_sig<'tcx>("}, {"sha": "f7434633ea442b40fa30f4a85370135e8c134017", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -63,10 +63,14 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 AbiParam::new(m.target_config().pointer_type()),\n             ],\n             returns: vec![AbiParam::new(m.target_config().pointer_type() /*isize*/)],\n-            call_conv: CallConv::triple_default(m.isa().triple()),\n+            call_conv: crate::conv_to_call_conv(\n+                tcx.sess.target.options.entry_abi,\n+                CallConv::triple_default(m.isa().triple()),\n+            ),\n         };\n \n-        let cmain_func_id = m.declare_function(\"main\", Linkage::Export, &cmain_sig).unwrap();\n+        let entry_name = tcx.sess.target.options.entry_name.as_ref();\n+        let cmain_func_id = m.declare_function(entry_name, Linkage::Export, &cmain_sig).unwrap();\n \n         let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n "}, {"sha": "2e71c3665daa75ed3e1b096c0ca1bac99e74584c", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -425,8 +425,9 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function> {\n-        if self.get_declared_value(\"main\").is_none() {\n-            Some(self.declare_cfn(\"main\", fn_type))\n+        let entry_name = self.sess().target.entry_name.as_ref();\n+        if self.get_declared_value(entry_name).is_none() {\n+            Some(self.declare_entry_fn(entry_name, fn_type, ()))\n         }\n         else {\n             // If the symbol already exists, it is an error: for example, the user wrote"}, {"sha": "eae77508c973abe0c0f50ab70a5e1935bcba246f", "filename": "compiler/rustc_codegen_gcc/src/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -65,13 +65,13 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         global\n     }\n \n-    pub fn declare_cfn(&self, name: &str, _fn_type: Type<'gcc>) -> RValue<'gcc> {\n+    pub fn declare_entry_fn(&self, name: &str, _fn_type: Type<'gcc>, callconv: () /*llvm::CCallConv*/) -> RValue<'gcc> {\n         // TODO(antoyo): use the fn_type parameter.\n         let const_string = self.context.new_type::<u8>().make_pointer().make_pointer();\n         let return_type = self.type_i32();\n         let variadic = false;\n         self.linkage.set(FunctionType::Exported);\n-        let func = declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, &[self.type_i32(), const_string], variadic);\n+        let func = declare_raw_fn(self, name, callconv, return_type, &[self.type_i32(), const_string], variadic);\n         // NOTE: it is needed to set the current_func here as well, because get_fn() is not called\n         // for the main function.\n         *self.current_func.borrow_mut() = Some(func);"}, {"sha": "a6fd2a7de6bd04eb544c7d10f78111d8de5938e2", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -398,23 +398,7 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     }\n \n     fn llvm_cconv(&self) -> llvm::CallConv {\n-        match self.conv {\n-            Conv::C | Conv::Rust | Conv::CCmseNonSecureCall => llvm::CCallConv,\n-            Conv::RustCold => llvm::ColdCallConv,\n-            Conv::AmdGpuKernel => llvm::AmdGpuKernel,\n-            Conv::AvrInterrupt => llvm::AvrInterrupt,\n-            Conv::AvrNonBlockingInterrupt => llvm::AvrNonBlockingInterrupt,\n-            Conv::ArmAapcs => llvm::ArmAapcsCallConv,\n-            Conv::Msp430Intr => llvm::Msp430Intr,\n-            Conv::PtxKernel => llvm::PtxKernel,\n-            Conv::X86Fastcall => llvm::X86FastcallCallConv,\n-            Conv::X86Intr => llvm::X86_Intr,\n-            Conv::X86Stdcall => llvm::X86StdcallCallConv,\n-            Conv::X86ThisCall => llvm::X86_ThisCall,\n-            Conv::X86VectorCall => llvm::X86_VectorCall,\n-            Conv::X86_64SysV => llvm::X86_64_SysV,\n-            Conv::X86_64Win64 => llvm::X86_64_Win64,\n-        }\n+        self.conv.into()\n     }\n \n     fn apply_attrs_llfn(&self, cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value) {\n@@ -596,3 +580,25 @@ impl<'tcx> AbiBuilderMethods<'tcx> for Builder<'_, '_, 'tcx> {\n         llvm::get_param(self.llfn(), index as c_uint)\n     }\n }\n+\n+impl From<Conv> for llvm::CallConv {\n+    fn from(conv: Conv) -> Self {\n+        match conv {\n+            Conv::C | Conv::Rust | Conv::CCmseNonSecureCall => llvm::CCallConv,\n+            Conv::RustCold => llvm::ColdCallConv,\n+            Conv::AmdGpuKernel => llvm::AmdGpuKernel,\n+            Conv::AvrInterrupt => llvm::AvrInterrupt,\n+            Conv::AvrNonBlockingInterrupt => llvm::AvrNonBlockingInterrupt,\n+            Conv::ArmAapcs => llvm::ArmAapcsCallConv,\n+            Conv::Msp430Intr => llvm::Msp430Intr,\n+            Conv::PtxKernel => llvm::PtxKernel,\n+            Conv::X86Fastcall => llvm::X86FastcallCallConv,\n+            Conv::X86Intr => llvm::X86_Intr,\n+            Conv::X86Stdcall => llvm::X86StdcallCallConv,\n+            Conv::X86ThisCall => llvm::X86_ThisCall,\n+            Conv::X86VectorCall => llvm::X86_VectorCall,\n+            Conv::X86_64SysV => llvm::X86_64_SysV,\n+            Conv::X86_64Win64 => llvm::X86_64_Win64,\n+        }\n+    }\n+}"}, {"sha": "4dcc7cd54477def2a32ab3ea7e06b9f566b08b0c", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -576,8 +576,14 @@ impl<'ll, 'tcx> MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function> {\n-        if self.get_declared_value(\"main\").is_none() {\n-            Some(self.declare_cfn(\"main\", llvm::UnnamedAddr::Global, fn_type))\n+        let entry_name = self.sess().target.entry_name.as_ref();\n+        if self.get_declared_value(entry_name).is_none() {\n+            Some(self.declare_entry_fn(\n+                entry_name,\n+                self.sess().target.entry_abi.into(),\n+                llvm::UnnamedAddr::Global,\n+                fn_type,\n+            ))\n         } else {\n             // If the symbol already exists, it is an error: for example, the user wrote\n             // #[no_mangle] extern \"C\" fn main(..) {..}"}, {"sha": "dc21a02cec44a144fef0c9704b3a16af5c1868d2", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -90,6 +90,28 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         declare_raw_fn(self, name, llvm::CCallConv, unnamed, visibility, fn_type)\n     }\n \n+    /// Declare an entry Function\n+    ///\n+    /// The ABI of this function can change depending on the target (although for now the same as\n+    /// `declare_cfn`)\n+    ///\n+    /// If there\u2019s a value with the same name already declared, the function will\n+    /// update the declaration and return existing Value instead.\n+    pub fn declare_entry_fn(\n+        &self,\n+        name: &str,\n+        callconv: llvm::CallConv,\n+        unnamed: llvm::UnnamedAddr,\n+        fn_type: &'ll Type,\n+    ) -> &'ll Value {\n+        let visibility = if self.tcx.sess.target.default_hidden_visibility {\n+            llvm::Visibility::Hidden\n+        } else {\n+            llvm::Visibility::Default\n+        };\n+        declare_raw_fn(self, name, callconv, unnamed, visibility, fn_type)\n+    }\n+\n     /// Declare a Rust function.\n     ///\n     /// If there\u2019s a value with the same name already declared, the function will"}, {"sha": "22f534d909ab6ca4ccab579d2003b535be8e8376", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -180,7 +180,8 @@ fn exported_symbols_provider_local<'tcx>(\n         .collect();\n \n     if tcx.entry_fn(()).is_some() {\n-        let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(tcx, \"main\"));\n+        let exported_symbol =\n+            ExportedSymbol::NoDefId(SymbolName::new(tcx, tcx.sess.target.entry_name.as_ref()));\n \n         symbols.push((\n             exported_symbol,"}, {"sha": "f59f34b874c19441de4178bf9bb4443e69242c8d", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -23,7 +23,7 @@ use super::{\n     MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, PointerArithmetic, Provenance,\n     Scalar, StackPopJump,\n };\n-use crate::transform::validate::equal_up_to_regions;\n+use crate::util;\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n@@ -354,8 +354,8 @@ pub(super) fn mir_assign_valid_types<'tcx>(\n     // Type-changing assignments can happen when subtyping is used. While\n     // all normal lifetimes are erased, higher-ranked types with their\n     // late-bound lifetimes are still around and can lead to type\n-    // differences. So we compare ignoring lifetimes.\n-    if equal_up_to_regions(tcx, param_env, src.ty, dest.ty) {\n+    // differences.\n+    if util::is_subtype(tcx, param_env, src.ty, dest.ty) {\n         // Make sure the layout is equal, too -- just to be safe. Miri really\n         // needs layout equality. For performance reason we skip this check when\n         // the types are equal. Equal types *can* have different layouts when"}, {"sha": "860dee589805780addc061110736fa9db4c888af", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 2, "deletions": 57, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -2,7 +2,6 @@\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_index::bit_set::BitSet;\n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::visit::NonUseContext::VarDebugInfo;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n@@ -12,8 +11,7 @@ use rustc_middle::mir::{\n     ProjectionElem, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind, Terminator,\n     TerminatorKind, UnOp, START_BLOCK,\n };\n-use rustc_middle::ty::fold::BottomUpFolder;\n-use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n+use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeVisitable};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n use rustc_mir_dataflow::storage::always_storage_live_locals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n@@ -70,44 +68,6 @@ impl<'tcx> MirPass<'tcx> for Validator {\n     }\n }\n \n-/// Returns whether the two types are equal up to lifetimes.\n-/// All lifetimes, including higher-ranked ones, get ignored for this comparison.\n-/// (This is unlike the `erasing_regions` methods, which keep higher-ranked lifetimes for soundness reasons.)\n-///\n-/// The point of this function is to approximate \"equal up to subtyping\".  However,\n-/// the approximation is incorrect as variance is ignored.\n-pub fn equal_up_to_regions<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ParamEnv<'tcx>,\n-    src: Ty<'tcx>,\n-    dest: Ty<'tcx>,\n-) -> bool {\n-    // Fast path.\n-    if src == dest {\n-        return true;\n-    }\n-\n-    // Normalize lifetimes away on both sides, then compare.\n-    let normalize = |ty: Ty<'tcx>| {\n-        tcx.try_normalize_erasing_regions(param_env, ty).unwrap_or(ty).fold_with(\n-            &mut BottomUpFolder {\n-                tcx,\n-                // FIXME: We erase all late-bound lifetimes, but this is not fully correct.\n-                // If you have a type like `<for<'a> fn(&'a u32) as SomeTrait>::Assoc`,\n-                // this is not necessarily equivalent to `<fn(&'static u32) as SomeTrait>::Assoc`,\n-                // since one may have an `impl SomeTrait for fn(&32)` and\n-                // `impl SomeTrait for fn(&'static u32)` at the same time which\n-                // specify distinct values for Assoc. (See also #56105)\n-                lt_op: |_| tcx.lifetimes.re_erased,\n-                // Leave consts and types unchanged.\n-                ct_op: |ct| ct,\n-                ty_op: |ty| ty,\n-            },\n-        )\n-    };\n-    tcx.infer_ctxt().build().can_eq(param_env, normalize(src), normalize(dest)).is_ok()\n-}\n-\n struct TypeChecker<'a, 'tcx> {\n     when: &'a str,\n     body: &'a Body<'tcx>,\n@@ -183,22 +143,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             return true;\n         }\n \n-        // Normalize projections and things like that.\n-        // Type-changing assignments can happen when subtyping is used. While\n-        // all normal lifetimes are erased, higher-ranked types with their\n-        // late-bound lifetimes are still around and can lead to type\n-        // differences. So we compare ignoring lifetimes.\n-\n-        // First, try with reveal_all. This might not work in some cases, as the predicates\n-        // can be cleared in reveal_all mode. We try the reveal first anyways as it is used\n-        // by some other passes like inlining as well.\n-        let param_env = self.param_env.with_reveal_all_normalized(self.tcx);\n-        if equal_up_to_regions(self.tcx, param_env, src, dest) {\n-            return true;\n-        }\n-\n-        // If this fails, we can try it without the reveal.\n-        equal_up_to_regions(self.tcx, self.param_env, src, dest)\n+        crate::util::is_subtype(self.tcx, self.param_env, src, dest)\n     }\n }\n "}, {"sha": "a9cb191cc593fc0f7d5c116580712a35b930e59f", "filename": "compiler/rustc_const_eval/src/util/compare_types.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -0,0 +1,63 @@\n+//! Routines to check for relations between fully inferred types.\n+//!\n+//! FIXME: Move this to a more general place. The utility of this extends to\n+//! other areas of the compiler as well.\n+\n+use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n+use rustc_trait_selection::traits::ObligationCtxt;\n+\n+/// Returns whether the two types are equal up to subtyping.\n+///\n+/// This is used in case we don't know the expected subtyping direction\n+/// and still want to check whether anything is broken.\n+pub fn is_equal_up_to_subtyping<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    src: Ty<'tcx>,\n+    dest: Ty<'tcx>,\n+) -> bool {\n+    // Fast path.\n+    if src == dest {\n+        return true;\n+    }\n+\n+    // Check for subtyping in either direction.\n+    is_subtype(tcx, param_env, src, dest) || is_subtype(tcx, param_env, dest, src)\n+}\n+\n+/// Returns whether `src` is a subtype of `dest`, i.e. `src <: dest`.\n+///\n+/// This mostly ignores opaque types as it can be used in constraining contexts\n+/// while still computing the final underlying type.\n+pub fn is_subtype<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    src: Ty<'tcx>,\n+    dest: Ty<'tcx>,\n+) -> bool {\n+    if src == dest {\n+        return true;\n+    }\n+\n+    let mut builder =\n+        tcx.infer_ctxt().ignoring_regions().with_opaque_type_inference(DefiningAnchor::Bubble);\n+    let infcx = builder.build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+    let cause = ObligationCause::dummy();\n+    let src = ocx.normalize(cause.clone(), param_env, src);\n+    let dest = ocx.normalize(cause.clone(), param_env, dest);\n+    match ocx.sub(&cause, param_env, src, dest) {\n+        Ok(()) => {}\n+        Err(_) => return false,\n+    };\n+    let errors = ocx.select_all_or_error();\n+    // With `Reveal::All`, opaque types get normalized away, with `Reveal::UserFacing`\n+    // we would get unification errors because we're unable to look into opaque types,\n+    // even if they're constrained in our current function.\n+    //\n+    // It seems very unlikely that this hides any bugs.\n+    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+    errors.is_empty()\n+}"}, {"sha": "76ea5a24e69edd8c1bd09cab7ece7e05eb345302", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -2,13 +2,15 @@ pub mod aggregate;\n mod alignment;\n mod call_kind;\n pub mod collect_writes;\n+mod compare_types;\n mod find_self_call;\n mod might_permit_raw_init;\n mod type_name;\n \n pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n pub use self::call_kind::{call_kind, CallDesugaringKind, CallKind};\n+pub use self::compare_types::{is_equal_up_to_subtyping, is_subtype};\n pub use self::find_self_call::find_self_call;\n pub use self::might_permit_raw_init::might_permit_raw_init;\n pub use self::type_name::type_name;"}, {"sha": "04fe6c4007e948fd106f14fb95947ae1003e3090", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -1436,7 +1436,7 @@ fn pretty_printing_compatibility_hack(item: &Item, sess: &ParseSess) -> bool {\n                             let crate_matches = if c.starts_with(\"allsorts-rental\") {\n                                 true\n                             } else {\n-                                let mut version = c.trim_start_matches(\"rental-\").split(\".\");\n+                                let mut version = c.trim_start_matches(\"rental-\").split('.');\n                                 version.next() == Some(\"0\")\n                                     && version.next() == Some(\"5\")\n                                     && version"}, {"sha": "83b95fe0e911ec055f08c426b50d498a2f583a66", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -115,7 +115,7 @@ pub trait AstConv<'tcx> {\n     /// (e.g., resolve) that is translated into a ty-error. This is\n     /// used to help suppress derived errors typeck might otherwise\n     /// report.\n-    fn set_tainted_by_errors(&self);\n+    fn set_tainted_by_errors(&self, e: ErrorGuaranteed);\n \n     fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span);\n }\n@@ -2620,8 +2620,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 }\n             }\n             Res::Err => {\n-                self.set_tainted_by_errors();\n-                self.tcx().ty_error()\n+                let e = self\n+                    .tcx()\n+                    .sess\n+                    .delay_span_bug(path.span, \"path with `Res:Err` but no error emitted\");\n+                self.set_tainted_by_errors(e);\n+                self.tcx().ty_error_with_guaranteed(e)\n             }\n             _ => span_bug!(span, \"unexpected resolution: {:?}\", path.res),\n         }"}, {"sha": "b4805de961889a2fcb8c1da77ee829a219b8e32f", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -449,8 +449,8 @@ fn check_opaque_meets_bounds<'tcx>(\n \n     let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n-    match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_ty) {\n-        Ok(infer_ok) => ocx.register_infer_ok_obligations(infer_ok),\n+    match ocx.eq(&misc_cause, param_env, opaque_ty, hidden_ty) {\n+        Ok(()) => {}\n         Err(ty_err) => {\n             tcx.sess.delay_span_bug(\n                 span,"}, {"sha": "0b9209771cd3232cddb01cc44ba5b36e08efa120", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -402,10 +402,8 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n         unnormalized_trait_sig.inputs_and_output.iter().chain(trait_sig.inputs_and_output.iter()),\n     );\n \n-    match infcx.at(&cause, param_env).eq(trait_return_ty, impl_return_ty) {\n-        Ok(infer::InferOk { value: (), obligations }) => {\n-            ocx.register_obligations(obligations);\n-        }\n+    match ocx.eq(&cause, param_env, trait_return_ty, impl_return_ty) {\n+        Ok(()) => {}\n         Err(terr) => {\n             let mut diag = struct_span_err!(\n                 tcx.sess,\n@@ -442,10 +440,8 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     // the lifetimes of the return type, but do this after unifying just the\n     // return types, since we want to avoid duplicating errors from\n     // `compare_predicate_entailment`.\n-    match infcx.at(&cause, param_env).eq(trait_fty, impl_fty) {\n-        Ok(infer::InferOk { value: (), obligations }) => {\n-            ocx.register_obligations(obligations);\n-        }\n+    match ocx.eq(&cause, param_env, trait_fty, impl_fty) {\n+        Ok(()) => {}\n         Err(terr) => {\n             // This function gets called during `compare_predicate_entailment` when normalizing a\n             // signature that contains RPITIT. When the method signatures don't match, we have to"}, {"sha": "a738ee4a14887ae60c0d41d7e2ff8d98aa429750", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -518,7 +518,7 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n         ty\n     }\n \n-    fn set_tainted_by_errors(&self) {\n+    fn set_tainted_by_errors(&self, _: ErrorGuaranteed) {\n         // There's no obvious place to track this, so just let it go.\n     }\n "}, {"sha": "af0b7f62ae3195f6ce058bde7b0cf97be631efc1", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -1561,7 +1561,9 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 // Mark that we've failed to coerce the types here to suppress\n                 // any superfluous errors we might encounter while trying to\n                 // emit or provide suggestions on how to fix the initial error.\n-                fcx.set_tainted_by_errors();\n+                fcx.set_tainted_by_errors(\n+                    fcx.tcx.sess.delay_span_bug(cause.span, \"coercion error but no error emitted\"),\n+                );\n                 let (expected, found) = if label_expression_as_expected {\n                     // In the case where this is a \"forced unit\", like\n                     // `break`, we want to call the `()` \"expected\""}, {"sha": "5a34ab401749f74491f92a45ec04a1b0786e5434", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -154,7 +154,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(e) => e,\n         };\n \n-        self.set_tainted_by_errors();\n+        self.set_tainted_by_errors(self.tcx.sess.delay_span_bug(\n+            expr.span,\n+            \"`TypeError` when attempting coercion but no error emitted\",\n+        ));\n         let expr = expr.peel_drop_temps();\n         let cause = self.misc(expr.span);\n         let expr_ty = self.resolve_vars_with_obligations(checked_ty);"}, {"sha": "752d2e0ff78589046f2c327c51b5bfd0288e60a4", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -527,12 +527,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.resolve_ty_and_res_fully_qualified_call(qpath, expr.hir_id, expr.span);\n         let ty = match res {\n             Res::Err => {\n-                self.set_tainted_by_errors();\n-                tcx.ty_error()\n+                let e =\n+                    self.tcx.sess.delay_span_bug(qpath.span(), \"`Res::Err` but no error emitted\");\n+                self.set_tainted_by_errors(e);\n+                tcx.ty_error_with_guaranteed(e)\n             }\n             Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n-                report_unexpected_variant_res(tcx, res, qpath, expr.span);\n-                tcx.ty_error()\n+                let e = report_unexpected_variant_res(tcx, res, qpath, expr.span);\n+                tcx.ty_error_with_guaranteed(e)\n             }\n             _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, expr.hir_id).0,\n         };\n@@ -1962,7 +1964,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr_span: Span,\n     ) {\n         if variant.is_recovered() {\n-            self.set_tainted_by_errors();\n+            self.set_tainted_by_errors(\n+                self.tcx\n+                    .sess\n+                    .delay_span_bug(expr_span, \"parser recovered but no error was emitted\"),\n+            );\n             return;\n         }\n         let mut err = self.err_ctxt().type_error_struct_with_diag("}, {"sha": "ac6b0924ab572498a4cc36f9fe8187f1b93b38ed", "filename": "compiler/rustc_hir_typeck/src/fallback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -104,7 +104,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // type, `?T` is not considered unsolved, but `?I` is. The\n         // same is true for float variables.)\n         let fallback = match ty.kind() {\n-            _ if self.is_tainted_by_errors() => self.tcx.ty_error(),\n+            _ if let Some(e) = self.tainted_by_errors() => self.tcx.ty_error_with_guaranteed(e),\n             ty::Infer(ty::IntVar(_)) => self.tcx.types.i32,\n             ty::Infer(ty::FloatVar(_)) => self.tcx.types.f64,\n             _ => match diverging_fallback.get(&ty) {"}, {"sha": "b85a23257286b6ddfad19fffb788d93e567a8001", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -140,8 +140,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"write_ty({:?}, {:?}) in fcx {}\", id, self.resolve_vars_if_possible(ty), self.tag());\n         self.typeck_results.borrow_mut().node_types_mut().insert(id, ty);\n \n-        if ty.references_error() {\n-            self.set_tainted_by_errors();\n+        if let Err(e) = ty.error_reported() {\n+            self.set_tainted_by_errors(e);\n         }\n     }\n \n@@ -528,7 +528,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n         match self.typeck_results.borrow().node_types().get(id) {\n             Some(&t) => t,\n-            None if self.is_tainted_by_errors() => self.tcx.ty_error(),\n+            None if let Some(e) = self.tainted_by_errors() => self.tcx.ty_error_with_guaranteed(e),\n             None => {\n                 bug!(\n                     \"no type for node {}: {} in fcx {}\",\n@@ -543,7 +543,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn node_ty_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n         match self.typeck_results.borrow().node_types().get(id) {\n             Some(&t) => Some(t),\n-            None if self.is_tainted_by_errors() => Some(self.tcx.ty_error()),\n+            None if let Some(e) = self.tainted_by_errors() => Some(self.tcx.ty_error_with_guaranteed(e)),\n             None => None,\n         }\n     }\n@@ -1148,9 +1148,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 explicit_late_bound = ExplicitLateBound::Yes;\n             }\n \n-            if let Err(GenericArgCountMismatch { reported: Some(_), .. }) = arg_count.correct {\n+            if let Err(GenericArgCountMismatch { reported: Some(e), .. }) = arg_count.correct {\n                 infer_args_for_err.insert(index);\n-                self.set_tainted_by_errors(); // See issue #53251.\n+                self.set_tainted_by_errors(e); // See issue #53251.\n             }\n         }\n \n@@ -1440,12 +1440,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if !ty.is_ty_var() {\n             ty\n         } else {\n-            if !self.is_tainted_by_errors() {\n+            let e = self.tainted_by_errors().unwrap_or_else(|| {\n                 self.err_ctxt()\n                     .emit_inference_failure_err((**self).body_id, sp, ty.into(), E0282, true)\n-                    .emit();\n-            }\n-            let err = self.tcx.ty_error();\n+                    .emit()\n+            });\n+            let err = self.tcx.ty_error_with_guaranteed(e);\n             self.demand_suptype(sp, err, ty);\n             err\n         }"}, {"sha": "a31ab9c8b23b899c00dcad27aad6b7f8816e9a54", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -511,8 +511,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             tys.into_iter().any(|ty| ty.references_error() || ty.is_ty_var())\n         }\n \n-        self.set_tainted_by_errors();\n         let tcx = self.tcx;\n+        // FIXME: taint after emitting errors and pass through an `ErrorGuaranteed`\n+        self.set_tainted_by_errors(\n+            tcx.sess.delay_span_bug(call_span, \"no errors reported for args\"),\n+        );\n \n         // Get the argument span in the context of the call span so that\n         // suggestions and labels are (more) correct when an arg is a\n@@ -1207,7 +1210,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, hir_id);\n         let variant = match def {\n             Res::Err => {\n-                self.set_tainted_by_errors();\n+                self.set_tainted_by_errors(\n+                    self.tcx.sess.delay_span_bug(path_span, \"`Res::Err` but no error emitted\"),\n+                );\n                 return None;\n             }\n             Res::Def(DefKind::Variant, _) => match ty.kind() {"}, {"sha": "177d521d2804cd1e1ff08f4e769229b64fd28f4a", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -4,6 +4,7 @@ mod checks;\n mod suggestions;\n \n pub use _impl::*;\n+use rustc_errors::ErrorGuaranteed;\n pub use suggestions::*;\n \n use crate::coercion::DynamicCoerceMany;\n@@ -289,8 +290,8 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn set_tainted_by_errors(&self) {\n-        self.infcx.set_tainted_by_errors()\n+    fn set_tainted_by_errors(&self, e: ErrorGuaranteed) {\n+        self.infcx.set_tainted_by_errors(e)\n     }\n \n     fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, _span: Span) {"}, {"sha": "334d6d0aa6c209838c6a042895e8d94eab3e7742", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -53,7 +53,7 @@ use crate::check::check_fn;\n use crate::coercion::DynamicCoerceMany;\n use crate::gather_locals::GatherLocalsVisitor;\n use rustc_data_structures::unord::UnordSet;\n-use rustc_errors::{struct_span_err, MultiSpan};\n+use rustc_errors::{struct_span_err, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::intravisit::Visitor;\n@@ -344,7 +344,7 @@ fn typeck_with_fallback<'tcx>(\n \n         fcx.select_all_obligations_or_error();\n \n-        if !fcx.infcx.is_tainted_by_errors() {\n+        if let None = fcx.infcx.tainted_by_errors() {\n             fcx.check_transmutes();\n         }\n \n@@ -428,7 +428,12 @@ impl<'tcx> EnclosingBreakables<'tcx> {\n     }\n }\n \n-fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, qpath: &hir::QPath<'_>, span: Span) {\n+fn report_unexpected_variant_res(\n+    tcx: TyCtxt<'_>,\n+    res: Res,\n+    qpath: &hir::QPath<'_>,\n+    span: Span,\n+) -> ErrorGuaranteed {\n     struct_span_err!(\n         tcx.sess,\n         span,\n@@ -437,7 +442,7 @@ fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, qpath: &hir::QPath<'\n         res.descr(),\n         rustc_hir_pretty::qpath_to_string(qpath),\n     )\n-    .emit();\n+    .emit()\n }\n \n /// Controls whether the arguments are tupled. This is used for the call"}, {"sha": "0b5dc946c1deffa589f20f036542cfacc7edd6a8", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     }\n \n     fn is_tainted_by_errors(&self) -> bool {\n-        self.infcx.is_tainted_by_errors()\n+        self.infcx.tainted_by_errors().is_some()\n     }\n \n     fn resolve_type_vars_or_error("}, {"sha": "4ac4914bd447954bc9776401f2c42e387ca5674d", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let report_candidates = |span: Span,\n                                  err: &mut Diagnostic,\n                                  sources: &mut Vec<CandidateSource>,\n-                                 sugg_span: Span| {\n+                                 sugg_span: Option<Span>| {\n             sources.sort();\n             sources.dedup();\n             // Dynamic limit to avoid hiding just one candidate, which is silly.\n@@ -175,7 +175,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         } else {\n                             err.note(&note_str);\n                         }\n-                        if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n+                        if let Some(sugg_span) = sugg_span\n+                            && let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n                             let path = self.tcx.def_path_str(trait_ref.def_id);\n \n                             let ty = match item.kind {\n@@ -224,20 +225,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             err.span_note(item_span, msg);\n                             None\n                         };\n-                        let path = self.tcx.def_path_str(trait_did);\n-                        print_disambiguation_help(\n-                            item_name,\n-                            args,\n-                            err,\n-                            path,\n-                            rcvr_ty,\n-                            item.kind,\n-                            item.def_id,\n-                            sugg_span,\n-                            idx,\n-                            self.tcx.sess.source_map(),\n-                            item.fn_has_self_parameter,\n-                        );\n+                        if let Some(sugg_span) = sugg_span {\n+                            let path = self.tcx.def_path_str(trait_did);\n+                            print_disambiguation_help(\n+                                item_name,\n+                                args,\n+                                err,\n+                                path,\n+                                rcvr_ty,\n+                                item.kind,\n+                                item.def_id,\n+                                sugg_span,\n+                                idx,\n+                                self.tcx.sess.source_map(),\n+                                item.fn_has_self_parameter,\n+                            );\n+                        }\n                     }\n                 }\n             }\n@@ -407,9 +410,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         sugg_span,\n                     );\n \n-                    report_candidates(span, &mut err, &mut static_candidates, sugg_span);\n+                    report_candidates(span, &mut err, &mut static_candidates, None);\n                 } else if static_candidates.len() > 1 {\n-                    report_candidates(span, &mut err, &mut static_candidates, sugg_span);\n+                    report_candidates(span, &mut err, &mut static_candidates, Some(sugg_span));\n                 }\n \n                 let mut bound_spans = vec![];\n@@ -1015,7 +1018,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n                 err.span_label(item_name.span, format!(\"multiple `{}` found\", item_name));\n \n-                report_candidates(span, &mut err, &mut sources, sugg_span);\n+                report_candidates(span, &mut err, &mut sources, Some(sugg_span));\n                 err.emit();\n             }\n "}, {"sha": "a62d43561302bf43d3126b502367f7d21c4c455e", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -839,12 +839,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let (res, opt_ty, segments) = path_resolution;\n         match res {\n             Res::Err => {\n-                self.set_tainted_by_errors();\n-                return tcx.ty_error();\n+                let e = tcx.sess.delay_span_bug(qpath.span(), \"`Res::Err` but no error emitted\");\n+                self.set_tainted_by_errors(e);\n+                return tcx.ty_error_with_guaranteed(e);\n             }\n             Res::Def(DefKind::AssocFn | DefKind::Ctor(_, CtorKind::Fictive | CtorKind::Fn), _) => {\n-                report_unexpected_variant_res(tcx, res, qpath, pat.span);\n-                return tcx.ty_error();\n+                let e = report_unexpected_variant_res(tcx, res, qpath, pat.span);\n+                return tcx.ty_error_with_guaranteed(e);\n             }\n             Res::SelfCtor(..)\n             | Res::Def(\n@@ -985,9 +986,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n-        let on_error = || {\n+        let on_error = |e| {\n             for pat in subpats {\n-                self.check_pat(pat, tcx.ty_error(), def_bm, ti);\n+                self.check_pat(pat, tcx.ty_error_with_guaranteed(e), def_bm, ti);\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n@@ -1014,36 +1015,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.span_label(pat.span, \"not a tuple variant or struct\");\n                 }\n             }\n-            err.emit();\n-            on_error();\n+            let e = err.emit();\n+            on_error(e);\n+            e\n         };\n \n         // Resolve the path and check the definition for errors.\n         let (res, opt_ty, segments) =\n             self.resolve_ty_and_res_fully_qualified_call(qpath, pat.hir_id, pat.span);\n         if res == Res::Err {\n-            self.set_tainted_by_errors();\n-            on_error();\n-            return self.tcx.ty_error();\n+            let e = tcx.sess.delay_span_bug(pat.span, \"`Res:Err` but no error emitted\");\n+            self.set_tainted_by_errors(e);\n+            on_error(e);\n+            return tcx.ty_error_with_guaranteed(e);\n         }\n \n         // Type-check the path.\n         let (pat_ty, res) =\n             self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id);\n         if !pat_ty.is_fn() {\n-            report_unexpected_res(res);\n-            return tcx.ty_error();\n+            let e = report_unexpected_res(res);\n+            return tcx.ty_error_with_guaranteed(e);\n         }\n \n         let variant = match res {\n             Res::Err => {\n-                self.set_tainted_by_errors();\n-                on_error();\n-                return tcx.ty_error();\n+                let e = tcx.sess.delay_span_bug(pat.span, \"`Res::Err` but no error emitted\");\n+                self.set_tainted_by_errors(e);\n+                on_error(e);\n+                return tcx.ty_error_with_guaranteed(e);\n             }\n             Res::Def(DefKind::AssocConst | DefKind::AssocFn, _) => {\n-                report_unexpected_res(res);\n-                return tcx.ty_error();\n+                let e = report_unexpected_res(res);\n+                return tcx.ty_error_with_guaranteed(e);\n             }\n             Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => tcx.expect_variant_res(res),\n             _ => bug!(\"unexpected pattern resolution: {:?}\", res),\n@@ -1082,9 +1086,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         } else {\n             // Pattern has wrong number of fields.\n-            self.e0023(pat.span, res, qpath, subpats, &variant.fields, expected, had_err);\n-            on_error();\n-            return tcx.ty_error();\n+            let e = self.e0023(pat.span, res, qpath, subpats, &variant.fields, expected, had_err);\n+            on_error(e);\n+            return tcx.ty_error_with_guaranteed(e);\n         }\n         pat_ty\n     }\n@@ -1098,7 +1102,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fields: &'tcx [ty::FieldDef],\n         expected: Ty<'tcx>,\n         had_err: bool,\n-    ) {\n+    ) -> ErrorGuaranteed {\n         let subpats_ending = pluralize!(subpats.len());\n         let fields_ending = pluralize!(fields.len());\n \n@@ -1245,7 +1249,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        err.emit();\n+        err.emit()\n     }\n \n     fn check_pat_tuple("}, {"sha": "6c2ee35fa50da5b1daef213e9941db8fc3510113", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -83,10 +83,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.typeck_results.treat_byte_string_as_slice =\n             mem::take(&mut self.typeck_results.borrow_mut().treat_byte_string_as_slice);\n \n-        if self.is_tainted_by_errors() {\n-            // FIXME(eddyb) keep track of `ErrorGuaranteed` from where the error was emitted.\n-            wbcx.typeck_results.tainted_by_errors =\n-                Some(ErrorGuaranteed::unchecked_claim_error_was_emitted());\n+        if let Some(e) = self.tainted_by_errors() {\n+            wbcx.typeck_results.tainted_by_errors = Some(e);\n         }\n \n         debug!(\"writeback: typeck results for {:?} are {:#?}\", item_def_id, wbcx.typeck_results);\n@@ -674,10 +672,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         // We may have introduced e.g. `ty::Error`, if inference failed, make sure\n         // to mark the `TypeckResults` as tainted in that case, so that downstream\n         // users of the typeck results don't produce extra errors, or worse, ICEs.\n-        if resolver.replaced_with_error {\n-            // FIXME(eddyb) keep track of `ErrorGuaranteed` from where the error was emitted.\n-            self.typeck_results.tainted_by_errors =\n-                Some(ErrorGuaranteed::unchecked_claim_error_was_emitted());\n+        if let Some(e) = resolver.replaced_with_error {\n+            self.typeck_results.tainted_by_errors = Some(e);\n         }\n \n         x\n@@ -708,8 +704,8 @@ struct Resolver<'cx, 'tcx> {\n     span: &'cx dyn Locatable,\n     body: &'tcx hir::Body<'tcx>,\n \n-    /// Set to `true` if any `Ty` or `ty::Const` had to be replaced with an `Error`.\n-    replaced_with_error: bool,\n+    /// Set to `Some` if any `Ty` or `ty::Const` had to be replaced with an `Error`.\n+    replaced_with_error: Option<ErrorGuaranteed>,\n }\n \n impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n@@ -718,12 +714,14 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n         span: &'cx dyn Locatable,\n         body: &'tcx hir::Body<'tcx>,\n     ) -> Resolver<'cx, 'tcx> {\n-        Resolver { tcx: fcx.tcx, infcx: fcx, span, body, replaced_with_error: false }\n+        Resolver { tcx: fcx.tcx, infcx: fcx, span, body, replaced_with_error: None }\n     }\n \n-    fn report_error(&self, p: impl Into<ty::GenericArg<'tcx>>) {\n-        if !self.tcx.sess.has_errors().is_some() {\n-            self.infcx\n+    fn report_error(&self, p: impl Into<ty::GenericArg<'tcx>>) -> ErrorGuaranteed {\n+        match self.tcx.sess.has_errors() {\n+            Some(e) => e,\n+            None => self\n+                .infcx\n                 .err_ctxt()\n                 .emit_inference_failure_err(\n                     Some(self.body.id()),\n@@ -732,7 +730,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                     E0282,\n                     false,\n                 )\n-                .emit();\n+                .emit(),\n         }\n     }\n }\n@@ -773,9 +771,9 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n             }\n             Err(_) => {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n-                self.report_error(t);\n-                self.replaced_with_error = true;\n-                self.tcx().ty_error()\n+                let e = self.report_error(t);\n+                self.replaced_with_error = Some(e);\n+                self.tcx().ty_error_with_guaranteed(e)\n             }\n         }\n     }\n@@ -790,9 +788,9 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n             Ok(ct) => self.tcx.erase_regions(ct),\n             Err(_) => {\n                 debug!(\"Resolver::fold_const: input const `{:?}` not fully resolvable\", ct);\n-                self.report_error(ct);\n-                self.replaced_with_error = true;\n-                self.tcx().const_error(ct.ty())\n+                let e = self.report_error(ct);\n+                self.replaced_with_error = Some(e);\n+                self.tcx().const_error_with_guaranteed(ct.ty(), e)\n             }\n         }\n     }"}, {"sha": "b9ed6b28c220d1f47172421bedf05f593f661dd9", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -34,7 +34,7 @@ pub use rustc_middle::ty::IntVarValue;\n use rustc_middle::ty::{self, GenericParamDefKind, InferConst, Ty, TyCtxt};\n use rustc_middle::ty::{ConstVid, FloatVid, IntVid, TyVid};\n use rustc_span::symbol::Symbol;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n \n use std::cell::{Cell, RefCell};\n use std::fmt;\n@@ -1208,7 +1208,8 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// reporting errors that often occur as a result of earlier\n     /// errors, but where it's hard to be 100% sure (e.g., unresolved\n     /// inference variables, regionck errors).\n-    pub fn is_tainted_by_errors(&self) -> bool {\n+    #[must_use = \"this method does not have any side effects\"]\n+    pub fn tainted_by_errors(&self) -> Option<ErrorGuaranteed> {\n         debug!(\n             \"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n              tainted_by_errors={})\",\n@@ -1217,19 +1218,25 @@ impl<'tcx> InferCtxt<'tcx> {\n             self.tainted_by_errors.get().is_some()\n         );\n \n+        if let Some(e) = self.tainted_by_errors.get() {\n+            return Some(e);\n+        }\n+\n         if self.tcx.sess.err_count() > self.err_count_on_creation {\n-            return true; // errors reported since this infcx was made\n+            // errors reported since this infcx was made\n+            let e = self.tcx.sess.has_errors().unwrap();\n+            self.set_tainted_by_errors(e);\n+            return Some(e);\n         }\n-        self.tainted_by_errors.get().is_some()\n+\n+        None\n     }\n \n     /// Set the \"tainted by errors\" flag to true. We call this when we\n     /// observe an error from a prior pass.\n-    pub fn set_tainted_by_errors(&self) {\n-        debug!(\"set_tainted_by_errors()\");\n-        self.tainted_by_errors.set(Some(\n-            self.tcx.sess.delay_span_bug(DUMMY_SP, \"`InferCtxt` incorrectly tainted by errors\"),\n-        ));\n+    pub fn set_tainted_by_errors(&self, e: ErrorGuaranteed) {\n+        debug!(\"set_tainted_by_errors(ErrorGuaranteed)\");\n+        self.tainted_by_errors.set(Some(e));\n     }\n \n     pub fn skip_region_resolution(&self) {\n@@ -1270,7 +1277,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             let mut inner = self.inner.borrow_mut();\n             let inner = &mut *inner;\n             assert!(\n-                self.is_tainted_by_errors() || inner.region_obligations.is_empty(),\n+                self.tainted_by_errors().is_some() || inner.region_obligations.is_empty(),\n                 \"region_obligations not empty: {:#?}\",\n                 inner.region_obligations\n             );\n@@ -1707,7 +1714,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     ) {\n         let errors = self.resolve_regions(outlives_env);\n \n-        if !self.is_tainted_by_errors() {\n+        if let None = self.tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors\n             // altogether if other errors have been reported while\n             // this infcx was in use.  This is totally hokey but"}, {"sha": "167a82d4499a188603895a21b2bfe9349d628341", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -556,8 +556,9 @@ where\n         self.ambient_variance_info = self.ambient_variance_info.xform(info);\n \n         debug!(?self.ambient_variance);\n-\n-        let r = self.relate(a, b)?;\n+        // In a bivariant context this always succeeds.\n+        let r =\n+            if self.ambient_variance == ty::Variance::Bivariant { a } else { self.relate(a, b)? };\n \n         self.ambient_variance = old_ambient_variance;\n "}, {"sha": "bd3c5780b891bb28efae312459722b10febf7e43", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -116,9 +116,9 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n                 Ok(a)\n             }\n \n-            (&ty::Error(_), _) | (_, &ty::Error(_)) => {\n-                infcx.set_tainted_by_errors();\n-                Ok(self.tcx().ty_error())\n+            (&ty::Error(e), _) | (_, &ty::Error(e)) => {\n+                infcx.set_tainted_by_errors(e);\n+                Ok(self.tcx().ty_error_with_guaranteed(e))\n             }\n \n             (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {"}, {"sha": "cdf279313a6726e0985cdd0d51c45d11576c7618", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -582,15 +582,15 @@ trait UnusedDelimLint {\n                 let sm = cx.sess().source_map();\n                 let lo_replace =\n                     if keep_space.0 &&\n-                        let Ok(snip) = sm.span_to_prev_source(lo) && !snip.ends_with(\" \") {\n+                        let Ok(snip) = sm.span_to_prev_source(lo) && !snip.ends_with(' ') {\n                         \" \".to_string()\n                         } else {\n                             \"\".to_string()\n                         };\n \n                 let hi_replace =\n                     if keep_space.1 &&\n-                        let Ok(snip) = sm.span_to_next_source(hi) && !snip.starts_with(\" \") {\n+                        let Ok(snip) = sm.span_to_next_source(hi) && !snip.starts_with(' ') {\n                         \" \".to_string()\n                         } else {\n                             \"\".to_string()"}, {"sha": "dff088b9bdfa66140867a8cc88f7e400a6c29961", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -830,5 +830,5 @@ pub(super) fn should_generate_set_arg(field: &Field) -> bool {\n }\n \n pub(super) fn is_doc_comment(attr: &Attribute) -> bool {\n-    attr.path.segments.last().unwrap().ident.to_string() == \"doc\"\n+    attr.path.segments.last().unwrap().ident == \"doc\"\n }"}, {"sha": "93d6850560d7cbeb996261db2b5e19ffb7c427b7", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -2194,11 +2194,9 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n \n         define_scoped_cx!(self);\n \n-        let possible_names =\n-            ('a'..='z').rev().map(|s| Symbol::intern(&format!(\"'{s}\"))).collect::<Vec<_>>();\n+        let possible_names = ('a'..='z').rev().map(|s| Symbol::intern(&format!(\"'{s}\")));\n \n         let mut available_names = possible_names\n-            .into_iter()\n             .filter(|name| !self.used_region_names.contains(&name))\n             .collect::<Vec<_>>();\n         debug!(?available_names);"}, {"sha": "cc69a1bb02db19cac318ec2c149bd18d7dcfc9bf", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -899,7 +899,7 @@ fn debug_with_context_rec<V: Debug + Eq>(\n         let info_elem = map.places[child].proj_elem.unwrap();\n         let child_place_str = match info_elem {\n             TrackElem::Field(field) => {\n-                if place_str.starts_with(\"*\") {\n+                if place_str.starts_with('*') {\n                     format!(\"({}).{}\", place_str, field.index())\n                 } else {\n                     format!(\"{}.{}\", place_str, field.index())"}, {"sha": "d7dd5fc8528454ca76c0a78ce2f1decdbedb437f", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -1,7 +1,6 @@\n //! Inlining pass for MIR functions\n use crate::deref_separator::deref_finder;\n use rustc_attr::InlineAttr;\n-use rustc_const_eval::transform::validate::equal_up_to_regions;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n@@ -14,7 +13,8 @@ use rustc_span::{hygiene::ExpnKind, ExpnData, LocalExpnId, Span};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n \n-use super::simplify::{remove_dead_blocks, CfgSimplifier};\n+use crate::simplify::{remove_dead_blocks, CfgSimplifier};\n+use crate::util;\n use crate::MirPass;\n use std::iter;\n use std::ops::{Range, RangeFrom};\n@@ -180,7 +180,7 @@ impl<'tcx> Inliner<'tcx> {\n         let TerminatorKind::Call { args, destination, .. } = &terminator.kind else { bug!() };\n         let destination_ty = destination.ty(&caller_body.local_decls, self.tcx).ty;\n         let output_type = callee_body.return_ty();\n-        if !equal_up_to_regions(self.tcx, self.param_env, output_type, destination_ty) {\n+        if !util::is_subtype(self.tcx, self.param_env, output_type, destination_ty) {\n             trace!(?output_type, ?destination_ty);\n             return Err(\"failed to normalize return type\");\n         }\n@@ -200,7 +200,7 @@ impl<'tcx> Inliner<'tcx> {\n                 arg_tuple_tys.iter().zip(callee_body.args_iter().skip(skipped_args))\n             {\n                 let input_type = callee_body.local_decls[input].ty;\n-                if !equal_up_to_regions(self.tcx, self.param_env, arg_ty, input_type) {\n+                if !util::is_subtype(self.tcx, self.param_env, input_type, arg_ty) {\n                     trace!(?arg_ty, ?input_type);\n                     return Err(\"failed to normalize tuple argument type\");\n                 }\n@@ -209,7 +209,7 @@ impl<'tcx> Inliner<'tcx> {\n             for (arg, input) in args.iter().zip(callee_body.args_iter()) {\n                 let input_type = callee_body.local_decls[input].ty;\n                 let arg_ty = arg.ty(&caller_body.local_decls, self.tcx);\n-                if !equal_up_to_regions(self.tcx, self.param_env, arg_ty, input_type) {\n+                if !util::is_subtype(self.tcx, self.param_env, input_type, arg_ty) {\n                     trace!(?arg_ty, ?input_type);\n                     return Err(\"failed to normalize argument type\");\n                 }\n@@ -847,7 +847,7 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n             let parent = Place { local, projection: self.tcx.intern_place_elems(proj_base) };\n             let parent_ty = parent.ty(&self.callee_body.local_decls, self.tcx);\n             let check_equal = |this: &mut Self, f_ty| {\n-                if !equal_up_to_regions(this.tcx, this.param_env, ty, f_ty) {\n+                if !util::is_equal_up_to_subtyping(this.tcx, this.param_env, ty, f_ty) {\n                     trace!(?ty, ?f_ty);\n                     this.validation = Err(\"failed to normalize projection type\");\n                     return;"}, {"sha": "2558ac801addd18c6a3a492db233d7245292787f", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -1660,14 +1660,14 @@ impl<'a> Parser<'a> {\n                 let left = begin_par_sp;\n                 let right = self.prev_token.span;\n                 let left_snippet = if let Ok(snip) = sm.span_to_prev_source(left) &&\n-                        !snip.ends_with(\" \") {\n+                        !snip.ends_with(' ') {\n                                 \" \".to_string()\n                             } else {\n                                 \"\".to_string()\n                             };\n \n                 let right_snippet = if let Ok(snip) = sm.span_to_next_source(right) &&\n-                        !snip.starts_with(\" \") {\n+                        !snip.starts_with(' ') {\n                                 \" \".to_string()\n                             } else {\n                                 \"\".to_string()"}, {"sha": "acb9bd8e78a4a57077e348f4e369eabd910f9730", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -353,7 +353,7 @@ impl CheckAttrVisitor<'_> {\n                 attr.span,\n                 OnlyHasEffectOn {\n                     attr_name: attr.name_or_empty(),\n-                    target_name: allowed_target.name().replace(\" \", \"_\"),\n+                    target_name: allowed_target.name().replace(' ', \"_\"),\n                 },\n             );\n         }"}, {"sha": "5d0224c35f3645a8716d2820e8d8a4f0f49914e9", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -772,7 +772,7 @@ impl<'tcx> DeadVisitor<'tcx> {\n         self.tcx.emit_spanned_lint(\n             lint,\n             tcx.hir().local_def_id_to_hir_id(first_id),\n-            MultiSpan::from_spans(spans.clone()),\n+            MultiSpan::from_spans(spans),\n             diag,\n         );\n     }"}, {"sha": "d602acec53e3214998c52ffa1f52ca334428f916", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -562,7 +562,10 @@ impl Session {\n         if self.err_count() == old_count {\n             Ok(result)\n         } else {\n-            Err(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n+            Err(self.delay_span_bug(\n+                rustc_span::DUMMY_SP,\n+                \"`self.err_count()` changed but an error was not emitted\",\n+            ))\n         }\n     }\n     #[allow(rustc::untranslatable_diagnostic)]"}, {"sha": "0c559ec04a413f1e86aab9052148956e89b5a5f3", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -3,6 +3,7 @@ use crate::abi::{HasDataLayout, TyAbiInterface, TyAndLayout};\n use crate::spec::{self, HasTargetSpec};\n use rustc_span::Symbol;\n use std::fmt;\n+use std::str::FromStr;\n \n mod aarch64;\n mod amdgpu;\n@@ -737,6 +738,33 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n     }\n }\n \n+impl FromStr for Conv {\n+    type Err = String;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"C\" => Ok(Conv::C),\n+            \"Rust\" => Ok(Conv::Rust),\n+            \"RustCold\" => Ok(Conv::Rust),\n+            \"ArmAapcs\" => Ok(Conv::ArmAapcs),\n+            \"CCmseNonSecureCall\" => Ok(Conv::CCmseNonSecureCall),\n+            \"Msp430Intr\" => Ok(Conv::Msp430Intr),\n+            \"PtxKernel\" => Ok(Conv::PtxKernel),\n+            \"X86Fastcall\" => Ok(Conv::X86Fastcall),\n+            \"X86Intr\" => Ok(Conv::X86Intr),\n+            \"X86Stdcall\" => Ok(Conv::X86Stdcall),\n+            \"X86ThisCall\" => Ok(Conv::X86ThisCall),\n+            \"X86VectorCall\" => Ok(Conv::X86VectorCall),\n+            \"X86_64SysV\" => Ok(Conv::X86_64SysV),\n+            \"X86_64Win64\" => Ok(Conv::X86_64Win64),\n+            \"AmdGpuKernel\" => Ok(Conv::AmdGpuKernel),\n+            \"AvrInterrupt\" => Ok(Conv::AvrInterrupt),\n+            \"AvrNonBlockingInterrupt\" => Ok(Conv::AvrNonBlockingInterrupt),\n+            _ => Err(format!(\"'{}' is not a valid value for entry function call convetion.\", s)),\n+        }\n+    }\n+}\n+\n // Some types are used a lot. Make sure they don't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {"}, {"sha": "75bb76a9de0878afe6f0faa1e65f7adf5f73a580", "filename": "compiler/rustc_target/src/json.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_target%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_target%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fjson.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -89,3 +89,28 @@ impl<A: ToJson> ToJson for Option<A> {\n         }\n     }\n }\n+\n+impl ToJson for crate::abi::call::Conv {\n+    fn to_json(&self) -> Json {\n+        let s = match self {\n+            Self::C => \"C\",\n+            Self::Rust => \"Rust\",\n+            Self::RustCold => \"RustCold\",\n+            Self::ArmAapcs => \"ArmAapcs\",\n+            Self::CCmseNonSecureCall => \"CCmseNonSecureCall\",\n+            Self::Msp430Intr => \"Msp430Intr\",\n+            Self::PtxKernel => \"PtxKernel\",\n+            Self::X86Fastcall => \"X86Fastcall\",\n+            Self::X86Intr => \"X86Intr\",\n+            Self::X86Stdcall => \"X86Stdcall\",\n+            Self::X86ThisCall => \"X86ThisCall\",\n+            Self::X86VectorCall => \"X86VectorCall\",\n+            Self::X86_64SysV => \"X86_64SysV\",\n+            Self::X86_64Win64 => \"X86_64Win64\",\n+            Self::AmdGpuKernel => \"AmdGpuKernel\",\n+            Self::AvrInterrupt => \"AvrInterrupt\",\n+            Self::AvrNonBlockingInterrupt => \"AvrNonBlockingInterrupt\",\n+        };\n+        Json::String(s.to_owned())\n+    }\n+}"}, {"sha": "6d936d2cb9ff0463e13ff9d6802a76b38dea4f1c", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -34,6 +34,7 @@\n //! the target's settings, though `target-feature` and `link-args` will *add*\n //! to the list specified by the target, rather than replace.\n \n+use crate::abi::call::Conv;\n use crate::abi::Endian;\n use crate::json::{Json, ToJson};\n use crate::spec::abi::{lookup as lookup_abi, Abi};\n@@ -1668,6 +1669,14 @@ pub struct TargetOptions {\n     /// Whether the target supports stack canary checks. `true` by default,\n     /// since this is most common among tier 1 and tier 2 targets.\n     pub supports_stack_protector: bool,\n+\n+    // The name of entry function.\n+    // Default value is \"main\"\n+    pub entry_name: StaticCow<str>,\n+\n+    // The ABI of entry function.\n+    // Default value is `Conv::C`, i.e. C call convention\n+    pub entry_abi: Conv,\n }\n \n /// Add arguments for the given flavor and also for its \"twin\" flavors\n@@ -1884,6 +1893,8 @@ impl Default for TargetOptions {\n             c_enum_min_bits: 32,\n             generate_arange_section: true,\n             supports_stack_protector: true,\n+            entry_name: \"main\".into(),\n+            entry_abi: Conv::C,\n         }\n     }\n }\n@@ -2404,6 +2415,18 @@ impl Target {\n                     }\n                 }\n             } );\n+            ($key_name:ident, Conv) => ( {\n+                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n+                obj.remove(&name).and_then(|o| o.as_str().and_then(|s| {\n+                    match Conv::from_str(s) {\n+                        Ok(c) => {\n+                            base.$key_name = c;\n+                            Some(Ok(()))\n+                        }\n+                        Err(e) => Some(Err(e))\n+                    }\n+                })).unwrap_or(Ok(()))\n+            } );\n         }\n \n         if let Some(j) = obj.remove(\"target-endian\") {\n@@ -2523,6 +2546,8 @@ impl Target {\n         key!(c_enum_min_bits, u64);\n         key!(generate_arange_section, bool);\n         key!(supports_stack_protector, bool);\n+        key!(entry_name);\n+        key!(entry_abi, Conv)?;\n \n         if base.is_builtin {\n             // This can cause unfortunate ICEs later down the line.\n@@ -2773,6 +2798,8 @@ impl ToJson for Target {\n         target_option_val!(c_enum_min_bits);\n         target_option_val!(generate_arange_section);\n         target_option_val!(supports_stack_protector);\n+        target_option_val!(entry_name);\n+        target_option_val!(entry_abi);\n \n         if let Some(abi) = self.default_adjusted_cabi {\n             d.insert(\"default-adjusted-cabi\".into(), Abi::name(abi).to_json());"}, {"sha": "f8346e515d70c57ab0a3e693a65871e4ad4a4c1a", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -125,20 +125,32 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n+    /// Checks whether `expected` is a subtype of `actual`: `expected <: actual`.\n+    pub fn sub<T: ToTrace<'tcx>>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        expected: T,\n+        actual: T,\n+    ) -> Result<(), TypeError<'tcx>> {\n+        self.infcx\n+            .at(cause, param_env)\n+            .sup(expected, actual)\n+            .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n+    }\n+\n+    /// Checks whether `expected` is a supertype of `actual`: `expected :> actual`.\n     pub fn sup<T: ToTrace<'tcx>>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         expected: T,\n         actual: T,\n     ) -> Result<(), TypeError<'tcx>> {\n-        match self.infcx.at(cause, param_env).sup(expected, actual) {\n-            Ok(InferOk { obligations, value: () }) => {\n-                self.register_obligations(obligations);\n-                Ok(())\n-            }\n-            Err(e) => Err(e),\n-        }\n+        self.infcx\n+            .at(cause, param_env)\n+            .sup(expected, actual)\n+            .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n     pub fn select_where_possible(&self) -> Vec<FulfillmentError<'tcx>> {"}, {"sha": "ad0785d3817e1cf386a7be5762d429a456e481ea", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -532,9 +532,12 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         root_obligation: &PredicateObligation<'tcx>,\n         error: &SelectionError<'tcx>,\n     ) {\n-        self.set_tainted_by_errors();\n         let tcx = self.tcx;\n         let mut span = obligation.cause.span;\n+        // FIXME: statically guarantee this by tainting after the diagnostic is emitted\n+        self.set_tainted_by_errors(\n+            tcx.sess.delay_span_bug(span, \"`report_selection_error` did not emit an error\"),\n+        );\n \n         let mut err = match *error {\n             SelectionError::Unimplemented => {\n@@ -2060,7 +2063,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // check upstream for type errors and don't add the obligations to\n                 // begin with in those cases.\n                 if self.tcx.lang_items().sized_trait() == Some(trait_ref.def_id()) {\n-                    if !self.is_tainted_by_errors() {\n+                    if let None = self.tainted_by_errors() {\n                         self.emit_inference_failure_err(\n                             body_id,\n                             span,\n@@ -2115,16 +2118,16 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         if impls.len() > 1 && impls.len() < 5 && has_non_region_infer {\n                             self.annotate_source_of_ambiguity(&mut err, &impls, predicate);\n                         } else {\n-                            if self.is_tainted_by_errors() {\n-                                err.delay_as_bug();\n+                            if self.tainted_by_errors().is_some() {\n+                                err.cancel();\n                                 return;\n                             }\n                             err.note(&format!(\"cannot satisfy `{}`\", predicate));\n                         }\n                     }\n                     _ => {\n-                        if self.is_tainted_by_errors() {\n-                            err.delay_as_bug();\n+                        if self.tainted_by_errors().is_some() {\n+                            err.cancel();\n                             return;\n                         }\n                         err.note(&format!(\"cannot satisfy `{}`\", predicate));\n@@ -2226,7 +2229,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         ] = path.segments\n                         && data.trait_ref.def_id == *trait_id\n                         && self.tcx.trait_of_item(*item_id) == Some(*trait_id)\n-                        && !self.is_tainted_by_errors()\n+                        && let None = self.tainted_by_errors()\n                     {\n                         let (verb, noun) = match self.tcx.associated_item(item_id).kind {\n                             ty::AssocKind::Const => (\"refer to the\", \"constant\"),\n@@ -2295,7 +2298,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // with error messages.\n                 if arg.references_error()\n                     || self.tcx.sess.has_errors().is_some()\n-                    || self.is_tainted_by_errors()\n+                    || self.tainted_by_errors().is_some()\n                 {\n                     return;\n                 }\n@@ -2306,7 +2309,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             ty::PredicateKind::Subtype(data) => {\n                 if data.references_error()\n                     || self.tcx.sess.has_errors().is_some()\n-                    || self.is_tainted_by_errors()\n+                    || self.tainted_by_errors().is_some()\n                 {\n                     // no need to overload user in such cases\n                     return;\n@@ -2317,7 +2320,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 self.emit_inference_failure_err(body_id, span, a.into(), ErrorCode::E0282, true)\n             }\n             ty::PredicateKind::Projection(data) => {\n-                if predicate.references_error() || self.is_tainted_by_errors() {\n+                if predicate.references_error() || self.tainted_by_errors().is_some() {\n                     return;\n                 }\n                 let subst = data\n@@ -2351,7 +2354,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n \n             ty::PredicateKind::ConstEvaluatable(data) => {\n-                if predicate.references_error() || self.is_tainted_by_errors() {\n+                if predicate.references_error() || self.tainted_by_errors().is_some() {\n                     return;\n                 }\n                 let subst = data.walk().find(|g| g.is_non_region_infer());\n@@ -2378,7 +2381,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n             _ => {\n-                if self.tcx.sess.has_errors().is_some() || self.is_tainted_by_errors() {\n+                if self.tcx.sess.has_errors().is_some() || self.tainted_by_errors().is_some() {\n                     return;\n                 }\n                 let mut err = struct_span_err!(\n@@ -2422,7 +2425,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         post.sort();\n         post.dedup();\n \n-        if self.is_tainted_by_errors()\n+        if self.tainted_by_errors().is_some()\n             && (crate_names.len() == 1\n                 && spans.len() == 0\n                 && [\"`core`\", \"`alloc`\", \"`std`\"].contains(&crate_names[0].as_str())"}, {"sha": "b05942353a343536100523b245a869ec16b16ccd", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -33,7 +33,7 @@ use crate::traits::ProjectionCacheKey;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::{Diagnostic, ErrorGuaranteed};\n+use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n@@ -1089,10 +1089,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if !self.infcx.tcx.recursion_limit().value_within_limit(depth) {\n             match self.query_mode {\n                 TraitQueryMode::Standard => {\n-                    if self.infcx.is_tainted_by_errors() {\n-                        return Err(OverflowError::Error(\n-                            ErrorGuaranteed::unchecked_claim_error_was_emitted(),\n-                        ));\n+                    if let Some(e) = self.infcx.tainted_by_errors() {\n+                        return Err(OverflowError::Error(e));\n                     }\n                     self.infcx.err_ctxt().report_overflow_error(error_obligation, true);\n                 }"}, {"sha": "b355d94ce4976697ff0226398b040c248f97ee38", "filename": "library/core/src/cell/lazy.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -4,6 +4,10 @@ use crate::ops::Deref;\n \n /// A value which is initialized on the first access.\n ///\n+/// For a thread-safe version of this struct, see [`std::sync::LazyLock`].\n+///\n+/// [`std::sync::LazyLock`]: ../../std/sync/struct.LazyLock.html\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "8c01643c7ac177a4d0e5027536b605a74e699278", "filename": "library/core/src/cell/once.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -4,8 +4,14 @@ use crate::mem;\n \n /// A cell which can be written to only once.\n ///\n-/// Unlike `RefCell`, a `OnceCell` only provides shared `&T` references to its value.\n-/// Unlike `Cell`, a `OnceCell` doesn't require copying or replacing the value to access it.\n+/// Unlike [`RefCell`], a `OnceCell` only provides shared `&T` references to its value.\n+/// Unlike [`Cell`], a `OnceCell` doesn't require copying or replacing the value to access it.\n+///\n+/// For a thread-safe version of this struct, see [`std::sync::OnceLock`].\n+///\n+/// [`RefCell`]: crate::cell::RefCell\n+/// [`Cell`]: crate::cell::Cell\n+/// [`std::sync::OnceLock`]: ../../std/sync/struct.OnceLock.html\n ///\n /// # Examples\n ///"}, {"sha": "4e30076246314edb50cdf017b1f1aa00878a3d12", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -880,7 +880,9 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn asinh(self) -> f32 {\n-        (self.abs() + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n+        let ax = self.abs();\n+        let ix = 1.0 / ax;\n+        (ax + (ax / (Self::hypot(1.0, ix) + ix))).ln_1p().copysign(self)\n     }\n \n     /// Inverse hyperbolic cosine function.\n@@ -900,7 +902,11 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn acosh(self) -> f32 {\n-        if self < 1.0 { Self::NAN } else { (self + ((self * self) - 1.0).sqrt()).ln() }\n+        if self < 1.0 {\n+            Self::NAN\n+        } else {\n+            (self + ((self - 1.0).sqrt() * (self + 1.0).sqrt())).ln()\n+        }\n     }\n \n     /// Inverse hyperbolic tangent function."}, {"sha": "6ee295de6163f3807fee36515ad138a61c10dc98", "filename": "library/std/src/f32/tests.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -587,6 +587,11 @@ fn test_asinh() {\n     assert_approx_eq!((-2.0f32).asinh(), -1.443635475178810342493276740273105f32);\n     // regression test for the catastrophic cancellation fixed in 72486\n     assert_approx_eq!((-3000.0f32).asinh(), -8.699514775987968673236893537700647f32);\n+\n+    // test for low accuracy from issue 104548\n+    assert_approx_eq!(60.0f32, 60.0f32.sinh().asinh());\n+    // mul needed for approximate comparison to be meaningful\n+    assert_approx_eq!(1.0f32, 1e-15f32.sinh().asinh() * 1e15f32);\n }\n \n #[test]\n@@ -602,6 +607,9 @@ fn test_acosh() {\n     assert!(nan.acosh().is_nan());\n     assert_approx_eq!(2.0f32.acosh(), 1.31695789692481670862504634730796844f32);\n     assert_approx_eq!(3.0f32.acosh(), 1.76274717403908605046521864995958461f32);\n+\n+    // test for low accuracy from issue 104548\n+    assert_approx_eq!(60.0f32, 60.0f32.cosh().acosh());\n }\n \n #[test]"}, {"sha": "ec67fdad4f726f50ac11d503701fef61ab8664b5", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -882,7 +882,9 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn asinh(self) -> f64 {\n-        (self.abs() + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n+        let ax = self.abs();\n+        let ix = 1.0 / ax;\n+        (ax + (ax / (Self::hypot(1.0, ix) + ix))).ln_1p().copysign(self)\n     }\n \n     /// Inverse hyperbolic cosine function.\n@@ -902,7 +904,11 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn acosh(self) -> f64 {\n-        if self < 1.0 { Self::NAN } else { (self + ((self * self) - 1.0).sqrt()).ln() }\n+        if self < 1.0 {\n+            Self::NAN\n+        } else {\n+            (self + ((self - 1.0).sqrt() * (self + 1.0).sqrt())).ln()\n+        }\n     }\n \n     /// Inverse hyperbolic tangent function."}, {"sha": "5b039d445ce14db91eabb7e6c570d6dc29cf0be5", "filename": "library/std/src/f64/tests.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -575,6 +575,11 @@ fn test_asinh() {\n     assert_approx_eq!((-2.0f64).asinh(), -1.443635475178810342493276740273105f64);\n     // regression test for the catastrophic cancellation fixed in 72486\n     assert_approx_eq!((-67452098.07139316f64).asinh(), -18.72007542627454439398548429400083);\n+\n+    // test for low accuracy from issue 104548\n+    assert_approx_eq!(60.0f64, 60.0f64.sinh().asinh());\n+    // mul needed for approximate comparison to be meaningful\n+    assert_approx_eq!(1.0f64, 1e-15f64.sinh().asinh() * 1e15f64);\n }\n \n #[test]\n@@ -590,6 +595,9 @@ fn test_acosh() {\n     assert!(nan.acosh().is_nan());\n     assert_approx_eq!(2.0f64.acosh(), 1.31695789692481670862504634730796844f64);\n     assert_approx_eq!(3.0f64.acosh(), 1.76274717403908605046521864995958461f64);\n+\n+    // test for low accuracy from issue 104548\n+    assert_approx_eq!(60.0f64, 60.0f64.cosh().acosh());\n }\n \n #[test]"}, {"sha": "c8d3289ca4a06986bd81ff1ea97ced5996745bd7", "filename": "library/std/src/sync/lazy_lock.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -6,7 +6,9 @@ use crate::sync::OnceLock;\n \n /// A value which is initialized on the first access.\n ///\n-/// This type is a thread-safe `Lazy`, and can be used in statics.\n+/// This type is a thread-safe [`LazyCell`], and can be used in statics.\n+///\n+/// [`LazyCell`]: crate::cell::LazyCell\n ///\n /// # Examples\n ///"}, {"sha": "16d1fd2a576b97703ae8483cd01953997d5b6e0d", "filename": "library/std/src/sync/once_lock.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -7,7 +7,9 @@ use crate::sync::Once;\n \n /// A synchronization primitive which can be written to only once.\n ///\n-/// This type is a thread-safe `OnceCell`.\n+/// This type is a thread-safe [`OnceCell`], and can be used in statics.\n+///\n+/// [`OnceCell`]: crate::cell::OnceCell\n ///\n /// # Examples\n ///\n@@ -33,7 +35,7 @@ use crate::sync::Once;\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n pub struct OnceLock<T> {\n     once: Once,\n-    // Whether or not the value is initialized is tracked by `state_and_queue`.\n+    // Whether or not the value is initialized is tracked by `once.is_completed()`.\n     value: UnsafeCell<MaybeUninit<T>>,\n     /// `PhantomData` to make sure dropck understands we're dropping T in our Drop impl.\n     ///"}, {"sha": "e0cdb86d9d1dc152e47f97f85e5ea4456ed0f2ea", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -418,7 +418,7 @@ impl Options {\n             ) {\n                 Ok(p) => p,\n                 Err(e) => {\n-                    diag.struct_err(&e.to_string()).emit();\n+                    diag.struct_err(e).emit();\n                     return Err(1);\n                 }\n             };\n@@ -561,7 +561,7 @@ impl Options {\n             ) {\n                 Ok(p) => p,\n                 Err(e) => {\n-                    diag.struct_err(&e.to_string()).emit();\n+                    diag.struct_err(e).emit();\n                     return Err(1);\n                 }\n             };"}, {"sha": "1f87f95563ad550d789ec580f3d4eff64fcb71ce", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -58,7 +58,7 @@ pub(crate) fn suffix_path(filename: &str, suffix: &str) -> PathBuf {\n }\n \n pub(crate) fn static_filename(filename: &str, contents: &[u8]) -> PathBuf {\n-    let filename = filename.rsplit(\"/\").next().unwrap();\n+    let filename = filename.rsplit('/').next().unwrap();\n     suffix_path(filename, &static_suffix(contents))\n }\n "}, {"sha": "1c8316f87fa073ef9bdf16e5503df9942beaaf0d", "filename": "src/test/ui/coherence/issue-100191-2.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/becc24a23aed2639db3b78acd93ec6d553898583/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becc24a23aed2639db3b78acd93ec6d553898583/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191-2.rs?ref=becc24a23aed2639db3b78acd93ec6d553898583", "patch": "@@ -1,12 +0,0 @@\n-//~ ERROR overflow evaluating the requirement `T: Trait<_>`\n-\n-#![feature(specialization, with_negative_coherence)]\n-#![allow(incomplete_features)]\n-\n-pub trait Trait<T> {}\n-\n-default impl<T, U> Trait<T> for U {}\n-\n-impl<T> Trait<<T as Iterator>::Item> for T {}\n-\n-fn main() {}"}, {"sha": "e8597fde54d3ba133ec922311d78233642e949cc", "filename": "src/test/ui/coherence/issue-100191.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/becc24a23aed2639db3b78acd93ec6d553898583/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becc24a23aed2639db3b78acd93ec6d553898583/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fissue-100191.rs?ref=becc24a23aed2639db3b78acd93ec6d553898583", "patch": "@@ -1,21 +0,0 @@\n-#![crate_type = \"lib\"]\n-#![feature(specialization, with_negative_coherence)]\n-#![allow(incomplete_features)]\n-\n-trait X {}\n-trait Y: X {}\n-trait Z {\n-    type Assoc: Y;\n-}\n-struct A<T>(T);\n-\n-impl<T> Y for T where T: X {}\n-impl<T: X> Z for A<T> {\n-    type Assoc = T;\n-}\n-\n-// this impl is invalid, but causes an ICE anyway\n-impl<T> From<<A<T> as Z>::Assoc> for T {}\n-//~^ ERROR type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n-\n-fn main() {}"}, {"sha": "547643f0d6e203f9644dd410d44deb97d3e7ffac", "filename": "src/test/ui/issues/issue-52262.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fissues%2Fissue-52262.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fissues%2Fissue-52262.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52262.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -1,4 +1,3 @@\n-// compile-flags:-Ztreat-err-as-bug=5\n #[derive(Debug)]\n enum MyError {\n     NotFound { key: Vec<u8> },"}, {"sha": "ef41f078b8037d25e1ab892ac182fad9a3656163", "filename": "src/test/ui/issues/issue-52262.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fissues%2Fissue-52262.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fissues%2Fissue-52262.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52262.stderr?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -1,5 +1,5 @@\n error[E0507]: cannot move out of `*key` which is behind a shared reference\n-  --> $DIR/issue-52262.rs:16:35\n+  --> $DIR/issue-52262.rs:15:35\n    |\n LL |                 String::from_utf8(*key).unwrap()\n    |                                   ^^^^ move occurs because `*key` has type `Vec<u8>`, which does not implement the `Copy` trait"}, {"sha": "cadfb3b66f29747cc0e37ffc30561e69b605eb29", "filename": "src/test/ui/mir/important-higher-ranked-regions.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fmir%2Fimportant-higher-ranked-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fmir%2Fimportant-higher-ranked-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fimportant-higher-ranked-regions.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+// compile-flags: -Zvalidate-mir\n+\n+// This test checks that bivariant parameters are handled correctly\n+// in the mir.\n+#![allow(coherence_leak_check)]\n+trait Trait {\n+    type Assoc;\n+}\n+\n+struct Foo<T, U>(T)\n+where\n+    T: Trait<Assoc = U>;\n+\n+impl Trait for for<'a> fn(&'a ()) {\n+    type Assoc = u32;\n+}\n+impl Trait for fn(&'static ()) {\n+    type Assoc = String;\n+}\n+\n+fn foo(x: Foo<for<'a> fn(&'a ()), u32>) -> Foo<fn(&'static ()), String> {\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "26db9d7c9974982e38c2b5a01283ce872f286985", "filename": "src/test/ui/specialization/issue-43037.current.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fspecialization%2Fissue-43037.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fspecialization%2Fissue-43037.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-43037.current.stderr?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -1,5 +1,5 @@\n error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n-  --> $DIR/issue-43037.rs:17:6\n+  --> $DIR/issue-43037.rs:19:6\n    |\n LL | impl<T> From<<A<T> as Z>::Assoc> for T {}\n    |      ^ type parameter `T` must be used as the type parameter for some local type", "previous_filename": "src/test/ui/specialization/issue-43037.stderr"}, {"sha": "26db9d7c9974982e38c2b5a01283ce872f286985", "filename": "src/test/ui/specialization/issue-43037.negative.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fspecialization%2Fissue-43037.negative.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fspecialization%2Fissue-43037.negative.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-43037.negative.stderr?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -1,5 +1,5 @@\n error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n-  --> $DIR/issue-100191.rs:18:6\n+  --> $DIR/issue-43037.rs:19:6\n    |\n LL | impl<T> From<<A<T> as Z>::Assoc> for T {}\n    |      ^ type parameter `T` must be used as the type parameter for some local type", "previous_filename": "src/test/ui/coherence/issue-100191.stderr"}, {"sha": "a1e3f998b23701c5a04d86fb76594c0d0d008d89", "filename": "src/test/ui/specialization/issue-43037.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fspecialization%2Fissue-43037.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fspecialization%2Fissue-43037.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-43037.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -1,4 +1,6 @@\n+// revisions: current negative\n #![feature(specialization)]\n+#![cfg_attr(negative, feature(with_negative_coherence))]\n #![allow(incomplete_features)]\n \n trait X {}"}, {"sha": "5013559b80ea9ae90fe56f3a5d77503072342208", "filename": "src/test/ui/specialization/issue-45814.current.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fspecialization%2Fissue-45814.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fspecialization%2Fissue-45814.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-45814.current.stderr?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -2,7 +2,7 @@ error[E0275]: overflow evaluating the requirement `T: Trait<_>`\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_45814`)\n note: required for `T` to implement `Trait<_>`\n-  --> $DIR/issue-45814.rs:8:20\n+  --> $DIR/issue-45814.rs:9:20\n    |\n LL | default impl<T, U> Trait<T> for U {}\n    |                    ^^^^^^^^     ^", "previous_filename": "src/test/ui/specialization/issue-45814.stderr"}, {"sha": "5013559b80ea9ae90fe56f3a5d77503072342208", "filename": "src/test/ui/specialization/issue-45814.negative.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fspecialization%2Fissue-45814.negative.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fspecialization%2Fissue-45814.negative.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-45814.negative.stderr?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -1,8 +1,8 @@\n error[E0275]: overflow evaluating the requirement `T: Trait<_>`\n    |\n-   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_100191_2`)\n+   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_45814`)\n note: required for `T` to implement `Trait<_>`\n-  --> $DIR/issue-100191-2.rs:8:20\n+  --> $DIR/issue-45814.rs:9:20\n    |\n LL | default impl<T, U> Trait<T> for U {}\n    |                    ^^^^^^^^     ^", "previous_filename": "src/test/ui/coherence/issue-100191-2.stderr"}, {"sha": "fce236390c2b0e78ef913361fbb234ac87f6d7b7", "filename": "src/test/ui/specialization/issue-45814.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fspecialization%2Fissue-45814.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fspecialization%2Fissue-45814.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-45814.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -1,6 +1,7 @@\n //~ ERROR overflow evaluating the requirement `T: Trait<_>`\n-\n+// revisions: current negative\n #![feature(specialization)]\n+#![cfg_attr(negative, feature(with_negative_coherence))]\n #![allow(incomplete_features)]\n \n pub trait Trait<T> {}"}, {"sha": "08d4b99559031e9c9f63d7a357e9e45d4c5f2733", "filename": "src/test/ui/suggestions/issue-102354.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fsuggestions%2Fissue-102354.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftest%2Fui%2Fsuggestions%2Fissue-102354.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-102354.stderr?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -2,22 +2,17 @@ error[E0599]: no method named `func` found for type `i32` in the current scope\n   --> $DIR/issue-102354.rs:9:7\n    |\n LL |     x.func();\n-   |       ^^^^ this is an associated function, not a method\n+   |     --^^^^--\n+   |     | |\n+   |     | this is an associated function, not a method\n+   |     help: use associated function syntax instead: `i32::func()`\n    |\n    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n note: the candidate is defined in the trait `Trait`\n   --> $DIR/issue-102354.rs:2:5\n    |\n LL |     fn func() {}\n    |     ^^^^^^^^^\n-help: use associated function syntax instead\n-   |\n-LL |     i32::func();\n-   |     ~~~~~~~~~~~\n-help: disambiguate the associated function for the candidate\n-   |\n-LL |     <i32 as Trait>::func(x);\n-   |     ~~~~~~~~~~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "cfba7d583b138633d8ad151badc188f60a1784b0", "filename": "src/tools/miropt-test-tools/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftools%2Fmiropt-test-tools%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d8040166a730d0da7bba0f2864f0ef7ff6364/src%2Ftools%2Fmiropt-test-tools%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiropt-test-tools%2Fsrc%2Flib.rs?ref=2f8d8040166a730d0da7bba0f2864f0ef7ff6364", "patch": "@@ -11,7 +11,7 @@ pub fn files_for_miropt_test(testfile: &std::path::Path, bit_width: u32) -> Vec<\n     let test_file_contents = fs::read_to_string(&testfile).unwrap();\n \n     let test_dir = testfile.parent().unwrap();\n-    let test_crate = testfile.file_stem().unwrap().to_str().unwrap().replace(\"-\", \"_\");\n+    let test_crate = testfile.file_stem().unwrap().to_str().unwrap().replace('-', \"_\");\n \n     let bit_width = if test_file_contents.lines().any(|l| l == \"// EMIT_MIR_FOR_EACH_BIT_WIDTH\") {\n         format!(\".{}bit\", bit_width)"}]}