{"sha": "bdca349573c00542635848a16276272fb0c1acc9", "node_id": "C_kwDOAAsO6NoAKGJkY2EzNDk1NzNjMDA1NDI2MzU4NDhhMTYyNzYyNzJmYjBjMWFjYzk", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-06-01T13:27:05Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-06-01T13:27:05Z"}, "message": "Arc DefMap::data so the block def maps can share it", "tree": {"sha": "346209027c3b8b2a4e17e3c48bc8901f2dff6475", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/346209027c3b8b2a4e17e3c48bc8901f2dff6475"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdca349573c00542635848a16276272fb0c1acc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdca349573c00542635848a16276272fb0c1acc9", "html_url": "https://github.com/rust-lang/rust/commit/bdca349573c00542635848a16276272fb0c1acc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdca349573c00542635848a16276272fb0c1acc9/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c466ccc2bdfc978abccc988b59018273b5a210e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c466ccc2bdfc978abccc988b59018273b5a210e", "html_url": "https://github.com/rust-lang/rust/commit/5c466ccc2bdfc978abccc988b59018273b5a210e"}], "stats": {"total": 128, "additions": 68, "deletions": 60}, "files": [{"sha": "e900de88dd02e36c88f77083daa7cfe152c98eea", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bdca349573c00542635848a16276272fb0c1acc9/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdca349573c00542635848a16276272fb0c1acc9/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=bdca349573c00542635848a16276272fb0c1acc9", "patch": "@@ -116,10 +116,10 @@ pub struct DefMap {\n     diagnostics: Vec<DefDiagnostic>,\n \n     // FIXME: Arc this so we can share it with block def maps\n-    data: CrateData,\n+    data: Arc<CrateData>,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n struct CrateData {\n     /// Side table for resolving derive helpers.\n     exported_derives: FxHashMap<MacroDefId, Box<[Name]>>,\n@@ -141,6 +141,28 @@ struct CrateData {\n     edition: Edition,\n     recursion_limit: Option<u32>,\n }\n+impl CrateData {\n+    fn shrink_to_fit(&mut self) {\n+        let Self {\n+            exported_derives,\n+            fn_proc_macro_mapping,\n+            registered_attrs,\n+            registered_tools,\n+            unstable_features,\n+            proc_macro_loading_error: _,\n+            rustc_coherence_is_core: _,\n+            no_core: _,\n+            no_std: _,\n+            edition: _,\n+            recursion_limit: _,\n+        } = self;\n+        exported_derives.shrink_to_fit();\n+        fn_proc_macro_mapping.shrink_to_fit();\n+        registered_attrs.shrink_to_fit();\n+        registered_tools.shrink_to_fit();\n+        unstable_features.shrink_to_fit();\n+    }\n+}\n \n /// For `DefMap`s computed for a block expression, this stores its location in the parent map.\n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n@@ -287,6 +309,7 @@ impl DefMap {\n             ModuleData::new(ModuleOrigin::BlockExpr { block: block.ast_id }, visibility);\n \n         let mut def_map = DefMap::empty(krate, parent_map.data.edition, module_data);\n+        def_map.data = parent_map.data.clone();\n         def_map.block = Some(BlockInfo {\n             block: block_id,\n             parent: BlockRelativeModuleId {\n@@ -314,7 +337,7 @@ impl DefMap {\n             prelude: None,\n             modules,\n             diagnostics: Vec::new(),\n-            data: CrateData {\n+            data: Arc::new(CrateData {\n                 recursion_limit: None,\n                 exported_derives: FxHashMap::default(),\n                 fn_proc_macro_mapping: FxHashMap::default(),\n@@ -326,7 +349,7 @@ impl DefMap {\n                 no_core: false,\n                 no_std: false,\n                 edition,\n-            },\n+            }),\n         }\n     }\n \n@@ -558,32 +581,14 @@ impl DefMap {\n             block: _,\n             krate: _,\n             prelude: _,\n-            data:\n-                CrateData {\n-                    exported_derives,\n-                    fn_proc_macro_mapping,\n-                    registered_attrs,\n-                    registered_tools,\n-                    unstable_features,\n-                    proc_macro_loading_error: _,\n-                    rustc_coherence_is_core: _,\n-                    no_core: _,\n-                    no_std: _,\n-                    edition: _,\n-                    recursion_limit: _,\n-                },\n+            data: _,\n         } = self;\n \n         extern_prelude.shrink_to_fit();\n         macro_use_prelude.shrink_to_fit();\n-        exported_derives.shrink_to_fit();\n         diagnostics.shrink_to_fit();\n         modules.shrink_to_fit();\n-        registered_attrs.shrink_to_fit();\n-        registered_tools.shrink_to_fit();\n-        fn_proc_macro_mapping.shrink_to_fit();\n         derive_helpers_in_scope.shrink_to_fit();\n-        unstable_features.shrink_to_fit();\n         for (_, module) in modules.iter_mut() {\n             module.children.shrink_to_fit();\n             module.scope.shrink_to_fit();"}, {"sha": "9e35c47d4fbfab743e2e89b42162afc1314a6f90", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/bdca349573c00542635848a16276272fb0c1acc9/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdca349573c00542635848a16276272fb0c1acc9/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=bdca349573c00542635848a16276272fb0c1acc9", "patch": "@@ -86,7 +86,7 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n     let proc_macros = if is_proc_macro {\n         match db.proc_macros().get(&def_map.krate) {\n             Some(Ok(proc_macros)) => {\n-                proc_macros\n+                Ok(proc_macros\n                     .iter()\n                     .enumerate()\n                     .map(|(idx, it)| {\n@@ -95,20 +95,13 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n                             tt::Ident { text: it.name.clone(), span: tt::TokenId::unspecified() };\n                         (name.as_name(), ProcMacroExpander::new(base_db::ProcMacroId(idx as u32)))\n                     })\n-                    .collect()\n-            }\n-            Some(Err(e)) => {\n-                def_map.data.proc_macro_loading_error = Some(e.clone().into_boxed_str());\n-                Vec::new()\n-            }\n-            None => {\n-                def_map.data.proc_macro_loading_error =\n-                    Some(\"No proc-macros present for crate\".to_owned().into_boxed_str());\n-                Vec::new()\n+                    .collect())\n             }\n+            Some(Err(e)) => Err(e.clone().into_boxed_str()),\n+            None => Err(\"No proc-macros present for crate\".to_owned().into_boxed_str()),\n         }\n     } else {\n-        vec![]\n+        Ok(vec![])\n     };\n \n     let mut collector = DefCollector {\n@@ -263,7 +256,7 @@ struct DefCollector<'a> {\n     /// built by the build system, and is the list of proc. macros we can actually expand. It is\n     /// empty when proc. macro support is disabled (in which case we still do name resolution for\n     /// them).\n-    proc_macros: Vec<(Name, ProcMacroExpander)>,\n+    proc_macros: Result<Vec<(Name, ProcMacroExpander)>, Box<str>>,\n     is_proc_macro: bool,\n     from_glob_import: PerNsGlobImports,\n     /// If we fail to resolve an attribute on a `ModItem`, we fall back to ignoring the attribute.\n@@ -290,6 +283,11 @@ impl DefCollector<'_> {\n         let module_id = DefMap::ROOT;\n \n         let attrs = item_tree.top_level_attrs(self.db, self.def_map.krate);\n+        let crate_data = Arc::get_mut(&mut self.def_map.data).unwrap();\n+\n+        if let Err(e) = &self.proc_macros {\n+            crate_data.proc_macro_loading_error = Some(e.clone());\n+        }\n \n         // Process other crate-level attributes.\n         for attr in &*attrs {\n@@ -306,7 +304,7 @@ impl DefCollector<'_> {\n             if *attr_name == hir_expand::name![recursion_limit] {\n                 if let Some(limit) = attr.string_value() {\n                     if let Ok(limit) = limit.parse() {\n-                        self.def_map.data.recursion_limit = Some(limit);\n+                        crate_data.recursion_limit = Some(limit);\n                     }\n                 }\n                 continue;\n@@ -320,17 +318,17 @@ impl DefCollector<'_> {\n             }\n \n             if *attr_name == hir_expand::name![no_core] {\n-                self.def_map.data.no_core = true;\n+                crate_data.no_core = true;\n                 continue;\n             }\n \n             if *attr_name == hir_expand::name![no_std] {\n-                self.def_map.data.no_std = true;\n+                crate_data.no_std = true;\n                 continue;\n             }\n \n             if attr_name.as_text().as_deref() == Some(\"rustc_coherence_is_core\") {\n-                self.def_map.data.rustc_coherence_is_core = true;\n+                crate_data.rustc_coherence_is_core = true;\n                 continue;\n             }\n \n@@ -344,7 +342,7 @@ impl DefCollector<'_> {\n                         [name] => Some(name.to_smol_str()),\n                         _ => None,\n                     });\n-                self.def_map.data.unstable_features.extend(features);\n+                crate_data.unstable_features.extend(features);\n             }\n \n             let attr_is_register_like = *attr_name == hir_expand::name![register_attr]\n@@ -359,14 +357,15 @@ impl DefCollector<'_> {\n             };\n \n             if *attr_name == hir_expand::name![register_attr] {\n-                self.def_map.data.registered_attrs.push(registered_name.to_smol_str());\n+                crate_data.registered_attrs.push(registered_name.to_smol_str());\n                 cov_mark::hit!(register_attr);\n             } else {\n-                self.def_map.data.registered_tools.push(registered_name.to_smol_str());\n+                crate_data.registered_tools.push(registered_name.to_smol_str());\n                 cov_mark::hit!(register_tool);\n             }\n         }\n \n+        crate_data.shrink_to_fit();\n         self.inject_prelude();\n \n         ModCollector {\n@@ -598,24 +597,29 @@ impl DefCollector<'_> {\n         def: ProcMacroDef,\n         id: ItemTreeId<item_tree::Function>,\n         fn_id: FunctionId,\n-        module_id: ModuleId,\n     ) {\n+        if self.def_map.block.is_some() {\n+            return;\n+        }\n+        let crate_root = self.def_map.module_id(DefMap::ROOT);\n+\n         let kind = def.kind.to_basedb_kind();\n-        let (expander, kind) = match self.proc_macros.iter().find(|(n, _)| n == &def.name) {\n-            Some(&(_, expander)) => (expander, kind),\n-            None => (ProcMacroExpander::dummy(), kind),\n-        };\n+        let (expander, kind) =\n+            match self.proc_macros.as_ref().map(|it| it.iter().find(|(n, _)| n == &def.name)) {\n+                Ok(Some(&(_, expander))) => (expander, kind),\n+                _ => (ProcMacroExpander::dummy(), kind),\n+            };\n \n         let proc_macro_id =\n-            ProcMacroLoc { container: module_id, id, expander, kind }.intern(self.db);\n+            ProcMacroLoc { container: crate_root, id, expander, kind }.intern(self.db);\n         self.define_proc_macro(def.name.clone(), proc_macro_id);\n+        let crate_data = Arc::get_mut(&mut self.def_map.data).unwrap();\n         if let ProcMacroKind::CustomDerive { helpers } = def.kind {\n-            self.def_map\n-                .data\n+            crate_data\n                 .exported_derives\n                 .insert(macro_id_to_def_id(self.db, proc_macro_id.into()), helpers);\n         }\n-        self.def_map.data.fn_proc_macro_mapping.insert(fn_id, proc_macro_id);\n+        crate_data.fn_proc_macro_mapping.insert(fn_id, proc_macro_id);\n     }\n \n     /// Define a macro with `macro_rules`.\n@@ -1639,12 +1643,10 @@ impl ModCollector<'_, '_> {\n                     let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n                     if self.def_collector.is_proc_macro && self.module_id == DefMap::ROOT {\n                         if let Some(proc_macro) = attrs.parse_proc_macro_decl(&it.name) {\n-                            let crate_root = def_map.module_id(DefMap::ROOT);\n                             self.def_collector.export_proc_macro(\n                                 proc_macro,\n                                 ItemTreeId::new(self.tree_id, id),\n                                 fn_id,\n-                                crate_root,\n                             );\n                         }\n                     }\n@@ -2165,11 +2167,12 @@ impl ModCollector<'_, '_> {\n             &self.item_tree[mac.visibility],\n         );\n         if let Some(helpers) = helpers_opt {\n-            self.def_collector\n-                .def_map\n-                .data\n-                .exported_derives\n-                .insert(macro_id_to_def_id(self.def_collector.db, macro_id.into()), helpers);\n+            if self.def_collector.def_map.block.is_none() {\n+                Arc::get_mut(&mut self.def_collector.def_map.data)\n+                    .unwrap()\n+                    .exported_derives\n+                    .insert(macro_id_to_def_id(self.def_collector.db, macro_id.into()), helpers);\n+            }\n         }\n     }\n \n@@ -2277,7 +2280,7 @@ mod tests {\n             unresolved_macros: Vec::new(),\n             mod_dirs: FxHashMap::default(),\n             cfg_options: &CfgOptions::default(),\n-            proc_macros: Default::default(),\n+            proc_macros: Ok(vec![]),\n             from_glob_import: Default::default(),\n             skip_attrs: Default::default(),\n             is_proc_macro: false,"}]}