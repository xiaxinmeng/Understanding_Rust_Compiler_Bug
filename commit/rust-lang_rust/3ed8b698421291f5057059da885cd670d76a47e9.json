{"sha": "3ed8b698421291f5057059da885cd670d76a47e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZDhiNjk4NDIxMjkxZjUwNTcwNTlkYTg4NWNkNjcwZDc2YTQ3ZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-06T10:20:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-06T10:20:14Z"}, "message": "Auto merge of #44965 - oconnor663:res_init_glibc, r=dtolnay\n\nreplace libc::res_init with res_init_if_glibc_before_2_26\n\nThe previous workaround for gibc's res_init bug is not thread-safe on\nother implementations of libc, and it can cause crashes. Use a runtime\ncheck to make sure we only call res_init when we need to, which is also\nwhen it's safe. See https://github.com/rust-lang/rust/issues/43592.\n\n~This PR is returning an InvalidData IO error if the glibc version string fails to parse. We could also have treated that case as \"not glibc\", and gotten rid of the idea that these functions could return an error. (Though I'm not a huge fan of ignoring error returns from `res_init` in any case.) Do other folks agree with these design choices?~\n\nI'm pretty new to hacking on libstd. Is there an easy way to build a toy rust program against my changes to test this, other than doing an entire `sudo make install` on my system? What's the usual workflow?", "tree": {"sha": "243914370c4ac9c3a93a0a16c2618644e4bb699d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/243914370c4ac9c3a93a0a16c2618644e4bb699d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ed8b698421291f5057059da885cd670d76a47e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ed8b698421291f5057059da885cd670d76a47e9", "html_url": "https://github.com/rust-lang/rust/commit/3ed8b698421291f5057059da885cd670d76a47e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ed8b698421291f5057059da885cd670d76a47e9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed1cffdb21220f633b8b91f099a69fab4ef2b8f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed1cffdb21220f633b8b91f099a69fab4ef2b8f4", "html_url": "https://github.com/rust-lang/rust/commit/ed1cffdb21220f633b8b91f099a69fab4ef2b8f4"}, {"sha": "9602fe1509f2d6ae274a42f61ca5b5cf0c3b9a6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9602fe1509f2d6ae274a42f61ca5b5cf0c3b9a6b", "html_url": "https://github.com/rust-lang/rust/commit/9602fe1509f2d6ae274a42f61ca5b5cf0c3b9a6b"}], "stats": {"total": 96, "additions": 92, "deletions": 4}, "files": [{"sha": "c3e8d0b7d95a8b31ca22b36dd8078bfd3fa078ec", "filename": "src/libstd/sys/unix/l4re.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ed8b698421291f5057059da885cd670d76a47e9/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed8b698421291f5057059da885cd670d76a47e9/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs?ref=3ed8b698421291f5057059da885cd670d76a47e9", "patch": "@@ -437,5 +437,9 @@ pub mod net {\n     pub fn lookup_host(_: &str) -> io::Result<LookupHost> {\n         unimpl!();\n     }\n+\n+    pub fn res_init_if_glibc_before_2_26() -> io::Result<()> {\n+        unimpl!();\n+    }\n }\n "}, {"sha": "c8019d1c768c5d7bdd34a9564baa139f54adf203", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/3ed8b698421291f5057059da885cd670d76a47e9/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed8b698421291f5057059da885cd670d76a47e9/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=3ed8b698421291f5057059da885cd670d76a47e9", "patch": "@@ -355,3 +355,82 @@ impl FromInner<c_int> for Socket {\n impl IntoInner<c_int> for Socket {\n     fn into_inner(self) -> c_int { self.0.into_raw() }\n }\n+\n+// In versions of glibc prior to 2.26, there's a bug where the DNS resolver\n+// will cache the contents of /etc/resolv.conf, so changes to that file on disk\n+// can be ignored by a long-running program. That can break DNS lookups on e.g.\n+// laptops where the network comes and goes. See\n+// https://sourceware.org/bugzilla/show_bug.cgi?id=984. Note however that some\n+// distros including Debian have patched glibc to fix this for a long time.\n+//\n+// A workaround for this bug is to call the res_init libc function, to clear\n+// the cached configs. Unfortunately, while we believe glibc's implementation\n+// of res_init is thread-safe, we know that other implementations are not\n+// (https://github.com/rust-lang/rust/issues/43592). Code here in libstd could\n+// try to synchronize its res_init calls with a Mutex, but that wouldn't\n+// protect programs that call into libc in other ways. So instead of calling\n+// res_init unconditionally, we call it only when we detect we're linking\n+// against glibc version < 2.26. (That is, when we both know its needed and\n+// believe it's thread-safe).\n+pub fn res_init_if_glibc_before_2_26() -> io::Result<()> {\n+    // If the version fails to parse, we treat it the same as \"not glibc\".\n+    if let Some(Ok(version_str)) = glibc_version_cstr().map(CStr::to_str) {\n+        if let Some(version) = parse_glibc_version(version_str) {\n+            if version < (2, 26) {\n+                let ret = unsafe { libc::res_init() };\n+                if ret != 0 {\n+                    return Err(io::Error::last_os_error());\n+                }\n+            }\n+        }\n+    }\n+    Ok(())\n+}\n+\n+fn glibc_version_cstr() -> Option<&'static CStr> {\n+    weak! {\n+        fn gnu_get_libc_version() -> *const libc::c_char\n+    }\n+    if let Some(f) = gnu_get_libc_version.get() {\n+        unsafe { Some(CStr::from_ptr(f())) }\n+    } else {\n+        None\n+    }\n+}\n+\n+// Returns Some((major, minor)) if the string is a valid \"x.y\" version,\n+// ignoring any extra dot-separated parts. Otherwise return None.\n+fn parse_glibc_version(version: &str) -> Option<(usize, usize)> {\n+    let mut parsed_ints = version.split(\".\").map(str::parse::<usize>).fuse();\n+    match (parsed_ints.next(), parsed_ints.next()) {\n+        (Some(Ok(major)), Some(Ok(minor))) => Some((major, minor)),\n+        _ => None\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn test_res_init() {\n+        // This mostly just tests that the weak linkage doesn't panic wildly...\n+        res_init_if_glibc_before_2_26().unwrap();\n+    }\n+\n+    #[test]\n+    fn test_parse_glibc_version() {\n+        let cases = [\n+            (\"0.0\", Some((0, 0))),\n+            (\"01.+2\", Some((1, 2))),\n+            (\"3.4.5.six\", Some((3, 4))),\n+            (\"1\", None),\n+            (\"1.-2\", None),\n+            (\"1.foo\", None),\n+            (\"foo.1\", None),\n+        ];\n+        for &(version_str, parsed) in cases.iter() {\n+            assert_eq!(parsed, parse_glibc_version(version_str));\n+        }\n+    }\n+}"}, {"sha": "c76b0bcf1c9ee2e09ccd239f686b26822ae3fd20", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3ed8b698421291f5057059da885cd670d76a47e9/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed8b698421291f5057059da885cd670d76a47e9/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=3ed8b698421291f5057059da885cd670d76a47e9", "patch": "@@ -175,10 +175,15 @@ pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n             },\n             #[cfg(unix)]\n             Err(e) => {\n-                // The lookup failure could be caused by using a stale /etc/resolv.conf.\n-                // See https://github.com/rust-lang/rust/issues/41570.\n-                // We therefore force a reload of the nameserver information.\n-                c::res_init();\n+                // If we're running glibc prior to version 2.26, the lookup\n+                // failure could be caused by caching a stale /etc/resolv.conf.\n+                // We need to call libc::res_init() to clear the cache. But we\n+                // shouldn't call it in on any other platform, because other\n+                // res_init implementations aren't thread-safe. See\n+                // https://github.com/rust-lang/rust/issues/41570 and\n+                // https://github.com/rust-lang/rust/issues/43592.\n+                use sys::net::res_init_if_glibc_before_2_26;\n+                let _ = res_init_if_glibc_before_2_26();\n                 Err(e)\n             },\n             // the cfg is needed here to avoid an \"unreachable pattern\" warning"}]}