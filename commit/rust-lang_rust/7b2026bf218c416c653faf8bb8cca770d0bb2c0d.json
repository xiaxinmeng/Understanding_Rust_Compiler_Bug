{"sha": "7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMjAyNmJmMjE4YzQxNmM2NTNmYWY4YmI4Y2NhNzcwZDBiYjJjMGQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-31T23:38:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-01T00:22:30Z"}, "message": "Introduce 'return', 'match' and 'module' as synonyms", "tree": {"sha": "9c09c3d7d1b1dcc2d12d11061bf5755727d83128", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c09c3d7d1b1dcc2d12d11061bf5755727d83128"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "html_url": "https://github.com/rust-lang/rust/commit/7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d18369804f23cd04d10f33e420fbcdc8ea76ecf", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d18369804f23cd04d10f33e420fbcdc8ea76ecf", "html_url": "https://github.com/rust-lang/rust/commit/7d18369804f23cd04d10f33e420fbcdc8ea76ecf"}], "stats": {"total": 668, "additions": 349, "deletions": 319}, "files": [{"sha": "d086d0834453c1847c451b5a7c0c1230c1f7888c", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -600,21 +600,21 @@ fn load_source_packages(c: cargo, src: source) {\n }\n \n fn build_cargo_options(argv: ~[~str]) -> options {\n-    let match = alt getopts::getopts(argv, opts()) {\n+    let matches = alt getopts::getopts(argv, opts()) {\n         result::ok(m) { m }\n         result::err(f) {\n             fail fmt!{\"%s\", getopts::fail_str(f)};\n         }\n     };\n \n-    let test = opt_present(match, ~\"test\");\n-    let G    = opt_present(match, ~\"G\");\n-    let g    = opt_present(match, ~\"g\");\n-    let help = opt_present(match, ~\"h\") || opt_present(match, ~\"help\");\n-    let len  = vec::len(match.free);\n+    let test = opt_present(matches, ~\"test\");\n+    let G    = opt_present(matches, ~\"G\");\n+    let g    = opt_present(matches, ~\"g\");\n+    let help = opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\");\n+    let len  = vec::len(matches.free);\n \n-    let is_install = len > 1u && match.free[1] == ~\"install\";\n-    let is_uninstall = len > 1u && match.free[1] == ~\"uninstall\";\n+    let is_install = len > 1u && matches.free[1] == ~\"install\";\n+    let is_uninstall = len > 1u && matches.free[1] == ~\"uninstall\";\n \n     if G && g { fail ~\"-G and -g both provided\"; }\n \n@@ -627,7 +627,7 @@ fn build_cargo_options(argv: ~[~str]) -> options {\n         else if G { system_mode }\n         else { local_mode };\n \n-    {test: test, mode: mode, free: match.free, help: help}\n+    {test: test, mode: mode, free: matches.free, help: help}\n }\n \n fn configure(opts: options) -> cargo {"}, {"sha": "42d69566152514f326015322ff601748efe1aff5", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -41,29 +41,29 @@ fn parse_config(args: ~[~str]) -> config {\n \n     assert (vec::is_not_empty(args));\n     let args_ = vec::tail(args);\n-    let match =\n+    let matches =\n         alt getopts::getopts(args_, opts) {\n           ok(m) { m }\n           err(f) { fail getopts::fail_str(f) }\n         };\n \n-    ret {compile_lib_path: getopts::opt_str(match, ~\"compile-lib-path\"),\n-         run_lib_path: getopts::opt_str(match, ~\"run-lib-path\"),\n-         rustc_path: getopts::opt_str(match, ~\"rustc-path\"),\n-         src_base: getopts::opt_str(match, ~\"src-base\"),\n-         build_base: getopts::opt_str(match, ~\"build-base\"),\n-         aux_base: getopts::opt_str(match, ~\"aux-base\"),\n-         stage_id: getopts::opt_str(match, ~\"stage-id\"),\n-         mode: str_mode(getopts::opt_str(match, ~\"mode\")),\n-         run_ignored: getopts::opt_present(match, ~\"ignored\"),\n+    ret {compile_lib_path: getopts::opt_str(matches, ~\"compile-lib-path\"),\n+         run_lib_path: getopts::opt_str(matches, ~\"run-lib-path\"),\n+         rustc_path: getopts::opt_str(matches, ~\"rustc-path\"),\n+         src_base: getopts::opt_str(matches, ~\"src-base\"),\n+         build_base: getopts::opt_str(matches, ~\"build-base\"),\n+         aux_base: getopts::opt_str(matches, ~\"aux-base\"),\n+         stage_id: getopts::opt_str(matches, ~\"stage-id\"),\n+         mode: str_mode(getopts::opt_str(matches, ~\"mode\")),\n+         run_ignored: getopts::opt_present(matches, ~\"ignored\"),\n          filter:\n-             if vec::len(match.free) > 0u {\n-                 option::some(match.free[0])\n+             if vec::len(matches.free) > 0u {\n+                 option::some(matches.free[0])\n              } else { option::none },\n-         logfile: getopts::opt_maybe_str(match, ~\"logfile\"),\n-         runtool: getopts::opt_maybe_str(match, ~\"runtool\"),\n-         rustcflags: getopts::opt_maybe_str(match, ~\"rustcflags\"),\n-         verbose: getopts::opt_present(match, ~\"verbose\")};\n+         logfile: getopts::opt_maybe_str(matches, ~\"logfile\"),\n+         runtool: getopts::opt_maybe_str(matches, ~\"runtool\"),\n+         rustcflags: getopts::opt_maybe_str(matches, ~\"rustcflags\"),\n+         verbose: getopts::opt_present(matches, ~\"verbose\")};\n }\n \n fn log_config(config: config) {"}, {"sha": "9db3d0bc2c4cf127b1c27801cce3f7b57338fae3", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -97,7 +97,7 @@ impl private_methods<A> for dvec<A> {\n     }\n \n     #[inline(always)]\n-    fn return(-data: ~[mut A]) {\n+    fn give_back(-data: ~[mut A]) {\n         unsafe {\n             self.data <- data;\n         }\n@@ -120,15 +120,15 @@ impl extensions<A> for dvec<A> {\n      */\n     #[inline(always)]\n     fn swap(f: fn(-~[mut A]) -> ~[mut A]) {\n-        self.borrow(|v| self.return(f(v)))\n+        self.borrow(|v| self.give_back(f(v)))\n     }\n \n     /// Returns the number of elements currently in the dvec\n     pure fn len() -> uint {\n         unchecked {\n             do self.borrow |v| {\n                 let l = v.len();\n-                self.return(v);\n+                self.give_back(v);\n                 l\n             }\n         }\n@@ -145,7 +145,7 @@ impl extensions<A> for dvec<A> {\n         do self.borrow |v| {\n             let mut v <- v;\n             let result = vec::pop(v);\n-            self.return(v);\n+            self.give_back(v);\n             result\n         }\n     }\n@@ -175,7 +175,7 @@ impl extensions<A> for dvec<A> {\n         do self.borrow |v| {\n             let mut v = vec::from_mut(v);\n             let result = vec::shift(v);\n-            self.return(vec::to_mut(v));\n+            self.give_back(vec::to_mut(v));\n             result\n         }\n     }\n@@ -247,7 +247,7 @@ impl extensions<A:copy> for dvec<A> {\n         unchecked {\n             do self.borrow |v| {\n                 let w = vec::from_mut(copy v);\n-                self.return(v);\n+                self.give_back(v);\n                 w\n             }\n         }"}, {"sha": "b8da3dcc38f7aaaee9525bf6c92b0cad3f4e7d3d", "filename": "src/libstd/list.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -192,18 +192,18 @@ mod tests {\n \n     #[test]\n     fn test_find_success() {\n-        fn match(&&i: int) -> bool { ret i == 2; }\n+        fn match_(&&i: int) -> bool { ret i == 2; }\n         let l = from_vec(~[0, 1, 2]);\n-        assert (list::find(l, match) == option::some(2));\n+        assert (list::find(l, match_) == option::some(2));\n     }\n \n     #[test]\n     fn test_find_fail() {\n-        fn match(&&_i: int) -> bool { ret false; }\n+        fn match_(&&_i: int) -> bool { ret false; }\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::nil::<int>;\n-        assert (list::find(l, match) == option::none::<int>);\n-        assert (list::find(empty, match) == option::none::<int>);\n+        assert (list::find(l, match_) == option::none::<int>);\n+        assert (list::find(empty, match_) == option::none::<int>);\n     }\n \n     #[test]"}, {"sha": "6a7b27a3b6baaed33f236f62bc23d262ad3037e9", "filename": "src/libstd/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -68,19 +68,19 @@ type opt_res = either<test_opts, ~str>;\n fn parse_opts(args: ~[~str]) -> opt_res {\n     let args_ = vec::tail(args);\n     let opts = ~[getopts::optflag(~\"ignored\"), getopts::optopt(~\"logfile\")];\n-    let match =\n+    let matches =\n         alt getopts::getopts(args_, opts) {\n           ok(m) { m }\n           err(f) { ret either::right(getopts::fail_str(f)) }\n         };\n \n     let filter =\n-        if vec::len(match.free) > 0u {\n-            option::some(match.free[0])\n+        if vec::len(matches.free) > 0u {\n+            option::some(matches.free[0])\n         } else { option::none };\n \n-    let run_ignored = getopts::opt_present(match, ~\"ignored\");\n-    let logfile = getopts::opt_maybe_str(match, ~\"logfile\");\n+    let run_ignored = getopts::opt_present(matches, ~\"ignored\");\n+    let logfile = getopts::opt_maybe_str(matches, ~\"logfile\");\n \n     let test_opts = {filter: filter, run_ignored: run_ignored,\n                      logfile: logfile};"}, {"sha": "62e5841a7493540ec7f545a0b1f7f7531b6b64f2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -129,17 +129,17 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n // NB: there is some redundancy between this and expand_item, below, and\n // they might benefit from some amount of semantic and language-UI merger.\n fn expand_mod_items(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n-                    module: ast::_mod, fld: ast_fold,\n+                    module_: ast::_mod, fld: ast_fold,\n                     orig: fn@(ast::_mod, ast_fold) -> ast::_mod)\n     -> ast::_mod\n {\n     // Fold the contents first:\n-    let module = orig(module, fld);\n+    let module_ = orig(module_, fld);\n \n     // For each item, look through the attributes.  If any of them are\n     // decorated with \"item decorators\", then use that function to transform\n     // the item into a new set of items.\n-    let new_items = do vec::flat_map(module.items) |item| {\n+    let new_items = do vec::flat_map(module_.items) |item| {\n         do vec::foldr(item.attrs, ~[item]) |attr, items| {\n             let mname = alt attr.node.value.node {\n               ast::meta_word(n) { n }\n@@ -159,7 +159,7 @@ fn expand_mod_items(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n         }\n     };\n \n-    ret {items: new_items with module};\n+    ret {items: new_items with module_};\n }\n \n "}, {"sha": "28ad7173be87333a8043441a2bfa70cb80c9f3fb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -789,7 +789,7 @@ class parser {\n             ret pexpr(self.parse_while_expr());\n         } else if self.eat_keyword(~\"loop\") {\n             ret pexpr(self.parse_loop_expr());\n-        } else if self.eat_keyword(~\"alt\") {\n+        } else if self.eat_keyword(~\"alt\") || self.eat_keyword(~\"match\") {\n             ret pexpr(self.parse_alt_expr());\n         } else if self.eat_keyword(~\"fn\") {\n             let proto = self.parse_fn_ty_proto();\n@@ -838,7 +838,7 @@ class parser {\n             let e = self.parse_expr();\n             ex = expr_assert(e);\n             hi = e.span.hi;\n-        } else if self.eat_keyword(~\"ret\") {\n+        } else if self.eat_keyword(~\"ret\") || self.eat_keyword(~\"return\") {\n             if can_begin_expr(self.token) {\n                 let e = self.parse_expr();\n                 hi = e.span.hi;\n@@ -2569,7 +2569,11 @@ class parser {\n     }\n \n     fn parse_item_foreign_mod() -> item_info {\n-        self.expect_keyword(~\"mod\");\n+        if self.is_keyword(~\"mod\") {\n+            self.expect_keyword(~\"mod\");\n+        } else {\n+            self.expect_keyword(~\"module\");\n+        }\n         let id = self.parse_ident();\n         self.expect(token::LBRACE);\n         let more_attrs = self.parse_inner_attrs_and_next();\n@@ -2714,7 +2718,7 @@ class parser {\n             } else {\n                 self.parse_item_foreign_mod()\n             }\n-        } else if self.eat_keyword(~\"mod\") {\n+        } else if self.eat_keyword(~\"mod\") || self.eat_keyword(~\"module\") {\n             self.parse_item_mod()\n         } else if self.eat_keyword(~\"type\") {\n             self.parse_item_type()\n@@ -2919,8 +2923,14 @@ class parser {\n         let expect_mod = vec::len(outer_attrs) > 0u;\n \n         let lo = self.span.lo;\n-        if expect_mod || self.is_keyword(~\"mod\") {\n-            self.expect_keyword(~\"mod\");\n+        if expect_mod || self.is_keyword(~\"mod\") ||\n+            self.is_keyword(~\"module\") {\n+\n+            if self.is_keyword(~\"mod\") {\n+                self.expect_keyword(~\"mod\");\n+            } else {\n+                self.expect_keyword(~\"module\");\n+            }\n             let id = self.parse_ident();\n             alt self.token {\n               // mod x = \"foo.rs\";\n@@ -2958,7 +2968,11 @@ class parser {\n         // accept seeing the terminator next, so if we do see it then fail the\n         // same way parse_crate_directive would\n         if vec::len(first_outer_attr) > 0u && self.token == term {\n-            self.expect_keyword(~\"mod\");\n+            if self.is_keyword(~\"mod\") {\n+                self.expect_keyword(~\"mod\");\n+            } else {\n+                self.expect_keyword(~\"module\");\n+            }\n         }\n \n         let mut cdirs: ~[@crate_directive] = ~[];"}, {"sha": "e4386ab140fffa58e5caed2b42dd156e75d1fb51", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -327,11 +327,11 @@ fn restricted_keyword_table() -> hashmap<~str, ()> {\n         ~\"fail\", ~\"false\", ~\"fn\", ~\"for\",\n         ~\"if\", ~\"iface\", ~\"impl\", ~\"import\",\n         ~\"let\", ~\"log\", ~\"loop\",\n-        ~\"mod\", ~\"mut\",\n+        ~\"match\", ~\"mod\", ~\"module\", ~\"mut\",\n         ~\"new\",\n         ~\"owned\",\n         ~\"pure\",\n-        ~\"ret\",\n+        ~\"ret\", ~\"return\",\n         ~\"struct\",\n         ~\"true\", ~\"trait\", ~\"type\",\n         ~\"unchecked\", ~\"unsafe\","}, {"sha": "f109e28cd594238357b2496d8eb97c56ed643205", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -408,19 +408,19 @@ fn host_triple() -> ~str {\n         };\n }\n \n-fn build_session_options(match: getopts::matches,\n+fn build_session_options(matches: getopts::matches,\n                          demitter: diagnostic::emitter) -> @session::options {\n-    let crate_type = if opt_present(match, ~\"lib\") {\n+    let crate_type = if opt_present(matches, ~\"lib\") {\n         session::lib_crate\n-    } else if opt_present(match, ~\"bin\") {\n+    } else if opt_present(matches, ~\"bin\") {\n         session::bin_crate\n     } else {\n         session::unknown_crate\n     };\n-    let static = opt_present(match, ~\"static\");\n+    let static = opt_present(matches, ~\"static\");\n \n-    let parse_only = opt_present(match, ~\"parse-only\");\n-    let no_trans = opt_present(match, ~\"no-trans\");\n+    let parse_only = opt_present(matches, ~\"parse-only\");\n+    let no_trans = opt_present(matches, ~\"no-trans\");\n \n     let lint_levels = [lint::allow, lint::warn,\n                        lint::deny, lint::forbid];\n@@ -429,8 +429,8 @@ fn build_session_options(match: getopts::matches,\n     for lint_levels.each |level| {\n         let level_name = lint::level_to_str(level);\n         let level_short = level_name.substr(0,1).to_upper();\n-        let flags = vec::append(getopts::opt_strs(match, level_short),\n-                                getopts::opt_strs(match, level_name));\n+        let flags = vec::append(getopts::opt_strs(matches, level_short),\n+                                getopts::opt_strs(matches, level_name));\n         for flags.each |lint_name| {\n             let lint_name = str::replace(lint_name, ~\"-\", ~\"_\");\n             alt lint_dict.find(lint_name) {\n@@ -446,7 +446,7 @@ fn build_session_options(match: getopts::matches,\n     }\n \n     let mut debugging_opts = 0u;\n-    let debug_flags = getopts::opt_strs(match, ~\"Z\");\n+    let debug_flags = getopts::opt_strs(matches, ~\"Z\");\n     let debug_map = session::debugging_opts_map();\n     for debug_flags.each |debug_flag| {\n         let mut this_bit = 0u;\n@@ -466,34 +466,34 @@ fn build_session_options(match: getopts::matches,\n     let output_type =\n         if parse_only || no_trans {\n             link::output_type_none\n-        } else if opt_present(match, ~\"S\") &&\n-                  opt_present(match, ~\"emit-llvm\") {\n+        } else if opt_present(matches, ~\"S\") &&\n+                  opt_present(matches, ~\"emit-llvm\") {\n             link::output_type_llvm_assembly\n-        } else if opt_present(match, ~\"S\") {\n+        } else if opt_present(matches, ~\"S\") {\n             link::output_type_assembly\n-        } else if opt_present(match, ~\"c\") {\n+        } else if opt_present(matches, ~\"c\") {\n             link::output_type_object\n-        } else if opt_present(match, ~\"emit-llvm\") {\n+        } else if opt_present(matches, ~\"emit-llvm\") {\n             link::output_type_bitcode\n         } else { link::output_type_exe };\n-    let extra_debuginfo = opt_present(match, ~\"xg\");\n-    let debuginfo = opt_present(match, ~\"g\") || extra_debuginfo;\n-    let sysroot_opt = getopts::opt_maybe_str(match, ~\"sysroot\");\n-    let target_opt = getopts::opt_maybe_str(match, ~\"target\");\n-    let save_temps = getopts::opt_present(match, ~\"save-temps\");\n+    let extra_debuginfo = opt_present(matches, ~\"xg\");\n+    let debuginfo = opt_present(matches, ~\"g\") || extra_debuginfo;\n+    let sysroot_opt = getopts::opt_maybe_str(matches, ~\"sysroot\");\n+    let target_opt = getopts::opt_maybe_str(matches, ~\"target\");\n+    let save_temps = getopts::opt_present(matches, ~\"save-temps\");\n     alt output_type {\n       // unless we're emitting huamn-readable assembly, omit comments.\n       link::output_type_llvm_assembly | link::output_type_assembly {}\n       _ { debugging_opts |= session::no_asm_comments; }\n     }\n     let opt_level: uint =\n-        if opt_present(match, ~\"O\") {\n-            if opt_present(match, ~\"opt-level\") {\n+        if opt_present(matches, ~\"O\") {\n+            if opt_present(matches, ~\"opt-level\") {\n                 early_error(demitter, ~\"-O and --opt-level both provided\");\n             }\n             2u\n-        } else if opt_present(match, ~\"opt-level\") {\n-            alt getopts::opt_str(match, ~\"opt-level\") {\n+        } else if opt_present(matches, ~\"opt-level\") {\n+            alt getopts::opt_str(matches, ~\"opt-level\") {\n               ~\"0\" { 0u }\n               ~\"1\" { 1u }\n               ~\"2\" { 2u }\n@@ -510,9 +510,9 @@ fn build_session_options(match: getopts::matches,\n             some(s) { s }\n         };\n \n-    let addl_lib_search_paths = getopts::opt_strs(match, ~\"L\");\n-    let cfg = parse_cfgspecs(getopts::opt_strs(match, ~\"cfg\"));\n-    let test = opt_present(match, ~\"test\");\n+    let addl_lib_search_paths = getopts::opt_strs(matches, ~\"L\");\n+    let cfg = parse_cfgspecs(getopts::opt_strs(matches, ~\"cfg\"));\n+    let test = opt_present(matches, ~\"test\");\n     let sopts: @session::options =\n         @{crate_type: crate_type,\n           static: static,\n@@ -719,13 +719,13 @@ mod test {\n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test() {\n-        let match =\n+        let matches =\n             alt getopts::getopts(~[~\"--test\"], opts()) {\n               ok(m) { m }\n               err(f) { fail ~\"test_switch_implies_cfg_test: \" +\n                        getopts::fail_str(f); }\n             };\n-        let sessopts = build_session_options(match, diagnostic::emit);\n+        let sessopts = build_session_options(matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n         let cfg = build_configuration(sess, ~\"whatever\", str_input(~\"\"));\n         assert (attr::contains_name(cfg, ~\"test\"));\n@@ -735,15 +735,15 @@ mod test {\n     // another --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n-        let match =\n+        let matches =\n             alt getopts::getopts(~[~\"--test\", ~\"--cfg=test\"], opts()) {\n               ok(m) { m }\n               err(f) {\n                 fail ~\"test_switch_implies_cfg_test_unless_cfg_test: \" +\n                     getopts::fail_str(f);\n               }\n             };\n-        let sessopts = build_session_options(match, diagnostic::emit);\n+        let sessopts = build_session_options(matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n         let cfg = build_configuration(sess, ~\"whatever\", str_input(~\"\"));\n         let test_items = attr::find_meta_items_by_name(cfg, ~\"test\");"}, {"sha": "dfc946a036a753ebbf75a2aa73466a63828d6ba5", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -128,39 +128,39 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n \n     if vec::len(args) == 0u { usage(binary); ret; }\n \n-    let match =\n+    let matches =\n         alt getopts::getopts(args, opts()) {\n           ok(m) { m }\n           err(f) {\n             early_error(demitter, getopts::fail_str(f))\n           }\n         };\n \n-    if opt_present(match, ~\"h\") || opt_present(match, ~\"help\") {\n+    if opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\") {\n         usage(binary);\n         ret;\n     }\n \n-    let lint_flags = vec::append(getopts::opt_strs(match, ~\"W\"),\n-                                 getopts::opt_strs(match, ~\"warn\"));\n+    let lint_flags = vec::append(getopts::opt_strs(matches, ~\"W\"),\n+                                 getopts::opt_strs(matches, ~\"warn\"));\n     if lint_flags.contains(~\"help\") {\n         describe_warnings();\n         ret;\n     }\n \n-    if getopts::opt_strs(match, ~\"Z\").contains(~\"help\") {\n+    if getopts::opt_strs(matches, ~\"Z\").contains(~\"help\") {\n         describe_debug_flags();\n         ret;\n     }\n \n-    if opt_present(match, ~\"v\") || opt_present(match, ~\"version\") {\n+    if opt_present(matches, ~\"v\") || opt_present(matches, ~\"version\") {\n         version(binary);\n         ret;\n     }\n-    let input = alt vec::len(match.free) {\n+    let input = alt vec::len(matches.free) {\n       0u { early_error(demitter, ~\"no input filename given\") }\n       1u {\n-        let ifile = match.free[0];\n+        let ifile = matches.free[0];\n         if ifile == ~\"-\" {\n             let src = str::from_bytes(io::stdin().read_whole_stream());\n             str_input(src)\n@@ -171,20 +171,20 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n       _ { early_error(demitter, ~\"multiple input filenames provided\") }\n     };\n \n-    let sopts = build_session_options(match, demitter);\n+    let sopts = build_session_options(matches, demitter);\n     let sess = build_session(sopts, demitter);\n-    let odir = getopts::opt_maybe_str(match, ~\"out-dir\");\n-    let ofile = getopts::opt_maybe_str(match, ~\"o\");\n+    let odir = getopts::opt_maybe_str(matches, ~\"out-dir\");\n+    let ofile = getopts::opt_maybe_str(matches, ~\"o\");\n     let cfg = build_configuration(sess, binary, input);\n     let pretty =\n-        option::map(getopts::opt_default(match, ~\"pretty\",\n+        option::map(getopts::opt_default(matches, ~\"pretty\",\n                                          ~\"normal\"),\n                     |a| parse_pretty(sess, a) );\n     alt pretty {\n       some::<pp_mode>(ppm) { pretty_print_input(sess, cfg, input, ppm); ret; }\n       none::<pp_mode> {/* continue */ }\n     }\n-    let ls = opt_present(match, ~\"ls\");\n+    let ls = opt_present(matches, ~\"ls\");\n     if ls {\n         alt input {\n           file_input(ifile) {"}, {"sha": "d0f8ac2747da1279a9eff41cf84b1527e40627cd", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -78,10 +78,10 @@ fn warn_if_multiple_versions(diag: span_handler,\n         if matches.len() != 1u {\n             diag.handler().warn(\n                 fmt!{\"using multiple versions of crate `%s`\", *name});\n-            for matches.each |match| {\n-                diag.span_note(match.span, ~\"used here\");\n+            for matches.each |match_| {\n+                diag.span_note(match_.span, ~\"used here\");\n                 let attrs = ~[\n-                    attr::mk_attr(attr::mk_list_item(@~\"link\", *match.metas))\n+                    attr::mk_attr(attr::mk_list_item(@~\"link\", *match_.metas))\n                 ];\n                 loader::note_linkage_attrs(diag, attrs);\n             }"}, {"sha": "c82869d164ca74ed1e4a2f4be92966717fc9b3da", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -157,11 +157,11 @@ fn encode_class_item_paths(ebml_w: ebml::writer,\n }\n \n fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n-                            module: _mod, path: ~[ident],\n+                            module_: _mod, path: ~[ident],\n                             &index: ~[entry<~str>]) {\n-    for module.items.each |it| {\n+    for module_.items.each |it| {\n         if !reachable(ecx, it.id) ||\n-           !ast_util::is_exported(it.ident, module) { again; }\n+           !ast_util::is_exported(it.ident, module_) { again; }\n         if !ast_util::is_item_impl(it) {\n             add_to_index(ebml_w, path, index, it.ident);\n         }"}, {"sha": "12d47cb86cf07a14ee4a8ccfeeab24dbcace513c", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -106,9 +106,9 @@ fn find_library_crate_aux(cx: ctxt,\n         cx.diag.span_err(\n             cx.span, fmt!{\"multiple matching crates for `%s`\", *crate_name});\n         cx.diag.handler().note(~\"candidates:\");\n-        for matches.each |match| {\n-            cx.diag.handler().note(fmt!{\"path: %s\", match.ident});\n-            let attrs = decoder::get_crate_attributes(match.data);\n+        for matches.each |match_| {\n+            cx.diag.handler().note(fmt!{\"path: %s\", match_.ident});\n+            let attrs = decoder::get_crate_attributes(match_.data);\n             note_linkage_attrs(cx.diag, attrs);\n         }\n         cx.diag.handler().abort_if_errors();"}, {"sha": "4d62f2818ee461abbc787840b5b1e72ac7893907", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -332,13 +332,13 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n       pat_box(a) | pat_uniq(a) { some(vec::append(~[a], vec::tail(r))) }\n       pat_lit(expr) {\n         let e_v = eval_const_expr(tcx, expr);\n-        let match = alt check ctor_id {\n+        let match_ = alt check ctor_id {\n           val(v) { compare_const_vals(e_v, v) == 0 }\n           range(c_lo, c_hi) { compare_const_vals(c_lo, e_v) >= 0 &&\n                               compare_const_vals(c_hi, e_v) <= 0 }\n           single { true }\n         };\n-        if match { some(vec::tail(r)) } else { none }\n+        if match_ { some(vec::tail(r)) } else { none }\n       }\n       pat_range(lo, hi) {\n         let (c_lo, c_hi) = alt check ctor_id {\n@@ -348,9 +348,9 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         };\n         let v_lo = eval_const_expr(tcx, lo),\n             v_hi = eval_const_expr(tcx, hi);\n-        let match = compare_const_vals(c_lo, v_lo) >= 0 &&\n+        let match_ = compare_const_vals(c_lo, v_lo) >= 0 &&\n                     compare_const_vals(c_hi, v_hi) <= 0;\n-        if match { some(vec::tail(r)) } else { none }\n+        if match_ { some(vec::tail(r)) } else { none }\n       }\n     }\n }"}, {"sha": "b4237d3e841a35f8a70ec71f736cbb78b9d25619", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 166, "deletions": 166, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -495,8 +495,8 @@ class NameBindings {\n     /// Creates a new module in this set of name bindings.\n     fn define_module(parent_link: ParentLink, def_id: option<def_id>) {\n         if self.module_def == NoModuleDef {\n-            let module = @Module(parent_link, def_id);\n-            self.module_def = ModuleDef(module);\n+            let module_ = @Module(parent_link, def_id);\n+            self.module_def = ModuleDef(module_);\n         }\n     }\n \n@@ -519,7 +519,7 @@ class NameBindings {\n     fn get_module_if_available() -> option<@Module> {\n         alt self.module_def {\n             NoModuleDef         { ret none;         }\n-            ModuleDef(module)   { ret some(module); }\n+            ModuleDef(module_)   { ret some(module_); }\n         }\n     }\n \n@@ -533,8 +533,8 @@ class NameBindings {\n                 fail\n                     ~\"get_module called on a node with no module definition!\";\n             }\n-            ModuleDef(module) {\n-                ret module;\n+            ModuleDef(module_) {\n+                ret module_;\n             }\n         }\n     }\n@@ -561,8 +561,8 @@ class NameBindings {\n                     NoModuleDef {\n                         ret none;\n                     }\n-                    ModuleDef(module) {\n-                        alt module.def_id {\n+                    ModuleDef(module_) {\n+                        alt module_.def_id {\n                             none {\n                                 ret none;\n                             }\n@@ -765,8 +765,8 @@ class Resolver {\n     fn get_module_from_parent(reduced_graph_parent: ReducedGraphParent)\n                            -> @Module {\n         alt reduced_graph_parent {\n-            ModuleReducedGraphParent(module) {\n-                ret module;\n+            ModuleReducedGraphParent(module_) {\n+                ret module_;\n             }\n         }\n     }\n@@ -789,19 +789,19 @@ class Resolver {\n         // child name directly. Otherwise, we create or reuse an anonymous\n         // module and add the child to that.\n \n-        let mut module;\n+        let mut module_;\n         alt reduced_graph_parent {\n             ModuleReducedGraphParent(parent_module) {\n-                module = parent_module;\n+                module_ = parent_module;\n             }\n         }\n \n         // Add or reuse the child.\n-        let new_parent = ModuleReducedGraphParent(module);\n-        alt module.children.find(name) {\n+        let new_parent = ModuleReducedGraphParent(module_);\n+        alt module_.children.find(name) {\n             none {\n                 let child = @NameBindings();\n-                module.children.insert(name, child);\n+                module_.children.insert(name, child);\n                 ret (child, new_parent);\n             }\n             some(child) {\n@@ -843,8 +843,8 @@ class Resolver {\n \n     fn get_parent_link(parent: ReducedGraphParent, name: Atom) -> ParentLink {\n         alt parent {\n-            ModuleReducedGraphParent(module) {\n-                ret ModuleParentLink(module, name);\n+            ModuleReducedGraphParent(module_) {\n+                ret ModuleParentLink(module_, name);\n             }\n         }\n     }\n@@ -858,15 +858,15 @@ class Resolver {\n         let (name_bindings, new_parent) = self.add_child(atom, parent);\n \n         alt item.node {\n-            item_mod(module) {\n+            item_mod(module_) {\n                 let parent_link = self.get_parent_link(new_parent, atom);\n                 let def_id = { crate: 0, node: item.id };\n                 (*name_bindings).define_module(parent_link, some(def_id));\n \n                 let new_parent =\n                     ModuleReducedGraphParent((*name_bindings).get_module());\n \n-                visit_mod(module, item.span, item.id, new_parent, visitor);\n+                visit_mod(module_, item.span, item.id, new_parent, visitor);\n             }\n             item_foreign_mod(foreign_module) {\n                 let parent_link = self.get_parent_link(new_parent, atom);\n@@ -1074,7 +1074,7 @@ class Resolver {\n                     }\n \n                     // Build up the import directives.\n-                    let module = self.get_module_from_parent(parent);\n+                    let module_ = self.get_module_from_parent(parent);\n                     alt view_path.node {\n                         view_path_simple(binding, full_path, _) {\n                             let target_atom =\n@@ -1084,7 +1084,7 @@ class Resolver {\n                                 (*self.atom_table).intern(source_ident);\n                             let subclass = @SingleImport(target_atom,\n                                                          source_atom);\n-                            self.build_import_directive(module,\n+                            self.build_import_directive(module_,\n                                                         module_path,\n                                                         subclass,\n                                                         view_path.span);\n@@ -1094,14 +1094,14 @@ class Resolver {\n                                 let name = source_ident.node.name;\n                                 let atom = (*self.atom_table).intern(name);\n                                 let subclass = @SingleImport(atom, atom);\n-                                self.build_import_directive(module,\n+                                self.build_import_directive(module_,\n                                                             module_path,\n                                                             subclass,\n                                                             view_path.span);\n                             }\n                         }\n                         view_path_glob(_, _) {\n-                            self.build_import_directive(module,\n+                            self.build_import_directive(module_,\n                                                         module_path,\n                                                         @GlobImport,\n                                                         view_path.span);\n@@ -1111,7 +1111,7 @@ class Resolver {\n             }\n \n             view_item_export(view_paths) {\n-                let module = self.get_module_from_parent(parent);\n+                let module_ = self.get_module_from_parent(parent);\n                 for view_paths.each |view_path| {\n                     alt view_path.node {\n                         view_path_simple(ident, full_path, ident_id) {\n@@ -1130,7 +1130,7 @@ class Resolver {\n                             }\n \n                             let atom = (*self.atom_table).intern(ident);\n-                            module.exported_names.insert(atom, ident_id);\n+                            module_.exported_names.insert(atom, ident_id);\n                         }\n \n                         view_path_glob(*) {\n@@ -1162,7 +1162,7 @@ class Resolver {\n                                     let atom = (*self.atom_table).intern\n                                         (path_list_ident.node.name);\n                                     let id = path_list_ident.node.id;\n-                                    module.exported_names.insert(atom, id);\n+                                    module_.exported_names.insert(atom, id);\n                                 }\n                             }\n                         }\n@@ -1360,12 +1360,12 @@ class Resolver {\n                                         }\n                                     }\n                                 }\n-                                ModuleDef(module) {\n+                                ModuleDef(module_) {\n                                     debug!{\"(building reduced graph for \\\n                                             external crate) already created \\\n                                             module\"};\n-                                    module.def_id = some(def_id);\n-                                    modules.insert(def_id, module);\n+                                    module_.def_id = some(def_id);\n+                                    modules.insert(def_id, module_);\n                                 }\n                             }\n                         }\n@@ -1446,11 +1446,11 @@ class Resolver {\n         self.build_reduced_graph_for_impls_in_external_module_subtree(root);\n     }\n \n-    fn build_reduced_graph_for_impls_in_external_module_subtree(module:\n+    fn build_reduced_graph_for_impls_in_external_module_subtree(module_:\n                                                                 @Module) {\n-        self.build_reduced_graph_for_impls_in_external_module(module);\n+        self.build_reduced_graph_for_impls_in_external_module(module_);\n \n-        for module.children.each |_name, child_node| {\n+        for module_.children.each |_name, child_node| {\n             alt (*child_node).get_module_if_available() {\n                 none {\n                     // Nothing to do.\n@@ -1464,7 +1464,7 @@ class Resolver {\n         }\n     }\n \n-    fn build_reduced_graph_for_impls_in_external_module(module: @Module) {\n+    fn build_reduced_graph_for_impls_in_external_module(module_: @Module) {\n         // XXX: This is really unfortunate. decoder::each_path can produce\n         // false positives, since, in the crate metadata, a trait named 'bar'\n         // in module 'foo' defining a method named 'baz' will result in the\n@@ -1475,14 +1475,14 @@ class Resolver {\n \n         debug!{\"(building reduced graph for impls in external crate) looking \\\n                 for impls in `%s` (%?)\",\n-               self.module_to_str(module),\n-               copy module.def_id};\n+               self.module_to_str(module_),\n+               copy module_.def_id};\n \n-        alt module.def_id {\n+        alt module_.def_id {\n             none {\n                 debug!{\"(building reduced graph for impls in external \\\n                         module) no def ID for `%s`, skipping\",\n-                       self.module_to_str(module)};\n+                       self.module_to_str(module_)};\n                 ret;\n             }\n             some(_) {\n@@ -1491,7 +1491,7 @@ class Resolver {\n         }\n \n         let impls_in_module = get_impls_for_mod(self.session.cstore,\n-                                                get(module.def_id),\n+                                                get(module_.def_id),\n                                                 none);\n \n         // Intern def IDs to prevent duplicates.\n@@ -1507,47 +1507,47 @@ class Resolver {\n                     added impl `%s` (%?) to `%s`\",\n                    *implementation.ident,\n                    implementation.did,\n-                   self.module_to_str(module)};\n+                   self.module_to_str(module_)};\n \n             let name = (*self.atom_table).intern(implementation.ident);\n \n             let (name_bindings, _) =\n-                self.add_child(name, ModuleReducedGraphParent(module));\n+                self.add_child(name, ModuleReducedGraphParent(module_));\n \n             name_bindings.impl_defs += ~[implementation];\n         }\n     }\n \n     /// Creates and adds an import directive to the given module.\n-    fn build_import_directive(module: @Module,\n+    fn build_import_directive(module_: @Module,\n                               module_path: @dvec<Atom>,\n                               subclass: @ImportDirectiveSubclass,\n                               span: span) {\n \n         let directive = @ImportDirective(module_path, subclass, span);\n-        module.imports.push(directive);\n+        module_.imports.push(directive);\n \n         // Bump the reference count on the name. Or, if this is a glob, set\n         // the appropriate flag.\n \n         alt *subclass {\n             SingleImport(target, _) {\n-                alt module.import_resolutions.find(target) {\n+                alt module_.import_resolutions.find(target) {\n                     some(resolution) {\n                         resolution.outstanding_references += 1u;\n                     }\n                     none {\n                         let resolution = @ImportResolution(span);\n                         resolution.outstanding_references = 1u;\n-                        module.import_resolutions.insert(target, resolution);\n+                        module_.import_resolutions.insert(target, resolution);\n                     }\n                 }\n             }\n             GlobImport {\n                 // Set the glob flag. This tells us that we don't know the\n                 // module's exports ahead of time.\n \n-                module.glob_count += 1u;\n+                module_.glob_count += 1u;\n             }\n         }\n \n@@ -1596,12 +1596,12 @@ class Resolver {\n      * Attempts to resolve imports for the given module and all of its\n      * submodules.\n      */\n-    fn resolve_imports_for_module_subtree(module: @Module) {\n+    fn resolve_imports_for_module_subtree(module_: @Module) {\n         debug!{\"(resolving imports for module subtree) resolving %s\",\n-               self.module_to_str(module)};\n-        self.resolve_imports_for_module(module);\n+               self.module_to_str(module_)};\n+        self.resolve_imports_for_module(module_);\n \n-        for module.children.each |_name, child_node| {\n+        for module_.children.each |_name, child_node| {\n             alt (*child_node).get_module_if_available() {\n                 none {\n                     // Nothing to do.\n@@ -1612,25 +1612,25 @@ class Resolver {\n             }\n         }\n \n-        for module.anonymous_children.each |_block_id, child_module| {\n+        for module_.anonymous_children.each |_block_id, child_module| {\n             self.resolve_imports_for_module_subtree(child_module);\n         }\n     }\n \n     /// Attempts to resolve imports for the given module only.\n-    fn resolve_imports_for_module(module: @Module) {\n-        if (*module).all_imports_resolved() {\n+    fn resolve_imports_for_module(module_: @Module) {\n+        if (*module_).all_imports_resolved() {\n             debug!{\"(resolving imports for module) all imports resolved for \\\n                    %s\",\n-                   self.module_to_str(module)};\n+                   self.module_to_str(module_)};\n             ret;\n         }\n \n-        let import_count = module.imports.len();\n-        while module.resolved_import_count < import_count {\n-            let import_index = module.resolved_import_count;\n-            let import_directive = module.imports.get_elt(import_index);\n-            alt self.resolve_import_for_module(module, import_directive) {\n+        let import_count = module_.imports.len();\n+        while module_.resolved_import_count < import_count {\n+            let import_index = module_.resolved_import_count;\n+            let import_directive = module_.imports.get_elt(import_index);\n+            alt self.resolve_import_for_module(module_, import_directive) {\n                 Failed {\n                     // We presumably emitted an error. Continue.\n                     self.session.span_err(import_directive.span,\n@@ -1645,7 +1645,7 @@ class Resolver {\n                 }\n             }\n \n-            module.resolved_import_count += 1u;\n+            module_.resolved_import_count += 1u;\n         }\n     }\n \n@@ -1656,7 +1656,7 @@ class Resolver {\n      * currently-unresolved imports, or success if we know the name exists.\n      * If successful, the resolved bindings are written into the module.\n      */\n-    fn resolve_import_for_module(module: @Module,\n+    fn resolve_import_for_module(module_: @Module,\n                                  import_directive: @ImportDirective)\n                               -> ResolveResult<()> {\n \n@@ -1666,18 +1666,18 @@ class Resolver {\n         debug!{\"(resolving import for module) resolving import `%s::...` in \\\n                 `%s`\",\n                *(*self.atom_table).atoms_to_str((*module_path).get()),\n-               self.module_to_str(module)};\n+               self.module_to_str(module_)};\n \n         // One-level renaming imports of the form `import foo = bar;` are\n         // handled specially.\n \n         if (*module_path).len() == 0u {\n             resolution_result =\n-                self.resolve_one_level_renaming_import(module,\n+                self.resolve_one_level_renaming_import(module_,\n                                                        import_directive);\n         } else {\n             // First, resolve the module path for the directive, if necessary.\n-            alt self.resolve_module_path_for_import(module,\n+            alt self.resolve_module_path_for_import(module_,\n                                                     module_path,\n                                                     NoXray,\n                                                     import_directive.span) {\n@@ -1695,15 +1695,15 @@ class Resolver {\n                     alt *import_directive.subclass {\n                         SingleImport(target, source) {\n                             resolution_result =\n-                                self.resolve_single_import(module,\n+                                self.resolve_single_import(module_,\n                                                            containing_module,\n                                                            target,\n                                                            source);\n                         }\n                         GlobImport {\n                             let span = import_directive.span;\n                             resolution_result =\n-                                self.resolve_glob_import(module,\n+                                self.resolve_glob_import(module_,\n                                                          containing_module,\n                                                          span);\n                         }\n@@ -1731,8 +1731,8 @@ class Resolver {\n         if resolution_result != Indeterminate {\n             alt *import_directive.subclass {\n                 GlobImport {\n-                    assert module.glob_count >= 1u;\n-                    module.glob_count -= 1u;\n+                    assert module_.glob_count >= 1u;\n+                    module_.glob_count -= 1u;\n                 }\n                 SingleImport(*) {\n                     // Ignore.\n@@ -1743,7 +1743,7 @@ class Resolver {\n         ret resolution_result;\n     }\n \n-    fn resolve_single_import(module: @Module, containing_module: @Module,\n+    fn resolve_single_import(module_: @Module, containing_module: @Module,\n                              target: Atom, source: Atom)\n                           -> ResolveResult<()> {\n \n@@ -1752,7 +1752,7 @@ class Resolver {\n                *(*self.atom_table).atom_to_str(target),\n                self.module_to_str(containing_module),\n                *(*self.atom_table).atom_to_str(source),\n-               self.module_to_str(module)};\n+               self.module_to_str(module_)};\n \n         if !self.name_is_exported(containing_module, source) {\n             debug!{\"(resolving single import) name `%s` is unexported\",\n@@ -1903,8 +1903,8 @@ class Resolver {\n         }\n \n         // We've successfully resolved the import. Write the results in.\n-        assert module.import_resolutions.contains_key(target);\n-        let import_resolution = module.import_resolutions.get(target);\n+        assert module_.import_resolutions.contains_key(target);\n+        let import_resolution = module_.import_resolutions.get(target);\n \n         alt module_result {\n             BoundResult(target_module, name_bindings) {\n@@ -1974,7 +1974,7 @@ class Resolver {\n      * succeeds or bails out (as importing * from an empty module or a module\n      * that exports nothing is valid).\n      */\n-    fn resolve_glob_import(module: @Module,\n+    fn resolve_glob_import(module_: @Module,\n                            containing_module: @Module,\n                            span: span)\n                         -> ResolveResult<()> {\n@@ -2007,10 +2007,10 @@ class Resolver {\n             debug!{\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n                    is_none(target_import_resolution.module_target),\n-                   self.module_to_str(module)};\n+                   self.module_to_str(module_)};\n \n             // Here we merge two import resolutions.\n-            alt module.import_resolutions.find(atom) {\n+            alt module_.import_resolutions.find(atom) {\n                 none {\n                     // Simple: just copy the old import resolution.\n                     let new_import_resolution =\n@@ -2024,7 +2024,7 @@ class Resolver {\n                     new_import_resolution.impl_target =\n                         copy target_import_resolution.impl_target;\n \n-                    module.import_resolutions.insert\n+                    module_.import_resolutions.insert\n                         (atom, new_import_resolution);\n                 }\n                 some(dest_import_resolution) {\n@@ -2082,11 +2082,11 @@ class Resolver {\n             }\n \n             let mut dest_import_resolution;\n-            alt module.import_resolutions.find(atom) {\n+            alt module_.import_resolutions.find(atom) {\n                 none {\n                     // Create a new import resolution from this child.\n                     dest_import_resolution = @ImportResolution(span);\n-                    module.import_resolutions.insert\n+                    module_.import_resolutions.insert\n                         (atom, dest_import_resolution);\n                 }\n                 some(existing_import_resolution) {\n@@ -2099,7 +2099,7 @@ class Resolver {\n                     to `%s`\",\n                    *(*self.atom_table).atom_to_str(atom),\n                    self.module_to_str(containing_module),\n-                   self.module_to_str(module)};\n+                   self.module_to_str(module_)};\n \n             // Merge the child item into the import resolution.\n             if (*name_bindings).defined_in_namespace(ModuleNS) {\n@@ -2128,14 +2128,14 @@ class Resolver {\n         ret Success(());\n     }\n \n-    fn resolve_module_path_from_root(module: @Module,\n+    fn resolve_module_path_from_root(module_: @Module,\n                                      module_path: @dvec<Atom>,\n                                      index: uint,\n                                      xray: XrayFlag,\n                                      span: span)\n                                   -> ResolveResult<@Module> {\n \n-        let mut search_module = module;\n+        let mut search_module = module_;\n         let mut index = index;\n         let module_path_len = (*module_path).len();\n \n@@ -2168,8 +2168,8 @@ class Resolver {\n                                                          atom_to_str(name)});\n                             ret Failed;\n                         }\n-                        ModuleDef(module) {\n-                            search_module = module;\n+                        ModuleDef(module_) {\n+                            search_module = module_;\n                         }\n                     }\n                 }\n@@ -2185,7 +2185,7 @@ class Resolver {\n      * Attempts to resolve the module part of an import directive rooted at\n      * the given module.\n      */\n-    fn resolve_module_path_for_import(module: @Module,\n+    fn resolve_module_path_for_import(module_: @Module,\n                                       module_path: @dvec<Atom>,\n                                       xray: XrayFlag,\n                                       span: span)\n@@ -2197,14 +2197,14 @@ class Resolver {\n         debug!{\"(resolving module path for import) processing `%s` rooted at \\\n                `%s`\",\n                *(*self.atom_table).atoms_to_str((*module_path).get()),\n-               self.module_to_str(module)};\n+               self.module_to_str(module_)};\n \n         // The first element of the module path must be in the current scope\n         // chain.\n \n         let first_element = (*module_path).get_elt(0u);\n         let mut search_module;\n-        alt self.resolve_module_in_lexical_scope(module, first_element) {\n+        alt self.resolve_module_in_lexical_scope(module_, first_element) {\n             Failed {\n                 self.session.span_err(span, ~\"unresolved name\");\n                 ret Failed;\n@@ -2226,7 +2226,7 @@ class Resolver {\n                                                span);\n     }\n \n-    fn resolve_item_in_lexical_scope(module: @Module,\n+    fn resolve_item_in_lexical_scope(module_: @Module,\n                                      name: Atom,\n                                      namespace: Namespace)\n                                   -> ResolveResult<Target> {\n@@ -2235,16 +2235,16 @@ class Resolver {\n                 namespace %? in `%s`\",\n                *(*self.atom_table).atom_to_str(name),\n                namespace,\n-               self.module_to_str(module)};\n+               self.module_to_str(module_)};\n \n         // The current module node is handled specially. First, check for\n         // its immediate children.\n \n-        alt module.children.find(name) {\n+        alt module_.children.find(name) {\n             some(name_bindings)\n                     if (*name_bindings).defined_in_namespace(namespace) {\n \n-                ret Success(Target(module, name_bindings));\n+                ret Success(Target(module_, name_bindings));\n             }\n             some(_) | none { /* Not found; continue. */ }\n         }\n@@ -2254,7 +2254,7 @@ class Resolver {\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n \n-        alt module.import_resolutions.find(name) {\n+        alt module_.import_resolutions.find(name) {\n             none {\n                 // Not found; continue.\n             }\n@@ -2275,7 +2275,7 @@ class Resolver {\n         }\n \n         // Finally, proceed up the scope chain looking for parent modules.\n-        let mut search_module = module;\n+        let mut search_module = module_;\n         loop {\n             // Go to the next parent.\n             alt search_module.parent_link {\n@@ -2313,19 +2313,19 @@ class Resolver {\n         }\n     }\n \n-    fn resolve_module_in_lexical_scope(module: @Module, name: Atom)\n+    fn resolve_module_in_lexical_scope(module_: @Module, name: Atom)\n                                     -> ResolveResult<@Module> {\n \n-        alt self.resolve_item_in_lexical_scope(module, name, ModuleNS) {\n+        alt self.resolve_item_in_lexical_scope(module_, name, ModuleNS) {\n             Success(target) {\n                 alt target.bindings.module_def {\n                     NoModuleDef {\n                         error!{\"!!! (resolving module in lexical scope) module\n                                 wasn't actually a module!\"};\n                         ret Failed;\n                     }\n-                    ModuleDef(module) {\n-                        ret Success(module);\n+                    ModuleDef(module_) {\n+                        ret Success(module_);\n                     }\n                 }\n             }\n@@ -2342,39 +2342,39 @@ class Resolver {\n         }\n     }\n \n-    fn name_is_exported(module: @Module, name: Atom) -> bool {\n-        ret module.exported_names.size() == 0u ||\n-                module.exported_names.contains_key(name);\n+    fn name_is_exported(module_: @Module, name: Atom) -> bool {\n+        ret module_.exported_names.size() == 0u ||\n+                module_.exported_names.contains_key(name);\n     }\n \n     /**\n      * Attempts to resolve the supplied name in the given module for the\n      * given namespace. If successful, returns the target corresponding to\n      * the name.\n      */\n-    fn resolve_name_in_module(module: @Module,\n+    fn resolve_name_in_module(module_: @Module,\n                               name: Atom,\n                               namespace: Namespace,\n                               xray: XrayFlag)\n                            -> ResolveResult<Target> {\n \n         debug!{\"(resolving name in module) resolving `%s` in `%s`\",\n                *(*self.atom_table).atom_to_str(name),\n-               self.module_to_str(module)};\n+               self.module_to_str(module_)};\n \n-        if xray == NoXray && !self.name_is_exported(module, name) {\n+        if xray == NoXray && !self.name_is_exported(module_, name) {\n             debug!{\"(resolving name in module) name `%s` is unexported\",\n                    *(*self.atom_table).atom_to_str(name)};\n             ret Failed;\n         }\n \n         // First, check the direct children of the module.\n-        alt module.children.find(name) {\n+        alt module_.children.find(name) {\n             some(name_bindings)\n                     if (*name_bindings).defined_in_namespace(namespace) {\n \n                 debug!{\"(resolving name in module) found node as child\"};\n-                ret Success(Target(module, name_bindings));\n+                ret Success(Target(module_, name_bindings));\n             }\n             some(_) | none {\n                 // Continue.\n@@ -2384,13 +2384,13 @@ class Resolver {\n         // Next, check the module's imports. If the module has a glob, then\n         // we bail out; we don't know its imports yet.\n \n-        if module.glob_count > 0u {\n+        if module_.glob_count > 0u {\n             debug!{\"(resolving name in module) module has glob; bailing out\"};\n             ret Indeterminate;\n         }\n \n         // Otherwise, we check the list of resolved imports.\n-        alt module.import_resolutions.find(name) {\n+        alt module_.import_resolutions.find(name) {\n             some(import_resolution) {\n                 if import_resolution.outstanding_references != 0u {\n                     debug!{\"(resolving name in module) import unresolved; \\\n@@ -2428,7 +2428,7 @@ class Resolver {\n      * This needs special handling, as, unlike all of the other imports, it\n      * needs to look in the scope chain for modules and non-modules alike.\n      */\n-    fn resolve_one_level_renaming_import(module: @Module,\n+    fn resolve_one_level_renaming_import(module_: @Module,\n                                          import_directive: @ImportDirective)\n                                       -> ResolveResult<()> {\n \n@@ -2448,15 +2448,15 @@ class Resolver {\n                 `%s` in `%s`\",\n                 *(*self.atom_table).atom_to_str(target_name),\n                 *(*self.atom_table).atom_to_str(source_name),\n-                self.module_to_str(module)};\n+                self.module_to_str(module_)};\n \n         // Find the matching items in the lexical scope chain for every\n         // namespace. If any of them come back indeterminate, this entire\n         // import is indeterminate.\n \n         let mut module_result;\n         debug!{\"(resolving one-level naming result) searching for module\"};\n-        alt self.resolve_item_in_lexical_scope(module,\n+        alt self.resolve_item_in_lexical_scope(module_,\n                                                source_name,\n                                                ModuleNS) {\n \n@@ -2479,7 +2479,7 @@ class Resolver {\n \n         let mut value_result;\n         debug!{\"(resolving one-level naming result) searching for value\"};\n-        alt self.resolve_item_in_lexical_scope(module,\n+        alt self.resolve_item_in_lexical_scope(module_,\n                                                source_name,\n                                                ValueNS) {\n \n@@ -2502,7 +2502,7 @@ class Resolver {\n \n         let mut type_result;\n         debug!{\"(resolving one-level naming result) searching for type\"};\n-        alt self.resolve_item_in_lexical_scope(module,\n+        alt self.resolve_item_in_lexical_scope(module_,\n                                                source_name,\n                                                TypeNS) {\n \n@@ -2542,7 +2542,7 @@ class Resolver {\n \n         let mut impl_result;\n         debug!{\"(resolving one-level naming result) searching for impl\"};\n-        alt self.resolve_item_in_lexical_scope(module,\n+        alt self.resolve_item_in_lexical_scope(module_,\n                                                source_name,\n                                                ImplNS) {\n \n@@ -2573,7 +2573,7 @@ class Resolver {\n         }\n \n         // Otherwise, proceed and write in the bindings.\n-        alt module.import_resolutions.find(target_name) {\n+        alt module_.import_resolutions.find(target_name) {\n             none {\n                 fail ~\"(resolving one-level renaming import) reduced graph \\\n                       construction or glob importing should have created the \\\n@@ -2584,7 +2584,7 @@ class Resolver {\n                         result %? for `%s` into `%s`\",\n                        is_none(module_result),\n                        *(*self.atom_table).atom_to_str(target_name),\n-                       self.module_to_str(module)};\n+                       self.module_to_str(module_)};\n \n                 import_resolution.module_target = module_result;\n                 import_resolution.value_target = value_result;\n@@ -2608,16 +2608,16 @@ class Resolver {\n         ret Success(());\n     }\n \n-    fn report_unresolved_imports(module: @Module) {\n-        let index = module.resolved_import_count;\n-        let import_count = module.imports.len();\n+    fn report_unresolved_imports(module_: @Module) {\n+        let index = module_.resolved_import_count;\n+        let import_count = module_.imports.len();\n         if index != import_count {\n-            self.session.span_err(module.imports.get_elt(index).span,\n+            self.session.span_err(module_.imports.get_elt(index).span,\n                                   ~\"unresolved import\");\n         }\n \n         // Descend into children and anonymous children.\n-        for module.children.each |_name, child_node| {\n+        for module_.children.each |_name, child_node| {\n             alt (*child_node).get_module_if_available() {\n                 none {\n                     // Continue.\n@@ -2628,8 +2628,8 @@ class Resolver {\n             }\n         }\n \n-        for module.anonymous_children.each |_name, module| {\n-            self.report_unresolved_imports(module);\n+        for module_.anonymous_children.each |_name, module_| {\n+            self.report_unresolved_imports(module_);\n         }\n     }\n \n@@ -2647,11 +2647,11 @@ class Resolver {\n         self.record_exports_for_module_subtree(root_module);\n     }\n \n-    fn record_exports_for_module_subtree(module: @Module) {\n+    fn record_exports_for_module_subtree(module_: @Module) {\n         // If this isn't a local crate, then bail out. We don't need to record\n         // exports for local crates.\n \n-        alt module.def_id {\n+        alt module_.def_id {\n             some(def_id) if def_id.crate == local_crate {\n                 // OK. Continue.\n             }\n@@ -2662,14 +2662,14 @@ class Resolver {\n                 // Bail out.\n                 debug!{\"(recording exports for module subtree) not recording \\\n                         exports for `%s`\",\n-                       self.module_to_str(module)};\n+                       self.module_to_str(module_)};\n                 ret;\n             }\n         }\n \n-        self.record_exports_for_module(module);\n+        self.record_exports_for_module(module_);\n \n-        for module.children.each |_atom, child_name_bindings| {\n+        for module_.children.each |_atom, child_name_bindings| {\n             alt (*child_name_bindings).get_module_if_available() {\n                 none {\n                     // Nothing to do.\n@@ -2680,13 +2680,13 @@ class Resolver {\n             }\n         }\n \n-        for module.anonymous_children.each |_node_id, child_module| {\n+        for module_.anonymous_children.each |_node_id, child_module| {\n             self.record_exports_for_module_subtree(child_module);\n         }\n     }\n \n-    fn record_exports_for_module(module: @Module) {\n-        for module.exported_names.each |name, node_id| {\n+    fn record_exports_for_module(module_: @Module) {\n+        for module_.exported_names.each |name, node_id| {\n             let mut exports = ~[];\n             for self.namespaces.each |namespace| {\n                 // Ignore impl namespaces; they cause the original resolve\n@@ -2696,7 +2696,7 @@ class Resolver {\n                     again;\n                 }\n \n-                alt self.resolve_definition_of_name_in_module(module,\n+                alt self.resolve_definition_of_name_in_module(module_,\n                                                               name,\n                                                               namespace,\n                                                               Xray) {\n@@ -2733,11 +2733,11 @@ class Resolver {\n         self.build_impl_scopes_for_module_subtree(root_module);\n     }\n \n-    fn build_impl_scopes_for_module_subtree(module: @Module) {\n+    fn build_impl_scopes_for_module_subtree(module_: @Module) {\n         // If this isn't a local crate, then bail out. We don't need to\n         // resolve implementations for external crates.\n \n-        alt module.def_id {\n+        alt module_.def_id {\n             some(def_id) if def_id.crate == local_crate {\n                 // OK. Continue.\n             }\n@@ -2748,14 +2748,14 @@ class Resolver {\n                 // Bail out.\n                 debug!{\"(building impl scopes for module subtree) not \\\n                         resolving implementations for `%s`\",\n-                       self.module_to_str(module)};\n+                       self.module_to_str(module_)};\n                 ret;\n             }\n         }\n \n-        self.build_impl_scope_for_module(module);\n+        self.build_impl_scope_for_module(module_);\n \n-        for module.children.each |_atom, child_name_bindings| {\n+        for module_.children.each |_atom, child_name_bindings| {\n             alt (*child_name_bindings).get_module_if_available() {\n                 none {\n                     // Nothing to do.\n@@ -2766,20 +2766,20 @@ class Resolver {\n             }\n         }\n \n-        for module.anonymous_children.each |_node_id, child_module| {\n+        for module_.anonymous_children.each |_node_id, child_module| {\n             self.build_impl_scopes_for_module_subtree(child_module);\n         }\n     }\n \n-    fn build_impl_scope_for_module(module: @Module) {\n+    fn build_impl_scope_for_module(module_: @Module) {\n         let mut impl_scope = ~[];\n \n         debug!{\"(building impl scope for module) processing module %s (%?)\",\n-               self.module_to_str(module),\n-               copy module.def_id};\n+               self.module_to_str(module_),\n+               copy module_.def_id};\n \n         // Gather up all direct children implementations in the module.\n-        for module.children.each |_impl_name, child_name_bindings| {\n+        for module_.children.each |_impl_name, child_name_bindings| {\n             if child_name_bindings.impl_defs.len() >= 1u {\n                 impl_scope += child_name_bindings.impl_defs;\n             }\n@@ -2790,7 +2790,7 @@ class Resolver {\n                impl_scope.len()};\n \n         // Gather up all imports.\n-        for module.import_resolutions.each |_impl_name, import_resolution| {\n+        for module_.import_resolutions.each |_impl_name, import_resolution| {\n             for (*import_resolution.impl_target).each |impl_target| {\n                 debug!{\"(building impl scope for module) found impl def\"};\n                 impl_scope += impl_target.bindings.impl_defs;\n@@ -2802,7 +2802,7 @@ class Resolver {\n \n         // Determine the parent's implementation scope.\n         let mut parent_impl_scopes;\n-        alt module.parent_link {\n+        alt module_.parent_link {\n             NoParentLink {\n                 parent_impl_scopes = @nil;\n             }\n@@ -2816,9 +2816,9 @@ class Resolver {\n         // it up to the parent.\n \n         if impl_scope.len() >= 1u {\n-            module.impl_scopes = @cons(@impl_scope, parent_impl_scopes);\n+            module_.impl_scopes = @cons(@impl_scope, parent_impl_scopes);\n         } else {\n-            module.impl_scopes = parent_impl_scopes;\n+            module_.impl_scopes = parent_impl_scopes;\n         }\n     }\n \n@@ -2863,8 +2863,8 @@ class Resolver {\n                                        *(*self.atom_table).atom_to_str(name),\n                                        self.module_to_str(orig_module)};\n                             }\n-                            some(module) {\n-                                self.current_module = module;\n+                            some(module_) {\n+                                self.current_module = module_;\n                             }\n                         }\n                     }\n@@ -3129,10 +3129,10 @@ class Resolver {\n                                    visitor);\n             }\n \n-            item_mod(module) {\n+            item_mod(module_) {\n                 let atom = (*self.atom_table).intern(item.ident);\n                 do self.with_scope(some(atom)) {\n-                    self.resolve_module(module, item.span, item.ident,\n+                    self.resolve_module(module_, item.span, item.ident,\n                                         item.id, visitor);\n                 }\n             }\n@@ -3537,14 +3537,14 @@ class Resolver {\n         }\n     }\n \n-    fn resolve_module(module: _mod, span: span, _name: ident, id: node_id,\n+    fn resolve_module(module_: _mod, span: span, _name: ident, id: node_id,\n                       visitor: ResolveVisitor) {\n \n         // Write the implementations in scope into the module metadata.\n         debug!{\"(resolving module) resolving module ID %d\", id};\n         self.impl_map.insert(id, self.current_module.impl_scopes);\n \n-        visit_mod(module, span, id, (), visitor);\n+        visit_mod(module_, span, id, (), visitor);\n     }\n \n     fn resolve_local(local: @local, visitor: ResolveVisitor) {\n@@ -4501,11 +4501,11 @@ class Resolver {\n         self.check_for_unused_imports_in_module_subtree(root_module);\n     }\n \n-    fn check_for_unused_imports_in_module_subtree(module: @Module) {\n+    fn check_for_unused_imports_in_module_subtree(module_: @Module) {\n         // If this isn't a local crate, then bail out. We don't need to check\n         // for unused imports in external crates.\n \n-        alt module.def_id {\n+        alt module_.def_id {\n             some(def_id) if def_id.crate == local_crate {\n                 // OK. Continue.\n             }\n@@ -4516,14 +4516,14 @@ class Resolver {\n                 // Bail out.\n                 debug!{\"(checking for unused imports in module subtree) not \\\n                         checking for unused imports for `%s`\",\n-                       self.module_to_str(module)};\n+                       self.module_to_str(module_)};\n                 ret;\n             }\n         }\n \n-        self.check_for_unused_imports_in_module(module);\n+        self.check_for_unused_imports_in_module(module_);\n \n-        for module.children.each |_atom, child_name_bindings| {\n+        for module_.children.each |_atom, child_name_bindings| {\n             alt (*child_name_bindings).get_module_if_available() {\n                 none {\n                     // Nothing to do.\n@@ -4535,13 +4535,13 @@ class Resolver {\n             }\n         }\n \n-        for module.anonymous_children.each |_node_id, child_module| {\n+        for module_.anonymous_children.each |_node_id, child_module| {\n             self.check_for_unused_imports_in_module_subtree(child_module);\n         }\n     }\n \n-    fn check_for_unused_imports_in_module(module: @Module) {\n-        for module.import_resolutions.each |_impl_name, import_resolution| {\n+    fn check_for_unused_imports_in_module(module_: @Module) {\n+        for module_.import_resolutions.each |_impl_name, import_resolution| {\n             if !import_resolution.used {\n                 alt self.unused_import_lint_level {\n                     warn {\n@@ -4570,21 +4570,21 @@ class Resolver {\n     //\n \n     /// A somewhat inefficient routine to print out the name of a module.\n-    fn module_to_str(module: @Module) -> ~str {\n+    fn module_to_str(module_: @Module) -> ~str {\n         let atoms = dvec();\n-        let mut current_module = module;\n+        let mut current_module = module_;\n         loop {\n             alt current_module.parent_link {\n                 NoParentLink {\n                     break;\n                 }\n-                ModuleParentLink(module, name) {\n+                ModuleParentLink(module_, name) {\n                     atoms.push(name);\n-                    current_module = module;\n+                    current_module = module_;\n                 }\n-                BlockParentLink(module, node_id) {\n+                BlockParentLink(module_, node_id) {\n                     atoms.push((*self.atom_table).intern(@~\"<opaque>\"));\n-                    current_module = module;\n+                    current_module = module_;\n                 }\n             }\n         }\n@@ -4610,16 +4610,16 @@ class Resolver {\n         ret string;\n     }\n \n-    fn dump_module(module: @Module) {\n-        debug!{\"Dump of module `%s`:\", self.module_to_str(module)};\n+    fn dump_module(module_: @Module) {\n+        debug!{\"Dump of module `%s`:\", self.module_to_str(module_)};\n \n         debug!{\"Children:\"};\n-        for module.children.each |name, _child| {\n+        for module_.children.each |name, _child| {\n             debug!{\"* %s\", *(*self.atom_table).atom_to_str(name)};\n         }\n \n         debug!{\"Import resolutions:\"};\n-        for module.import_resolutions.each |name, import_resolution| {\n+        for module_.import_resolutions.each |name, import_resolution| {\n             let mut module_repr;\n             alt (*import_resolution).target_for_namespace(ModuleNS) {\n                 none { module_repr = ~\"\"; }"}, {"sha": "c079e78c78218a91c8d0786450f0a1d1d83ef336", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -93,9 +93,9 @@ type match_branch =\n       data: @{bodycx: block,\n               guard: option<@ast::expr>,\n               id_map: pat_id_map}};\n-type match = ~[match_branch];\n+type match_ = ~[match_branch];\n \n-fn has_nested_bindings(m: match, col: uint) -> bool {\n+fn has_nested_bindings(m: match_, col: uint) -> bool {\n     for vec::each(m) |br| {\n         alt br.pats[col].node {\n           ast::pat_ident(_, some(_)) { ret true; }\n@@ -105,7 +105,7 @@ fn has_nested_bindings(m: match, col: uint) -> bool {\n     ret false;\n }\n \n-fn expand_nested_bindings(m: match, col: uint, val: ValueRef) -> match {\n+fn expand_nested_bindings(m: match_, col: uint, val: ValueRef) -> match_ {\n     let mut result = ~[];\n     for vec::each(m) |br| {\n       alt br.pats[col].node {\n@@ -129,8 +129,8 @@ fn expand_nested_bindings(m: match, col: uint, val: ValueRef) -> match {\n \n type enter_pat = fn(@ast::pat) -> option<~[@ast::pat]>;\n \n-fn enter_match(dm: DefMap, m: match, col: uint, val: ValueRef,\n-               e: enter_pat) -> match {\n+fn enter_match(dm: DefMap, m: match_, col: uint, val: ValueRef,\n+               e: enter_pat) -> match_ {\n     let mut result = ~[];\n     for vec::each(m) |br| {\n         alt e(br.pats[col]) {\n@@ -154,7 +154,7 @@ fn enter_match(dm: DefMap, m: match, col: uint, val: ValueRef,\n     ret result;\n }\n \n-fn enter_default(dm: DefMap, m: match, col: uint, val: ValueRef) -> match {\n+fn enter_default(dm: DefMap, m: match_, col: uint, val: ValueRef) -> match_ {\n     do enter_match(dm, m, col, val) |p| {\n         alt p.node {\n           ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) { some(~[]) }\n@@ -166,8 +166,8 @@ fn enter_default(dm: DefMap, m: match, col: uint, val: ValueRef) -> match {\n     }\n }\n \n-fn enter_opt(tcx: ty::ctxt, m: match, opt: opt, col: uint,\n-             variant_size: uint, val: ValueRef) -> match {\n+fn enter_opt(tcx: ty::ctxt, m: match_, opt: opt, col: uint,\n+             variant_size: uint, val: ValueRef) -> match_ {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(tcx.def_map, m, col, val) |p| {\n         alt p.node {\n@@ -192,8 +192,8 @@ fn enter_opt(tcx: ty::ctxt, m: match, opt: opt, col: uint,\n     }\n }\n \n-fn enter_rec(dm: DefMap, m: match, col: uint, fields: ~[ast::ident],\n-             val: ValueRef) -> match {\n+fn enter_rec(dm: DefMap, m: match_, col: uint, fields: ~[ast::ident],\n+             val: ValueRef) -> match_ {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(dm, m, col, val) |p| {\n         alt p.node {\n@@ -213,8 +213,8 @@ fn enter_rec(dm: DefMap, m: match, col: uint, fields: ~[ast::ident],\n     }\n }\n \n-fn enter_tup(dm: DefMap, m: match, col: uint, val: ValueRef,\n-             n_elts: uint) -> match {\n+fn enter_tup(dm: DefMap, m: match_, col: uint, val: ValueRef,\n+             n_elts: uint) -> match_ {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(dm, m, col, val) |p| {\n         alt p.node {\n@@ -224,7 +224,7 @@ fn enter_tup(dm: DefMap, m: match, col: uint, val: ValueRef,\n     }\n }\n \n-fn enter_box(dm: DefMap, m: match, col: uint, val: ValueRef) -> match {\n+fn enter_box(dm: DefMap, m: match_, col: uint, val: ValueRef) -> match_ {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(dm, m, col, val) |p| {\n         alt p.node {\n@@ -234,7 +234,7 @@ fn enter_box(dm: DefMap, m: match, col: uint, val: ValueRef) -> match {\n     }\n }\n \n-fn enter_uniq(dm: DefMap, m: match, col: uint, val: ValueRef) -> match {\n+fn enter_uniq(dm: DefMap, m: match_, col: uint, val: ValueRef) -> match_ {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(dm, m, col, val) |p| {\n         alt p.node {\n@@ -244,7 +244,7 @@ fn enter_uniq(dm: DefMap, m: match, col: uint, val: ValueRef) -> match {\n     }\n }\n \n-fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> ~[opt] {\n+fn get_options(ccx: @crate_ctxt, m: match_, col: uint) -> ~[opt] {\n     fn add_to_set(tcx: ty::ctxt, &&set: dvec<opt>, val: opt) {\n         if set.any(|l| opt_eq(tcx, l, val)) {ret;}\n         set.push(val);\n@@ -294,7 +294,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     ret {vals: args, bcx: bcx};\n }\n \n-fn collect_record_fields(m: match, col: uint) -> ~[ast::ident] {\n+fn collect_record_fields(m: match_, col: uint) -> ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n     for vec::each(m) |br| {\n         alt br.pats[col].node {\n@@ -311,7 +311,7 @@ fn collect_record_fields(m: match, col: uint) -> ~[ast::ident] {\n     ret fields;\n }\n \n-fn root_pats_as_necessary(bcx: block, m: match, col: uint, val: ValueRef) {\n+fn root_pats_as_necessary(bcx: block, m: match_, col: uint, val: ValueRef) {\n     for vec::each(m) |br| {\n         let pat_id = br.pats[col].id;\n \n@@ -331,21 +331,21 @@ fn root_pats_as_necessary(bcx: block, m: match, col: uint, val: ValueRef) {\n     }\n }\n \n-fn any_box_pat(m: match, col: uint) -> bool {\n+fn any_box_pat(m: match_, col: uint) -> bool {\n     for vec::each(m) |br| {\n         alt br.pats[col].node { ast::pat_box(_) { ret true; } _ { } }\n     }\n     ret false;\n }\n \n-fn any_uniq_pat(m: match, col: uint) -> bool {\n+fn any_uniq_pat(m: match_, col: uint) -> bool {\n     for vec::each(m) |br| {\n         alt br.pats[col].node { ast::pat_uniq(_) { ret true; } _ { } }\n     }\n     ret false;\n }\n \n-fn any_tup_pat(m: match, col: uint) -> bool {\n+fn any_tup_pat(m: match_, col: uint) -> bool {\n     for vec::each(m) |br| {\n         alt br.pats[col].node { ast::pat_tup(_) { ret true; } _ { } }\n     }\n@@ -355,7 +355,7 @@ fn any_tup_pat(m: match, col: uint) -> bool {\n type exit_node = {bound: bind_map, from: BasicBlockRef, to: BasicBlockRef};\n type mk_fail = fn@() -> BasicBlockRef;\n \n-fn pick_col(m: match) -> uint {\n+fn pick_col(m: match_) -> uint {\n     fn score(p: @ast::pat) -> uint {\n         alt p.node {\n           ast::pat_lit(_) | ast::pat_enum(_, _) | ast::pat_range(_, _) { 1u }\n@@ -383,7 +383,7 @@ fn pick_col(m: match) -> uint {\n     ret best_col;\n }\n \n-fn compile_submatch(bcx: block, m: match, vals: ~[ValueRef],\n+fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n                     chk: option<mk_fail>, &exits: ~[exit_node]) {\n     /*\n       For an empty match, a fall-through case must exist\n@@ -651,7 +651,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n                    mode: ast::alt_mode, dest: dest) -> block {\n     let _icx = scope_cx.insn_ctxt(~\"alt::trans_alt_inner\");\n     let bcx = scope_cx, tcx = bcx.tcx();\n-    let mut bodies = ~[], match = ~[];\n+    let mut bodies = ~[], matches = ~[];\n \n     let {bcx, val, _} = trans_temp_expr(bcx, expr);\n     if bcx.unreachable { ret bcx; }\n@@ -661,7 +661,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n         vec::push(bodies, body);\n         for vec::each(a.pats) |p| {\n-            vec::push(match, @{pats: ~[p],\n+            vec::push(matches, @{pats: ~[p],\n                         bound: ~[],\n                         data: @{bodycx: body, guard: a.guard,\n                                 id_map: id_map}});\n@@ -698,7 +698,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n     };\n     let mut exit_map = ~[];\n     let spilled = spill_if_immediate(bcx, val, t);\n-    compile_submatch(bcx, match, ~[spilled], mk_fail, exit_map);\n+    compile_submatch(bcx, matches, ~[spilled], mk_fail, exit_map);\n \n     let mut arm_cxs = ~[], arm_dests = ~[], i = 0u;\n     for vec::each(arms) |a| {"}, {"sha": "af074ddb7ab55d04f8c12cb8fb54577ee4a9d97b", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -363,10 +363,10 @@ class CoherenceChecker {\n         visit_crate(*crate, (), mk_vt(@{\n             visit_item: |item, _context, visitor| {\n                 alt item.node {\n-                    item_mod(module) {\n+                    item_mod(module_) {\n                         // First, gather up all privileged types.\n                         let privileged_types =\n-                            self.gather_privileged_types(module.items);\n+                            self.gather_privileged_types(module_.items);\n                         for privileged_types.each |privileged_type| {\n                             debug!{\"(checking privileged scopes) entering \\\n                                     privileged scope of %d:%d\",\n@@ -377,7 +377,7 @@ class CoherenceChecker {\n                         }\n \n                         // Then visit the module items.\n-                        visit_mod(module, item.span, item.id, (), visitor);\n+                        visit_mod(module_, item.span, item.id, (), visitor);\n \n                         // Finally, remove privileged types from the map.\n                         for privileged_types.each |privileged_type| {"}, {"sha": "c663806bf99a3da55361fe6d8c826bf752de33b3", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -101,11 +101,11 @@ fn parse_config_(\n     let args = vec::tail(args);\n     let opts = vec::unzip(opts()).first();\n     alt getopts::getopts(args, opts) {\n-        result::ok(match) {\n-            if vec::len(match.free) == 1u {\n-                let input_crate = vec::head(match.free);\n-                config_from_opts(input_crate, match, program_output)\n-            } else if vec::is_empty(match.free) {\n+        result::ok(matches) {\n+            if vec::len(matches.free) == 1u {\n+                let input_crate = vec::head(matches.free);\n+                config_from_opts(input_crate, matches, program_output)\n+            } else if vec::is_empty(matches.free) {\n                 result::err(~\"no crates specified\")\n             } else {\n                 result::err(~\"multiple crates specified\")\n@@ -119,22 +119,22 @@ fn parse_config_(\n \n fn config_from_opts(\n     input_crate: ~str,\n-    match: getopts::matches,\n+    matches: getopts::matches,\n     program_output: program_output\n ) -> result<config, ~str> {\n \n     let config = default_config(input_crate);\n     let result = result::ok(config);\n     let result = do result::chain(result) |config| {\n-        let output_dir = getopts::opt_maybe_str(match, opt_output_dir());\n+        let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n         result::ok({\n             output_dir: option::get_default(output_dir, config.output_dir)\n             with config\n         })\n     };\n     let result = do result::chain(result) |config| {\n         let output_format = getopts::opt_maybe_str(\n-            match, opt_output_format());\n+            matches, opt_output_format());\n         do option::map_default(output_format, result::ok(config))\n             |output_format| {\n             do result::chain(parse_output_format(output_format))\n@@ -148,7 +148,8 @@ fn config_from_opts(\n         }\n     };\n     let result = do result::chain(result) |config| {\n-        let output_style = getopts::opt_maybe_str(match, opt_output_style());\n+        let output_style =\n+            getopts::opt_maybe_str(matches, opt_output_style());\n         do option::map_default(output_style, result::ok(config))\n             |output_style| {\n             do result::chain(parse_output_style(output_style))\n@@ -161,7 +162,7 @@ fn config_from_opts(\n         }\n     };\n     let result = do result::chain(result) |config| {\n-        let pandoc_cmd = getopts::opt_maybe_str(match, opt_pandoc_cmd());\n+        let pandoc_cmd = getopts::opt_maybe_str(matches, opt_pandoc_cmd());\n         let pandoc_cmd = maybe_find_pandoc(\n             config, pandoc_cmd, program_output);\n         do result::chain(pandoc_cmd) |pandoc_cmd| {"}, {"sha": "0028887d4906f48b4323a393f48ce96dee535d3f", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -52,11 +52,11 @@ fn mk_itemdoc(id: ast::node_id, name: ast::ident) -> doc::itemdoc {\n \n fn moddoc_from_mod(\n     itemdoc: doc::itemdoc,\n-    module: ast::_mod\n+    module_: ast::_mod\n ) -> doc::moddoc {\n     doc::moddoc_({\n         item: itemdoc,\n-        items: do vec::filter_map(module.items) |item| {\n+        items: do vec::filter_map(module_.items) |item| {\n             let itemdoc = mk_itemdoc(item.id, item.ident);\n             alt item.node {\n               ast::item_mod(m) {\n@@ -110,11 +110,11 @@ fn moddoc_from_mod(\n \n fn nmoddoc_from_mod(\n     itemdoc: doc::itemdoc,\n-    module: ast::foreign_mod\n+    module_: ast::foreign_mod\n ) -> doc::nmoddoc {\n     {\n         item: itemdoc,\n-        fns: do vec::map(module.items) |item| {\n+        fns: do vec::map(module_.items) |item| {\n             let itemdoc = mk_itemdoc(item.id, item.ident);\n             alt item.node {\n               ast::foreign_item_fn(_, _) {"}, {"sha": "d363a92f37594eb6d9a04aeefb6cfc6820e87eff", "filename": "src/test/compile-fail/attr-bad-crate-attr.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Ftest%2Fcompile-fail%2Fattr-bad-crate-attr.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Ftest%2Fcompile-fail%2Fattr-bad-crate-attr.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-bad-crate-attr.rc?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: expected `mod`\n+// error-pattern: expected `module`\n \n #[attr = \"val\"];\n #[attr = \"val\"] // Unterminated"}, {"sha": "459648452e4e9d59d004dbafd2d2df971de82791", "filename": "src/test/run-pass/keyword-changes-2012-07-31.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Ftest%2Frun-pass%2Fkeyword-changes-2012-07-31.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2026bf218c416c653faf8bb8cca770d0bb2c0d/src%2Ftest%2Frun-pass%2Fkeyword-changes-2012-07-31.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkeyword-changes-2012-07-31.rs?ref=7b2026bf218c416c653faf8bb8cca770d0bb2c0d", "patch": "@@ -0,0 +1,15 @@\n+// ret -> return\n+// mod -> module\n+// alt -> match\n+\n+fn main() {\n+}\n+\n+mod foo {\n+}\n+\n+fn bar() -> int {\n+    match 0 {\n+      _ { 0 }\n+    }\n+}\n\\ No newline at end of file"}]}