{"sha": "61ff847203d6491f13782b0f6e461b593afc7a0d", "node_id": "C_kwDOAAsO6NoAKDYxZmY4NDcyMDNkNjQ5MWYxMzc4MmIwZjZlNDYxYjU5M2FmYzdhMGQ", "commit": {"author": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2021-11-27T01:57:09Z"}, "committer": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2021-11-27T01:57:09Z"}, "message": "Use iterator instead of recursion in `codegen_place`", "tree": {"sha": "fcd48bb477653ee8f54373fb8834f8624e432d3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcd48bb477653ee8f54373fb8834f8624e432d3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61ff847203d6491f13782b0f6e461b593afc7a0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61ff847203d6491f13782b0f6e461b593afc7a0d", "html_url": "https://github.com/rust-lang/rust/commit/61ff847203d6491f13782b0f6e461b593afc7a0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61ff847203d6491f13782b0f6e461b593afc7a0d/comments", "author": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2f6fb99967ba5d007f6885f1eba022b8c4a6dd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2f6fb99967ba5d007f6885f1eba022b8c4a6dd6", "html_url": "https://github.com/rust-lang/rust/commit/e2f6fb99967ba5d007f6885f1eba022b8c4a6dd6"}], "stats": {"total": 143, "additions": 67, "deletions": 76}, "files": [{"sha": "c21d19a62279ff4aa35435c1ac392d63378b905c", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 67, "deletions": 76, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/61ff847203d6491f13782b0f6e461b593afc7a0d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ff847203d6491f13782b0f6e461b593afc7a0d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=61ff847203d6491f13782b0f6e461b593afc7a0d", "patch": "@@ -429,87 +429,78 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let cx = self.cx;\n         let tcx = self.cx.tcx();\n \n-        let result = match place_ref {\n-            mir::PlaceRef { local, projection: [] } => match self.locals[local] {\n-                LocalRef::Place(place) => {\n-                    return place;\n-                }\n-                LocalRef::UnsizedPlace(place) => {\n-                    return bx.load_operand(place).deref(cx);\n-                }\n-                LocalRef::Operand(..) => {\n+        let mut base = 0;\n+        let mut cg_base = match self.locals[place_ref.local] {\n+            LocalRef::Place(place) => place,\n+            LocalRef::UnsizedPlace(place) => bx.load_operand(place).deref(cx),\n+            LocalRef::Operand(..) => {\n+                if let Some(elem) = place_ref\n+                    .projection\n+                    .iter()\n+                    .enumerate()\n+                    .find(|elem| matches!(elem.1, mir::ProjectionElem::Deref))\n+                {\n+                    base = elem.0 + 1;\n+                    self.codegen_consume(\n+                        bx,\n+                        mir::PlaceRef { projection: &place_ref.projection[..elem.0], ..place_ref },\n+                    )\n+                    .deref(bx.cx())\n+                } else {\n                     bug!(\"using operand local {:?} as place\", place_ref);\n                 }\n-            },\n-            mir::PlaceRef { local, projection: [proj_base @ .., mir::ProjectionElem::Deref] } => {\n-                // Load the pointer from its location.\n-                self.codegen_consume(bx, mir::PlaceRef { local, projection: proj_base })\n-                    .deref(bx.cx())\n             }\n-            mir::PlaceRef { local, projection: &[ref proj_base @ .., elem] } => {\n-                // FIXME turn this recursion into iteration\n-                let cg_base =\n-                    self.codegen_place(bx, mir::PlaceRef { local, projection: proj_base });\n-\n-                match elem {\n-                    mir::ProjectionElem::Deref => bug!(),\n-                    mir::ProjectionElem::Field(ref field, _) => {\n-                        cg_base.project_field(bx, field.index())\n-                    }\n-                    mir::ProjectionElem::Index(index) => {\n-                        let index = &mir::Operand::Copy(mir::Place::from(index));\n-                        let index = self.codegen_operand(bx, index);\n-                        let llindex = index.immediate();\n-                        cg_base.project_index(bx, llindex)\n-                    }\n-                    mir::ProjectionElem::ConstantIndex {\n-                        offset,\n-                        from_end: false,\n-                        min_length: _,\n-                    } => {\n-                        let lloffset = bx.cx().const_usize(offset as u64);\n-                        cg_base.project_index(bx, lloffset)\n-                    }\n-                    mir::ProjectionElem::ConstantIndex {\n-                        offset,\n-                        from_end: true,\n-                        min_length: _,\n-                    } => {\n-                        let lloffset = bx.cx().const_usize(offset as u64);\n-                        let lllen = cg_base.len(bx.cx());\n-                        let llindex = bx.sub(lllen, lloffset);\n-                        cg_base.project_index(bx, llindex)\n-                    }\n-                    mir::ProjectionElem::Subslice { from, to, from_end } => {\n-                        let mut subslice =\n-                            cg_base.project_index(bx, bx.cx().const_usize(from as u64));\n-                        let projected_ty =\n-                            PlaceTy::from_ty(cg_base.layout.ty).projection_ty(tcx, elem).ty;\n-                        subslice.layout = bx.cx().layout_of(self.monomorphize(projected_ty));\n-\n-                        if subslice.layout.is_unsized() {\n-                            assert!(from_end, \"slice subslices should be `from_end`\");\n-                            subslice.llextra = Some(bx.sub(\n-                                cg_base.llextra.unwrap(),\n-                                bx.cx().const_usize((from as u64) + (to as u64)),\n-                            ));\n-                        }\n-\n-                        // Cast the place pointer type to the new\n-                        // array or slice type (`*[%_; new_len]`).\n-                        subslice.llval = bx.pointercast(\n-                            subslice.llval,\n-                            bx.cx().type_ptr_to(bx.cx().backend_type(subslice.layout)),\n-                        );\n-\n-                        subslice\n+        };\n+        for elem in place_ref.projection[base..].iter() {\n+            cg_base = match elem.clone() {\n+                mir::ProjectionElem::Deref => bx.load_operand(cg_base).deref(bx.cx()),\n+                mir::ProjectionElem::Field(ref field, _) => {\n+                    cg_base.project_field(bx, field.index())\n+                }\n+                mir::ProjectionElem::Index(index) => {\n+                    let index = &mir::Operand::Copy(mir::Place::from(index));\n+                    let index = self.codegen_operand(bx, index);\n+                    let llindex = index.immediate();\n+                    cg_base.project_index(bx, llindex)\n+                }\n+                mir::ProjectionElem::ConstantIndex { offset, from_end: false, min_length: _ } => {\n+                    let lloffset = bx.cx().const_usize(offset as u64);\n+                    cg_base.project_index(bx, lloffset)\n+                }\n+                mir::ProjectionElem::ConstantIndex { offset, from_end: true, min_length: _ } => {\n+                    let lloffset = bx.cx().const_usize(offset as u64);\n+                    let lllen = cg_base.len(bx.cx());\n+                    let llindex = bx.sub(lllen, lloffset);\n+                    cg_base.project_index(bx, llindex)\n+                }\n+                mir::ProjectionElem::Subslice { from, to, from_end } => {\n+                    let mut subslice = cg_base.project_index(bx, bx.cx().const_usize(from as u64));\n+                    let projected_ty =\n+                        PlaceTy::from_ty(cg_base.layout.ty).projection_ty(tcx, elem.clone()).ty;\n+                    subslice.layout = bx.cx().layout_of(self.monomorphize(projected_ty));\n+\n+                    if subslice.layout.is_unsized() {\n+                        assert!(from_end, \"slice subslices should be `from_end`\");\n+                        subslice.llextra = Some(bx.sub(\n+                            cg_base.llextra.unwrap(),\n+                            bx.cx().const_usize((from as u64) + (to as u64)),\n+                        ));\n                     }\n-                    mir::ProjectionElem::Downcast(_, v) => cg_base.project_downcast(bx, v),\n+\n+                    // Cast the place pointer type to the new\n+                    // array or slice type (`*[%_; new_len]`).\n+                    subslice.llval = bx.pointercast(\n+                        subslice.llval,\n+                        bx.cx().type_ptr_to(bx.cx().backend_type(subslice.layout)),\n+                    );\n+\n+                    subslice\n                 }\n-            }\n-        };\n-        debug!(\"codegen_place(place={:?}) => {:?}\", place_ref, result);\n-        result\n+                mir::ProjectionElem::Downcast(_, v) => cg_base.project_downcast(bx, v),\n+            };\n+        }\n+        debug!(\"codegen_place(place={:?}) => {:?}\", place_ref, cg_base);\n+        cg_base\n     }\n \n     pub fn monomorphized_place_ty(&self, place_ref: mir::PlaceRef<'tcx>) -> Ty<'tcx> {"}]}