{"sha": "dced2f4ed42b7013c761f2ed53c6c2482fa76169", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZWQyZjRlZDQyYjcwMTNjNzYxZjJlZDUzYzZjMjQ4MmZhNzYxNjk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-11T09:53:10Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-11T09:53:10Z"}, "message": "Handle SourceRoots automatically in fixtures", "tree": {"sha": "4eaf3d862a920b7e0f18733ee520cbb6719551c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eaf3d862a920b7e0f18733ee520cbb6719551c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dced2f4ed42b7013c761f2ed53c6c2482fa76169", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dced2f4ed42b7013c761f2ed53c6c2482fa76169", "html_url": "https://github.com/rust-lang/rust/commit/dced2f4ed42b7013c761f2ed53c6c2482fa76169", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dced2f4ed42b7013c761f2ed53c6c2482fa76169/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81852f6dd2c1bf86da440d9216959baa9a0a5ed2", "url": "https://api.github.com/repos/rust-lang/rust/commits/81852f6dd2c1bf86da440d9216959baa9a0a5ed2", "html_url": "https://github.com/rust-lang/rust/commit/81852f6dd2c1bf86da440d9216959baa9a0a5ed2"}], "stats": {"total": 130, "additions": 75, "deletions": 55}, "files": [{"sha": "29b696afa33b97f402795a57140f18ae4cdc7817", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 55, "deletions": 27, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/dced2f4ed42b7013c761f2ed53c6c2482fa76169/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dced2f4ed42b7013c761f2ed53c6c2482fa76169/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=dced2f4ed42b7013c761f2ed53c6c2482fa76169", "patch": "@@ -6,6 +6,7 @@ use ra_db::{\n };\n use relative_path::RelativePathBuf;\n use test_utils::{parse_fixture, CURSOR_MARKER, extract_offset};\n+use rustc_hash::FxHashMap;\n \n use crate::{db, HirInterner};\n \n@@ -21,82 +22,107 @@ pub struct MockDatabase {\n     events: Mutex<Option<Vec<salsa::Event<MockDatabase>>>>,\n     runtime: salsa::Runtime<MockDatabase>,\n     interner: Arc<HirInterner>,\n-    file_counter: u32,\n+    files: FxHashMap<String, FileId>,\n }\n \n impl panic::RefUnwindSafe for MockDatabase {}\n \n impl MockDatabase {\n-    pub fn with_files(fixture: &str) -> (MockDatabase, SourceRoot) {\n-        let (db, source_root, position) = MockDatabase::from_fixture(fixture);\n+    pub fn with_files(fixture: &str) -> MockDatabase {\n+        let (db, position) = MockDatabase::from_fixture(fixture);\n         assert!(position.is_none());\n-        (db, source_root)\n+        db\n     }\n \n     pub fn with_single_file(text: &str) -> (MockDatabase, SourceRoot, FileId) {\n         let mut db = MockDatabase::default();\n         let mut source_root = SourceRoot::default();\n-        let file_id = db.add_file(WORKSPACE, &mut source_root, \"/main.rs\", text);\n+        let file_id = db.add_file(WORKSPACE, \"/\", &mut source_root, \"/main.rs\", text);\n         db.set_source_root(WORKSPACE, Arc::new(source_root.clone()));\n         (db, source_root, file_id)\n     }\n \n     pub fn with_position(fixture: &str) -> (MockDatabase, FilePosition) {\n-        let (db, _, position) = MockDatabase::from_fixture(fixture);\n+        let (db, position) = MockDatabase::from_fixture(fixture);\n         let position = position.expect(\"expected a marker ( <|> )\");\n         (db, position)\n     }\n \n-    fn from_fixture(fixture: &str) -> (MockDatabase, SourceRoot, Option<FilePosition>) {\n+    pub fn file_id_of(&self, path: &str) -> FileId {\n+        match self.files.get(path) {\n+            Some(it) => *it,\n+            None => panic!(\"unknown file: {:?}\\nexisting files:\\n{:#?}\", path, self.files),\n+        }\n+    }\n+\n+    fn from_fixture(fixture: &str) -> (MockDatabase, Option<FilePosition>) {\n         let mut db = MockDatabase::default();\n \n-        let (source_root, pos) = db.add_fixture(WORKSPACE, fixture);\n+        let pos = db.add_fixture(fixture);\n \n-        (db, source_root, pos)\n+        (db, pos)\n     }\n \n-    pub fn add_fixture(\n-        &mut self,\n-        source_root_id: SourceRootId,\n-        fixture: &str,\n-    ) -> (SourceRoot, Option<FilePosition>) {\n+    fn add_fixture(&mut self, fixture: &str) -> Option<FilePosition> {\n         let mut position = None;\n         let mut source_root = SourceRoot::default();\n+        let mut source_root_id = WORKSPACE;\n+        let mut source_root_prefix = \"/\".to_string();\n         for entry in parse_fixture(fixture) {\n+            if entry.meta.starts_with(\"root\") {\n+                self.set_source_root(source_root_id, Arc::new(source_root));\n+                source_root = SourceRoot::default();\n+\n+                source_root_id = SourceRootId(source_root_id.0 + 1);\n+                source_root_prefix = entry.meta[\"root\".len()..].trim().to_string();\n+                continue;\n+            }\n             if entry.text.contains(CURSOR_MARKER) {\n                 assert!(position.is_none(), \"only one marker (<|>) per fixture is allowed\");\n                 position = Some(self.add_file_with_position(\n                     source_root_id,\n+                    &source_root_prefix,\n                     &mut source_root,\n                     &entry.meta,\n                     &entry.text,\n                 ));\n             } else {\n-                self.add_file(source_root_id, &mut source_root, &entry.meta, &entry.text);\n+                self.add_file(\n+                    source_root_id,\n+                    &source_root_prefix,\n+                    &mut source_root,\n+                    &entry.meta,\n+                    &entry.text,\n+                );\n             }\n         }\n-        self.set_source_root(source_root_id, Arc::new(source_root.clone()));\n-        (source_root, position)\n+        self.set_source_root(source_root_id, Arc::new(source_root));\n+        position\n     }\n \n     fn add_file(\n         &mut self,\n         source_root_id: SourceRootId,\n+        source_root_prefix: &str,\n         source_root: &mut SourceRoot,\n         path: &str,\n         text: &str,\n     ) -> FileId {\n-        assert!(path.starts_with('/'));\n-        let is_crate_root = path == \"/lib.rs\" || path == \"/main.rs\";\n+        assert!(source_root_prefix.starts_with('/'));\n+        assert!(source_root_prefix.ends_with('/'));\n+        assert!(path.starts_with(source_root_prefix));\n+        let rel_path = RelativePathBuf::from_path(&path[source_root_prefix.len()..]).unwrap();\n+\n+        let is_crate_root = rel_path == \"lib.rs\" || rel_path == \"/main.rs\";\n \n-        let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n-        let file_id = FileId(self.file_counter);\n-        self.file_counter += 1;\n+        let file_id = FileId(self.files.len() as u32);\n+        let prev = self.files.insert(path.to_string(), file_id);\n+        assert!(prev.is_none(), \"duplicate files in the text fixture\");\n         let text = Arc::new(text.to_string());\n         self.set_file_text(file_id, text);\n-        self.set_file_relative_path(file_id, path.clone());\n+        self.set_file_relative_path(file_id, rel_path.clone());\n         self.set_file_source_root(file_id, source_root_id);\n-        source_root.files.insert(path, file_id);\n+        source_root.files.insert(rel_path, file_id);\n \n         if is_crate_root {\n             let mut crate_graph = CrateGraph::default();\n@@ -109,12 +135,13 @@ impl MockDatabase {\n     fn add_file_with_position(\n         &mut self,\n         source_root_id: SourceRootId,\n+        source_root_prefix: &str,\n         source_root: &mut SourceRoot,\n         path: &str,\n         text: &str,\n     ) -> FilePosition {\n         let (offset, text) = extract_offset(text);\n-        let file_id = self.add_file(source_root_id, source_root, path, &text);\n+        let file_id = self.add_file(source_root_id, source_root_prefix, source_root, path, &text);\n         FilePosition { file_id, offset }\n     }\n }\n@@ -138,7 +165,7 @@ impl Default for MockDatabase {\n             events: Default::default(),\n             runtime: salsa::Runtime::default(),\n             interner: Default::default(),\n-            file_counter: 0,\n+            files: FxHashMap::default(),\n         };\n         db.set_crate_graph(Default::default());\n         db\n@@ -151,7 +178,8 @@ impl salsa::ParallelDatabase for MockDatabase {\n             events: Default::default(),\n             runtime: self.runtime.snapshot(self),\n             interner: Arc::clone(&self.interner),\n-            file_counter: self.file_counter,\n+            // only the root database can be used to get file_id by path.\n+            files: FxHashMap::default(),\n         })\n     }\n }"}, {"sha": "905c3accf2a243f5e1a28d73c79fbb1995029e4a", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/dced2f4ed42b7013c761f2ed53c6c2482fa76169/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dced2f4ed42b7013c761f2ed53c6c2482fa76169/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=dced2f4ed42b7013c761f2ed53c6c2482fa76169", "patch": "@@ -1,7 +1,6 @@\n use std::sync::Arc;\n \n-use ra_db::{CrateGraph, SourceRootId, SourceDatabase};\n-use relative_path::RelativePath;\n+use ra_db::{CrateGraph, SourceDatabase};\n use test_utils::{assert_eq_text, covers};\n \n use crate::{\n@@ -252,7 +251,7 @@ fn glob_enum() {\n #[test]\n fn glob_across_crates() {\n     covers!(glob_across_crates);\n-    let (mut db, sr) = MockDatabase::with_files(\n+    let mut db = MockDatabase::with_files(\n         \"\n         //- /main.rs\n         use test_crate::*;\n@@ -261,8 +260,8 @@ fn glob_across_crates() {\n         pub struct Baz;\n     \",\n     );\n-    let main_id = sr.files[RelativePath::new(\"/main.rs\")];\n-    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n+    let main_id = db.file_id_of(\"/main.rs\");\n+    let lib_id = db.file_id_of(\"/lib.rs\");\n \n     let mut crate_graph = CrateGraph::default();\n     let main_crate = crate_graph.add_crate_root(main_id);\n@@ -411,7 +410,7 @@ fn item_map_enum_importing() {\n \n #[test]\n fn item_map_across_crates() {\n-    let (mut db, sr) = MockDatabase::with_files(\n+    let mut db = MockDatabase::with_files(\n         \"\n         //- /main.rs\n         use test_crate::Baz;\n@@ -420,8 +419,8 @@ fn item_map_across_crates() {\n         pub struct Baz;\n     \",\n     );\n-    let main_id = sr.files[RelativePath::new(\"/main.rs\")];\n-    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n+    let main_id = db.file_id_of(\"/main.rs\");\n+    let lib_id = db.file_id_of(\"/lib.rs\");\n \n     let mut crate_graph = CrateGraph::default();\n     let main_crate = crate_graph.add_crate_root(main_id);\n@@ -445,7 +444,7 @@ fn item_map_across_crates() {\n \n #[test]\n fn extern_crate_rename() {\n-    let (mut db, sr) = MockDatabase::with_files(\n+    let mut db = MockDatabase::with_files(\n         \"\n         //- /main.rs\n         extern crate alloc as alloc_crate;\n@@ -460,9 +459,9 @@ fn extern_crate_rename() {\n         struct Arc;\n     \",\n     );\n-    let main_id = sr.files[RelativePath::new(\"/main.rs\")];\n-    let sync_id = sr.files[RelativePath::new(\"/sync.rs\")];\n-    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n+    let main_id = db.file_id_of(\"/main.rs\");\n+    let sync_id = db.file_id_of(\"/sync.rs\");\n+    let lib_id = db.file_id_of(\"/lib.rs\");\n \n     let mut crate_graph = CrateGraph::default();\n     let main_crate = crate_graph.add_crate_root(main_id);\n@@ -486,30 +485,23 @@ fn extern_crate_rename() {\n \n #[test]\n fn import_across_source_roots() {\n-    let (mut db, sr) = MockDatabase::with_files(\n+    let mut db = MockDatabase::with_files(\n         \"\n         //- /lib.rs\n         pub mod a {\n             pub mod b {\n                 pub struct C;\n             }\n         }\n-    \",\n-    );\n-    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n \n-    let source_root = SourceRootId(1);\n+        //- root /test_crate/\n \n-    let (sr2, pos) = db.add_fixture(\n-        source_root,\n-        \"\n-        //- /main.rs\n+        //- /test_crate/main.rs\n         use test_crate::a::b::C;\n-    \",\n+        \",\n     );\n-    assert!(pos.is_none());\n-\n-    let main_id = sr2.files[RelativePath::new(\"/main.rs\")];\n+    let lib_id = db.file_id_of(\"/lib.rs\");\n+    let main_id = db.file_id_of(\"/test_crate/main.rs\");\n \n     let mut crate_graph = CrateGraph::default();\n     let main_crate = crate_graph.add_crate_root(main_id);\n@@ -533,7 +525,7 @@ fn import_across_source_roots() {\n \n #[test]\n fn reexport_across_crates() {\n-    let (mut db, sr) = MockDatabase::with_files(\n+    let mut db = MockDatabase::with_files(\n         \"\n         //- /main.rs\n         use test_crate::Baz;\n@@ -547,8 +539,8 @@ fn reexport_across_crates() {\n         pub struct Baz;\n     \",\n     );\n-    let main_id = sr.files[RelativePath::new(\"/main.rs\")];\n-    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n+    let main_id = db.file_id_of(\"/main.rs\");\n+    let lib_id = db.file_id_of(\"/lib.rs\");\n \n     let mut crate_graph = CrateGraph::default();\n     let main_crate = crate_graph.add_crate_root(main_id);"}]}