{"sha": "49f276ec6f08a136c00ff621caf77500e03c16d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZjI3NmVjNmYwOGExMzZjMDBmZjYyMWNhZjc3NTAwZTAzYzE2ZDM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-08-08T15:09:36Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-08-08T15:09:36Z"}, "message": "enable changing wrong_self_convention's lint level at the function level", "tree": {"sha": "6043f419df71771117e75fcb982009210fb2be99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6043f419df71771117e75fcb982009210fb2be99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49f276ec6f08a136c00ff621caf77500e03c16d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXqKCwAAoJEFbW7qD8Z6xGa/gP/jsxagUV0ikFNOMHLDFjxr8x\nfkULQ0ErFwRu4G1Iv8XsurxP+aIofwdRgPIOHdwNWePAcry3WI06dJ6puoOzt5Hq\nUIJb7nPSnUoXg9PY5iuy9UANu4vdYGHWvu6cr9yy6irdOeO0Tld53Or/cMf3DkGG\nCne2EG8fuven4Zkrvq41bIpdb39ANR9NMnw54SBF54JtuBgLyWv4agx5n1sLuJyI\nK37Y9NOObQ1G1flU/MPFvZDQDTeMILmGAPWr2cIxuSLWerRjXTMA7fBJIg6SwqHu\nbPbnphYywSYeJuayZvgoHmWLrqdjMIDvjlFG+RO3RFZu+uNzcbTwPwBcU4v2IJHq\nDDBWeCBIdavZGXs+QtqaY9/T7ywFGvhMwKBtYyMC3vfePZ9oSUn52sng94xCDlpZ\nRdBCfs96tZvo+RKGVGLVTVrRWkkdg73xxDS2JVfXJ46lf2NZSnmuc9S0Hu1X7HIJ\npTyQ53b/UCgJPd3GJNAr005AxB2qkZhBnS9ni8bXZ54JS76D6T1KyJX7n6rDhUCI\nK729hYMFPTVXJcyu26+7pTmvzU2iRtektKSK5COvaIrnYqdzc7UB4bogE9xmj2J1\nhQUbHm0zPbRKMZRZ/jE/jwlgiwW/Z1h3G0JN0h8sgjtI4S9JTbbzufcCkkjK95hL\nBNLUevPNTcc6OH7kvsZQ\n=IdIv\n-----END PGP SIGNATURE-----", "payload": "tree 6043f419df71771117e75fcb982009210fb2be99\nparent ac5abcf5930ea59f13a4da3ff579cc4b3ed88bd1\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1470668976 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1470668976 +0200\n\nenable changing wrong_self_convention's lint level at the function level"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49f276ec6f08a136c00ff621caf77500e03c16d3", "html_url": "https://github.com/rust-lang/rust/commit/49f276ec6f08a136c00ff621caf77500e03c16d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49f276ec6f08a136c00ff621caf77500e03c16d3/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac5abcf5930ea59f13a4da3ff579cc4b3ed88bd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac5abcf5930ea59f13a4da3ff579cc4b3ed88bd1", "html_url": "https://github.com/rust-lang/rust/commit/ac5abcf5930ea59f13a4da3ff579cc4b3ed88bd1"}], "stats": {"total": 109, "additions": 55, "deletions": 54}, "files": [{"sha": "d6d51e2d7804986e20361e6b8e1af72ae7ccbd64", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 52, "deletions": 54, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/49f276ec6f08a136c00ff621caf77500e03c16d3/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f276ec6f08a136c00ff621caf77500e03c16d3/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=49f276ec6f08a136c00ff621caf77500e03c16d3", "patch": "@@ -538,68 +538,66 @@ impl LateLintPass for Pass {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n-        if in_external_macro(cx, item.span) {\n+    fn check_impl_item(&mut self, cx: &LateContext, implitem: &hir::ImplItem) {\n+        if in_external_macro(cx, implitem.span) {\n             return;\n         }\n+        let name = implitem.name;\n+        let parent = cx.tcx.map.get_parent(implitem.id);\n+        let item = cx.tcx.map.expect_item(parent);\n+        if_let_chain! {[\n+            let hir::ImplItemKind::Method(ref sig, _) = implitem.node,\n+            let Some(explicit_self) = sig.decl.inputs.get(0).and_then(hir::Arg::to_self),\n+            let hir::ItemImpl(_, _, _, None, _, _) = item.node,\n+        ], {\n+            // check missing trait implementations\n+            for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n+                if name.as_str() == method_name &&\n+                   sig.decl.inputs.len() == n_args &&\n+                   out_type.matches(&sig.decl.output) &&\n+                   self_kind.matches(&explicit_self, false) {\n+                    span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n+                        \"defining a method called `{}` on this type; consider implementing \\\n+                         the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+                }\n+            }\n \n-        if let hir::ItemImpl(_, _, _, None, _, ref items) = item.node {\n-            for implitem in items {\n-                let name = implitem.name;\n+            // check conventions w.r.t. conversion method names and predicates\n+            let ty = cx.tcx.lookup_item_type(cx.tcx.map.local_def_id(item.id)).ty;\n+            let is_copy = is_copy(cx, ty, item.id);\n+            for &(ref conv, self_kinds) in &CONVENTIONS {\n                 if_let_chain! {[\n-                    let hir::ImplItemKind::Method(ref sig, _) = implitem.node,\n+                    conv.check(&name.as_str()),\n                     let Some(explicit_self) = sig.decl.inputs.get(0).and_then(hir::Arg::to_self),\n+                    !self_kinds.iter().any(|k| k.matches(&explicit_self, is_copy)),\n                 ], {\n-                    // check missing trait implementations\n-                    for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                        if name.as_str() == method_name &&\n-                           sig.decl.inputs.len() == n_args &&\n-                           out_type.matches(&sig.decl.output) &&\n-                           self_kind.matches(&explicit_self, false) {\n-                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n-                                \"defining a method called `{}` on this type; consider implementing \\\n-                                 the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n-                        }\n-                    }\n-\n-                    // check conventions w.r.t. conversion method names and predicates\n-                    let ty = cx.tcx.lookup_item_type(cx.tcx.map.local_def_id(item.id)).ty;\n-                    let is_copy = is_copy(cx, ty, item.id);\n-                    for &(ref conv, self_kinds) in &CONVENTIONS {\n-                        if_let_chain! {[\n-                            conv.check(&name.as_str()),\n-                            let Some(explicit_self) = sig.decl.inputs.get(0).and_then(hir::Arg::to_self),\n-                            !self_kinds.iter().any(|k| k.matches(&explicit_self, is_copy)),\n-                        ], {\n-                            let lint = if item.vis == hir::Visibility::Public {\n-                                WRONG_PUB_SELF_CONVENTION\n-                            } else {\n-                                WRONG_SELF_CONVENTION\n-                            };\n-                            span_lint(cx,\n-                                      lint,\n-                                      explicit_self.span,\n-                                      &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n-                                                ambiguous name\",\n-                                               conv,\n-                                               &self_kinds.iter()\n-                                                          .map(|k| k.description())\n-                                                          .collect::<Vec<_>>()\n-                                                          .join(\" or \")));\n-                        }}\n-                    }\n-\n-                    let ret_ty = return_ty(cx, implitem.id);\n-                    if &name.as_str() == &\"new\" &&\n-                       !ret_ty.map_or(false, |ret_ty| ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id))) {\n-                        span_lint(cx,\n-                                  NEW_RET_NO_SELF,\n-                                  explicit_self.span,\n-                                  \"methods called `new` usually return `Self`\");\n-                    }\n+                    let lint = if item.vis == hir::Visibility::Public {\n+                        WRONG_PUB_SELF_CONVENTION\n+                    } else {\n+                        WRONG_SELF_CONVENTION\n+                    };\n+                    span_lint(cx,\n+                              lint,\n+                              explicit_self.span,\n+                              &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n+                                        ambiguous name\",\n+                                       conv,\n+                                       &self_kinds.iter()\n+                                                  .map(|k| k.description())\n+                                                  .collect::<Vec<_>>()\n+                                                  .join(\" or \")));\n                 }}\n             }\n-        }\n+\n+            let ret_ty = return_ty(cx, implitem.id);\n+            if &name.as_str() == &\"new\" &&\n+               !ret_ty.map_or(false, |ret_ty| ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id))) {\n+                span_lint(cx,\n+                          NEW_RET_NO_SELF,\n+                          explicit_self.span,\n+                          \"methods called `new` usually return `Self`\");\n+            }\n+        }}\n     }\n }\n "}, {"sha": "682f522b363d9e39ecb6994396f4abbd48210ad8", "filename": "tests/compile-fail/wrong_self_convention.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/49f276ec6f08a136c00ff621caf77500e03c16d3/tests%2Fcompile-fail%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f276ec6f08a136c00ff621caf77500e03c16d3/tests%2Fcompile-fail%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwrong_self_convention.rs?ref=49f276ec6f08a136c00ff621caf77500e03c16d3", "patch": "@@ -23,6 +23,9 @@ impl Foo {\n     pub fn is_i64(self) {}\n     pub fn to_i64(self) {}\n     pub fn from_i64(self) {} //~ERROR: methods called `from_*` usually take no self\n+    // check whether the lint can be allowed at the function level\n+    #[allow(wrong_self_convention)]\n+    pub fn from_cake(self) {}\n \n }\n "}]}