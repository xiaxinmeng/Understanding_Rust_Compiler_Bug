{"sha": "9482bce56e9b56b91ec6c6af92eb660961ce8734", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ODJiY2U1NmU5YjU2YjkxZWM2YzZhZjkyZWI2NjA5NjFjZTg3MzQ=", "commit": {"author": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-10-02T01:25:40Z"}, "committer": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-10-02T17:13:40Z"}, "message": "Replace offset_after_field with offsets", "tree": {"sha": "730e82882229d6216504fb5e6cf4284e027ca860", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/730e82882229d6216504fb5e6cf4284e027ca860"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9482bce56e9b56b91ec6c6af92eb660961ce8734", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9482bce56e9b56b91ec6c6af92eb660961ce8734", "html_url": "https://github.com/rust-lang/rust/commit/9482bce56e9b56b91ec6c6af92eb660961ce8734", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9482bce56e9b56b91ec6c6af92eb660961ce8734/comments", "author": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "791fb778ccfb3dc831d99544093a9d4e3cf82a49", "url": "https://api.github.com/repos/rust-lang/rust/commits/791fb778ccfb3dc831d99544093a9d4e3cf82a49", "html_url": "https://github.com/rust-lang/rust/commit/791fb778ccfb3dc831d99544093a9d4e3cf82a49"}], "stats": {"total": 123, "additions": 47, "deletions": 76}, "files": [{"sha": "ec6843eb75d1f7f4ac8d7fbb390bd5a0030e90da", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9482bce56e9b56b91ec6c6af92eb660961ce8734/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9482bce56e9b56b91ec6c6af92eb660961ce8734/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9482bce56e9b56b91ec6c6af92eb660961ce8734", "patch": "@@ -511,11 +511,11 @@ pub struct Struct {\n     /// If true, the size is exact, otherwise it's only a lower bound.\n     pub sized: bool,\n \n-    /// Offsets for the first byte after each field.\n-    /// That is, field_offset(i) = offset_after_field[i - 1] and the\n-    /// whole structure's size is the last offset, excluding padding.\n-    // FIXME(eddyb) use small vector optimization for the common case.\n-    pub offset_after_field: Vec<Size>\n+    /// Offsets for the first byte of each field.\n+    /// FIXME(eddyb) use small vector optimization for the common case.\n+    pub offsets: Vec<Size>,\n+\n+    pub min_size: Size,\n }\n \n impl<'a, 'gcx, 'tcx> Struct {\n@@ -524,7 +524,8 @@ impl<'a, 'gcx, 'tcx> Struct {\n             align: if packed { dl.i8_align } else { dl.aggregate_align },\n             packed: packed,\n             sized: true,\n-            offset_after_field: vec![]\n+            offsets: vec![],\n+            min_size: Size::from_bytes(0),\n         }\n     }\n \n@@ -534,12 +535,14 @@ impl<'a, 'gcx, 'tcx> Struct {\n                      scapegoat: Ty<'gcx>)\n                      -> Result<(), LayoutError<'gcx>>\n     where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n-        self.offset_after_field.reserve(fields.size_hint().0);\n+        self.offsets.reserve(fields.size_hint().0);\n+\n+        let mut offset = self.min_size;\n \n         for field in fields {\n             if !self.sized {\n                 bug!(\"Struct::extend: field #{} of `{}` comes after unsized field\",\n-                     self.offset_after_field.len(), scapegoat);\n+                     self.offsets.len(), scapegoat);\n             }\n \n             let field = field?;\n@@ -548,34 +551,29 @@ impl<'a, 'gcx, 'tcx> Struct {\n             }\n \n             // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-            let mut offset = if !self.packed {\n+            if !self.packed {\n                 let align = field.align(dl);\n                 self.align = self.align.max(align);\n-                self.offset_after_field.last_mut().map_or(Size::from_bytes(0), |last| {\n-                    *last = last.abi_align(align);\n-                    *last\n-                })\n-            } else {\n-                self.offset_after_field.last().map_or(Size::from_bytes(0), |&last| last)\n-            };\n+                offset = offset.abi_align(align);\n+            }\n+\n+            self.offsets.push(offset);\n+\n \n             offset = offset.checked_add(field.size(dl), dl)\n                            .map_or(Err(LayoutError::SizeOverflow(scapegoat)), Ok)?;\n-\n-            self.offset_after_field.push(offset);\n         }\n \n+        self.min_size = offset;\n+\n         Ok(())\n     }\n \n     /// Get the size without trailing alignment padding.\n-    pub fn min_size(&self) -> Size {\n-        self.offset_after_field.last().map_or(Size::from_bytes(0), |&last| last)\n-    }\n \n     /// Get the size with trailing aligment padding.\n     pub fn stride(&self) -> Size {\n-        self.min_size().abi_align(self.align)\n+        self.min_size.abi_align(self.align)\n     }\n \n     /// Determine whether a structure would be zero-sized, given its fields.\n@@ -671,15 +669,6 @@ impl<'a, 'gcx, 'tcx> Struct {\n         }\n         Ok(None)\n     }\n-\n-    pub fn offset_of_field(&self, index: usize) -> Size {\n-        assert!(index < self.offset_after_field.len());\n-        if index == 0 {\n-            Size::from_bytes(0)\n-        } else {\n-            self.offset_after_field[index-1]\n-        }\n-    }\n }\n \n /// An untagged union.\n@@ -1138,7 +1127,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     });\n                     let mut st = Struct::new(dl, false);\n                     st.extend(dl, discr.iter().map(Ok).chain(fields), ty)?;\n-                    size = cmp::max(size, st.min_size());\n+                    size = cmp::max(size, st.min_size);\n                     align = align.max(st.align);\n                     Ok(st)\n                 }).collect::<Result<Vec<_>, _>>()?;\n@@ -1171,12 +1160,16 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     let old_ity_size = Int(min_ity).size(dl);\n                     let new_ity_size = Int(ity).size(dl);\n                     for variant in &mut variants {\n-                        for offset in &mut variant.offset_after_field {\n+                        for offset in &mut variant.offsets[1..] {\n                             if *offset > old_ity_size {\n                                 break;\n                             }\n                             *offset = new_ity_size;\n                         }\n+                        // We might be making the struct larger.\n+                        if variant.min_size <= old_ity_size {\n+                            variant.min_size = new_ity_size;\n+                        }\n                     }\n                 }\n "}, {"sha": "4caf7a04fe05806d40834755117b5f87e95e4a5a", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9482bce56e9b56b91ec6c6af92eb660961ce8734/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9482bce56e9b56b91ec6c6af92eb660961ce8734/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9482bce56e9b56b91ec6c6af92eb660961ce8734", "patch": "@@ -738,7 +738,7 @@ impl LateLintPass for VariantSizeDifferences {\n                         .zip(variants)\n                         .map(|(variant, variant_layout)| {\n                             // Subtract the size of the enum discriminant\n-                            let bytes = variant_layout.min_size().bytes()\n+                            let bytes = variant_layout.min_size.bytes()\n                                                                  .saturating_sub(discr_size);\n \n                             debug!(\"- variant `{}` is {} bytes large\", variant.node.name, bytes);"}, {"sha": "f5cbe138cc5eb6216af21799ceb09662425b2b12", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9482bce56e9b56b91ec6c6af92eb660961ce8734/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9482bce56e9b56b91ec6c6af92eb660961ce8734/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=9482bce56e9b56b91ec6c6af92eb660961ce8734", "patch": "@@ -632,7 +632,7 @@ fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     let meta = val.meta;\n \n \n-    let offset = st.offset_of_field(ix).bytes();\n+    let offset = st.offsets[ix].bytes();\n     let unaligned_offset = C_uint(bcx.ccx(), offset);\n \n     // Get the alignment of the field\n@@ -695,9 +695,9 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>, discr: D\n             let lldiscr = C_integral(Type::from_integer(ccx, d), discr.0 as u64, true);\n             let mut vals_with_discr = vec![lldiscr];\n             vals_with_discr.extend_from_slice(vals);\n-            let mut contents = build_const_struct(ccx, &variant.offset_after_field[..],\n-                &vals_with_discr[..], variant.packed);\n-            let needed_padding = l.size(dl).bytes() - variant.min_size().bytes();\n+            let mut contents = build_const_struct(ccx, &variant,\n+                &vals_with_discr[..]);\n+            let needed_padding = l.size(dl).bytes() - variant.min_size.bytes();\n             if needed_padding > 0 {\n                 contents.push(padding(ccx, needed_padding));\n             }\n@@ -711,7 +711,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>, discr: D\n         layout::Univariant { ref variant, .. } => {\n             assert_eq!(discr, Disr(0));\n             let contents = build_const_struct(ccx,\n-                &variant.offset_after_field[..], vals, variant.packed);\n+                &variant, vals);\n             C_struct(ccx, &contents[..], variant.packed)\n         }\n         layout::Vector { .. } => {\n@@ -728,9 +728,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>, discr: D\n         }\n         layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n             if discr.0 == nndiscr {\n-                C_struct(ccx, &build_const_struct(ccx,\n-                                                 &nonnull.offset_after_field[..],\n-                                                 vals, nonnull.packed),\n+                C_struct(ccx, &build_const_struct(ccx, &nonnull, vals),\n                          false)\n             } else {\n                 let fields = compute_fields(ccx, t, nndiscr as usize, false);\n@@ -739,10 +737,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>, discr: D\n                     // field; see #8506.\n                     C_null(type_of::sizing_type_of(ccx, ty))\n                 }).collect::<Vec<ValueRef>>();\n-                C_struct(ccx, &build_const_struct(ccx,\n-                                                 &nonnull.offset_after_field[..],\n-                                                 &vals[..],\n-                                                 false),\n+                C_struct(ccx, &build_const_struct(ccx, &nonnull, &vals[..]),\n                          false)\n             }\n         }\n@@ -759,11 +754,10 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>, discr: D\n /// a two-element struct will locate it at offset 4, and accesses to it\n /// will read the wrong memory.\n fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                offset_after_field: &[layout::Size],\n-                                vals: &[ValueRef],\n-                                packed: bool)\n+                                st: &layout::Struct,\n+                                vals: &[ValueRef])\n                                 -> Vec<ValueRef> {\n-    assert_eq!(vals.len(), offset_after_field.len());\n+    assert_eq!(vals.len(), st.offsets.len());\n \n     if vals.len() == 0 {\n         return Vec::new();\n@@ -772,24 +766,19 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // offset of current value\n     let mut offset = 0;\n     let mut cfields = Vec::new();\n-    let target_offsets = offset_after_field.iter().map(|i| i.bytes());\n-    for (&val, target_offset) in vals.iter().zip(target_offsets) {\n-        assert!(!is_undef(val));\n-        cfields.push(val);\n-        offset += machine::llsize_of_alloc(ccx, val_ty(val));\n-        if !packed {\n-            let val_align = machine::llalign_of_min(ccx, val_ty(val));\n-            offset = roundup(offset, val_align);\n-        }\n-        if offset != target_offset {\n+    let offsets = st.offsets.iter().map(|i| i.bytes());\n+    for (&val, target_offset) in vals.iter().zip(offsets) {\n+        if offset < target_offset {\n             cfields.push(padding(ccx, target_offset - offset));\n             offset = target_offset;\n         }\n+        assert!(!is_undef(val));\n+        cfields.push(val);\n+        offset += machine::llsize_of_alloc(ccx, val_ty(val));\n     }\n \n-    let size = offset_after_field.last().unwrap();\n-    if offset < size.bytes() {\n-        cfields.push(padding(ccx, size.bytes() - offset));\n+    if offset < st.min_size.bytes() {\n+        cfields.push(padding(ccx, st.min_size.bytes() - offset));\n     }\n \n     cfields"}, {"sha": "6ae5fc1657aa728359f7b8f27df4743b537ec15a", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9482bce56e9b56b91ec6c6af92eb660961ce8734/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9482bce56e9b56b91ec6c6af92eb660961ce8734/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=9482bce56e9b56b91ec6c6af92eb660961ce8734", "patch": "@@ -127,7 +127,7 @@ pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n         Layout::FatPointer { .. } => true,\n         Layout::Univariant { ref variant, .. } => {\n             // There must be only 2 fields.\n-            if variant.offset_after_field.len() != 2 {\n+            if variant.offsets.len() != 2 {\n                 return false;\n             }\n "}, {"sha": "64d959d29080ccc975c67fef1208e92c9a8a2cf6", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9482bce56e9b56b91ec6c6af92eb660961ce8734/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9482bce56e9b56b91ec6c6af92eb660961ce8734/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=9482bce56e9b56b91ec6c6af92eb660961ce8734", "patch": "@@ -335,20 +335,9 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             let layout = ccx.layout_of(t);\n             debug!(\"DST {} layout: {:?}\", t, layout);\n \n-            // Returns size in bytes of all fields except the last one\n-            // (we will be recursing on the last one).\n-            fn local_prefix_bytes(variant: &ty::layout::Struct) -> u64 {\n-                let fields = variant.offset_after_field.len();\n-                if fields > 1 {\n-                    variant.offset_after_field[fields - 2].bytes()\n-                } else {\n-                    0\n-                }\n-            }\n-\n             let (sized_size, sized_align) = match *layout {\n                 ty::layout::Layout::Univariant { ref variant, .. } => {\n-                    (local_prefix_bytes(variant), variant.align.abi())\n+                    (variant.offsets.last().map_or(0, |o| o.bytes()), variant.align.abi())\n                 }\n                 _ => {\n                     bug!(\"size_and_align_of_dst: expcted Univariant for `{}`, found {:#?}\","}]}