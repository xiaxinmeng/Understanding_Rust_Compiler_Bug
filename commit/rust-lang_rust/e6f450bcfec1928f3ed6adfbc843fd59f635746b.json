{"sha": "e6f450bcfec1928f3ed6adfbc843fd59f635746b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZjQ1MGJjZmVjMTkyOGYzZWQ2YWRmYmM4NDNmZDU5ZjYzNTc0NmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-30T22:20:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-30T22:20:36Z"}, "message": "Auto merge of #86489 - cjgillot:lower, r=petrochenkov\n\nSimplify early compilation interface\n\n* separate resolver creation and AST configuration.\n* bundle lowering with global_ctxt creation.", "tree": {"sha": "6d189d535b7b79226cb465669d49846f14e6933f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d189d535b7b79226cb465669d49846f14e6933f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6f450bcfec1928f3ed6adfbc843fd59f635746b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6f450bcfec1928f3ed6adfbc843fd59f635746b", "html_url": "https://github.com/rust-lang/rust/commit/e6f450bcfec1928f3ed6adfbc843fd59f635746b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6f450bcfec1928f3ed6adfbc843fd59f635746b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "868c702d0c9a471a28fb55f0148eb1e3e8b1dcc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/868c702d0c9a471a28fb55f0148eb1e3e8b1dcc5", "html_url": "https://github.com/rust-lang/rust/commit/868c702d0c9a471a28fb55f0148eb1e3e8b1dcc5"}, {"sha": "f69877426a6a65fceccaedf9a1e82fa5f05de9d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f69877426a6a65fceccaedf9a1e82fa5f05de9d2", "html_url": "https://github.com/rust-lang/rust/commit/f69877426a6a65fceccaedf9a1e82fa5f05de9d2"}], "stats": {"total": 269, "additions": 101, "deletions": 168}, "files": [{"sha": "7a4e39376a86d7c50318cc3fa19d5b3cb4b7f7af", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6f450bcfec1928f3ed6adfbc843fd59f635746b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6f450bcfec1928f3ed6adfbc843fd59f635746b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=e6f450bcfec1928f3ed6adfbc843fd59f635746b", "patch": "@@ -296,7 +296,7 @@ pub fn lower_crate<'a, 'hir>(\n     resolver: &'a mut dyn ResolverAstLowering,\n     nt_to_tokenstream: NtToTokenstream,\n     arena: &'hir Arena<'hir>,\n-) -> hir::Crate<'hir> {\n+) -> &'hir hir::Crate<'hir> {\n     let _prof_timer = sess.prof.verbose_generic_activity(\"hir_lowering\");\n \n     LoweringContext {\n@@ -403,7 +403,7 @@ enum AnonymousLifetimeMode {\n }\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n-    fn lower_crate(mut self, c: &Crate) -> hir::Crate<'hir> {\n+    fn lower_crate(mut self, c: &Crate) -> &'hir hir::Crate<'hir> {\n         /// Full-crate AST visitor that inserts into a fresh\n         /// `LoweringContext` any information that may be\n         /// needed from arbitrary locations in the crate,\n@@ -530,7 +530,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n \n-        hir::Crate {\n+        let krate = hir::Crate {\n             item: module,\n             exported_macros: self.arena.alloc_from_iter(self.exported_macros),\n             non_exported_macro_attrs: self.arena.alloc_from_iter(self.non_exported_macro_attrs),\n@@ -545,7 +545,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             proc_macros,\n             trait_map,\n             attrs: self.attrs,\n-        }\n+        };\n+        self.arena.alloc(krate)\n     }\n \n     fn insert_item(&mut self, item: hir::Item<'hir>) -> hir::ItemId {"}, {"sha": "20f1e192a618b6e8cbb307be65ed22ca2fb18dc8", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e6f450bcfec1928f3ed6adfbc843fd59f635746b/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6f450bcfec1928f3ed6adfbc843fd59f635746b/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=e6f450bcfec1928f3ed6adfbc843fd59f635746b", "patch": "@@ -46,7 +46,6 @@ use std::ffi::OsString;\n use std::fs;\n use std::io::{self, Read, Write};\n use std::lazy::SyncLazy;\n-use std::mem;\n use std::panic::{self, catch_unwind};\n use std::path::PathBuf;\n use std::process::{self, Command, Stdio};\n@@ -316,12 +315,12 @@ fn run_compiler(\n \n             if let Some(ppm) = &sess.opts.pretty {\n                 if ppm.needs_ast_map() {\n+                    let expanded_crate = queries.expansion()?.peek().0.clone();\n                     queries.global_ctxt()?.peek_mut().enter(|tcx| {\n-                        let expanded_crate = queries.expansion()?.take().0;\n                         pretty::print_after_hir_lowering(\n                             tcx,\n                             compiler.input(),\n-                            &expanded_crate,\n+                            &*expanded_crate,\n                             *ppm,\n                             compiler.output_file().as_ref().map(|p| &**p),\n                         );\n@@ -377,12 +376,6 @@ fn run_compiler(\n \n             queries.global_ctxt()?;\n \n-            // Drop AST after creating GlobalCtxt to free memory\n-            {\n-                let _timer = sess.prof.generic_activity(\"drop_ast\");\n-                mem::drop(queries.expansion()?.take());\n-            }\n-\n             if sess.opts.debugging_opts.no_analysis || sess.opts.debugging_opts.ast_json {\n                 return early_exit();\n             }"}, {"sha": "ee62089b2376003d84b526073cc84c21b4a00ba1", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e6f450bcfec1928f3ed6adfbc843fd59f635746b/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6f450bcfec1928f3ed6adfbc843fd59f635746b/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=e6f450bcfec1928f3ed6adfbc843fd59f635746b", "patch": "@@ -21,8 +21,8 @@ pub enum LoadResult<T> {\n     Error { message: String },\n }\n \n-impl LoadResult<(SerializedDepGraph, WorkProductMap)> {\n-    pub fn open(self, sess: &Session) -> (SerializedDepGraph, WorkProductMap) {\n+impl<T: Default> LoadResult<T> {\n+    pub fn open(self, sess: &Session) -> T {\n         match self {\n             LoadResult::Error { message } => {\n                 sess.warn(&message);\n@@ -74,11 +74,14 @@ pub enum MaybeAsync<T> {\n     Sync(T),\n     Async(std::thread::JoinHandle<T>),\n }\n-impl<T> MaybeAsync<T> {\n-    pub fn open(self) -> std::thread::Result<T> {\n+\n+impl<T> MaybeAsync<LoadResult<T>> {\n+    pub fn open(self) -> LoadResult<T> {\n         match self {\n-            MaybeAsync::Sync(result) => Ok(result),\n-            MaybeAsync::Async(handle) => handle.join(),\n+            MaybeAsync::Sync(result) => result,\n+            MaybeAsync::Async(handle) => handle.join().unwrap_or_else(|e| LoadResult::Error {\n+                message: format!(\"could not decode incremental cache: {:?}\", e),\n+            }),\n         }\n     }\n }"}, {"sha": "9ea1f88b43f79a48e72e68ccaa5c2a8322472109", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 52, "deletions": 73, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/e6f450bcfec1928f3ed6adfbc843fd59f635746b/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6f450bcfec1928f3ed6adfbc843fd59f635746b/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=e6f450bcfec1928f3ed6adfbc843fd59f635746b", "patch": "@@ -7,7 +7,6 @@ use rustc_ast::{self as ast, visit};\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::parallel;\n-use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{par_iter, Lrc, OnceCell, ParallelIterator, WorkerLocal};\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::{ErrorReported, PResult};\n@@ -101,7 +100,7 @@ mod boxed_resolver {\n     }\n \n     // Note: Drop order is important to prevent dangling references. Resolver must be dropped first,\n-    // then resolver_arenas and finally session.\n+    // then resolver_arenas and session.\n     impl Drop for BoxedResolverInner {\n         fn drop(&mut self) {\n             self.resolver.take();\n@@ -110,13 +109,10 @@ mod boxed_resolver {\n     }\n \n     impl BoxedResolver {\n-        pub(super) fn new<F>(session: Lrc<Session>, make_resolver: F) -> Result<(ast::Crate, Self)>\n-        where\n-            F: for<'a> FnOnce(\n-                &'a Session,\n-                &'a ResolverArenas<'a>,\n-            ) -> Result<(ast::Crate, Resolver<'a>)>,\n-        {\n+        pub(super) fn new(\n+            session: Lrc<Session>,\n+            make_resolver: impl for<'a> FnOnce(&'a Session, &'a ResolverArenas<'a>) -> Resolver<'a>,\n+        ) -> BoxedResolver {\n             let mut boxed_resolver = Box::new(BoxedResolverInner {\n                 session,\n                 resolver_arenas: Some(Resolver::arenas()),\n@@ -127,14 +123,14 @@ mod boxed_resolver {\n             // returns a resolver with the same lifetime as the arena. We ensure that the arena\n             // outlives the resolver in the drop impl and elsewhere so these transmutes are sound.\n             unsafe {\n-                let (crate_, resolver) = make_resolver(\n+                let resolver = make_resolver(\n                     std::mem::transmute::<&Session, &Session>(&boxed_resolver.session),\n                     std::mem::transmute::<&ResolverArenas<'_>, &ResolverArenas<'_>>(\n                         boxed_resolver.resolver_arenas.as_ref().unwrap(),\n                     ),\n-                )?;\n+                );\n                 boxed_resolver.resolver = Some(resolver);\n-                Ok((crate_, BoxedResolver(Pin::new_unchecked(boxed_resolver))))\n+                BoxedResolver(Pin::new_unchecked(boxed_resolver))\n             }\n         }\n \n@@ -165,35 +161,15 @@ mod boxed_resolver {\n     }\n }\n \n-/// Runs the \"early phases\" of the compiler: initial `cfg` processing, loading compiler plugins,\n-/// syntax expansion, secondary `cfg` expansion, synthesis of a test\n-/// harness if one is to be provided, injection of a dependency on the\n-/// standard library and prelude, and name resolution.\n-///\n-/// Returns [`None`] if we're aborting after handling -W help.\n-pub fn configure_and_expand(\n+pub fn create_resolver(\n     sess: Lrc<Session>,\n-    lint_store: Lrc<LintStore>,\n     metadata_loader: Box<MetadataLoaderDyn>,\n-    krate: ast::Crate,\n+    krate: &ast::Crate,\n     crate_name: &str,\n-) -> Result<(ast::Crate, BoxedResolver)> {\n-    tracing::trace!(\"configure_and_expand\");\n-    // Currently, we ignore the name resolution data structures for the purposes of dependency\n-    // tracking. Instead we will run name resolution and include its output in the hash of each\n-    // item, much like we do for macro expansion. In other words, the hash reflects not just\n-    // its contents but the results of name resolution on those contents. Hopefully we'll push\n-    // this back at some point.\n-    let crate_name = crate_name.to_string();\n+) -> BoxedResolver {\n+    tracing::trace!(\"create_resolver\");\n     BoxedResolver::new(sess, move |sess, resolver_arenas| {\n-        configure_and_expand_inner(\n-            sess,\n-            &lint_store,\n-            krate,\n-            &crate_name,\n-            &resolver_arenas,\n-            metadata_loader,\n-        )\n+        Resolver::new(sess, &krate, &crate_name, metadata_loader, &resolver_arenas)\n     })\n }\n \n@@ -278,28 +254,24 @@ fn pre_expansion_lint(\n     });\n }\n \n-fn configure_and_expand_inner<'a>(\n-    sess: &'a Session,\n+/// Runs the \"early phases\" of the compiler: initial `cfg` processing, loading compiler plugins,\n+/// syntax expansion, secondary `cfg` expansion, synthesis of a test\n+/// harness if one is to be provided, injection of a dependency on the\n+/// standard library and prelude, and name resolution.\n+pub fn configure_and_expand(\n+    sess: &Session,\n     lint_store: &LintStore,\n     mut krate: ast::Crate,\n     crate_name: &str,\n-    resolver_arenas: &'a ResolverArenas<'a>,\n-    metadata_loader: Box<MetadataLoaderDyn>,\n-) -> Result<(ast::Crate, Resolver<'a>)> {\n-    tracing::trace!(\"configure_and_expand_inner\");\n+    resolver: &mut Resolver<'_>,\n+) -> Result<ast::Crate> {\n+    tracing::trace!(\"configure_and_expand\");\n     pre_expansion_lint(sess, lint_store, &krate, crate_name);\n-\n-    let mut resolver = Resolver::new(sess, &krate, crate_name, metadata_loader, &resolver_arenas);\n-    rustc_builtin_macros::register_builtin_macros(&mut resolver);\n+    rustc_builtin_macros::register_builtin_macros(resolver);\n \n     krate = sess.time(\"crate_injection\", || {\n         let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| Symbol::intern(s));\n-        rustc_builtin_macros::standard_library_imports::inject(\n-            krate,\n-            &mut resolver,\n-            &sess,\n-            alt_std_name,\n-        )\n+        rustc_builtin_macros::standard_library_imports::inject(krate, resolver, &sess, alt_std_name)\n     });\n \n     util::check_attr_crate_type(&sess, &krate.attrs, &mut resolver.lint_buffer());\n@@ -354,7 +326,7 @@ fn configure_and_expand_inner<'a>(\n             pre_expansion_lint(sess, lint_store, &krate, &ident.name.as_str());\n             (krate.attrs, krate.items)\n         };\n-        let mut ecx = ExtCtxt::new(&sess, cfg, &mut resolver, Some(&extern_mod_loaded));\n+        let mut ecx = ExtCtxt::new(&sess, cfg, resolver, Some(&extern_mod_loaded));\n \n         // Expand macros now!\n         let krate = sess.time(\"expand_crate\", || ecx.monotonic_expander().expand_crate(krate));\n@@ -396,16 +368,16 @@ fn configure_and_expand_inner<'a>(\n     })?;\n \n     sess.time(\"maybe_building_test_harness\", || {\n-        rustc_builtin_macros::test_harness::inject(&sess, &mut resolver, &mut krate)\n+        rustc_builtin_macros::test_harness::inject(&sess, resolver, &mut krate)\n     });\n \n     if let Some(PpMode::Source(PpSourceMode::EveryBodyLoops)) = sess.opts.pretty {\n         tracing::debug!(\"replacing bodies with loop {{}}\");\n-        util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n+        util::ReplaceBodyWithLoop::new(resolver).visit_crate(&mut krate);\n     }\n \n     let has_proc_macro_decls = sess.time(\"AST_validation\", || {\n-        rustc_ast_passes::ast_validation::check_crate(sess, &krate, &mut resolver.lint_buffer())\n+        rustc_ast_passes::ast_validation::check_crate(sess, &krate, resolver.lint_buffer())\n     });\n \n     let crate_types = sess.crate_types();\n@@ -431,7 +403,7 @@ fn configure_and_expand_inner<'a>(\n             let is_test_crate = sess.opts.test;\n             rustc_builtin_macros::proc_macro_harness::inject(\n                 &sess,\n-                &mut resolver,\n+                resolver,\n                 krate,\n                 is_proc_macro_crate,\n                 has_proc_macro_decls,\n@@ -471,26 +443,20 @@ fn configure_and_expand_inner<'a>(\n         }\n     });\n \n-    Ok((krate, resolver))\n+    Ok(krate)\n }\n \n pub fn lower_to_hir<'res, 'tcx>(\n     sess: &'tcx Session,\n     lint_store: &LintStore,\n     resolver: &'res mut Resolver<'_>,\n-    dep_graph: &'res DepGraph,\n-    krate: &'res ast::Crate,\n+    krate: Rc<ast::Crate>,\n     arena: &'tcx rustc_ast_lowering::Arena<'tcx>,\n-) -> Crate<'tcx> {\n-    // We're constructing the HIR here; we don't care what we will\n-    // read, since we haven't even constructed the *input* to\n-    // incr. comp. yet.\n-    dep_graph.assert_ignored();\n-\n+) -> &'tcx Crate<'tcx> {\n     // Lower AST to HIR.\n     let hir_crate = rustc_ast_lowering::lower_crate(\n         sess,\n-        &krate,\n+        &*krate,\n         resolver,\n         rustc_parse::nt_to_tokenstream,\n         arena,\n@@ -511,6 +477,9 @@ pub fn lower_to_hir<'res, 'tcx>(\n         )\n     });\n \n+    // Drop AST to free memory\n+    sess.time(\"drop_ast\", || std::mem::drop(krate));\n+\n     // Discard hygiene data, which isn't required after lowering to HIR.\n     if !sess.opts.debugging_opts.keep_hygiene_data {\n         rustc_span::hygiene::clear_syntax_context_map();\n@@ -603,7 +572,7 @@ fn escape_dep_env(symbol: Symbol) -> String {\n \n fn write_out_deps(\n     sess: &Session,\n-    boxed_resolver: &Steal<Rc<RefCell<BoxedResolver>>>,\n+    boxed_resolver: &RefCell<BoxedResolver>,\n     outputs: &OutputFilenames,\n     out_filenames: &[PathBuf],\n ) {\n@@ -630,7 +599,7 @@ fn write_out_deps(\n         }\n \n         if sess.binary_dep_depinfo() {\n-            boxed_resolver.borrow().borrow_mut().access(|resolver| {\n+            boxed_resolver.borrow_mut().access(|resolver| {\n                 for cnum in resolver.cstore().crates_untracked() {\n                     let source = resolver.cstore().crate_source_untracked(cnum);\n                     if let Some((path, _)) = source.dylib {\n@@ -699,7 +668,7 @@ pub fn prepare_outputs(\n     sess: &Session,\n     compiler: &Compiler,\n     krate: &ast::Crate,\n-    boxed_resolver: &Steal<Rc<RefCell<BoxedResolver>>>,\n+    boxed_resolver: &RefCell<BoxedResolver>,\n     crate_name: &str,\n ) -> Result<OutputFilenames> {\n     let _timer = sess.timer(\"prepare_outputs\");\n@@ -803,16 +772,26 @@ impl<'tcx> QueryContext<'tcx> {\n pub fn create_global_ctxt<'tcx>(\n     compiler: &'tcx Compiler,\n     lint_store: Lrc<LintStore>,\n-    krate: &'tcx Crate<'tcx>,\n+    krate: Rc<ast::Crate>,\n     dep_graph: DepGraph,\n-    resolver_outputs: ResolverOutputs,\n+    resolver: Rc<RefCell<BoxedResolver>>,\n     outputs: OutputFilenames,\n     crate_name: &str,\n     queries: &'tcx OnceCell<TcxQueries<'tcx>>,\n     global_ctxt: &'tcx OnceCell<GlobalCtxt<'tcx>>,\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n+    hir_arena: &'tcx WorkerLocal<rustc_ast_lowering::Arena<'tcx>>,\n ) -> QueryContext<'tcx> {\n+    // We're constructing the HIR here; we don't care what we will\n+    // read, since we haven't even constructed the *input* to\n+    // incr. comp. yet.\n+    dep_graph.assert_ignored();\n+\n     let sess = &compiler.session();\n+    let krate = resolver\n+        .borrow_mut()\n+        .access(|resolver| lower_to_hir(sess, &lint_store, resolver, krate, hir_arena));\n+    let resolver_outputs = BoxedResolver::to_resolver_outputs(resolver);\n \n     let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n \n@@ -831,7 +810,7 @@ pub fn create_global_ctxt<'tcx>(\n     let queries = queries.get_or_init(|| TcxQueries::new(local_providers, extern_providers));\n \n     let gcx = sess.time(\"setup_global_ctxt\", || {\n-        global_ctxt.get_or_init(|| {\n+        global_ctxt.get_or_init(move || {\n             TyCtxt::create_global_ctxt(\n                 sess,\n                 lint_store,"}, {"sha": "8a0964e6b9f92ba7f84259455f6cbe58c666e1a2", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 31, "deletions": 72, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/e6f450bcfec1928f3ed6adfbc843fd59f635746b/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6f450bcfec1928f3ed6adfbc843fd59f635746b/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=e6f450bcfec1928f3ed6adfbc843fd59f635746b", "patch": "@@ -3,17 +3,15 @@ use crate::passes::{self, BoxedResolver, QueryContext};\n \n use rustc_ast as ast;\n use rustc_codegen_ssa::traits::CodegenBackend;\n-use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_errors::ErrorReported;\n use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_hir::Crate;\n use rustc_incremental::DepGraphFuture;\n use rustc_lint::LintStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n-use rustc_middle::ty::{GlobalCtxt, ResolverOutputs, TyCtxt};\n+use rustc_middle::ty::{GlobalCtxt, TyCtxt};\n use rustc_query_impl::Queries as TcxQueries;\n use rustc_serialize::json;\n use rustc_session::config::{self, OutputFilenames, OutputType};\n@@ -81,9 +79,8 @@ pub struct Queries<'tcx> {\n     parse: Query<ast::Crate>,\n     crate_name: Query<String>,\n     register_plugins: Query<(ast::Crate, Lrc<LintStore>)>,\n-    expansion: Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>,\n+    expansion: Query<(Rc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n-    lower_to_hir: Query<(&'tcx Crate<'tcx>, Steal<ResolverOutputs>)>,\n     prepare_outputs: Query<OutputFilenames>,\n     global_ctxt: Query<QueryContext<'tcx>>,\n     ongoing_codegen: Query<Box<dyn Any>>,\n@@ -103,7 +100,6 @@ impl<'tcx> Queries<'tcx> {\n             register_plugins: Default::default(),\n             expansion: Default::default(),\n             dep_graph: Default::default(),\n-            lower_to_hir: Default::default(),\n             prepare_outputs: Default::default(),\n             global_ctxt: Default::default(),\n             ongoing_codegen: Default::default(),\n@@ -117,13 +113,10 @@ impl<'tcx> Queries<'tcx> {\n         &self.compiler.codegen_backend()\n     }\n \n-    pub fn dep_graph_future(&self) -> Result<&Query<Option<DepGraphFuture>>> {\n+    fn dep_graph_future(&self) -> Result<&Query<Option<DepGraphFuture>>> {\n         self.dep_graph_future.compute(|| {\n-            Ok(self\n-                .session()\n-                .opts\n-                .build_dep_graph()\n-                .then(|| rustc_incremental::load_dep_graph(self.session())))\n+            let sess = self.session();\n+            Ok(sess.opts.build_dep_graph().then(|| rustc_incremental::load_dep_graph(sess)))\n         })\n     }\n \n@@ -174,83 +167,51 @@ impl<'tcx> Queries<'tcx> {\n \n     pub fn expansion(\n         &self,\n-    ) -> Result<&Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>> {\n+    ) -> Result<&Query<(Rc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>> {\n         tracing::trace!(\"expansion\");\n         self.expansion.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let (krate, lint_store) = self.register_plugins()?.take();\n             let _timer = self.session().timer(\"configure_and_expand\");\n-            passes::configure_and_expand(\n-                self.session().clone(),\n-                lint_store.clone(),\n+            let sess = self.session();\n+            let mut resolver = passes::create_resolver(\n+                sess.clone(),\n                 self.codegen_backend().metadata_loader(),\n-                krate,\n+                &krate,\n                 &crate_name,\n-            )\n-            .map(|(krate, resolver)| {\n-                (krate, Steal::new(Rc::new(RefCell::new(resolver))), lint_store)\n-            })\n+            );\n+            let krate = resolver.access(|resolver| {\n+                passes::configure_and_expand(&sess, &lint_store, krate, &crate_name, resolver)\n+            })?;\n+            Ok((Rc::new(krate), Rc::new(RefCell::new(resolver)), lint_store))\n         })\n     }\n \n-    pub fn dep_graph(&self) -> Result<&Query<DepGraph>> {\n+    fn dep_graph(&self) -> Result<&Query<DepGraph>> {\n         self.dep_graph.compute(|| {\n-            Ok(match self.dep_graph_future()?.take() {\n-                None => DepGraph::new_disabled(),\n-                Some(future) => {\n+            let sess = self.session();\n+            let future_opt = self.dep_graph_future()?.take();\n+            let dep_graph = future_opt\n+                .and_then(|future| {\n                     let (prev_graph, prev_work_products) =\n-                        self.session().time(\"blocked_on_dep_graph_loading\", || {\n-                            future\n-                                .open()\n-                                .unwrap_or_else(|e| rustc_incremental::LoadResult::Error {\n-                                    message: format!(\"could not decode incremental cache: {:?}\", e),\n-                                })\n-                                .open(self.session())\n-                        });\n-\n-                    rustc_incremental::build_dep_graph(\n-                        self.session(),\n-                        prev_graph,\n-                        prev_work_products,\n-                    )\n-                    .unwrap_or_else(DepGraph::new_disabled)\n-                }\n-            })\n-        })\n-    }\n+                        sess.time(\"blocked_on_dep_graph_loading\", || future.open().open(sess));\n \n-    pub fn lower_to_hir(&'tcx self) -> Result<&Query<(&'tcx Crate<'tcx>, Steal<ResolverOutputs>)>> {\n-        self.lower_to_hir.compute(|| {\n-            let expansion_result = self.expansion()?;\n-            let peeked = expansion_result.peek();\n-            let krate = &peeked.0;\n-            let resolver = peeked.1.steal();\n-            let lint_store = &peeked.2;\n-            let hir = resolver.borrow_mut().access(|resolver| {\n-                Ok(passes::lower_to_hir(\n-                    self.session(),\n-                    lint_store,\n-                    resolver,\n-                    &*self.dep_graph()?.peek(),\n-                    &krate,\n-                    &self.hir_arena,\n-                ))\n-            })?;\n-            let hir = self.hir_arena.alloc(hir);\n-            Ok((hir, Steal::new(BoxedResolver::to_resolver_outputs(resolver))))\n+                    rustc_incremental::build_dep_graph(sess, prev_graph, prev_work_products)\n+                })\n+                .unwrap_or_else(DepGraph::new_disabled);\n+            Ok(dep_graph)\n         })\n     }\n \n     pub fn prepare_outputs(&self) -> Result<&Query<OutputFilenames>> {\n         self.prepare_outputs.compute(|| {\n-            let expansion_result = self.expansion()?;\n-            let (krate, boxed_resolver, _) = &*expansion_result.peek();\n+            let (krate, boxed_resolver, _) = &*self.expansion()?.peek();\n             let crate_name = self.crate_name()?.peek();\n             passes::prepare_outputs(\n                 self.session(),\n                 self.compiler,\n-                &krate,\n-                &boxed_resolver,\n+                krate,\n+                &*boxed_resolver,\n                 &crate_name,\n             )\n         })\n@@ -260,22 +221,20 @@ impl<'tcx> Queries<'tcx> {\n         self.global_ctxt.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let outputs = self.prepare_outputs()?.peek().clone();\n-            let lint_store = self.expansion()?.peek().2.clone();\n-            let hir = self.lower_to_hir()?.peek();\n             let dep_graph = self.dep_graph()?.peek().clone();\n-            let (ref krate, ref resolver_outputs) = &*hir;\n-            let _timer = self.session().timer(\"create_global_ctxt\");\n+            let (krate, resolver, lint_store) = self.expansion()?.take();\n             Ok(passes::create_global_ctxt(\n                 self.compiler,\n                 lint_store,\n                 krate,\n                 dep_graph,\n-                resolver_outputs.steal(),\n+                resolver,\n                 outputs,\n                 &crate_name,\n                 &self.queries,\n                 &self.gcx,\n                 &self.arena,\n+                &self.hir_arena,\n             ))\n         })\n     }"}, {"sha": "71fcde8bca89f51566251db2bddc5f2903874f70", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e6f450bcfec1928f3ed6adfbc843fd59f635746b/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6f450bcfec1928f3ed6adfbc843fd59f635746b/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e6f450bcfec1928f3ed6adfbc843fd59f635746b", "patch": "@@ -303,9 +303,8 @@ crate fn create_resolver<'a>(\n     queries: &Queries<'a>,\n     sess: &Session,\n ) -> Rc<RefCell<interface::BoxedResolver>> {\n-    let parts = abort_on_err(queries.expansion(), sess).peek();\n-    let (krate, resolver, _) = &*parts;\n-    let resolver = resolver.borrow().clone();\n+    let (krate, resolver, _) = &*abort_on_err(queries.expansion(), sess).peek();\n+    let resolver = resolver.clone();\n \n     let mut loader = crate::passes::collect_intra_doc_links::IntraLinkCrateLoader::new(resolver);\n     ast::visit::walk_crate(&mut loader, krate);"}, {"sha": "1281f76fd0fdc9d42739251f8799cf8ef54d87a9", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6f450bcfec1928f3ed6adfbc843fd59f635746b/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6f450bcfec1928f3ed6adfbc843fd59f635746b/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=e6f450bcfec1928f3ed6adfbc843fd59f635746b", "patch": "@@ -112,7 +112,6 @@ crate fn run(options: Options) -> Result<(), ErrorReported> {\n \n     let res = interface::run_compiler(config, |compiler| {\n         compiler.enter(|queries| {\n-            let _lower_to_hir = queries.lower_to_hir()?;\n             let mut global_ctxt = queries.global_ctxt()?.take();\n \n             let collector = global_ctxt.enter(|tcx| {"}]}