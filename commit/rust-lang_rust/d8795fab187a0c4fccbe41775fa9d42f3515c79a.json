{"sha": "d8795fab187a0c4fccbe41775fa9d42f3515c79a", "node_id": "C_kwDOAAsO6NoAKGQ4Nzk1ZmFiMTg3YTBjNGZjY2JlNDE3NzVmYTlkNDJmMzUxNWM3OWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-22T16:53:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-22T16:53:03Z"}, "message": "Auto merge of #2821 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "99944866851e1d8db3f35d7e73ae5b5812501f1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99944866851e1d8db3f35d7e73ae5b5812501f1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8795fab187a0c4fccbe41775fa9d42f3515c79a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8795fab187a0c4fccbe41775fa9d42f3515c79a", "html_url": "https://github.com/rust-lang/rust/commit/d8795fab187a0c4fccbe41775fa9d42f3515c79a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8795fab187a0c4fccbe41775fa9d42f3515c79a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c2adebf90c6eaf491b2c7ee9213e597381072b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c2adebf90c6eaf491b2c7ee9213e597381072b7", "html_url": "https://github.com/rust-lang/rust/commit/3c2adebf90c6eaf491b2c7ee9213e597381072b7"}, {"sha": "4f8534f446a6c55d5d53e72e4940ad35e9e0d50e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f8534f446a6c55d5d53e72e4940ad35e9e0d50e", "html_url": "https://github.com/rust-lang/rust/commit/4f8534f446a6c55d5d53e72e4940ad35e9e0d50e"}], "stats": {"total": 4927, "additions": 3130, "deletions": 1797}, "files": [{"sha": "9148b79e98016352998379523954214a8f065269", "filename": ".mailmap", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -29,6 +29,8 @@ Alexander Ronald Altman <alexanderaltman@me.com>\n Alexandre Martin <martin.alex32@hotmail.fr>\n Alexis Beingessner <a.beingessner@gmail.com>\n Alfie John <alfie@alfie.wtf> Alfie John <alfiej@fastmail.fm>\n+Alona Enraght-Moony <code@alona.page> <nixon.emoony@gmail.com>\n+Alona Enraght-Moony <code@alona.page> <nixon@caminus.local>\n Amos Onn <amosonn@gmail.com>\n Ana-Maria Mihalache <mihalacheana.maria@yahoo.com>\n Anatoly Ikorsky <aikorsky@gmail.com>\n@@ -415,7 +417,6 @@ Nicolas Abram <abramlujan@gmail.com>\n Nicole Mazzuca <npmazzuca@gmail.com>\n Nif Ward <nif.ward@gmail.com>\n Nika Layzell <nika@thelayzells.com> <michael@thelayzells.com>\n-Nixon Enraght-Moony <nixon.emoony@gmail.com>\n NODA Kai <nodakai@gmail.com>\n oliver <16816606+o752d@users.noreply.github.com>\n Oliver Middleton <olliemail27@gmail.com> <ollie27@users.noreply.github.com>"}, {"sha": "2b08aab41eddd38aca0e7a429f888dc8c08d33c7", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1128,9 +1128,9 @@ dependencies = [\n \n [[package]]\n name = \"curl-sys\"\n-version = \"0.4.59+curl-7.86.0\"\n+version = \"0.4.61+curl-8.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6cfce34829f448b08f55b7db6d0009e23e2e86a34e8c2b366269bf5799b4a407\"\n+checksum = \"14d05c10f541ae6f3bc5b3d923c20001f47db7d5f0b2bc6ad16490133842db79\"\n dependencies = [\n  \"cc\",\n  \"libc\","}, {"sha": "75a3dd0c0f3d6f953b157b8a0fceabe1deb8ab7c", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -24,6 +24,7 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::ObligationCtxt;\n \n use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n@@ -760,20 +761,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         else { return; };\n         // Try to find predicates on *generic params* that would allow copying `ty`\n         let infcx = tcx.infer_ctxt().build();\n-        let copy_did = infcx.tcx.require_lang_item(LangItem::Copy, Some(span));\n-        let cause = ObligationCause::new(\n-            span,\n-            self.mir_def_id(),\n-            rustc_infer::traits::ObligationCauseCode::MiscObligation,\n-        );\n-        let errors = rustc_trait_selection::traits::fully_solve_bound(\n-            &infcx,\n-            cause,\n-            self.param_env,\n-            // Erase any region vids from the type, which may not be resolved\n-            infcx.tcx.erase_regions(ty),\n-            copy_did,\n-        );\n+        let ocx = ObligationCtxt::new(&infcx);\n+        let copy_did = tcx.require_lang_item(LangItem::Copy, Some(span));\n+        let cause = ObligationCause::misc(span, self.mir_def_id());\n+\n+        ocx.register_bound(cause, self.param_env, infcx.tcx.erase_regions(ty), copy_did);\n+        let errors = ocx.select_all_or_error();\n \n         // Only emit suggestion if all required predicates are on generic\n         let predicates: Result<Vec<_>, _> = errors"}, {"sha": "9f543b71c5fa4098c406e3b1fcfc3832e70d3524", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1078,7 +1078,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     self.param_env,\n                                     tcx.mk_imm_ref(tcx.lifetimes.re_erased, tcx.erase_regions(ty)),\n                                     def_id,\n-                                    DUMMY_SP,\n                                 )\n                             }\n                             _ => false,"}, {"sha": "e542a1da053be7d1742d74715f98b2949e905691", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -284,7 +284,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // hidden type is well formed even without those bounds.\n         let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()));\n \n-        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id.to_def_id());\n+        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n \n         // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n         // the bounds that the function supplies."}, {"sha": "e2a592d851a8cd9a55e28e88bf603668cbdbd4a7", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -176,15 +176,14 @@ fn build_pointer_or_reference_di_node<'ll, 'tcx>(\n \n     return_if_di_node_created_in_meantime!(cx, unique_type_id);\n \n-    let (thin_pointer_size, thin_pointer_align) =\n-        cx.size_and_align_of(cx.tcx.mk_imm_ptr(cx.tcx.types.unit));\n+    let data_layout = &cx.tcx.data_layout;\n     let ptr_type_debuginfo_name = compute_debuginfo_type_name(cx.tcx, ptr_type, true);\n \n     match fat_pointer_kind(cx, pointee_type) {\n         None => {\n             // This is a thin pointer. Create a regular pointer type and give it the correct name.\n             debug_assert_eq!(\n-                (thin_pointer_size, thin_pointer_align),\n+                (data_layout.pointer_size, data_layout.pointer_align.abi),\n                 cx.size_and_align_of(ptr_type),\n                 \"ptr_type={}, pointee_type={}\",\n                 ptr_type,\n@@ -195,8 +194,8 @@ fn build_pointer_or_reference_di_node<'ll, 'tcx>(\n                 llvm::LLVMRustDIBuilderCreatePointerType(\n                     DIB(cx),\n                     pointee_type_di_node,\n-                    thin_pointer_size.bits(),\n-                    thin_pointer_align.bits() as u32,\n+                    data_layout.pointer_size.bits(),\n+                    data_layout.pointer_align.abi.bits() as u32,\n                     0, // Ignore DWARF address space.\n                     ptr_type_debuginfo_name.as_ptr().cast(),\n                     ptr_type_debuginfo_name.len(),"}, {"sha": "e403a1fd8ae78666c654664896630fe00faa9326", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -10,6 +10,7 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::middle::exported_symbols::{\n     metadata_symbol_name, ExportedSymbol, SymbolExportInfo, SymbolExportKind, SymbolExportLevel,\n };\n+use rustc_middle::query::LocalCrate;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::Instance;\n@@ -41,9 +42,7 @@ pub fn crates_export_threshold(crate_types: &[CrateType]) -> SymbolExportLevel {\n     }\n }\n \n-fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<SymbolExportInfo> {\n-    assert_eq!(cnum, LOCAL_CRATE);\n-\n+fn reachable_non_generics_provider(tcx: TyCtxt<'_>, _: LocalCrate) -> DefIdMap<SymbolExportInfo> {\n     if !tcx.sess.opts.output_types.should_codegen() {\n         return Default::default();\n     }\n@@ -154,10 +153,10 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n     reachable_non_generics\n }\n \n-fn is_reachable_non_generic_provider_local(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+fn is_reachable_non_generic_provider_local(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     let export_threshold = threshold(tcx);\n \n-    if let Some(&info) = tcx.reachable_non_generics(def_id.krate).get(&def_id) {\n+    if let Some(&info) = tcx.reachable_non_generics(LOCAL_CRATE).get(&def_id.to_def_id()) {\n         info.level.is_below_threshold(export_threshold)\n     } else {\n         false\n@@ -170,10 +169,8 @@ fn is_reachable_non_generic_provider_extern(tcx: TyCtxt<'_>, def_id: DefId) -> b\n \n fn exported_symbols_provider_local(\n     tcx: TyCtxt<'_>,\n-    cnum: CrateNum,\n+    _: LocalCrate,\n ) -> &[(ExportedSymbol<'_>, SymbolExportInfo)] {\n-    assert_eq!(cnum, LOCAL_CRATE);\n-\n     if !tcx.sess.opts.output_types.should_codegen() {\n         return &[];\n     }"}, {"sha": "037b07dec62972740b8b78cfb4229fec7c05840e", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -43,7 +43,7 @@ fn linkage_by_name(tcx: TyCtxt<'_>, def_id: LocalDefId, name: &str) -> Linkage {\n     }\n }\n \n-fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n+fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {\n     if cfg!(debug_assertions) {\n         let def_kind = tcx.def_kind(did);\n         assert!(\n@@ -52,7 +52,6 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n         );\n     }\n \n-    let did = did.expect_local();\n     let attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(did));\n     let mut codegen_fn_attrs = CodegenFnAttrs::new();\n     if tcx.should_inherit_track_caller(did) {"}, {"sha": "088a824fd8f14c05b6a15529eea4e6b6fbe9589d", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -32,8 +32,7 @@ pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n /// it is a trait impl/function, return if it has a `const` modifier. If it is an intrinsic,\n /// report whether said intrinsic has a `rustc_const_{un,}stable` attribute. Otherwise, return\n /// `Constness::NotConst`.\n-fn constness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Constness {\n-    let def_id = def_id.expect_local();\n+fn constness(tcx: TyCtxt<'_>, def_id: LocalDefId) -> hir::Constness {\n     let node = tcx.hir().get_by_def_id(def_id);\n \n     match node {"}, {"sha": "0d9cd78fe12ac9acd2f91c94fe78754dcb34783d", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -246,7 +246,7 @@ impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n             self.check_local_or_return_ty(return_ty.skip_binder(), RETURN_PLACE);\n         }\n \n-        if !tcx.has_attr(def_id.to_def_id(), sym::rustc_do_not_const_check) {\n+        if !tcx.has_attr(def_id, sym::rustc_do_not_const_check) {\n             self.visit_body(&body);\n         }\n "}, {"sha": "f01ab4c5d611da57e5edc4672de9f2edc6490406", "filename": "compiler/rustc_const_eval/src/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -30,7 +30,7 @@ pub fn check_live_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mir::Body<'tcx>) {\n         return;\n     }\n \n-    if tcx.has_attr(def_id.to_def_id(), sym::rustc_do_not_const_check) {\n+    if tcx.has_attr(def_id, sym::rustc_do_not_const_check) {\n         return;\n     }\n "}, {"sha": "6758cba2eed3485a6efeb82d0b98c2317cc26241", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n use rustc_trait_selection::traits::{\n-    self, ImplSource, Obligation, ObligationCause, SelectionContext,\n+    self, ImplSource, Obligation, ObligationCause, ObligationCtxt, SelectionContext,\n };\n \n use super::ConstCx;\n@@ -184,7 +184,10 @@ impl Qualif for NeedsNonConstDrop {\n         }\n \n         // If we had any errors, then it's bad\n-        !traits::fully_solve_obligations(&infcx, impl_src.nested_obligations()).is_empty()\n+        let ocx = ObligationCtxt::new(&infcx);\n+        ocx.register_obligations(impl_src.nested_obligations());\n+        let errors = ocx.select_all_or_error();\n+        !errors.is_empty()\n     }\n \n     fn in_adt_inherently<'tcx>("}, {"sha": "9866a9bffe0e183dd2c28fa56bb712532a23cb2a", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -331,7 +331,7 @@ impl CodeSuggestion {\n                     });\n                     buf.push_str(&part.snippet);\n                     let cur_hi = sm.lookup_char_pos(part.span.hi());\n-                    if cur_hi.line == cur_lo.line {\n+                    if cur_hi.line == cur_lo.line && !part.snippet.is_empty() {\n                         // Account for the difference between the width of the current code and the\n                         // snippet being suggested, so that the *later* suggestions are correctly\n                         // aligned on the screen."}, {"sha": "37ac37231619b045ff31c235d24f5727ee05d393", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -22,6 +22,12 @@ impl From<OwnerId> for HirId {\n     }\n }\n \n+impl From<OwnerId> for DefId {\n+    fn from(value: OwnerId) -> Self {\n+        value.to_def_id()\n+    }\n+}\n+\n impl OwnerId {\n     #[inline]\n     pub fn to_def_id(self) -> DefId {"}, {"sha": "8a9aac14fb65ff7940f09d721355ab763927cddb", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -75,7 +75,7 @@ pub trait AstConv<'tcx> {\n     fn get_type_parameter_bounds(\n         &self,\n         span: Span,\n-        def_id: DefId,\n+        def_id: LocalDefId,\n         assoc_name: Ident,\n     ) -> ty::GenericPredicates<'tcx>;\n \n@@ -1773,9 +1773,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty_param_def_id, assoc_name, span,\n         );\n \n-        let predicates = &self\n-            .get_type_parameter_bounds(span, ty_param_def_id.to_def_id(), assoc_name)\n-            .predicates;\n+        let predicates =\n+            &self.get_type_parameter_bounds(span, ty_param_def_id, assoc_name).predicates;\n \n         debug!(\"find_bound_for_assoc_item: predicates={:#?}\", predicates);\n "}, {"sha": "4082759006de737f1cb9747afd78d60e00aad450", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -211,7 +211,7 @@ fn check_opaque(tcx: TyCtxt<'_>, id: hir::ItemId) {\n         return;\n     }\n \n-    let substs = InternalSubsts::identity_for_item(tcx, item.owner_id.to_def_id());\n+    let substs = InternalSubsts::identity_for_item(tcx, item.owner_id);\n     let span = tcx.def_span(item.owner_id.def_id);\n \n     if !tcx.features().impl_trait_projections {\n@@ -304,7 +304,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n         ..\n     }) = item.kind\n     {\n-        let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+        let substs = InternalSubsts::identity_for_item(tcx, def_id);\n         let opaque_identity_ty = if in_trait {\n             tcx.mk_projection(def_id.to_def_id(), substs)\n         } else {\n@@ -535,7 +535,7 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n                     }\n                     ty::AssocKind::Type if assoc_item.defaultness(tcx).has_value() => {\n                         let trait_substs =\n-                            InternalSubsts::identity_for_item(tcx, id.owner_id.to_def_id());\n+                            InternalSubsts::identity_for_item(tcx, id.owner_id);\n                         let _: Result<_, rustc_errors::ErrorGuaranteed> = check_type_bounds(\n                             tcx,\n                             assoc_item,\n@@ -1161,7 +1161,7 @@ fn check_enum(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     def.destructor(tcx); // force the destructor to be evaluated\n \n     if def.variants().is_empty() {\n-        if let Some(attr) = tcx.get_attrs(def_id.to_def_id(), sym::repr).next() {\n+        if let Some(attr) = tcx.get_attrs(def_id, sym::repr).next() {\n             struct_span_err!(\n                 tcx.sess,\n                 attr.span,"}, {"sha": "49665525967fa42e8538a4eeb38deb54e7ae2e7c", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -583,13 +583,13 @@ fn compare_asyncness<'tcx>(\n #[instrument(skip(tcx), level = \"debug\", ret)]\n pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    impl_m_def_id: LocalDefId,\n ) -> Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed> {\n-    let impl_m = tcx.opt_associated_item(def_id).unwrap();\n+    let impl_m = tcx.opt_associated_item(impl_m_def_id.to_def_id()).unwrap();\n     let trait_m = tcx.opt_associated_item(impl_m.trait_item_def_id.unwrap()).unwrap();\n     let impl_trait_ref =\n         tcx.impl_trait_ref(impl_m.impl_container(tcx).unwrap()).unwrap().subst_identity();\n-    let param_env = tcx.param_env(def_id);\n+    let param_env = tcx.param_env(impl_m_def_id);\n \n     // First, check a few of the same things as `compare_impl_method`,\n     // just so we don't ICE during substitution later.\n@@ -599,7 +599,6 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n \n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n-    let impl_m_def_id = impl_m.def_id.expect_local();\n     let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m_def_id);\n     let return_span = tcx.hir().fn_decl_by_hir_id(impl_m_hir_id).unwrap().output.span();\n     let cause = ObligationCause::new("}, {"sha": "f7aaa7a159ffa67977dc8862316a7a6f5267b7a5", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -59,6 +59,7 @@ fn equate_intrinsic_type<'tcx>(\n         require_same_types(\n             tcx,\n             &cause,\n+            ty::ParamEnv::empty(), // FIXME: do all intrinsics have an empty param env?\n             tcx.mk_fn_ptr(tcx.fn_sig(it.owner_id).subst_identity()),\n             fty,\n         );"}, {"sha": "1e2b37bd50c5bbfeab5fff8cd3f5ceb5de48b94d", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -109,8 +109,8 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-fn adt_destructor(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::Destructor> {\n-    tcx.calculate_dtor(def_id, dropck::check_drop_impl)\n+fn adt_destructor(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<ty::Destructor> {\n+    tcx.calculate_dtor(def_id.to_def_id(), dropck::check_drop_impl)\n }\n \n /// Given a `DefId` for an opaque type in return position, find its parent item's return"}, {"sha": "737532b98a47a7b1735729779f1c351064565e12", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1794,7 +1794,7 @@ fn check_variances_for_type_defn<'tcx>(\n \n     // Lazily calculated because it is only needed in case of an error.\n     let explicitly_bounded_params = LazyCell::new(|| {\n-        let icx = crate::collect::ItemCtxt::new(tcx, item.owner_id.to_def_id());\n+        let icx = crate::collect::ItemCtxt::new(tcx, item.owner_id.def_id);\n         hir_generics\n             .predicates\n             .iter()"}, {"sha": "25d56ea45c19929a11d7141eb91355331306664a", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -11,13 +11,14 @@ use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{self, RegionResolutionError};\n use rustc_infer::infer::{DefineOpaqueTypes, TyCtxtInferExt};\n+use rustc_infer::traits::Obligation;\n use rustc_middle::ty::adjustment::CoerceUnsizedInfo;\n use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeVisitableExt};\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::misc::{\n     type_allowed_to_implement_copy, CopyImplementationError, InfringingFieldsReason,\n };\n-use rustc_trait_selection::traits::predicate_for_trait_def;\n+use rustc_trait_selection::traits::ObligationCtxt;\n use rustc_trait_selection::traits::{self, ObligationCause};\n use std::collections::BTreeMap;\n \n@@ -334,19 +335,19 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n                     ))\n                     .emit();\n             } else {\n-                let errors = traits::fully_solve_obligations(\n-                    &infcx,\n-                    coerced_fields.into_iter().map(|field| {\n-                        predicate_for_trait_def(\n-                            tcx,\n-                            param_env,\n-                            cause.clone(),\n+                let ocx = ObligationCtxt::new(&infcx);\n+                for field in coerced_fields {\n+                    ocx.register_obligation(Obligation::new(\n+                        tcx,\n+                        cause.clone(),\n+                        param_env,\n+                        ty::Binder::dummy(tcx.mk_trait_ref(\n                             dispatch_from_dyn_trait,\n-                            0,\n                             [field.ty(tcx, substs_a), field.ty(tcx, substs_b)],\n-                        )\n-                    }),\n-                );\n+                        )),\n+                    ));\n+                }\n+                let errors = ocx.select_all_or_error();\n                 if !errors.is_empty() {\n                     infcx.err_ctxt().report_fulfillment_errors(&errors);\n                 }\n@@ -368,11 +369,8 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n     }\n }\n \n-pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedInfo {\n+pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: LocalDefId) -> CoerceUnsizedInfo {\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n-\n-    // this provider should only get invoked for local def-ids\n-    let impl_did = impl_did.expect_local();\n     let span = tcx.def_span(impl_did);\n \n     let coerce_unsized_trait = tcx.require_lang_item(LangItem::CoerceUnsized, Some(span));\n@@ -583,10 +581,12 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n     };\n \n     // Register an obligation for `A: Trait<B>`.\n+    let ocx = ObligationCtxt::new(&infcx);\n     let cause = traits::ObligationCause::misc(span, impl_did);\n-    let predicate =\n-        predicate_for_trait_def(tcx, param_env, cause, trait_def_id, 0, [source, target]);\n-    let errors = traits::fully_solve_obligation(&infcx, predicate);\n+    let obligation =\n+        Obligation::new(tcx, cause, param_env, tcx.mk_trait_ref(trait_def_id, [source, target]));\n+    ocx.register_obligation(obligation);\n+    let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n         infcx.err_ctxt().report_fulfillment_errors(&errors);\n     }"}, {"sha": "d4dfe455b29a941cc3664375e5569a566470fc2a", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -10,7 +10,7 @@\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams, TreatProjections};\n use rustc_middle::ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n@@ -24,17 +24,15 @@ pub fn crate_inherent_impls(tcx: TyCtxt<'_>, (): ()) -> CrateInherentImpls {\n     collect.impls_map\n }\n \n-pub fn crate_incoherent_impls(tcx: TyCtxt<'_>, (_, simp): (CrateNum, SimplifiedType)) -> &[DefId] {\n+pub fn crate_incoherent_impls(tcx: TyCtxt<'_>, simp: SimplifiedType) -> &[DefId] {\n     let crate_map = tcx.crate_inherent_impls(());\n     tcx.arena.alloc_from_iter(\n         crate_map.incoherent_impls.get(&simp).unwrap_or(&Vec::new()).iter().map(|d| d.to_def_id()),\n     )\n }\n \n /// On-demand query: yields a vector of the inherent impls for a specific type.\n-pub fn inherent_impls(tcx: TyCtxt<'_>, ty_def_id: DefId) -> &[DefId] {\n-    let ty_def_id = ty_def_id.expect_local();\n-\n+pub fn inherent_impls(tcx: TyCtxt<'_>, ty_def_id: LocalDefId) -> &[DefId] {\n     let crate_map = tcx.crate_inherent_impls(());\n     match crate_map.inherent_impls.get(&ty_def_id) {\n         Some(v) => &v[..],"}, {"sha": "db58f4af8ec3825038ddf3e0ce8d0d31448b5b90", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 39, "deletions": 46, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -113,7 +113,7 @@ pub fn provide(providers: &mut Providers) {\n /// the AST (`hir::Generics`), recursively.\n pub struct ItemCtxt<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    item_def_id: DefId,\n+    item_def_id: LocalDefId,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -347,7 +347,7 @@ fn bad_placeholder<'tcx>(\n }\n \n impl<'tcx> ItemCtxt<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>, item_def_id: DefId) -> ItemCtxt<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, item_def_id: LocalDefId) -> ItemCtxt<'tcx> {\n         ItemCtxt { tcx, item_def_id }\n     }\n \n@@ -356,7 +356,7 @@ impl<'tcx> ItemCtxt<'tcx> {\n     }\n \n     pub fn hir_id(&self) -> hir::HirId {\n-        self.tcx.hir().local_def_id_to_hir_id(self.item_def_id.expect_local())\n+        self.tcx.hir().local_def_id_to_hir_id(self.item_def_id)\n     }\n \n     pub fn node(&self) -> hir::Node<'tcx> {\n@@ -370,20 +370,16 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n     }\n \n     fn item_def_id(&self) -> DefId {\n-        self.item_def_id\n+        self.item_def_id.to_def_id()\n     }\n \n     fn get_type_parameter_bounds(\n         &self,\n         span: Span,\n-        def_id: DefId,\n+        def_id: LocalDefId,\n         assoc_name: Ident,\n     ) -> ty::GenericPredicates<'tcx> {\n-        self.tcx.at(span).type_param_predicates((\n-            self.item_def_id,\n-            def_id.expect_local(),\n-            assoc_name,\n-        ))\n+        self.tcx.at(span).type_param_predicates((self.item_def_id, def_id, assoc_name))\n     }\n \n     fn re_infer(&self, _: Option<&ty::GenericParamDef>, _: Span) -> Option<ty::Region<'tcx>> {\n@@ -839,17 +835,15 @@ fn convert_variant(\n         adt_kind,\n         parent_did.to_def_id(),\n         recovered,\n-        adt_kind == AdtKind::Struct && tcx.has_attr(parent_did.to_def_id(), sym::non_exhaustive)\n-            || variant_did.map_or(false, |variant_did| {\n-                tcx.has_attr(variant_did.to_def_id(), sym::non_exhaustive)\n-            }),\n+        adt_kind == AdtKind::Struct && tcx.has_attr(parent_did, sym::non_exhaustive)\n+            || variant_did\n+                .map_or(false, |variant_did| tcx.has_attr(variant_did, sym::non_exhaustive)),\n     )\n }\n \n-fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtDef<'_> {\n+fn adt_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::AdtDef<'_> {\n     use rustc_hir::*;\n \n-    let def_id = def_id.expect_local();\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let Node::Item(item) = tcx.hir().get(hir_id) else {\n         bug!();\n@@ -908,8 +902,8 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtDef<'_> {\n     tcx.mk_adt_def(def_id.to_def_id(), kind, variants, repr)\n }\n \n-fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n-    let item = tcx.hir().expect_item(def_id.expect_local());\n+fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n+    let item = tcx.hir().expect_item(def_id);\n \n     let (is_auto, unsafety, items) = match item.kind {\n         hir::ItemKind::Trait(is_auto, unsafety, .., items) => {\n@@ -1036,7 +1030,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n         });\n \n     ty::TraitDef {\n-        def_id,\n+        def_id: def_id.to_def_id(),\n         unsafety,\n         paren_sugar,\n         has_auto_impl: is_auto,\n@@ -1091,14 +1085,13 @@ pub fn get_infer_ret_ty<'hir>(output: &'hir hir::FnRetTy<'hir>) -> Option<&'hir\n }\n \n #[instrument(level = \"debug\", skip(tcx))]\n-fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<ty::PolyFnSig<'_>> {\n+fn fn_sig(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<ty::PolyFnSig<'_>> {\n     use rustc_hir::Node::*;\n     use rustc_hir::*;\n \n-    let def_id = def_id.expect_local();\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n-    let icx = ItemCtxt::new(tcx, def_id.to_def_id());\n+    let icx = ItemCtxt::new(tcx, def_id);\n \n     let output = match tcx.hir().get(hir_id) {\n         TraitItem(hir::TraitItem {\n@@ -1139,7 +1132,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<ty::PolyFnSig<'_>>\n \n         ForeignItem(&hir::ForeignItem { kind: ForeignItemKind::Fn(fn_decl, _, _), .. }) => {\n             let abi = tcx.hir().get_foreign_abi(hir_id);\n-            compute_sig_of_foreign_fn_decl(tcx, def_id.to_def_id(), fn_decl, abi)\n+            compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n         Ctor(data) | Variant(hir::Variant { data, .. }) if data.ctor().is_some() => {\n@@ -1338,9 +1331,12 @@ fn suggest_impl_trait<'tcx>(\n     None\n }\n \n-fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::EarlyBinder<ty::TraitRef<'_>>> {\n+fn impl_trait_ref(\n+    tcx: TyCtxt<'_>,\n+    def_id: LocalDefId,\n+) -> Option<ty::EarlyBinder<ty::TraitRef<'_>>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n-    let impl_ = tcx.hir().expect_item(def_id.expect_local()).expect_impl();\n+    let impl_ = tcx.hir().expect_item(def_id).expect_impl();\n     impl_\n         .of_trait\n         .as_ref()\n@@ -1380,9 +1376,9 @@ fn check_impl_constness(\n     }\n }\n \n-fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n+fn impl_polarity(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::ImplPolarity {\n     let is_rustc_reservation = tcx.has_attr(def_id, sym::rustc_reservation_impl);\n-    let item = tcx.hir().expect_item(def_id.expect_local());\n+    let item = tcx.hir().expect_item(def_id);\n     match &item.kind {\n         hir::ItemKind::Impl(hir::Impl {\n             polarity: hir::ImplPolarity::Negative(span),\n@@ -1465,16 +1461,16 @@ fn predicates_defined_on(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicate\n \n fn compute_sig_of_foreign_fn_decl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     decl: &'tcx hir::FnDecl<'tcx>,\n     abi: abi::Abi,\n ) -> ty::PolyFnSig<'tcx> {\n     let unsafety = if abi == abi::Abi::RustIntrinsic {\n-        intrinsic_operation_unsafety(tcx, def_id)\n+        intrinsic_operation_unsafety(tcx, def_id.to_def_id())\n     } else {\n         hir::Unsafety::Unsafe\n     };\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let fty =\n         ItemCtxt::new(tcx, def_id).astconv().ty_of_fn(hir_id, unsafety, abi, decl, None, None);\n \n@@ -1515,31 +1511,28 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n     fty\n }\n \n-fn is_foreign_item(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    match tcx.hir().get_if_local(def_id) {\n-        Some(Node::ForeignItem(..)) => true,\n-        Some(_) => false,\n-        _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id),\n+fn is_foreign_item(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n+    match tcx.hir().get_by_def_id(def_id) {\n+        Node::ForeignItem(..) => true,\n+        _ => false,\n     }\n }\n \n-fn generator_kind(tcx: TyCtxt<'_>, def_id: DefId) -> Option<hir::GeneratorKind> {\n-    match tcx.hir().get_if_local(def_id) {\n-        Some(Node::Expr(&rustc_hir::Expr {\n+fn generator_kind(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<hir::GeneratorKind> {\n+    match tcx.hir().get_by_def_id(def_id) {\n+        Node::Expr(&rustc_hir::Expr {\n             kind: rustc_hir::ExprKind::Closure(&rustc_hir::Closure { body, .. }),\n             ..\n-        })) => tcx.hir().body(body).generator_kind(),\n-        Some(_) => None,\n-        _ => bug!(\"generator_kind applied to non-local def-id {:?}\", def_id),\n+        }) => tcx.hir().body(body).generator_kind(),\n+        _ => None,\n     }\n }\n \n-fn is_type_alias_impl_trait<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n-    match tcx.hir().get_if_local(def_id) {\n-        Some(Node::Item(hir::Item { kind: hir::ItemKind::OpaqueTy(opaque), .. })) => {\n+fn is_type_alias_impl_trait<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> bool {\n+    match tcx.hir().get_by_def_id(def_id) {\n+        Node::Item(hir::Item { kind: hir::ItemKind::OpaqueTy(opaque), .. }) => {\n             matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias)\n         }\n-        Some(_) => bug!(\"tried getting opaque_ty_origin for non-opaque: {:?}\", def_id),\n-        _ => bug!(\"tried getting opaque_ty_origin for non-local def-id {:?}\", def_id),\n+        _ => bug!(\"tried getting opaque_ty_origin for non-opaque: {:?}\", def_id),\n     }\n }"}, {"sha": "119933697a165d8311c8c0865f758d77d5718b1a", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -5,16 +5,16 @@ use hir::{\n };\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::Span;\n \n-pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n+pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Generics {\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n     let node = tcx.hir().get(hir_id);\n     let parent_def_id = match node {\n@@ -121,7 +121,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                         Some(parent_def_id.to_def_id())\n                     }\n                     Node::Expr(&Expr { kind: ExprKind::ConstBlock(_), .. }) => {\n-                        Some(tcx.typeck_root_def_id(def_id))\n+                        Some(tcx.typeck_root_def_id(def_id.to_def_id()))\n                     }\n                     // Exclude `GlobalAsm` here which cannot have generics.\n                     Node::Expr(&Expr { kind: ExprKind::InlineAsm(asm), .. })\n@@ -140,7 +140,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             }\n         }\n         Node::Expr(&hir::Expr { kind: hir::ExprKind::Closure { .. }, .. }) => {\n-            Some(tcx.typeck_root_def_id(def_id))\n+            Some(tcx.typeck_root_def_id(def_id.to_def_id()))\n         }\n         Node::Item(item) => match item.kind {\n             ItemKind::OpaqueTy(hir::OpaqueTy {\n@@ -189,7 +189,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                     let opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n                         name: kw::SelfUpper,\n-                        def_id,\n+                        def_id: def_id.to_def_id(),\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n                             has_default: false,\n@@ -326,7 +326,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n         params.extend(dummy_args.iter().map(|&arg| ty::GenericParamDef {\n             index: next_index(),\n             name: Symbol::intern(arg),\n-            def_id,\n+            def_id: def_id.to_def_id(),\n             pure_wrt_drop: false,\n             kind: ty::GenericParamDefKind::Type { has_default: false, synthetic: false },\n         }));\n@@ -339,7 +339,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             params.push(ty::GenericParamDef {\n                 index: next_index(),\n                 name: Symbol::intern(\"<const_ty>\"),\n-                def_id,\n+                def_id: def_id.to_def_id(),\n                 pure_wrt_drop: false,\n                 kind: ty::GenericParamDefKind::Type { has_default: false, synthetic: false },\n             });"}, {"sha": "aa66d7bb5efc8556c1350763fb7a59cd5c0f9315", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -4,7 +4,7 @@ use rustc_hir as hir;\n use rustc_infer::traits::util;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::def_id::DefId;\n+use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::Span;\n \n /// For associated types we include both bounds written on the type\n@@ -16,12 +16,12 @@ use rustc_span::Span;\n /// `hr-associated-type-bound-1.rs`.\n fn associated_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    assoc_item_def_id: DefId,\n+    assoc_item_def_id: LocalDefId,\n     ast_bounds: &'tcx [hir::GenericBound<'tcx>],\n     span: Span,\n ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n     let item_ty = tcx.mk_projection(\n-        assoc_item_def_id,\n+        assoc_item_def_id.to_def_id(),\n         InternalSubsts::identity_for_item(tcx, assoc_item_def_id),\n     );\n \n@@ -30,8 +30,8 @@ fn associated_type_bounds<'tcx>(\n     // Associated types are implicitly sized unless a `?Sized` bound is found\n     icx.astconv().add_implicitly_sized(&mut bounds, item_ty, ast_bounds, None, span);\n \n-    let trait_def_id = tcx.parent(assoc_item_def_id);\n-    let trait_predicates = tcx.trait_explicit_predicates_and_bounds(trait_def_id.expect_local());\n+    let trait_def_id = tcx.local_parent(assoc_item_def_id);\n+    let trait_predicates = tcx.trait_explicit_predicates_and_bounds(trait_def_id);\n \n     let bounds_from_parent = trait_predicates.predicates.iter().copied().filter(|(pred, _)| {\n         match pred.kind().skip_binder() {\n@@ -45,7 +45,11 @@ fn associated_type_bounds<'tcx>(\n     });\n \n     let all_bounds = tcx.arena.alloc_from_iter(bounds.predicates().chain(bounds_from_parent));\n-    debug!(\"associated_type_bounds({}) = {:?}\", tcx.def_path_str(assoc_item_def_id), all_bounds);\n+    debug!(\n+        \"associated_type_bounds({}) = {:?}\",\n+        tcx.def_path_str(assoc_item_def_id.to_def_id()),\n+        all_bounds\n+    );\n     all_bounds\n }\n \n@@ -56,7 +60,7 @@ fn associated_type_bounds<'tcx>(\n #[instrument(level = \"trace\", skip(tcx), ret)]\n fn opaque_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    opaque_def_id: DefId,\n+    opaque_def_id: LocalDefId,\n     ast_bounds: &'tcx [hir::GenericBound<'tcx>],\n     item_ty: Ty<'tcx>,\n     span: Span,\n@@ -74,19 +78,22 @@ fn opaque_type_bounds<'tcx>(\n \n pub(super) fn explicit_item_bounds(\n     tcx: TyCtxt<'_>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n ) -> &'_ [(ty::Predicate<'_>, Span)] {\n-    match tcx.opt_rpitit_info(def_id) {\n+    match tcx.opt_rpitit_info(def_id.to_def_id()) {\n         // RPITIT's bounds are the same as opaque type bounds, but with\n         // a projection self type.\n         Some(ty::ImplTraitInTraitData::Trait { opaque_def_id, .. }) => {\n             let item = tcx.hir().get_by_def_id(opaque_def_id.expect_local()).expect_item();\n             let opaque_ty = item.expect_opaque_ty();\n             return opaque_type_bounds(\n                 tcx,\n-                opaque_def_id,\n+                opaque_def_id.expect_local(),\n                 opaque_ty.bounds,\n-                tcx.mk_projection(def_id, ty::InternalSubsts::identity_for_item(tcx, def_id)),\n+                tcx.mk_projection(\n+                    def_id.to_def_id(),\n+                    ty::InternalSubsts::identity_for_item(tcx, def_id),\n+                ),\n                 item.span,\n             );\n         }\n@@ -95,7 +102,7 @@ pub(super) fn explicit_item_bounds(\n         None => {}\n     }\n \n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     match tcx.hir().get(hir_id) {\n         hir::Node::TraitItem(hir::TraitItem {\n             kind: hir::TraitItemKind::Type(bounds, _),\n@@ -109,9 +116,9 @@ pub(super) fn explicit_item_bounds(\n         }) => {\n             let substs = InternalSubsts::identity_for_item(tcx, def_id);\n             let item_ty = if *in_trait && !tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n-                tcx.mk_projection(def_id, substs)\n+                tcx.mk_projection(def_id.to_def_id(), substs)\n             } else {\n-                tcx.mk_opaque(def_id, substs)\n+                tcx.mk_opaque(def_id.to_def_id(), substs)\n             };\n             opaque_type_bounds(tcx, def_id, bounds, item_ty, *span)\n         }"}, {"sha": "fdab87b6acea7e06c8a08f7fea57799c6ace91e8", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 72, "deletions": 71, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -62,15 +62,16 @@ pub(super) fn predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredic\n /// Returns a list of user-specified type predicates for the definition with ID `def_id`.\n /// N.B., this does not include any implied/inferred constraints.\n #[instrument(level = \"trace\", skip(tcx), ret)]\n-fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n+fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::GenericPredicates<'_> {\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let node = tcx.hir().get(hir_id);\n \n     let mut is_trait = None;\n     let mut is_default_impl_trait = None;\n \n+    // FIXME: Should ItemCtxt take a LocalDefId?\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     const NO_GENERICS: &hir::Generics<'_> = hir::Generics::empty();\n@@ -99,7 +100,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n             | ItemKind::Union(_, generics) => generics,\n \n             ItemKind::Trait(_, _, generics, ..) | ItemKind::TraitAlias(generics, _) => {\n-                is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n+                is_trait = Some(ty::TraitRef::identity(tcx, def_id.to_def_id()));\n                 generics\n             }\n             ItemKind::OpaqueTy(OpaqueTy { generics, .. }) => generics,\n@@ -253,7 +254,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n     }\n \n     if tcx.features().generic_const_exprs {\n-        predicates.extend(const_evaluatable_predicates_of(tcx, def_id.expect_local()));\n+        predicates.extend(const_evaluatable_predicates_of(tcx, def_id));\n     }\n \n     let mut predicates: Vec<_> = predicates.into_iter().collect();\n@@ -392,18 +393,18 @@ pub(super) fn trait_explicit_predicates_and_bounds(\n     def_id: LocalDefId,\n ) -> ty::GenericPredicates<'_> {\n     assert_eq!(tcx.def_kind(def_id), DefKind::Trait);\n-    gather_explicit_predicates_of(tcx, def_id.to_def_id())\n+    gather_explicit_predicates_of(tcx, def_id)\n }\n \n pub(super) fn explicit_predicates_of<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n ) -> ty::GenericPredicates<'tcx> {\n     let def_kind = tcx.def_kind(def_id);\n     if let DefKind::Trait = def_kind {\n         // Remove bounds on associated types from the predicates, they will be\n         // returned by `explicit_item_bounds`.\n-        let predicates_and_bounds = tcx.trait_explicit_predicates_and_bounds(def_id.expect_local());\n+        let predicates_and_bounds = tcx.trait_explicit_predicates_and_bounds(def_id);\n         let trait_identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n \n         let is_assoc_item_ty = |ty: Ty<'tcx>| {\n@@ -418,7 +419,8 @@ pub(super) fn explicit_predicates_of<'tcx>(\n             //   supertrait).\n             if let ty::Alias(ty::Projection, projection) = ty.kind() {\n                 projection.substs == trait_identity_substs\n-                    && tcx.associated_item(projection.def_id).container_id(tcx) == def_id\n+                    && tcx.associated_item(projection.def_id).container_id(tcx)\n+                        == def_id.to_def_id()\n             } else {\n                 false\n             }\n@@ -449,7 +451,7 @@ pub(super) fn explicit_predicates_of<'tcx>(\n         }\n     } else {\n         if matches!(def_kind, DefKind::AnonConst) && tcx.lazy_normalization() {\n-            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n             let parent_def_id = tcx.hir().get_parent_item(hir_id);\n \n             if let Some(defaulted_param_def_id) =\n@@ -537,9 +539,9 @@ pub(super) fn explicit_predicates_of<'tcx>(\n /// the transitive super-predicates are converted.\n pub(super) fn super_predicates_of(\n     tcx: TyCtxt<'_>,\n-    trait_def_id: DefId,\n+    trait_def_id: LocalDefId,\n ) -> ty::GenericPredicates<'_> {\n-    tcx.super_predicates_that_define_assoc_type((trait_def_id, None))\n+    tcx.super_predicates_that_define_assoc_type((trait_def_id.to_def_id(), None))\n }\n \n /// Ensures that the super-predicates of the trait with a `DefId`\n@@ -549,80 +551,78 @@ pub(super) fn super_predicates_that_define_assoc_type(\n     tcx: TyCtxt<'_>,\n     (trait_def_id, assoc_name): (DefId, Option<Ident>),\n ) -> ty::GenericPredicates<'_> {\n-    if trait_def_id.is_local() {\n-        debug!(\"local trait\");\n-        let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id.expect_local());\n+    let Some(trait_def_id) = trait_def_id.as_local() else {\n+        // if `assoc_name` is None, then the query should've been redirected to an\n+        // external provider\n+        assert!(assoc_name.is_some());\n+        return tcx.super_predicates_of(trait_def_id);\n+    };\n \n-        let Node::Item(item) = tcx.hir().get(trait_hir_id) else {\n-            bug!(\"trait_node_id {} is not an item\", trait_hir_id);\n-        };\n+    debug!(\"local trait\");\n+    let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id);\n \n-        let (generics, bounds) = match item.kind {\n-            hir::ItemKind::Trait(.., generics, supertraits, _) => (generics, supertraits),\n-            hir::ItemKind::TraitAlias(generics, supertraits) => (generics, supertraits),\n-            _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n-        };\n+    let Node::Item(item) = tcx.hir().get(trait_hir_id) else {\n+        bug!(\"trait_node_id {} is not an item\", trait_hir_id);\n+    };\n \n-        let icx = ItemCtxt::new(tcx, trait_def_id);\n+    let (generics, bounds) = match item.kind {\n+        hir::ItemKind::Trait(.., generics, supertraits, _) => (generics, supertraits),\n+        hir::ItemKind::TraitAlias(generics, supertraits) => (generics, supertraits),\n+        _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n+    };\n \n-        // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n-        let self_param_ty = tcx.types.self_param;\n-        let superbounds1 = if let Some(assoc_name) = assoc_name {\n-            icx.astconv().compute_bounds_that_match_assoc_type(self_param_ty, bounds, assoc_name)\n-        } else {\n-            icx.astconv().compute_bounds(self_param_ty, bounds)\n-        };\n+    let icx = ItemCtxt::new(tcx, trait_def_id);\n \n-        let superbounds1 = superbounds1.predicates();\n-\n-        // Convert any explicit superbounds in the where-clause,\n-        // e.g., `trait Foo where Self: Bar`.\n-        // In the case of trait aliases, however, we include all bounds in the where-clause,\n-        // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n-        // as one of its \"superpredicates\".\n-        let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n-        let superbounds2 = icx.type_parameter_bounds_in_generics(\n-            generics,\n-            item.owner_id.def_id,\n-            self_param_ty,\n-            OnlySelfBounds(!is_trait_alias),\n-            assoc_name,\n-        );\n+    // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n+    let self_param_ty = tcx.types.self_param;\n+    let superbounds1 = if let Some(assoc_name) = assoc_name {\n+        icx.astconv().compute_bounds_that_match_assoc_type(self_param_ty, bounds, assoc_name)\n+    } else {\n+        icx.astconv().compute_bounds(self_param_ty, bounds)\n+    };\n \n-        // Combine the two lists to form the complete set of superbounds:\n-        let superbounds = &*tcx.arena.alloc_from_iter(superbounds1.into_iter().chain(superbounds2));\n-        debug!(?superbounds);\n+    let superbounds1 = superbounds1.predicates();\n+\n+    // Convert any explicit superbounds in the where-clause,\n+    // e.g., `trait Foo where Self: Bar`.\n+    // In the case of trait aliases, however, we include all bounds in the where-clause,\n+    // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n+    // as one of its \"superpredicates\".\n+    let is_trait_alias = tcx.is_trait_alias(trait_def_id.to_def_id());\n+    let superbounds2 = icx.type_parameter_bounds_in_generics(\n+        generics,\n+        item.owner_id.def_id,\n+        self_param_ty,\n+        OnlySelfBounds(!is_trait_alias),\n+        assoc_name,\n+    );\n+\n+    // Combine the two lists to form the complete set of superbounds:\n+    let superbounds = &*tcx.arena.alloc_from_iter(superbounds1.into_iter().chain(superbounds2));\n+    debug!(?superbounds);\n \n+    // Now require that immediate supertraits are converted,\n+    // which will, in turn, reach indirect supertraits.\n+    if assoc_name.is_none() {\n         // Now require that immediate supertraits are converted,\n         // which will, in turn, reach indirect supertraits.\n-        if assoc_name.is_none() {\n-            // Now require that immediate supertraits are converted,\n-            // which will, in turn, reach indirect supertraits.\n-            for &(pred, span) in superbounds {\n-                debug!(\"superbound: {:?}\", pred);\n-                if let ty::PredicateKind::Clause(ty::Clause::Trait(bound)) =\n-                    pred.kind().skip_binder()\n-                {\n-                    tcx.at(span).super_predicates_of(bound.def_id());\n-                }\n+        for &(pred, span) in superbounds {\n+            debug!(\"superbound: {:?}\", pred);\n+            if let ty::PredicateKind::Clause(ty::Clause::Trait(bound)) = pred.kind().skip_binder() {\n+                tcx.at(span).super_predicates_of(bound.def_id());\n             }\n         }\n-\n-        ty::GenericPredicates { parent: None, predicates: superbounds }\n-    } else {\n-        // if `assoc_name` is None, then the query should've been redirected to an\n-        // external provider\n-        assert!(assoc_name.is_some());\n-        tcx.super_predicates_of(trait_def_id)\n     }\n+\n+    ty::GenericPredicates { parent: None, predicates: superbounds }\n }\n \n /// Returns the predicates defined on `item_def_id` of the form\n /// `X: Foo` where `X` is the type parameter `def_id`.\n #[instrument(level = \"trace\", skip(tcx))]\n pub(super) fn type_param_predicates(\n     tcx: TyCtxt<'_>,\n-    (item_def_id, def_id, assoc_name): (DefId, LocalDefId, Ident),\n+    (item_def_id, def_id, assoc_name): (LocalDefId, LocalDefId, Ident),\n ) -> ty::GenericPredicates<'_> {\n     use rustc_hir::*;\n \n@@ -637,21 +637,21 @@ pub(super) fn type_param_predicates(\n     let ty = tcx.mk_ty_param(index, tcx.hir().ty_param_name(def_id));\n \n     // Don't look for bounds where the type parameter isn't in scope.\n-    let parent = if item_def_id == param_owner.to_def_id() {\n+    let parent = if item_def_id == param_owner {\n         None\n     } else {\n-        tcx.generics_of(item_def_id).parent\n+        tcx.generics_of(item_def_id).parent.map(|def_id| def_id.expect_local())\n     };\n \n     let mut result = parent\n         .map(|parent| {\n             let icx = ItemCtxt::new(tcx, parent);\n-            icx.get_type_parameter_bounds(DUMMY_SP, def_id.to_def_id(), assoc_name)\n+            icx.get_type_parameter_bounds(DUMMY_SP, def_id, assoc_name)\n         })\n         .unwrap_or_default();\n     let mut extend = None;\n \n-    let item_hir_id = tcx.hir().local_def_id_to_hir_id(item_def_id.expect_local());\n+    let item_hir_id = tcx.hir().local_def_id_to_hir_id(item_def_id);\n     let ast_generics = match tcx.hir().get(item_hir_id) {\n         Node::TraitItem(item) => &item.generics,\n \n@@ -673,7 +673,8 @@ pub(super) fn type_param_predicates(\n                 ItemKind::Trait(_, _, generics, ..) => {\n                     // Implied `Self: Trait` and supertrait bounds.\n                     if param_id == item_hir_id {\n-                        let identity_trait_ref = ty::TraitRef::identity(tcx, item_def_id);\n+                        let identity_trait_ref =\n+                            ty::TraitRef::identity(tcx, item_def_id.to_def_id());\n                         extend =\n                             Some((identity_trait_ref.without_const().to_predicate(tcx), item.span));\n                     }"}, {"sha": "f1769415797c1aa411a57151c73450709ec690f8", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1051,9 +1051,8 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n     }\n }\n \n-fn object_lifetime_default(tcx: TyCtxt<'_>, param_def_id: DefId) -> ObjectLifetimeDefault {\n+fn object_lifetime_default(tcx: TyCtxt<'_>, param_def_id: LocalDefId) -> ObjectLifetimeDefault {\n     debug_assert_eq!(tcx.def_kind(param_def_id), DefKind::TyParam);\n-    let param_def_id = param_def_id.expect_local();\n     let hir::Node::GenericParam(param) = tcx.hir().get_by_def_id(param_def_id) else {\n         bug!(\"expected GenericParam for object_lifetime_default\");\n     };"}, {"sha": "9bbca9b4e96995938ef63fa282bd7857f3d489ca", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -63,7 +63,7 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                 .find(|(_, node)| matches!(node, OwnerNode::Item(_)))\n                 .unwrap()\n                 .0\n-                .to_def_id();\n+                .def_id;\n             let item_ctxt = &ItemCtxt::new(tcx, item_def_id) as &dyn crate::astconv::AstConv<'_>;\n             let ty = item_ctxt.ast_ty_to_ty(hir_ty);\n \n@@ -244,11 +244,13 @@ fn get_path_containing_arg_in_pat<'hir>(\n     arg_path\n }\n \n-pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>> {\n+pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty<'_>> {\n     // If we are computing `type_of` the synthesized associated type for an RPITIT in the impl\n     // side, use `collect_return_position_impl_trait_in_trait_tys` to infer the value of the\n     // associated type in the impl.\n-    if let Some(ImplTraitInTraitData::Impl { fn_def_id, .. }) = tcx.opt_rpitit_info(def_id) {\n+    if let Some(ImplTraitInTraitData::Impl { fn_def_id, .. }) =\n+        tcx.opt_rpitit_info(def_id.to_def_id())\n+    {\n         match tcx.collect_return_position_impl_trait_in_trait_tys(fn_def_id) {\n             Ok(map) => {\n                 let assoc_item = tcx.associated_item(def_id);\n@@ -263,17 +265,16 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n         }\n     }\n \n-    let def_id = def_id.expect_local();\n     use rustc_hir::*;\n \n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n-    let icx = ItemCtxt::new(tcx, def_id.to_def_id());\n+    let icx = ItemCtxt::new(tcx, def_id);\n \n     let output = match tcx.hir().get(hir_id) {\n         Node::TraitItem(item) => match item.kind {\n             TraitItemKind::Fn(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id.to_def_id(), substs)\n             }\n             TraitItemKind::Const(ty, body_id) => body_id\n@@ -293,7 +294,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n \n         Node::ImplItem(item) => match item.kind {\n             ImplItemKind::Fn(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id.to_def_id(), substs)\n             }\n             ImplItemKind::Const(ty, body_id) => {\n@@ -349,12 +350,12 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                     _ => icx.to_ty(*self_ty),\n                 },\n                 ItemKind::Fn(..) => {\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     tcx.mk_fn_def(def_id.to_def_id(), substs)\n                 }\n                 ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) => {\n                     let def = tcx.adt_def(def_id);\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     tcx.mk_adt(def, substs)\n                 }\n                 ItemKind::OpaqueTy(OpaqueTy { origin: hir::OpaqueTyOrigin::TyAlias, .. }) => {\n@@ -394,7 +395,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n \n         Node::ForeignItem(foreign_item) => match foreign_item.kind {\n             ForeignItemKind::Fn(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id.to_def_id(), substs)\n             }\n             ForeignItemKind::Static(t, _) => icx.to_ty(t),\n@@ -406,7 +407,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                 tcx.type_of(tcx.hir().get_parent_item(hir_id)).subst_identity()\n             }\n             VariantData::Tuple(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id.to_def_id(), substs)\n             }\n         },\n@@ -439,7 +440,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                 Node::Expr(Expr { kind: ExprKind::ConstBlock(anon_const), .. })\n                     if anon_const.hir_id == hir_id =>\n                 {\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     substs.as_inline_const().ty()\n                 }\n \n@@ -605,7 +606,7 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n         found: Option<ty::OpaqueHiddenType<'tcx>>,\n \n         /// In the presence of dead code, typeck may figure out a hidden type\n-        /// while borrowck will now. We collect these cases here and check at\n+        /// while borrowck will not. We collect these cases here and check at\n         /// the end that we actually found a type that matches (modulo regions).\n         typeck_types: Vec<ty::OpaqueHiddenType<'tcx>>,\n     }"}, {"sha": "8269a6ddea5f46db316bce65f896ca66639ea1ad", "filename": "compiler/rustc_hir_analysis/src/hir_wf_check.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -7,7 +7,7 @@ use rustc_infer::traits::{ObligationCause, WellFormedLoc};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Region, TyCtxt, TypeFoldable, TypeFolder};\n use rustc_span::def_id::LocalDefId;\n-use rustc_trait_selection::traits;\n+use rustc_trait_selection::traits::{self, ObligationCtxt};\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers { diagnostic_hir_wf_check, ..*providers };\n@@ -31,7 +31,7 @@ fn diagnostic_hir_wf_check<'tcx>(\n     tcx.sess\n         .delay_span_bug(tcx.def_span(def_id), \"Performed HIR wfcheck without an existing error!\");\n \n-    let icx = ItemCtxt::new(tcx, def_id.to_def_id());\n+    let icx = ItemCtxt::new(tcx, def_id);\n \n     // To perform HIR-based WF checking, we iterate over all HIR types\n     // that occur 'inside' the item we're checking. For example,\n@@ -66,35 +66,35 @@ fn diagnostic_hir_wf_check<'tcx>(\n     impl<'tcx> Visitor<'tcx> for HirWfCheck<'tcx> {\n         fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n             let infcx = self.tcx.infer_ctxt().build();\n+            let ocx = ObligationCtxt::new(&infcx);\n+\n             let tcx_ty = self.icx.to_ty(ty).fold_with(&mut EraseAllBoundRegions { tcx: self.tcx });\n             let cause = traits::ObligationCause::new(\n                 ty.span,\n                 self.def_id,\n                 traits::ObligationCauseCode::WellFormed(None),\n             );\n-            let errors = traits::fully_solve_obligation(\n-                &infcx,\n-                traits::Obligation::new(\n-                    self.tcx,\n-                    cause,\n-                    self.param_env,\n-                    ty::Binder::dummy(ty::PredicateKind::WellFormed(tcx_ty.into())),\n-                ),\n-            );\n-            if !errors.is_empty() {\n-                debug!(\"Wf-check got errors for {:?}: {:?}\", ty, errors);\n-                for error in errors {\n-                    if error.obligation.predicate == self.predicate {\n-                        // Save the cause from the greatest depth - this corresponds\n-                        // to picking more-specific types (e.g. `MyStruct<u8>`)\n-                        // over less-specific types (e.g. `Option<MyStruct<u8>>`)\n-                        if self.depth >= self.cause_depth {\n-                            self.cause = Some(error.obligation.cause);\n-                            self.cause_depth = self.depth\n-                        }\n+\n+            ocx.register_obligation(traits::Obligation::new(\n+                self.tcx,\n+                cause,\n+                self.param_env,\n+                ty::PredicateKind::WellFormed(tcx_ty.into()),\n+            ));\n+\n+            for error in ocx.select_all_or_error() {\n+                debug!(\"Wf-check got error for {:?}: {:?}\", ty, error);\n+                if error.obligation.predicate == self.predicate {\n+                    // Save the cause from the greatest depth - this corresponds\n+                    // to picking more-specific types (e.g. `MyStruct<u8>`)\n+                    // over less-specific types (e.g. `Option<MyStruct<u8>>`)\n+                    if self.depth >= self.cause_depth {\n+                        self.cause = Some(error.obligation.cause);\n+                        self.cause_depth = self.depth\n                     }\n                 }\n             }\n+\n             self.depth += 1;\n             intravisit::walk_ty(self, ty);\n             self.depth -= 1;"}, {"sha": "91c64eeec1ebaae196b74344c5e9c5dc48307e61", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -168,7 +168,7 @@ fn get_impl_substs(\n     let assumed_wf_types =\n         ocx.assumed_wf_types(param_env, tcx.def_span(impl1_def_id), impl1_def_id);\n \n-    let impl1_substs = InternalSubsts::identity_for_item(tcx, impl1_def_id.to_def_id());\n+    let impl1_substs = InternalSubsts::identity_for_item(tcx, impl1_def_id);\n     let impl2_substs =\n         translate_substs(infcx, param_env, impl1_def_id.to_def_id(), impl1_substs, impl2_node);\n "}, {"sha": "d43230cb563bdd9515e9f1682b46f244fc8e4dd6", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -102,7 +102,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::Node;\n-use rustc_infer::infer::{DefineOpaqueTypes, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_macros::fluent_messages;\n use rustc_middle::middle;\n use rustc_middle::ty::query::Providers;\n@@ -113,7 +113,7 @@ use rustc_span::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_span::{symbol::sym, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, ObligationCtxt};\n \n use std::ops::Not;\n \n@@ -160,24 +160,21 @@ fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl<'_>, abi: Abi\n fn require_same_types<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     cause: &ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     expected: Ty<'tcx>,\n     actual: Ty<'tcx>,\n-) -> bool {\n+) {\n     let infcx = &tcx.infer_ctxt().build();\n-    let param_env = ty::ParamEnv::empty();\n-    let errors = match infcx.at(cause, param_env).eq(DefineOpaqueTypes::No, expected, actual) {\n-        Ok(InferOk { obligations, .. }) => traits::fully_solve_obligations(infcx, obligations),\n+    let ocx = ObligationCtxt::new(infcx);\n+    match ocx.eq(cause, param_env, expected, actual) {\n+        Ok(()) => {\n+            let errors = ocx.select_all_or_error();\n+            if !errors.is_empty() {\n+                infcx.err_ctxt().report_fulfillment_errors(&errors);\n+            }\n+        }\n         Err(err) => {\n             infcx.err_ctxt().report_mismatched_types(cause, expected, actual, err).emit();\n-            return false;\n-        }\n-    };\n-\n-    match &errors[..] {\n-        [] => true,\n-        errors => {\n-            infcx.err_ctxt().report_fulfillment_errors(errors);\n-            false\n         }\n     }\n }\n@@ -296,6 +293,8 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         return;\n     }\n \n+    // Main should have no WC, so empty param env is OK here.\n+    let param_env = ty::ParamEnv::empty();\n     let expected_return_type;\n     if let Some(term_did) = tcx.lang_items().termination() {\n         let return_ty = main_fnsig.output();\n@@ -306,8 +305,6 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         }\n         let return_ty = return_ty.skip_binder();\n         let infcx = tcx.infer_ctxt().build();\n-        // Main should have no WC, so empty param env is OK here.\n-        let param_env = ty::ParamEnv::empty();\n         let cause = traits::ObligationCause::new(\n             return_ty_span,\n             main_diagnostics_def_id,\n@@ -343,6 +340,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n             main_diagnostics_def_id,\n             ObligationCauseCode::MainFunctionType,\n         ),\n+        param_env,\n         se_ty,\n         tcx.mk_fn_ptr(main_fnsig),\n     );\n@@ -417,6 +415,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n                     start_def_id,\n                     ObligationCauseCode::StartFunctionType,\n                 ),\n+                ty::ParamEnv::empty(), // start should not have any where bounds.\n                 se_ty,\n                 tcx.mk_fn_ptr(tcx.fn_sig(start_def_id).subst_identity()),\n             );\n@@ -513,7 +512,7 @@ pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n     // def-ID that will be used to determine the traits/predicates in\n     // scope. This is derived from the enclosing item-like thing.\n     let env_def_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n-    let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n+    let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.def_id);\n     item_cx.astconv().ast_ty_to_ty(hir_ty)\n }\n \n@@ -526,7 +525,7 @@ pub fn hir_trait_to_predicates<'tcx>(\n     // def-ID that will be used to determine the traits/predicates in\n     // scope. This is derived from the enclosing item-like thing.\n     let env_def_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n-    let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n+    let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.def_id);\n     let mut bounds = Bounds::default();\n     let _ = &item_cx.astconv().instantiate_poly_trait_ref(\n         hir_trait,"}, {"sha": "da72d2584e335ac450e5db3e4a0e8f4a87f71898", "filename": "compiler/rustc_hir_analysis/src/outlives/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,6 +1,6 @@\n use hir::Node;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, CratePredicatesMap, TyCtxt};\n@@ -17,8 +17,8 @@ pub fn provide(providers: &mut Providers) {\n     *providers = Providers { inferred_outlives_of, inferred_outlives_crate, ..*providers };\n }\n \n-fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Clause<'_>, Span)] {\n-    let id = tcx.hir().local_def_id_to_hir_id(item_def_id.expect_local());\n+fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[(ty::Clause<'_>, Span)] {\n+    let id = tcx.hir().local_def_id_to_hir_id(item_def_id);\n \n     if matches!(tcx.def_kind(item_def_id), hir::def::DefKind::AnonConst) && tcx.lazy_normalization()\n     {\n@@ -45,7 +45,8 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Clause<'_\n             hir::ItemKind::Struct(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Union(..) => {\n                 let crate_map = tcx.inferred_outlives_crate(());\n \n-                let predicates = crate_map.predicates.get(&item_def_id).copied().unwrap_or(&[]);\n+                let predicates =\n+                    crate_map.predicates.get(&item_def_id.to_def_id()).copied().unwrap_or(&[]);\n \n                 if tcx.has_attr(item_def_id, sym::rustc_outlives) {\n                     let mut pred: Vec<String> = predicates"}, {"sha": "60f8e246ad662979967f7a8eb6c379ba52c67bb0", "filename": "compiler/rustc_hir_analysis/src/outlives/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -6,7 +6,7 @@ pub fn test_inferred_outlives(tcx: TyCtxt<'_>) {\n     for id in tcx.hir().items() {\n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found.\n-        if tcx.has_attr(id.owner_id.to_def_id(), sym::rustc_outlives) {\n+        if tcx.has_attr(id.owner_id, sym::rustc_outlives) {\n             let inferred_outlives_of = tcx.inferred_outlives_of(id.owner_id);\n             struct_span_err!(\n                 tcx.sess,"}, {"sha": "0a45119ff055b10bd55bd35fa83c5f37cbc03993", "filename": "compiler/rustc_hir_analysis/src/variance/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -38,7 +38,7 @@ fn crate_variances(tcx: TyCtxt<'_>, (): ()) -> CrateVariancesMap<'_> {\n     solve::solve_constraints(constraints_cx)\n }\n \n-fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n+fn variances_of(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Variance] {\n     // Skip items with no generics - there's nothing to infer in them.\n     if tcx.generics_of(item_def_id).count() == 0 {\n         return &[];\n@@ -53,7 +53,7 @@ fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n         | DefKind::Variant\n         | DefKind::Ctor(..) => {}\n         DefKind::OpaqueTy | DefKind::ImplTraitPlaceholder => {\n-            return variance_of_opaque(tcx, item_def_id.expect_local());\n+            return variance_of_opaque(tcx, item_def_id);\n         }\n         _ => {\n             // Variance not relevant.\n@@ -64,7 +64,7 @@ fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n     // Everything else must be inferred.\n \n     let crate_map = tcx.crate_variances(());\n-    crate_map.variances.get(&item_def_id).copied().unwrap_or(&[])\n+    crate_map.variances.get(&item_def_id.to_def_id()).copied().unwrap_or(&[])\n }\n \n #[instrument(level = \"trace\", skip(tcx), ret)]\n@@ -152,7 +152,7 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n \n     let mut collector =\n         OpaqueTypeLifetimeCollector { tcx, root_def_id: item_def_id.to_def_id(), variances };\n-    let id_substs = ty::InternalSubsts::identity_for_item(tcx, item_def_id.to_def_id());\n+    let id_substs = ty::InternalSubsts::identity_for_item(tcx, item_def_id);\n     for pred in tcx.bound_explicit_item_bounds(item_def_id.to_def_id()).transpose_iter() {\n         let pred = pred.map_bound(|(pred, _)| *pred).subst(tcx, id_substs);\n         debug!(?pred);"}, {"sha": "d57d05d7605db0770604f04978378411f54e8caf", "filename": "compiler/rustc_hir_analysis/src/variance/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -7,7 +7,7 @@ pub fn test_variance(tcx: TyCtxt<'_>) {\n     // For unit testing: check for a special \"rustc_variance\"\n     // attribute and report an error with various results if found.\n     for id in tcx.hir().items() {\n-        if tcx.has_attr(id.owner_id.to_def_id(), sym::rustc_variance) {\n+        if tcx.has_attr(id.owner_id, sym::rustc_variance) {\n             let variances_of = tcx.variances_of(id.owner_id);\n \n             tcx.sess.emit_err(errors::VariancesOf {"}, {"sha": "5235710a2666e38e6e3af80c2e438b349efd8502", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -668,7 +668,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if !self.maybe_suggest_bad_array_definition(&mut err, call_expr, callee_expr) {\n             if let Some((maybe_def, output_ty, _)) = self.extract_callable_info(callee_ty)\n-                && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n+                && !self.type_is_sized_modulo_regions(self.param_env, output_ty)\n             {\n                 let descr = match maybe_def {\n                     DefIdOrName::DefId(def_id) => self.tcx.def_descr(def_id),"}, {"sha": "d28b3b3ce7bbd11e0071d6ddfef6724763bf5858", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let t = self.resolve_vars_if_possible(t);\n         t.error_reported()?;\n \n-        if self.type_is_sized_modulo_regions(self.param_env, t, span) {\n+        if self.type_is_sized_modulo_regions(self.param_env, t) {\n             return Ok(Some(PointerKind::Thin));\n         }\n \n@@ -722,7 +722,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n         debug!(\"check_cast({}, {:?} as {:?})\", self.expr.hir_id, self.expr_ty, self.cast_ty);\n \n-        if !fcx.type_is_sized_modulo_regions(fcx.param_env, self.cast_ty, self.span)\n+        if !fcx.type_is_sized_modulo_regions(fcx.param_env, self.cast_ty)\n             && !self.cast_ty.has_infer_types()\n         {\n             self.report_cast_to_unsized_type(fcx);"}, {"sha": "8fa3bcd68c3d3c1807d342594bebc512f3e7c834", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -46,7 +46,7 @@ use rustc_hir::Expr;\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{Coercion, DefineOpaqueTypes, InferOk, InferResult};\n-use rustc_infer::traits::Obligation;\n+use rustc_infer::traits::{Obligation, PredicateObligation};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -597,13 +597,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // and almost never more than 3. By using a SmallVec we avoid an\n         // allocation, at the (very small) cost of (occasionally) having to\n         // shift subsequent elements down when removing the front element.\n-        let mut queue: SmallVec<[_; 4]> = smallvec![traits::predicate_for_trait_def(\n+        let mut queue: SmallVec<[PredicateObligation<'tcx>; 4]> = smallvec![Obligation::new(\n             self.tcx,\n-            self.fcx.param_env,\n             cause,\n-            coerce_unsized_did,\n-            0,\n-            [coerce_source, coerce_target]\n+            self.fcx.param_env,\n+            self.tcx.mk_trait_ref(coerce_unsized_did, [coerce_source, coerce_target])\n         )];\n \n         let mut has_unsized_tuple_coercion = false;\n@@ -651,9 +649,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                         let self_ty = trait_pred.skip_binder().self_ty();\n                         let unsize_ty = trait_pred.skip_binder().trait_ref.substs[1].expect_ty();\n                         debug!(\"coerce_unsized: ambiguous unsize case for {:?}\", trait_pred);\n-                        match (&self_ty.kind(), &unsize_ty.kind()) {\n-                            (ty::Infer(ty::TyVar(v)), ty::Dynamic(..))\n-                                if self.type_var_is_sized(*v) =>\n+                        match (self_ty.kind(), unsize_ty.kind()) {\n+                            (&ty::Infer(ty::TyVar(v)), ty::Dynamic(..))\n+                                if self.type_var_is_sized(v) =>\n                             {\n                                 debug!(\"coerce_unsized: have sized infer {:?}\", v);\n                                 coercion.obligations.push(obligation);"}, {"sha": "06e857ec3ca1d6b915a377eea5aae6d940797613", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1480,7 +1480,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     // For this suggestion to make sense, the type would need to be `Copy`,\n                     // or we have to be moving out of a `Box<T>`\n-                    if self.type_is_copy_modulo_regions(self.param_env, expected, sp)\n+                    if self.type_is_copy_modulo_regions(self.param_env, expected)\n                         // FIXME(compiler-errors): We can actually do this if the checked_ty is\n                         // `steps` layers of boxes, not just one, but this is easier and most likely.\n                         || (checked_ty.is_box() && steps == 1)"}, {"sha": "c62c1553d6f722c3b6c97f4cc35eeca4410fa442", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -867,10 +867,7 @@ fn copy_or_move<'a, 'tcx>(\n     mc: &mc::MemCategorizationContext<'a, 'tcx>,\n     place_with_id: &PlaceWithHirId<'tcx>,\n ) -> ConsumeMode {\n-    if !mc.type_is_copy_modulo_regions(\n-        place_with_id.place.ty(),\n-        mc.tcx().hir().span(place_with_id.hir_id),\n-    ) {\n+    if !mc.type_is_copy_modulo_regions(place_with_id.place.ty()) {\n         ConsumeMode::Move\n     } else {\n         ConsumeMode::Copy"}, {"sha": "c6fd0b61035889fcffc3915b7717dfe07c9e303d", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -211,13 +211,13 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn get_type_parameter_bounds(\n         &self,\n         _: Span,\n-        def_id: DefId,\n+        def_id: LocalDefId,\n         _: Ident,\n     ) -> ty::GenericPredicates<'tcx> {\n         let tcx = self.tcx;\n-        let item_def_id = tcx.hir().ty_param_owner(def_id.expect_local());\n+        let item_def_id = tcx.hir().ty_param_owner(def_id);\n         let generics = tcx.generics_of(item_def_id);\n-        let index = generics.param_def_id_to_index[&def_id];\n+        let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n         ty::GenericPredicates {\n             parent: None,\n             predicates: tcx.arena.alloc_from_iter("}, {"sha": "7273b93b67690f5d4014119cae483c3c8c17369c", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1011,11 +1011,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut suggest_copied_or_cloned = || {\n             let expr_inner_ty = substs.type_at(0);\n             let expected_inner_ty = expected_substs.type_at(0);\n-            if let ty::Ref(_, ty, hir::Mutability::Not) = expr_inner_ty.kind()\n-                && self.can_eq(self.param_env, *ty, expected_inner_ty)\n+            if let &ty::Ref(_, ty, hir::Mutability::Not) = expr_inner_ty.kind()\n+                && self.can_eq(self.param_env, ty, expected_inner_ty)\n             {\n                 let def_path = self.tcx.def_path_str(adt_def.did());\n-                if self.type_is_copy_modulo_regions(self.param_env, *ty, expr.span) {\n+                if self.type_is_copy_modulo_regions(self.param_env, ty) {\n                     diag.span_suggestion_verbose(\n                         expr.span.shrink_to_hi(),\n                         format!(\n@@ -1029,9 +1029,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     && rustc_trait_selection::traits::type_known_to_meet_bound_modulo_regions(\n                         self,\n                         self.param_env,\n-                        *ty,\n+                        ty,\n                         clone_did,\n-                        expr.span\n                     )\n                 {\n                     diag.span_suggestion_verbose("}, {"sha": "6af095cb4d437d23cbeb85b89ac335159bf9eaff", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -207,7 +207,7 @@ fn typeck_with_fallback<'tcx>(\n     let body = tcx.hir().body(body_id);\n \n     let param_env = tcx.param_env(def_id);\n-    let param_env = if tcx.has_attr(def_id.to_def_id(), sym::rustc_do_not_const_check) {\n+    let param_env = if tcx.has_attr(def_id, sym::rustc_do_not_const_check) {\n         param_env.without_const()\n     } else {\n         param_env"}, {"sha": "95e5483abf3bd31211bf427f282d5ebd77aa784e", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -120,8 +120,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub(crate) fn type_is_copy_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n-        self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span)\n+    pub(crate) fn type_is_copy_modulo_regions(&self, ty: Ty<'tcx>) -> bool {\n+        self.infcx.type_is_copy_modulo_regions(self.param_env, ty)\n     }\n \n     fn resolve_vars_if_possible<T>(&self, value: T) -> T"}, {"sha": "8a83bb58573d3c2467b663ea3424562a6149be58", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -21,7 +21,7 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{self, FulfillmentError};\n+use rustc_trait_selection::traits::{self, FulfillmentError, ObligationCtxt};\n use rustc_type_ir::sty::TyKind::*;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -434,7 +434,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if self.type_is_copy_modulo_regions(\n                         self.param_env,\n                         *lhs_deref_ty,\n-                        lhs_expr.span,\n                     ) {\n                         suggest_deref_binop(*lhs_deref_ty);\n                     }\n@@ -776,7 +775,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (None, Some(trait_did)) => {\n                 let (obligation, _) =\n                     self.obligation_for_method(cause, trait_did, lhs_ty, Some(input_types));\n-                Err(rustc_trait_selection::traits::fully_solve_obligation(self, obligation))\n+                // FIXME: This should potentially just add the obligation to the `FnCtxt`\n+                let ocx = ObligationCtxt::new(&self.infcx);\n+                ocx.register_obligation(obligation);\n+                Err(ocx.select_all_or_error())\n             }\n         }\n     }"}, {"sha": "d5d260d713897fd6f44f8539378c81f134b2cd7c", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -424,7 +424,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // closures. We want to make sure any adjustment that might make us move the place into\n                 // the closure gets handled.\n                 let (place, capture_kind) =\n-                    restrict_precision_for_drop_types(self, place, capture_kind, usage_span);\n+                    restrict_precision_for_drop_types(self, place, capture_kind);\n \n                 capture_info.capture_kind = capture_kind;\n                 (place, capture_info)\n@@ -1498,7 +1498,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn should_log_capture_analysis(&self, closure_def_id: LocalDefId) -> bool {\n-        self.tcx.has_attr(closure_def_id.to_def_id(), sym::rustc_capture_analysis)\n+        self.tcx.has_attr(closure_def_id, sym::rustc_capture_analysis)\n     }\n \n     fn log_capture_analysis_first_pass(\n@@ -1822,9 +1822,8 @@ fn restrict_precision_for_drop_types<'a, 'tcx>(\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     mut place: Place<'tcx>,\n     mut curr_mode: ty::UpvarCapture,\n-    span: Span,\n ) -> (Place<'tcx>, ty::UpvarCapture) {\n-    let is_copy_type = fcx.infcx.type_is_copy_modulo_regions(fcx.param_env, place.ty(), span);\n+    let is_copy_type = fcx.infcx.type_is_copy_modulo_regions(fcx.param_env, place.ty());\n \n     if let (false, UpvarCapture::ByValue) = (is_copy_type, curr_mode) {\n         for i in 0..place.projections.len() {"}, {"sha": "e876fa27593d46e1eeaabcfc3f3a89d097e7df23", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -44,8 +44,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // This attribute causes us to dump some writeback information\n         // in the form of errors, which is used for unit tests.\n-        let rustc_dump_user_substs =\n-            self.tcx.has_attr(item_def_id.to_def_id(), sym::rustc_dump_user_substs);\n+        let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, sym::rustc_dump_user_substs);\n \n         let mut wbcx = WritebackCx::new(self, body, rustc_dump_user_substs);\n         for param in body.params {"}, {"sha": "1d88dfd20c8cd0c353ea2b6221e33c9afd5c745d", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -371,7 +371,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n     fn check_item(&mut self, item_id: LocalDefId) {\n         let item_span = self.tcx.def_span(item_id.to_def_id());\n         let def_path_hash = self.tcx.def_path_hash(item_id.to_def_id());\n-        for attr in self.tcx.get_attrs(item_id.to_def_id(), sym::rustc_clean) {\n+        for attr in self.tcx.get_attrs(item_id, sym::rustc_clean) {\n             let Some(assertion) = self.assertion_maybe(item_id, attr) else {\n                 continue;\n             };"}, {"sha": "4503af03ca341200fadd47c843d6e9c543bcce97", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -189,10 +189,19 @@ impl<'tcx> InferCtxt<'tcx> {\n         // the expected const's type. Specifically, we don't want const infer vars\n         // to do any type shapeshifting before and after resolution.\n         if let Err(guar) = compatible_types {\n-            return Ok(self.tcx.const_error_with_guaranteed(\n-                if relation.a_is_expected() { a.ty() } else { b.ty() },\n-                guar,\n-            ));\n+            // HACK: equating both sides with `[const error]` eagerly prevents us\n+            // from leaving unconstrained inference vars during things like impl\n+            // matching in the solver.\n+            let a_error = self.tcx.const_error_with_guaranteed(a.ty(), guar);\n+            if let ty::ConstKind::Infer(InferConst::Var(vid)) = a.kind() {\n+                return self.unify_const_variable(vid, a_error);\n+            }\n+            let b_error = self.tcx.const_error_with_guaranteed(b.ty(), guar);\n+            if let ty::ConstKind::Infer(InferConst::Var(vid)) = b.kind() {\n+                return self.unify_const_variable(vid, b_error);\n+            }\n+\n+            return Ok(if relation.a_is_expected() { a_error } else { b_error });\n         }\n \n         match (a.kind(), b.kind()) {"}, {"sha": "e720af73c39f23abf3730d2bf409c4145d20a066", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -306,9 +306,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             // Replace the explicit self type with `Self` for better suggestion rendering\n             .with_self_ty(self.tcx, self.tcx.mk_ty_param(0, kw::SelfUpper))\n             .substs;\n-        let trait_item_substs =\n-            ty::InternalSubsts::identity_for_item(self.tcx, impl_item_def_id.to_def_id())\n-                .rebase_onto(self.tcx, impl_def_id, trait_substs);\n+        let trait_item_substs = ty::InternalSubsts::identity_for_item(self.tcx, impl_item_def_id)\n+            .rebase_onto(self.tcx, impl_def_id, trait_substs);\n \n         let Ok(trait_predicates) = self\n             .tcx"}, {"sha": "ec122dc039f7715ae944187384d53805007eefb8", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -356,7 +356,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n                 if !self.same_type_modulo_infer(*found_sig, *expected_sig)\n                     || !sig.is_suggestable(self.tcx, true)\n-                    || ty::util::is_intrinsic(self.tcx, *did)\n+                    || self.tcx.is_intrinsic(*did)\n                 {\n                     return;\n                 }\n@@ -400,8 +400,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 if !self.same_type_modulo_infer(*found_sig, *expected_sig)\n                     || !found_sig.is_suggestable(self.tcx, true)\n                     || !expected_sig.is_suggestable(self.tcx, true)\n-                    || ty::util::is_intrinsic(self.tcx, *did1)\n-                    || ty::util::is_intrinsic(self.tcx, *did2)\n+                    || self.tcx.is_intrinsic(*did1)\n+                    || self.tcx.is_intrinsic(*did2)\n                 {\n                     return;\n                 }"}, {"sha": "dd9b2e548c7315d67ebbc7ce58b2d55fcea83d2d", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -8,6 +8,8 @@ mod project;\n mod structural_impls;\n pub mod util;\n \n+use std::cmp;\n+\n use hir::def_id::LocalDefId;\n use rustc_hir as hir;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n@@ -139,6 +141,14 @@ impl<'tcx, O> Obligation<'tcx, O> {\n         Self::with_depth(tcx, cause, 0, param_env, predicate)\n     }\n \n+    /// We often create nested obligations without setting the correct depth.\n+    ///\n+    /// To deal with this evaluate and fulfill explicitly update the depth\n+    /// of nested obligations using this function.\n+    pub fn set_depth_from_parent(&mut self, parent_depth: usize) {\n+        self.recursion_depth = cmp::max(parent_depth + 1, self.recursion_depth);\n+    }\n+\n     pub fn with_depth(\n         tcx: TyCtxt<'tcx>,\n         cause: ObligationCause<'tcx>,"}, {"sha": "8af1a663ef5e3987a6258175dd8152e751fdd267", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1306,7 +1306,7 @@ impl<'tcx> LateLintPass<'tcx> for UngatedAsyncFnTrackCaller {\n         if fn_kind.asyncness() == IsAsync::Async\n             && !cx.tcx.features().closure_track_caller\n             // Now, check if the function has the `#[track_caller]` attribute\n-            && let Some(attr) = cx.tcx.get_attr(def_id.to_def_id(), sym::track_caller)\n+            && let Some(attr) = cx.tcx.get_attr(def_id, sym::track_caller)\n         {\n             cx.emit_spanned_lint(UNGATED_ASYNC_FN_TRACK_CALLER, attr.span, BuiltinUngatedAsyncFnTrackCaller {\n                 label: span,\n@@ -2748,10 +2748,7 @@ impl ClashingExternDeclarations {\n                 // information, we could have codegen_fn_attrs also give span information back for\n                 // where the attribute was defined. However, until this is found to be a\n                 // bottleneck, this does just fine.\n-                (\n-                    overridden_link_name,\n-                    tcx.get_attr(fi.owner_id.to_def_id(), sym::link_name).unwrap().span,\n-                )\n+                (overridden_link_name, tcx.get_attr(fi.owner_id, sym::link_name).unwrap().span)\n             })\n         {\n             SymbolName::Link(overridden_link_name, overridden_link_name_span)"}, {"sha": "7b58bf03bbea8a76eab9f983cbee60fdbb248d57", "filename": "compiler/rustc_lint/src/for_loops_over_fallibles.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -11,6 +11,7 @@ use rustc_hir as hir;\n use rustc_infer::{infer::TyCtxtInferExt, traits::ObligationCause};\n use rustc_middle::ty::{self, List};\n use rustc_span::{sym, Span};\n+use rustc_trait_selection::traits::ObligationCtxt;\n \n declare_lint! {\n     /// The `for_loops_over_fallibles` lint checks for `for` loops over `Option` or `Result` values.\n@@ -136,20 +137,22 @@ fn suggest_question_mark<'tcx>(\n \n     let ty = substs.type_at(0);\n     let infcx = cx.tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+\n     let body_def_id = cx.tcx.hir().body_owner_def_id(body_id);\n     let cause = ObligationCause::new(\n         span,\n         body_def_id,\n         rustc_infer::traits::ObligationCauseCode::MiscObligation,\n     );\n-    let errors = rustc_trait_selection::traits::fully_solve_bound(\n-        &infcx,\n+\n+    ocx.register_bound(\n         cause,\n-        ty::ParamEnv::empty(),\n+        cx.param_env,\n         // Erase any region vids from the type, which may not be resolved\n         infcx.tcx.erase_regions(ty),\n         into_iterator_did,\n     );\n \n-    errors.is_empty()\n+    ocx.select_all_or_error().is_empty()\n }"}, {"sha": "9c7feadaf874ff853b8a537dd1354f871f4828ee", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -386,7 +386,7 @@ impl LateLintPass<'_> for Diagnostics {\n         for (hir_id, parent) in cx.tcx.hir().parent_iter(expr.hir_id) {\n             if let Some(owner_did) = hir_id.as_owner() {\n                 found_parent_with_attr = found_parent_with_attr\n-                    || cx.tcx.has_attr(owner_did.to_def_id(), sym::rustc_lint_diagnostics);\n+                    || cx.tcx.has_attr(owner_did, sym::rustc_lint_diagnostics);\n             }\n \n             debug!(?parent);"}, {"sha": "0f44dde59485adf2713216a71fa0236392e758b3", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -384,9 +384,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n         match &fk {\n             FnKind::Method(ident, sig, ..) => match method_context(cx, id) {\n                 MethodLateContext::PlainImpl => {\n-                    if sig.header.abi != Abi::Rust\n-                        && cx.tcx.has_attr(id.to_def_id(), sym::no_mangle)\n-                    {\n+                    if sig.header.abi != Abi::Rust && cx.tcx.has_attr(id, sym::no_mangle) {\n                         return;\n                     }\n                     self.check_snake_case(cx, \"method\", ident);\n@@ -398,7 +396,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n             },\n             FnKind::ItemFn(ident, _, header) => {\n                 // Skip foreign-ABI #[no_mangle] functions (Issue #31924)\n-                if header.abi != Abi::Rust && cx.tcx.has_attr(id.to_def_id(), sym::no_mangle) {\n+                if header.abi != Abi::Rust && cx.tcx.has_attr(id, sym::no_mangle) {\n                     return;\n                 }\n                 self.check_snake_case(cx, \"function\", ident);"}, {"sha": "9661e815623db34f960339c1d3e811031150d8f2", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -13,6 +13,7 @@ use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::exported_symbols::ExportedSymbol;\n use rustc_middle::middle::stability::DeprecationEntry;\n+use rustc_middle::query::LocalCrate;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::{self, TyCtxt};\n@@ -367,10 +368,7 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         allocator_kind: |tcx, ()| CStore::from_tcx(tcx).allocator_kind(),\n         alloc_error_handler_kind: |tcx, ()| CStore::from_tcx(tcx).alloc_error_handler_kind(),\n-        is_private_dep: |_tcx, cnum| {\n-            assert_eq!(cnum, LOCAL_CRATE);\n-            false\n-        },\n+        is_private_dep: |_tcx, LocalCrate| false,\n         native_library: |tcx, id| {\n             tcx.native_libraries(id.krate)\n                 .iter()\n@@ -386,12 +384,8 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n                         .contains(&id)\n                 })\n         },\n-        native_libraries: |tcx, cnum| {\n-            assert_eq!(cnum, LOCAL_CRATE);\n-            native_libs::collect(tcx)\n-        },\n-        foreign_modules: |tcx, cnum| {\n-            assert_eq!(cnum, LOCAL_CRATE);\n+        native_libraries: |tcx, LocalCrate| native_libs::collect(tcx),\n+        foreign_modules: |tcx, LocalCrate| {\n             foreign_modules::collect(tcx).into_iter().map(|m| (m.def_id, m)).collect()\n         },\n \n@@ -489,14 +483,8 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n         },\n \n         dependency_formats: |tcx, ()| Lrc::new(crate::dependency_format::calculate(tcx)),\n-        has_global_allocator: |tcx, cnum| {\n-            assert_eq!(cnum, LOCAL_CRATE);\n-            CStore::from_tcx(tcx).has_global_allocator()\n-        },\n-        has_alloc_error_handler: |tcx, cnum| {\n-            assert_eq!(cnum, LOCAL_CRATE);\n-            CStore::from_tcx(tcx).has_alloc_error_handler()\n-        },\n+        has_global_allocator: |tcx, LocalCrate| CStore::from_tcx(tcx).has_global_allocator(),\n+        has_alloc_error_handler: |tcx, LocalCrate| CStore::from_tcx(tcx).has_alloc_error_handler(),\n         postorder_cnums: |tcx, ()| {\n             tcx.arena\n                 .alloc_slice(&CStore::from_tcx(tcx).crate_dependencies_in_postorder(LOCAL_CRATE))"}, {"sha": "ef3eda584e1b83d5068a174dc1269cd7ff9b4648", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -24,6 +24,7 @@ use rustc_middle::middle::exported_symbols::{\n     metadata_symbol_name, ExportedSymbol, SymbolExportInfo,\n };\n use rustc_middle::mir::interpret;\n+use rustc_middle::query::LocalCrate;\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams, TreatProjections};\n@@ -2231,18 +2232,16 @@ pub fn provide(providers: &mut Providers) {\n         doc_link_resolutions: |tcx, def_id| {\n             tcx.resolutions(())\n                 .doc_link_resolutions\n-                .get(&def_id.expect_local())\n+                .get(&def_id)\n                 .expect(\"no resolutions for a doc link\")\n         },\n         doc_link_traits_in_scope: |tcx, def_id| {\n             tcx.resolutions(())\n                 .doc_link_traits_in_scope\n-                .get(&def_id.expect_local())\n+                .get(&def_id)\n                 .expect(\"no traits in scope for a doc link\")\n         },\n-        traits_in_crate: |tcx, cnum| {\n-            assert_eq!(cnum, LOCAL_CRATE);\n-\n+        traits_in_crate: |tcx, LocalCrate| {\n             let mut traits = Vec::new();\n             for id in tcx.hir().items() {\n                 if matches!(tcx.def_kind(id.owner_id), DefKind::Trait | DefKind::TraitAlias) {\n@@ -2254,9 +2253,7 @@ pub fn provide(providers: &mut Providers) {\n             traits.sort_by_cached_key(|&def_id| tcx.def_path_hash(def_id));\n             tcx.arena.alloc_slice(&traits)\n         },\n-        trait_impls_in_crate: |tcx, cnum| {\n-            assert_eq!(cnum, LOCAL_CRATE);\n-\n+        trait_impls_in_crate: |tcx, LocalCrate| {\n             let mut trait_impls = Vec::new();\n             for id in tcx.hir().items() {\n                 if matches!(tcx.def_kind(id.owner_id), DefKind::Impl { .. })"}, {"sha": "b2bae47054cc2894602fb38e7192ffdf63b3ef8c", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,12 +1,13 @@\n use crate::hir::{ModuleItems, Owner};\n+use crate::query::LocalCrate;\n use crate::ty::TyCtxt;\n use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::*;\n@@ -1131,8 +1132,7 @@ impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n     }\n }\n \n-pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n-    debug_assert_eq!(crate_num, LOCAL_CRATE);\n+pub(super) fn crate_hash(tcx: TyCtxt<'_>, _: LocalCrate) -> Svh {\n     let krate = tcx.hir_crate(());\n     let hir_body_hash = krate.opt_hir_hash.expect(\"HIR hash missing while computing crate hash\");\n "}, {"sha": "0d8a8c9cdfd43f55dd8806990e5f8129aab3ce45", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -147,18 +147,18 @@ pub fn provide(providers: &mut Providers) {\n         tcx.hir_crate(()).owners[id.def_id].as_owner().map_or(AttributeMap::EMPTY, |o| &o.attrs)\n     };\n     providers.def_span = |tcx, def_id| {\n-        let def_id = def_id.expect_local();\n+        let def_id = def_id;\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         tcx.hir().opt_span(hir_id).unwrap_or(DUMMY_SP)\n     };\n     providers.def_ident_span = |tcx, def_id| {\n-        let def_id = def_id.expect_local();\n+        let def_id = def_id;\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         tcx.hir().opt_ident_span(hir_id)\n     };\n     providers.fn_arg_names = |tcx, id| {\n         let hir = tcx.hir();\n-        let def_id = id.expect_local();\n+        let def_id = id;\n         let hir_id = hir.local_def_id_to_hir_id(def_id);\n         if let Some(body_id) = hir.maybe_body_owned_by(def_id) {\n             tcx.arena.alloc_from_iter(hir.body_param_names(body_id))\n@@ -176,12 +176,10 @@ pub fn provide(providers: &mut Providers) {\n             span_bug!(hir.span(hir_id), \"fn_arg_names: unexpected item {:?}\", id);\n         }\n     };\n-    providers.opt_def_kind = |tcx, def_id| tcx.hir().opt_def_kind(def_id.expect_local());\n+    providers.opt_def_kind = |tcx, def_id| tcx.hir().opt_def_kind(def_id);\n     providers.all_local_trait_impls = |tcx, ()| &tcx.resolutions(()).trait_impls;\n-    providers.expn_that_defined = |tcx, id| {\n-        let id = id.expect_local();\n-        tcx.resolutions(()).expn_that_defined.get(&id).copied().unwrap_or(ExpnId::root())\n-    };\n+    providers.expn_that_defined =\n+        |tcx, id| tcx.resolutions(()).expn_that_defined.get(&id).copied().unwrap_or(ExpnId::root());\n     providers.in_scope_traits_map = |tcx, id| {\n         tcx.hir_crate(()).owners[id.def_id].as_owner().map(|owner_info| &owner_info.trait_map)\n     };"}, {"sha": "638c082cc84c771a26a096421df8f961f418dba2", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -2525,7 +2525,7 @@ impl<'tcx> ConstantKind<'tcx> {\n         let parent_substs = if let Some(parent_hir_id) = tcx.hir().opt_parent_id(hir_id)\n             && let Some(parent_did) = parent_hir_id.as_owner()\n         {\n-            InternalSubsts::identity_for_item(tcx, parent_did.to_def_id())\n+            InternalSubsts::identity_for_item(tcx, parent_did)\n         } else {\n             List::empty()\n         };\n@@ -2554,7 +2554,7 @@ impl<'tcx> ConstantKind<'tcx> {\n                 Self::Unevaluated(\n                     UnevaluatedConst {\n                         def: def.to_global(),\n-                        substs: InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n+                        substs: InternalSubsts::identity_for_item(tcx, def.did),\n                         promoted: None,\n                     },\n                     ty,"}, {"sha": "3a893cdabf67eba0dc23a512dae950637ec71229", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -78,7 +78,8 @@ pub enum MirPhase {\n     ///    MIR, this is UB.\n     ///  - Retags: If `-Zmir-emit-retag` is enabled, analysis MIR has \"implicit\" retags in the same way\n     ///    that Rust itself has them. Where exactly these are is generally subject to change, and so we\n-    ///    don't document this here. Runtime MIR has all retags explicit.\n+    ///    don't document this here. Runtime MIR has most retags explicit (though implicit retags\n+    ///    can still occur at `Rvalue::{Ref,AddrOf}`).\n     ///  - Generator bodies: In analysis MIR, locals may actually be behind a pointer that user code has\n     ///    access to. This occurs in generator bodies. Such locals do not behave like other locals,\n     ///    because they eg may be aliased in surprising ways. Runtime MIR has no such special locals -\n@@ -1165,7 +1166,7 @@ pub enum AggregateKind<'tcx> {\n     Tuple,\n \n     /// The second field is the variant index. It's equal to 0 for struct\n-    /// and union expressions. The fourth field is\n+    /// and union expressions. The last field is the\n     /// active field number and is present only for union expressions\n     /// -- e.g., for a union expression `SomeUnion { c: .. }`, the\n     /// active field index would identity the field `c`"}, {"sha": "ca65fbc2fd470cde55ed344b0b3668f2bb4b8fd4", "filename": "compiler/rustc_middle/src/query/keys.rs", "status": "modified", "additions": 63, "deletions": 227, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -13,6 +13,10 @@ use rustc_query_system::query::{DefaultCacheSelector, SingleCacheSelector, VecCa\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n+/// Placeholder for `CrateNum`'s \"local\" counterpart\n+#[derive(Copy, Clone, Debug)]\n+pub struct LocalCrate;\n+\n /// The `Key` trait controls what types can legally be used as the key\n /// for a query.\n pub trait Key: Sized {\n@@ -26,10 +30,6 @@ pub trait Key: Sized {\n     //      r-a issue: <https://github.com/rust-lang/rust-analyzer/issues/13693>\n     type CacheSelector;\n \n-    /// Given an instance of this key, what crate is it referring to?\n-    /// This is used to find the provider.\n-    fn query_crate_is_local(&self) -> bool;\n-\n     /// In the event that a cycle occurs, if no explicit span has been\n     /// given for a query with key `self`, what span should we use?\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span;\n@@ -45,14 +45,17 @@ pub trait Key: Sized {\n     }\n }\n \n+pub trait AsLocalKey: Key {\n+    type LocalKey;\n+\n+    /// Given an instance of this key, what crate is it referring to?\n+    /// This is used to find the provider.\n+    fn as_local_key(&self) -> Option<Self::LocalKey>;\n+}\n+\n impl Key for () {\n     type CacheSelector = SingleCacheSelector;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n-\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -61,23 +64,22 @@ impl Key for () {\n impl<'tcx> Key for ty::InstanceDef<'tcx> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.def_id().is_local()\n-    }\n-\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(self.def_id())\n     }\n }\n \n-impl<'tcx> Key for ty::Instance<'tcx> {\n-    type CacheSelector = DefaultCacheSelector<Self>;\n+impl<'tcx> AsLocalKey for ty::InstanceDef<'tcx> {\n+    type LocalKey = Self;\n \n     #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.def_id().is_local()\n+    fn as_local_key(&self) -> Option<Self::LocalKey> {\n+        self.def_id().is_local().then(|| *self)\n     }\n+}\n+\n+impl<'tcx> Key for ty::Instance<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n \n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(self.def_id())\n@@ -87,11 +89,6 @@ impl<'tcx> Key for ty::Instance<'tcx> {\n impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n-\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.instance.default_span(tcx)\n     }\n@@ -100,11 +97,6 @@ impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n impl<'tcx> Key for (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n-\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -113,11 +105,6 @@ impl<'tcx> Key for (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>) {\n impl<'tcx> Key for mir::interpret::LitToConstInput<'tcx> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n-\n     fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -126,25 +113,27 @@ impl<'tcx> Key for mir::interpret::LitToConstInput<'tcx> {\n impl Key for CrateNum {\n     type CacheSelector = VecCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        *self == LOCAL_CRATE\n-    }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n \n-impl Key for OwnerId {\n-    type CacheSelector = VecCacheSelector<Self>;\n+impl AsLocalKey for CrateNum {\n+    type LocalKey = LocalCrate;\n \n     #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n+    fn as_local_key(&self) -> Option<Self::LocalKey> {\n+        (*self == LOCAL_CRATE).then_some(LocalCrate)\n     }\n+}\n+\n+impl Key for OwnerId {\n+    type CacheSelector = VecCacheSelector<Self>;\n+\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.to_def_id().default_span(tcx)\n     }\n+\n     fn key_as_def_id(&self) -> Option<DefId> {\n         Some(self.to_def_id())\n     }\n@@ -153,13 +142,10 @@ impl Key for OwnerId {\n impl Key for LocalDefId {\n     type CacheSelector = VecCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.to_def_id().default_span(tcx)\n     }\n+\n     fn key_as_def_id(&self) -> Option<DefId> {\n         Some(self.to_def_id())\n     }\n@@ -168,26 +154,28 @@ impl Key for LocalDefId {\n impl Key for DefId {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.krate == LOCAL_CRATE\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(*self)\n     }\n+\n     #[inline(always)]\n     fn key_as_def_id(&self) -> Option<DefId> {\n         Some(*self)\n     }\n }\n \n-impl Key for ty::WithOptConstParam<LocalDefId> {\n-    type CacheSelector = DefaultCacheSelector<Self>;\n+impl AsLocalKey for DefId {\n+    type LocalKey = LocalDefId;\n \n     #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n+    fn as_local_key(&self) -> Option<Self::LocalKey> {\n+        self.as_local()\n     }\n+}\n+\n+impl Key for ty::WithOptConstParam<LocalDefId> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.did.default_span(tcx)\n     }\n@@ -196,10 +184,6 @@ impl Key for ty::WithOptConstParam<LocalDefId> {\n impl Key for SimplifiedType {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -208,10 +192,6 @@ impl Key for SimplifiedType {\n impl Key for (DefId, DefId) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.0.krate == LOCAL_CRATE\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.1.default_span(tcx)\n     }\n@@ -220,10 +200,6 @@ impl Key for (DefId, DefId) {\n impl<'tcx> Key for (ty::Instance<'tcx>, LocalDefId) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.0.default_span(tcx)\n     }\n@@ -232,10 +208,6 @@ impl<'tcx> Key for (ty::Instance<'tcx>, LocalDefId) {\n impl Key for (DefId, LocalDefId) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.0.krate == LOCAL_CRATE\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.1.default_span(tcx)\n     }\n@@ -244,10 +216,6 @@ impl Key for (DefId, LocalDefId) {\n impl Key for (LocalDefId, DefId) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.0.default_span(tcx)\n     }\n@@ -256,10 +224,6 @@ impl Key for (LocalDefId, DefId) {\n impl Key for (LocalDefId, LocalDefId) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.0.default_span(tcx)\n     }\n@@ -268,26 +232,19 @@ impl Key for (LocalDefId, LocalDefId) {\n impl Key for (DefId, Option<Ident>) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.0.krate == LOCAL_CRATE\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(self.0)\n     }\n+\n     #[inline(always)]\n     fn key_as_def_id(&self) -> Option<DefId> {\n         Some(self.0)\n     }\n }\n \n-impl Key for (DefId, LocalDefId, Ident) {\n+impl Key for (LocalDefId, LocalDefId, Ident) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.0.krate == LOCAL_CRATE\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.1.default_span(tcx)\n     }\n@@ -296,34 +253,40 @@ impl Key for (DefId, LocalDefId, Ident) {\n impl Key for (CrateNum, DefId) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.0 == LOCAL_CRATE\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.1.default_span(tcx)\n     }\n }\n \n-impl Key for (CrateNum, SimplifiedType) {\n-    type CacheSelector = DefaultCacheSelector<Self>;\n+impl AsLocalKey for (CrateNum, DefId) {\n+    type LocalKey = DefId;\n \n     #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.0 == LOCAL_CRATE\n+    fn as_local_key(&self) -> Option<Self::LocalKey> {\n+        (self.0 == LOCAL_CRATE).then(|| self.1)\n     }\n+}\n+\n+impl Key for (CrateNum, SimplifiedType) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n \n-impl Key for (DefId, SimplifiedType) {\n-    type CacheSelector = DefaultCacheSelector<Self>;\n+impl AsLocalKey for (CrateNum, SimplifiedType) {\n+    type LocalKey = SimplifiedType;\n \n     #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.0.krate == LOCAL_CRATE\n+    fn as_local_key(&self) -> Option<Self::LocalKey> {\n+        (self.0 == LOCAL_CRATE).then(|| self.1)\n     }\n+}\n+\n+impl Key for (DefId, SimplifiedType) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.0.default_span(tcx)\n     }\n@@ -332,10 +295,6 @@ impl Key for (DefId, SimplifiedType) {\n impl<'tcx> Key for SubstsRef<'tcx> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -344,10 +303,6 @@ impl<'tcx> Key for SubstsRef<'tcx> {\n impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.0.krate == LOCAL_CRATE\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.0.default_span(tcx)\n     }\n@@ -356,10 +311,6 @@ impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n impl<'tcx> Key for (ty::UnevaluatedConst<'tcx>, ty::UnevaluatedConst<'tcx>) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        (self.0).def.did.krate == LOCAL_CRATE\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         (self.0).def.did.default_span(tcx)\n     }\n@@ -368,10 +319,6 @@ impl<'tcx> Key for (ty::UnevaluatedConst<'tcx>, ty::UnevaluatedConst<'tcx>) {\n impl<'tcx> Key for (LocalDefId, DefId, SubstsRef<'tcx>) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.0.default_span(tcx)\n     }\n@@ -380,10 +327,6 @@ impl<'tcx> Key for (LocalDefId, DefId, SubstsRef<'tcx>) {\n impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.1.def_id().krate == LOCAL_CRATE\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(self.1.def_id())\n     }\n@@ -392,10 +335,6 @@ impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n impl<'tcx> Key for (ty::Const<'tcx>, mir::Field) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -404,10 +343,6 @@ impl<'tcx> Key for (ty::Const<'tcx>, mir::Field) {\n impl<'tcx> Key for mir::interpret::ConstAlloc<'tcx> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -416,10 +351,6 @@ impl<'tcx> Key for mir::interpret::ConstAlloc<'tcx> {\n impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.def_id().krate == LOCAL_CRATE\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(self.def_id())\n     }\n@@ -428,10 +359,6 @@ impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n impl<'tcx> Key for ty::PolyExistentialTraitRef<'tcx> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.def_id().krate == LOCAL_CRATE\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(self.def_id())\n     }\n@@ -440,10 +367,6 @@ impl<'tcx> Key for ty::PolyExistentialTraitRef<'tcx> {\n impl<'tcx> Key for (ty::PolyTraitRef<'tcx>, ty::PolyTraitRef<'tcx>) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.0.def_id().krate == LOCAL_CRATE\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(self.0.def_id())\n     }\n@@ -452,10 +375,6 @@ impl<'tcx> Key for (ty::PolyTraitRef<'tcx>, ty::PolyTraitRef<'tcx>) {\n impl<'tcx> Key for GenericArg<'tcx> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -464,10 +383,6 @@ impl<'tcx> Key for GenericArg<'tcx> {\n impl<'tcx> Key for mir::ConstantKind<'tcx> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -476,10 +391,6 @@ impl<'tcx> Key for mir::ConstantKind<'tcx> {\n impl<'tcx> Key for ty::Const<'tcx> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -488,13 +399,10 @@ impl<'tcx> Key for ty::Const<'tcx> {\n impl<'tcx> Key for Ty<'tcx> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n+\n     fn ty_adt_id(&self) -> Option<DefId> {\n         match self.kind() {\n             ty::Adt(adt, _) => Some(adt.did()),\n@@ -506,10 +414,6 @@ impl<'tcx> Key for Ty<'tcx> {\n impl<'tcx> Key for TyAndLayout<'tcx> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -518,10 +422,6 @@ impl<'tcx> Key for TyAndLayout<'tcx> {\n impl<'tcx> Key for (Ty<'tcx>, Ty<'tcx>) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -530,10 +430,6 @@ impl<'tcx> Key for (Ty<'tcx>, Ty<'tcx>) {\n impl<'tcx> Key for &'tcx ty::List<ty::Predicate<'tcx>> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -542,10 +438,6 @@ impl<'tcx> Key for &'tcx ty::List<ty::Predicate<'tcx>> {\n impl<'tcx> Key for ty::ParamEnv<'tcx> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -554,10 +446,6 @@ impl<'tcx> Key for ty::ParamEnv<'tcx> {\n impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        self.value.query_crate_is_local()\n-    }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.value.default_span(tcx)\n     }\n@@ -566,10 +454,6 @@ impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n impl Key for Symbol {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -578,25 +462,16 @@ impl Key for Symbol {\n impl Key for Option<Symbol> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n     fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n \n /// Canonical query goals correspond to abstract trait operations that\n /// are not tied to any crate in particular.\n-impl<'tcx, T> Key for Canonical<'tcx, T> {\n+impl<'tcx, T: Clone> Key for Canonical<'tcx, T> {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n-\n     fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -605,11 +480,6 @@ impl<'tcx, T> Key for Canonical<'tcx, T> {\n impl Key for (Symbol, u32, u32) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n-\n     fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -618,11 +488,6 @@ impl Key for (Symbol, u32, u32) {\n impl<'tcx> Key for (DefId, Ty<'tcx>, SubstsRef<'tcx>, ty::ParamEnv<'tcx>) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n-\n     fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -631,11 +496,6 @@ impl<'tcx> Key for (DefId, Ty<'tcx>, SubstsRef<'tcx>, ty::ParamEnv<'tcx>) {\n impl<'tcx> Key for (ty::Predicate<'tcx>, traits::WellFormedLoc) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n-\n     fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -644,11 +504,6 @@ impl<'tcx> Key for (ty::Predicate<'tcx>, traits::WellFormedLoc) {\n impl<'tcx> Key for (ty::PolyFnSig<'tcx>, &'tcx ty::List<Ty<'tcx>>) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n-\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -657,11 +512,6 @@ impl<'tcx> Key for (ty::PolyFnSig<'tcx>, &'tcx ty::List<Ty<'tcx>>) {\n impl<'tcx> Key for (ty::Instance<'tcx>, &'tcx ty::List<Ty<'tcx>>) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n-\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.0.default_span(tcx)\n     }\n@@ -670,11 +520,6 @@ impl<'tcx> Key for (ty::Instance<'tcx>, &'tcx ty::List<Ty<'tcx>>) {\n impl<'tcx> Key for (Ty<'tcx>, ty::ValTree<'tcx>) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n-\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n@@ -683,11 +528,6 @@ impl<'tcx> Key for (Ty<'tcx>, ty::ValTree<'tcx>) {\n impl Key for HirId {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n-\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.hir().span(*self)\n     }\n@@ -702,10 +542,6 @@ impl<'tcx> Key for (ValidityRequirement, ty::ParamEnvAnd<'tcx, Ty<'tcx>>) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n     // Just forward to `Ty<'tcx>`\n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n \n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP"}, {"sha": "f740ec51080ae4bb3d8511cde81cba1d5ad2abc8", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -8,7 +8,7 @@ use crate::ty::{self, print::describe_as_module, TyCtxt};\n use rustc_span::def_id::LOCAL_CRATE;\n \n mod keys;\n-pub use keys::Key;\n+pub use keys::{AsLocalKey, Key, LocalCrate};\n \n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n@@ -639,7 +639,7 @@ rustc_queries! {\n \n     /// To avoid cycles within the predicates of a single item we compute\n     /// per-type-parameter predicates for resolving `T::AssocTy`.\n-    query type_param_predicates(key: (DefId, LocalDefId, rustc_span::symbol::Ident)) -> ty::GenericPredicates<'tcx> {\n+    query type_param_predicates(key: (LocalDefId, LocalDefId, rustc_span::symbol::Ident)) -> ty::GenericPredicates<'tcx> {\n         desc { |tcx| \"computing the bounds for type parameter `{}`\", tcx.hir().ty_param_name(key.1) }\n     }\n \n@@ -796,7 +796,6 @@ rustc_queries! {\n     query associated_type_for_impl_trait_in_trait(opaque_ty_def_id: LocalDefId) -> LocalDefId {\n         desc { |tcx| \"creates the associated item corresponding to the opaque type `{}`\", tcx.def_path_str(opaque_ty_def_id.to_def_id()) }\n         cache_on_disk_if { true }\n-        separate_provide_extern\n     }\n \n     /// Given an `impl_id`, return the trait it implements."}, {"sha": "833402abfc4798a16ebb1cb64e7a11fa5550e5e7", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -897,6 +897,9 @@ pub enum ObjectSafetyViolation {\n     /// (e.g., `trait Foo : Bar<Self>`).\n     SupertraitSelf(SmallVec<[Span; 1]>),\n \n+    // Supertrait has a non-lifetime `for<T>` binder.\n+    SupertraitNonLifetimeBinder(SmallVec<[Span; 1]>),\n+\n     /// Method has something illegal.\n     Method(Symbol, MethodViolationCode, Span),\n \n@@ -919,6 +922,9 @@ impl ObjectSafetyViolation {\n                         .into()\n                 }\n             }\n+            ObjectSafetyViolation::SupertraitNonLifetimeBinder(_) => {\n+                format!(\"where clause cannot reference non-lifetime `for<...>` variables\").into()\n+            }\n             ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod(_), _) => {\n                 format!(\"associated function `{}` has no `self` parameter\", name).into()\n             }\n@@ -969,7 +975,9 @@ impl ObjectSafetyViolation {\n \n     pub fn solution(&self, err: &mut Diagnostic) {\n         match self {\n-            ObjectSafetyViolation::SizedSelf(_) | ObjectSafetyViolation::SupertraitSelf(_) => {}\n+            ObjectSafetyViolation::SizedSelf(_)\n+            | ObjectSafetyViolation::SupertraitSelf(_)\n+            | ObjectSafetyViolation::SupertraitNonLifetimeBinder(..) => {}\n             ObjectSafetyViolation::Method(\n                 name,\n                 MethodViolationCode::StaticMethod(Some((add_self_sugg, make_sized_sugg))),\n@@ -1023,7 +1031,8 @@ impl ObjectSafetyViolation {\n         // diagnostics use a `note` instead of a `span_label`.\n         match self {\n             ObjectSafetyViolation::SupertraitSelf(spans)\n-            | ObjectSafetyViolation::SizedSelf(spans) => spans.clone(),\n+            | ObjectSafetyViolation::SizedSelf(spans)\n+            | ObjectSafetyViolation::SupertraitNonLifetimeBinder(spans) => spans.clone(),\n             ObjectSafetyViolation::AssocConst(_, span)\n             | ObjectSafetyViolation::GAT(_, span)\n             | ObjectSafetyViolation::Method(_, _, span)"}, {"sha": "bcedae233d93d618a31d45eda2c7003a5c96d477", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -4,7 +4,7 @@ use crate::ty::{self, InternalSubsts, ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_macros::HashStable;\n use std::fmt;\n \n@@ -83,7 +83,7 @@ impl<'tcx> Const<'tcx> {\n             None => tcx.mk_const(\n                 ty::UnevaluatedConst {\n                     def: def.to_global(),\n-                    substs: InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n+                    substs: InternalSubsts::identity_for_item(tcx, def.did),\n                 },\n                 ty,\n             ),\n@@ -265,8 +265,8 @@ impl<'tcx> Const<'tcx> {\n     }\n }\n \n-pub fn const_param_default(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Const<'_>> {\n-    let default_def_id = match tcx.hir().get_by_def_id(def_id.expect_local()) {\n+pub fn const_param_default(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Const<'_>> {\n+    let default_def_id = match tcx.hir().get_by_def_id(def_id) {\n         hir::Node::GenericParam(hir::GenericParam {\n             kind: hir::GenericParamKind::Const { default: Some(ac), .. },\n             .."}, {"sha": "653763353987c310bf9a1242603eb34206aeebe6", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -15,6 +15,7 @@ use crate::mir::interpret::{self, Allocation, ConstAllocation};\n use crate::mir::{\n     Body, BorrowCheckResult, Field, Local, Place, PlaceElem, ProjectionKind, Promoted,\n };\n+use crate::query::LocalCrate;\n use crate::thir::Thir;\n use crate::traits;\n use crate::traits::solve;\n@@ -2518,16 +2519,11 @@ pub fn provide(providers: &mut ty::query::Providers) {\n \n     providers.extern_mod_stmt_cnum =\n         |tcx, id| tcx.resolutions(()).extern_crate_map.get(&id).cloned();\n-    providers.is_panic_runtime = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::panic_runtime)\n-    };\n-    providers.is_compiler_builtins = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins)\n-    };\n-    providers.has_panic_handler = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n+    providers.is_panic_runtime =\n+        |tcx, LocalCrate| tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::panic_runtime);\n+    providers.is_compiler_builtins =\n+        |tcx, LocalCrate| tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins);\n+    providers.has_panic_handler = |tcx, LocalCrate| {\n         // We want to check if the panic handler was defined in this crate\n         tcx.lang_items().panic_impl().map_or(false, |did| did.is_local())\n     };"}, {"sha": "6205e2bf24dd11bce80c4617b2c75731e8d442b2", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -51,9 +51,7 @@ where\n // Region folder\n \n impl<'tcx> TyCtxt<'tcx> {\n-    /// Folds the escaping and free regions in `value` using `f`, and\n-    /// sets `skipped_regions` to true if any late-bound region was found\n-    /// and skipped.\n+    /// Folds the escaping and free regions in `value` using `f`.\n     pub fn fold_regions<T>(\n         self,\n         value: T,\n@@ -64,17 +62,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     {\n         value.fold_with(&mut RegionFolder::new(self, &mut f))\n     }\n-\n-    pub fn super_fold_regions<T>(\n-        self,\n-        value: T,\n-        mut f: impl FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx>,\n-    ) -> T\n-    where\n-        T: TypeSuperFoldable<TyCtxt<'tcx>>,\n-    {\n-        value.super_fold_with(&mut RegionFolder::new(self, &mut f))\n-    }\n }\n \n /// Folds over the substructure of a type, visiting its component"}, {"sha": "aa10a651c0711aad0a440a6e08cc0f65a998eba9", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -187,7 +187,11 @@ impl<'tcx> InstanceDef<'tcx> {\n     }\n \n     #[inline]\n-    pub fn get_attrs(&self, tcx: TyCtxt<'tcx>, attr: Symbol) -> ty::Attributes<'tcx> {\n+    pub fn get_attrs(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        attr: Symbol,\n+    ) -> impl Iterator<Item = &'tcx rustc_ast::Attribute> {\n         tcx.get_attrs(self.def_id(), attr)\n     }\n "}, {"sha": "d383a4132081961feff9d1f1ae54593acd9d7e2e", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1128,6 +1128,13 @@ impl<'tcx, T> ToPredicate<'tcx, T> for T {\n     }\n }\n \n+impl<'tcx> ToPredicate<'tcx> for PredicateKind<'tcx> {\n+    #[inline(always)]\n+    fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        ty::Binder::dummy(self).to_predicate(tcx)\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx> for Binder<'tcx, PredicateKind<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n@@ -1142,6 +1149,13 @@ impl<'tcx> ToPredicate<'tcx> for Clause<'tcx> {\n     }\n }\n \n+impl<'tcx> ToPredicate<'tcx> for TraitRef<'tcx> {\n+    #[inline(always)]\n+    fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        ty::Binder::dummy(self).to_predicate(tcx)\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx> for Binder<'tcx, TraitRef<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n@@ -1385,7 +1399,7 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n         // lifetimes with 'static and remapping only those used in the\n         // `impl Trait` return type, resulting in the parameters\n         // shifting.\n-        let id_substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+        let id_substs = InternalSubsts::identity_for_item(tcx, def_id);\n         debug!(?id_substs);\n \n         // This zip may have several times the same lifetime in `substs` paired with a different\n@@ -2027,7 +2041,6 @@ impl<'tcx> FieldDef {\n     }\n }\n \n-pub type Attributes<'tcx> = impl Iterator<Item = &'tcx ast::Attribute>;\n #[derive(Debug, PartialEq, Eq)]\n pub enum ImplOverlapKind {\n     /// These impls are always allowed to overlap.\n@@ -2375,7 +2388,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Gets all attributes with the given name.\n-    pub fn get_attrs(self, did: DefId, attr: Symbol) -> ty::Attributes<'tcx> {\n+    pub fn get_attrs(\n+        self,\n+        did: impl Into<DefId>,\n+        attr: Symbol,\n+    ) -> impl Iterator<Item = &'tcx ast::Attribute> {\n+        let did: DefId = did.into();\n         let filter_fn = move |a: &&ast::Attribute| a.has_name(attr);\n         if let Some(did) = did.as_local() {\n             self.hir().attrs(self.hir().local_def_id_to_hir_id(did)).iter().filter(filter_fn)\n@@ -2386,16 +2404,18 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn get_attr(self, did: DefId, attr: Symbol) -> Option<&'tcx ast::Attribute> {\n+    pub fn get_attr(self, did: impl Into<DefId>, attr: Symbol) -> Option<&'tcx ast::Attribute> {\n         if cfg!(debug_assertions) && !rustc_feature::is_valid_for_get_attr(attr) {\n+            let did: DefId = did.into();\n             bug!(\"get_attr: unexpected called with DefId `{:?}`, attr `{:?}`\", did, attr);\n         } else {\n             self.get_attrs(did, attr).next()\n         }\n     }\n \n     /// Determines whether an item is annotated with an attribute.\n-    pub fn has_attr(self, did: DefId, attr: Symbol) -> bool {\n+    pub fn has_attr(self, did: impl Into<DefId>, attr: Symbol) -> bool {\n+        let did: DefId = did.into();\n         if cfg!(debug_assertions) && !did.is_local() && rustc_feature::is_builtin_only_local(attr) {\n             bug!(\"tried to access the `only_local` attribute `{}` from an extern crate\", attr);\n         } else {"}, {"sha": "30246fe4dbebc8a6404a4b17e3da6caf94e0f698", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -17,7 +17,7 @@ use crate::mir::interpret::{\n };\n use crate::mir::interpret::{LitToConstError, LitToConstInput};\n use crate::mir::mono::CodegenUnit;\n-use crate::query::Key;\n+use crate::query::{AsLocalKey, Key};\n use crate::thir;\n use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n@@ -151,6 +151,20 @@ macro_rules! query_if_arena {\n     };\n }\n \n+/// If `separate_provide_if_extern`, then the key can be projected to its\n+/// local key via `<$K as AsLocalKey>::LocalKey`.\n+macro_rules! local_key_if_separate_extern {\n+    ([] $($K:tt)*) => {\n+        $($K)*\n+    };\n+    ([(separate_provide_extern) $($rest:tt)*] $($K:tt)*) => {\n+        <$($K)* as AsLocalKey>::LocalKey\n+    };\n+    ([$other:tt $($modifiers:tt)*] $($K:tt)*) => {\n+        local_key_if_separate_extern!([$($modifiers)*] $($K)*)\n+    };\n+}\n+\n macro_rules! separate_provide_extern_decl {\n     ([][$name:ident]) => {\n         ()\n@@ -212,6 +226,12 @@ macro_rules! define_callbacks {\n             $(pub type $name<'tcx> = $($K)*;)*\n         }\n         #[allow(nonstandard_style, unused_lifetimes)]\n+        pub mod query_keys_local {\n+            use super::*;\n+\n+            $(pub type $name<'tcx> = local_key_if_separate_extern!([$($modifiers)*] $($K)*);)*\n+        }\n+        #[allow(nonstandard_style, unused_lifetimes)]\n         pub mod query_values {\n             use super::*;\n \n@@ -385,7 +405,7 @@ macro_rules! define_callbacks {\n         pub struct Providers {\n             $(pub $name: for<'tcx> fn(\n                 TyCtxt<'tcx>,\n-                query_keys::$name<'tcx>,\n+                query_keys_local::$name<'tcx>,\n             ) -> query_provided::$name<'tcx>,)*\n         }\n \n@@ -395,17 +415,14 @@ macro_rules! define_callbacks {\n \n         impl Default for Providers {\n             fn default() -> Self {\n-                use crate::query::Key;\n-\n                 Providers {\n                     $($name: |_, key| bug!(\n-                        \"`tcx.{}({:?})` is not supported for {} crate;\\n\\\n+                        \"`tcx.{}({:?})` is not supported for this key;\\n\\\n                         hint: Queries can be either made to the local crate, or the external crate. \\\n                         This error means you tried to use it for one that's not supported.\\n\\\n                         If that's not the case, {} was likely never assigned to a provider function.\\n\",\n                         stringify!($name),\n                         key,\n-                        if key.query_crate_is_local() { \"local\" } else { \"external\" },\n                         stringify!($name),\n                     ),)*\n                 }"}, {"sha": "2a0536a1af72d66e2de2dedb9e14f6ce46f79c13", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -23,7 +23,7 @@ use rustc_macros::HashStable;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n-use rustc_target::spec::abi;\n+use rustc_target::spec::abi::{self, Abi};\n use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::fmt;\n@@ -1403,6 +1403,18 @@ impl<'tcx> PolyFnSig<'tcx> {\n     pub fn abi(&self) -> abi::Abi {\n         self.skip_binder().abi\n     }\n+\n+    pub fn is_fn_trait_compatible(&self) -> bool {\n+        matches!(\n+            self.skip_binder(),\n+            ty::FnSig {\n+                unsafety: rustc_hir::Unsafety::Normal,\n+                abi: Abi::Rust,\n+                c_variadic: false,\n+                ..\n+            }\n+        )\n+    }\n }\n \n pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<'tcx, FnSig<'tcx>>>;"}, {"sha": "f05b873432d29e0ffece15ca6a80a41a17455e08", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -302,8 +302,8 @@ impl<'tcx> InternalSubsts<'tcx> {\n     }\n \n     /// Creates an `InternalSubsts` that maps each generic parameter to itself.\n-    pub fn identity_for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n-        Self::for_item(tcx, def_id, |param, _| tcx.mk_param_from_def(param))\n+    pub fn identity_for_item(tcx: TyCtxt<'tcx>, def_id: impl Into<DefId>) -> SubstsRef<'tcx> {\n+        Self::for_item(tcx, def_id.into(), |param, _| tcx.mk_param_from_def(param))\n     }\n \n     /// Creates an `InternalSubsts` for generic parameter definitions,"}, {"sha": "dcd9743196e1db0977247bd894ce8a5372b6c6a8", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n@@ -1439,8 +1439,7 @@ pub fn reveal_opaque_types_in_bounds<'tcx>(\n }\n \n /// Determines whether an item is annotated with `doc(hidden)`.\n-fn is_doc_hidden(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    assert!(def_id.is_local());\n+fn is_doc_hidden(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     tcx.get_attrs(def_id, sym::doc)\n         .filter_map(|attr| attr.meta_item_list())\n         .any(|items| items.iter().any(|item| item.has_name(sym::hidden)))\n@@ -1454,7 +1453,7 @@ pub fn is_doc_notable_trait(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n }\n \n /// Determines whether an item is an intrinsic by Abi.\n-pub fn is_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+pub fn is_intrinsic(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     matches!(tcx.fn_sig(def_id).skip_binder().abi(), Abi::RustIntrinsic | Abi::PlatformIntrinsic)\n }\n "}, {"sha": "adbd37a7cd9502e0a3877cae4d0abc0aa9d401a2", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -166,6 +166,28 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n                 let cast_kind = mir_cast_kind(source_ty, expr.ty);\n                 Ok(Rvalue::Cast(cast_kind, source, expr.ty))\n             },\n+            ExprKind::Tuple { fields } => Ok(\n+                Rvalue::Aggregate(\n+                    Box::new(AggregateKind::Tuple),\n+                    fields.iter().map(|e| self.parse_operand(*e)).collect::<Result<_, _>>()?\n+                )\n+            ),\n+            ExprKind::Array { fields } => {\n+                let elem_ty = expr.ty.builtin_index().expect(\"ty must be an array\");\n+                Ok(Rvalue::Aggregate(\n+                    Box::new(AggregateKind::Array(elem_ty)),\n+                    fields.iter().map(|e| self.parse_operand(*e)).collect::<Result<_, _>>()?\n+                ))\n+            },\n+            ExprKind::Adt(box AdtExpr{ adt_def, variant_index, substs, fields, .. }) => {\n+                let is_union = adt_def.is_union();\n+                let active_field_index = is_union.then(|| fields[0].name.index());\n+\n+                Ok(Rvalue::Aggregate(\n+                    Box::new(AggregateKind::Adt(adt_def.did(), *variant_index, substs, None, active_field_index)),\n+                    fields.iter().map(|f| self.parse_operand(f.expr)).collect::<Result<_, _>>()?\n+                ))\n+            },\n             _ => self.parse_operand(expr_id).map(Rvalue::Use),\n         )\n     }"}, {"sha": "90d78658f968387b09ba1c54c219e90298e7c9f9", "filename": "compiler/rustc_mir_build/src/build/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -5,7 +5,7 @@ use crate::build::Builder;\n \n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub(crate) fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n         let tcx = self.tcx;\n         let ty = place.ty(&self.local_decls, tcx).ty;\n-        if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, DUMMY_SP) {\n+        if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty) {\n             Operand::Move(place)\n         } else {\n             Operand::Copy(place)"}, {"sha": "8937b78fe34e895f326b5f9ae68cf8e4ea4a243e", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -18,7 +18,7 @@ pub(crate) fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n         let trait_substs = match tcx.trait_of_item(def_id.to_def_id()) {\n             Some(trait_def_id) => {\n                 let trait_substs_count = tcx.generics_of(trait_def_id).count();\n-                &InternalSubsts::identity_for_item(tcx, def_id.to_def_id())[..trait_substs_count]\n+                &InternalSubsts::identity_for_item(tcx, def_id)[..trait_substs_count]\n             }\n             _ => &[],\n         };"}, {"sha": "274c2f06137a33a8c9b9f32cbfff709274b48b6c", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,14 +1,14 @@\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::traits::Obligation;\n use rustc_middle::mir::{self, Field};\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_span::Span;\n-use rustc_trait_selection::traits::predicate_for_trait_def;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n-use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligation};\n+use rustc_trait_selection::traits::{self, ObligationCause};\n \n use std::cell::Cell;\n \n@@ -189,17 +189,15 @@ impl<'tcx> ConstToPat<'tcx> {\n         // using `PartialEq::eq` in this scenario in the past.)\n         let partial_eq_trait_id =\n             self.tcx().require_lang_item(hir::LangItem::PartialEq, Some(self.span));\n-        let obligation: PredicateObligation<'_> = predicate_for_trait_def(\n+        let partial_eq_obligation = Obligation::new(\n             self.tcx(),\n+            ObligationCause::dummy(),\n             self.param_env,\n-            ObligationCause::misc(self.span, self.id.owner.def_id),\n-            partial_eq_trait_id,\n-            0,\n-            [ty, ty],\n+            self.tcx().mk_trait_ref(partial_eq_trait_id, [ty, ty]),\n         );\n-        // FIXME: should this call a `predicate_must_hold` variant instead?\n \n-        let has_impl = self.infcx.predicate_may_hold(&obligation);\n+        // FIXME: should this call a `predicate_must_hold` variant instead?\n+        let has_impl = self.infcx.predicate_may_hold(&partial_eq_obligation);\n \n         // Note: To fix rust-lang/rust#65466, we could just remove this type\n         // walk hack for function pointers, and unconditionally error"}, {"sha": "bebd9723740f8106605b050bef334df6ab02677d", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -4,6 +4,7 @@\n use either::Right;\n \n use rustc_const_eval::const_eval::CheckAlignment;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n@@ -151,12 +152,17 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n pub struct ConstPropMachine<'mir, 'tcx> {\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx>>,\n+    pub written_only_inside_own_block_locals: FxHashSet<Local>,\n     pub can_const_prop: IndexVec<Local, ConstPropMode>,\n }\n \n impl ConstPropMachine<'_, '_> {\n     pub fn new(can_const_prop: IndexVec<Local, ConstPropMode>) -> Self {\n-        Self { stack: Vec::new(), can_const_prop }\n+        Self {\n+            stack: Vec::new(),\n+            written_only_inside_own_block_locals: Default::default(),\n+            can_const_prop,\n+        }\n     }\n }\n \n@@ -249,7 +255,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n                     \"tried to write to a local that is marked as not propagatable\"\n                 )\n             }\n-            ConstPropMode::OnlyInsideOwnBlock | ConstPropMode::FullConstProp => {}\n+            ConstPropMode::OnlyInsideOwnBlock => {\n+                ecx.machine.written_only_inside_own_block_locals.insert(local);\n+            }\n+            ConstPropMode::FullConstProp => {}\n         }\n         ecx.machine.stack[frame].locals[local].access_mut()\n     }\n@@ -416,6 +425,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn remove_const(ecx: &mut InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>, local: Local) {\n         ecx.frame_mut().locals[local].value =\n             LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit));\n+        ecx.machine.written_only_inside_own_block_locals.remove(&local);\n     }\n \n     /// Returns the value, if any, of evaluating `c`.\n@@ -693,7 +703,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn ensure_not_propagated(&mut self, local: Local) {\n+    fn ensure_not_propagated(&self, local: Local) {\n         if cfg!(debug_assertions) {\n             assert!(\n                 self.get_const(local.into()).is_none()\n@@ -963,17 +973,31 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         // We remove all Locals which are restricted in propagation to their containing blocks and\n         // which were modified in the current block.\n         // Take it out of the ecx so we can get a mutable reference to the ecx for `remove_const`.\n-        let can_const_prop = std::mem::take(&mut self.ecx.machine.can_const_prop);\n-        for (local, &mode) in can_const_prop.iter_enumerated() {\n-            match mode {\n-                ConstPropMode::FullConstProp => {}\n-                ConstPropMode::NoPropagation => self.ensure_not_propagated(local),\n-                ConstPropMode::OnlyInsideOwnBlock => {\n-                    Self::remove_const(&mut self.ecx, local);\n-                    self.ensure_not_propagated(local);\n+        let mut written_only_inside_own_block_locals =\n+            std::mem::take(&mut self.ecx.machine.written_only_inside_own_block_locals);\n+\n+        // This loop can get very hot for some bodies: it check each local in each bb.\n+        // To avoid this quadratic behaviour, we only clear the locals that were modified inside\n+        // the current block.\n+        for local in written_only_inside_own_block_locals.drain() {\n+            debug_assert_eq!(\n+                self.ecx.machine.can_const_prop[local],\n+                ConstPropMode::OnlyInsideOwnBlock\n+            );\n+            Self::remove_const(&mut self.ecx, local);\n+        }\n+        self.ecx.machine.written_only_inside_own_block_locals =\n+            written_only_inside_own_block_locals;\n+\n+        if cfg!(debug_assertions) {\n+            for (local, &mode) in self.ecx.machine.can_const_prop.iter_enumerated() {\n+                match mode {\n+                    ConstPropMode::FullConstProp => {}\n+                    ConstPropMode::NoPropagation | ConstPropMode::OnlyInsideOwnBlock => {\n+                        self.ensure_not_propagated(local);\n+                    }\n                 }\n             }\n         }\n-        self.ecx.machine.can_const_prop = can_const_prop;\n     }\n }"}, {"sha": "45bd98f39d2ba9a433488116d612235b46d0ceda", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -247,6 +247,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn remove_const(ecx: &mut InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>, local: Local) {\n         ecx.frame_mut().locals[local].value =\n             LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit));\n+        ecx.machine.written_only_inside_own_block_locals.remove(&local);\n     }\n \n     fn lint_root(&self, source_info: SourceInfo) -> Option<HirId> {\n@@ -484,7 +485,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Some(())\n     }\n \n-    fn ensure_not_propagated(&mut self, local: Local) {\n+    fn ensure_not_propagated(&self, local: Local) {\n         if cfg!(debug_assertions) {\n             assert!(\n                 self.get_const(local.into()).is_none()\n@@ -691,17 +692,31 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         // We remove all Locals which are restricted in propagation to their containing blocks and\n         // which were modified in the current block.\n         // Take it out of the ecx so we can get a mutable reference to the ecx for `remove_const`.\n-        let can_const_prop = std::mem::take(&mut self.ecx.machine.can_const_prop);\n-        for (local, &mode) in can_const_prop.iter_enumerated() {\n-            match mode {\n-                ConstPropMode::FullConstProp => {}\n-                ConstPropMode::NoPropagation => self.ensure_not_propagated(local),\n-                ConstPropMode::OnlyInsideOwnBlock => {\n-                    Self::remove_const(&mut self.ecx, local);\n-                    self.ensure_not_propagated(local);\n+        let mut written_only_inside_own_block_locals =\n+            std::mem::take(&mut self.ecx.machine.written_only_inside_own_block_locals);\n+\n+        // This loop can get very hot for some bodies: it check each local in each bb.\n+        // To avoid this quadratic behaviour, we only clear the locals that were modified inside\n+        // the current block.\n+        for local in written_only_inside_own_block_locals.drain() {\n+            debug_assert_eq!(\n+                self.ecx.machine.can_const_prop[local],\n+                ConstPropMode::OnlyInsideOwnBlock\n+            );\n+            Self::remove_const(&mut self.ecx, local);\n+        }\n+        self.ecx.machine.written_only_inside_own_block_locals =\n+            written_only_inside_own_block_locals;\n+\n+        if cfg!(debug_assertions) {\n+            for (local, &mode) in self.ecx.machine.can_const_prop.iter_enumerated() {\n+                match mode {\n+                    ConstPropMode::FullConstProp => {}\n+                    ConstPropMode::NoPropagation | ConstPropMode::OnlyInsideOwnBlock => {\n+                        self.ensure_not_propagated(local);\n+                    }\n                 }\n             }\n         }\n-        self.ecx.machine.can_const_prop = can_const_prop;\n     }\n }"}, {"sha": "e5c3fa5646a737db238ece801f5513300d49a02c", "filename": "compiler/rustc_mir_transform/src/deduce_param_attrs.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -5,7 +5,7 @@\n //! purposes on a best-effort basis. We compute them here and store them into the crate metadata so\n //! dependent crates can use them.\n \n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location, Operand, Terminator, TerminatorKind, RETURN_PLACE};\n@@ -149,7 +149,10 @@ fn type_will_always_be_passed_directly(ty: Ty<'_>) -> bool {\n /// body of the function instead of just the signature. These can be useful for optimization\n /// purposes on a best-effort basis. We compute them here and store them into the crate metadata so\n /// dependent crates can use them.\n-pub fn deduced_param_attrs<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [DeducedParamAttrs] {\n+pub fn deduced_param_attrs<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+) -> &'tcx [DeducedParamAttrs] {\n     // This computation is unfortunately rather expensive, so don't do it unless we're optimizing.\n     // Also skip it in incremental mode.\n     if tcx.sess.opts.optimize == OptLevel::No || tcx.sess.opts.incremental.is_some() {\n@@ -182,10 +185,6 @@ pub fn deduced_param_attrs<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [Ded\n         return &[];\n     }\n \n-    // Deduced attributes for other crates should be read from the metadata instead of via this\n-    // function.\n-    debug_assert!(def_id.is_local());\n-\n     // Grab the optimized MIR. Analyze it to determine which arguments have been mutated.\n     let body: &Body<'tcx> = tcx.optimized_mir(def_id);\n     let mut deduce_read_only = DeduceReadOnly::new(body.arg_count);"}, {"sha": "c9b24adba0ca817384c337d6f65eea828d9cfbb5", "filename": "compiler/rustc_mir_transform/src/ffi_unwind_calls.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,5 +1,6 @@\n-use rustc_hir::def_id::{CrateNum, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n use rustc_middle::mir::*;\n+use rustc_middle::query::LocalCrate;\n use rustc_middle::ty::layout;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n@@ -121,9 +122,7 @@ fn has_ffi_unwind_calls(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> bool {\n     tainted\n }\n \n-fn required_panic_strategy(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<PanicStrategy> {\n-    assert_eq!(cnum, LOCAL_CRATE);\n-\n+fn required_panic_strategy(tcx: TyCtxt<'_>, _: LocalCrate) -> Option<PanicStrategy> {\n     if tcx.is_panic_runtime(LOCAL_CRATE) {\n         return Some(tcx.sess.panic_strategy());\n     }"}, {"sha": "8a6360114dc5489c4abf1dbee285c3587754442c", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -70,7 +70,7 @@ use rustc_mir_dataflow::impls::{\n };\n use rustc_mir_dataflow::storage::always_storage_live_locals;\n use rustc_mir_dataflow::{self, Analysis};\n-use rustc_span::def_id::DefId;\n+use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n@@ -1386,10 +1386,9 @@ fn create_cases<'tcx>(\n #[instrument(level = \"debug\", skip(tcx), ret)]\n pub(crate) fn mir_generator_witnesses<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n ) -> GeneratorLayout<'tcx> {\n     assert!(tcx.sess.opts.unstable_opts.drop_tracking_mir);\n-    let def_id = def_id.expect_local();\n \n     let (body, _) = tcx.mir_promoted(ty::WithOptConstParam::unknown(def_id));\n     let body = body.borrow();"}, {"sha": "3a515fe8323e9ddafd031b10f8698f9b94bc7863", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -112,7 +112,6 @@ pub fn provide(providers: &mut Providers) {\n         mir_keys,\n         mir_const,\n         mir_const_qualif: |tcx, def_id| {\n-            let def_id = def_id.expect_local();\n             if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n                 tcx.mir_const_qualif_const_arg(def)\n             } else {\n@@ -133,7 +132,6 @@ pub fn provide(providers: &mut Providers) {\n         mir_callgraph_reachable: inline::cycle::mir_callgraph_reachable,\n         mir_inliner_callees: inline::cycle::mir_inliner_callees,\n         promoted_mir: |tcx, def_id| {\n-            let def_id = def_id.expect_local();\n             if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n                 tcx.promoted_mir_of_const_arg(def)\n             } else {\n@@ -206,8 +204,7 @@ fn remap_mir_for_const_eval_select<'tcx>(\n     body\n }\n \n-fn is_mir_available(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    let def_id = def_id.expect_local();\n+fn is_mir_available(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     tcx.mir_keys(()).contains(&def_id)\n }\n \n@@ -350,12 +347,11 @@ fn mir_promoted(\n }\n \n /// Compute the MIR that is used during CTFE (and thus has no optimizations run on it)\n-fn mir_for_ctfe(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n-    let did = def_id.expect_local();\n-    if let Some(def) = ty::WithOptConstParam::try_lookup(did, tcx) {\n+fn mir_for_ctfe(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &Body<'_> {\n+    if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n         tcx.mir_for_ctfe_of_const_arg(def)\n     } else {\n-        tcx.arena.alloc(inner_mir_for_ctfe(tcx, ty::WithOptConstParam::unknown(did)))\n+        tcx.arena.alloc(inner_mir_for_ctfe(tcx, ty::WithOptConstParam::unknown(def_id)))\n     }\n }\n \n@@ -599,8 +595,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n }\n \n /// Optimize the MIR and prepare it for codegen.\n-fn optimized_mir(tcx: TyCtxt<'_>, did: DefId) -> &Body<'_> {\n-    let did = did.expect_local();\n+fn optimized_mir(tcx: TyCtxt<'_>, did: LocalDefId) -> &Body<'_> {\n     assert_eq!(ty::WithOptConstParam::try_lookup(did, tcx), None);\n     tcx.arena.alloc(inner_optimized_mir(tcx, did))\n }"}, {"sha": "c4605e63cf39f0f99f63a06b4956e7baa3be316e", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1843,20 +1843,14 @@ impl<'a> Parser<'a> {\n         &mut self,\n         mk_lit_char: impl FnOnce(Symbol, Span) -> L,\n     ) -> PResult<'a, L> {\n-        if let token::Interpolated(inner) = &self.token.kind {\n-            let expr = match inner.as_ref() {\n-                token::NtExpr(expr) => Some(expr),\n-                token::NtLiteral(expr) => Some(expr),\n-                _ => None,\n-            };\n-            if let Some(expr) = expr {\n-                if matches!(expr.kind, ExprKind::Err) {\n-                    let mut err = errors::InvalidInterpolatedExpression { span: self.token.span }\n-                        .into_diagnostic(&self.sess.span_diagnostic);\n-                    err.downgrade_to_delayed_bug();\n-                    return Err(err);\n-                }\n-            }\n+        if let token::Interpolated(nt) = &self.token.kind\n+            && let token::NtExpr(e) | token::NtLiteral(e) = &**nt\n+            && matches!(e.kind, ExprKind::Err)\n+        {\n+            let mut err = errors::InvalidInterpolatedExpression { span: self.token.span }\n+                .into_diagnostic(&self.sess.span_diagnostic);\n+            err.downgrade_to_delayed_bug();\n+            return Err(err);\n         }\n         let token = self.token.clone();\n         let err = |self_: &Self| {"}, {"sha": "30dd3e4d016996a30c0e4ad621bfe60e456b4740", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -104,9 +104,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n \n             // If this crate is not using stability attributes, or this function is not claiming to be a\n             // stable `const fn`, that is all that is required.\n-            if !tcx.features().staged_api\n-                || tcx.has_attr(def_id.to_def_id(), sym::rustc_const_unstable)\n-            {\n+            if !tcx.features().staged_api || tcx.has_attr(def_id, sym::rustc_const_unstable) {\n                 return true;\n             }\n "}, {"sha": "75ce446e6b44faf1591e191b7c31c2237755b9be", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -469,9 +469,9 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n \n fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     fn has_lang_attr(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n-        tcx.has_attr(def_id.to_def_id(), sym::lang)\n+        tcx.has_attr(def_id, sym::lang)\n             // Stable attribute for #[lang = \"panic_impl\"]\n-            || tcx.has_attr(def_id.to_def_id(), sym::panic_handler)\n+            || tcx.has_attr(def_id, sym::panic_handler)\n     }\n \n     fn has_allow_dead_code(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {"}, {"sha": "9dd39a5c9fe069be3964aa5a1bda1aa144ec9b23", "filename": "compiler/rustc_passes/src/debugger_visualizer.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -4,11 +4,9 @@ use hir::CRATE_HIR_ID;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::resolve_path;\n use rustc_hir as hir;\n-use rustc_hir::def_id::CrateNum;\n use rustc_hir::HirId;\n-use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::def_id::LOCAL_CRATE;\n+use rustc_middle::{query::LocalCrate, ty::query::Providers};\n use rustc_span::{sym, DebuggerVisualizerFile, DebuggerVisualizerType};\n \n use std::sync::Arc;\n@@ -69,9 +67,7 @@ fn check_for_debugger_visualizer(\n }\n \n /// Traverses and collects the debugger visualizers for a specific crate.\n-fn debugger_visualizers(tcx: TyCtxt<'_>, cnum: CrateNum) -> Vec<DebuggerVisualizerFile> {\n-    assert_eq!(cnum, LOCAL_CRATE);\n-\n+fn debugger_visualizers(tcx: TyCtxt<'_>, _: LocalCrate) -> Vec<DebuggerVisualizerFile> {\n     // Initialize the collector.\n     let mut debugger_visualizers = FxHashSet::default();\n "}, {"sha": "eb6ea673c85d4cffe11930dfa792e2414ff61944", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -12,9 +12,10 @@\n use rustc_ast as ast;\n use rustc_hir::diagnostic_items::DiagnosticItems;\n use rustc_hir::OwnerId;\n+use rustc_middle::query::LocalCrate;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_span::def_id::{DefId, LOCAL_CRATE};\n use rustc_span::symbol::{sym, Symbol};\n \n use crate::errors::DuplicateDiagnosticItemInCrate;\n@@ -62,9 +63,7 @@ fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n }\n \n /// Traverse and collect the diagnostic items in the current\n-fn diagnostic_items(tcx: TyCtxt<'_>, cnum: CrateNum) -> DiagnosticItems {\n-    assert_eq!(cnum, LOCAL_CRATE);\n-\n+fn diagnostic_items(tcx: TyCtxt<'_>, _: LocalCrate) -> DiagnosticItems {\n     // Initialize the collector.\n     let mut diagnostic_items = DiagnosticItems::default();\n "}, {"sha": "5a1ae808e661a937d708b8e484d3f911ae36edfc", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -18,7 +18,7 @@ pub fn test_layout(tcx: TyCtxt<'_>) {\n                 tcx.def_kind(id.owner_id),\n                 DefKind::TyAlias | DefKind::Enum | DefKind::Struct | DefKind::Union\n             ) {\n-                for attr in tcx.get_attrs(id.owner_id.to_def_id(), sym::rustc_layout) {\n+                for attr in tcx.get_attrs(id.owner_id, sym::rustc_layout) {\n                     dump_layout_of(tcx, id.owner_id.def_id, attr);\n                 }\n             }"}, {"sha": "a8471ce3b6fb2c6fac7aa6c5aadf085b7afce6a3", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -146,7 +146,7 @@ fn check_liveness(tcx: TyCtxt<'_>, def_id: DefId) {\n     // Don't run unused pass for #[derive()]\n     let parent = tcx.local_parent(local_def_id);\n     if let DefKind::Impl { .. } = tcx.def_kind(parent)\n-        && tcx.has_attr(parent.to_def_id(), sym::automatically_derived)\n+        && tcx.has_attr(parent, sym::automatically_derived)\n     {\n         return;\n     }"}, {"sha": "c398467f03ef825097f509007274b6916b404c42", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -30,7 +30,7 @@ fn check_mod_naked_functions(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n             continue;\n         }\n \n-        let naked = tcx.has_attr(def_id.to_def_id(), sym::naked);\n+        let naked = tcx.has_attr(def_id, sym::naked);\n         if !naked {\n             continue;\n         }\n@@ -59,7 +59,7 @@ fn check_mod_naked_functions(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n \n /// Check that the function isn't inlined.\n fn check_inline(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let attrs = tcx.get_attrs(def_id.to_def_id(), sym::inline);\n+    let attrs = tcx.get_attrs(def_id, sym::inline);\n     for attr in attrs {\n         tcx.sess.emit_err(CannotInlineNakedFunction { span: attr.span });\n     }"}, {"sha": "6d0cfea00d1fdf4e04f50e73cc84768e5e4acba1", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -691,14 +691,10 @@ pub(crate) fn provide(providers: &mut Providers) {\n         check_mod_unstable_api_usage,\n         stability_index,\n         stability_implications: |tcx, _| tcx.stability().implications.clone(),\n-        lookup_stability: |tcx, id| tcx.stability().local_stability(id.expect_local()),\n-        lookup_const_stability: |tcx, id| tcx.stability().local_const_stability(id.expect_local()),\n-        lookup_default_body_stability: |tcx, id| {\n-            tcx.stability().local_default_body_stability(id.expect_local())\n-        },\n-        lookup_deprecation_entry: |tcx, id| {\n-            tcx.stability().local_deprecation_entry(id.expect_local())\n-        },\n+        lookup_stability: |tcx, id| tcx.stability().local_stability(id),\n+        lookup_const_stability: |tcx, id| tcx.stability().local_const_stability(id),\n+        lookup_default_body_stability: |tcx, id| tcx.stability().local_default_body_stability(id),\n+        lookup_deprecation_entry: |tcx, id| tcx.stability().local_deprecation_entry(id),\n         ..*providers\n     };\n }"}, {"sha": "d884ebd9acc73b9154e0ea7f03beca7681a8b552", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -920,7 +920,7 @@ pub struct TestReachabilityVisitor<'tcx, 'a> {\n \n impl<'tcx, 'a> TestReachabilityVisitor<'tcx, 'a> {\n     fn effective_visibility_diagnostic(&mut self, def_id: LocalDefId) {\n-        if self.tcx.has_attr(def_id.to_def_id(), sym::rustc_effective_visibility) {\n+        if self.tcx.has_attr(def_id, sym::rustc_effective_visibility) {\n             let mut error_msg = String::new();\n             let span = self.tcx.def_span(def_id.to_def_id());\n             if let Some(effective_vis) = self.effective_visibilities.effective_vis(def_id) {\n@@ -2060,8 +2060,8 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-fn visibility(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Visibility<DefId> {\n-    local_visibility(tcx, def_id.expect_local()).to_def_id()\n+fn visibility(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Visibility<DefId> {\n+    local_visibility(tcx, def_id).to_def_id()\n }\n \n fn local_visibility(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Visibility {"}, {"sha": "4cd9423706104807b3be3a7dc607ce41460509c2", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -20,7 +20,7 @@ extern crate rustc_middle;\n use rustc_data_structures::sync::AtomicU64;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::{self, DepKindStruct};\n-use rustc_middle::query::Key;\n+use rustc_middle::query::AsLocalKey;\n use rustc_middle::ty::query::{\n     query_keys, query_provided, query_provided_to_value, query_storage, query_values,\n };"}, {"sha": "9bba26cc8e846359d64249377ccc644e9c1f27c1", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -274,19 +274,19 @@ macro_rules! hash_result {\n     };\n }\n \n-macro_rules! get_provider {\n-    ([][$tcx:expr, $name:ident, $key:expr]) => {{\n-        $tcx.queries.local_providers.$name\n+macro_rules! call_provider {\n+    ([][$qcx:expr, $name:ident, $key:expr]) => {{\n+        ($qcx.queries.local_providers.$name)($qcx.tcx, $key)\n     }};\n-    ([(separate_provide_extern) $($rest:tt)*][$tcx:expr, $name:ident, $key:expr]) => {{\n-        if $key.query_crate_is_local() {\n-            $tcx.queries.local_providers.$name\n+    ([(separate_provide_extern) $($rest:tt)*][$qcx:expr, $name:ident, $key:expr]) => {{\n+        if let Some(key) = $key.as_local_key() {\n+            ($qcx.queries.local_providers.$name)($qcx.tcx, key)\n         } else {\n-            $tcx.queries.extern_providers.$name\n+            ($qcx.queries.extern_providers.$name)($qcx.tcx, $key)\n         }\n     }};\n     ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n-        get_provider!([$($modifiers)*][$($args)*])\n+        call_provider!([$($modifiers)*][$($args)*])\n     };\n }\n \n@@ -516,7 +516,7 @@ macro_rules! define_queries {\n             fn compute(self, qcx: QueryCtxt<'tcx>, key: Self::Key) -> Self::Value {\n                 query_provided_to_value::$name(\n                     qcx.tcx,\n-                    get_provider!([$($modifiers)*][qcx, $name, key])(qcx.tcx, key)\n+                    call_provider!([$($modifiers)*][qcx, $name, key])\n                 )\n             }\n "}, {"sha": "4d4bc1be34973b241a0282fa75a1e184ebc798dd", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -423,13 +423,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n     pub(crate) fn resolve_imports(&mut self) {\n-        let mut prev_num_indeterminates = self.indeterminate_imports.len() + 1;\n-        while self.indeterminate_imports.len() < prev_num_indeterminates {\n-            prev_num_indeterminates = self.indeterminate_imports.len();\n+        let mut prev_indeterminate_count = usize::MAX;\n+        let mut indeterminate_count = self.indeterminate_imports.len() * 3;\n+        while indeterminate_count < prev_indeterminate_count {\n+            prev_indeterminate_count = indeterminate_count;\n+            indeterminate_count = 0;\n             for import in mem::take(&mut self.indeterminate_imports) {\n-                match self.resolve_import(&import) {\n-                    true => self.determined_imports.push(import),\n-                    false => self.indeterminate_imports.push(import),\n+                let import_indeterminate_count = self.resolve_import(&import);\n+                indeterminate_count += import_indeterminate_count;\n+                match import_indeterminate_count {\n+                    0 => self.determined_imports.push(import),\n+                    _ => self.indeterminate_imports.push(import),\n                 }\n             }\n         }\n@@ -581,9 +585,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         diag.emit();\n     }\n \n-    /// Attempts to resolve the given import, returning true if its resolution is determined.\n-    /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import(&mut self, import: &'a Import<'a>) -> bool {\n+    /// Attempts to resolve the given import, returning:\n+    /// - `0` means its resolution is determined.\n+    /// - Other values mean that indeterminate exists under certain namespaces.\n+    ///\n+    /// Meanwhile, if resolve successful, the resolved bindings are written\n+    /// into the module.\n+    fn resolve_import(&mut self, import: &'a Import<'a>) -> usize {\n         debug!(\n             \"(resolving import for module) resolving import `{}::...` in `{}`\",\n             Segment::names_to_string(&import.module_path),\n@@ -601,8 +609,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             match path_res {\n                 PathResult::Module(module) => module,\n-                PathResult::Indeterminate => return false,\n-                PathResult::NonModule(..) | PathResult::Failed { .. } => return true,\n+                PathResult::Indeterminate => return 3,\n+                PathResult::NonModule(..) | PathResult::Failed { .. } => return 0,\n             }\n         };\n \n@@ -618,12 +626,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } => (source, target, source_bindings, target_bindings, type_ns_only),\n             ImportKind::Glob { .. } => {\n                 self.resolve_glob_import(import);\n-                return true;\n+                return 0;\n             }\n             _ => unreachable!(),\n         };\n \n-        let mut indeterminate = false;\n+        let mut indeterminate_count = 0;\n         self.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n                 if let Err(Undetermined) = source_bindings[ns].get() {\n@@ -646,7 +654,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 let parent = import.parent_scope.module;\n                 match source_bindings[ns].get() {\n-                    Err(Undetermined) => indeterminate = true,\n+                    Err(Undetermined) => indeterminate_count += 1,\n                     // Don't update the resolution, because it was never added.\n                     Err(Determined) if target.name == kw::Underscore => {}\n                     Ok(binding) if binding.is_importable() => {\n@@ -670,7 +678,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         });\n \n-        !indeterminate\n+        indeterminate_count\n     }\n \n     /// Performs final import resolution, consistency checks and error reporting."}, {"sha": "b4d5b7f3621c8556011f0fe0d7f9c472c4e1fce2", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -53,7 +53,7 @@ impl SymbolNamesTest<'_> {\n         // The formatting of `tag({})` is chosen so that tests can elect\n         // to test the entirety of the string, if they choose, or else just\n         // some subset.\n-        for attr in tcx.get_attrs(def_id.to_def_id(), SYMBOL_NAME) {\n+        for attr in tcx.get_attrs(def_id, SYMBOL_NAME) {\n             let def_id = def_id.to_def_id();\n             let instance = Instance::new(\n                 def_id,\n@@ -79,7 +79,7 @@ impl SymbolNamesTest<'_> {\n             }\n         }\n \n-        for attr in tcx.get_attrs(def_id.to_def_id(), DEF_PATH) {\n+        for attr in tcx.get_attrs(def_id, DEF_PATH) {\n             tcx.sess.emit_err(TestOutput {\n                 span: attr.span,\n                 kind: Kind::DefPath,"}, {"sha": "911cc0b88c406f6789f4630894d7a270a7fdb524", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -8,26 +8,16 @@ use rustc_middle::infer::canonical::{Canonical, CanonicalQueryResponse, QueryRes\n use rustc_middle::traits::query::Fallible;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitableExt};\n use rustc_middle::ty::{GenericArg, ToPredicate};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::DUMMY_SP;\n \n use std::fmt::Debug;\n \n pub use rustc_infer::infer::*;\n \n pub trait InferCtxtExt<'tcx> {\n-    fn type_is_copy_modulo_regions(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> bool;\n+    fn type_is_copy_modulo_regions(&self, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool;\n \n-    fn type_is_sized_modulo_regions(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> bool;\n+    fn type_is_sized_modulo_regions(&self, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool;\n \n     /// Check whether a `ty` implements given trait(trait_def_id).\n     /// The inputs are:\n@@ -46,13 +36,9 @@ pub trait InferCtxtExt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> traits::EvaluationResult;\n }\n+\n impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n-    fn type_is_copy_modulo_regions(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> bool {\n+    fn type_is_copy_modulo_regions(&self, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n         let ty = self.resolve_vars_if_possible(ty);\n \n         if !(param_env, ty).needs_infer() {\n@@ -65,17 +51,12 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // rightly refuses to work with inference variables, but\n         // moves_by_default has a cache, which we want to use in other\n         // cases.\n-        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, copy_def_id, span)\n+        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, copy_def_id)\n     }\n \n-    fn type_is_sized_modulo_regions(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> bool {\n+    fn type_is_sized_modulo_regions(&self, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n         let lang_item = self.tcx.require_lang_item(LangItem::Sized, None);\n-        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, lang_item, span)\n+        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, lang_item)\n     }\n \n     #[instrument(level = \"debug\", skip(self, params), ret)]"}, {"sha": "76cde1a669225247c8d2077e6f988a7b0facb7a9", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -224,7 +224,9 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         if goal.predicate.self_ty().is_ty_var() {\n             return vec![Candidate {\n                 source: CandidateSource::BuiltinImpl,\n-                result: self.make_canonical_response(Certainty::AMBIGUOUS).unwrap(),\n+                result: self\n+                    .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                    .unwrap(),\n             }];\n         }\n \n@@ -261,37 +263,26 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n             return\n         };\n-        self.probe(|this| {\n-            let normalized_ty = this.next_ty_infer();\n+\n+        self.probe(|ecx| {\n+            let normalized_ty = ecx.next_ty_infer();\n             let normalizes_to_goal = goal.with(\n                 tcx,\n                 ty::Binder::dummy(ty::ProjectionPredicate {\n                     projection_ty,\n                     term: normalized_ty.into(),\n                 }),\n             );\n-            let normalization_certainty = match this.evaluate_goal(normalizes_to_goal) {\n-                Ok((_, certainty)) => certainty,\n-                Err(NoSolution) => return,\n-            };\n-            let normalized_ty = this.resolve_vars_if_possible(normalized_ty);\n-\n-            // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n-            // This doesn't work as long as we use `CandidateSource` in winnowing.\n-            let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-            let normalized_candidates = this.assemble_and_evaluate_candidates(goal);\n-            for mut normalized_candidate in normalized_candidates {\n-                normalized_candidate.result =\n-                    normalized_candidate.result.unchecked_map(|mut response| {\n-                        // FIXME: This currently hides overflow in the normalization step of the self type\n-                        // which is probably wrong. Maybe `unify_and` should actually keep overflow as\n-                        // we treat it as non-fatal anyways.\n-                        response.certainty = response.certainty.unify_and(normalization_certainty);\n-                        response\n-                    });\n-                candidates.push(normalized_candidate);\n+            ecx.add_goal(normalizes_to_goal);\n+            if let Ok(_) = ecx.try_evaluate_added_goals() {\n+                let normalized_ty = ecx.resolve_vars_if_possible(normalized_ty);\n+\n+                // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n+                // This doesn't work as long as we use `CandidateSource` in winnowing.\n+                let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n+                candidates.extend(ecx.assemble_and_evaluate_candidates(goal));\n             }\n-        })\n+        });\n     }\n \n     fn assemble_impl_candidates<G: GoalKind<'tcx>>(\n@@ -516,7 +507,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 } else {\n                     Certainty::AMBIGUOUS\n                 };\n-                return self.make_canonical_response(certainty);\n+                return self.evaluate_added_goals_and_make_canonical_response(certainty);\n             }\n         }\n \n@@ -538,14 +529,16 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n-    fn discard_reservation_impl(&self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n+    fn discard_reservation_impl(&mut self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n         if let CandidateSource::Impl(def_id) = candidate.source {\n             if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n                 debug!(\"Selected reservation impl\");\n                 // We assemble all candidates inside of a probe so by\n                 // making a new canonical response here our result will\n                 // have no constraints.\n-                candidate.result = self.make_canonical_response(Certainty::AMBIGUOUS).unwrap();\n+                candidate.result = self\n+                    .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                    .unwrap();\n             }\n         }\n "}, {"sha": "9d45e78ebab044b9d2d12e11ae2333cc1dafaf64", "filename": "compiler/rustc_trait_selection/src/solve/canonical/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -48,7 +48,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     /// - `external_constraints`: additional constraints which aren't expressable\n     ///   using simple unification of inference variables.\n     #[instrument(level = \"debug\", skip(self))]\n-    pub(super) fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n+    pub(super) fn evaluate_added_goals_and_make_canonical_response(\n+        &mut self,\n+        certainty: Certainty,\n+    ) -> QueryResult<'tcx> {\n+        let goals_certainty = self.try_evaluate_added_goals()?;\n+        let certainty = certainty.unify_and(goals_certainty);\n+\n         let external_constraints = self.compute_external_query_constraints()?;\n \n         let response = Response { var_values: self.var_values, external_constraints, certainty };\n@@ -209,7 +215,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             // FIXME: To deal with #105787 I also expect us to emit nested obligations here at\n             // some point. We can figure out how to deal with this once we actually have\n             // an ICE.\n-            let nested_goals = self.eq(param_env, orig, response)?;\n+            let nested_goals = self.eq_and_get_goals(param_env, orig, response)?;\n             assert!(nested_goals.is_empty(), \"{nested_goals:?}\");\n         }\n "}, {"sha": "9541292235795a2d8a4b7e9b72adeefe217fbe79", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 334, "deletions": 7, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -2,8 +2,11 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use rustc_infer::infer::{\n+    DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime, TyCtxtInferExt,\n+};\n use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::{\n@@ -13,8 +16,8 @@ use rustc_middle::ty::{\n use rustc_span::DUMMY_SP;\n use std::ops::ControlFlow;\n \n-use super::search_graph::SearchGraph;\n-use super::Goal;\n+use super::search_graph::{self, OverflowHandler};\n+use super::{search_graph::SearchGraph, Goal};\n \n pub struct EvalCtxt<'a, 'tcx> {\n     // FIXME: should be private.\n@@ -33,14 +36,305 @@ pub struct EvalCtxt<'a, 'tcx> {\n \n     pub(super) search_graph: &'a mut SearchGraph<'tcx>,\n \n-    /// This field is used by a debug assertion in [`EvalCtxt::evaluate_goal`],\n-    /// see the comment in that method for more details.\n-    pub in_projection_eq_hack: bool,\n+    pub(super) nested_goals: NestedGoals<'tcx>,\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub(super) enum IsNormalizesToHack {\n+    Yes,\n+    No,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub(super) struct NestedGoals<'tcx> {\n+    pub(super) normalizes_to_hack_goal: Option<Goal<'tcx, ty::ProjectionPredicate<'tcx>>>,\n+    pub(super) goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n+}\n+\n+impl NestedGoals<'_> {\n+    pub(super) fn new() -> Self {\n+        Self { normalizes_to_hack_goal: None, goals: Vec::new() }\n+    }\n+\n+    pub(super) fn is_empty(&self) -> bool {\n+        self.normalizes_to_hack_goal.is_none() && self.goals.is_empty()\n+    }\n+}\n+\n+pub trait InferCtxtEvalExt<'tcx> {\n+    /// Evaluates a goal from **outside** of the trait solver.\n+    ///\n+    /// Using this while inside of the solver is wrong as it uses a new\n+    /// search graph which would break cycle detection.\n+    fn evaluate_root_goal(\n+        &self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution>;\n+}\n+\n+impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn evaluate_root_goal(\n+        &self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let mut search_graph = search_graph::SearchGraph::new(self.tcx);\n+\n+        let mut ecx = EvalCtxt {\n+            search_graph: &mut search_graph,\n+            infcx: self,\n+            // Only relevant when canonicalizing the response.\n+            max_input_universe: ty::UniverseIndex::ROOT,\n+            var_values: CanonicalVarValues::dummy(),\n+            nested_goals: NestedGoals::new(),\n+        };\n+        let result = ecx.evaluate_goal(IsNormalizesToHack::No, goal);\n+\n+        assert!(\n+            ecx.nested_goals.is_empty(),\n+            \"root `EvalCtxt` should not have any goals added to it\"\n+        );\n+\n+        assert!(search_graph.is_empty());\n+        result\n+    }\n+}\n+\n+impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n+    /// The entry point of the solver.\n+    ///\n+    /// This function deals with (coinductive) cycles, overflow, and caching\n+    /// and then calls [`EvalCtxt::compute_goal`] which contains the actual\n+    /// logic of the solver.\n+    ///\n+    /// Instead of calling this function directly, use either [EvalCtxt::evaluate_goal]\n+    /// if you're inside of the solver or [InferCtxtEvalExt::evaluate_root_goal] if you're\n+    /// outside of it.\n+    #[instrument(level = \"debug\", skip(tcx, search_graph), ret)]\n+    fn evaluate_canonical_goal(\n+        tcx: TyCtxt<'tcx>,\n+        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n+        canonical_goal: CanonicalGoal<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        // Deal with overflow, caching, and coinduction.\n+        //\n+        // The actual solver logic happens in `ecx.compute_goal`.\n+        search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n+            let (ref infcx, goal, var_values) =\n+                tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n+            let mut ecx = EvalCtxt {\n+                infcx,\n+                var_values,\n+                max_input_universe: canonical_goal.max_universe,\n+                search_graph,\n+                nested_goals: NestedGoals::new(),\n+            };\n+            ecx.compute_goal(goal)\n+        })\n+    }\n+\n+    /// Recursively evaluates `goal`, returning whether any inference vars have\n+    /// been constrained and the certainty of the result.\n+    fn evaluate_goal(\n+        &mut self,\n+        is_normalizes_to_hack: IsNormalizesToHack,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n+        let canonical_response =\n+            EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n+\n+        let has_changed = !canonical_response.value.var_values.is_identity();\n+        let certainty = self.instantiate_and_apply_query_response(\n+            goal.param_env,\n+            orig_values,\n+            canonical_response,\n+        )?;\n+\n+        // Check that rerunning this query with its inference constraints applied\n+        // doesn't result in new inference constraints and has the same result.\n+        //\n+        // If we have projection goals like `<T as Trait>::Assoc == u32` we recursively\n+        // call `exists<U> <T as Trait>::Assoc == U` to enable better caching. This goal\n+        // could constrain `U` to `u32` which would cause this check to result in a\n+        // solver cycle.\n+        if cfg!(debug_assertions)\n+            && has_changed\n+            && is_normalizes_to_hack == IsNormalizesToHack::No\n+            && !self.search_graph.in_cycle()\n+        {\n+            debug!(\"rerunning goal to check result is stable\");\n+            let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n+            let canonical_response =\n+                EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n+            if !canonical_response.value.var_values.is_identity() {\n+                bug!(\"unstable result: {goal:?} {canonical_goal:?} {canonical_response:?}\");\n+            }\n+            assert_eq!(certainty, canonical_response.value.certainty);\n+        }\n+\n+        Ok((has_changed, certainty))\n+    }\n+\n+    fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {\n+        let Goal { param_env, predicate } = goal;\n+        let kind = predicate.kind();\n+        if let Some(kind) = kind.no_bound_vars() {\n+            match kind {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n+                    self.compute_trait_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n+                    self.compute_projection_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => {\n+                    self.compute_type_outlives_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n+                    self.compute_region_outlives_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                    self.compute_const_arg_has_type_goal(Goal { param_env, predicate: (ct, ty) })\n+                }\n+                ty::PredicateKind::Subtype(predicate) => {\n+                    self.compute_subtype_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Coerce(predicate) => {\n+                    self.compute_coerce_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::ClosureKind(def_id, substs, kind) => self\n+                    .compute_closure_kind_goal(Goal {\n+                        param_env,\n+                        predicate: (def_id, substs, kind),\n+                    }),\n+                ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+                    self.compute_object_safe_goal(trait_def_id)\n+                }\n+                ty::PredicateKind::WellFormed(arg) => {\n+                    self.compute_well_formed_goal(Goal { param_env, predicate: arg })\n+                }\n+                ty::PredicateKind::Ambiguous => {\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                }\n+                // FIXME: implement these predicates :)\n+                ty::PredicateKind::ConstEvaluatable(_) | ty::PredicateKind::ConstEquate(_, _) => {\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                }\n+                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n+                    bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n+                }\n+                ty::PredicateKind::AliasEq(lhs, rhs) => {\n+                    self.compute_alias_eq_goal(Goal { param_env, predicate: (lhs, rhs) })\n+                }\n+            }\n+        } else {\n+            let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n+            let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n+            self.add_goal(goal);\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        }\n+    }\n+\n+    // Recursively evaluates all the goals added to this `EvalCtxt` to completion, returning\n+    // the certainty of all the goals.\n+    #[instrument(level = \"debug\", skip(self))]\n+    pub(super) fn try_evaluate_added_goals(&mut self) -> Result<Certainty, NoSolution> {\n+        let mut goals = core::mem::replace(&mut self.nested_goals, NestedGoals::new());\n+        let mut new_goals = NestedGoals::new();\n+\n+        let response = self.repeat_while_none(\n+            |_| Ok(Certainty::Maybe(MaybeCause::Overflow)),\n+            |this| {\n+                let mut has_changed = Err(Certainty::Yes);\n+\n+                if let Some(goal) = goals.normalizes_to_hack_goal.take() {\n+                    let (_, certainty) = match this.evaluate_goal(\n+                        IsNormalizesToHack::Yes,\n+                        goal.with(this.tcx(), ty::Binder::dummy(goal.predicate)),\n+                    ) {\n+                        Ok(r) => r,\n+                        Err(NoSolution) => return Some(Err(NoSolution)),\n+                    };\n+\n+                    if goal.predicate.projection_ty\n+                        != this.resolve_vars_if_possible(goal.predicate.projection_ty)\n+                    {\n+                        has_changed = Ok(())\n+                    }\n+\n+                    match certainty {\n+                        Certainty::Yes => {}\n+                        Certainty::Maybe(_) => {\n+                            let goal = this.resolve_vars_if_possible(goal);\n+\n+                            // The rhs of this `normalizes-to` must always be an unconstrained infer var as it is\n+                            // the hack used by `normalizes-to` to ensure that every `normalizes-to` behaves the same\n+                            // regardless of the rhs.\n+                            //\n+                            // However it is important not to unconditionally replace the rhs with a new infer var\n+                            // as otherwise we may replace the original unconstrained infer var with a new infer var\n+                            // and never propagate any constraints on the new var back to the original var.\n+                            let term = this\n+                                .term_is_fully_unconstrained(goal)\n+                                .then_some(goal.predicate.term)\n+                                .unwrap_or_else(|| {\n+                                    this.next_term_infer_of_kind(goal.predicate.term)\n+                                });\n+                            let projection_pred = ty::ProjectionPredicate {\n+                                term,\n+                                projection_ty: goal.predicate.projection_ty,\n+                            };\n+                            new_goals.normalizes_to_hack_goal =\n+                                Some(goal.with(this.tcx(), projection_pred));\n+\n+                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                        }\n+                    }\n+                }\n+\n+                for nested_goal in goals.goals.drain(..) {\n+                    let (changed, certainty) =\n+                        match this.evaluate_goal(IsNormalizesToHack::No, nested_goal) {\n+                            Ok(result) => result,\n+                            Err(NoSolution) => return Some(Err(NoSolution)),\n+                        };\n+\n+                    if changed {\n+                        has_changed = Ok(());\n+                    }\n+\n+                    match certainty {\n+                        Certainty::Yes => {}\n+                        Certainty::Maybe(_) => {\n+                            new_goals.goals.push(nested_goal);\n+                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                        }\n+                    }\n+                }\n+\n+                core::mem::swap(&mut new_goals, &mut goals);\n+                match has_changed {\n+                    Ok(()) => None,\n+                    Err(certainty) => Some(Ok(certainty)),\n+                }\n+            },\n+        );\n+\n+        self.nested_goals = goals;\n+        response\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn probe<T>(&mut self, f: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> T) -> T {\n-        self.infcx.probe(|_| f(self))\n+        let mut ecx = EvalCtxt {\n+            infcx: self.infcx,\n+            var_values: self.var_values,\n+            max_input_universe: self.max_input_universe,\n+            search_graph: self.search_graph,\n+            nested_goals: self.nested_goals.clone(),\n+        };\n+        self.infcx.probe(|_| f(&mut ecx))\n     }\n \n     pub(super) fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -61,6 +355,15 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         )\n     }\n \n+    /// Returns a ty infer or a const infer depending on whether `kind` is a `Ty` or `Const`.\n+    /// If `kind` is an integer inference variable this will still return a ty infer var.\n+    pub(super) fn next_term_infer_of_kind(&self, kind: ty::Term<'tcx>) -> ty::Term<'tcx> {\n+        match kind.unpack() {\n+            ty::TermKind::Ty(_) => self.next_ty_infer().into(),\n+            ty::TermKind::Const(ct) => self.next_const_infer(ct.ty()).into(),\n+        }\n+    }\n+\n     /// Is the projection predicate is of the form `exists<T> <Ty as Trait>::Assoc = T`.\n     ///\n     /// This is the case if the `term` is an inference variable in the innermost universe\n@@ -137,6 +440,30 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n     #[instrument(level = \"debug\", skip(self, param_env), ret)]\n     pub(super) fn eq<T: ToTrace<'tcx>>(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: T,\n+        rhs: T,\n+    ) -> Result<(), NoSolution> {\n+        self.infcx\n+            .at(&ObligationCause::dummy(), param_env)\n+            .eq(DefineOpaqueTypes::No, lhs, rhs)\n+            .map(|InferOk { value: (), obligations }| {\n+                self.add_goals(obligations.into_iter().map(|o| o.into()));\n+            })\n+            .map_err(|e| {\n+                debug!(?e, \"failed to equate\");\n+                NoSolution\n+            })\n+    }\n+\n+    /// Equates two values returning the nested goals without adding them\n+    /// to the nested goals of the `EvalCtxt`.\n+    ///\n+    /// If possible, try using `eq` instead which automatically handles nested\n+    /// goals correctly.\n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    pub(super) fn eq_and_get_goals<T: ToTrace<'tcx>>(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         lhs: T,"}, {"sha": "606c2eaa510518b07595dbd6460773efcc155236", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 49, "deletions": 241, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -15,23 +15,19 @@\n \n // FIXME: uses of `infcx.at` need to enable deferred projection equality once that's implemented.\n \n-use std::mem;\n-\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n     CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n-    Goal, MaybeCause, QueryResult, Response,\n+    Goal, QueryResult, Response,\n };\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n     CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, TypeOutlivesPredicate,\n };\n-use rustc_span::DUMMY_SP;\n \n-use crate::solve::search_graph::OverflowHandler;\n use crate::traits::ObligationCause;\n \n mod assembly;\n@@ -42,7 +38,7 @@ mod project_goals;\n mod search_graph;\n mod trait_goals;\n \n-pub use eval_ctxt::EvalCtxt;\n+pub use eval_ctxt::{EvalCtxt, InferCtxtEvalExt};\n pub use fulfill::FulfillmentCtxt;\n \n trait CanonicalResponseExt {\n@@ -57,180 +53,18 @@ impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n     }\n }\n \n-pub trait InferCtxtEvalExt<'tcx> {\n-    /// Evaluates a goal from **outside** of the trait solver.\n-    ///\n-    /// Using this while inside of the solver is wrong as it uses a new\n-    /// search graph which would break cycle detection.\n-    fn evaluate_root_goal(\n-        &self,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution>;\n-}\n-\n-impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n-    fn evaluate_root_goal(\n-        &self,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n-        let mut search_graph = search_graph::SearchGraph::new(self.tcx);\n-\n-        let result = EvalCtxt {\n-            search_graph: &mut search_graph,\n-            infcx: self,\n-            // Only relevant when canonicalizing the response.\n-            max_input_universe: ty::UniverseIndex::ROOT,\n-            var_values: CanonicalVarValues::dummy(),\n-            in_projection_eq_hack: false,\n-        }\n-        .evaluate_goal(goal);\n-\n-        assert!(search_graph.is_empty());\n-        result\n-    }\n-}\n-\n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n-    /// The entry point of the solver.\n-    ///\n-    /// This function deals with (coinductive) cycles, overflow, and caching\n-    /// and then calls [`EvalCtxt::compute_goal`] which contains the actual\n-    /// logic of the solver.\n-    ///\n-    /// Instead of calling this function directly, use either [EvalCtxt::evaluate_goal]\n-    /// if you're inside of the solver or [InferCtxtEvalExt::evaluate_root_goal] if you're\n-    /// outside of it.\n-    #[instrument(level = \"debug\", skip(tcx, search_graph), ret)]\n-    fn evaluate_canonical_goal(\n-        tcx: TyCtxt<'tcx>,\n-        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n-        canonical_goal: CanonicalGoal<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        // Deal with overflow, caching, and coinduction.\n-        //\n-        // The actual solver logic happens in `ecx.compute_goal`.\n-        search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n-            let (ref infcx, goal, var_values) =\n-                tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-            let mut ecx = EvalCtxt {\n-                infcx,\n-                var_values,\n-                max_input_universe: canonical_goal.max_universe,\n-                search_graph,\n-                in_projection_eq_hack: false,\n-            };\n-            ecx.compute_goal(goal)\n-        })\n-    }\n-\n-    /// Recursively evaluates `goal`, returning whether any inference vars have\n-    /// been constrained and the certainty of the result.\n-    fn evaluate_goal(\n-        &mut self,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n-        let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n-        let canonical_response =\n-            EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-\n-        let has_changed = !canonical_response.value.var_values.is_identity();\n-        let certainty = self.instantiate_and_apply_query_response(\n-            goal.param_env,\n-            orig_values,\n-            canonical_response,\n-        )?;\n-\n-        // Check that rerunning this query with its inference constraints applied\n-        // doesn't result in new inference constraints and has the same result.\n-        //\n-        // If we have projection goals like `<T as Trait>::Assoc == u32` we recursively\n-        // call `exists<U> <T as Trait>::Assoc == U` to enable better caching. This goal\n-        // could constrain `U` to `u32` which would cause this check to result in a\n-        // solver cycle.\n-        if cfg!(debug_assertions)\n-            && has_changed\n-            && !self.in_projection_eq_hack\n-            && !self.search_graph.in_cycle()\n-            && false\n-        {\n-            let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n-            let canonical_response =\n-                EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-            if !canonical_response.value.var_values.is_identity() {\n-                bug!(\"unstable result: {goal:?} {canonical_goal:?} {canonical_response:?}\");\n-            }\n-            assert_eq!(certainty, canonical_response.value.certainty);\n-        }\n-\n-        Ok((has_changed, certainty))\n-    }\n-\n-    fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {\n-        let Goal { param_env, predicate } = goal;\n-        let kind = predicate.kind();\n-        if let Some(kind) = kind.no_bound_vars() {\n-            match kind {\n-                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n-                    self.compute_trait_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n-                    self.compute_projection_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => {\n-                    self.compute_type_outlives_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n-                    self.compute_region_outlives_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n-                    self.compute_const_arg_has_type_goal(Goal { param_env, predicate: (ct, ty) })\n-                }\n-                ty::PredicateKind::Subtype(predicate) => {\n-                    self.compute_subtype_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Coerce(predicate) => {\n-                    self.compute_coerce_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::ClosureKind(def_id, substs, kind) => self\n-                    .compute_closure_kind_goal(Goal {\n-                        param_env,\n-                        predicate: (def_id, substs, kind),\n-                    }),\n-                ty::PredicateKind::ObjectSafe(trait_def_id) => {\n-                    self.compute_object_safe_goal(trait_def_id)\n-                }\n-                ty::PredicateKind::WellFormed(arg) => {\n-                    self.compute_well_formed_goal(Goal { param_env, predicate: arg })\n-                }\n-                ty::PredicateKind::Ambiguous => self.make_canonical_response(Certainty::AMBIGUOUS),\n-                // FIXME: implement these predicates :)\n-                ty::PredicateKind::ConstEvaluatable(_) | ty::PredicateKind::ConstEquate(_, _) => {\n-                    self.make_canonical_response(Certainty::Yes)\n-                }\n-                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n-                    bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n-                }\n-                ty::PredicateKind::AliasEq(lhs, rhs) => {\n-                    self.compute_alias_eq_goal(Goal { param_env, predicate: (lhs, rhs) })\n-                }\n-            }\n-        } else {\n-            let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n-            let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n-            let (_, certainty) = self.evaluate_goal(goal)?;\n-            self.make_canonical_response(certainty)\n-        }\n-    }\n-\n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_type_outlives_goal(\n         &mut self,\n         goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let ty::OutlivesPredicate(ty, lt) = goal.predicate;\n         self.infcx.register_region_obligation_with_cause(ty, lt, &ObligationCause::dummy());\n-        self.make_canonical_response(Certainty::Yes)\n+        self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_region_outlives_goal(\n         &mut self,\n         goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n@@ -239,9 +73,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             &ObligationCause::dummy(),\n             ty::Binder::dummy(goal.predicate),\n         );\n-        self.make_canonical_response(Certainty::Yes)\n+        self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_coerce_goal(\n         &mut self,\n         goal: Goal<'tcx, CoercePredicate<'tcx>>,\n@@ -256,25 +91,26 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         })\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_subtype_goal(\n         &mut self,\n         goal: Goal<'tcx, SubtypePredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         if goal.predicate.a.is_ty_var() && goal.predicate.b.is_ty_var() {\n             // FIXME: Do we want to register a subtype relation between these vars?\n             // That won't actually reflect in the query response, so it seems moot.\n-            self.make_canonical_response(Certainty::AMBIGUOUS)\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n         } else {\n             let InferOk { value: (), obligations } = self\n                 .infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n                 .sub(DefineOpaqueTypes::No, goal.predicate.a, goal.predicate.b)?;\n-            self.evaluate_all_and_make_canonical_response(\n-                obligations.into_iter().map(|pred| pred.into()).collect(),\n-            )\n+            self.add_goals(obligations.into_iter().map(|pred| pred.into()));\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_closure_kind_goal(\n         &mut self,\n         goal: Goal<'tcx, (DefId, ty::SubstsRef<'tcx>, ty::ClosureKind)>,\n@@ -283,23 +119,25 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         let found_kind = substs.as_closure().kind_ty().to_opt_closure_kind();\n \n         let Some(found_kind) = found_kind else {\n-            return self.make_canonical_response(Certainty::AMBIGUOUS);\n+            return self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         };\n         if found_kind.extends(expected_kind) {\n-            self.make_canonical_response(Certainty::Yes)\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_object_safe_goal(&mut self, trait_def_id: DefId) -> QueryResult<'tcx> {\n         if self.tcx().check_is_object_safe(trait_def_id) {\n-            self.make_canonical_response(Certainty::Yes)\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_well_formed_goal(\n         &mut self,\n         goal: Goal<'tcx, ty::GenericArg<'tcx>>,\n@@ -309,10 +147,11 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             goal.param_env,\n             goal.predicate,\n         ) {\n-            Some(obligations) => self.evaluate_all_and_make_canonical_response(\n-                obligations.into_iter().map(|o| o.into()).collect(),\n-            ),\n-            None => self.make_canonical_response(Certainty::AMBIGUOUS),\n+            Some(obligations) => {\n+                self.add_goals(obligations.into_iter().map(|o| o.into()));\n+                self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            }\n+            None => self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS),\n         }\n     }\n \n@@ -326,14 +165,14 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         let evaluate_normalizes_to = |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other| {\n             debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n             let r = ecx.probe(|ecx| {\n-                let (_, certainty) = ecx.evaluate_goal(goal.with(\n+                ecx.add_goal(goal.with(\n                     tcx,\n                     ty::Binder::dummy(ty::ProjectionPredicate {\n                         projection_ty: alias,\n                         term: other,\n                     }),\n-                ))?;\n-                ecx.make_canonical_response(certainty)\n+                ));\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             });\n             debug!(\"evaluate_normalizes_to(..) -> {:?}\", r);\n             r\n@@ -360,10 +199,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 // Evaluate all 3 potential candidates for the alias' being equal\n                 candidates.push(evaluate_normalizes_to(self, alias_lhs, goal.predicate.1));\n                 candidates.push(evaluate_normalizes_to(self, alias_rhs, goal.predicate.0));\n-                candidates.push(self.probe(|this| {\n+                candidates.push(self.probe(|ecx| {\n                     debug!(\"compute_alias_eq_goal: alias defids are equal, equating substs\");\n-                    let nested_goals = this.eq(goal.param_env, alias_lhs, alias_rhs)?;\n-                    this.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }));\n \n                 debug!(?candidates);\n@@ -379,62 +218,31 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         goal: Goal<'tcx, (ty::Const<'tcx>, Ty<'tcx>)>,\n     ) -> QueryResult<'tcx> {\n         let (ct, ty) = goal.predicate;\n-        let nested_goals = self.eq(goal.param_env, ct.ty(), ty)?;\n-        self.evaluate_all_and_make_canonical_response(nested_goals)\n+        self.eq(goal.param_env, ct.ty(), ty)?;\n+        self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n-    // Recursively evaluates a list of goals to completion, returning the certainty\n-    // of all of the goals.\n-    fn evaluate_all(\n-        &mut self,\n-        mut goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n-    ) -> Result<Certainty, NoSolution> {\n-        let mut new_goals = Vec::new();\n-        self.repeat_while_none(\n-            |_| Ok(Certainty::Maybe(MaybeCause::Overflow)),\n-            |this| {\n-                let mut has_changed = Err(Certainty::Yes);\n-                for goal in goals.drain(..) {\n-                    let (changed, certainty) = match this.evaluate_goal(goal) {\n-                        Ok(result) => result,\n-                        Err(NoSolution) => return Some(Err(NoSolution)),\n-                    };\n-\n-                    if changed {\n-                        has_changed = Ok(());\n-                    }\n-\n-                    match certainty {\n-                        Certainty::Yes => {}\n-                        Certainty::Maybe(_) => {\n-                            new_goals.push(goal);\n-                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n-                        }\n-                    }\n-                }\n-\n-                match has_changed {\n-                    Ok(()) => {\n-                        mem::swap(&mut new_goals, &mut goals);\n-                        None\n-                    }\n-                    Err(certainty) => Some(Ok(certainty)),\n-                }\n-            },\n-        )\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn set_normalizes_to_hack_goal(&mut self, goal: Goal<'tcx, ty::ProjectionPredicate<'tcx>>) {\n+        assert!(\n+            self.nested_goals.normalizes_to_hack_goal.is_none(),\n+            \"attempted to set the projection eq hack goal when one already exists\"\n+        );\n+        self.nested_goals.normalizes_to_hack_goal = Some(goal);\n     }\n \n-    // Recursively evaluates a list of goals to completion, making a query response.\n-    //\n-    // This is just a convenient way of calling [`EvalCtxt::evaluate_all`],\n-    // then [`EvalCtxt::make_canonical_response`].\n-    fn evaluate_all_and_make_canonical_response(\n-        &mut self,\n-        goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n-    ) -> QueryResult<'tcx> {\n-        self.evaluate_all(goals).and_then(|certainty| self.make_canonical_response(certainty))\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn add_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) {\n+        self.nested_goals.goals.push(goal);\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, goals))]\n+    fn add_goals(&mut self, goals: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>) {\n+        let current_len = self.nested_goals.goals.len();\n+        self.nested_goals.goals.extend(goals);\n+        debug!(\"added_goals={:?}\", &self.nested_goals.goals[current_len..]);\n     }\n \n     fn try_merge_responses(\n@@ -466,7 +274,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         });\n         // FIXME(-Ztrait-solver=next): We should take the intersection of the constraints on all the\n         // responses and use that for the constraints of this ambiguous response.\n-        let response = self.make_canonical_response(certainty);\n+        let response = self.evaluate_added_goals_and_make_canonical_response(certainty);\n         if let Ok(response) = &response {\n             assert!(response.has_no_inference_or_external_constraints());\n         }"}, {"sha": "93d77c39f9580a37e1fc85cabbd9a83a6ed5f0a6", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 55, "deletions": 96, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -20,6 +20,7 @@ use rustc_span::{sym, DUMMY_SP};\n use std::iter;\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     pub(super) fn compute_projection_goal(\n         &mut self,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n@@ -36,53 +37,17 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             self.merge_candidates_and_discard_reservation_impls(candidates)\n         } else {\n             let predicate = goal.predicate;\n-            let unconstrained_rhs = match predicate.term.unpack() {\n-                ty::TermKind::Ty(_) => self.next_ty_infer().into(),\n-                ty::TermKind::Const(ct) => self.next_const_infer(ct.ty()).into(),\n-            };\n-            let unconstrained_predicate = ty::Clause::Projection(ProjectionPredicate {\n+            let unconstrained_rhs = self.next_term_infer_of_kind(predicate.term);\n+            let unconstrained_predicate = ProjectionPredicate {\n                 projection_ty: goal.predicate.projection_ty,\n                 term: unconstrained_rhs,\n-            });\n-            let (_has_changed, normalize_certainty) = self.in_projection_eq_hack(|this| {\n-                this.evaluate_goal(goal.with(this.tcx(), unconstrained_predicate))\n-            })?;\n-\n-            let nested_eq_goals = self.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n-            let eval_certainty = self.evaluate_all(nested_eq_goals)?;\n-            self.make_canonical_response(normalize_certainty.unify_and(eval_certainty))\n-        }\n-    }\n-\n-    /// This sets a flag used by a debug assert in [`EvalCtxt::evaluate_goal`],\n-    /// see the comment in that method for more details.\n-    fn in_projection_eq_hack<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n-        self.in_projection_eq_hack = true;\n-        let result = f(self);\n-        self.in_projection_eq_hack = false;\n-        result\n-    }\n-\n-    /// After normalizing the projection to `normalized_alias` with the given\n-    /// `normalization_certainty`, constrain the inference variable `term` to it\n-    /// and return a query response.\n-    fn eq_term_and_make_canonical_response(\n-        &mut self,\n-        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n-        normalization_certainty: Certainty,\n-        normalized_alias: impl Into<ty::Term<'tcx>>,\n-    ) -> QueryResult<'tcx> {\n-        // The term of our goal should be fully unconstrained, so this should never fail.\n-        //\n-        // It can however be ambiguous when the `normalized_alias` contains a projection.\n-        let nested_goals = self\n-            .eq(goal.param_env, goal.predicate.term, normalized_alias.into())\n-            .expect(\"failed to unify with unconstrained term\");\n-\n-        let unify_certainty =\n-            self.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n+            };\n \n-        self.make_canonical_response(normalization_certainty.unify_and(unify_certainty))\n+            self.set_normalizes_to_hack_goal(goal.with(self.tcx(), unconstrained_predicate));\n+            self.try_evaluate_added_goals()?;\n+            self.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        }\n     }\n }\n \n@@ -111,19 +76,14 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             ecx.probe(|ecx| {\n                 let assumption_projection_pred =\n                     ecx.instantiate_binder_with_infer(poly_projection_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.projection_ty,\n                     assumption_projection_pred.projection_ty,\n                 )?;\n-                nested_goals.extend(requirements);\n-                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n-\n-                ecx.eq_term_and_make_canonical_response(\n-                    goal,\n-                    subst_certainty,\n-                    assumption_projection_pred.term,\n-                )\n+                ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)?;\n+                ecx.add_goals(requirements);\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -139,36 +99,31 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n         {\n             ecx.probe(|ecx| {\n+                let tcx = ecx.tcx();\n+\n                 let assumption_projection_pred =\n                     ecx.instantiate_binder_with_infer(poly_projection_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.projection_ty,\n                     assumption_projection_pred.projection_ty,\n                 )?;\n \n-                let tcx = ecx.tcx();\n                 let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n                     bug!(\"expected object type in `consider_object_bound_candidate`\");\n                 };\n-                nested_goals.extend(\n+                ecx.add_goals(\n                     structural_traits::predicates_for_object_candidate(\n-                        ecx,\n+                        &ecx,\n                         goal.param_env,\n                         goal.predicate.projection_ty.trait_ref(tcx),\n                         bounds,\n                     )\n                     .into_iter()\n                     .map(|pred| goal.with(tcx, pred)),\n                 );\n-\n-                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n-\n-                ecx.eq_term_and_make_canonical_response(\n-                    goal,\n-                    subst_certainty,\n-                    assumption_projection_pred.term,\n-                )\n+                ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)?;\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -195,16 +150,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let mut nested_goals = ecx.eq(goal.param_env, goal_trait_ref, impl_trait_ref)?;\n+            ecx.eq(goal.param_env, goal_trait_ref, impl_trait_ref)?;\n+\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n                 .predicates\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n-\n-            nested_goals.extend(where_clause_bounds);\n-            let match_impl_certainty = ecx.evaluate_all(nested_goals)?;\n+            ecx.add_goals(where_clause_bounds);\n \n             // In case the associated item is hidden due to specialization, we have to\n             // return ambiguity this would otherwise be incomplete, resulting in\n@@ -216,7 +170,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 goal.predicate.def_id(),\n                 impl_def_id\n             )? else {\n-                return ecx.make_canonical_response(match_impl_certainty.unify_and(Certainty::AMBIGUOUS));\n+                return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -263,7 +217,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty.map_bound(|ty| ty.into())\n             };\n \n-            ecx.eq_term_and_make_canonical_response(goal, match_impl_certainty, term.subst(tcx, substs))\n+            ecx.eq(goal.param_env, goal.predicate.term, term.subst(tcx, substs))?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -308,14 +263,18 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n-        let Some(tupled_inputs_and_output) =\n-        structural_traits::extract_tupled_inputs_and_output_from_callable(\n-            tcx,\n-            goal.predicate.self_ty(),\n-            goal_kind,\n-        )? else {\n-        return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n-    };\n+        let tupled_inputs_and_output =\n+            match structural_traits::extract_tupled_inputs_and_output_from_callable(\n+                tcx,\n+                goal.predicate.self_ty(),\n+                goal_kind,\n+            )? {\n+                Some(tupled_inputs_and_output) => tupled_inputs_and_output,\n+                None => {\n+                    return ecx\n+                        .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n+                }\n+            };\n         let output_is_sized_pred = tupled_inputs_and_output\n             .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n \n@@ -380,26 +339,22 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                         [ty::GenericArg::from(goal.predicate.self_ty())],\n                     ));\n \n-                    let (_, is_sized_certainty) =\n-                        ecx.evaluate_goal(goal.with(tcx, sized_predicate))?;\n-                    return ecx.eq_term_and_make_canonical_response(\n-                        goal,\n-                        is_sized_certainty,\n-                        tcx.types.unit,\n-                    );\n+                    ecx.add_goal(goal.with(tcx, sized_predicate));\n+                    ecx.eq(goal.param_env, goal.predicate.term, tcx.types.unit.into())?;\n+                    return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n                 }\n \n                 ty::Adt(def, substs) if def.is_struct() => {\n                     match def.non_enum_variant().fields.last() {\n                         None => tcx.types.unit,\n                         Some(field_def) => {\n                             let self_ty = field_def.ty(tcx, substs);\n-                            let new_goal = goal.with(\n+                            ecx.add_goal(goal.with(\n                                 tcx,\n                                 ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n-                            );\n-                            let (_, certainty) = ecx.evaluate_goal(new_goal)?;\n-                            return ecx.make_canonical_response(certainty);\n+                            ));\n+                            return ecx\n+                                .evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n                         }\n                     }\n                 }\n@@ -408,12 +363,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty::Tuple(elements) => match elements.last() {\n                     None => tcx.types.unit,\n                     Some(&self_ty) => {\n-                        let new_goal = goal.with(\n+                        ecx.add_goal(goal.with(\n                             tcx,\n                             ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n-                        );\n-                        let (_, certainty) = ecx.evaluate_goal(new_goal)?;\n-                        return ecx.make_canonical_response(certainty);\n+                        ));\n+                        return ecx\n+                            .evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n                     }\n                 },\n \n@@ -426,7 +381,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ),\n             };\n \n-            ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, metadata_ty)\n+            ecx.eq(goal.param_env, goal.predicate.term, metadata_ty.into())?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -522,7 +478,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         let discriminant = goal.predicate.self_ty().discriminant_ty(ecx.tcx());\n-        ecx.probe(|ecx| ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, discriminant))\n+        ecx.probe(|ecx| {\n+            ecx.eq(goal.param_env, goal.predicate.term, discriminant.into())?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n     }\n }\n "}, {"sha": "83d77a69c0020e950d7dc24dbb3091fb884f178a", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -39,9 +39,7 @@ impl<'tcx> SearchGraph<'tcx> {\n     }\n \n     pub(super) fn is_empty(&self) -> bool {\n-        self.stack.is_empty()\n-            && self.provisional_cache.is_empty()\n-            && !self.overflow_data.did_overflow()\n+        self.stack.is_empty() && self.provisional_cache.is_empty()\n     }\n \n     /// Whether we're currently in a cycle. This should only be used"}, {"sha": "8ab55c79fc4502ec41a12c8b9bbdbb9df14cb374", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 63, "deletions": 66, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -47,16 +47,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let mut nested_goals =\n-                ecx.eq(goal.param_env, goal.predicate.trait_ref, impl_trait_ref)?;\n+            ecx.eq(goal.param_env, goal.predicate.trait_ref, impl_trait_ref)?;\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n                 .predicates\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n-            nested_goals.extend(where_clause_bounds);\n-            ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+            ecx.add_goals(where_clause_bounds);\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -73,13 +72,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             ecx.probe(|ecx| {\n                 let assumption_trait_pred =\n                     ecx.instantiate_binder_with_infer(poly_trait_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n                 )?;\n-                nested_goals.extend(requirements);\n-                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                ecx.add_goals(requirements);\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -98,7 +97,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             ecx.probe(|ecx| {\n                 let assumption_trait_pred =\n                     ecx.instantiate_binder_with_infer(poly_trait_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n@@ -108,18 +107,17 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n                     bug!(\"expected object type in `consider_object_bound_candidate`\");\n                 };\n-                nested_goals.extend(\n+                ecx.add_goals(\n                     structural_traits::predicates_for_object_candidate(\n-                        ecx,\n+                        &ecx,\n                         goal.param_env,\n                         goal.predicate.trait_ref,\n                         bounds,\n                     )\n                     .into_iter()\n                     .map(|pred| goal.with(tcx, pred)),\n                 );\n-\n-                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -166,9 +164,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             let nested_obligations = tcx\n                 .predicates_of(goal.predicate.def_id())\n                 .instantiate(tcx, goal.predicate.trait_ref.substs);\n-            ecx.evaluate_all_and_make_canonical_response(\n-                nested_obligations.predicates.into_iter().map(|p| goal.with(tcx, p)).collect(),\n-            )\n+            ecx.add_goals(nested_obligations.predicates.into_iter().map(|p| goal.with(tcx, p)));\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -197,7 +194,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         if goal.predicate.self_ty().has_non_region_infer() {\n-            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+            return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         }\n \n         let tcx = ecx.tcx();\n@@ -209,7 +206,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             && layout.layout.align().abi == usize_layout.align().abi\n         {\n             // FIXME: We could make this faster by making a no-constraints response\n-            ecx.make_canonical_response(Certainty::Yes)\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n@@ -221,14 +218,18 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n-        let Some(tupled_inputs_and_output) =\n-            structural_traits::extract_tupled_inputs_and_output_from_callable(\n+        let tupled_inputs_and_output =\n+            match structural_traits::extract_tupled_inputs_and_output_from_callable(\n                 tcx,\n                 goal.predicate.self_ty(),\n                 goal_kind,\n-            )? else {\n-            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n-        };\n+            )? {\n+                Some(a) => a,\n+                None => {\n+                    return ecx\n+                        .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n+                }\n+            };\n         let output_is_sized_pred = tupled_inputs_and_output\n             .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n \n@@ -247,7 +248,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         if let ty::Tuple(..) = goal.predicate.self_ty().kind() {\n-            ecx.make_canonical_response(Certainty::Yes)\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n@@ -257,7 +258,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         _goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n-        ecx.make_canonical_response(Certainty::Yes)\n+        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n     fn consider_builtin_future_candidate(\n@@ -277,7 +278,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         // Async generator unconditionally implement `Future`\n         // Technically, we need to check that the future output type is Sized,\n         // but that's already proven by the generator being WF.\n-        ecx.make_canonical_response(Certainty::Yes)\n+        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n     fn consider_builtin_generator_candidate(\n@@ -317,7 +318,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         let a_ty = goal.predicate.self_ty();\n         let b_ty = goal.predicate.trait_ref.substs.type_at(1);\n         if b_ty.is_ty_var() {\n-            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+            return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         }\n         ecx.probe(|ecx| {\n             match (a_ty.kind(), b_ty.kind()) {\n@@ -326,7 +327,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     // Dyn upcasting is handled separately, since due to upcasting,\n                     // when there are two supertraits that differ by substs, we\n                     // may return more than one query response.\n-                    return Err(NoSolution);\n+                    Err(NoSolution)\n                 }\n                 // `T` -> `dyn Trait` unsizing\n                 (_, &ty::Dynamic(data, region, ty::Dyn)) => {\n@@ -341,29 +342,26 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     let Some(sized_def_id) = tcx.lang_items().sized_trait() else {\n                         return Err(NoSolution);\n                     };\n-                    let nested_goals: Vec<_> = data\n-                        .iter()\n-                        // Check that the type implements all of the predicates of the def-id.\n-                        // (i.e. the principal, all of the associated types match, and any auto traits)\n-                        .map(|pred| goal.with(tcx, pred.with_self_ty(tcx, a_ty)))\n-                        .chain([\n-                            // The type must be Sized to be unsized.\n-                            goal.with(\n-                                tcx,\n-                                ty::Binder::dummy(tcx.mk_trait_ref(sized_def_id, [a_ty])),\n-                            ),\n-                            // The type must outlive the lifetime of the `dyn` we're unsizing into.\n-                            goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_ty, region))),\n-                        ])\n-                        .collect();\n-\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    // Check that the type implements all of the predicates of the def-id.\n+                    // (i.e. the principal, all of the associated types match, and any auto traits)\n+                    ecx.add_goals(\n+                        data.iter().map(|pred| goal.with(tcx, pred.with_self_ty(tcx, a_ty))),\n+                    );\n+                    // The type must be Sized to be unsized.\n+                    ecx.add_goal(\n+                        goal.with(tcx, ty::Binder::dummy(tcx.mk_trait_ref(sized_def_id, [a_ty]))),\n+                    );\n+                    // The type must outlive the lifetime of the `dyn` we're unsizing into.\n+                    ecx.add_goal(\n+                        goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_ty, region))),\n+                    );\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 // `[T; n]` -> `[T]` unsizing\n                 (&ty::Array(a_elem_ty, ..), &ty::Slice(b_elem_ty)) => {\n                     // We just require that the element type stays the same\n-                    let nested_goals = ecx.eq(goal.param_env, a_elem_ty, b_elem_ty)?;\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.eq(goal.param_env, a_elem_ty, b_elem_ty)?;\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 // Struct unsizing `Struct<T>` -> `Struct<U>` where `T: Unsize<U>`\n                 (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs))\n@@ -397,15 +395,14 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n \n                     // Finally, we require that `TailA: Unsize<TailB>` for the tail field\n                     // types.\n-                    let mut nested_goals = ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n-                    nested_goals.push(goal.with(\n+                    ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+                    ecx.add_goal(goal.with(\n                         tcx,\n                         ty::Binder::dummy(\n                             tcx.mk_trait_ref(goal.predicate.def_id(), [a_tail_ty, b_tail_ty]),\n                         ),\n                     ));\n-\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 // Tuple unsizing `(.., T)` -> `(.., U)` where `T: Unsize<U>`\n                 (&ty::Tuple(a_tys), &ty::Tuple(b_tys))\n@@ -417,17 +414,16 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     // Substitute just the tail field of B., and require that they're equal.\n                     let unsized_a_ty =\n                         tcx.mk_tup_from_iter(a_rest_tys.iter().chain([b_last_ty]).copied());\n-                    let mut nested_goals = ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+                    ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n \n                     // Similar to ADTs, require that the rest of the fields are equal.\n-                    nested_goals.push(goal.with(\n+                    ecx.add_goal(goal.with(\n                         tcx,\n                         ty::Binder::dummy(\n                             tcx.mk_trait_ref(goal.predicate.def_id(), [*a_last_ty, *b_last_ty]),\n                         ),\n                     ));\n-\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 _ => Err(NoSolution),\n             }\n@@ -477,12 +473,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 let new_a_ty = tcx.mk_dynamic(new_a_data, b_region, ty::Dyn);\n \n                 // We also require that A's lifetime outlives B's lifetime.\n-                let mut nested_obligations = ecx.eq(goal.param_env, new_a_ty, b_ty)?;\n-                nested_obligations.push(\n+                ecx.eq(goal.param_env, new_a_ty, b_ty)?;\n+                ecx.add_goal(\n                     goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_region, b_region))),\n                 );\n-\n-                ecx.evaluate_all_and_make_canonical_response(nested_obligations)\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         };\n \n@@ -516,7 +511,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         _goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         // `DiscriminantKind` is automatically implemented for every type.\n-        ecx.make_canonical_response(Certainty::Yes)\n+        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n }\n \n@@ -530,21 +525,23 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n         constituent_tys: impl Fn(&EvalCtxt<'_, 'tcx>, Ty<'tcx>) -> Result<Vec<Ty<'tcx>>, NoSolution>,\n     ) -> QueryResult<'tcx> {\n-        self.probe(|this| {\n-            this.evaluate_all_and_make_canonical_response(\n-                constituent_tys(this, goal.predicate.self_ty())?\n+        self.probe(|ecx| {\n+            ecx.add_goals(\n+                constituent_tys(ecx, goal.predicate.self_ty())?\n                     .into_iter()\n                     .map(|ty| {\n                         goal.with(\n-                            this.tcx(),\n-                            ty::Binder::dummy(goal.predicate.with_self_ty(this.tcx(), ty)),\n+                            ecx.tcx(),\n+                            ty::Binder::dummy(goal.predicate.with_self_ty(ecx.tcx(), ty)),\n                         )\n                     })\n-                    .collect(),\n-            )\n+                    .collect::<Vec<_>>(),\n+            );\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn compute_trait_goal(\n         &mut self,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,"}, {"sha": "9817186b874ccc8ee89987b29a54a1fefe6adabc", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -189,12 +189,28 @@ pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n     goal_kind: ty::ClosureKind,\n ) -> Result<Option<ty::Binder<'tcx, (Ty<'tcx>, Ty<'tcx>)>>, NoSolution> {\n     match *self_ty.kind() {\n-        ty::FnDef(def_id, substs) => Ok(Some(\n-            tcx.fn_sig(def_id)\n-                .subst(tcx, substs)\n-                .map_bound(|sig| (tcx.mk_tup(sig.inputs()), sig.output())),\n-        )),\n-        ty::FnPtr(sig) => Ok(Some(sig.map_bound(|sig| (tcx.mk_tup(sig.inputs()), sig.output())))),\n+        // keep this in sync with assemble_fn_pointer_candidates until the old solver is removed.\n+        ty::FnDef(def_id, substs) => {\n+            let sig = tcx.fn_sig(def_id);\n+            if sig.skip_binder().is_fn_trait_compatible()\n+                && tcx.codegen_fn_attrs(def_id).target_features.is_empty()\n+            {\n+                Ok(Some(\n+                    sig.subst(tcx, substs)\n+                        .map_bound(|sig| (tcx.mk_tup(sig.inputs()), sig.output())),\n+                ))\n+            } else {\n+                Err(NoSolution)\n+            }\n+        }\n+        // keep this in sync with assemble_fn_pointer_candidates until the old solver is removed.\n+        ty::FnPtr(sig) => {\n+            if sig.is_fn_trait_compatible() {\n+                Ok(Some(sig.map_bound(|sig| (tcx.mk_tup(sig.inputs()), sig.output()))))\n+            } else {\n+                Err(NoSolution)\n+            }\n+        }\n         ty::Closure(_, substs) => {\n             let closure_substs = substs.as_closure();\n             match closure_substs.kind_ty().to_opt_closure_kind() {\n@@ -333,7 +349,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ReplaceProjectionWith<'_, 'tcx> {\n             // FIXME: Technically this folder could be fallible?\n             let nested = self\n                 .ecx\n-                .eq(self.param_env, alias_ty, proj.projection_ty)\n+                .eq_and_get_goals(self.param_env, alias_ty, proj.projection_ty)\n                 .expect(\"expected to be able to unify goal projection with dyn's projection\");\n             // FIXME: Technically we could register these too..\n             assert!(nested.is_empty(), \"did not expect unification to have any nested goals\");"}, {"sha": "dbf6775afc2fcc9610510a5a95bd2a35d94be730", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -180,8 +180,9 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n         // At this point, we already have all of the bounds we need. FulfillmentContext is used\n         // to store all of the necessary region/lifetime bounds in the InferContext, as well as\n         // an additional sanity check.\n-        let errors =\n-            super::fully_solve_bound(&infcx, ObligationCause::dummy(), full_env, ty, trait_did);\n+        let ocx = ObligationCtxt::new(&infcx);\n+        ocx.register_bound(ObligationCause::dummy(), full_env, ty, trait_did);\n+        let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n             panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, errors);\n         }"}, {"sha": "572d20b5368b405243f39d426eec44fe01352eaa", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -383,7 +383,10 @@ fn resolve_negative_obligation<'tcx>(\n     };\n \n     let param_env = o.param_env;\n-    if !super::fully_solve_obligation(&infcx, o).is_empty() {\n+    let ocx = ObligationCtxt::new(&infcx);\n+    ocx.register_obligation(o);\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n         return false;\n     }\n "}, {"sha": "b501840b9260b749bbb444c29849e8569bd2bd57", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -420,6 +420,7 @@ fn suggest_restriction<'tcx>(\n ) {\n     if hir_generics.where_clause_span.from_expansion()\n         || hir_generics.where_clause_span.desugaring_kind().is_some()\n+        || projection.map_or(false, |projection| tcx.opt_rpitit_info(projection.def_id).is_some())\n     {\n         return;\n     }"}, {"sha": "b27a39290781af94dc6c9d251467592aaf769512", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 13, "deletions": 59, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::{TypeVisitable, TypeVisitableExt};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeSuperVisitable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n-use rustc_span::def_id::{DefId, CRATE_DEF_ID};\n+use rustc_span::def_id::DefId;\n use rustc_span::Span;\n \n use std::fmt::Debug;\n@@ -63,9 +63,7 @@ pub use self::util::{\n     elaborate_trait_ref, elaborate_trait_refs,\n };\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n-pub use self::util::{\n-    get_vtable_index_of_object_method, impl_item_is_final, predicate_for_trait_def, upcast_choices,\n-};\n+pub use self::util::{get_vtable_index_of_object_method, impl_item_is_final, upcast_choices};\n pub use self::util::{\n     supertrait_def_ids, supertraits, transitive_bounds, transitive_bounds_that_define_assoc_type,\n     SupertraitDefIds, Supertraits,\n@@ -131,29 +129,23 @@ pub fn type_known_to_meet_bound_modulo_regions<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n     def_id: DefId,\n-    span: Span,\n ) -> bool {\n     let trait_ref = ty::Binder::dummy(infcx.tcx.mk_trait_ref(def_id, [ty]));\n-    pred_known_to_hold_modulo_regions(infcx, param_env, trait_ref.without_const(), span)\n+    pred_known_to_hold_modulo_regions(infcx, param_env, trait_ref.without_const())\n }\n \n-#[instrument(level = \"debug\", skip(infcx, param_env, span, pred), ret)]\n+/// FIXME(@lcnr): this function doesn't seem right and shouldn't exist?\n+///\n+/// Ping me on zulip if you want to use this method and need help with finding\n+/// an appropriate replacement.\n+#[instrument(level = \"debug\", skip(infcx, param_env, pred), ret)]\n fn pred_known_to_hold_modulo_regions<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     pred: impl ToPredicate<'tcx> + TypeVisitable<TyCtxt<'tcx>>,\n-    span: Span,\n ) -> bool {\n     let has_non_region_infer = pred.has_non_region_infer();\n-    let obligation = Obligation {\n-        param_env,\n-        // We can use a dummy node-id here because we won't pay any mind\n-        // to region obligations that arise (there shouldn't really be any\n-        // anyhow).\n-        cause: ObligationCause::misc(span, CRATE_DEF_ID),\n-        recursion_depth: 0,\n-        predicate: pred.to_predicate(infcx.tcx),\n-    };\n+    let obligation = Obligation::new(infcx.tcx, ObligationCause::dummy(), param_env, pred);\n \n     let result = infcx.evaluate_obligation_no_overflow(&obligation);\n     debug!(?result);\n@@ -166,14 +158,13 @@ fn pred_known_to_hold_modulo_regions<'tcx>(\n         // this function's result remains infallible, we must confirm\n         // that guess. While imperfect, I believe this is sound.\n \n-        // FIXME(@lcnr): this function doesn't seem right.\n-        //\n         // The handling of regions in this area of the code is terrible,\n         // see issue #29149. We should be able to improve on this with\n         // NLL.\n-        let errors = fully_solve_obligation(infcx, obligation);\n-\n-        match &errors[..] {\n+        let ocx = ObligationCtxt::new(infcx);\n+        ocx.register_obligation(obligation);\n+        let errors = ocx.select_all_or_error();\n+        match errors.as_slice() {\n             [] => true,\n             errors => {\n                 debug!(?errors);\n@@ -389,43 +380,6 @@ where\n     Ok(resolved_value)\n }\n \n-/// Process an obligation (and any nested obligations that come from it) to\n-/// completion, returning any errors\n-pub fn fully_solve_obligation<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    obligation: PredicateObligation<'tcx>,\n-) -> Vec<FulfillmentError<'tcx>> {\n-    fully_solve_obligations(infcx, [obligation])\n-}\n-\n-/// Process a set of obligations (and any nested obligations that come from them)\n-/// to completion\n-pub fn fully_solve_obligations<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n-) -> Vec<FulfillmentError<'tcx>> {\n-    let ocx = ObligationCtxt::new(infcx);\n-    ocx.register_obligations(obligations);\n-    ocx.select_all_or_error()\n-}\n-\n-/// Process a bound (and any nested obligations that come from it) to completion.\n-/// This is a convenience function for traits that have no generic arguments, such\n-/// as auto traits, and builtin traits like Copy or Sized.\n-pub fn fully_solve_bound<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n-    bound: DefId,\n-) -> Vec<FulfillmentError<'tcx>> {\n-    let tcx = infcx.tcx;\n-    let trait_ref = tcx.mk_trait_ref(bound, [ty]);\n-    let obligation = Obligation::new(tcx, cause, param_env, ty::Binder::dummy(trait_ref));\n-\n-    fully_solve_obligation(infcx, obligation)\n-}\n-\n /// Normalizes the predicates and checks whether they hold in an empty environment. If this\n /// returns true, then either normalize encountered an error or one of the predicates did not\n /// hold. Used when creating vtables to check for unsatisfiable methods."}, {"sha": "038f8964471f5c8f2190b93df6b15beacb46709f", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -17,10 +17,10 @@ use rustc_errors::{DelayDm, FatalError, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n-use rustc_middle::ty::ToPredicate;\n use rustc_middle::ty::{\n     self, EarlyBinder, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n+use rustc_middle::ty::{ToPredicate, TypeVisitableExt};\n use rustc_session::lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n@@ -139,6 +139,10 @@ fn object_safety_violations_for_trait(\n     if !spans.is_empty() {\n         violations.push(ObjectSafetyViolation::SupertraitSelf(spans));\n     }\n+    let spans = super_predicates_have_non_lifetime_binders(tcx, trait_def_id);\n+    if !spans.is_empty() {\n+        violations.push(ObjectSafetyViolation::SupertraitNonLifetimeBinder(spans));\n+    }\n \n     violations.extend(\n         tcx.associated_items(trait_def_id)\n@@ -348,6 +352,21 @@ fn predicate_references_self<'tcx>(\n     }\n }\n \n+fn super_predicates_have_non_lifetime_binders(\n+    tcx: TyCtxt<'_>,\n+    trait_def_id: DefId,\n+) -> SmallVec<[Span; 1]> {\n+    // If non_lifetime_binders is disabled, then exit early\n+    if !tcx.features().non_lifetime_binders {\n+        return SmallVec::new();\n+    }\n+    tcx.super_predicates_of(trait_def_id)\n+        .predicates\n+        .iter()\n+        .filter_map(|(pred, span)| pred.has_non_region_late_bound().then_some(*span))\n+        .collect()\n+}\n+\n fn trait_has_sized_self(tcx: TyCtxt<'_>, trait_def_id: DefId) -> bool {\n     generics_require_sized_self(tcx, trait_def_id)\n }"}, {"sha": "bac02f2d38328adf0000ce59c97bc8082471b7ad", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,7 +1,7 @@\n use crate::infer::InferCtxt;\n use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use crate::traits::query::NoSolution;\n-use crate::traits::ObligationCause;\n+use crate::traits::{ObligationCause, ObligationCtxt};\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_middle::ty::{self, ParamEnv, Ty};\n use rustc_span::def_id::LocalDefId;\n@@ -71,22 +71,23 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n \n         if let Some(constraints) = constraints {\n             debug!(?constraints);\n+            if !constraints.member_constraints.is_empty() {\n+                span_bug!(span, \"{:#?}\", constraints.member_constraints);\n+            }\n+\n             // Instantiation may have produced new inference variables and constraints on those\n             // variables. Process these constraints.\n+            let ocx = ObligationCtxt::new(self);\n             let cause = ObligationCause::misc(span, body_id);\n-            let errors = super::fully_solve_obligations(\n-                self,\n-                constraints.outlives.iter().map(|constraint| {\n-                    self.query_outlives_constraint_to_obligation(\n-                        *constraint,\n-                        cause.clone(),\n-                        param_env,\n-                    )\n-                }),\n-            );\n-            if !constraints.member_constraints.is_empty() {\n-                span_bug!(span, \"{:#?}\", constraints.member_constraints);\n+            for &constraint in &constraints.outlives {\n+                ocx.register_obligation(self.query_outlives_constraint_to_obligation(\n+                    constraint,\n+                    cause.clone(),\n+                    param_env,\n+                ));\n             }\n+\n+            let errors = ocx.select_all_or_error();\n             if !errors.is_empty() {\n                 self.tcx.sess.delay_span_bug(\n                     span,"}, {"sha": "8f1b05c1190d5b875983e8cf93a336bbd460e4b7", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,8 +1,8 @@\n use crate::infer::canonical::query_response;\n use crate::infer::{InferCtxt, InferOk};\n-use crate::traits;\n use crate::traits::query::type_op::TypeOpOutput;\n use crate::traits::query::Fallible;\n+use crate::traits::ObligationCtxt;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n use rustc_span::source_map::DUMMY_SP;\n \n@@ -73,7 +73,9 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     );\n \n     let InferOk { value, obligations } = infcx.commit_if_ok(|_| op())?;\n-    let errors = traits::fully_solve_obligations(infcx, obligations);\n+    let ocx = ObligationCtxt::new(infcx);\n+    ocx.register_obligations(obligations);\n+    let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n         infcx.tcx.sess.diagnostic().delay_span_bug(\n             DUMMY_SP,\n@@ -82,9 +84,7 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     }\n \n     let region_obligations = infcx.take_registered_region_obligations();\n-\n     let region_constraint_data = infcx.take_and_reset_region_constraints();\n-\n     let region_constraints = query_response::make_query_region_constraints(\n         infcx.tcx,\n         region_obligations"}, {"sha": "e06eff34df21a4cf6c9cf347d8b7498b872c77aa", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -11,7 +11,6 @@ use rustc_infer::traits::ObligationCause;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n-use rustc_target::spec::abi::Abi;\n \n use crate::traits;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -291,6 +290,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n+        // Keep this funtion in sync with extract_tupled_inputs_and_output_from_callable\n+        // until the old solver (and thus this function) is removed.\n+\n         // Okay to skip binder because what we are inspecting doesn't involve bound regions.\n         let self_ty = obligation.self_ty().skip_binder();\n         match *self_ty.kind() {\n@@ -299,31 +301,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 candidates.ambiguous = true; // Could wind up being a fn() type.\n             }\n             // Provide an impl, but only for suitable `fn` pointers.\n-            ty::FnPtr(_) => {\n-                if let ty::FnSig {\n-                    unsafety: hir::Unsafety::Normal,\n-                    abi: Abi::Rust,\n-                    c_variadic: false,\n-                    ..\n-                } = self_ty.fn_sig(self.tcx()).skip_binder()\n-                {\n+            ty::FnPtr(sig) => {\n+                if sig.is_fn_trait_compatible() {\n                     candidates.vec.push(FnPointerCandidate { is_const: false });\n                 }\n             }\n             // Provide an impl for suitable functions, rejecting `#[target_feature]` functions (RFC 2396).\n             ty::FnDef(def_id, _) => {\n-                if let ty::FnSig {\n-                    unsafety: hir::Unsafety::Normal,\n-                    abi: Abi::Rust,\n-                    c_variadic: false,\n-                    ..\n-                } = self_ty.fn_sig(self.tcx()).skip_binder()\n+                if self.tcx().fn_sig(def_id).skip_binder().is_fn_trait_compatible()\n+                    && self.tcx().codegen_fn_attrs(def_id).target_features.is_empty()\n                 {\n-                    if self.tcx().codegen_fn_attrs(def_id).target_features.is_empty() {\n-                        candidates\n-                            .vec\n-                            .push(FnPointerCandidate { is_const: self.tcx().is_const_fn(def_id) });\n-                    }\n+                    candidates\n+                        .vec\n+                        .push(FnPointerCandidate { is_const: self.tcx().is_const_fn(def_id) });\n                 }\n             }\n             _ => {}"}, {"sha": "eb354bc3f50c6386ceea3b2359ef995b01666da8", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -18,7 +18,7 @@ use rustc_session::config::TraitSolver;\n use rustc_span::def_id::DefId;\n \n use crate::traits::project::{normalize_with_depth, normalize_with_depth_to};\n-use crate::traits::util::{self, closure_trait_ref_and_return_type, predicate_for_trait_def};\n+use crate::traits::util::{self, closure_trait_ref_and_return_type};\n use crate::traits::vtable::{\n     count_own_vtable_entries, prepare_vtable_segments, vtable_trait_first_method_offset,\n     VtblSegment,\n@@ -253,15 +253,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             };\n \n             let cause = obligation.derived_cause(BuiltinDerivedObligation);\n-            ensure_sufficient_stack(|| {\n-                self.collect_predicates_for_types(\n-                    obligation.param_env,\n-                    cause,\n-                    obligation.recursion_depth + 1,\n-                    trait_def,\n-                    nested,\n-                )\n-            })\n+            self.collect_predicates_for_types(\n+                obligation.param_env,\n+                cause,\n+                obligation.recursion_depth + 1,\n+                trait_def,\n+                nested,\n+            )\n         } else {\n             vec![]\n         };\n@@ -1118,14 +1116,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nested.extend(obligations);\n \n                 // Construct the nested `TailField<T>: Unsize<TailField<U>>` predicate.\n-                nested.push(predicate_for_trait_def(\n+                let tail_unsize_obligation = obligation.with(\n                     tcx,\n-                    obligation.param_env,\n-                    obligation.cause.clone(),\n-                    obligation.predicate.def_id(),\n-                    obligation.recursion_depth + 1,\n-                    [source_tail, target_tail],\n-                ));\n+                    tcx.mk_trait_ref(obligation.predicate.def_id(), [source_tail, target_tail]),\n+                );\n+                nested.push(tail_unsize_obligation);\n             }\n \n             // `(.., T)` -> `(.., U)`\n@@ -1147,17 +1142,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n-                // Construct the nested `T: Unsize<U>` predicate.\n-                nested.push(ensure_sufficient_stack(|| {\n-                    predicate_for_trait_def(\n-                        tcx,\n-                        obligation.param_env,\n-                        obligation.cause.clone(),\n-                        obligation.predicate.def_id(),\n-                        obligation.recursion_depth + 1,\n-                        [a_last, b_last],\n-                    )\n-                }));\n+                // Add a nested `T: Unsize<U>` predicate.\n+                let last_unsize_obligation = obligation\n+                    .with(tcx, tcx.mk_trait_ref(obligation.predicate.def_id(), [a_last, b_last]));\n+                nested.push(last_unsize_obligation);\n             }\n \n             _ => bug!(\"source: {source}, target: {target}\"),"}, {"sha": "b8758ad93231d905a77e344c6080f8587773567b", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 25, "deletions": 59, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -17,7 +17,7 @@ use super::project;\n use super::project::normalize_with_depth_to;\n use super::project::ProjectionTyObligation;\n use super::util;\n-use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n+use super::util::closure_trait_ref_and_return_type;\n use super::wf;\n use super::{\n     ErrorReporting, ImplDerivedObligation, ImplDerivedObligationCause, Normalized, Obligation,\n@@ -595,7 +595,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             self.evaluate_predicates_recursively_in_new_solver(predicates)\n         } else {\n             let mut result = EvaluatedToOk;\n-            for obligation in predicates {\n+            for mut obligation in predicates {\n+                obligation.set_depth_from_parent(stack.depth());\n                 let eval = self.evaluate_predicate_recursively(stack, obligation.clone())?;\n                 if let EvaluatedToErr = eval {\n                     // fast-path - EvaluatedToErr is the top of the lattice,\n@@ -661,12 +662,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     let p = bound_predicate.rebind(p);\n                     // Does this code ever run?\n                     match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n-                        Ok(Ok(InferOk { mut obligations, .. })) => {\n-                            self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n-                            self.evaluate_predicates_recursively(\n-                                previous_stack,\n-                                obligations.into_iter(),\n-                            )\n+                        Ok(Ok(InferOk { obligations, .. })) => {\n+                            self.evaluate_predicates_recursively(previous_stack, obligations)\n                         }\n                         Ok(Err(_)) => Ok(EvaluatedToErr),\n                         Err(..) => Ok(EvaluatedToAmbig),\n@@ -677,12 +674,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     let p = bound_predicate.rebind(p);\n                     // Does this code ever run?\n                     match self.infcx.coerce_predicate(&obligation.cause, obligation.param_env, p) {\n-                        Ok(Ok(InferOk { mut obligations, .. })) => {\n-                            self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n-                            self.evaluate_predicates_recursively(\n-                                previous_stack,\n-                                obligations.into_iter(),\n-                            )\n+                        Ok(Ok(InferOk { obligations, .. })) => {\n+                            self.evaluate_predicates_recursively(previous_stack, obligations)\n                         }\n                         Ok(Err(_)) => Ok(EvaluatedToErr),\n                         Err(..) => Ok(EvaluatedToAmbig),\n@@ -755,9 +748,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         arg,\n                         obligation.cause.span,\n                     ) {\n-                        Some(mut obligations) => {\n-                            self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n-\n+                        Some(obligations) => {\n                             cache.wf_args.borrow_mut().push((arg, previous_stack.depth()));\n                             let result =\n                                 self.evaluate_predicates_recursively(previous_stack, obligations);\n@@ -826,10 +817,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     }\n                                 }\n \n-                                self.add_depth(\n-                                    subobligations.iter_mut(),\n-                                    obligation.recursion_depth,\n-                                );\n+                                // Need to explicitly set the depth of nested goals here as\n+                                // projection obligations can cycle by themselves and in\n+                                // `evaluate_predicates_recursively` we only add the depth\n+                                // for parent trait goals because only these get added to the\n+                                // `TraitObligationStackList`.\n+                                for subobligation in subobligations.iter_mut() {\n+                                    subobligation.set_depth_from_parent(obligation.recursion_depth);\n+                                }\n                                 let res = self.evaluate_predicates_recursively(\n                                     previous_stack,\n                                     subobligations,\n@@ -909,38 +904,28 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 if a.def.did == b.def.did\n                                     && tcx.def_kind(a.def.did) == DefKind::AssocConst =>\n                             {\n-                                if let Ok(new_obligations) = self\n+                                if let Ok(InferOk { obligations, value: () }) = self\n                                     .infcx\n                                     .at(&obligation.cause, obligation.param_env)\n                                     .trace(c1, c2)\n                                     .eq(DefineOpaqueTypes::No, a.substs, b.substs)\n                                 {\n-                                    let mut obligations = new_obligations.obligations;\n-                                    self.add_depth(\n-                                        obligations.iter_mut(),\n-                                        obligation.recursion_depth,\n-                                    );\n                                     return self.evaluate_predicates_recursively(\n                                         previous_stack,\n-                                        obligations.into_iter(),\n+                                        obligations,\n                                     );\n                                 }\n                             }\n                             (_, Unevaluated(_)) | (Unevaluated(_), _) => (),\n                             (_, _) => {\n-                                if let Ok(new_obligations) = self\n+                                if let Ok(InferOk { obligations, value: () }) = self\n                                     .infcx\n                                     .at(&obligation.cause, obligation.param_env)\n                                     .eq(DefineOpaqueTypes::No, c1, c2)\n                                 {\n-                                    let mut obligations = new_obligations.obligations;\n-                                    self.add_depth(\n-                                        obligations.iter_mut(),\n-                                        obligation.recursion_depth,\n-                                    );\n                                     return self.evaluate_predicates_recursively(\n                                         previous_stack,\n-                                        obligations.into_iter(),\n+                                        obligations,\n                                     );\n                                 }\n                             }\n@@ -1366,24 +1351,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx.evaluation_cache.insert((param_env, trait_pred), dep_node, result);\n     }\n \n-    /// For various reasons, it's possible for a subobligation\n-    /// to have a *lower* recursion_depth than the obligation used to create it.\n-    /// Projection sub-obligations may be returned from the projection cache,\n-    /// which results in obligations with an 'old' `recursion_depth`.\n-    /// Additionally, methods like `InferCtxt.subtype_predicate` produce\n-    /// subobligations without taking in a 'parent' depth, causing the\n-    /// generated subobligations to have a `recursion_depth` of `0`.\n-    ///\n-    /// To ensure that obligation_depth never decreases, we force all subobligations\n-    /// to have at least the depth of the original obligation.\n-    fn add_depth<T: 'cx, I: Iterator<Item = &'cx mut Obligation<'tcx, T>>>(\n-        &self,\n-        it: I,\n-        min_depth: usize,\n-    ) {\n-        it.for_each(|o| o.recursion_depth = cmp::max(min_depth, o.recursion_depth) + 1);\n-    }\n-\n     fn check_recursion_depth<T>(\n         &self,\n         depth: usize,\n@@ -2440,15 +2407,14 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n                             placeholder_ty,\n                         )\n                     });\n-                let placeholder_obligation = predicate_for_trait_def(\n+\n+                let obligation = Obligation::new(\n                     self.tcx(),\n-                    param_env,\n                     cause.clone(),\n-                    trait_def_id,\n-                    recursion_depth,\n-                    [normalized_ty],\n+                    param_env,\n+                    self.tcx().mk_trait_ref(trait_def_id, [normalized_ty]),\n                 );\n-                obligations.push(placeholder_obligation);\n+                obligations.push(obligation);\n                 obligations\n             })\n             .collect()"}, {"sha": "8546bbe52dcc39d369520f97958284dfc79f7225", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -22,7 +22,7 @@ use crate::traits::{\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{error_code, DelayDm, Diagnostic};\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt, TypeVisitableExt};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_session::lint::builtin::COHERENCE_LEAK_CHECK;\n use rustc_session::lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS;\n@@ -350,6 +350,10 @@ fn report_conflicting_impls<'tcx>(\n         impl_span: Span,\n         err: &mut Diagnostic,\n     ) {\n+        if (overlap.trait_ref, overlap.self_ty).references_error() {\n+            err.downgrade_to_delayed_bug();\n+        }\n+\n         match tcx.span_of_impl(overlap.with_impl) {\n             Ok(span) => {\n                 err.span_label(span, \"first implementation here\");"}, {"sha": "00c9a35225881ad82f57cf26b3bf2c2999bf9733", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,11 +1,11 @@\n use super::NormalizeExt;\n-use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext};\n+use super::{ObligationCause, PredicateObligation, SelectionContext};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::InferOk;\n+use rustc_middle::ty::SubstsRef;\n use rustc_middle::ty::{self, ImplSubject, ToPredicate, Ty, TyCtxt, TypeVisitableExt};\n-use rustc_middle::ty::{GenericArg, SubstsRef};\n use rustc_span::Span;\n use smallvec::SmallVec;\n \n@@ -218,33 +218,6 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n     (subject, impl_obligations)\n }\n \n-pub fn predicate_for_trait_ref<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    trait_ref: ty::TraitRef<'tcx>,\n-    recursion_depth: usize,\n-) -> PredicateObligation<'tcx> {\n-    Obligation {\n-        cause,\n-        param_env,\n-        recursion_depth,\n-        predicate: ty::Binder::dummy(trait_ref).without_const().to_predicate(tcx),\n-    }\n-}\n-\n-pub fn predicate_for_trait_def<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    trait_def_id: DefId,\n-    recursion_depth: usize,\n-    params: impl IntoIterator<Item: Into<GenericArg<'tcx>>>,\n-) -> PredicateObligation<'tcx> {\n-    let trait_ref = tcx.mk_trait_ref(trait_def_id, params);\n-    predicate_for_trait_ref(tcx, cause, param_env, trait_ref, recursion_depth)\n-}\n-\n /// Casts a trait reference into a reference to one of its super\n /// traits; returns `None` if `target_trait_def_id` is not a\n /// supertrait."}, {"sha": "6d9ad96fa74d4d654e4568713312e8948016e2c8", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -18,8 +18,8 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     };\n }\n \n-fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n-    let item = tcx.hir().expect_item(def_id.expect_local());\n+fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &[DefId] {\n+    let item = tcx.hir().expect_item(def_id);\n     match item.kind {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             if tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n@@ -107,27 +107,26 @@ fn impl_item_implementor_ids(tcx: TyCtxt<'_>, impl_id: DefId) -> DefIdMap<DefId>\n         .collect()\n }\n \n-fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n-    let id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+fn associated_item(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::AssocItem {\n+    let id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let parent_def_id = tcx.hir().get_parent_item(id);\n     let parent_item = tcx.hir().expect_item(parent_def_id.def_id);\n     match parent_item.kind {\n         hir::ItemKind::Impl(ref impl_) => {\n-            if let Some(impl_item_ref) =\n-                impl_.items.iter().find(|i| i.id.owner_id.to_def_id() == def_id)\n+            if let Some(impl_item_ref) = impl_.items.iter().find(|i| i.id.owner_id.def_id == def_id)\n             {\n                 let assoc_item = associated_item_from_impl_item_ref(impl_item_ref);\n-                debug_assert_eq!(assoc_item.def_id, def_id);\n+                debug_assert_eq!(assoc_item.def_id.expect_local(), def_id);\n                 return assoc_item;\n             }\n         }\n \n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             if let Some(trait_item_ref) =\n-                trait_item_refs.iter().find(|i| i.id.owner_id.to_def_id() == def_id)\n+                trait_item_refs.iter().find(|i| i.id.owner_id.def_id == def_id)\n             {\n                 let assoc_item = associated_item_from_trait_item_ref(trait_item_ref);\n-                debug_assert_eq!(assoc_item.def_id, def_id);\n+                debug_assert_eq!(assoc_item.def_id.expect_local(), def_id);\n                 return assoc_item;\n             }\n         }\n@@ -191,9 +190,9 @@ fn associated_item_from_impl_item_ref(impl_item_ref: &hir::ImplItemRef) -> ty::A\n /// above, synthesize a corresponding associated type in the impl.\n fn associated_types_for_impl_traits_in_associated_fn(\n     tcx: TyCtxt<'_>,\n-    fn_def_id: DefId,\n+    fn_def_id: LocalDefId,\n ) -> &'_ [DefId] {\n-    let parent_def_id = tcx.parent(fn_def_id);\n+    let parent_def_id = tcx.local_parent(fn_def_id);\n \n     match tcx.def_kind(parent_def_id) {\n         DefKind::Trait => {\n@@ -212,7 +211,7 @@ fn associated_types_for_impl_traits_in_associated_fn(\n \n             let mut visitor = RPITVisitor { rpits: Vec::new() };\n \n-            if let Some(output) = tcx.hir().get_fn_output(fn_def_id.expect_local()) {\n+            if let Some(output) = tcx.hir().get_fn_output(fn_def_id) {\n                 visitor.visit_fn_ret_ty(output);\n \n                 tcx.arena.alloc_from_iter(visitor.rpits.iter().map(|opaque_ty_def_id| {\n@@ -232,7 +231,7 @@ fn associated_types_for_impl_traits_in_associated_fn(\n                         associated_type_for_impl_trait_in_impl(\n                             tcx,\n                             trait_assoc_def_id.expect_local(),\n-                            fn_def_id.expect_local(),\n+                            fn_def_id,\n                         )\n                         .to_def_id()\n                     },\n@@ -297,7 +296,7 @@ fn associated_type_for_impl_trait_in_trait(\n     // Copy type_of of the opaque.\n     trait_assoc_ty.type_of(ty::EarlyBinder(tcx.mk_opaque(\n         opaque_ty_def_id.to_def_id(),\n-        InternalSubsts::identity_for_item(tcx, opaque_ty_def_id.to_def_id()),\n+        InternalSubsts::identity_for_item(tcx, opaque_ty_def_id),\n     )));\n \n     trait_assoc_ty.is_type_alias_impl_trait(false);"}, {"sha": "3b1abdcb24f8f3c18eaf7cfdf6250231b35474d7", "filename": "compiler/rustc_ty_utils/src/common_traits.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -3,7 +3,6 @@\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits;\n \n fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n@@ -30,7 +29,7 @@ fn is_item_raw<'tcx>(\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(item, None);\n     let infcx = tcx.infer_ctxt().build();\n-    traits::type_known_to_meet_bound_modulo_regions(&infcx, param_env, ty, trait_def_id, DUMMY_SP)\n+    traits::type_known_to_meet_bound_modulo_regions(&infcx, param_env, ty, trait_def_id)\n }\n \n pub(crate) fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "4d0fd260de2fea8ccd92725e5b01d733ec914b2c", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -425,7 +425,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n         destructure_const,\n         thir_abstract_const: |tcx, def_id| {\n-            let def_id = def_id.expect_local();\n             if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n                 tcx.thir_abstract_const_of_const_arg(def)\n             } else {"}, {"sha": "26d6deab883eb7d380d0b2bf2624ad029659374c", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Representability, Ty, TyCtxt};\n-use rustc_span::def_id::{DefId, LocalDefId};\n+use rustc_span::def_id::LocalDefId;\n \n pub fn provide(providers: &mut Providers) {\n     *providers =\n@@ -85,7 +85,7 @@ fn representability_adt_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Representab\n     Representability::Representable\n }\n \n-fn params_in_repr(tcx: TyCtxt<'_>, def_id: DefId) -> BitSet<u32> {\n+fn params_in_repr(tcx: TyCtxt<'_>, def_id: LocalDefId) -> BitSet<u32> {\n     let adt_def = tcx.adt_def(def_id);\n     let generics = tcx.generics_of(def_id);\n     let mut params_in_repr = BitSet::new_empty(generics.params.len());"}, {"sha": "70686eefbca01882de882077f3907281b28e7fef", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -7,7 +7,8 @@ use rustc_middle::ty::{\n     TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n use rustc_session::config::TraitSolver;\n-use rustc_span::def_id::{DefId, CRATE_DEF_ID};\n+use rustc_span::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n+use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits;\n \n fn sized_constraint_for_ty<'tcx>(\n@@ -76,8 +77,8 @@ fn sized_constraint_for_ty<'tcx>(\n     result\n }\n \n-fn impl_defaultness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Defaultness {\n-    match tcx.hir().get_by_def_id(def_id.expect_local()) {\n+fn impl_defaultness(tcx: TyCtxt<'_>, def_id: LocalDefId) -> hir::Defaultness {\n+    match tcx.hir().get_by_def_id(def_id) {\n         hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(impl_), .. }) => impl_.defaultness,\n         hir::Node::ImplItem(hir::ImplItem { defaultness, .. })\n         | hir::Node::TraitItem(hir::TraitItem { defaultness, .. }) => *defaultness,\n@@ -275,16 +276,22 @@ impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ImplTraitInTraitFinder<'_, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n-        if let ty::Alias(ty::Projection, alias_ty) = *ty.kind()\n-            && self.tcx.is_impl_trait_in_trait(alias_ty.def_id)\n-            && self.tcx.impl_trait_in_trait_parent_fn(alias_ty.def_id) == self.fn_def_id\n-            && self.seen.insert(alias_ty.def_id)\n+        if let ty::Alias(ty::Projection, unshifted_alias_ty) = *ty.kind()\n+            && self.tcx.is_impl_trait_in_trait(unshifted_alias_ty.def_id)\n+            && self.tcx.impl_trait_in_trait_parent_fn(unshifted_alias_ty.def_id) == self.fn_def_id\n+            && self.seen.insert(unshifted_alias_ty.def_id)\n         {\n             // We have entered some binders as we've walked into the\n             // bounds of the RPITIT. Shift these binders back out when\n             // constructing the top-level projection predicate.\n-            let alias_ty = self.tcx.fold_regions(alias_ty, |re, _| {\n+            let shifted_alias_ty = self.tcx.fold_regions(unshifted_alias_ty, |re, depth| {\n                 if let ty::ReLateBound(index, bv) = re.kind() {\n+                    if depth != ty::INNERMOST {\n+                        return self.tcx.mk_re_error_with_message(\n+                            DUMMY_SP,\n+                            \"we shouldn't walk non-predicate binders with `impl Trait`...\",\n+                        );\n+                    }\n                     self.tcx.mk_re_late_bound(index.shifted_out_to_binder(self.depth), bv)\n                 } else {\n                     re\n@@ -295,26 +302,27 @@ impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ImplTraitInTraitFinder<'_, 'tcx> {\n             // the `type_of` of the trait's associated item. If we're using the old lowering\n             // strategy, then just reinterpret the associated type like an opaque :^)\n             let default_ty = if self.tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n-                self\n-                    .tcx\n-                    .type_of(alias_ty.def_id)\n-                    .subst(self.tcx, alias_ty.substs)\n+                self.tcx.type_of(shifted_alias_ty.def_id).subst(self.tcx, shifted_alias_ty.substs)\n             } else {\n-                self.tcx.mk_alias(ty::Opaque, alias_ty)\n+                self.tcx.mk_alias(ty::Opaque, shifted_alias_ty)\n             };\n \n             self.predicates.push(\n                 ty::Binder::bind_with_vars(\n-                    ty::ProjectionPredicate {\n-                        projection_ty: alias_ty,\n-                        term: default_ty.into(),\n-                    },\n+                    ty::ProjectionPredicate { projection_ty: shifted_alias_ty, term: default_ty.into() },\n                     self.bound_vars,\n                 )\n                 .to_predicate(self.tcx),\n             );\n \n-            for bound in self.tcx.item_bounds(alias_ty.def_id).subst_iter(self.tcx, alias_ty.substs)\n+            // We walk the *un-shifted* alias ty, because we're tracking the de bruijn\n+            // binder depth, and if we were to walk `shifted_alias_ty` instead, we'd\n+            // have to reset `self.depth` back to `ty::INNERMOST` or something. It's\n+            // easier to just do this.\n+            for bound in self\n+                .tcx\n+                .item_bounds(unshifted_alias_ty.def_id)\n+                .subst_iter(self.tcx, unshifted_alias_ty.substs)\n             {\n                 bound.visit_with(self);\n             }\n@@ -506,8 +514,8 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<EarlyBinder<Ty<'\n }\n \n /// Check if a function is async.\n-fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n-    let node = tcx.hir().get_by_def_id(def_id.expect_local());\n+fn asyncness(tcx: TyCtxt<'_>, def_id: LocalDefId) -> hir::IsAsync {\n+    let node = tcx.hir().get_by_def_id(def_id);\n     node.fn_sig().map_or(hir::IsAsync::NotAsync, |sig| sig.header.asyncness)\n }\n "}, {"sha": "32eab76b3695909d16f01126dd867322e1ba6740", "filename": "config.example.toml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/config.example.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/config.example.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.example.toml?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -806,3 +806,9 @@ changelog-seen = 2\n #\n # This list must be non-empty.\n #compression-formats = [\"gz\", \"xz\"]\n+\n+# How much time should be spent compressing the tarballs. The better the\n+# compression profile, the longer compression will take.\n+#\n+# Available options: fast, balanced, best\n+#compression-profile = \"fast\""}, {"sha": "9f0111db4524ca27b2fe57f96b2f22e2cab0bc71", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -59,7 +59,6 @@ use core::cmp::Ordering;\n use core::convert::TryFrom;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::intrinsics::assume;\n use core::iter;\n #[cfg(not(no_global_oom_handling))]\n use core::iter::FromIterator;\n@@ -1240,11 +1239,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     pub fn as_ptr(&self) -> *const T {\n         // We shadow the slice method of the same name to avoid going through\n         // `deref`, which creates an intermediate reference.\n-        let ptr = self.buf.ptr();\n-        unsafe {\n-            assume(!ptr.is_null());\n-        }\n-        ptr\n+        self.buf.ptr()\n     }\n \n     /// Returns an unsafe mutable pointer to the vector's buffer, or a dangling\n@@ -1277,11 +1272,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n         // We shadow the slice method of the same name to avoid going through\n         // `deref_mut`, which creates an intermediate reference.\n-        let ptr = self.buf.ptr();\n-        unsafe {\n-            assume(!ptr.is_null());\n-        }\n-        ptr\n+        self.buf.ptr()\n     }\n \n     /// Returns a reference to the underlying allocator."}, {"sha": "f9c7eb8f9383e24a7e5f50717fd396de866c32bd", "filename": "library/core/src/iter/traits/accum.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Faccum.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -164,12 +164,13 @@ where\n     /// element is encountered:\n     ///\n     /// ```\n+    /// let f = |&x: &i32| if x < 0 { Err(\"Negative element found\") } else { Ok(x) };\n     /// let v = vec![1, 2];\n-    /// let res: Result<i32, &'static str> = v.iter().map(|&x: &i32|\n-    ///     if x < 0 { Err(\"Negative element found\") }\n-    ///     else { Ok(x) }\n-    /// ).sum();\n+    /// let res: Result<i32, _> = v.iter().map(f).sum();\n     /// assert_eq!(res, Ok(3));\n+    /// let v = vec![1, -2];\n+    /// let res: Result<i32, _> = v.iter().map(f).sum();\n+    /// assert_eq!(res, Err(\"Negative element found\"));\n     /// ```\n     fn sum<I>(iter: I) -> Result<T, E>\n     where\n@@ -187,6 +188,20 @@ where\n     /// Takes each element in the [`Iterator`]: if it is an [`Err`], no further\n     /// elements are taken, and the [`Err`] is returned. Should no [`Err`]\n     /// occur, the product of all elements is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This multiplies each number in a vector of strings,\n+    /// if a string could not be parsed the operation returns `Err`:\n+    ///\n+    /// ```\n+    /// let nums = vec![\"5\", \"10\", \"1\", \"2\"];\n+    /// let total: Result<usize, _> = nums.iter().map(|w| w.parse::<usize>()).product();\n+    /// assert_eq!(total, Ok(100));\n+    /// let nums = vec![\"5\", \"10\", \"one\", \"2\"];\n+    /// let total: Result<usize, _> = nums.iter().map(|w| w.parse::<usize>()).product();\n+    /// assert!(total.is_err());\n+    /// ```\n     fn product<I>(iter: I) -> Result<T, E>\n     where\n         I: Iterator<Item = Result<U, E>>,\n@@ -213,6 +228,9 @@ where\n     /// let words = vec![\"have\", \"a\", \"great\", \"day\"];\n     /// let total: Option<usize> = words.iter().map(|w| w.find('a')).sum();\n     /// assert_eq!(total, Some(5));\n+    /// let words = vec![\"have\", \"a\", \"good\", \"day\"];\n+    /// let total: Option<usize> = words.iter().map(|w| w.find('a')).sum();\n+    /// assert_eq!(total, None);\n     /// ```\n     fn sum<I>(iter: I) -> Option<T>\n     where\n@@ -230,6 +248,20 @@ where\n     /// Takes each element in the [`Iterator`]: if it is a [`None`], no further\n     /// elements are taken, and the [`None`] is returned. Should no [`None`]\n     /// occur, the product of all elements is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This multiplies each number in a vector of strings,\n+    /// if a string could not be parsed the operation returns `None`:\n+    ///\n+    /// ```\n+    /// let nums = vec![\"5\", \"10\", \"1\", \"2\"];\n+    /// let total: Option<usize> = nums.iter().map(|w| w.parse::<usize>().ok()).product();\n+    /// assert_eq!(total, Some(100));\n+    /// let nums = vec![\"5\", \"10\", \"one\", \"2\"];\n+    /// let total: Option<usize> = nums.iter().map(|w| w.parse::<usize>().ok()).product();\n+    /// assert_eq!(total, None);\n+    /// ```\n     fn product<I>(iter: I) -> Option<T>\n     where\n         I: Iterator<Item = Option<U>>,"}, {"sha": "16c9f668b8ea8602768e3e915cbd6410153d67af", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -3448,6 +3448,9 @@ pub trait Iterator {\n     ///\n     /// An empty iterator returns the zero value of the type.\n     ///\n+    /// `sum()` can be used to sum any type implementing [`Sum`][`core::iter::Sum`],\n+    /// including [`Option`][`Option::sum`] and [`Result`][`Result::sum`].\n+    ///\n     /// # Panics\n     ///\n     /// When calling `sum()` and a primitive integer type is being returned, this\n@@ -3478,6 +3481,9 @@ pub trait Iterator {\n     ///\n     /// An empty iterator returns the one value of the type.\n     ///\n+    /// `product()` can be used to multiply any type implementing [`Product`][`core::iter::Product`],\n+    /// including [`Option`][`Option::product`] and [`Result`][`Result::product`].\n+    ///\n     /// # Panics\n     ///\n     /// When calling `product()` and a primitive integer type is being returned,"}, {"sha": "401def1845827d84186941851ef9a70a62d592d7", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -2,7 +2,8 @@ use crate::io::prelude::*;\n \n use crate::env;\n use crate::fs::{self, File, OpenOptions};\n-use crate::io::{ErrorKind, SeekFrom};\n+use crate::io::{BorrowedBuf, ErrorKind, SeekFrom};\n+use crate::mem::MaybeUninit;\n use crate::path::Path;\n use crate::str;\n use crate::sync::Arc;\n@@ -401,6 +402,23 @@ fn file_test_io_seek_read_write() {\n     check!(fs::remove_file(&filename));\n }\n \n+#[test]\n+fn file_test_read_buf() {\n+    let tmpdir = tmpdir();\n+    let filename = &tmpdir.join(\"test\");\n+    check!(fs::write(filename, &[1, 2, 3, 4]));\n+\n+    let mut buf: [MaybeUninit<u8>; 128] = MaybeUninit::uninit_array();\n+    let mut buf = BorrowedBuf::from(buf.as_mut_slice());\n+    let mut file = check!(File::open(filename));\n+    check!(file.read_buf(buf.unfilled()));\n+    assert_eq!(buf.filled(), &[1, 2, 3, 4]);\n+    // File::read_buf should omit buffer initialization.\n+    assert_eq!(buf.init_len(), 4);\n+\n+    check!(fs::remove_file(filename));\n+}\n+\n #[test]\n fn file_test_stat_is_correct_on_is_file() {\n     let tmpdir = tmpdir();"}, {"sha": "0455a00956e6fa5345e3e20ea1217a13d66d6c47", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -8,7 +8,7 @@ use crate::io::prelude::*;\n use crate::cell::{Cell, RefCell};\n use crate::fmt;\n use crate::fs::File;\n-use crate::io::{self, BufReader, IoSlice, IoSliceMut, LineWriter, Lines};\n+use crate::io::{self, BorrowedCursor, BufReader, IoSlice, IoSliceMut, LineWriter, Lines};\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sync::{Arc, Mutex, MutexGuard, OnceLock, ReentrantMutex, ReentrantMutexGuard};\n use crate::sys::stdio;\n@@ -97,6 +97,10 @@ impl Read for StdinRaw {\n         handle_ebadf(self.0.read(buf), 0)\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        handle_ebadf(self.0.read_buf(buf), ())\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         handle_ebadf(self.0.read_vectored(bufs), 0)\n     }\n@@ -418,6 +422,9 @@ impl Read for Stdin {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.lock().read(buf)\n     }\n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.lock().read_buf(buf)\n+    }\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.lock().read_vectored(bufs)\n     }\n@@ -450,6 +457,10 @@ impl Read for StdinLock<'_> {\n         self.inner.read(buf)\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.inner.read_buf(buf)\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.inner.read_vectored(bufs)\n     }"}, {"sha": "3982d3636614e4a4ba1bf0e303b9d0d91fc76729", "filename": "library/std/src/net/tcp.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -6,7 +6,7 @@ mod tests;\n use crate::io::prelude::*;\n \n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::iter::FusedIterator;\n use crate::net::{Shutdown, SocketAddr, ToSocketAddrs};\n use crate::sys_common::net as net_imp;\n@@ -619,6 +619,10 @@ impl Read for TcpStream {\n         self.0.read(buf)\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.0.read_buf(buf)\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.0.read_vectored(bufs)\n     }\n@@ -653,6 +657,10 @@ impl Read for &TcpStream {\n         self.0.read(buf)\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.0.read_buf(buf)\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.0.read_vectored(bufs)\n     }"}, {"sha": "7a3c66e450456ff554c911822ba3f957592bbc61", "filename": "library/std/src/net/tcp/tests.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,6 +1,7 @@\n use crate::fmt;\n use crate::io::prelude::*;\n-use crate::io::{ErrorKind, IoSlice, IoSliceMut};\n+use crate::io::{BorrowedBuf, ErrorKind, IoSlice, IoSliceMut};\n+use crate::mem::MaybeUninit;\n use crate::net::test::{next_test_ip4, next_test_ip6};\n use crate::net::*;\n use crate::sync::mpsc::channel;\n@@ -279,6 +280,31 @@ fn partial_read() {\n     })\n }\n \n+#[test]\n+fn read_buf() {\n+    each_ip(&mut |addr| {\n+        let srv = t!(TcpListener::bind(&addr));\n+        let t = thread::spawn(move || {\n+            let mut s = t!(TcpStream::connect(&addr));\n+            s.write_all(&[1, 2, 3, 4]).unwrap();\n+        });\n+\n+        let mut s = t!(srv.accept()).0;\n+        let mut buf: [MaybeUninit<u8>; 128] = MaybeUninit::uninit_array();\n+        let mut buf = BorrowedBuf::from(buf.as_mut_slice());\n+        t!(s.read_buf(buf.unfilled()));\n+        assert_eq!(buf.filled(), &[1, 2, 3, 4]);\n+\n+        // FIXME: sgx uses default_read_buf that initializes the buffer.\n+        if cfg!(not(target_env = \"sgx\")) {\n+            // TcpStream::read_buf should omit buffer initialization.\n+            assert_eq!(buf.init_len(), 4);\n+        }\n+\n+        t.join().ok().expect(\"thread panicked\");\n+    })\n+}\n+\n #[test]\n fn read_vectored() {\n     each_ip(&mut |addr| {"}, {"sha": "80d73084c4f01091f6868101f8379e1b8ab6c742", "filename": "library/std/src/process.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -110,7 +110,7 @@ use crate::convert::Infallible;\n use crate::ffi::OsStr;\n use crate::fmt;\n use crate::fs;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::num::NonZeroI32;\n use crate::path::Path;\n use crate::str;\n@@ -354,6 +354,10 @@ impl Read for ChildStdout {\n         self.inner.read(buf)\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.inner.read_buf(buf)\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.inner.read_vectored(bufs)\n     }\n@@ -419,6 +423,10 @@ impl Read for ChildStderr {\n         self.inner.read(buf)\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.inner.read_buf(buf)\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.inner.read_vectored(bufs)\n     }"}, {"sha": "d7f4d335de3e334f7b8bcf25bbf01968a1240e96", "filename": "library/std/src/process/tests.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,7 +1,8 @@\n use crate::io::prelude::*;\n \n use super::{Command, Output, Stdio};\n-use crate::io::ErrorKind;\n+use crate::io::{BorrowedBuf, ErrorKind};\n+use crate::mem::MaybeUninit;\n use crate::str;\n \n fn known_command() -> Command {\n@@ -119,6 +120,37 @@ fn stdin_works() {\n     assert_eq!(out, \"foobar\\n\");\n }\n \n+#[test]\n+#[cfg_attr(any(target_os = \"vxworks\"), ignore)]\n+fn child_stdout_read_buf() {\n+    let mut cmd = if cfg!(target_os = \"windows\") {\n+        let mut cmd = Command::new(\"cmd\");\n+        cmd.arg(\"/C\").arg(\"echo abc\");\n+        cmd\n+    } else {\n+        let mut cmd = shell_cmd();\n+        cmd.arg(\"-c\").arg(\"echo abc\");\n+        cmd\n+    };\n+    cmd.stdin(Stdio::null());\n+    cmd.stdout(Stdio::piped());\n+    let child = cmd.spawn().unwrap();\n+\n+    let mut stdout = child.stdout.unwrap();\n+    let mut buf: [MaybeUninit<u8>; 128] = MaybeUninit::uninit_array();\n+    let mut buf = BorrowedBuf::from(buf.as_mut_slice());\n+    stdout.read_buf(buf.unfilled()).unwrap();\n+\n+    // ChildStdout::read_buf should omit buffer initialization.\n+    if cfg!(target_os = \"windows\") {\n+        assert_eq!(buf.filled(), b\"abc\\r\\n\");\n+        assert_eq!(buf.init_len(), 5);\n+    } else {\n+        assert_eq!(buf.filled(), b\"abc\\n\");\n+        assert_eq!(buf.init_len(), 4);\n+    };\n+}\n+\n #[test]\n #[cfg_attr(any(target_os = \"vxworks\"), ignore)]\n fn test_process_status() {"}, {"sha": "492e21d9bdb634b737e1a0d15ff2ba16adf1a732", "filename": "library/std/src/sync/mpmc/array.rs", "status": "modified", "additions": 83, "deletions": 24, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -25,7 +25,8 @@ struct Slot<T> {\n     /// The current stamp.\n     stamp: AtomicUsize,\n \n-    /// The message in this slot.\n+    /// The message in this slot. Either read out in `read` or dropped through\n+    /// `discard_all_messages`.\n     msg: UnsafeCell<MaybeUninit<T>>,\n }\n \n@@ -439,21 +440,99 @@ impl<T> Channel<T> {\n         Some(self.cap)\n     }\n \n-    /// Disconnects the channel and wakes up all blocked senders and receivers.\n+    /// Disconnects senders and wakes up all blocked receivers.\n     ///\n     /// Returns `true` if this call disconnected the channel.\n-    pub(crate) fn disconnect(&self) -> bool {\n+    pub(crate) fn disconnect_senders(&self) -> bool {\n         let tail = self.tail.fetch_or(self.mark_bit, Ordering::SeqCst);\n \n         if tail & self.mark_bit == 0 {\n-            self.senders.disconnect();\n             self.receivers.disconnect();\n             true\n         } else {\n             false\n         }\n     }\n \n+    /// Disconnects receivers and wakes up all blocked senders.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    ///\n+    /// # Safety\n+    /// May only be called once upon dropping the last receiver. The\n+    /// destruction of all other receivers must have been observed with acquire\n+    /// ordering or stronger.\n+    pub(crate) unsafe fn disconnect_receivers(&self) -> bool {\n+        let tail = self.tail.fetch_or(self.mark_bit, Ordering::SeqCst);\n+        let disconnected = if tail & self.mark_bit == 0 {\n+            self.senders.disconnect();\n+            true\n+        } else {\n+            false\n+        };\n+\n+        self.discard_all_messages(tail);\n+        disconnected\n+    }\n+\n+    /// Discards all messages.\n+    ///\n+    /// `tail` should be the current (and therefore last) value of `tail`.\n+    ///\n+    /// # Panicking\n+    /// If a destructor panics, the remaining messages are leaked, matching the\n+    /// behaviour of the unbounded channel.\n+    ///\n+    /// # Safety\n+    /// This method must only be called when dropping the last receiver. The\n+    /// destruction of all other receivers must have been observed with acquire\n+    /// ordering or stronger.\n+    unsafe fn discard_all_messages(&self, tail: usize) {\n+        debug_assert!(self.is_disconnected());\n+\n+        // Only receivers modify `head`, so since we are the last one,\n+        // this value will not change and will not be observed (since\n+        // no new messages can be sent after disconnection).\n+        let mut head = self.head.load(Ordering::Relaxed);\n+        let tail = tail & !self.mark_bit;\n+\n+        let backoff = Backoff::new();\n+        loop {\n+            // Deconstruct the head.\n+            let index = head & (self.mark_bit - 1);\n+            let lap = head & !(self.one_lap - 1);\n+\n+            // Inspect the corresponding slot.\n+            debug_assert!(index < self.buffer.len());\n+            let slot = unsafe { self.buffer.get_unchecked(index) };\n+            let stamp = slot.stamp.load(Ordering::Acquire);\n+\n+            // If the stamp is ahead of the head by 1, we may drop the message.\n+            if head + 1 == stamp {\n+                head = if index + 1 < self.cap {\n+                    // Same lap, incremented index.\n+                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n+                    head + 1\n+                } else {\n+                    // One lap forward, index wraps around to zero.\n+                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n+                    lap.wrapping_add(self.one_lap)\n+                };\n+\n+                unsafe {\n+                    (*slot.msg.get()).assume_init_drop();\n+                }\n+            // If the tail equals the head, that means the channel is empty.\n+            } else if tail == head {\n+                return;\n+            // Otherwise, a sender is about to write into the slot, so we need\n+            // to wait for it to update the stamp.\n+            } else {\n+                backoff.spin_heavy();\n+            }\n+        }\n+    }\n+\n     /// Returns `true` if the channel is disconnected.\n     pub(crate) fn is_disconnected(&self) -> bool {\n         self.tail.load(Ordering::SeqCst) & self.mark_bit != 0\n@@ -483,23 +562,3 @@ impl<T> Channel<T> {\n         head.wrapping_add(self.one_lap) == tail & !self.mark_bit\n     }\n }\n-\n-impl<T> Drop for Channel<T> {\n-    fn drop(&mut self) {\n-        // Get the index of the head.\n-        let hix = self.head.load(Ordering::Relaxed) & (self.mark_bit - 1);\n-\n-        // Loop over all slots that hold a message and drop them.\n-        for i in 0..self.len() {\n-            // Compute the index of the next slot holding a message.\n-            let index = if hix + i < self.cap { hix + i } else { hix + i - self.cap };\n-\n-            unsafe {\n-                debug_assert!(index < self.buffer.len());\n-                let slot = self.buffer.get_unchecked_mut(index);\n-                let msg = &mut *slot.msg.get();\n-                msg.as_mut_ptr().drop_in_place();\n-            }\n-        }\n-    }\n-}"}, {"sha": "2068dda393a2b632952b26e10786c181721975c0", "filename": "library/std/src/sync/mpmc/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -227,7 +227,7 @@ impl<T> Drop for Sender<T> {\n     fn drop(&mut self) {\n         unsafe {\n             match &self.flavor {\n-                SenderFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n+                SenderFlavor::Array(chan) => chan.release(|c| c.disconnect_senders()),\n                 SenderFlavor::List(chan) => chan.release(|c| c.disconnect_senders()),\n                 SenderFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n             }\n@@ -403,7 +403,7 @@ impl<T> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         unsafe {\n             match &self.flavor {\n-                ReceiverFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n+                ReceiverFlavor::Array(chan) => chan.release(|c| c.disconnect_receivers()),\n                 ReceiverFlavor::List(chan) => chan.release(|c| c.disconnect_receivers()),\n                 ReceiverFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n             }"}, {"sha": "632709fd98d8691e3fcc64cd56f4792422c03d5f", "filename": "library/std/src/sync/mpsc/sync_tests.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n use crate::env;\n+use crate::rc::Rc;\n use crate::sync::mpmc::SendTimeoutError;\n use crate::thread;\n use crate::time::Duration;\n@@ -656,3 +657,15 @@ fn issue_15761() {\n         repro()\n     }\n }\n+\n+#[test]\n+fn drop_unreceived() {\n+    let (tx, rx) = sync_channel::<Rc<()>>(1);\n+    let msg = Rc::new(());\n+    let weak = Rc::downgrade(&msg);\n+    assert!(tx.send(msg).is_ok());\n+    drop(rx);\n+    // Messages should be dropped immediately when the last receiver is destroyed.\n+    assert!(weak.upgrade().is_none());\n+    drop(tx);\n+}"}, {"sha": "0c02a107691c89fe2fea710c313b0696f2814c87", "filename": "library/std/src/sys/sgx/fd.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ffd.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,7 +1,7 @@\n use fortanix_sgx_abi::Fd;\n \n use super::abi::usercalls;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::sys::{AsInner, FromInner, IntoInner};\n \n@@ -30,6 +30,10 @@ impl FileDesc {\n         usercalls::read(self.fd, &mut [IoSliceMut::new(buf)])\n     }\n \n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        crate::io::default_read_buf(|b| self.read(b), buf)\n+    }\n+\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         usercalls::read(self.fd, bufs)\n     }"}, {"sha": "923be5eb944ec09d1d1ba1b4aa0f272090643688", "filename": "library/std/src/sys/sgx/net.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,6 +1,6 @@\n use crate::error;\n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr, ToSocketAddrs};\n use crate::sync::Arc;\n use crate::sys::fd::FileDesc;\n@@ -144,6 +144,10 @@ impl TcpStream {\n         self.inner.inner.read(buf)\n     }\n \n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.inner.inner.read_buf(buf)\n+    }\n+\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.inner.inner.read_vectored(bufs)\n     }"}, {"sha": "ce5c048f252a1572deeda25680314173ba808c0d", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -469,6 +469,15 @@ impl<'a> Read for &'a FileDesc {\n     fn read_buf(&mut self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n         (**self).read_buf(cursor)\n     }\n+\n+    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        (**self).read_vectored(bufs)\n+    }\n+\n+    #[inline]\n+    fn is_read_vectored(&self) -> bool {\n+        (**self).is_read_vectored()\n+    }\n }\n \n impl AsInner<OwnedFd> for FileDesc {"}, {"sha": "f84240d268fec3e3620f693346db6751a8bcc7d8", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,6 +1,6 @@\n use crate::cmp;\n use crate::ffi::CStr;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedBuf, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::net::{Shutdown, SocketAddr};\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd};\n@@ -242,19 +242,35 @@ impl Socket {\n         self.0.duplicate().map(Socket)\n     }\n \n-    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n+    fn recv_with_flags(&self, mut buf: BorrowedCursor<'_>, flags: c_int) -> io::Result<()> {\n         let ret = cvt(unsafe {\n-            libc::recv(self.as_raw_fd(), buf.as_mut_ptr() as *mut c_void, buf.len(), flags)\n+            libc::recv(\n+                self.as_raw_fd(),\n+                buf.as_mut().as_mut_ptr() as *mut c_void,\n+                buf.capacity(),\n+                flags,\n+            )\n         })?;\n-        Ok(ret as usize)\n+        unsafe {\n+            buf.advance(ret as usize);\n+        }\n+        Ok(())\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.recv_with_flags(buf, 0)\n+        let mut buf = BorrowedBuf::from(buf);\n+        self.recv_with_flags(buf.unfilled(), 0)?;\n+        Ok(buf.len())\n     }\n \n     pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.recv_with_flags(buf, MSG_PEEK)\n+        let mut buf = BorrowedBuf::from(buf);\n+        self.recv_with_flags(buf.unfilled(), MSG_PEEK)?;\n+        Ok(buf.len())\n+    }\n+\n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.recv_with_flags(buf, 0)\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {"}, {"sha": "dc17c9fac460a8dd3f0443623e167169614cb1fd", "filename": "library/std/src/sys/unix/pipe.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpipe.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,4 +1,4 @@\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd};\n use crate::sys::fd::FileDesc;\n@@ -49,6 +49,10 @@ impl AnonPipe {\n         self.0.read(buf)\n     }\n \n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.0.read_buf(buf)\n+    }\n+\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.0.read_vectored(bufs)\n     }"}, {"sha": "a26f20795a191eeb40a07d11fbff6e2bba186b3a", "filename": "library/std/src/sys/unix/stdio.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstdio.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,4 +1,4 @@\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::mem::ManuallyDrop;\n use crate::os::unix::io::FromRawFd;\n use crate::sys::fd::FileDesc;\n@@ -18,6 +18,10 @@ impl io::Read for Stdin {\n         unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDIN_FILENO)).read(buf) }\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDIN_FILENO)).read_buf(buf) }\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDIN_FILENO)).read_vectored(bufs) }\n     }"}, {"sha": "bbc52703f96322dffa18097a8743ee72775e60c3", "filename": "library/std/src/sys/unsupported/net.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fnet.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,5 +1,5 @@\n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::sys::unsupported;\n use crate::time::Duration;\n@@ -39,6 +39,10 @@ impl TcpStream {\n         self.0\n     }\n \n+    pub fn read_buf(&self, _buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.0\n+    }\n+\n     pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.0\n     }"}, {"sha": "d7d8f297ae586aecd61fd18088c3596adcf54a9e", "filename": "library/std/src/sys/unsupported/pipe.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fpipe.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,4 +1,4 @@\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n \n pub struct AnonPipe(!);\n \n@@ -7,6 +7,10 @@ impl AnonPipe {\n         self.0\n     }\n \n+    pub fn read_buf(&self, _buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.0\n+    }\n+\n     pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.0\n     }"}, {"sha": "191db4b60f72a690b58c6ee36acd0efcab630168", "filename": "library/std/src/sys/wasi/fd.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffd.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -2,7 +2,7 @@\n #![allow(dead_code)]\n \n use super::err2io;\n-use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::net::Shutdown;\n use crate::os::wasi::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n@@ -46,6 +46,22 @@ impl WasiFd {\n         unsafe { wasi::fd_read(self.as_raw_fd() as wasi::Fd, iovec(bufs)).map_err(err2io) }\n     }\n \n+    pub fn read_buf(&self, mut buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        unsafe {\n+            let bufs = [wasi::Iovec {\n+                buf: buf.as_mut().as_mut_ptr() as *mut u8,\n+                buf_len: buf.capacity(),\n+            }];\n+            match wasi::fd_read(self.as_raw_fd() as wasi::Fd, &bufs) {\n+                Ok(n) => {\n+                    buf.advance(n);\n+                    Ok(())\n+                }\n+                Err(e) => Err(err2io(e)),\n+            }\n+        }\n+    }\n+\n     pub fn write(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         unsafe { wasi::fd_write(self.as_raw_fd() as wasi::Fd, ciovec(bufs)).map_err(err2io) }\n     }"}, {"sha": "3a205267e34689b88671cfadcdef653225641fdc", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -441,7 +441,7 @@ impl File {\n     }\n \n     pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n-        crate::io::default_read_buf(|buf| self.read(buf), cursor)\n+        self.fd.read_buf(cursor)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {"}, {"sha": "59d94a3686dc513e94370cb2ecaa74a2c0b0ba66", "filename": "library/std/src/sys/wasi/net.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -3,7 +3,7 @@\n use super::err2io;\n use super::fd::WasiFd;\n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::os::wasi::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd};\n use crate::sys::unsupported;\n@@ -91,6 +91,10 @@ impl TcpStream {\n         self.read_vectored(&mut [IoSliceMut::new(buf)])\n     }\n \n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.socket().as_inner().read_buf(buf)\n+    }\n+\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.socket().as_inner().read(bufs)\n     }"}, {"sha": "43c0cdb657ef1d71d9cbf8fbc409fd66835724f8", "filename": "library/std/src/sys/windows/args.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -11,10 +11,11 @@ use crate::fmt;\n use crate::io;\n use crate::num::NonZeroU16;\n use crate::os::windows::prelude::*;\n-use crate::path::PathBuf;\n-use crate::sys::c;\n+use crate::path::{Path, PathBuf};\n+use crate::sys::path::get_long_path;\n use crate::sys::process::ensure_no_nuls;\n use crate::sys::windows::os::current_exe;\n+use crate::sys::{c, to_u16s};\n use crate::sys_common::wstr::WStrUnits;\n use crate::vec;\n \n@@ -311,7 +312,7 @@ pub(crate) fn make_bat_command_line(\n /// Takes a path and tries to return a non-verbatim path.\n ///\n /// This is necessary because cmd.exe does not support verbatim paths.\n-pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n+pub(crate) fn to_user_path(path: &Path) -> io::Result<Vec<u16>> {\n     use crate::ptr;\n     use crate::sys::windows::fill_utf16_buf;\n \n@@ -324,6 +325,8 @@ pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n     const N: u16 = b'N' as _;\n     const C: u16 = b'C' as _;\n \n+    let mut path = to_u16s(path)?;\n+\n     // Early return if the path is too long to remove the verbatim prefix.\n     const LEGACY_MAX_PATH: usize = 260;\n     if path.len() > LEGACY_MAX_PATH {\n@@ -337,7 +340,13 @@ pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n             fill_utf16_buf(\n                 |buffer, size| c::GetFullPathNameW(lpfilename, size, buffer, ptr::null_mut()),\n                 |full_path: &[u16]| {\n-                    if full_path == &path[4..path.len() - 1] { full_path.into() } else { path }\n+                    if full_path == &path[4..path.len() - 1] {\n+                        let mut path: Vec<u16> = full_path.into();\n+                        path.push(0);\n+                        path\n+                    } else {\n+                        path\n+                    }\n                 },\n             )\n         },\n@@ -350,7 +359,9 @@ pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n                 |buffer, size| c::GetFullPathNameW(lpfilename, size, buffer, ptr::null_mut()),\n                 |full_path: &[u16]| {\n                     if full_path == &path[6..path.len() - 1] {\n-                        full_path.into()\n+                        let mut path: Vec<u16> = full_path.into();\n+                        path.push(0);\n+                        path\n                     } else {\n                         // Restore the 'C' in \"UNC\".\n                         path[6] = b'C' as u16;\n@@ -360,6 +371,6 @@ pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n             )\n         },\n         // For everything else, leave the path unchanged.\n-        _ => Ok(path),\n+        _ => get_long_path(path, false),\n     }\n }"}, {"sha": "b290f4070e8fdb766adc3b0097906fa5d328cda8", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -327,7 +327,16 @@ impl<'a> Read for &'a Handle {\n         (**self).read(buf)\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        (**self).read_buf(buf)\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         (**self).read_vectored(bufs)\n     }\n+\n+    #[inline]\n+    fn is_read_vectored(&self) -> bool {\n+        (**self).is_read_vectored()\n+    }\n }"}, {"sha": "ee1f5482b47eedb420be2ccb3dbbb5ca080a248c", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,7 +1,7 @@\n #![unstable(issue = \"none\", feature = \"windows_net\")]\n \n use crate::cmp;\n-use crate::io::{self, IoSlice, IoSliceMut, Read};\n+use crate::io::{self, BorrowedBuf, BorrowedCursor, IoSlice, IoSliceMut, Read};\n use crate::mem;\n use crate::net::{Shutdown, SocketAddr};\n use crate::os::windows::io::{\n@@ -214,28 +214,38 @@ impl Socket {\n         Ok(Self(self.0.try_clone()?))\n     }\n \n-    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n+    fn recv_with_flags(&self, mut buf: BorrowedCursor<'_>, flags: c_int) -> io::Result<()> {\n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n-        let length = cmp::min(buf.len(), i32::MAX as usize) as i32;\n-        let result =\n-            unsafe { c::recv(self.as_raw_socket(), buf.as_mut_ptr() as *mut _, length, flags) };\n+        let length = cmp::min(buf.capacity(), i32::MAX as usize) as i32;\n+        let result = unsafe {\n+            c::recv(self.as_raw_socket(), buf.as_mut().as_mut_ptr() as *mut _, length, flags)\n+        };\n \n         match result {\n             c::SOCKET_ERROR => {\n                 let error = unsafe { c::WSAGetLastError() };\n \n                 if error == c::WSAESHUTDOWN {\n-                    Ok(0)\n+                    Ok(())\n                 } else {\n                     Err(io::Error::from_raw_os_error(error))\n                 }\n             }\n-            _ => Ok(result as usize),\n+            _ => {\n+                unsafe { buf.advance(result as usize) };\n+                Ok(())\n+            }\n         }\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        let mut buf = BorrowedBuf::from(buf);\n+        self.recv_with_flags(buf.unfilled(), 0)?;\n+        Ok(buf.len())\n+    }\n+\n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n         self.recv_with_flags(buf, 0)\n     }\n \n@@ -277,7 +287,9 @@ impl Socket {\n     }\n \n     pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.recv_with_flags(buf, c::MSG_PEEK)\n+        let mut buf = BorrowedBuf::from(buf);\n+        self.recv_with_flags(buf.unfilled(), c::MSG_PEEK)?;\n+        Ok(buf.len())\n     }\n \n     fn recv_from_with_flags("}, {"sha": "c3573d14c7f929cb87cc13faf81e1a8a40d615f3", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -220,6 +220,19 @@ fn parse_next_component(path: &OsStr, verbatim: bool) -> (&OsStr, &OsStr) {\n ///\n /// This path may or may not have a verbatim prefix.\n pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n+    let path = to_u16s(path)?;\n+    get_long_path(path, true)\n+}\n+\n+/// Get a normalized absolute path that can bypass path length limits.\n+///\n+/// Setting prefer_verbatim to true suggests a stronger preference for verbatim\n+/// paths even when not strictly necessary. This allows the Windows API to avoid\n+/// repeating our work. However, if the path may be given back to users or\n+/// passed to other application then it's preferable to use non-verbatim paths\n+/// when possible. Non-verbatim paths are better understood by users and handled\n+/// by more software.\n+pub(crate) fn get_long_path(mut path: Vec<u16>, prefer_verbatim: bool) -> io::Result<Vec<u16>> {\n     // Normally the MAX_PATH is 260 UTF-16 code units (including the NULL).\n     // However, for APIs such as CreateDirectory[1], the limit is 248.\n     //\n@@ -243,7 +256,6 @@ pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n     // \\\\?\\UNC\\\n     const UNC_PREFIX: &[u16] = &[SEP, SEP, QUERY, SEP, U, N, C, SEP];\n \n-    let mut path = to_u16s(path)?;\n     if path.starts_with(VERBATIM_PREFIX) || path.starts_with(NT_PREFIX) || path == &[0] {\n         // Early return for paths that are already verbatim or empty.\n         return Ok(path);\n@@ -275,29 +287,34 @@ pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n         |mut absolute| {\n             path.clear();\n \n-            // Secondly, add the verbatim prefix. This is easier here because we know the\n-            // path is now absolute and fully normalized (e.g. `/` has been changed to `\\`).\n-            let prefix = match absolute {\n-                // C:\\ => \\\\?\\C:\\\n-                [_, COLON, SEP, ..] => VERBATIM_PREFIX,\n-                // \\\\.\\ => \\\\?\\\n-                [SEP, SEP, DOT, SEP, ..] => {\n-                    absolute = &absolute[4..];\n-                    VERBATIM_PREFIX\n-                }\n-                // Leave \\\\?\\ and \\??\\ as-is.\n-                [SEP, SEP, QUERY, SEP, ..] | [SEP, QUERY, QUERY, SEP, ..] => &[],\n-                // \\\\ => \\\\?\\UNC\\\n-                [SEP, SEP, ..] => {\n-                    absolute = &absolute[2..];\n-                    UNC_PREFIX\n-                }\n-                // Anything else we leave alone.\n-                _ => &[],\n-            };\n-\n-            path.reserve_exact(prefix.len() + absolute.len() + 1);\n-            path.extend_from_slice(prefix);\n+            // Only prepend the prefix if needed.\n+            if prefer_verbatim || absolute.len() + 1 >= LEGACY_MAX_PATH {\n+                // Secondly, add the verbatim prefix. This is easier here because we know the\n+                // path is now absolute and fully normalized (e.g. `/` has been changed to `\\`).\n+                let prefix = match absolute {\n+                    // C:\\ => \\\\?\\C:\\\n+                    [_, COLON, SEP, ..] => VERBATIM_PREFIX,\n+                    // \\\\.\\ => \\\\?\\\n+                    [SEP, SEP, DOT, SEP, ..] => {\n+                        absolute = &absolute[4..];\n+                        VERBATIM_PREFIX\n+                    }\n+                    // Leave \\\\?\\ and \\??\\ as-is.\n+                    [SEP, SEP, QUERY, SEP, ..] | [SEP, QUERY, QUERY, SEP, ..] => &[],\n+                    // \\\\ => \\\\?\\UNC\\\n+                    [SEP, SEP, ..] => {\n+                        absolute = &absolute[2..];\n+                        UNC_PREFIX\n+                    }\n+                    // Anything else we leave alone.\n+                    _ => &[],\n+                };\n+\n+                path.reserve_exact(prefix.len() + absolute.len() + 1);\n+                path.extend_from_slice(prefix);\n+            } else {\n+                path.reserve_exact(absolute.len() + 1);\n+            }\n             path.extend_from_slice(absolute);\n             path.push(0);\n         },"}, {"sha": "0780b29584da40f11c285dbf2540b88977993295", "filename": "library/std/src/sys/windows/pipe.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,7 +1,7 @@\n use crate::os::windows::prelude::*;\n \n use crate::ffi::OsStr;\n-use crate::io::{self, IoSlice, IoSliceMut, Read};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, Read};\n use crate::mem;\n use crate::path::Path;\n use crate::ptr;\n@@ -252,6 +252,28 @@ impl AnonPipe {\n         }\n     }\n \n+    pub fn read_buf(&self, mut buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        let result = unsafe {\n+            let len = crate::cmp::min(buf.capacity(), c::DWORD::MAX as usize) as c::DWORD;\n+            self.alertable_io_internal(c::ReadFileEx, buf.as_mut().as_mut_ptr() as _, len)\n+        };\n+\n+        match result {\n+            // The special treatment of BrokenPipe is to deal with Windows\n+            // pipe semantics, which yields this error when *reading* from\n+            // a pipe after the other end has closed; we interpret that as\n+            // EOF on the pipe.\n+            Err(ref e) if e.kind() == io::ErrorKind::BrokenPipe => Ok(()),\n+            Err(e) => Err(e),\n+            Ok(n) => {\n+                unsafe {\n+                    buf.advance(n);\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.inner.read_vectored(bufs)\n     }"}, {"sha": "1c73b64e250ea76264536420eaec9f291d629ccf", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -266,11 +266,7 @@ impl Command {\n         let (program, mut cmd_str) = if is_batch_file {\n             (\n                 command_prompt()?,\n-                args::make_bat_command_line(\n-                    &args::to_user_path(program)?,\n-                    &self.args,\n-                    self.force_quotes_enabled,\n-                )?,\n+                args::make_bat_command_line(&program, &self.args, self.force_quotes_enabled)?,\n             )\n         } else {\n             let cmd_str = make_command_line(&self.program, &self.args, self.force_quotes_enabled)?;\n@@ -410,7 +406,7 @@ fn resolve_exe<'a>(\n         if has_exe_suffix {\n             // The application name is a path to a `.exe` file.\n             // Let `CreateProcessW` figure out if it exists or not.\n-            return path::maybe_verbatim(Path::new(exe_path));\n+            return args::to_user_path(Path::new(exe_path));\n         }\n         let mut path = PathBuf::from(exe_path);\n \n@@ -422,7 +418,7 @@ fn resolve_exe<'a>(\n             // It's ok to use `set_extension` here because the intent is to\n             // remove the extension that was just added.\n             path.set_extension(\"\");\n-            return path::maybe_verbatim(&path);\n+            return args::to_user_path(&path);\n         }\n     } else {\n         ensure_no_nuls(exe_path)?;\n@@ -510,7 +506,7 @@ where\n /// Check if a file exists without following symlinks.\n fn program_exists(path: &Path) -> Option<Vec<u16>> {\n     unsafe {\n-        let path = path::maybe_verbatim(path).ok()?;\n+        let path = args::to_user_path(path).ok()?;\n         // Getting attributes using `GetFileAttributesW` does not follow symlinks\n         // and it will almost always be successful if the link exists.\n         // There are some exceptions for special system files (e.g. the pagefile)"}, {"sha": "eb427dbda2393253e495e0ef3548f8309a1ddd17", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -4,7 +4,7 @@ mod tests;\n use crate::cmp;\n use crate::convert::{TryFrom, TryInto};\n use crate::fmt;\n-use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, ErrorKind, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::ptr;\n@@ -272,6 +272,10 @@ impl TcpStream {\n         self.inner.read(buf)\n     }\n \n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.inner.read_buf(buf)\n+    }\n+\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.inner.read_vectored(bufs)\n     }"}, {"sha": "27236e191fdebb8589c97a62e10c4d30b320fe3d", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -11,6 +11,17 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"atty\"\n+version = \"0.2.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\n+dependencies = [\n+ \"hermit-abi\",\n+ \"libc\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"autocfg\"\n version = \"1.1.0\"\n@@ -36,6 +47,7 @@ dependencies = [\n name = \"bootstrap\"\n version = \"0.0.0\"\n dependencies = [\n+ \"atty\",\n  \"build_helper\",\n  \"cc\",\n  \"cmake\",\n@@ -55,6 +67,7 @@ dependencies = [\n  \"sha2\",\n  \"sysinfo\",\n  \"tar\",\n+ \"termcolor\",\n  \"toml\",\n  \"walkdir\",\n  \"windows\",\n@@ -636,6 +649,15 @@ dependencies = [\n  \"xattr\",\n ]\n \n+[[package]]\n+name = \"termcolor\"\n+version = \"1.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"be55cf8942feac5c765c2c993422806843c9a9a45d4d5c407ad6dd2ea95eb9b6\"\n+dependencies = [\n+ \"winapi-util\",\n+]\n+\n [[package]]\n name = \"thread_local\"\n version = \"1.1.4\""}, {"sha": "5c659800bdb6c15413827384d991168cdfefd838", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -30,6 +30,7 @@ path = \"bin/sccache-plus-cl.rs\"\n test = false\n \n [dependencies]\n+atty = \"0.2.14\"\n build_helper = { path = \"../tools/build_helper\" }\n cmake = \"0.1.38\"\n filetime = \"0.2\"\n@@ -45,6 +46,7 @@ serde_derive = \"1.0.137\"\n serde_json = \"1.0.2\"\n sha2 = \"0.10\"\n tar = \"0.4\"\n+termcolor = \"1.2.0\"\n toml = \"0.5\"\n ignore = \"0.4.10\"\n opener = \"0.5\""}, {"sha": "95625170478f66a162cdf310f795e6b2e0085689", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -87,6 +87,9 @@ pub struct Config {\n     pub patch_binaries_for_nix: bool,\n     pub stage0_metadata: Stage0Metadata,\n \n+    pub stdout_is_tty: bool,\n+    pub stderr_is_tty: bool,\n+\n     pub on_fail: Option<String>,\n     pub stage: u32,\n     pub keep_stage: Vec<u32>,\n@@ -191,6 +194,7 @@ pub struct Config {\n     pub dist_sign_folder: Option<PathBuf>,\n     pub dist_upload_addr: Option<String>,\n     pub dist_compression_formats: Option<Vec<String>>,\n+    pub dist_compression_profile: String,\n     pub dist_include_mingw_linker: bool,\n \n     // libstd features\n@@ -703,6 +707,7 @@ define_config! {\n         src_tarball: Option<bool> = \"src-tarball\",\n         missing_tools: Option<bool> = \"missing-tools\",\n         compression_formats: Option<Vec<String>> = \"compression-formats\",\n+        compression_profile: Option<String> = \"compression-profile\",\n         include_mingw_linker: Option<bool> = \"include-mingw-linker\",\n     }\n }\n@@ -821,6 +826,10 @@ impl Config {\n         config.deny_warnings = true;\n         config.bindir = \"bin\".into();\n         config.dist_include_mingw_linker = true;\n+        config.dist_compression_profile = \"fast\".into();\n+\n+        config.stdout_is_tty = atty::is(atty::Stream::Stdout);\n+        config.stderr_is_tty = atty::is(atty::Stream::Stderr);\n \n         // set by build.rs\n         config.build = TargetSelection::from_user(&env!(\"BUILD_TRIPLE\"));\n@@ -1308,6 +1317,7 @@ impl Config {\n             config.dist_sign_folder = t.sign_folder.map(PathBuf::from);\n             config.dist_upload_addr = t.upload_addr;\n             config.dist_compression_formats = t.compression_formats;\n+            set(&mut config.dist_compression_profile, t.compression_profile);\n             set(&mut config.rust_dist_src, t.src_tarball);\n             set(&mut config.missing_tools, t.missing_tools);\n             set(&mut config.dist_include_mingw_linker, t.include_mingw_linker)"}, {"sha": "ee271c3fb519dc58a4278360a3f42ee3f7f43ed0", "filename": "src/bootstrap/defaults/config.user.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -11,3 +11,7 @@ extended = true\n [llvm]\n # Most users installing from source want to build all parts of the project from source, not just rustc itself.\n download-ci-llvm = false\n+\n+[dist]\n+# Use better compression when preparing tarballs.\n+compression-profile = \"balanced\""}, {"sha": "47a970c782e53aaa8a6dfea267f113eb990429da", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -55,6 +55,7 @@ mod format;\n mod install;\n mod metadata;\n mod native;\n+mod render_tests;\n mod run;\n mod sanity;\n mod setup;\n@@ -88,6 +89,7 @@ pub use crate::builder::PathSet;\n use crate::cache::{Interned, INTERNER};\n pub use crate::config::Config;\n pub use crate::flags::Subcommand;\n+use termcolor::{ColorChoice, StandardStream, WriteColor};\n \n const LLVM_TOOLS: &[&str] = &[\n     \"llvm-cov\",      // used to generate coverage report\n@@ -1582,6 +1584,31 @@ to download LLVM rather than building it.\n \n         self.config.ninja_in_file\n     }\n+\n+    pub fn colored_stdout<R, F: FnOnce(&mut dyn WriteColor) -> R>(&self, f: F) -> R {\n+        self.colored_stream_inner(StandardStream::stdout, self.config.stdout_is_tty, f)\n+    }\n+\n+    pub fn colored_stderr<R, F: FnOnce(&mut dyn WriteColor) -> R>(&self, f: F) -> R {\n+        self.colored_stream_inner(StandardStream::stderr, self.config.stderr_is_tty, f)\n+    }\n+\n+    fn colored_stream_inner<R, F, C>(&self, constructor: C, is_tty: bool, f: F) -> R\n+    where\n+        C: Fn(ColorChoice) -> StandardStream,\n+        F: FnOnce(&mut dyn WriteColor) -> R,\n+    {\n+        let choice = match self.config.color {\n+            flags::Color::Always => ColorChoice::Always,\n+            flags::Color::Never => ColorChoice::Never,\n+            flags::Color::Auto if !is_tty => ColorChoice::Never,\n+            flags::Color::Auto => ColorChoice::Auto,\n+        };\n+        let mut stream = constructor(choice);\n+        let result = f(&mut stream);\n+        stream.reset().unwrap();\n+        result\n+    }\n }\n \n #[cfg(unix)]"}, {"sha": "5f254761aa19f21c18f6360e9e6008eec5422b70", "filename": "src/bootstrap/metrics.rs", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2Fmetrics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2Fmetrics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetrics.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -51,6 +51,7 @@ impl BuildMetrics {\n             duration_excluding_children_sec: Duration::ZERO,\n \n             children: Vec::new(),\n+            tests: Vec::new(),\n         });\n     }\n \n@@ -72,6 +73,16 @@ impl BuildMetrics {\n         }\n     }\n \n+    pub(crate) fn record_test(&self, name: &str, outcome: TestOutcome) {\n+        let mut state = self.state.borrow_mut();\n+        state\n+            .running_steps\n+            .last_mut()\n+            .unwrap()\n+            .tests\n+            .push(Test { name: name.to_string(), outcome });\n+    }\n+\n     fn collect_stats(&self, state: &mut MetricsState) {\n         let step = state.running_steps.last_mut().unwrap();\n \n@@ -125,6 +136,14 @@ impl BuildMetrics {\n     }\n \n     fn prepare_json_step(&self, step: StepMetrics) -> JsonNode {\n+        let mut children = Vec::new();\n+        children.extend(step.children.into_iter().map(|child| self.prepare_json_step(child)));\n+        children.extend(\n+            step.tests\n+                .into_iter()\n+                .map(|test| JsonNode::Test { name: test.name, outcome: test.outcome }),\n+        );\n+\n         JsonNode::RustbuildStep {\n             type_: step.type_,\n             debug_repr: step.debug_repr,\n@@ -135,11 +154,7 @@ impl BuildMetrics {\n                     / step.duration_excluding_children_sec.as_secs_f64(),\n             },\n \n-            children: step\n-                .children\n-                .into_iter()\n-                .map(|child| self.prepare_json_step(child))\n-                .collect(),\n+            children,\n         }\n     }\n }\n@@ -161,6 +176,12 @@ struct StepMetrics {\n     duration_excluding_children_sec: Duration,\n \n     children: Vec<StepMetrics>,\n+    tests: Vec<Test>,\n+}\n+\n+struct Test {\n+    name: String,\n+    outcome: TestOutcome,\n }\n \n #[derive(Serialize, Deserialize)]\n@@ -190,6 +211,19 @@ enum JsonNode {\n \n         children: Vec<JsonNode>,\n     },\n+    Test {\n+        name: String,\n+        #[serde(flatten)]\n+        outcome: TestOutcome,\n+    },\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(tag = \"outcome\", rename_all = \"snake_case\")]\n+pub(crate) enum TestOutcome {\n+    Passed,\n+    Failed,\n+    Ignored { ignore_reason: Option<String> },\n }\n \n #[derive(Serialize, Deserialize)]"}, {"sha": "af2370d439e6b1d1df65acdd9fda2733ac942a42", "filename": "src/bootstrap/render_tests.rs", "status": "added", "additions": 376, "deletions": 0, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2Frender_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2Frender_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frender_tests.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,376 @@\n+//! This module renders the JSON output of libtest into a human-readable form, trying to be as\n+//! similar to libtest's native output as possible.\n+//!\n+//! This is needed because we need to use libtest in JSON mode to extract granluar information\n+//! about the executed tests. Doing so suppresses the human-readable output, and (compared to Cargo\n+//! and rustc) libtest doesn't include the rendered human-readable output as a JSON field. We had\n+//! to reimplement all the rendering logic in this module because of that.\n+\n+use crate::builder::Builder;\n+use std::io::{BufRead, BufReader, Write};\n+use std::process::{ChildStdout, Command, Stdio};\n+use std::time::Duration;\n+use termcolor::{Color, ColorSpec, WriteColor};\n+\n+const TERSE_TESTS_PER_LINE: usize = 88;\n+\n+pub(crate) fn add_flags_and_try_run_tests(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n+    if cmd.get_args().position(|arg| arg == \"--\").is_none() {\n+        cmd.arg(\"--\");\n+    }\n+    cmd.args(&[\"-Z\", \"unstable-options\", \"--format\", \"json\"]);\n+\n+    try_run_tests(builder, cmd)\n+}\n+\n+pub(crate) fn try_run_tests(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n+    if builder.config.dry_run() {\n+        return true;\n+    }\n+\n+    if !run_tests(builder, cmd) {\n+        if builder.fail_fast {\n+            crate::detail_exit(1);\n+        } else {\n+            let mut failures = builder.delayed_failures.borrow_mut();\n+            failures.push(format!(\"{cmd:?}\"));\n+            false\n+        }\n+    } else {\n+        true\n+    }\n+}\n+\n+fn run_tests(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n+    cmd.stdout(Stdio::piped());\n+\n+    builder.verbose(&format!(\"running: {cmd:?}\"));\n+\n+    let mut process = cmd.spawn().unwrap();\n+\n+    // This runs until the stdout of the child is closed, which means the child exited. We don't\n+    // run this on another thread since the builder is not Sync.\n+    Renderer::new(process.stdout.take().unwrap(), builder).render_all();\n+\n+    let result = process.wait_with_output().unwrap();\n+    if !result.status.success() && builder.is_verbose() {\n+        println!(\n+            \"\\n\\ncommand did not execute successfully: {cmd:?}\\n\\\n+             expected success, got: {}\",\n+            result.status\n+        );\n+    }\n+\n+    result.status.success()\n+}\n+\n+struct Renderer<'a> {\n+    stdout: BufReader<ChildStdout>,\n+    failures: Vec<TestOutcome>,\n+    benches: Vec<BenchOutcome>,\n+    builder: &'a Builder<'a>,\n+    tests_count: Option<usize>,\n+    executed_tests: usize,\n+    terse_tests_in_line: usize,\n+}\n+\n+impl<'a> Renderer<'a> {\n+    fn new(stdout: ChildStdout, builder: &'a Builder<'a>) -> Self {\n+        Self {\n+            stdout: BufReader::new(stdout),\n+            benches: Vec::new(),\n+            failures: Vec::new(),\n+            builder,\n+            tests_count: None,\n+            executed_tests: 0,\n+            terse_tests_in_line: 0,\n+        }\n+    }\n+\n+    fn render_all(mut self) {\n+        let mut line = String::new();\n+        loop {\n+            line.clear();\n+            match self.stdout.read_line(&mut line) {\n+                Ok(_) => {}\n+                Err(err) if err.kind() == std::io::ErrorKind::UnexpectedEof => break,\n+                Err(err) => panic!(\"failed to read output of test runner: {err}\"),\n+            }\n+            if line.is_empty() {\n+                break;\n+            }\n+\n+            let trimmed = line.trim();\n+            if trimmed.starts_with(\"{\") && trimmed.ends_with(\"}\") {\n+                self.render_message(match serde_json::from_str(&trimmed) {\n+                    Ok(parsed) => parsed,\n+                    Err(err) => {\n+                        panic!(\"failed to parse libtest json output; error: {err}, line: {line:?}\");\n+                    }\n+                });\n+            } else {\n+                // Handle non-JSON output, for example when --nocapture is passed.\n+                print!(\"{line}\");\n+                let _ = std::io::stdout().flush();\n+            }\n+        }\n+    }\n+\n+    fn render_test_outcome(&mut self, outcome: Outcome<'_>, test: &TestOutcome) {\n+        self.executed_tests += 1;\n+\n+        #[cfg(feature = \"build-metrics\")]\n+        self.builder.metrics.record_test(\n+            &test.name,\n+            match outcome {\n+                Outcome::Ok | Outcome::BenchOk => crate::metrics::TestOutcome::Passed,\n+                Outcome::Failed => crate::metrics::TestOutcome::Failed,\n+                Outcome::Ignored { reason } => crate::metrics::TestOutcome::Ignored {\n+                    ignore_reason: reason.map(|s| s.to_string()),\n+                },\n+            },\n+        );\n+\n+        if self.builder.config.verbose_tests {\n+            self.render_test_outcome_verbose(outcome, test);\n+        } else {\n+            self.render_test_outcome_terse(outcome, test);\n+        }\n+    }\n+\n+    fn render_test_outcome_verbose(&self, outcome: Outcome<'_>, test: &TestOutcome) {\n+        print!(\"test {} ... \", test.name);\n+        self.builder.colored_stdout(|stdout| outcome.write_long(stdout)).unwrap();\n+        if let Some(exec_time) = test.exec_time {\n+            print!(\" ({exec_time:.2?})\");\n+        }\n+        println!();\n+    }\n+\n+    fn render_test_outcome_terse(&mut self, outcome: Outcome<'_>, _: &TestOutcome) {\n+        if self.terse_tests_in_line != 0 && self.terse_tests_in_line % TERSE_TESTS_PER_LINE == 0 {\n+            if let Some(total) = self.tests_count {\n+                let total = total.to_string();\n+                let executed = format!(\"{:>width$}\", self.executed_tests - 1, width = total.len());\n+                print!(\" {executed}/{total}\");\n+            }\n+            println!();\n+            self.terse_tests_in_line = 0;\n+        }\n+\n+        self.terse_tests_in_line += 1;\n+        self.builder.colored_stdout(|stdout| outcome.write_short(stdout)).unwrap();\n+        let _ = std::io::stdout().flush();\n+    }\n+\n+    fn render_suite_outcome(&self, outcome: Outcome<'_>, suite: &SuiteOutcome) {\n+        // The terse output doesn't end with a newline, so we need to add it ourselves.\n+        if !self.builder.config.verbose_tests {\n+            println!();\n+        }\n+\n+        if !self.failures.is_empty() {\n+            println!(\"\\nfailures:\\n\");\n+            for failure in &self.failures {\n+                if let Some(stdout) = &failure.stdout {\n+                    println!(\"---- {} stdout ----\", failure.name);\n+                    println!(\"{stdout}\");\n+                }\n+            }\n+\n+            println!(\"\\nfailures:\");\n+            for failure in &self.failures {\n+                println!(\"    {}\", failure.name);\n+            }\n+        }\n+\n+        if !self.benches.is_empty() {\n+            println!(\"\\nbenchmarks:\");\n+\n+            let mut rows = Vec::new();\n+            for bench in &self.benches {\n+                rows.push((\n+                    &bench.name,\n+                    format!(\"{:.2?}/iter\", Duration::from_nanos(bench.median)),\n+                    format!(\"+/- {:.2?}\", Duration::from_nanos(bench.deviation)),\n+                ));\n+            }\n+\n+            let max_0 = rows.iter().map(|r| r.0.len()).max().unwrap_or(0);\n+            let max_1 = rows.iter().map(|r| r.1.len()).max().unwrap_or(0);\n+            let max_2 = rows.iter().map(|r| r.2.len()).max().unwrap_or(0);\n+            for row in &rows {\n+                println!(\"    {:<max_0$} {:>max_1$} {:>max_2$}\", row.0, row.1, row.2);\n+            }\n+        }\n+\n+        print!(\"\\ntest result: \");\n+        self.builder.colored_stdout(|stdout| outcome.write_long(stdout)).unwrap();\n+        println!(\n+            \". {} passed; {} failed; {} ignored; {} measured; {} filtered out; \\\n+             finished in {:.2?}\\n\",\n+            suite.passed,\n+            suite.failed,\n+            suite.ignored,\n+            suite.measured,\n+            suite.filtered_out,\n+            Duration::from_secs_f64(suite.exec_time)\n+        );\n+    }\n+\n+    fn render_message(&mut self, message: Message) {\n+        match message {\n+            Message::Suite(SuiteMessage::Started { test_count }) => {\n+                println!(\"\\nrunning {test_count} tests\");\n+                self.executed_tests = 0;\n+                self.terse_tests_in_line = 0;\n+                self.tests_count = Some(test_count);\n+            }\n+            Message::Suite(SuiteMessage::Ok(outcome)) => {\n+                self.render_suite_outcome(Outcome::Ok, &outcome);\n+            }\n+            Message::Suite(SuiteMessage::Failed(outcome)) => {\n+                self.render_suite_outcome(Outcome::Failed, &outcome);\n+            }\n+            Message::Bench(outcome) => {\n+                // The formatting for benchmarks doesn't replicate 1:1 the formatting libtest\n+                // outputs, mostly because libtest's formatting is broken in terse mode, which is\n+                // the default used by our monorepo. We use a different formatting instead:\n+                // successful benchmarks are just showed as \"benchmarked\"/\"b\", and the details are\n+                // outputted at the bottom like failures.\n+                let fake_test_outcome = TestOutcome {\n+                    name: outcome.name.clone(),\n+                    exec_time: None,\n+                    stdout: None,\n+                    message: None,\n+                };\n+                self.render_test_outcome(Outcome::BenchOk, &fake_test_outcome);\n+                self.benches.push(outcome);\n+            }\n+            Message::Test(TestMessage::Ok(outcome)) => {\n+                self.render_test_outcome(Outcome::Ok, &outcome);\n+            }\n+            Message::Test(TestMessage::Ignored(outcome)) => {\n+                self.render_test_outcome(\n+                    Outcome::Ignored { reason: outcome.message.as_deref() },\n+                    &outcome,\n+                );\n+            }\n+            Message::Test(TestMessage::Failed(outcome)) => {\n+                self.render_test_outcome(Outcome::Failed, &outcome);\n+                self.failures.push(outcome);\n+            }\n+            Message::Test(TestMessage::Timeout { name }) => {\n+                println!(\"test {name} has been running for a long time\");\n+            }\n+            Message::Test(TestMessage::Started) => {} // Not useful\n+        }\n+    }\n+}\n+\n+enum Outcome<'a> {\n+    Ok,\n+    BenchOk,\n+    Failed,\n+    Ignored { reason: Option<&'a str> },\n+}\n+\n+impl Outcome<'_> {\n+    fn write_short(&self, writer: &mut dyn WriteColor) -> Result<(), std::io::Error> {\n+        match self {\n+            Outcome::Ok => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Green)))?;\n+                write!(writer, \".\")?;\n+            }\n+            Outcome::BenchOk => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Cyan)))?;\n+                write!(writer, \"b\")?;\n+            }\n+            Outcome::Failed => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Red)))?;\n+                write!(writer, \"F\")?;\n+            }\n+            Outcome::Ignored { .. } => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Yellow)))?;\n+                write!(writer, \"i\")?;\n+            }\n+        }\n+        writer.reset()\n+    }\n+\n+    fn write_long(&self, writer: &mut dyn WriteColor) -> Result<(), std::io::Error> {\n+        match self {\n+            Outcome::Ok => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Green)))?;\n+                write!(writer, \"ok\")?;\n+            }\n+            Outcome::BenchOk => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Cyan)))?;\n+                write!(writer, \"benchmarked\")?;\n+            }\n+            Outcome::Failed => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Red)))?;\n+                write!(writer, \"FAILED\")?;\n+            }\n+            Outcome::Ignored { reason } => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Yellow)))?;\n+                write!(writer, \"ignored\")?;\n+                if let Some(reason) = reason {\n+                    write!(writer, \", {reason}\")?;\n+                }\n+            }\n+        }\n+        writer.reset()\n+    }\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+#[serde(tag = \"type\", rename_all = \"snake_case\")]\n+enum Message {\n+    Suite(SuiteMessage),\n+    Test(TestMessage),\n+    Bench(BenchOutcome),\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+#[serde(tag = \"event\", rename_all = \"snake_case\")]\n+enum SuiteMessage {\n+    Ok(SuiteOutcome),\n+    Failed(SuiteOutcome),\n+    Started { test_count: usize },\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+struct SuiteOutcome {\n+    passed: usize,\n+    failed: usize,\n+    ignored: usize,\n+    measured: usize,\n+    filtered_out: usize,\n+    exec_time: f64,\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+#[serde(tag = \"event\", rename_all = \"snake_case\")]\n+enum TestMessage {\n+    Ok(TestOutcome),\n+    Failed(TestOutcome),\n+    Ignored(TestOutcome),\n+    Timeout { name: String },\n+    Started,\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+struct BenchOutcome {\n+    name: String,\n+    median: u64,\n+    deviation: u64,\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+struct TestOutcome {\n+    name: String,\n+    exec_time: Option<f64>,\n+    stdout: Option<String>,\n+    message: Option<String>,\n+}"}, {"sha": "7fa8a4d9d7f8afdf9044ba1195bd1be2bdc8db79", "filename": "src/bootstrap/tarball.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2Ftarball.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2Ftarball.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftarball.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -318,6 +318,7 @@ impl<'a> Tarball<'a> {\n             assert!(!formats.is_empty(), \"dist.compression-formats can't be empty\");\n             cmd.arg(\"--compression-formats\").arg(formats.join(\",\"));\n         }\n+        cmd.args(&[\"--compression-profile\", &self.builder.config.dist_compression_profile]);\n         self.builder.run(&mut cmd);\n \n         // Ensure there are no symbolic links in the tarball. In particular,"}, {"sha": "29d37c09d884c125ada52418977f64b1d07e0763", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -20,6 +20,7 @@ use crate::dist;\n use crate::doc::DocumentationFormat;\n use crate::flags::Subcommand;\n use crate::native;\n+use crate::render_tests::add_flags_and_try_run_tests;\n use crate::tool::{self, SourceType, Tool};\n use crate::toolstate::ToolState;\n use crate::util::{self, add_link_lib_path, dylib_path, dylib_path_var, output, t};\n@@ -123,7 +124,7 @@ impl Step for CrateJsonDocLint {\n             SourceType::InTree,\n             &[],\n         );\n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -172,7 +173,7 @@ You can skip linkcheck with --exclude src/tools/linkchecker\"\n             SourceType::InTree,\n             &[],\n         );\n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n \n         // Build all the default documentation.\n         builder.default_doc(&[]);\n@@ -333,7 +334,7 @@ impl Step for Cargo {\n \n         cargo.env(\"PATH\", &path_for_cargo(builder, compiler));\n \n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -392,7 +393,7 @@ impl Step for RustAnalyzer {\n         cargo.add_rustc_lib_path(builder, compiler);\n         cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n-        builder.run(&mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -445,7 +446,7 @@ impl Step for Rustfmt {\n \n         cargo.add_rustc_lib_path(builder, compiler);\n \n-        builder.run(&mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -496,7 +497,7 @@ impl Step for RustDemangler {\n \n         cargo.add_rustc_lib_path(builder, compiler);\n \n-        builder.run(&mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -637,8 +638,7 @@ impl Step for Miri {\n         // Forward test filters.\n         cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n-        let mut cargo = Command::from(cargo);\n-        builder.run(&mut cargo);\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n \n         // # Run `cargo miri test`.\n         // This is just a smoke test (Miri's own CI invokes this in a bunch of different ways and ensures\n@@ -711,7 +711,7 @@ impl Step for CompiletestTest {\n         );\n         cargo.allow_features(\"test\");\n \n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -1193,7 +1193,7 @@ impl Step for TidySelfTest {\n             SourceType::InTree,\n             &[],\n         );\n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -1620,9 +1620,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             cmd.arg(\"--verbose\");\n         }\n \n-        if !builder.config.verbose_tests {\n-            cmd.arg(\"--quiet\");\n-        }\n+        cmd.arg(\"--json\");\n \n         let mut llvm_components_passed = false;\n         let mut copts_passed = false;\n@@ -1773,7 +1771,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             suite, mode, &compiler.host, target\n         ));\n         let _time = util::timeit(&builder);\n-        try_run(builder, &mut cmd);\n+        crate::render_tests::try_run_tests(builder, &mut cmd);\n \n         if let Some(compare_mode) = compare_mode {\n             cmd.arg(\"--compare-mode\").arg(compare_mode);\n@@ -1782,7 +1780,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n                 suite, mode, compare_mode, &compiler.host, target\n             ));\n             let _time = util::timeit(&builder);\n-            try_run(builder, &mut cmd);\n+            crate::render_tests::try_run_tests(builder, &mut cmd);\n         }\n     }\n }\n@@ -2184,9 +2182,8 @@ impl Step for Crate {\n         cargo.arg(\"--\");\n         cargo.args(&builder.config.cmd.test_args());\n \n-        if !builder.config.verbose_tests {\n-            cargo.arg(\"--quiet\");\n-        }\n+        cargo.arg(\"-Z\").arg(\"unstable-options\");\n+        cargo.arg(\"--format\").arg(\"json\");\n \n         if target.contains(\"emscripten\") {\n             cargo.env(\n@@ -2214,7 +2211,7 @@ impl Step for Crate {\n             target\n         ));\n         let _time = util::timeit(&builder);\n-        try_run(builder, &mut cargo.into());\n+        crate::render_tests::try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -2334,7 +2331,7 @@ impl Step for CrateRustdoc {\n         ));\n         let _time = util::timeit(&builder);\n \n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -2395,17 +2392,13 @@ impl Step for CrateRustdocJsonTypes {\n             cargo.arg(\"'-Ctarget-feature=-crt-static'\");\n         }\n \n-        if !builder.config.verbose_tests {\n-            cargo.arg(\"--quiet\");\n-        }\n-\n         builder.info(&format!(\n             \"{} rustdoc-json-types stage{} ({} -> {})\",\n             test_kind, compiler.stage, &compiler.host, target\n         ));\n         let _time = util::timeit(&builder);\n \n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -2574,7 +2567,7 @@ impl Step for Bootstrap {\n         // rustbuild tests are racy on directory creation so just run them one at a time.\n         // Since there's not many this shouldn't be a problem.\n         cmd.arg(\"--test-threads=1\");\n-        try_run(builder, &mut cmd);\n+        add_flags_and_try_run_tests(builder, &mut cmd);\n     }\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -2655,7 +2648,7 @@ impl Step for ReplacePlaceholderTest {\n             SourceType::InTree,\n             &[],\n         );\n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {"}, {"sha": "2089bf3871626d80375311930edb2d75f9b22058", "filename": "src/ci/docker/host-x86_64/dist-x86_64-illumos/Dockerfile", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-illumos%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-illumos%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-illumos%2FDockerfile?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -9,10 +9,10 @@ RUN bash /tmp/cross-apt-packages.sh\n # Required for cross-build gcc\n RUN apt-get update && \\\n     apt-get install -y --no-install-recommends \\\n-      libgmp-dev \\\n-      libmpfr-dev \\\n-      libmpc-dev \\\n-      && rm -rf /var/lib/apt/lists/*\n+    libgmp-dev \\\n+    libmpfr-dev \\\n+    libmpc-dev \\\n+    && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/illumos-toolchain.sh /tmp/\n \n@@ -28,6 +28,7 @@ RUN /scripts/cmake.sh\n \n ENV \\\n     AR_x86_64_unknown_illumos=x86_64-illumos-ar \\\n+    RANLIB_x86_64_unknown_illumos=x86_64-illumos-ranlib \\\n     CC_x86_64_unknown_illumos=x86_64-illumos-gcc \\\n     CXX_x86_64_unknown_illumos=x86_64-illumos-g++\n "}, {"sha": "fc4ed57fb82575848e6c4138e49fe3adc6e29d54", "filename": "src/ci/run.sh", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -58,6 +58,15 @@ RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-manage-submodules\"\n RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-locked-deps\"\n RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-cargo-native-static\"\n RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set rust.codegen-units-std=1\"\n+RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set dist.compression-profile=best\"\n+\n+# When building for mingw, limit the number of parallel linker jobs during\n+# the LLVM build, as not to run out of memory.\n+# This is an attempt to fix the spurious build error tracked by\n+# https://github.com/rust-lang/rust/issues/108227.\n+if isWindows && [[ ${CUSTOM_MINGW-0} -eq 1 ]]; then\n+    RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set llvm.link-jobs=4\"\n+fi\n \n # Only produce xz tarballs on CI. gz tarballs will be generated by the release\n # process by recompressing the existing xz ones. This decreases the storage"}, {"sha": "15d090969743630bff549a1b068bcaa8174e5ee3", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1 +1 @@\n-Subproject commit 4a3c588b1f0a8e2dc8dd8789dbf3b6a71b02ed49\n+Subproject commit 15d090969743630bff549a1b068bcaa8174e5ee3"}, {"sha": "a8926b29ac83f3de4694c7e69aaf2328fe58c3e7", "filename": "src/tools/clippy/clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -143,7 +143,7 @@ impl<'tcx> LateLintPass<'tcx> for CognitiveComplexity {\n         span: Span,\n         def_id: LocalDefId,\n     ) {\n-        if !cx.tcx.has_attr(def_id.to_def_id(), sym::test) {\n+        if !cx.tcx.has_attr(def_id, sym::test) {\n             let expr = if is_async_fn(kind) {\n                 match get_async_fn_body(cx.tcx, body) {\n                     Some(b) => b,"}, {"sha": "8f68f90a2a130ccc8ce1fe4b690297f0ce8efab8", "filename": "src/tools/clippy/clippy_lints/src/derivable_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -181,7 +181,7 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n                 self_ty,\n                 ..\n             }) = item.kind;\n-            if !cx.tcx.has_attr(item.owner_id.to_def_id(), sym::automatically_derived);\n+            if !cx.tcx.has_attr(item.owner_id, sym::automatically_derived);\n             if !item.span.from_expansion();\n             if let Some(def_id) = trait_ref.trait_def_id();\n             if cx.tcx.is_diagnostic_item(sym::Default, def_id);"}, {"sha": "715348e869ef9ae38fea8212cf1ad86f2e071608", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -212,7 +212,7 @@ impl<'tcx> LateLintPass<'tcx> for Derive {\n         }) = item.kind\n         {\n             let ty = cx.tcx.type_of(item.owner_id).subst_identity();\n-            let is_automatically_derived = cx.tcx.has_attr(item.owner_id.to_def_id(), sym::automatically_derived);\n+            let is_automatically_derived = cx.tcx.has_attr(item.owner_id, sym::automatically_derived);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);\n             check_ord_partial_ord(cx, item.span, trait_ref, ty, is_automatically_derived);"}, {"sha": "eacbf6c6ec9b6ee36750b438bc2b3cca84e8c338", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -22,7 +22,7 @@ use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n \n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n-    let attr = cx.tcx.get_attr(item.owner_id.to_def_id(), sym::must_use);\n+    let attr = cx.tcx.get_attr(item.owner_id, sym::must_use);\n     if let hir::ItemKind::Fn(ref sig, _generics, ref body_id) = item.kind {\n         let is_public = cx.effective_visibilities.is_exported(item.owner_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n@@ -47,7 +47,7 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n         let is_public = cx.effective_visibilities.is_exported(item.owner_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = cx.tcx.get_attr(item.owner_id.to_def_id(), sym::must_use);\n+        let attr = cx.tcx.get_attr(item.owner_id, sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n         } else if is_public\n@@ -73,7 +73,7 @@ pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Tr\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n \n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = cx.tcx.get_attr(item.owner_id.to_def_id(), sym::must_use);\n+        let attr = cx.tcx.get_attr(item.owner_id, sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n         } else if let hir::TraitFn::Provided(eid) = *eid {"}, {"sha": "ed0bd58c770c7566ca2847cc00fe9162fa73977c", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -9,7 +9,7 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt;\n-use rustc_trait_selection::traits::{self, FulfillmentError};\n+use rustc_trait_selection::traits::{self, FulfillmentError, ObligationCtxt};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -79,8 +79,10 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                 let send_trait = cx.tcx.get_diagnostic_item(sym::Send).unwrap();\n                 let span = decl.output.span();\n                 let infcx = cx.tcx.infer_ctxt().build();\n+                let ocx = ObligationCtxt::new(&infcx);\n                 let cause = traits::ObligationCause::misc(span, fn_def_id);\n-                let send_errors = traits::fully_solve_bound(&infcx, cause, cx.param_env, ret_ty, send_trait);\n+                ocx.register_bound(cause, cx.param_env, ret_ty, send_trait);\n+                let send_errors = ocx.select_all_or_error();\n                 if !send_errors.is_empty() {\n                     span_lint_and_then(\n                         cx,"}, {"sha": "a8c4823fe53889d643d2ebbde602cf5037170ab7", "filename": "src/tools/clippy/clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -36,7 +36,7 @@ impl<'tcx> LateLintPass<'tcx> for PartialEqNeImpl {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if_chain! {\n             if let ItemKind::Impl(Impl { of_trait: Some(ref trait_ref), items: impl_items, .. }) = item.kind;\n-            if !cx.tcx.has_attr(item.owner_id.to_def_id(), sym::automatically_derived);\n+            if !cx.tcx.has_attr(item.owner_id, sym::automatically_derived);\n             if let Some(eq_trait) = cx.tcx.lang_items().eq_trait();\n             if trait_ref.path.res.def_id() == eq_trait;\n             then {"}, {"sha": "7691f5c32b21e562286e6e382fe6ed459e807b29", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -9,7 +9,7 @@ use std::str::FromStr;\n \n use crate::util::{add_dylib_path, PathBufExt};\n use lazycell::LazyCell;\n-use test::ColorConfig;\n+use test::{ColorConfig, OutputFormat};\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n pub enum Mode {\n@@ -337,7 +337,7 @@ pub struct Config {\n     pub verbose: bool,\n \n     /// Print one character per test instead of one line\n-    pub quiet: bool,\n+    pub format: OutputFormat,\n \n     /// Whether to use colors in test.\n     pub color: ColorConfig,"}, {"sha": "cbaa599f79308d2c203c4de2654d4353d01ef832", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -114,6 +114,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         )\n         .optflag(\"\", \"quiet\", \"print one character per test instead of one line\")\n         .optopt(\"\", \"color\", \"coloring: auto, always, never\", \"WHEN\")\n+        .optflag(\"\", \"json\", \"emit json output instead of plaintext output\")\n         .optopt(\"\", \"logfile\", \"file to log test execution to\", \"FILE\")\n         .optopt(\"\", \"target\", \"the target to build for\", \"TARGET\")\n         .optopt(\"\", \"host\", \"the host to build for\", \"HOST\")\n@@ -281,7 +282,12 @@ pub fn parse_config(args: Vec<String>) -> Config {\n             && !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n         lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n         verbose: matches.opt_present(\"verbose\"),\n-        quiet: matches.opt_present(\"quiet\"),\n+        format: match (matches.opt_present(\"quiet\"), matches.opt_present(\"json\")) {\n+            (true, true) => panic!(\"--quiet and --json are incompatible\"),\n+            (true, false) => test::OutputFormat::Terse,\n+            (false, true) => test::OutputFormat::Json,\n+            (false, false) => test::OutputFormat::Pretty,\n+        },\n         only_modified: matches.opt_present(\"only-modified\"),\n         color,\n         remote_test_client: matches.opt_str(\"remote-test-client\").map(PathBuf::from),\n@@ -339,7 +345,7 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"ar: {}\", config.ar));\n     logv(c, format!(\"linker: {:?}\", config.linker));\n     logv(c, format!(\"verbose: {}\", config.verbose));\n-    logv(c, format!(\"quiet: {}\", config.quiet));\n+    logv(c, format!(\"format: {:?}\", config.format));\n     logv(c, \"\\n\".to_string());\n }\n \n@@ -416,7 +422,7 @@ pub fn run_tests(config: Config) {\n             // easy to miss which tests failed, and as such fail to reproduce\n             // the failure locally.\n \n-            eprintln!(\n+            println!(\n                 \"Some tests failed in compiletest suite={}{} mode={} host={} target={}\",\n                 config.suite,\n                 config.compare_mode.map(|c| format!(\" compare_mode={:?}\", c)).unwrap_or_default(),\n@@ -501,7 +507,7 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         filters: config.filters.clone(),\n         filter_exact: config.filter_exact,\n         run_ignored: if config.run_ignored { test::RunIgnored::Yes } else { test::RunIgnored::No },\n-        format: if config.quiet { test::OutputFormat::Terse } else { test::OutputFormat::Pretty },\n+        format: config.format,\n         logfile: config.logfile.clone(),\n         run_tests: true,\n         bench_benchmarks: true,"}, {"sha": "e267b08d0829932cb3056b07ea11cdc66971cbbf", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1 +1 @@\n-84c47b8279b39e165dfebeb529eb6d92592e4f8d\n+439292bc7913399e406d9bb7e8da0f70c6317c6e"}, {"sha": "26a7ead2407cb79e7523f000deb4dca001c218e5", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -22,12 +22,13 @@ use log::debug;\n \n use rustc_data_structures::sync::Lrc;\n use rustc_driver::Compilation;\n-use rustc_hir::{self as hir, def_id::LOCAL_CRATE, Node};\n+use rustc_hir::{self as hir, Node};\n use rustc_interface::interface::Config;\n use rustc_middle::{\n     middle::exported_symbols::{\n         ExportedSymbol, SymbolExportInfo, SymbolExportKind, SymbolExportLevel,\n     },\n+    query::LocalCrate,\n     ty::{query::ExternProviders, TyCtxt},\n };\n use rustc_session::config::OptLevel;\n@@ -124,8 +125,7 @@ impl rustc_driver::Callbacks for MiriBeRustCompilerCalls {\n             config.override_queries = Some(|_, local_providers, _| {\n                 // `exported_symbols` and `reachable_non_generics` provided by rustc always returns\n                 // an empty result if `tcx.sess.opts.output_types.should_codegen()` is false.\n-                local_providers.exported_symbols = |tcx, cnum| {\n-                    assert_eq!(cnum, LOCAL_CRATE);\n+                local_providers.exported_symbols = |tcx, LocalCrate| {\n                     let reachable_set = tcx.with_stable_hashing_context(|hcx| {\n                         tcx.reachable_set(()).to_sorted(&hcx, true)\n                     });"}, {"sha": "abcf59cfe36cd39372b6ca1490aeb60fcf5e75ba", "filename": "src/tools/rust-installer/src/combiner.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Frust-installer%2Fsrc%2Fcombiner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Frust-installer%2Fsrc%2Fcombiner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fcombiner.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,7 +1,7 @@\n use super::Scripter;\n use super::Tarballer;\n use crate::{\n-    compression::{CompressionFormat, CompressionFormats},\n+    compression::{CompressionFormat, CompressionFormats, CompressionProfile},\n     util::*,\n };\n use anyhow::{bail, Context, Result};\n@@ -48,6 +48,10 @@ actor! {\n         #[clap(value_name = \"DIR\")]\n         output_dir: String = \"./dist\",\n \n+        /// The profile used to compress the tarball.\n+        #[clap(value_name = \"FORMAT\", default_value_t)]\n+        compression_profile: CompressionProfile,\n+\n         /// The formats used to compress the tarball\n         #[clap(value_name = \"FORMAT\", default_value_t)]\n         compression_formats: CompressionFormats,\n@@ -153,6 +157,7 @@ impl Combiner {\n             .work_dir(self.work_dir)\n             .input(self.package_name)\n             .output(path_to_str(&output)?.into())\n+            .compression_profile(self.compression_profile)\n             .compression_formats(self.compression_formats.clone());\n         tarballer.run()?;\n "}, {"sha": "510c914163c7e754b83485dee4a9328dd68a6782", "filename": "src/tools/rust-installer/src/compression.rs", "status": "modified", "additions": 93, "deletions": 43, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Frust-installer%2Fsrc%2Fcompression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Frust-installer%2Fsrc%2Fcompression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fcompression.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -4,6 +4,37 @@ use rayon::prelude::*;\n use std::{convert::TryFrom, fmt, io::Read, io::Write, path::Path, str::FromStr};\n use xz2::{read::XzDecoder, write::XzEncoder};\n \n+#[derive(Default, Debug, Copy, Clone)]\n+pub enum CompressionProfile {\n+    Fast,\n+    #[default]\n+    Balanced,\n+    Best,\n+}\n+\n+impl FromStr for CompressionProfile {\n+    type Err = Error;\n+\n+    fn from_str(input: &str) -> Result<Self, Error> {\n+        Ok(match input {\n+            \"fast\" => Self::Fast,\n+            \"balanced\" => Self::Balanced,\n+            \"best\" => Self::Best,\n+            other => anyhow::bail!(\"invalid compression profile: {other}\"),\n+        })\n+    }\n+}\n+\n+impl fmt::Display for CompressionProfile {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            CompressionProfile::Fast => f.write_str(\"fast\"),\n+            CompressionProfile::Balanced => f.write_str(\"balanced\"),\n+            CompressionProfile::Best => f.write_str(\"best\"),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone)]\n pub enum CompressionFormat {\n     Gz,\n@@ -26,7 +57,11 @@ impl CompressionFormat {\n         }\n     }\n \n-    pub(crate) fn encode(&self, path: impl AsRef<Path>) -> Result<Box<dyn Encoder>, Error> {\n+    pub(crate) fn encode(\n+        &self,\n+        path: impl AsRef<Path>,\n+        profile: CompressionProfile,\n+    ) -> Result<Box<dyn Encoder>, Error> {\n         let mut os = path.as_ref().as_os_str().to_os_string();\n         os.push(format!(\".{}\", self.extension()));\n         let path = Path::new(&os);\n@@ -37,49 +72,64 @@ impl CompressionFormat {\n         let file = crate::util::create_new_file(path)?;\n \n         Ok(match self {\n-            CompressionFormat::Gz => Box::new(GzEncoder::new(file, flate2::Compression::best())),\n+            CompressionFormat::Gz => Box::new(GzEncoder::new(\n+                file,\n+                match profile {\n+                    CompressionProfile::Fast => flate2::Compression::fast(),\n+                    CompressionProfile::Balanced => flate2::Compression::new(6),\n+                    CompressionProfile::Best => flate2::Compression::best(),\n+                },\n+            )),\n             CompressionFormat::Xz => {\n-                let mut filters = xz2::stream::Filters::new();\n-                // the preset is overridden by the other options so it doesn't matter\n-                let mut lzma_ops = xz2::stream::LzmaOptions::new_preset(9).unwrap();\n-                // This sets the overall dictionary size, which is also how much memory (baseline)\n-                // is needed for decompression.\n-                lzma_ops.dict_size(64 * 1024 * 1024);\n-                // Use the best match finder for compression ratio.\n-                lzma_ops.match_finder(xz2::stream::MatchFinder::BinaryTree4);\n-                lzma_ops.mode(xz2::stream::Mode::Normal);\n-                // Set nice len to the maximum for best compression ratio\n-                lzma_ops.nice_len(273);\n-                // Set depth to a reasonable value, 0 means auto, 1000 is somwhat high but gives\n-                // good results.\n-                lzma_ops.depth(1000);\n-                // 2 is the default and does well for most files\n-                lzma_ops.position_bits(2);\n-                // 0 is the default and does well for most files\n-                lzma_ops.literal_position_bits(0);\n-                // 3 is the default and does well for most files\n-                lzma_ops.literal_context_bits(3);\n-\n-                filters.lzma2(&lzma_ops);\n-\n-                let mut builder = xz2::stream::MtStreamBuilder::new();\n-                builder.filters(filters);\n-\n-                // On 32-bit platforms limit ourselves to 3 threads, otherwise we exceed memory\n-                // usage this process can take. In the future we'll likely only do super-fast\n-                // compression in CI and move this heavyweight processing to promote-release (which\n-                // is always 64-bit and can run on big-memory machines) but for now this lets us\n-                // move forward.\n-                if std::mem::size_of::<usize>() == 4 {\n-                    builder.threads(3);\n-                } else {\n-                    builder.threads(6);\n-                }\n-\n-                let compressor = XzEncoder::new_stream(\n-                    std::io::BufWriter::new(file),\n-                    builder.encoder().unwrap(),\n-                );\n+                let encoder = match profile {\n+                    CompressionProfile::Fast => {\n+                        xz2::stream::MtStreamBuilder::new().threads(6).preset(1).encoder().unwrap()\n+                    }\n+                    CompressionProfile::Balanced => {\n+                        xz2::stream::MtStreamBuilder::new().threads(6).preset(6).encoder().unwrap()\n+                    }\n+                    CompressionProfile::Best => {\n+                        let mut filters = xz2::stream::Filters::new();\n+                        // the preset is overridden by the other options so it doesn't matter\n+                        let mut lzma_ops = xz2::stream::LzmaOptions::new_preset(9).unwrap();\n+                        // This sets the overall dictionary size, which is also how much memory (baseline)\n+                        // is needed for decompression.\n+                        lzma_ops.dict_size(64 * 1024 * 1024);\n+                        // Use the best match finder for compression ratio.\n+                        lzma_ops.match_finder(xz2::stream::MatchFinder::BinaryTree4);\n+                        lzma_ops.mode(xz2::stream::Mode::Normal);\n+                        // Set nice len to the maximum for best compression ratio\n+                        lzma_ops.nice_len(273);\n+                        // Set depth to a reasonable value, 0 means auto, 1000 is somwhat high but gives\n+                        // good results.\n+                        lzma_ops.depth(1000);\n+                        // 2 is the default and does well for most files\n+                        lzma_ops.position_bits(2);\n+                        // 0 is the default and does well for most files\n+                        lzma_ops.literal_position_bits(0);\n+                        // 3 is the default and does well for most files\n+                        lzma_ops.literal_context_bits(3);\n+\n+                        filters.lzma2(&lzma_ops);\n+\n+                        let mut builder = xz2::stream::MtStreamBuilder::new();\n+                        builder.filters(filters);\n+\n+                        // On 32-bit platforms limit ourselves to 3 threads, otherwise we exceed memory\n+                        // usage this process can take. In the future we'll likely only do super-fast\n+                        // compression in CI and move this heavyweight processing to promote-release (which\n+                        // is always 64-bit and can run on big-memory machines) but for now this lets us\n+                        // move forward.\n+                        if std::mem::size_of::<usize>() == 4 {\n+                            builder.threads(3);\n+                        } else {\n+                            builder.threads(6);\n+                        }\n+                        builder.encoder().unwrap()\n+                    }\n+                };\n+\n+                let compressor = XzEncoder::new_stream(std::io::BufWriter::new(file), encoder);\n                 Box::new(compressor)\n             }\n         })"}, {"sha": "ddd1052599d58bff1fc353383aa413a737905b70", "filename": "src/tools/rust-installer/src/generator.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Frust-installer%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Frust-installer%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fgenerator.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,6 +1,6 @@\n use super::Scripter;\n use super::Tarballer;\n-use crate::compression::CompressionFormats;\n+use crate::compression::{CompressionFormats, CompressionProfile};\n use crate::util::*;\n use anyhow::{bail, format_err, Context, Result};\n use std::collections::BTreeSet;\n@@ -54,6 +54,10 @@ actor! {\n         #[clap(value_name = \"DIR\")]\n         output_dir: String = \"./dist\",\n \n+        /// The profile used to compress the tarball.\n+        #[clap(value_name = \"FORMAT\", default_value_t)]\n+        compression_profile: CompressionProfile,\n+\n         /// The formats used to compress the tarball\n         #[clap(value_name = \"FORMAT\", default_value_t)]\n         compression_formats: CompressionFormats,\n@@ -113,6 +117,7 @@ impl Generator {\n             .work_dir(self.work_dir)\n             .input(self.package_name)\n             .output(path_to_str(&output)?.into())\n+            .compression_profile(self.compression_profile)\n             .compression_formats(self.compression_formats.clone());\n         tarballer.run()?;\n "}, {"sha": "592eba8f69850aa51e98fe355bc45b8a9bb40849", "filename": "src/tools/rust-installer/src/tarballer.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Frust-installer%2Fsrc%2Ftarballer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/src%2Ftools%2Frust-installer%2Fsrc%2Ftarballer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Ftarballer.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -6,7 +6,7 @@ use tar::{Builder, Header};\n use walkdir::WalkDir;\n \n use crate::{\n-    compression::{CombinedEncoder, CompressionFormats},\n+    compression::{CombinedEncoder, CompressionFormats, CompressionProfile},\n     util::*,\n };\n \n@@ -25,6 +25,10 @@ actor! {\n         #[clap(value_name = \"DIR\")]\n         work_dir: String = \"./workdir\",\n \n+        /// The profile used to compress the tarball.\n+        #[clap(value_name = \"FORMAT\", default_value_t)]\n+        compression_profile: CompressionProfile,\n+\n         /// The formats used to compress the tarball.\n         #[clap(value_name = \"FORMAT\", default_value_t)]\n         compression_formats: CompressionFormats,\n@@ -38,7 +42,7 @@ impl Tarballer {\n         let encoder = CombinedEncoder::new(\n             self.compression_formats\n                 .iter()\n-                .map(|f| f.encode(&tarball_name))\n+                .map(|f| f.encode(&tarball_name, self.compression_profile))\n                 .collect::<Result<Vec<_>>>()?,\n         );\n "}, {"sha": "8ff7ba9cb64ca6c9d522e449f5ef8cfa35425f7e", "filename": "tests/codegen/vec-as-ptr.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fcodegen%2Fvec-as-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fcodegen%2Fvec-as-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fvec-as-ptr.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -O -Zmerge-functions=disabled\n+\n+#![crate_type = \"lib\"]\n+\n+// Test that even though we return a *const u8 not a &[u8] or a NonNull<u8>, LLVM knows that this\n+// pointer is nonnull.\n+// CHECK: nonnull {{i8\\*|ptr}} @vec_as_ptr\n+#[no_mangle]\n+pub fn vec_as_ptr(v: &Vec<u8>) -> *const u8 {\n+    v.as_ptr()\n+}\n+\n+// Test that even though we return a *const u8 not a &[u8] or a NonNull<u8>, LLVM knows that this\n+// pointer is nonnull.\n+// CHECK: nonnull {{i8\\*|ptr}} @vec_as_mut_ptr\n+#[no_mangle]\n+pub fn vec_as_mut_ptr(v: &mut Vec<u8>) -> *mut u8 {\n+    v.as_mut_ptr()\n+}"}, {"sha": "49e8c812c197a7e3a1d4296272ac50ea472a2d3b", "filename": "tests/mir-opt/building/custom/aggregate_exprs.adt.built.after.mir", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.adt.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.adt.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.adt.built.after.mir?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,16 @@\n+// MIR for `adt` after built\n+\n+fn adt() -> Onion {\n+    let mut _0: Onion;                   // return place in scope 0 at $DIR/aggregate_exprs.rs:+0:13: +0:18\n+    let mut _1: i32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _2: Foo;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _3: Bar;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _1 = const 1_i32;                // scope 0 at $DIR/aggregate_exprs.rs:+6:13: +6:20\n+        _2 = Foo { a: const 1_i32, b: const 2_i32 }; // scope 0 at $DIR/aggregate_exprs.rs:+7:13: +10:14\n+        _3 = Bar::Foo(move _2, _1);      // scope 0 at $DIR/aggregate_exprs.rs:+11:13: +11:39\n+        _0 = Onion { neon: ((_3 as variant#0).1: i32) }; // scope 0 at $DIR/aggregate_exprs.rs:+12:13: +12:58\n+        return;                          // scope 0 at $DIR/aggregate_exprs.rs:+13:13: +13:21\n+    }\n+}"}, {"sha": "30d12897331ce87c378a08d0ff791e6b2cd0921d", "filename": "tests/mir-opt/building/custom/aggregate_exprs.array.built.after.mir", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.array.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.array.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.array.built.after.mir?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,15 @@\n+// MIR for `array` after built\n+\n+fn array() -> [i32; 2] {\n+    let mut _0: [i32; 2];                // return place in scope 0 at $DIR/aggregate_exprs.rs:+0:15: +0:23\n+    let mut _1: [i32; 2];                // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _2: i32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _1 = [const 42_i32, const 43_i32]; // scope 0 at $DIR/aggregate_exprs.rs:+5:13: +5:25\n+        _2 = const 1_i32;                // scope 0 at $DIR/aggregate_exprs.rs:+6:13: +6:20\n+        _1 = [_2, const 2_i32];          // scope 0 at $DIR/aggregate_exprs.rs:+7:13: +7:25\n+        _0 = move _1;                    // scope 0 at $DIR/aggregate_exprs.rs:+8:13: +8:26\n+        return;                          // scope 0 at $DIR/aggregate_exprs.rs:+9:13: +9:21\n+    }\n+}"}, {"sha": "554c9c03ba4a007fe643068408c9d5de4104e406", "filename": "tests/mir-opt/building/custom/aggregate_exprs.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,71 @@\n+#![feature(custom_mir, core_intrinsics)]\n+\n+extern crate core;\n+use core::intrinsics::mir::*;\n+\n+// EMIT_MIR aggregate_exprs.tuple.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn tuple() -> (i32, bool) {\n+    mir!(\n+        {\n+            RET = (1, true);\n+            Return()\n+        }\n+    )\n+}\n+\n+// EMIT_MIR aggregate_exprs.array.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn array() -> [i32; 2] {\n+    mir!(\n+        let x: [i32; 2];\n+        let one: i32;\n+        {\n+            x = [42, 43];\n+            one = 1;\n+            x = [one, 2];\n+            RET = Move(x);\n+            Return()\n+        }\n+    )\n+}\n+\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+enum Bar {\n+    Foo(Foo, i32),\n+}\n+\n+union Onion {\n+    neon: i32,\n+    noun: f32,\n+}\n+\n+// EMIT_MIR aggregate_exprs.adt.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn adt() -> Onion {\n+    mir!(\n+        let one: i32;\n+        let x: Foo;\n+        let y: Bar;\n+        {\n+            one = 1;\n+            x = Foo {\n+                a: 1,\n+                b: 2,\n+            };\n+            y = Bar::Foo(Move(x), one);\n+            RET = Onion { neon: Field(Variant(y, 0), 1) };\n+            Return()\n+        }\n+    )\n+}\n+\n+fn main() {\n+    assert_eq!(tuple(), (1, true));\n+    assert_eq!(array(), [1, 2]);\n+    assert_eq!(unsafe { adt().neon }, 1);\n+}"}, {"sha": "5fe45ccc90ca641663b165ba7b6d9efba34ee484", "filename": "tests/mir-opt/building/custom/aggregate_exprs.tuple.built.after.mir", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.tuple.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.tuple.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.tuple.built.after.mir?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,10 @@\n+// MIR for `tuple` after built\n+\n+fn tuple() -> (i32, bool) {\n+    let mut _0: (i32, bool);             // return place in scope 0 at $DIR/aggregate_exprs.rs:+0:15: +0:26\n+\n+    bb0: {\n+        _0 = (const 1_i32, const true);  // scope 0 at $DIR/aggregate_exprs.rs:+3:13: +3:28\n+        return;                          // scope 0 at $DIR/aggregate_exprs.rs:+4:13: +4:21\n+    }\n+}"}, {"sha": "db788fe6e6af1d2facf2521ef1061d97e3ab9317", "filename": "tests/ui/associated-consts/issue-93775.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fassociated-consts%2Fissue-93775.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fassociated-consts%2Fissue-93775.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-consts%2Fissue-93775.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -3,7 +3,7 @@\n \n // Regression for #93775, needs build-pass to test it.\n \n-#![recursion_limit = \"1000\"]\n+#![recursion_limit = \"1001\"]\n \n use std::marker::PhantomData;\n "}, {"sha": "319ed582e2719eae56940b8ce1755c3a95c76d74", "filename": "tests/ui/async-await/in-trait/missing-send-bound.current.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.current.stderr?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,5 +1,5 @@\n warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/missing-send-bound.rs:3:12\n+  --> $DIR/missing-send-bound.rs:5:12\n    |\n LL | #![feature(async_fn_in_trait)]\n    |            ^^^^^^^^^^^^^^^^^\n@@ -8,19 +8,19 @@ LL | #![feature(async_fn_in_trait)]\n    = note: `#[warn(incomplete_features)]` on by default\n \n error: future cannot be sent between threads safely\n-  --> $DIR/missing-send-bound.rs:15:20\n+  --> $DIR/missing-send-bound.rs:17:20\n    |\n LL |     assert_is_send(test::<T>());\n    |                    ^^^^^^^^^^^ future returned by `test` is not `Send`\n    |\n    = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `impl Future<Output = ()>`\n note: future is not `Send` as it awaits another future which is not `Send`\n-  --> $DIR/missing-send-bound.rs:11:5\n+  --> $DIR/missing-send-bound.rs:13:5\n    |\n LL |     T::bar().await;\n    |     ^^^^^^^^ await occurs here on type `impl Future<Output = ()>`, which is not `Send`\n note: required by a bound in `assert_is_send`\n-  --> $DIR/missing-send-bound.rs:19:27\n+  --> $DIR/missing-send-bound.rs:21:27\n    |\n LL | fn assert_is_send(_: impl Send) {}\n    |                           ^^^^ required by this bound in `assert_is_send`", "previous_filename": "tests/ui/async-await/in-trait/missing-send-bound.stderr"}, {"sha": "319ed582e2719eae56940b8ce1755c3a95c76d74", "filename": "tests/ui/async-await/in-trait/missing-send-bound.next.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.next.stderr?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,29 @@\n+warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/missing-send-bound.rs:5:12\n+   |\n+LL | #![feature(async_fn_in_trait)]\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/missing-send-bound.rs:17:20\n+   |\n+LL |     assert_is_send(test::<T>());\n+   |                    ^^^^^^^^^^^ future returned by `test` is not `Send`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `impl Future<Output = ()>`\n+note: future is not `Send` as it awaits another future which is not `Send`\n+  --> $DIR/missing-send-bound.rs:13:5\n+   |\n+LL |     T::bar().await;\n+   |     ^^^^^^^^ await occurs here on type `impl Future<Output = ()>`, which is not `Send`\n+note: required by a bound in `assert_is_send`\n+  --> $DIR/missing-send-bound.rs:21:27\n+   |\n+LL | fn assert_is_send(_: impl Send) {}\n+   |                           ^^^^ required by this bound in `assert_is_send`\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "705fcf322f9eaa5cd09693d47c090715c28145b4", "filename": "tests/ui/async-await/in-trait/missing-send-bound.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,4 +1,6 @@\n // edition:2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n //~^ WARN the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes"}, {"sha": "e13dfbacd242225c5eb374973abe9b1c3db57ca2", "filename": "tests/ui/const-generics/bad-subst-const-kind.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,13 @@\n+// incremental\n+#![crate_type = \"lib\"]\n+\n+trait Q {\n+    const ASSOC: usize;\n+}\n+\n+impl<const N: u64> Q for [u8; N] {\n+    //~^ ERROR mismatched types\n+    const ASSOC: usize = 1;\n+}\n+\n+pub fn test() -> [u8; <[u8; 13] as Q>::ASSOC] { todo!() }"}, {"sha": "bd24f9140e4ea72912355109b1f662bb57dfb0cc", "filename": "tests/ui/const-generics/bad-subst-const-kind.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.stderr?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/bad-subst-const-kind.rs:8:31\n+   |\n+LL | impl<const N: u64> Q for [u8; N] {\n+   |                               ^ expected `usize`, found `u64`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "70e49566ac0d99bf580658119f3ef9f8178f55e6", "filename": "tests/ui/did_you_mean/recursion_limit.stderr", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fdid_you_mean%2Frecursion_limit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fdid_you_mean%2Frecursion_limit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Frecursion_limit.stderr?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,15 +1,10 @@\n-error[E0275]: overflow evaluating the requirement `K: Send`\n+error[E0275]: overflow evaluating the requirement `J: Send`\n   --> $DIR/recursion_limit.rs:34:5\n    |\n LL |     is_send::<A>();\n    |     ^^^^^^^^^^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"20\"]` attribute to your crate (`recursion_limit`)\n-note: required because it appears within the type `J`\n-  --> $DIR/recursion_limit.rs:24:9\n-   |\n-LL | link! { J, K }\n-   |         ^\n note: required because it appears within the type `I`\n   --> $DIR/recursion_limit.rs:23:9\n    |"}, {"sha": "03c37d6f0e1deffc9ce61a28197990b411ba6a2e", "filename": "tests/ui/error-codes/E0275.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ferror-codes%2FE0275.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ferror-codes%2FE0275.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0275.stderr?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -11,7 +11,7 @@ note: required for `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<\n LL | impl<T> Foo for T where Bar<T>: Foo {}\n    |         ^^^     ^               --- unsatisfied trait bound introduced here\n    = note: the full type name has been written to '$TEST_BUILD_DIR/error-codes/E0275/E0275.long-type-hash.txt'\n-   = note: 127 redundant requirements hidden\n+   = note: 126 redundant requirements hidden\n    = note: required for `Bar<T>` to implement `Foo`\n \n error: aborting due to previous error"}, {"sha": "de82544f29338ce529f16cd6dd5e321c25a9587c", "filename": "tests/ui/impl-trait/in-trait/default-method-binder-shifting.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -13,4 +13,10 @@ trait Trait {\n     fn method(&self) -> impl Trait<Type = impl Sized + '_>;\n }\n \n+trait Trait2 {\n+    type Type;\n+\n+    fn method(&self) -> impl Trait2<Type = impl Trait2<Type = impl Sized + '_> + '_>;\n+}\n+\n fn main() {}"}, {"sha": "8891a26784e4b87bb0122108c6b4a2b3809b7356", "filename": "tests/ui/issues/issue-20413.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fissues%2Fissue-20413.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fissues%2Fissue-20413.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-20413.stderr?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -20,51 +20,51 @@ note: required for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoDa\n LL | impl<T> Foo for T where NoData<T>: Foo {\n    |         ^^^     ^                  --- unsatisfied trait bound introduced here\n    = note: the full type name has been written to '$TEST_BUILD_DIR/issues/issue-20413/issue-20413.long-type-hash.txt'\n-   = note: 127 redundant requirements hidden\n+   = note: 126 redundant requirements hidden\n    = note: required for `NoData<T>` to implement `Foo`\n \n-error[E0275]: overflow evaluating the requirement `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<...>>>>>>>: Baz`\n+error[E0275]: overflow evaluating the requirement `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<...>>>>>>>: Bar`\n   --> $DIR/issue-20413.rs:28:42\n    |\n LL | impl<T> Bar for T where EvenLessData<T>: Baz {\n    |                                          ^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_20413`)\n-note: required for `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<...>>>>>>>` to implement `Bar`\n-  --> $DIR/issue-20413.rs:28:9\n-   |\n-LL | impl<T> Bar for T where EvenLessData<T>: Baz {\n-   |         ^^^     ^                        --- unsatisfied trait bound introduced here\n-   = note: the full type name has been written to '$TEST_BUILD_DIR/issues/issue-20413/issue-20413.long-type-hash.txt'\n note: required for `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<...>>>>>>>` to implement `Baz`\n   --> $DIR/issue-20413.rs:35:9\n    |\n LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n    |         ^^^     ^                        --- unsatisfied trait bound introduced here\n    = note: the full type name has been written to '$TEST_BUILD_DIR/issues/issue-20413/issue-20413.long-type-hash.txt'\n-   = note: 126 redundant requirements hidden\n+note: required for `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<...>>>>>>>` to implement `Bar`\n+  --> $DIR/issue-20413.rs:28:9\n+   |\n+LL | impl<T> Bar for T where EvenLessData<T>: Baz {\n+   |         ^^^     ^                        --- unsatisfied trait bound introduced here\n+   = note: the full type name has been written to '$TEST_BUILD_DIR/issues/issue-20413/issue-20413.long-type-hash.txt'\n+   = note: 125 redundant requirements hidden\n    = note: required for `EvenLessData<T>` to implement `Baz`\n \n-error[E0275]: overflow evaluating the requirement `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<...>>>>>>>: Bar`\n+error[E0275]: overflow evaluating the requirement `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<...>>>>>>>: Baz`\n   --> $DIR/issue-20413.rs:35:42\n    |\n LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n    |                                          ^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_20413`)\n-note: required for `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<...>>>>>>>` to implement `Baz`\n-  --> $DIR/issue-20413.rs:35:9\n-   |\n-LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n-   |         ^^^     ^                        --- unsatisfied trait bound introduced here\n-   = note: the full type name has been written to '$TEST_BUILD_DIR/issues/issue-20413/issue-20413.long-type-hash.txt'\n note: required for `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<...>>>>>>>` to implement `Bar`\n   --> $DIR/issue-20413.rs:28:9\n    |\n LL | impl<T> Bar for T where EvenLessData<T>: Baz {\n    |         ^^^     ^                        --- unsatisfied trait bound introduced here\n    = note: the full type name has been written to '$TEST_BUILD_DIR/issues/issue-20413/issue-20413.long-type-hash.txt'\n-   = note: 126 redundant requirements hidden\n+note: required for `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<...>>>>>>>` to implement `Baz`\n+  --> $DIR/issue-20413.rs:35:9\n+   |\n+LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n+   |         ^^^     ^                        --- unsatisfied trait bound introduced here\n+   = note: the full type name has been written to '$TEST_BUILD_DIR/issues/issue-20413/issue-20413.long-type-hash.txt'\n+   = note: 125 redundant requirements hidden\n    = note: required for `AlmostNoData<T>` to implement `Bar`\n \n error: aborting due to 4 previous errors"}, {"sha": "21aa81e80926ead1252b83b6cf06c2295fc3c943", "filename": "tests/ui/macros/nested-use-as.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fmacros%2Fnested-use-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fmacros%2Fnested-use-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fnested-use-as.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,83 @@\n+// check-pass\n+// edition:2018\n+// issue: https://github.com/rust-lang/rust/issues/97534\n+\n+macro_rules! m {\n+    () => {\n+        macro_rules! foo {\n+            () => {}\n+        }\n+        use foo as bar;\n+    }\n+}\n+\n+m!{}\n+\n+use bar as baz;\n+\n+baz!{}\n+\n+macro_rules! foo2 {\n+    () => {};\n+}\n+\n+macro_rules! m2 {\n+    () => {\n+        use foo2 as bar2;\n+    };\n+}\n+\n+m2! {}\n+\n+use bar2 as baz2;\n+\n+baz2! {}\n+\n+macro_rules! n1 {\n+    () => {\n+        macro_rules! n2 {\n+            () => {\n+                macro_rules! n3 {\n+                    () => {\n+                        macro_rules! n4 {\n+                            () => {}\n+                        }\n+                        use n4 as c4;\n+                    }\n+                }\n+                use n3 as c3;\n+            }\n+        }\n+        use n2 as c2;\n+    }\n+}\n+\n+use n1 as c1;\n+c1!{}\n+use c2 as a2;\n+a2!{}\n+use c3 as a3;\n+a3!{}\n+use c4 as a4;\n+a4!{}\n+\n+// https://github.com/rust-lang/rust/pull/108729#issuecomment-1474750675\n+// reversed\n+use d5 as d6;\n+use d4 as d5;\n+use d3 as d4;\n+use d2 as d3;\n+use d1 as d2;\n+use foo2 as d1;\n+d6! {}\n+\n+// mess\n+use f3 as f4;\n+f5! {}\n+use f1 as f2;\n+use f4 as f5;\n+use f2 as f3;\n+use foo2 as f1;\n+\n+fn main() {\n+}"}, {"sha": "5fd7c647c253111888d7059dfe31f9c626f26fe0", "filename": "tests/ui/specialization/min_specialization/bad-const-wf-doesnt-specialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -2,11 +2,11 @@\n \n // An impl that has an erroneous const substitution should not specialize one\n // that is well-formed.\n-\n+#[derive(Clone)]\n struct S<const L: usize>;\n \n impl<const N: i32> Copy for S<N> {}\n+//~^ ERROR the constant `N` is not of type `usize`\n impl<const M: usize> Copy for S<M> {}\n-//~^ ERROR conflicting implementations of trait `Copy` for type `S<_>`\n \n fn main() {}"}, {"sha": "6d7028c5e7088e18cbf060cfae64233e3be8c857", "filename": "tests/ui/specialization/min_specialization/bad-const-wf-doesnt-specialize.stderr", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,11 +1,14 @@\n-error[E0119]: conflicting implementations of trait `Copy` for type `S<_>`\n-  --> $DIR/bad-const-wf-doesnt-specialize.rs:9:1\n+error: the constant `N` is not of type `usize`\n+  --> $DIR/bad-const-wf-doesnt-specialize.rs:8:29\n    |\n LL | impl<const N: i32> Copy for S<N> {}\n-   | -------------------------------- first implementation here\n-LL | impl<const M: usize> Copy for S<M> {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `S<_>`\n+   |                             ^^^^\n+   |\n+note: required by a bound in `S`\n+  --> $DIR/bad-const-wf-doesnt-specialize.rs:6:10\n+   |\n+LL | struct S<const L: usize>;\n+   |          ^^^^^^^^^^^^^^ required by this bound in `S`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0119`."}, {"sha": "b6c464d45a2e30ad0c5ffb583178952580d58b9c", "filename": "tests/ui/suggestions/issue-109396.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fsuggestions%2Fissue-109396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fsuggestions%2Fissue-109396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-109396.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,12 @@\n+fn main() {\n+    {\n+        let mut mutex = std::mem::zeroed(\n+            //~^ ERROR this function takes 0 arguments but 4 arguments were supplied\n+            file.as_raw_fd(),\n+            //~^ ERROR expected value, found macro `file`\n+            0,\n+            0,\n+            0,\n+        );\n+    }\n+}"}, {"sha": "eca160e2fab2c763e21a8cad3fb52a99fe3b24a0", "filename": "tests/ui/suggestions/issue-109396.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fsuggestions%2Fissue-109396.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Fsuggestions%2Fissue-109396.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-109396.stderr?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,34 @@\n+error[E0423]: expected value, found macro `file`\n+  --> $DIR/issue-109396.rs:5:13\n+   |\n+LL |             file.as_raw_fd(),\n+   |             ^^^^ not a value\n+\n+error[E0061]: this function takes 0 arguments but 4 arguments were supplied\n+  --> $DIR/issue-109396.rs:3:25\n+   |\n+LL |         let mut mutex = std::mem::zeroed(\n+   |                         ^^^^^^^^^^^^^^^^\n+LL |\n+LL |             file.as_raw_fd(),\n+   |             ---------------- unexpected argument\n+LL |\n+LL |             0,\n+   |             - unexpected argument of type `{integer}`\n+LL |             0,\n+   |             - unexpected argument of type `{integer}`\n+LL |             0,\n+   |             - unexpected argument of type `{integer}`\n+   |\n+note: function defined here\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+help: remove the extra arguments\n+   |\n+LL -             file.as_raw_fd(),\n+LL +             ,\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0061, E0423.\n+For more information about an error, try `rustc --explain E0061`."}, {"sha": "2ff16b4af38d4fab44da3d4e07ec6afdb339fdf7", "filename": "tests/ui/traits/cycle-cache-err-60010.stderr", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,22 +1,9 @@\n-error[E0275]: overflow evaluating the requirement `SalsaStorage: RefUnwindSafe`\n+error[E0275]: overflow evaluating the requirement `RootDatabase: RefUnwindSafe`\n   --> $DIR/cycle-cache-err-60010.rs:27:13\n    |\n LL |     _parse: <ParseQuery as Query<RootDatabase>>::Data,\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: required because it appears within the type `PhantomData<SalsaStorage>`\n-   = note: required because it appears within the type `Unique<SalsaStorage>`\n-   = note: required because it appears within the type `Box<SalsaStorage>`\n-note: required because it appears within the type `Runtime<RootDatabase>`\n-  --> $DIR/cycle-cache-err-60010.rs:23:8\n-   |\n-LL | struct Runtime<DB: Database> {\n-   |        ^^^^^^^\n-note: required because it appears within the type `RootDatabase`\n-  --> $DIR/cycle-cache-err-60010.rs:20:8\n-   |\n-LL | struct RootDatabase {\n-   |        ^^^^^^^^^^^^\n note: required for `RootDatabase` to implement `SourceDatabase`\n   --> $DIR/cycle-cache-err-60010.rs:44:9\n    |"}, {"sha": "4eca643a92d4c7143d6e36f907a4bbe63552f7ba", "filename": "tests/ui/traits/issue-91949-hangs-on-recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ftraits%2Fissue-91949-hangs-on-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ftraits%2Fissue-91949-hangs-on-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fissue-91949-hangs-on-recursion.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,6 +1,6 @@\n // build-fail\n // compile-flags: -Zinline-mir=no\n-// error-pattern: overflow evaluating the requirement `(): Sized`\n+// error-pattern: overflow evaluating the requirement `<std::iter::Empty<()> as Iterator>::Item == ()`\n // error-pattern: function cannot return without recursing\n // normalize-stderr-test: \"long-type-\\d+\" -> \"long-type-hash\"\n "}, {"sha": "144990d50f00088ebded469495593bb234b4ca28", "filename": "tests/ui/traits/issue-91949-hangs-on-recursion.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ftraits%2Fissue-91949-hangs-on-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ftraits%2Fissue-91949-hangs-on-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fissue-91949-hangs-on-recursion.stderr?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -12,11 +12,17 @@ LL |       recurse(IteratorOfWrapped(elements).map(|t| t.0))\n    = help: a `loop` may express intention better if this is on purpose\n    = note: `#[warn(unconditional_recursion)]` on by default\n \n-error[E0275]: overflow evaluating the requirement `(): Sized`\n+error[E0275]: overflow evaluating the requirement `<std::iter::Empty<()> as Iterator>::Item == ()`\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"512\"]` attribute to your crate (`issue_91949_hangs_on_recursion`)\n-   = note: required for `std::iter::Empty<()>` to implement `Iterator`\n-   = note: 171 redundant requirements hidden\n+note: required for `IteratorOfWrapped<(), std::iter::Empty<()>>` to implement `Iterator`\n+  --> $DIR/issue-91949-hangs-on-recursion.rs:16:32\n+   |\n+LL | impl<T, I: Iterator<Item = T>> Iterator for IteratorOfWrapped<T, I> {\n+   |                     --------   ^^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |                     |\n+   |                     unsatisfied trait bound introduced here\n+   = note: 256 redundant requirements hidden\n    = note: required for `IteratorOfWrapped<(), Map<IteratorOfWrapped<(), Map<IteratorOfWrapped<(), Map<..., ...>>, ...>>, ...>>` to implement `Iterator`\n    = note: the full type name has been written to '$TEST_BUILD_DIR/traits/issue-91949-hangs-on-recursion/issue-91949-hangs-on-recursion.long-type-hash.txt'\n "}, {"sha": "0599e51d7ad8cca56a301706ec7365261dda663d", "filename": "tests/ui/traits/new-solver/fn-trait.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -1,13 +1,32 @@\n // compile-flags: -Ztrait-solver=next\n-// check-pass\n \n fn require_fn(_: impl Fn() -> i32) {}\n \n fn f() -> i32 {\n     1i32\n }\n \n+extern \"C\" fn g() -> i32 {\n+    2i32\n+}\n+\n+unsafe fn h() -> i32 {\n+    2i32\n+}\n+\n fn main() {\n     require_fn(f);\n     require_fn(f as fn() -> i32);\n+    require_fn(f as unsafe fn() -> i32);\n+    //~^ ERROR: expected a `Fn<()>` closure, found `unsafe fn() -> i32`\n+    //~| ERROR: type mismatch resolving `<unsafe fn() -> i32 as FnOnce<()>>::Output == i32`\n+    require_fn(g);\n+    //~^ ERROR: expected a `Fn<()>` closure, found `extern \"C\" fn() -> i32 {g}`\n+    //~| ERROR: type mismatch resolving `<extern \"C\" fn() -> i32 {g} as FnOnce<()>>::Output == i32`\n+    require_fn(g as extern \"C\" fn() -> i32);\n+    //~^ ERROR: expected a `Fn<()>` closure, found `extern \"C\" fn() -> i32`\n+    //~| ERROR: type mismatch resolving `<extern \"C\" fn() -> i32 as FnOnce<()>>::Output == i32`\n+    require_fn(h);\n+    //~^ ERROR: expected a `Fn<()>` closure, found `unsafe fn() -> i32 {h}`\n+    //~| ERROR: type mismatch resolving `<unsafe fn() -> i32 {h} as FnOnce<()>>::Output == i32`\n }"}, {"sha": "d52bcaf25b87c14d40a98670fedb42065744537f", "filename": "tests/ui/traits/new-solver/fn-trait.stderr", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.stderr?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,124 @@\n+error[E0277]: expected a `Fn<()>` closure, found `unsafe fn() -> i32`\n+  --> $DIR/fn-trait.rs:20:16\n+   |\n+LL |     require_fn(f as unsafe fn() -> i32);\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^ call the function in a closure: `|| unsafe { /* code */ }`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `Fn<()>` is not implemented for `unsafe fn() -> i32`\n+   = note: wrap the `unsafe fn() -> i32` in a closure with no arguments: `|| { /* code */ }`\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:23\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                       ^^^^^^^^^^^ required by this bound in `require_fn`\n+\n+error[E0271]: type mismatch resolving `<unsafe fn() -> i32 as FnOnce<()>>::Output == i32`\n+  --> $DIR/fn-trait.rs:20:16\n+   |\n+LL |     require_fn(f as unsafe fn() -> i32);\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^ types differ\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:31\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                               ^^^ required by this bound in `require_fn`\n+\n+error[E0277]: expected a `Fn<()>` closure, found `extern \"C\" fn() -> i32 {g}`\n+  --> $DIR/fn-trait.rs:23:16\n+   |\n+LL |     require_fn(g);\n+   |     ---------- ^ expected an `Fn<()>` closure, found `extern \"C\" fn() -> i32 {g}`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `Fn<()>` is not implemented for fn item `extern \"C\" fn() -> i32 {g}`\n+   = note: wrap the `extern \"C\" fn() -> i32 {g}` in a closure with no arguments: `|| { /* code */ }`\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:23\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                       ^^^^^^^^^^^ required by this bound in `require_fn`\n+\n+error[E0271]: type mismatch resolving `<extern \"C\" fn() -> i32 {g} as FnOnce<()>>::Output == i32`\n+  --> $DIR/fn-trait.rs:23:16\n+   |\n+LL |     require_fn(g);\n+   |     ---------- ^ types differ\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:31\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                               ^^^ required by this bound in `require_fn`\n+\n+error[E0277]: expected a `Fn<()>` closure, found `extern \"C\" fn() -> i32`\n+  --> $DIR/fn-trait.rs:26:16\n+   |\n+LL |     require_fn(g as extern \"C\" fn() -> i32);\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an `Fn<()>` closure, found `extern \"C\" fn() -> i32`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `Fn<()>` is not implemented for `extern \"C\" fn() -> i32`\n+   = note: wrap the `extern \"C\" fn() -> i32` in a closure with no arguments: `|| { /* code */ }`\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:23\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                       ^^^^^^^^^^^ required by this bound in `require_fn`\n+\n+error[E0271]: type mismatch resolving `<extern \"C\" fn() -> i32 as FnOnce<()>>::Output == i32`\n+  --> $DIR/fn-trait.rs:26:16\n+   |\n+LL |     require_fn(g as extern \"C\" fn() -> i32);\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ types differ\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:31\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                               ^^^ required by this bound in `require_fn`\n+\n+error[E0277]: expected a `Fn<()>` closure, found `unsafe fn() -> i32 {h}`\n+  --> $DIR/fn-trait.rs:29:16\n+   |\n+LL |     require_fn(h);\n+   |     ---------- ^ call the function in a closure: `|| unsafe { /* code */ }`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `Fn<()>` is not implemented for fn item `unsafe fn() -> i32 {h}`\n+   = note: wrap the `unsafe fn() -> i32 {h}` in a closure with no arguments: `|| { /* code */ }`\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:23\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                       ^^^^^^^^^^^ required by this bound in `require_fn`\n+\n+error[E0271]: type mismatch resolving `<unsafe fn() -> i32 {h} as FnOnce<()>>::Output == i32`\n+  --> $DIR/fn-trait.rs:29:16\n+   |\n+LL |     require_fn(h);\n+   |     ---------- ^ types differ\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:31\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                               ^^^ required by this bound in `require_fn`\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0271, E0277.\n+For more information about an error, try `rustc --explain E0271`."}, {"sha": "a635edb4485bd94425a6b5a481c7593b72e99a19", "filename": "tests/ui/traits/non_lifetime_binders/supertrait-object-safety.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fsupertrait-object-safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fsupertrait-object-safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fsupertrait-object-safety.rs?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,24 @@\n+#![feature(non_lifetime_binders)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+\n+trait Foo: for<T> Bar<T> {}\n+\n+trait Bar<T: ?Sized> {\n+    fn method(&self) {}\n+}\n+\n+fn needs_bar(x: &(impl Bar<i32> + ?Sized)) {\n+    x.method();\n+}\n+\n+impl Foo for () {}\n+\n+impl<T: ?Sized> Bar<T> for () {}\n+\n+fn main() {\n+    let x: &dyn Foo = &();\n+    //~^ ERROR the trait `Foo` cannot be made into an object\n+    //~| ERROR the trait `Foo` cannot be made into an object\n+    needs_bar(x);\n+    //~^ ERROR the trait `Foo` cannot be made into an object\n+}"}, {"sha": "47fa29b66488b4ec29beada11f8439b1f8d8474c", "filename": "tests/ui/traits/non_lifetime_binders/supertrait-object-safety.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fsupertrait-object-safety.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8795fab187a0c4fccbe41775fa9d42f3515c79a/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fsupertrait-object-safety.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fsupertrait-object-safety.stderr?ref=d8795fab187a0c4fccbe41775fa9d42f3515c79a", "patch": "@@ -0,0 +1,56 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/supertrait-object-safety.rs:1:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #108185 <https://github.com/rust-lang/rust/issues/108185> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/supertrait-object-safety.rs:19:23\n+   |\n+LL |     let x: &dyn Foo = &();\n+   |                       ^^^ `Foo` cannot be made into an object\n+   |\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/supertrait-object-safety.rs:4:12\n+   |\n+LL | trait Foo: for<T> Bar<T> {}\n+   |       ---  ^^^^^^^^^^^^^ ...because where clause cannot reference non-lifetime `for<...>` variables\n+   |       |\n+   |       this trait cannot be made into an object...\n+   = note: required for `&()` to implement `CoerceUnsized<&dyn Foo>`\n+   = note: required by cast to type `&dyn Foo`\n+\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/supertrait-object-safety.rs:19:12\n+   |\n+LL |     let x: &dyn Foo = &();\n+   |            ^^^^^^^^ `Foo` cannot be made into an object\n+   |\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/supertrait-object-safety.rs:4:12\n+   |\n+LL | trait Foo: for<T> Bar<T> {}\n+   |       ---  ^^^^^^^^^^^^^ ...because where clause cannot reference non-lifetime `for<...>` variables\n+   |       |\n+   |       this trait cannot be made into an object...\n+\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/supertrait-object-safety.rs:22:5\n+   |\n+LL |     needs_bar(x);\n+   |     ^^^^^^^^^ `Foo` cannot be made into an object\n+   |\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/supertrait-object-safety.rs:4:12\n+   |\n+LL | trait Foo: for<T> Bar<T> {}\n+   |       ---  ^^^^^^^^^^^^^ ...because where clause cannot reference non-lifetime `for<...>` variables\n+   |       |\n+   |       this trait cannot be made into an object...\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0038`."}]}