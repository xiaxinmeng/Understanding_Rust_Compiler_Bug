{"sha": "cfa4ac66c194046f631ce076c75516ecfdeb77ee", "node_id": "C_kwDOAAsO6NoAKGNmYTRhYzY2YzE5NDA0NmY2MzFjZTA3NmM3NTUxNmVjZmRlYjc3ZWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-06T15:30:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-06T15:30:46Z"}, "message": "Auto merge of #92609 - matthiaskrgr:rollup-ldp47ot, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #92058 (Make Run button visible on hover)\n - #92288 (Fix a pair of mistyped test cases in `std::net::ip`)\n - #92349 (Fix rustdoc::private_doc_tests lint for public re-exported items)\n - #92360 (Some cleanups around check_argument_types)\n - #92389 (Regression test for borrowck ICE #92015)\n - #92404 (Fix font size for [src] links in headers)\n - #92443 (Rustdoc: resolve associated traits for non-generic primitive types)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "10ace45fd5a86349c627f743747c097c5cdb7256", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10ace45fd5a86349c627f743747c097c5cdb7256"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfa4ac66c194046f631ce076c75516ecfdeb77ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfa4ac66c194046f631ce076c75516ecfdeb77ee", "html_url": "https://github.com/rust-lang/rust/commit/cfa4ac66c194046f631ce076c75516ecfdeb77ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfa4ac66c194046f631ce076c75516ecfdeb77ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a77cc64af491a31db224109a76b9b81cd26cd07c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a77cc64af491a31db224109a76b9b81cd26cd07c", "html_url": "https://github.com/rust-lang/rust/commit/a77cc64af491a31db224109a76b9b81cd26cd07c"}, {"sha": "26a90e4cd780175dd2d9dbf061eccd53eb9a2489", "url": "https://api.github.com/repos/rust-lang/rust/commits/26a90e4cd780175dd2d9dbf061eccd53eb9a2489", "html_url": "https://github.com/rust-lang/rust/commit/26a90e4cd780175dd2d9dbf061eccd53eb9a2489"}], "stats": {"total": 508, "additions": 353, "deletions": 155}, "files": [{"sha": "eea8f40635d74a416ee51b9f6159c164b4222737", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -496,7 +496,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             call_expr.span,\n             call_expr,\n             fn_sig.inputs(),\n-            &expected_arg_tys,\n+            expected_arg_tys,\n             arg_exprs,\n             fn_sig.c_variadic,\n             TupleArgumentsFlag::DontTupleArguments,\n@@ -529,7 +529,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             call_expr.span,\n             call_expr,\n             fn_sig.inputs(),\n-            &expected_arg_tys,\n+            expected_arg_tys,\n             arg_exprs,\n             fn_sig.c_variadic,\n             TupleArgumentsFlag::TupleArguments,"}, {"sha": "e796fe58170d2e2bddaa87b7fdd111b248455c34", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 121, "deletions": 106, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 sp,\n                 expr,\n                 &err_inputs,\n-                &[],\n+                vec![],\n                 args_no_rcvr,\n                 false,\n                 tuple_arguments,\n@@ -73,7 +73,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let method = method.unwrap();\n         // HACK(eddyb) ignore self in the definition (see above).\n-        let expected_arg_tys = self.expected_inputs_for_expected_output(\n+        let expected_input_tys = self.expected_inputs_for_expected_output(\n             sp,\n             expected,\n             method.sig.output(),\n@@ -83,7 +83,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             sp,\n             expr,\n             &method.sig.inputs()[1..],\n-            &expected_arg_tys[..],\n+            expected_input_tys,\n             args_no_rcvr,\n             method.sig.c_variadic,\n             tuple_arguments,\n@@ -96,34 +96,43 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// method calls and overloaded operators.\n     pub(in super::super) fn check_argument_types(\n         &self,\n-        sp: Span,\n-        expr: &'tcx hir::Expr<'tcx>,\n-        fn_inputs: &[Ty<'tcx>],\n-        expected_arg_tys: &[Ty<'tcx>],\n-        args: &'tcx [hir::Expr<'tcx>],\n+        // Span enclosing the call site\n+        call_span: Span,\n+        // Expression of the call site\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        // Types (as defined in the *signature* of the target function)\n+        formal_input_tys: &[Ty<'tcx>],\n+        // More specific expected types, after unifying with caller output types\n+        expected_input_tys: Vec<Ty<'tcx>>,\n+        // The expressions for each provided argument\n+        provided_args: &'tcx [hir::Expr<'tcx>],\n+        // Whether the function is variadic, for example when imported from C\n         c_variadic: bool,\n+        // Whether the arguments have been bundled in a tuple (ex: closures)\n         tuple_arguments: TupleArgumentsFlag,\n-        def_id: Option<DefId>,\n+        // The DefId for the function being called, for better error messages\n+        fn_def_id: Option<DefId>,\n     ) {\n         let tcx = self.tcx;\n         // Grab the argument types, supplying fresh type variables\n         // if the wrong number of arguments were supplied\n-        let supplied_arg_count = if tuple_arguments == DontTupleArguments { args.len() } else { 1 };\n+        let supplied_arg_count =\n+            if tuple_arguments == DontTupleArguments { provided_args.len() } else { 1 };\n \n         // All the input types from the fn signature must outlive the call\n         // so as to validate implied bounds.\n-        for (&fn_input_ty, arg_expr) in iter::zip(fn_inputs, args) {\n+        for (&fn_input_ty, arg_expr) in iter::zip(formal_input_tys, provided_args) {\n             self.register_wf_obligation(fn_input_ty.into(), arg_expr.span, traits::MiscObligation);\n         }\n \n-        let expected_arg_count = fn_inputs.len();\n+        let expected_arg_count = formal_input_tys.len();\n \n         let param_count_error = |expected_count: usize,\n                                  arg_count: usize,\n                                  error_code: &str,\n                                  c_variadic: bool,\n                                  sugg_unit: bool| {\n-            let (span, start_span, args, ctor_of) = match &expr.kind {\n+            let (span, start_span, args, ctor_of) = match &call_expr.kind {\n                 hir::ExprKind::Call(\n                     hir::Expr {\n                         span,\n@@ -156,14 +165,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     &args[1..], // Skip the receiver.\n                     None,       // methods are never ctors\n                 ),\n-                k => span_bug!(sp, \"checking argument types on a non-call: `{:?}`\", k),\n+                k => span_bug!(call_span, \"checking argument types on a non-call: `{:?}`\", k),\n             };\n-            let arg_spans = if args.is_empty() {\n+            let arg_spans = if provided_args.is_empty() {\n                 // foo()\n                 // ^^^-- supplied 0 arguments\n                 // |\n                 // expected 2 arguments\n-                vec![tcx.sess.source_map().next_point(start_span).with_hi(sp.hi())]\n+                vec![tcx.sess.source_map().next_point(start_span).with_hi(call_span.hi())]\n             } else {\n                 // foo(1, 2, 3)\n                 // ^^^ -  -  - supplied 3 arguments\n@@ -196,7 +205,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n             }\n \n-            if let Some(def_id) = def_id {\n+            if let Some(def_id) = fn_def_id {\n                 if let Some(def_span) = tcx.def_ident_span(def_id) {\n                     let mut spans: MultiSpan = def_span.into();\n \n@@ -218,7 +227,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             if sugg_unit {\n-                let sugg_span = tcx.sess.source_map().end_point(expr.span);\n+                let sugg_span = tcx.sess.source_map().end_point(call_expr.span);\n                 // remove closing `)` from the span\n                 let sugg_span = sugg_span.shrink_to_lo();\n                 err.span_suggestion(\n@@ -240,164 +249,170 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.emit();\n         };\n \n-        let mut expected_arg_tys = expected_arg_tys.to_vec();\n-\n-        let formal_tys = if tuple_arguments == TupleArguments {\n-            let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n+        let (formal_input_tys, expected_input_tys) = if tuple_arguments == TupleArguments {\n+            let tuple_type = self.structurally_resolved_type(call_span, formal_input_tys[0]);\n             match tuple_type.kind() {\n-                ty::Tuple(arg_types) if arg_types.len() != args.len() => {\n-                    param_count_error(arg_types.len(), args.len(), \"E0057\", false, false);\n-                    expected_arg_tys = vec![];\n-                    self.err_args(args.len())\n+                ty::Tuple(arg_types) if arg_types.len() != provided_args.len() => {\n+                    param_count_error(arg_types.len(), provided_args.len(), \"E0057\", false, false);\n+                    (self.err_args(provided_args.len()), vec![])\n                 }\n                 ty::Tuple(arg_types) => {\n-                    expected_arg_tys = match expected_arg_tys.get(0) {\n+                    let expected_input_tys = match expected_input_tys.get(0) {\n                         Some(&ty) => match ty.kind() {\n                             ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).collect(),\n                             _ => vec![],\n                         },\n                         None => vec![],\n                     };\n-                    arg_types.iter().map(|k| k.expect_ty()).collect()\n+                    (arg_types.iter().map(|k| k.expect_ty()).collect(), expected_input_tys)\n                 }\n                 _ => {\n                     struct_span_err!(\n                         tcx.sess,\n-                        sp,\n+                        call_span,\n                         E0059,\n                         \"cannot use call notation; the first type parameter \\\n                          for the function trait is neither a tuple nor unit\"\n                     )\n                     .emit();\n-                    expected_arg_tys = vec![];\n-                    self.err_args(args.len())\n+                    (self.err_args(provided_args.len()), vec![])\n                 }\n             }\n         } else if expected_arg_count == supplied_arg_count {\n-            fn_inputs.to_vec()\n+            (formal_input_tys.to_vec(), expected_input_tys)\n         } else if c_variadic {\n             if supplied_arg_count >= expected_arg_count {\n-                fn_inputs.to_vec()\n+                (formal_input_tys.to_vec(), expected_input_tys)\n             } else {\n                 param_count_error(expected_arg_count, supplied_arg_count, \"E0060\", true, false);\n-                expected_arg_tys = vec![];\n-                self.err_args(supplied_arg_count)\n+                (self.err_args(supplied_arg_count), vec![])\n             }\n         } else {\n             // is the missing argument of type `()`?\n-            let sugg_unit = if expected_arg_tys.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_vars_if_possible(expected_arg_tys[0]).is_unit()\n-            } else if fn_inputs.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_vars_if_possible(fn_inputs[0]).is_unit()\n+            let sugg_unit = if expected_input_tys.len() == 1 && supplied_arg_count == 0 {\n+                self.resolve_vars_if_possible(expected_input_tys[0]).is_unit()\n+            } else if formal_input_tys.len() == 1 && supplied_arg_count == 0 {\n+                self.resolve_vars_if_possible(formal_input_tys[0]).is_unit()\n             } else {\n                 false\n             };\n             param_count_error(expected_arg_count, supplied_arg_count, \"E0061\", false, sugg_unit);\n \n-            expected_arg_tys = vec![];\n-            self.err_args(supplied_arg_count)\n+            (self.err_args(supplied_arg_count), vec![])\n         };\n \n         debug!(\n-            \"check_argument_types: formal_tys={:?}\",\n-            formal_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>()\n+            \"check_argument_types: formal_input_tys={:?}\",\n+            formal_input_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>()\n         );\n \n-        // If there is no expectation, expect formal_tys.\n-        let expected_arg_tys =\n-            if !expected_arg_tys.is_empty() { expected_arg_tys } else { formal_tys.clone() };\n+        // If there is no expectation, expect formal_input_tys.\n+        let expected_input_tys = if !expected_input_tys.is_empty() {\n+            expected_input_tys\n+        } else {\n+            formal_input_tys.clone()\n+        };\n+\n+        assert_eq!(expected_input_tys.len(), formal_input_tys.len());\n \n+        // Keep track of the fully coerced argument types\n         let mut final_arg_types: Vec<(usize, Ty<'_>, Ty<'_>)> = vec![];\n \n+        // We introduce a helper function to demand that a given argument satisfy a given input\n+        // This is more complicated than just checking type equality, as arguments could be coerced\n+        // This version writes those types back so further type checking uses the narrowed types\n+        let demand_compatible = |idx, final_arg_types: &mut Vec<(usize, Ty<'tcx>, Ty<'tcx>)>| {\n+            let formal_input_ty: Ty<'tcx> = formal_input_tys[idx];\n+            let expected_input_ty: Ty<'tcx> = expected_input_tys[idx];\n+            let provided_arg = &provided_args[idx];\n+\n+            debug!(\"checking argument {}: {:?} = {:?}\", idx, provided_arg, formal_input_ty);\n+\n+            // The special-cased logic below has three functions:\n+            // 1. Provide as good of an expected type as possible.\n+            let expectation = Expectation::rvalue_hint(self, expected_input_ty);\n+\n+            let checked_ty = self.check_expr_with_expectation(provided_arg, expectation);\n+\n+            // 2. Coerce to the most detailed type that could be coerced\n+            //    to, which is `expected_ty` if `rvalue_hint` returns an\n+            //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n+            let coerced_ty = expectation.only_has_type(self).unwrap_or(formal_input_ty);\n+\n+            // Keep track of these for below\n+            final_arg_types.push((idx, checked_ty, coerced_ty));\n+\n+            // Cause selection errors caused by resolving a single argument to point at the\n+            // argument and not the call. This is otherwise redundant with the `demand_coerce`\n+            // call immediately after, but it lets us customize the span pointed to in the\n+            // fulfillment error to be more accurate.\n+            let _ =\n+                self.resolve_vars_with_obligations_and_mutate_fulfillment(coerced_ty, |errors| {\n+                    self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n+                    self.point_at_arg_instead_of_call_if_possible(\n+                        errors,\n+                        &final_arg_types,\n+                        call_expr,\n+                        call_span,\n+                        provided_args,\n+                    );\n+                });\n+\n+            // We're processing function arguments so we definitely want to use\n+            // two-phase borrows.\n+            self.demand_coerce(&provided_arg, checked_ty, coerced_ty, None, AllowTwoPhase::Yes);\n+\n+            // 3. Relate the expected type and the formal one,\n+            //    if the expected type was used for the coercion.\n+            self.demand_suptype(provided_arg.span, formal_input_ty, coerced_ty);\n+        };\n+\n         // Check the arguments.\n         // We do this in a pretty awful way: first we type-check any arguments\n         // that are not closures, then we type-check the closures. This is so\n         // that we have more information about the types of arguments when we\n         // type-check the functions. This isn't really the right way to do this.\n         for check_closures in [false, true] {\n-            debug!(\"check_closures={}\", check_closures);\n-\n             // More awful hacks: before we check argument types, try to do\n             // an \"opportunistic\" trait resolution of any trait bounds on\n             // the call. This helps coercions.\n             if check_closures {\n                 self.select_obligations_where_possible(false, |errors| {\n-                    self.point_at_type_arg_instead_of_call_if_possible(errors, expr);\n+                    self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n                     self.point_at_arg_instead_of_call_if_possible(\n                         errors,\n                         &final_arg_types,\n-                        expr,\n-                        sp,\n-                        &args,\n+                        call_expr,\n+                        call_span,\n+                        &provided_args,\n                     );\n                 })\n             }\n \n-            // For C-variadic functions, we don't have a declared type for all of\n-            // the arguments hence we only do our usual type checking with\n-            // the arguments who's types we do know.\n-            let t = if c_variadic {\n-                expected_arg_count\n-            } else if tuple_arguments == TupleArguments {\n-                args.len()\n-            } else {\n-                supplied_arg_count\n-            };\n-            for (i, arg) in args.iter().take(t).enumerate() {\n+            let minimum_input_count = formal_input_tys.len();\n+            for (idx, arg) in provided_args.iter().enumerate() {\n                 // Warn only for the first loop (the \"no closures\" one).\n                 // Closure arguments themselves can't be diverging, but\n                 // a previous argument can, e.g., `foo(panic!(), || {})`.\n                 if !check_closures {\n                     self.warn_if_unreachable(arg.hir_id, arg.span, \"expression\");\n                 }\n \n-                let is_closure = matches!(arg.kind, ExprKind::Closure(..));\n+                // For C-variadic functions, we don't have a declared type for all of\n+                // the arguments hence we only do our usual type checking with\n+                // the arguments who's types we do know. However, we *can* check\n+                // for unreachable expressions (see above).\n+                // FIXME: unreachable warning current isn't emitted\n+                if idx >= minimum_input_count {\n+                    continue;\n+                }\n \n+                let is_closure = matches!(arg.kind, ExprKind::Closure(..));\n                 if is_closure != check_closures {\n                     continue;\n                 }\n \n-                let formal_ty = formal_tys[i];\n-                debug!(\"checking argument {}: {:?} = {:?}\", i, arg, formal_ty);\n-\n-                // The special-cased logic below has three functions:\n-                // 1. Provide as good of an expected type as possible.\n-                let expected = Expectation::rvalue_hint(self, expected_arg_tys[i]);\n-\n-                let checked_ty = self.check_expr_with_expectation(&arg, expected);\n-\n-                // 2. Coerce to the most detailed type that could be coerced\n-                //    to, which is `expected_ty` if `rvalue_hint` returns an\n-                //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n-                let coerce_ty = expected.only_has_type(self).unwrap_or(formal_ty);\n-\n-                final_arg_types.push((i, checked_ty, coerce_ty));\n-\n-                // Cause selection errors caused by resolving a single argument to point at the\n-                // argument and not the call. This is otherwise redundant with the `demand_coerce`\n-                // call immediately after, but it lets us customize the span pointed to in the\n-                // fulfillment error to be more accurate.\n-                let _ = self.resolve_vars_with_obligations_and_mutate_fulfillment(\n-                    coerce_ty,\n-                    |errors| {\n-                        self.point_at_type_arg_instead_of_call_if_possible(errors, expr);\n-                        self.point_at_arg_instead_of_call_if_possible(\n-                            errors,\n-                            &final_arg_types,\n-                            expr,\n-                            sp,\n-                            args,\n-                        );\n-                    },\n-                );\n-\n-                // We're processing function arguments so we definitely want to use\n-                // two-phase borrows.\n-                self.demand_coerce(&arg, checked_ty, coerce_ty, None, AllowTwoPhase::Yes);\n-\n-                // 3. Relate the expected type and the formal one,\n-                //    if the expected type was used for the coercion.\n-                self.demand_suptype(arg.span, formal_ty, coerce_ty);\n+                demand_compatible(idx, &mut final_arg_types);\n             }\n         }\n \n@@ -410,7 +425,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 MissingCastForVariadicArg { sess, span, ty, cast_ty }.diagnostic().emit()\n             }\n \n-            for arg in args.iter().skip(expected_arg_count) {\n+            for arg in provided_args.iter().skip(expected_arg_count) {\n                 let arg_ty = self.check_expr(&arg);\n \n                 // There are a few types which get autopromoted when passed via varargs"}, {"sha": "7956c6a25e4959acf2e6f1802b01e8162ef7c0ca", "filename": "library/std/src/net/ip/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -77,10 +77,10 @@ fn test_from_str_ipv4_in_ipv6() {\n     let none: Option<Ipv4Addr> = \"::127.0.0.1:\".parse().ok();\n     assert_eq!(None, none);\n     // not enough groups\n-    let none: Option<Ipv6Addr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n+    let none: Option<Ipv6Addr> = \"1:2:3:4:5:127.0.0.1\".parse().ok();\n     assert_eq!(None, none);\n     // too many groups\n-    let none: Option<Ipv6Addr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n+    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:127.0.0.1\".parse().ok();\n     assert_eq!(None, none);\n }\n "}, {"sha": "28cb8ae48e21080e0d9eac90254132bcc1aaae69", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -1080,8 +1080,11 @@ body.blur > :not(#help) {\n \n .impl-items .srclink, .impl .srclink, .methods .srclink {\n \t/* Override header settings otherwise it's too bold */\n-\tfont-size: 1.0625rem;\n \tfont-weight: normal;\n+\tfont-size: 1rem;\n+}\n+.impl .srclink {\n+\tfont-size: 1.0625rem;\n }\n \n .rightside {\n@@ -1117,6 +1120,7 @@ pre.rust .question-mark {\n \n a.test-arrow {\n \tdisplay: inline-block;\n+\tvisibility: hidden;\n \tposition: absolute;\n \tpadding: 5px 10px 5px 10px;\n \tborder-radius: 5px;\n@@ -1125,10 +1129,12 @@ a.test-arrow {\n \tright: 5px;\n \tz-index: 1;\n }\n+.example-wrap:hover .test-arrow {\n+\tvisibility: visible;\n+}\n a.test-arrow:hover{\n \ttext-decoration: none;\n }\n-\n .section-header:hover a:before {\n \tposition: absolute;\n \tleft: -25px;"}, {"sha": "6ed7845e83a354f9c8ebe31c6bf11169abeb9d24", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -351,11 +351,8 @@ a.test-arrow:hover {\n \tcolor: #999;\n }\n \n-:target, :target > * {\n-\tbackground: rgba(255, 236, 164, 0.06);\n-}\n-\n :target {\n+\tbackground: rgba(255, 236, 164, 0.06);\n \tborder-right: 3px solid rgba(255, 180, 76, 0.85);\n }\n "}, {"sha": "64b6eb6696b831219f19899ee844b17e23cb5e63", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -295,11 +295,8 @@ a.test-arrow:hover{\n \tcolor: #999;\n }\n \n-:target, :target > * {\n-\tbackground-color: #494a3d;\n-}\n-\n :target {\n+\tbackground-color: #494a3d;\n \tborder-right: 3px solid #bb7410;\n }\n "}, {"sha": "dbacc9f30735bf837f6632c14e26fa07fca7a15d", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -284,11 +284,8 @@ a.test-arrow:hover{\n \tcolor: #999;\n }\n \n-:target, :target > * {\n-\tbackground: #FDFFD3;\n-}\n-\n :target {\n+\tbackground: #FDFFD3;\n \tborder-right: 3px solid #AD7C37;\n }\n "}, {"sha": "e8f8ff988c1f0233b7db810c0e1f045491880092", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -131,7 +131,7 @@ crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n             );\n         }\n     } else if tests.found_tests > 0\n-        && !cx.cache.access_levels.is_public(item.def_id.expect_def_id())\n+        && !cx.cache.access_levels.is_exported(item.def_id.expect_def_id())\n     {\n         cx.tcx.struct_span_lint_hir(\n             crate::lint::PRIVATE_DOC_TESTS,"}, {"sha": "7953008628204f3e72b0ff460d14b7260e06ff3d", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 71, "deletions": 21, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def::{\n     PerNS,\n };\n use rustc_hir::def_id::{CrateNum, DefId};\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_middle::{bug, span_bug, ty};\n use rustc_resolve::ParentScope;\n use rustc_session::lint::Lint;\n@@ -618,6 +618,39 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         })\n     }\n \n+    /// Convert a PrimitiveType to a Ty, where possible.\n+    ///\n+    /// This is used for resolving trait impls for primitives\n+    fn primitive_type_to_ty(&mut self, prim: PrimitiveType) -> Option<Ty<'tcx>> {\n+        use PrimitiveType::*;\n+        let tcx = self.cx.tcx;\n+\n+        // FIXME: Only simple types are supported here, see if we can support\n+        // other types such as Tuple, Array, Slice, etc.\n+        // See https://github.com/rust-lang/rust/issues/90703#issuecomment-1004263455\n+        Some(tcx.mk_ty(match prim {\n+            Bool => ty::Bool,\n+            Str => ty::Str,\n+            Char => ty::Char,\n+            Never => ty::Never,\n+            I8 => ty::Int(ty::IntTy::I8),\n+            I16 => ty::Int(ty::IntTy::I16),\n+            I32 => ty::Int(ty::IntTy::I32),\n+            I64 => ty::Int(ty::IntTy::I64),\n+            I128 => ty::Int(ty::IntTy::I128),\n+            Isize => ty::Int(ty::IntTy::Isize),\n+            F32 => ty::Float(ty::FloatTy::F32),\n+            F64 => ty::Float(ty::FloatTy::F64),\n+            U8 => ty::Uint(ty::UintTy::U8),\n+            U16 => ty::Uint(ty::UintTy::U16),\n+            U32 => ty::Uint(ty::UintTy::U32),\n+            U64 => ty::Uint(ty::UintTy::U64),\n+            U128 => ty::Uint(ty::UintTy::U128),\n+            Usize => ty::Uint(ty::UintTy::Usize),\n+            _ => return None,\n+        }))\n+    }\n+\n     /// Returns:\n     /// - None if no associated item was found\n     /// - Some((_, _, Some(_))) if an item was found and should go through a side channel\n@@ -632,7 +665,25 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         let tcx = self.cx.tcx;\n \n         match root_res {\n-            Res::Primitive(prim) => self.resolve_primitive_associated_item(prim, ns, item_name),\n+            Res::Primitive(prim) => {\n+                self.resolve_primitive_associated_item(prim, ns, item_name).or_else(|| {\n+                    let assoc_item = self\n+                        .primitive_type_to_ty(prim)\n+                        .map(|ty| {\n+                            resolve_associated_trait_item(ty, module_id, item_name, ns, self.cx)\n+                        })\n+                        .flatten();\n+\n+                    assoc_item.map(|item| {\n+                        let kind = item.kind;\n+                        let fragment = UrlFragment::from_assoc_item(item_name, kind, false);\n+                        // HACK(jynelson): `clean` expects the type, not the associated item\n+                        // but the disambiguator logic expects the associated item.\n+                        // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                        (root_res, fragment, Some((kind.as_def_kind(), item.def_id)))\n+                    })\n+                })\n+            }\n             Res::Def(DefKind::TyAlias, did) => {\n                 // Resolve the link on the type the alias points to.\n                 // FIXME: if the associated item is defined directly on the type alias,\n@@ -666,8 +717,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // To handle that properly resolve() would have to support\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n                     .or_else(|| {\n-                        let item =\n-                            resolve_associated_trait_item(did, module_id, item_name, ns, self.cx);\n+                        let item = resolve_associated_trait_item(\n+                            tcx.type_of(did),\n+                            module_id,\n+                            item_name,\n+                            ns,\n+                            self.cx,\n+                        );\n                         debug!(\"got associated item {:?}\", item);\n                         item\n                     });\n@@ -767,20 +823,20 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n /// Given `[std::io::Error::source]`, where `source` is unresolved, this would\n /// find `std::error::Error::source` and return\n /// `<io::Error as error::Error>::source`.\n-fn resolve_associated_trait_item(\n-    did: DefId,\n+fn resolve_associated_trait_item<'a>(\n+    ty: Ty<'a>,\n     module: DefId,\n     item_name: Symbol,\n     ns: Namespace,\n-    cx: &mut DocContext<'_>,\n+    cx: &mut DocContext<'a>,\n ) -> Option<ty::AssocItem> {\n     // FIXME: this should also consider blanket impls (`impl<T> X for T`). Unfortunately\n     // `get_auto_trait_and_blanket_impls` is broken because the caching behavior is wrong. In the\n     // meantime, just don't look for these blanket impls.\n \n     // Next consider explicit impls: `impl MyTrait for MyType`\n     // Give precedence to inherent impls.\n-    let traits = traits_implemented_by(cx, did, module);\n+    let traits = traits_implemented_by(cx, ty, module);\n     debug!(\"considering traits {:?}\", traits);\n     let mut candidates = traits.iter().filter_map(|&trait_| {\n         cx.tcx.associated_items(trait_).find_by_name_and_namespace(\n@@ -799,7 +855,11 @@ fn resolve_associated_trait_item(\n ///\n /// NOTE: this cannot be a query because more traits could be available when more crates are compiled!\n /// So it is not stable to serialize cross-crate.\n-fn traits_implemented_by(cx: &mut DocContext<'_>, type_: DefId, module: DefId) -> FxHashSet<DefId> {\n+fn traits_implemented_by<'a>(\n+    cx: &mut DocContext<'a>,\n+    ty: Ty<'a>,\n+    module: DefId,\n+) -> FxHashSet<DefId> {\n     let mut resolver = cx.resolver.borrow_mut();\n     let in_scope_traits = cx.module_trait_cache.entry(module).or_insert_with(|| {\n         resolver.access(|resolver| {\n@@ -813,7 +873,6 @@ fn traits_implemented_by(cx: &mut DocContext<'_>, type_: DefId, module: DefId) -\n     });\n \n     let tcx = cx.tcx;\n-    let ty = tcx.type_of(type_);\n     let iter = in_scope_traits.iter().flat_map(|&trait_| {\n         trace!(\"considering explicit impl for trait {:?}\", trait_);\n \n@@ -826,19 +885,10 @@ fn traits_implemented_by(cx: &mut DocContext<'_>, type_: DefId, module: DefId) -\n                 \"comparing type {} with kind {:?} against type {:?}\",\n                 impl_type,\n                 impl_type.kind(),\n-                type_\n+                ty\n             );\n             // Fast path: if this is a primitive simple `==` will work\n-            let saw_impl = impl_type == ty\n-                || match impl_type.kind() {\n-                    // Check if these are the same def_id\n-                    ty::Adt(def, _) => {\n-                        debug!(\"adt def_id: {:?}\", def.did);\n-                        def.did == type_\n-                    }\n-                    ty::Foreign(def_id) => *def_id == type_,\n-                    _ => false,\n-                };\n+            let saw_impl = impl_type == ty;\n \n             if saw_impl { Some(trait_) } else { None }\n         })"}, {"sha": "b8efa8e302f71dd2eef0349d160708e584f65592", "filename": "src/test/rustdoc-gui/run-on-hover.goml", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-gui%2Frun-on-hover.goml", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-gui%2Frun-on-hover.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Frun-on-hover.goml?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -0,0 +1,7 @@\n+// Example code blocks sometimes have a \"Run\" button to run them on the\n+// Playground. That button is hidden until the user hovers over the code block.\n+// This test checks that it is hidden, and that it shows on hover.\n+goto: file://|DOC_PATH|/test_docs/fn.foo.html\n+assert-css: (\".test-arrow\", {\"visibility\": \"hidden\"})\n+move-cursor-to: \".example-wrap\"\n+assert-css: (\".test-arrow\", {\"visibility\": \"visible\"})"}, {"sha": "b0b2f122afdb90b7fe362b9f39d39ad3fbf069ce", "filename": "src/test/rustdoc-gui/src-font-size.goml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-gui%2Fsrc-font-size.goml", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-gui%2Fsrc-font-size.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc-font-size.goml?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -0,0 +1,12 @@\n+// This test ensures that the \"[src]\" have the same font size as their headers\n+// to avoid having some weird height difference in the background when the element\n+// is selected.\n+goto: file://|DOC_PATH|/test_docs/struct.Foo.html\n+show-text: true\n+// Check the impl headers.\n+assert-css: (\".impl.has-srclink .srclink\", {\"font-size\": \"17px\"}, ALL)\n+// The \".6\" part is because the font-size is actually \"1.1em\".\n+assert-css: (\".impl.has-srclink .code-header.in-band\", {\"font-size\": \"17.6px\"}, ALL)\n+// Check the impl items.\n+assert-css: (\".impl-items .has-srclink .srclink\", {\"font-size\": \"16px\"}, ALL)\n+assert-css: (\".impl-items .has-srclink .code-header\", {\"font-size\": \"16px\"}, ALL)"}, {"sha": "f75de949292a1b151a5ddd234f3e64d1ac25c7f6", "filename": "src/test/rustdoc-gui/src/test_docs/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -1,5 +1,6 @@\n //! The point of this crate is to be able to have enough different \"kinds\" of\n //! documentation generated so we can test each different features.\n+#![doc(html_playground_url=\"https://play.rust-lang.org/\")]\n \n #![crate_name = \"test_docs\"]\n #![feature(rustdoc_internals)]"}, {"sha": "587cbad68486422f1cb4d0ed487b1e011cac02d4", "filename": "src/test/rustdoc-ui/intra-doc/non-path-primitives.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.rs?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -28,7 +28,6 @@\n //! [unit::eq] //~ ERROR unresolved\n //! [tuple::eq] //~ ERROR unresolved\n //! [fn::eq] //~ ERROR unresolved\n-//! [never::eq] //~ ERROR unresolved\n \n // FIXME(#78800): This breaks because it's a blanket impl\n // (I think? Might break for other reasons too.)"}, {"sha": "4828a30446355d70b91c605165be598399076039", "filename": "src/test/rustdoc-ui/intra-doc/non-path-primitives.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -53,17 +53,11 @@ error: unresolved link to `fn::eq`\n LL | //! [fn::eq]\n    |      ^^^^^^ the builtin type `fn` has no associated item named `eq`\n \n-error: unresolved link to `never::eq`\n-  --> $DIR/non-path-primitives.rs:31:6\n-   |\n-LL | //! [never::eq]\n-   |      ^^^^^^^^^ the builtin type `never` has no associated item named `eq`\n-\n error: unresolved link to `reference::deref`\n-  --> $DIR/non-path-primitives.rs:35:6\n+  --> $DIR/non-path-primitives.rs:34:6\n    |\n LL | //! [reference::deref]\n    |      ^^^^^^^^^^^^^^^^ the builtin type `reference` has no associated item named `deref`\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "7cc62b38cc26080174a39ef01c3ff1b64176dfce", "filename": "src/test/rustdoc-ui/private-public-item-doc-test.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-ui%2Fprivate-public-item-doc-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-ui%2Fprivate-public-item-doc-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fprivate-public-item-doc-test.rs?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -0,0 +1,11 @@\n+#![deny(rustdoc::private_doc_tests)]\n+\n+mod foo {\n+    /// private doc test\n+    ///\n+    /// ```\n+    /// assert!(false);\n+    /// ```\n+    //~^^^^^ ERROR documentation test in private item\n+    pub fn bar() {}\n+}"}, {"sha": "f50dbd1844e7afc0972a8a764c2921e241504d5f", "filename": "src/test/rustdoc-ui/private-public-item-doc-test.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-ui%2Fprivate-public-item-doc-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-ui%2Fprivate-public-item-doc-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fprivate-public-item-doc-test.stderr?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -0,0 +1,18 @@\n+error: documentation test in private item\n+  --> $DIR/private-public-item-doc-test.rs:4:5\n+   |\n+LL | /     /// private doc test\n+LL | |     ///\n+LL | |     /// ```\n+LL | |     /// assert!(false);\n+LL | |     /// ```\n+   | |___________^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/private-public-item-doc-test.rs:1:9\n+   |\n+LL | #![deny(rustdoc::private_doc_tests)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "b86a53305a175fb66c83a60288dc50396e35abd7", "filename": "src/test/rustdoc-ui/public-reexported-item-doc-test.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-ui%2Fpublic-reexported-item-doc-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc-ui%2Fpublic-reexported-item-doc-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fpublic-reexported-item-doc-test.rs?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+#![deny(rustdoc::private_doc_tests)]\n+\n+pub fn foo() {}\n+\n+mod private {\n+    /// re-exported doc test\n+    ///\n+    /// ```\n+    /// assert!(true);\n+    /// ```\n+    pub fn bar() {}\n+}\n+\n+pub use private::bar;"}, {"sha": "8639a24f7f3864e46410b2b185a38d8382fda71e", "filename": "src/test/rustdoc/intra-doc/prim-associated-traits.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-associated-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-associated-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-associated-traits.rs?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -0,0 +1,46 @@\n+#![feature(never_type)]\n+use std::str::FromStr;\n+\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.f64.html#method.from_str\"]' 'f64::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.f32.html#method.from_str\"]' 'f32::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.isize.html#method.from_str\"]' 'isize::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.i8.html#method.from_str\"]' 'i8::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.i16.html#method.from_str\"]' 'i16::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.i32.html#method.from_str\"]' 'i32::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.i64.html#method.from_str\"]' 'i64::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.i128.html#method.from_str\"]' 'i128::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.usize.html#method.from_str\"]' 'usize::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.u8.html#method.from_str\"]' 'u8::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.u16.html#method.from_str\"]' 'u16::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.u32.html#method.from_str\"]' 'u32::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.u64.html#method.from_str\"]' 'u64::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.u128.html#method.from_str\"]' 'u128::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.char.html#method.from_str\"]' 'char::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.bool.html#method.from_str\"]' 'bool::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.str.html#method.eq\"]' 'str::eq()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.never.html#method.eq\"]' 'never::eq()'\n+/// [`f64::from_str()`] [`f32::from_str()`] [`isize::from_str()`] [`i8::from_str()`]\n+/// [`i16::from_str()`] [`i32::from_str()`] [`i64::from_str()`] [`i128::from_str()`]\n+/// [`u16::from_str()`] [`u32::from_str()`] [`u64::from_str()`] [`u128::from_str()`]\n+/// [`usize::from_str()`] [`u8::from_str()`] [`char::from_str()`] [`bool::from_str()`]\n+/// [`str::eq()`] [`never::eq()`]\n+pub struct Number {\n+    pub f_64: f64,\n+    pub f_32: f32,\n+    pub i_size: isize,\n+    pub i_8: i8,\n+    pub i_16: i16,\n+    pub i_32: i32,\n+    pub i_64: i64,\n+    pub i_128: i128,\n+    pub u_size: usize,\n+    pub u_8: u8,\n+    pub u_16: u16,\n+    pub u_32: u32,\n+    pub u_64: u64,\n+    pub u_128: u128,\n+    pub ch: char,\n+    pub boolean: bool,\n+    pub string: str,\n+    pub n: !,\n+}"}, {"sha": "16d651717ff2c0f935a7e550e6f7f3cc556e7c51", "filename": "src/test/ui/borrowck/issue-92015.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Fui%2Fborrowck%2Fissue-92015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Fui%2Fborrowck%2Fissue-92015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-92015.rs?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -0,0 +1,7 @@\n+// Regression test for #92105.\n+// ICE when mutating immutable reference from last statement of a block.\n+\n+fn main() {\n+    let foo = Some(&0).unwrap();\n+    *foo = 1; //~ ERROR cannot assign\n+}"}, {"sha": "32a65d3b5bb0f472b341a95cfeb90c9a064abd66", "filename": "src/test/ui/borrowck/issue-92015.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Fui%2Fborrowck%2Fissue-92015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Fui%2Fborrowck%2Fissue-92015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-92015.stderr?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -0,0 +1,11 @@\n+error[E0594]: cannot assign to `*foo`, which is behind a `&` reference\n+  --> $DIR/issue-92015.rs:6:5\n+   |\n+LL |     let foo = Some(&0).unwrap();\n+   |         --- help: consider changing this to be a mutable reference: `&mut i32`\n+LL |     *foo = 1;\n+   |     ^^^^^^^^ `foo` is a `&` reference, so the data it refers to cannot be written\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0594`."}, {"sha": "f60f6f3e808725d447f21d0c551d3cda1f1376c3", "filename": "src/test/ui/c-variadic/variadic-unreachable-arg-error.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-unreachable-arg-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa4ac66c194046f631ce076c75516ecfdeb77ee/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-unreachable-arg-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-unreachable-arg-error.rs?ref=cfa4ac66c194046f631ce076c75516ecfdeb77ee", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+#![feature(c_variadic)]\n+\n+extern \"C\" {\n+    fn foo(f: isize, x: u8, ...);\n+}\n+\n+fn main() {\n+    unsafe {\n+        // FIXME: Ideally we could give an unreachable warning\n+        foo(1, loop {}, 1usize);\n+    }\n+}"}]}