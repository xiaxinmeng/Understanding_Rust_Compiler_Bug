{"sha": "8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmOGViYjU1MGNmN2U2NDFkN2RlZGQ1NmUwOGVmZDRmMGUxNWFmYWI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-17T15:42:17Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-18T11:49:01Z"}, "message": "Implement a last-use-of-local finding algorithm\n\nIssue #925", "tree": {"sha": "fce19d94b7df2f56541a51898ca6d0c2048ddef5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fce19d94b7df2f56541a51898ca6d0c2048ddef5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "html_url": "https://github.com/rust-lang/rust/commit/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c97fcbf6689d8d4f466cdea80369ae057a4523e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c97fcbf6689d8d4f466cdea80369ae057a4523e", "html_url": "https://github.com/rust-lang/rust/commit/0c97fcbf6689d8d4f466cdea80369ae057a4523e"}], "stats": {"total": 256, "additions": 250, "deletions": 6}, "files": [{"sha": "518a62517022a4f09324b9fffd56bec304705daa", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -5,7 +5,8 @@ import metadata::{creader, cstore};\n import syntax::parse::{parser};\n import syntax::{ast, codemap};\n import front::attr;\n-import middle::{trans, resolve, freevars, kind, ty, typeck, fn_usage};\n+import middle::{trans, resolve, freevars, kind, ty, typeck, fn_usage,\n+                last_use};\n import syntax::print::{pp, pprust};\n import util::{ppaux, filesearch};\n import back::link;\n@@ -138,6 +139,8 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n              bind freevars::annotate_freevars(def_map, crate));\n     let ty_cx = ty::mk_ctxt(sess, def_map, ext_map, ast_map, freevars);\n     time(time_passes, \"typechecking\", bind typeck::check_crate(ty_cx, crate));\n+    let last_uses = time(time_passes, \"last use finding\",\n+        bind last_use::find_last_uses(crate, def_map, ty_cx));\n     time(time_passes, \"function usage\",\n          bind fn_usage::check_crate_fn_usage(ty_cx, crate));\n     time(time_passes, \"alt checking\",\n@@ -150,7 +153,8 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n     let copy_map =\n         time(time_passes, \"alias checking\",\n              bind middle::alias::check_crate(ty_cx, crate));\n-    time(time_passes, \"kind checking\", bind kind::check_crate(ty_cx, crate));\n+    time(time_passes, \"kind checking\",\n+         bind kind::check_crate(ty_cx, last_uses, crate));\n     time(time_passes, \"const checking\",\n          bind middle::check_const::check_crate(ty_cx, crate));\n     if sess.get_opts().no_trans { ret; }"}, {"sha": "3618a17ff2cc134cf3d121caa0771181db2aef8d", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -15,11 +15,14 @@ type rval_map = std::map::hashmap<node_id, ()>;\n \n type ctx = {tcx: ty::ctxt,\n             rval_map: rval_map,\n+            last_uses: last_use::last_uses,\n             mutable ret_by_ref: bool};\n \n-fn check_crate(tcx: ty::ctxt, crate: @crate) -> rval_map {\n+fn check_crate(tcx: ty::ctxt, last_uses: last_use::last_uses,\n+               crate: @crate) -> rval_map {\n     let ctx = {tcx: tcx,\n                rval_map: std::map::new_int_hash(),\n+               last_uses: last_uses,\n                mutable ret_by_ref: false};\n     let visit = visit::mk_vt(@{\n         visit_expr: check_expr,\n@@ -118,7 +121,7 @@ fn maybe_copy(cx: ctx, ex: @expr) {\n }\n \n fn check_copy_ex(cx: ctx, ex: @expr, _warn: bool) {\n-    if ty::expr_is_lval(cx.tcx, ex) {\n+    if ty::expr_is_lval(cx.tcx, ex) && !cx.last_uses.contains_key(ex.id) {\n         let ty = ty::expr_ty(cx.tcx, ex);\n         check_copy(cx, ty, ex.span);\n         // FIXME turn this on again once vector types are no longer unique."}, {"sha": "5d8aa2493d2afba882abc3acd6c63945a7f25202", "filename": "src/comp/middle/last_use.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -0,0 +1,219 @@\n+import syntax::{visit, ast_util};\n+import syntax::ast::*;\n+import std::list::{list, nil, cons, tail};\n+import std::{vec, list, option};\n+\n+// Marks expr_paths that are last uses.\n+type last_uses = std::map::hashmap<node_id, ()>;\n+\n+tag seen { unset; seen(node_id); }\n+tag block_type { func; loop; }\n+\n+type set = [{def: node_id, exprs: list<node_id>}];\n+type bl = @{type: block_type, mutable second: bool, mutable exits: [set]};\n+\n+type ctx = {last_uses: std::map::hashmap<node_id, bool>,\n+            def_map: resolve::def_map,\n+            tcx: ty::ctxt,\n+            // The current set of local last uses\n+            mutable current: set,\n+            mutable blocks: list<bl>};\n+\n+fn find_last_uses(c: @crate, def_map: resolve::def_map, tcx: ty::ctxt)\n+    -> last_uses {\n+    let v = visit::mk_vt(@{visit_expr: visit_expr,\n+                           visit_fn: visit_fn\n+                           with *visit::default_visitor()});\n+    let cx = {last_uses: std::map::new_int_hash(),\n+              def_map: def_map,\n+              tcx: tcx,\n+              mutable current: [],\n+              mutable blocks: nil};\n+    visit::visit_crate(*c, cx, v);\n+    let mini_table = std::map::new_int_hash();\n+    cx.last_uses.items {|key, val| if val { mini_table.insert(key, ()); }}\n+    ret mini_table;\n+}\n+\n+fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n+    alt ex.node {\n+      expr_ret(oexpr) {\n+        visit::visit_expr_opt(oexpr, cx, v);\n+        if !add_block_exit(cx, func) { leave_fn(cx); }\n+      }\n+      expr_fail(oexpr) {\n+        visit::visit_expr_opt(oexpr, cx, v);\n+        leave_fn(cx);\n+      }\n+      expr_break. { add_block_exit(cx, loop); }\n+      expr_while(_, _) | expr_do_while(_, _) {\n+        visit_block(loop, cx) {|| visit::visit_expr(ex, cx, v);}\n+      }\n+      expr_for(_, coll, blk) {\n+        v.visit_expr(coll, cx, v);\n+        visit_block(loop, cx) {|| visit::visit_block(blk, cx, v);}\n+      }\n+      expr_ternary(_, _, _) {\n+        v.visit_expr(ast_util::ternary_to_if(ex), cx, v);\n+      }\n+      expr_alt(input, arms) {\n+        v.visit_expr(input, cx, v);\n+        let before = cx.current, sets = [];\n+        for arm in arms {\n+            cx.current = before;\n+            v.visit_arm(arm, cx, v);\n+            sets += [cx.current];\n+        }\n+        cx.current = join_branches(sets);\n+      }\n+      expr_if(cond, then, els) {\n+        v.visit_expr(cond, cx, v);\n+        let cur = cx.current;\n+        visit::visit_block(then, cx, v);\n+        cx.current <-> cur;\n+        visit::visit_expr_opt(els, cx, v);\n+        cx.current = join_branches([cur, cx.current]);\n+      }\n+      expr_path(_) {\n+        alt clear_if_path(cx, ex, v, false) {\n+          option::some(my_def) {\n+            cx.current += [{def: my_def, exprs: cons(ex.id, @nil)}];\n+          }\n+          _ {}\n+        }\n+      }\n+      expr_swap(lhs, rhs) {\n+        clear_if_path(cx, lhs, v, false);\n+        clear_if_path(cx, rhs, v, false);\n+      }\n+      expr_move(dest, src) | expr_assign(dest, src) {\n+        v.visit_expr(src, cx, v);\n+        clear_if_path(cx, dest, v, true);\n+      }\n+      expr_assign_op(_, dest, src) {\n+        v.visit_expr(src, cx, v);\n+        v.visit_expr(dest, cx, v);\n+        clear_if_path(cx, dest, v, true);\n+      }\n+      expr_call(f, args, _) {\n+        v.visit_expr(f, cx, v);\n+        let i = 0u;\n+        for arg_t in ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f)) {\n+            alt arg_t.mode {\n+              by_mut_ref. { clear_if_path(cx, args[i], v, false); }\n+              _ { v.visit_expr(args[i], cx, v); }\n+            }\n+            i += 1u;\n+        }\n+      }\n+      _ { visit::visit_expr(ex, cx, v); }\n+    }\n+}\n+\n+fn visit_fn(f: _fn, tps: [ty_param], sp: syntax::codemap::span,\n+            ident: fn_ident, id: node_id, cx: ctx, v: visit::vt<ctx>) {\n+    if f.proto == proto_block {\n+        visit_block(func, cx, {||\n+            visit::visit_fn(f, tps, sp, ident, id, cx, v);\n+        });\n+    } else {\n+        let old = nil;\n+        cx.blocks <-> old;\n+        visit::visit_fn(f, tps, sp, ident, id, cx, v);\n+        cx.blocks <-> old;\n+        leave_fn(cx);\n+    }\n+}\n+\n+fn visit_block(tp: block_type, cx: ctx, visit: block()) {\n+    let local = @{type: tp, mutable second: false, mutable exits: []};\n+    cx.blocks = cons(local, @cx.blocks);\n+    visit();\n+    local.second = true;\n+    visit();\n+    cx.blocks = tail(cx.blocks);\n+    cx.current = join_branches(local.exits);\n+}\n+\n+fn add_block_exit(cx: ctx, tp: block_type) -> bool {\n+    let cur = cx.blocks;\n+    while cur != nil {\n+        alt cur {\n+          cons(b, tail) {\n+            if (b.type == tp) {\n+                if !b.second { b.exits += [cx.current]; }\n+                ret true;\n+            }\n+            cur = *tail;\n+          }\n+        }\n+    }\n+    ret false;\n+}\n+\n+fn join_branches(branches: [set]) -> set {\n+    let found: set = [], i = 0u, l = vec::len(branches);\n+    for set in branches {\n+        i += 1u;\n+        for {def, exprs} in set {\n+            if !vec::any({|v| v.def == def}, found) {\n+                let j = i, ne = exprs;\n+                while j < l {\n+                    for {def: d2, exprs} in branches[j] {\n+                        if d2 == def {\n+                            list::iter(exprs) {|e|\n+                                if !list::has(ne, e) { ne = cons(e, @ne); }\n+                            }\n+                        }\n+                    }\n+                    j += 1u;\n+                }\n+                found += [{def: def, exprs: ne}];\n+            }\n+        }\n+    }\n+    ret found;\n+}\n+\n+fn leave_fn(cx: ctx) {\n+    for {def, exprs} in cx.current {\n+        list::iter(exprs) {|ex_id|\n+            if !cx.last_uses.contains_key(ex_id) {\n+                cx.last_uses.insert(ex_id, true);\n+            }\n+        }\n+    }\n+}\n+\n+fn clear_in_current(cx: ctx, my_def: node_id, to: bool) {\n+    for {def, exprs} in cx.current {\n+        if def == my_def {\n+            list::iter(exprs) {|expr|\n+                if !to || !cx.last_uses.contains_key(expr) {\n+                     cx.last_uses.insert(expr, to);\n+                }\n+            }\n+            cx.current = vec::filter({|x| x.def != my_def},\n+                                     copy cx.current);\n+            break;\n+        }\n+    }\n+}\n+\n+fn clear_if_path(cx: ctx, ex: @expr, v: visit::vt<ctx>, to: bool)\n+    -> option::t<node_id> {\n+    alt ex.node {\n+      expr_path(_) {\n+        alt cx.def_map.get(ex.id) {\n+          def_local(def_id, let_copy.) | def_arg(def_id, by_copy.) |\n+          def_arg(def_id, by_move.) {\n+            clear_in_current(cx, def_id.node, to);\n+            ret option::some(def_id.node);\n+          }\n+          _ {}\n+        }\n+      }\n+      _ { v.visit_expr(ex, cx, v); }\n+    }\n+    ret option::none;\n+}"}, {"sha": "af6369b5bceddb75e9ede0d21275a80133a74b31", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -30,6 +30,7 @@ mod middle {\n     mod check_const;\n     mod mut;\n     mod alias;\n+    mod last_use;\n     mod kind;\n     mod freevars;\n     mod shape;"}, {"sha": "300a5c72a67339bb9576739a926238686b6b5b9f", "filename": "src/lib/list.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -134,6 +134,23 @@ fn append<T>(l: list<T>, m: list<T>) -> list<T> {\n     }\n }\n \n+/*\n+Function: iter\n+\n+Iterate over a list\n+*/\n+fn iter<copy T>(l: list<T>, f: block(T)) {\n+    let cur = l;\n+    while cur != nil {\n+        alt cur {\n+          cons(hd, tl) {\n+            f(hd);\n+            cur = *tl;\n+          }\n+        }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "2ae7f2247b12dfd95d1adf61c799c83c9f708259", "filename": "src/lib/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -703,8 +703,8 @@ Iterates over vector `v` and, for each element, calls function `f` with the\n element's value and index.\n */\n fn iter2<T>(v: [const T], f: block(uint, T)) {\n-    let i = 0u;\n-    for x in v { f(i, x); i += 1u; }\n+    let i = 0u, l = len(v);\n+    while i < l { f(i, v[i]); i += 1u; }\n }\n \n /*"}]}