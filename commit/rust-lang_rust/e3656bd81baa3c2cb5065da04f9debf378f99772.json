{"sha": "e3656bd81baa3c2cb5065da04f9debf378f99772", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNjU2YmQ4MWJhYTNjMmNiNTA2NWRhMDRmOWRlYmYzNzhmOTk3NzI=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-03-07T05:16:44Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-03-10T06:24:34Z"}, "message": "Implement RFC 640", "tree": {"sha": "d10b07092f56e83dd42e97c1f97fd924fc05b6bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d10b07092f56e83dd42e97c1f97fd924fc05b6bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3656bd81baa3c2cb5065da04f9debf378f99772", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3656bd81baa3c2cb5065da04f9debf378f99772", "html_url": "https://github.com/rust-lang/rust/commit/e3656bd81baa3c2cb5065da04f9debf378f99772", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3656bd81baa3c2cb5065da04f9debf378f99772/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12b846ab80ca054d2fbfb0320d33badbd5ef0112", "url": "https://api.github.com/repos/rust-lang/rust/commits/12b846ab80ca054d2fbfb0320d33badbd5ef0112", "html_url": "https://github.com/rust-lang/rust/commit/12b846ab80ca054d2fbfb0320d33badbd5ef0112"}], "stats": {"total": 802, "additions": 801, "deletions": 1}, "files": [{"sha": "e7b4cd1122cd0e0c04f8bb6c5923c68b3157ff7e", "filename": "src/libcore/fmt/builders.rs", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/e3656bd81baa3c2cb5065da04f9debf378f99772/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3656bd81baa3c2cb5065da04f9debf378f99772/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=e3656bd81baa3c2cb5065da04f9debf378f99772", "patch": "@@ -0,0 +1,292 @@\n+use prelude::*;\n+use fmt::{self, Write, FlagV1};\n+\n+struct PadAdapter<'a, 'b: 'a> {\n+    fmt: &'a mut fmt::Formatter<'b>,\n+    on_newline: bool,\n+}\n+\n+impl<'a, 'b: 'a> PadAdapter<'a, 'b> {\n+    fn new(fmt: &'a mut fmt::Formatter<'b>) -> PadAdapter<'a, 'b> {\n+        PadAdapter {\n+            fmt: fmt,\n+            on_newline: false,\n+        }\n+    }\n+}\n+\n+impl<'a, 'b: 'a> fmt::Write for PadAdapter<'a, 'b> {\n+    fn write_str(&mut self, mut s: &str) -> fmt::Result {\n+        while !s.is_empty() {\n+            if self.on_newline {\n+                try!(self.fmt.write_str(\"    \"));\n+            }\n+\n+            let split = match s.find('\\n') {\n+                Some(pos) => {\n+                    self.on_newline = true;\n+                    pos + 1\n+                }\n+                None => {\n+                    self.on_newline = false;\n+                    s.len()\n+                }\n+            };\n+            try!(self.fmt.write_str(&s[..split]));\n+            s = &s[split..];\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+/// A struct to help with `fmt::Debug` implementations.\n+///\n+/// Constructed by the `Formatter::debug_struct` method.\n+#[must_use]\n+pub struct DebugStruct<'a, 'b: 'a> {\n+    fmt: &'a mut fmt::Formatter<'b>,\n+    result: fmt::Result,\n+    has_fields: bool,\n+}\n+\n+pub fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str)\n+                                -> DebugStruct<'a, 'b> {\n+    let result = fmt.write_str(name);\n+    DebugStruct {\n+        fmt: fmt,\n+        result: result,\n+        has_fields: false,\n+    }\n+}\n+\n+impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n+    /// Adds a new field to the generated struct output.\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    pub fn field<S>(mut self, name: &str, value: &S) -> DebugStruct<'a, 'b>\n+            where S: fmt::Debug {\n+        self.result = self.result.and_then(|_| {\n+            let prefix = if self.has_fields {\n+                \",\"\n+            } else {\n+                \" {\"\n+            };\n+\n+            if self.is_pretty() {\n+                let mut writer = PadAdapter::new(self.fmt);\n+                fmt::write(&mut writer, format_args!(\"{}\\n{}: {:#?}\", prefix, name, value))\n+            } else {\n+                write!(self.fmt, \"{} {}: {:?}\", prefix, name, value)\n+            }\n+        });\n+\n+        self.has_fields = true;\n+        self\n+    }\n+\n+    /// Consumes the `DebugStruct`, finishing output and returning any error\n+    /// encountered.\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    pub fn finish(mut self) -> fmt::Result {\n+        if self.has_fields {\n+            self.result = self.result.and_then(|_| {\n+                if self.is_pretty() {\n+                    self.fmt.write_str(\"\\n}\")\n+                } else {\n+                    self.fmt.write_str(\" }\")\n+                }\n+            });\n+        }\n+        self.result\n+    }\n+\n+    fn is_pretty(&self) -> bool {\n+        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+    }\n+}\n+\n+/// A struct to help with `fmt::Debug` implementations.\n+///\n+/// Constructed by the `Formatter::debug_tuple` method.\n+#[must_use]\n+pub struct DebugTuple<'a, 'b: 'a> {\n+    fmt: &'a mut fmt::Formatter<'b>,\n+    result: fmt::Result,\n+    has_fields: bool,\n+}\n+\n+pub fn debug_tuple_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugTuple<'a, 'b> {\n+    let result = fmt.write_str(name);\n+    DebugTuple {\n+        fmt: fmt,\n+        result: result,\n+        has_fields: false,\n+    }\n+}\n+\n+impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n+    /// Adds a new field to the generated tuple struct output.\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    pub fn field<S>(mut self, value: &S) -> DebugTuple<'a, 'b> where S: fmt::Debug {\n+        self.result = self.result.and_then(|_| {\n+            let (prefix, space) = if self.has_fields {\n+                (\",\", \" \")\n+            } else {\n+                (\"(\", \"\")\n+            };\n+\n+            if self.is_pretty() {\n+                let mut writer = PadAdapter::new(self.fmt);\n+                fmt::write(&mut writer, format_args!(\"{}\\n{:#?}\", prefix, value))\n+            } else {\n+                write!(self.fmt, \"{}{}{:?}\", prefix, space, value)\n+            }\n+        });\n+\n+        self.has_fields = true;\n+        self\n+    }\n+\n+    /// Consumes the `DebugTuple`, finishing output and returning any error\n+    /// encountered.\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    pub fn finish(mut self) -> fmt::Result {\n+        if self.has_fields {\n+            self.result = self.result.and_then(|_| {\n+                if self.is_pretty() {\n+                    self.fmt.write_str(\"\\n)\")\n+                } else {\n+                    self.fmt.write_str(\")\")\n+                }\n+            });\n+        }\n+        self.result\n+    }\n+\n+    fn is_pretty(&self) -> bool {\n+        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+    }\n+}\n+\n+/// A struct to help with `fmt::Debug` implementations.\n+///\n+/// Constructed by the `Formatter::debug_set` method.\n+#[must_use]\n+pub struct DebugSet<'a, 'b: 'a> {\n+    fmt: &'a mut fmt::Formatter<'b>,\n+    result: fmt::Result,\n+    has_fields: bool,\n+}\n+\n+pub fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugSet<'a, 'b> {\n+    let result = write!(fmt, \"{} {{\", name);\n+    DebugSet {\n+        fmt: fmt,\n+        result: result,\n+        has_fields: false,\n+    }\n+}\n+\n+impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n+    /// Adds a new entry to the set output.\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    pub fn entry<S>(mut self, entry: &S) -> DebugSet<'a, 'b> where S: fmt::Debug {\n+        self.result = self.result.and_then(|_| {\n+            let prefix = if self.has_fields {\n+                \",\"\n+            } else {\n+                \"\"\n+            };\n+\n+            if self.is_pretty() {\n+                let mut writer = PadAdapter::new(self.fmt);\n+                fmt::write(&mut writer, format_args!(\"{}\\n{:#?}\", prefix, entry))\n+            } else {\n+                write!(self.fmt, \"{} {:?}\", prefix, entry)\n+            }\n+        });\n+\n+        self.has_fields = true;\n+        self\n+    }\n+\n+    /// Consumes the `DebugSet`, finishing output and returning any error\n+    /// encountered.\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    pub fn finish(self) -> fmt::Result {\n+        self.result.and_then(|_| {\n+            let end = match (self.has_fields, self.is_pretty()) {\n+                (false, _) => \"}\",\n+                (true, false) => \" }\",\n+                (true, true) => \"\\n}\",\n+            };\n+            self.fmt.write_str(end)\n+        })\n+    }\n+\n+    fn is_pretty(&self) -> bool {\n+        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+    }\n+}\n+\n+/// A struct to help with `fmt::Debug` implementations.\n+///\n+/// Constructed by the `Formatter::debug_map` method.\n+#[must_use]\n+pub struct DebugMap<'a, 'b: 'a> {\n+    fmt: &'a mut fmt::Formatter<'b>,\n+    result: fmt::Result,\n+    has_fields: bool,\n+}\n+\n+pub fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugMap<'a, 'b> {\n+    let result = write!(fmt, \"{} {{\", name);\n+    DebugMap {\n+        fmt: fmt,\n+        result: result,\n+        has_fields: false,\n+    }\n+}\n+\n+impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n+    /// Adds a new entry to the map output.\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    pub fn entry<K, V>(mut self, key: &K, value: &V) -> DebugMap<'a, 'b>\n+            where K: fmt::Debug, V: fmt::Debug {\n+        self.result = self.result.and_then(|_| {\n+            let prefix = if self.has_fields {\n+                \",\"\n+            } else {\n+                \"\"\n+            };\n+\n+            if self.is_pretty() {\n+                let mut writer = PadAdapter::new(self.fmt);\n+                fmt::write(&mut writer, format_args!(\"{}\\n{:#?}: {:#?}\", prefix, key, value))\n+            } else {\n+                write!(self.fmt, \"{} {:?}: {:?}\", prefix, key, value)\n+            }\n+        });\n+\n+        self.has_fields = true;\n+        self\n+    }\n+\n+    /// Consumes the `DebugMap`, finishing output and returning any error\n+    /// encountered.\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    pub fn finish(self) -> fmt::Result {\n+        self.result.and_then(|_| {\n+            let end = match (self.has_fields, self.is_pretty()) {\n+                (false, _) => \"}\",\n+                (true, false) => \" }\",\n+                (true, true) => \"\\n}\",\n+            };\n+            self.fmt.write_str(end)\n+        })\n+    }\n+\n+    fn is_pretty(&self) -> bool {\n+        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+    }\n+}"}, {"sha": "572d613f192adaad4ffedb5d7aca694cd028057f", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 117, "deletions": 1, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/e3656bd81baa3c2cb5065da04f9debf378f99772/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3656bd81baa3c2cb5065da04f9debf378f99772/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=e3656bd81baa3c2cb5065da04f9debf378f99772", "patch": "@@ -32,8 +32,11 @@ pub use self::num::radix;\n pub use self::num::Radix;\n pub use self::num::RadixFmt;\n \n+pub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugMap};\n+\n mod num;\n mod float;\n+mod builders;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(hidden)]\n@@ -425,7 +428,7 @@ impl<'a> Formatter<'a> {\n     /// # Arguments\n     ///\n     /// * is_positive - whether the original integer was positive or not.\n-    /// * prefix - if the '#' character (FlagAlternate) is provided, this\n+    /// * prefix - if the '#' character (Alternate) is provided, this\n     ///   is the prefix to put in front of the number.\n     /// * buf - the byte array that the number has been formatted into\n     ///\n@@ -614,6 +617,119 @@ impl<'a> Formatter<'a> {\n     /// Optionally specified precision for numeric types\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn precision(&self) -> Option<usize> { self.precision }\n+\n+    /// Creates a `DebugStruct` builder designed to assist with creation of\n+    /// `fmt::Debug` implementations for structs.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo {\n+    ///     bar: i32,\n+    ///     baz: String,\n+    /// }\n+    ///\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///         fmt.debug_struct(\"Foo\")\n+    ///             .field(\"bar\", &self.bar)\n+    ///             .field(\"baz\", &self.baz)\n+    ///             .finish()\n+    ///     }\n+    /// }\n+    ///\n+    /// // prints \"Foo { bar: 10, baz: \"Hello World\" }\"\n+    /// println!(\"{:?}\", Foo { bar: 10, baz: \"Hello World\".to_string() });\n+    /// ```\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    pub fn debug_struct<'b>(&'b mut self, name: &str) -> DebugStruct<'b, 'a> {\n+        builders::debug_struct_new(self, name)\n+    }\n+\n+    /// Creates a `DebugTuple` builder designed to assist with creation of\n+    /// `fmt::Debug` implementations for tuple structs.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32, String);\n+    ///\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///         fmt.debug_tuple(\"Foo\")\n+    ///             .field(&self.0)\n+    ///             .field(&self.1)\n+    ///             .finish()\n+    ///     }\n+    /// }\n+    ///\n+    /// // prints \"Foo(10, \"Hello World\")\"\n+    /// println!(\"{:?}\", Foo(10, \"Hello World\".to_string()));\n+    /// ```\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, 'a> {\n+        builders::debug_tuple_new(self, name)\n+    }\n+\n+    /// Creates a `DebugSet` builder designed to assist with creation of\n+    /// `fmt::Debug` implementations for set-like structures.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(Vec<i32>);\n+    ///\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///         let mut builder = fmt.debug_set(\"Foo\");\n+    ///         for i in &self.0 {\n+    ///             builder = builder.entry(i);\n+    ///         }\n+    ///         builder.finish()\n+    ///     }\n+    /// }\n+    ///\n+    /// // prints \"Foo { 10, 11 }\"\n+    /// println!(\"{:?}\", Foo(vec![10, 11]));\n+    /// ```\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    pub fn debug_set<'b>(&'b mut self, name: &str) -> DebugSet<'b, 'a> {\n+        builders::debug_set_new(self, name)\n+    }\n+\n+    /// Creates a `DebugMap` builder designed to assist with creation of\n+    /// `fmt::Debug` implementations for map-like structures.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(Vec<(String, i32)>);\n+    ///\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///         let mut builder = fmt.debug_map(\"Foo\");\n+    ///         for &(ref key, ref value) in &self.0 {\n+    ///             builder = builder.entry(key, value);\n+    ///         }\n+    ///         builder.finish()\n+    ///     }\n+    /// }\n+    ///\n+    /// // prints \"Foo { \"A\": 10, \"B\": 11 }\"\n+    /// println!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)));\n+    /// ```\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    pub fn debug_map<'b>(&'b mut self, name: &str) -> DebugMap<'b, 'a> {\n+        builders::debug_map_new(self, name)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "84076b349d2f75344c6c2f9b73edc279dfd5108d", "filename": "src/libcoretest/fmt/builders.rs", "status": "added", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/e3656bd81baa3c2cb5065da04f9debf378f99772/src%2Flibcoretest%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3656bd81baa3c2cb5065da04f9debf378f99772/src%2Flibcoretest%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fbuilders.rs?ref=e3656bd81baa3c2cb5065da04f9debf378f99772", "patch": "@@ -0,0 +1,391 @@\n+mod debug_struct {\n+    use std::fmt;\n+\n+    #[test]\n+    fn test_empty() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_struct(\"Foo\").finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo\", format!(\"{:?}\", Foo));\n+        assert_eq!(\"Foo\", format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_single() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_struct(\"Foo\")\n+                    .field(\"bar\", &true)\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { bar: true }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo {\n+    bar: true\n+}\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_multiple() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_struct(\"Foo\")\n+                    .field(\"bar\", &true)\n+                    .field(\"baz\", &format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { bar: true, baz: 10/20 }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo {\n+    bar: true,\n+    baz: 10/20\n+}\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_nested() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_struct(\"Foo\")\n+                    .field(\"bar\", &true)\n+                    .field(\"baz\", &format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        struct Bar;\n+\n+        impl fmt::Debug for Bar {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_struct(\"Bar\")\n+                    .field(\"foo\", &Foo)\n+                    .field(\"hello\", &\"world\")\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Bar { foo: Foo { bar: true, baz: 10/20 }, hello: \\\"world\\\" }\",\n+                   format!(\"{:?}\", Bar));\n+        assert_eq!(\n+\"Bar {\n+    foo: Foo {\n+        bar: true,\n+        baz: 10/20\n+    },\n+    hello: \\\"world\\\"\n+}\",\n+                   format!(\"{:#?}\", Bar));\n+    }\n+}\n+\n+mod debug_tuple {\n+    use std::fmt;\n+\n+    #[test]\n+    fn test_empty() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_tuple(\"Foo\").finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo\", format!(\"{:?}\", Foo));\n+        assert_eq!(\"Foo\", format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_single() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_tuple(\"Foo\")\n+                    .field(&true)\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo(true)\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo(\n+    true\n+)\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_multiple() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_tuple(\"Foo\")\n+                    .field(&true)\n+                    .field(&format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo(true, 10/20)\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo(\n+    true,\n+    10/20\n+)\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_nested() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_tuple(\"Foo\")\n+                    .field(&true)\n+                    .field(&format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        struct Bar;\n+\n+        impl fmt::Debug for Bar {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_tuple(\"Bar\")\n+                    .field(&Foo)\n+                    .field(&\"world\")\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Bar(Foo(true, 10/20), \\\"world\\\")\",\n+                   format!(\"{:?}\", Bar));\n+        assert_eq!(\n+\"Bar(\n+    Foo(\n+        true,\n+        10/20\n+    ),\n+    \\\"world\\\"\n+)\",\n+                   format!(\"{:#?}\", Bar));\n+    }\n+}\n+\n+mod debug_map {\n+    use std::fmt;\n+\n+    #[test]\n+    fn test_empty() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_map(\"Foo\").finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo {}\", format!(\"{:?}\", Foo));\n+        assert_eq!(\"Foo {}\", format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_single() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_map(\"Foo\")\n+                    .entry(&\"bar\", &true)\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { \\\"bar\\\": true }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo {\n+    \\\"bar\\\": true\n+}\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_multiple() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_map(\"Foo\")\n+                    .entry(&\"bar\", &true)\n+                    .entry(&10i32, &format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { \\\"bar\\\": true, 10: 10/20 }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo {\n+    \\\"bar\\\": true,\n+    10: 10/20\n+}\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_nested() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_map(\"Foo\")\n+                    .entry(&\"bar\", &true)\n+                    .entry(&10i32, &format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        struct Bar;\n+\n+        impl fmt::Debug for Bar {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_map(\"Bar\")\n+                    .entry(&\"foo\", &Foo)\n+                    .entry(&Foo, &\"world\")\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Bar { \\\"foo\\\": Foo { \\\"bar\\\": true, 10: 10/20 }, \\\n+                    Foo { \\\"bar\\\": true, 10: 10/20 }: \\\"world\\\" }\",\n+                   format!(\"{:?}\", Bar));\n+        assert_eq!(\n+\"Bar {\n+    \\\"foo\\\": Foo {\n+        \\\"bar\\\": true,\n+        10: 10/20\n+    },\n+    Foo {\n+        \\\"bar\\\": true,\n+        10: 10/20\n+    }: \\\"world\\\"\n+}\",\n+                   format!(\"{:#?}\", Bar));\n+    }\n+}\n+\n+mod debug_set {\n+    use std::fmt;\n+\n+    #[test]\n+    fn test_empty() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_set(\"Foo\").finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo {}\", format!(\"{:?}\", Foo));\n+        assert_eq!(\"Foo {}\", format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_single() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_set(\"Foo\")\n+                    .entry(&true)\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { true }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo {\n+    true\n+}\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_multiple() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_set(\"Foo\")\n+                    .entry(&true)\n+                    .entry(&format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { true, 10/20 }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo {\n+    true,\n+    10/20\n+}\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_nested() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_set(\"Foo\")\n+                    .entry(&true)\n+                    .entry(&format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        struct Bar;\n+\n+        impl fmt::Debug for Bar {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_set(\"Bar\")\n+                    .entry(&Foo)\n+                    .entry(&\"world\")\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Bar { Foo { true, 10/20 }, \\\"world\\\" }\",\n+                   format!(\"{:?}\", Bar));\n+        assert_eq!(\n+\"Bar {\n+    Foo {\n+        true,\n+        10/20\n+    },\n+    \\\"world\\\"\n+}\",\n+                   format!(\"{:#?}\", Bar));\n+    }\n+}"}, {"sha": "cdb9c38f027f729d83c99f7c8d44e1170859c34c", "filename": "src/libcoretest/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e3656bd81baa3c2cb5065da04f9debf378f99772/src%2Flibcoretest%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3656bd81baa3c2cb5065da04f9debf378f99772/src%2Flibcoretest%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fmod.rs?ref=e3656bd81baa3c2cb5065da04f9debf378f99772", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n mod num;\n+mod builders;\n \n #[test]\n fn test_format_flags() {"}]}