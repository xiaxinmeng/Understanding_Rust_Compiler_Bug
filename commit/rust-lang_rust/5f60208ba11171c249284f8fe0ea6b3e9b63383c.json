{"sha": "5f60208ba11171c249284f8fe0ea6b3e9b63383c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNjAyMDhiYTExMTcxYzI0OTI4NGY4ZmUwZWE2YjNlOWI2MzM4M2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-29T05:22:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-29T05:22:51Z"}, "message": "Auto merge of #57957 - Centril:rollup, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #57045 (Kill remaining uses of mem::uninitialized in libcore, liballoc)\n - #57674 (Avoid erase_regions_ty queries if there are no regions to erase)\n - #57833 (Print a slightly clearer message when failing to launch a thread)\n - #57859 (Fix invalid background color)\n - #57904 (add typo suggestion to unknown attribute error)\n - #57915 (Pretty print `$crate` as `crate` or `crate_name` in more cases)\n - #57950 (Extend E0106, E0261)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "a6995e1eb1f22d67fe3ef79ef8e41fb9db6f4147", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6995e1eb1f22d67fe3ef79ef8e41fb9db6f4147"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f60208ba11171c249284f8fe0ea6b3e9b63383c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f60208ba11171c249284f8fe0ea6b3e9b63383c", "html_url": "https://github.com/rust-lang/rust/commit/5f60208ba11171c249284f8fe0ea6b3e9b63383c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f60208ba11171c249284f8fe0ea6b3e9b63383c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8a0dd7ae88023bd09fa4b86c9ca1f6ed8095b43", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8a0dd7ae88023bd09fa4b86c9ca1f6ed8095b43", "html_url": "https://github.com/rust-lang/rust/commit/d8a0dd7ae88023bd09fa4b86c9ca1f6ed8095b43"}, {"sha": "d77db2e99ebc54c73af60223466e9d95a36fe0f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d77db2e99ebc54c73af60223466e9d95a36fe0f1", "html_url": "https://github.com/rust-lang/rust/commit/d77db2e99ebc54c73af60223466e9d95a36fe0f1"}], "stats": {"total": 361, "additions": 269, "deletions": 92}, "files": [{"sha": "a6b09722e1c9497d2d70833dfdf3a2b4802108e4", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -330,19 +330,20 @@ def children_of_node(boxed_node, height, want_values):\n         leaf = node_ptr['data']\n     else:\n         leaf = node_ptr.dereference()\n-    keys = leaf['keys']['value']['value']\n+    keys = leaf['keys']\n     if want_values:\n-        values = leaf['vals']['value']['value']\n+        values = leaf['vals']\n     length = int(leaf['len'])\n     for i in xrange(0, length + 1):\n         if height > 0:\n-            for child in children_of_node(node_ptr['edges'][i], height - 1, want_values):\n+            child_ptr = node_ptr['edges'][i]['value']['value']\n+            for child in children_of_node(child_ptr, height - 1, want_values):\n                 yield child\n         if i < length:\n             if want_values:\n-                yield (keys[i], values[i])\n+                yield (keys[i]['value']['value'], values[i]['value']['value'])\n             else:\n-                yield keys[i]\n+                yield keys[i]['value']['value']\n \n class RustStdBTreeSetPrinter(object):\n     def __init__(self, val):"}, {"sha": "b47337e44b2fed5627fc4eb99bbd33a53002b737", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -380,7 +380,6 @@ impl<'a, B: ?Sized> Hash for Cow<'a, B>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n impl<'a, T: ?Sized + ToOwned> AsRef<T> for Cow<'a, T> {\n     fn as_ref(&self) -> &T {\n         self"}, {"sha": "e969e119dbe880c5abcd15512b3be9b4901af0e6", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -95,8 +95,8 @@ struct LeafNode<K, V> {\n \n     /// The arrays storing the actual data of the node. Only the first `len` elements of each\n     /// array are initialized and valid.\n-    keys: MaybeUninit<[K; CAPACITY]>,\n-    vals: MaybeUninit<[V; CAPACITY]>,\n+    keys: [MaybeUninit<K>; CAPACITY],\n+    vals: [MaybeUninit<V>; CAPACITY],\n }\n \n impl<K, V> LeafNode<K, V> {\n@@ -106,8 +106,8 @@ impl<K, V> LeafNode<K, V> {\n         LeafNode {\n             // As a general policy, we leave fields uninitialized if they can be, as this should\n             // be both slightly faster and easier to track in Valgrind.\n-            keys: MaybeUninit::uninitialized(),\n-            vals: MaybeUninit::uninitialized(),\n+            keys: uninitialized_array![_; CAPACITY],\n+            vals: uninitialized_array![_; CAPACITY],\n             parent: ptr::null(),\n             parent_idx: MaybeUninit::uninitialized(),\n             len: 0\n@@ -145,7 +145,7 @@ struct InternalNode<K, V> {\n \n     /// The pointers to the children of this node. `len + 1` of these are considered\n     /// initialized and valid.\n-    edges: [BoxedNode<K, V>; 2 * B],\n+    edges: [MaybeUninit<BoxedNode<K, V>>; 2 * B],\n }\n \n impl<K, V> InternalNode<K, V> {\n@@ -159,7 +159,7 @@ impl<K, V> InternalNode<K, V> {\n     unsafe fn new() -> Self {\n         InternalNode {\n             data: LeafNode::new(),\n-            edges: mem::uninitialized()\n+            edges: uninitialized_array![_; 2*B],\n         }\n     }\n }\n@@ -261,7 +261,7 @@ impl<K, V> Root<K, V> {\n             -> NodeRef<marker::Mut, K, V, marker::Internal> {\n         debug_assert!(!self.is_shared_root());\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n-        new_node.edges[0] = unsafe { BoxedNode::from_ptr(self.node.as_ptr()) };\n+        new_node.edges[0].set(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n \n         self.node = BoxedNode::from_internal(new_node);\n         self.height += 1;\n@@ -623,7 +623,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n         // We cannot be the root, so `as_leaf` is okay\n         unsafe {\n             slice::from_raw_parts(\n-                self.as_leaf().vals.as_ptr() as *const V,\n+                MaybeUninit::first_ptr(&self.as_leaf().vals),\n                 self.len()\n             )\n         }\n@@ -650,7 +650,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         } else {\n             unsafe {\n                 slice::from_raw_parts_mut(\n-                    (*self.as_leaf_mut()).keys.as_mut_ptr() as *mut K,\n+                    MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n                     self.len()\n                 )\n             }\n@@ -661,7 +661,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         debug_assert!(!self.is_shared_root());\n         unsafe {\n             slice::from_raw_parts_mut(\n-                (*self.as_leaf_mut()).vals.as_mut_ptr() as *mut V,\n+                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n                 self.len()\n             )\n         }\n@@ -718,7 +718,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         unsafe {\n             ptr::write(self.keys_mut().get_unchecked_mut(idx), key);\n             ptr::write(self.vals_mut().get_unchecked_mut(idx), val);\n-            ptr::write(self.as_internal_mut().edges.get_unchecked_mut(idx + 1), edge.node);\n+            self.as_internal_mut().edges.get_unchecked_mut(idx + 1).set(edge.node);\n \n             (*self.as_leaf_mut()).len += 1;\n \n@@ -749,7 +749,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n             slice_insert(self.vals_mut(), 0, val);\n             slice_insert(\n                 slice::from_raw_parts_mut(\n-                    self.as_internal_mut().edges.as_mut_ptr(),\n+                    MaybeUninit::first_ptr_mut(&mut self.as_internal_mut().edges),\n                     self.len()+1\n                 ),\n                 0,\n@@ -778,7 +778,9 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(internal) => {\n-                    let edge = ptr::read(internal.as_internal().edges.get_unchecked(idx + 1));\n+                    let edge = ptr::read(\n+                        internal.as_internal().edges.get_unchecked(idx + 1).as_ptr()\n+                    );\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n                     (*new_root.as_mut().as_leaf_mut()).parent = ptr::null();\n                     Some(new_root)\n@@ -806,7 +808,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                 ForceResult::Internal(mut internal) => {\n                     let edge = slice_remove(\n                         slice::from_raw_parts_mut(\n-                            internal.as_internal_mut().edges.as_mut_ptr(),\n+                            MaybeUninit::first_ptr_mut(&mut internal.as_internal_mut().edges),\n                             old_len+1\n                         ),\n                         0\n@@ -1085,7 +1087,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n             slice_insert(\n                 slice::from_raw_parts_mut(\n-                    self.node.as_internal_mut().edges.as_mut_ptr(),\n+                    MaybeUninit::first_ptr_mut(&mut self.node.as_internal_mut().edges),\n                     self.node.len()\n                 ),\n                 self.idx + 1,\n@@ -1140,7 +1142,9 @@ impl<BorrowType, K, V>\n     pub fn descend(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.node.height - 1,\n-            node: unsafe { self.node.as_internal().edges.get_unchecked(self.idx).as_ptr() },\n+            node: unsafe {\n+                self.node.as_internal().edges.get_unchecked(self.idx).get_ref().as_ptr()\n+            },\n             root: self.node.root,\n             _marker: PhantomData\n         }"}, {"sha": "d2ff1bae635616c050cb0a5b40e886abc94dbc19", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -63,8 +63,9 @@\n #![no_std]\n #![needs_allocator]\n \n-#![deny(intra_doc_link_resolution_failure)]\n-#![deny(missing_debug_implementations)]\n+#![warn(deprecated_in_future)]\n+#![warn(intra_doc_link_resolution_failure)]\n+#![warn(missing_debug_implementations)]\n \n #![cfg_attr(not(test), feature(fn_traits))]\n #![cfg_attr(not(test), feature(generator_trait))]"}, {"sha": "c0dc010fe59a5df1260f5dde025468a07f1e7bc6", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -1,5 +1,3 @@\n-#![allow(deprecated)]\n-\n //! Single-threaded reference-counting pointers. 'Rc' stands for 'Reference\n //! Counted'.\n //!"}, {"sha": "530b2f52c0df2c352f2ea007ee697b2cfb2d4843", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -2048,7 +2048,7 @@ macro_rules! tuple {\n     ( $($name:ident,)+ ) => (\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<$($name:Debug),*> Debug for ($($name,)*) where last_type!($($name,)+): ?Sized {\n-            #[allow(non_snake_case, unused_assignments, deprecated)]\n+            #[allow(non_snake_case, unused_assignments)]\n             fn fmt(&self, f: &mut Formatter) -> Result {\n                 let mut builder = f.debug_tuple(\"\");\n                 let ($(ref $name,)*) = *self;"}, {"sha": "3a812337bb111e855f6053cb8c0088ae89f5f528", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -1,14 +1,12 @@\n //! Integer and floating-point number formatting\n \n-#![allow(deprecated)]\n-\n \n use fmt;\n use ops::{Div, Rem, Sub};\n use str;\n use slice;\n use ptr;\n-use mem;\n+use mem::MaybeUninit;\n \n #[doc(hidden)]\n trait Int: PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n@@ -53,7 +51,7 @@ trait GenericRadix {\n         // characters for a base 2 number.\n         let zero = T::zero();\n         let is_nonnegative = x >= zero;\n-        let mut buf: [u8; 128] = unsafe { mem::uninitialized() };\n+        let mut buf = uninitialized_array![u8; 128];\n         let mut curr = buf.len();\n         let base = T::from_u8(Self::BASE);\n         if is_nonnegative {\n@@ -62,7 +60,7 @@ trait GenericRadix {\n             for byte in buf.iter_mut().rev() {\n                 let n = x % base;               // Get the current place value.\n                 x = x / base;                   // Deaccumulate the number.\n-                *byte = Self::digit(n.to_u8()); // Store the digit in the buffer.\n+                byte.set(Self::digit(n.to_u8())); // Store the digit in the buffer.\n                 curr -= 1;\n                 if x == zero {\n                     // No more digits left to accumulate.\n@@ -74,15 +72,19 @@ trait GenericRadix {\n             for byte in buf.iter_mut().rev() {\n                 let n = zero - (x % base);      // Get the current place value.\n                 x = x / base;                   // Deaccumulate the number.\n-                *byte = Self::digit(n.to_u8()); // Store the digit in the buffer.\n+                byte.set(Self::digit(n.to_u8())); // Store the digit in the buffer.\n                 curr -= 1;\n                 if x == zero {\n                     // No more digits left to accumulate.\n                     break\n                 };\n             }\n         }\n-        let buf = unsafe { str::from_utf8_unchecked(&buf[curr..]) };\n+        let buf = &buf[curr..];\n+        let buf = unsafe { str::from_utf8_unchecked(slice::from_raw_parts(\n+            MaybeUninit::first_ptr(buf),\n+            buf.len()\n+        )) };\n         f.pad_integral(is_nonnegative, Self::PREFIX, buf)\n     }\n }\n@@ -196,9 +198,9 @@ macro_rules! impl_Display {\n                 // convert the negative num to positive by summing 1 to it's 2 complement\n                 (!self.$conv_fn()).wrapping_add(1)\n             };\n-            let mut buf: [u8; 39] = unsafe { mem::uninitialized() };\n+            let mut buf = uninitialized_array![u8; 39];\n             let mut curr = buf.len() as isize;\n-            let buf_ptr = buf.as_mut_ptr();\n+            let buf_ptr = MaybeUninit::first_ptr_mut(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n             unsafe {"}, {"sha": "18f09f4c5dda4fed7235733881a9f1caac40f236", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -1,6 +1,6 @@\n //! An implementation of SipHash.\n \n-#![allow(deprecated)]\n+#![allow(deprecated)] // the types in this module are deprecated\n \n use marker::PhantomData;\n use ptr;"}, {"sha": "1ef21832592ca5c32b58ad8cf9fb8c0e45f759a4", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -58,11 +58,12 @@\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n        test(no_crate_inject, attr(deny(warnings))),\n        test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n-\n #![no_core]\n-#![deny(missing_docs)]\n-#![deny(intra_doc_link_resolution_failure)]\n-#![deny(missing_debug_implementations)]\n+\n+#![warn(deprecated_in_future)]\n+#![warn(missing_docs)]\n+#![warn(intra_doc_link_resolution_failure)]\n+#![warn(missing_debug_implementations)]\n \n #![feature(allow_internal_unstable)]\n #![feature(arbitrary_self_types)]\n@@ -122,6 +123,7 @@\n #![feature(structural_match)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n+#![feature(maybe_uninit)]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "12b7adb8a9d268d828478153408ea6bcbe8f9da7", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -547,6 +547,23 @@ macro_rules! unimplemented {\n     ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", format_args!($($arg)*)));\n }\n \n+/// A macro to create an array of [`MaybeUninit`]\n+///\n+/// This macro constructs and uninitialized array of the type `[MaybeUninit<K>; N]`.\n+///\n+/// [`MaybeUninit`]: mem/union.MaybeUninit.html\n+#[macro_export]\n+#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+macro_rules! uninitialized_array {\n+    // This `into_inner` is safe because an array of `MaybeUninit` does not\n+    // require initialization.\n+    // FIXME(#49147): Could be replaced by an array initializer, once those can\n+    // be any const expression.\n+    ($t:ty; $size:expr) => (unsafe {\n+        MaybeUninit::<[MaybeUninit<$t>; $size]>::uninitialized().into_inner()\n+    });\n+}\n+\n /// Built-in macros to the compiler itself.\n ///\n /// These macros do not have any corresponding definition with a `macro_rules!`"}, {"sha": "8b6d9d882b5ad6d31c113c85535ab6cafbe9f06a", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -1148,4 +1148,18 @@ impl<T> MaybeUninit<T> {\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n         unsafe { &mut *self.value as *mut T }\n     }\n+\n+    /// Get a pointer to the first element of the array.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n+        this as *const [MaybeUninit<T>] as *const T\n+    }\n+\n+    /// Get a mutable pointer to the first element of the array.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n+        this as *mut [MaybeUninit<T>] as *mut T\n+    }\n }"}, {"sha": "3f84faa04993915091367dea8caff8b596e5767b", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -216,14 +216,14 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n     let mut block_l = BLOCK;\n     let mut start_l = ptr::null_mut();\n     let mut end_l = ptr::null_mut();\n-    let mut offsets_l = MaybeUninit::<[u8; BLOCK]>::uninitialized();\n+    let mut offsets_l: [MaybeUninit<u8>; BLOCK] = uninitialized_array![u8; BLOCK];\n \n     // The current block on the right side (from `r.sub(block_r)` to `r`).\n     let mut r = unsafe { l.add(v.len()) };\n     let mut block_r = BLOCK;\n     let mut start_r = ptr::null_mut();\n     let mut end_r = ptr::null_mut();\n-    let mut offsets_r = MaybeUninit::<[u8; BLOCK]>::uninitialized();\n+    let mut offsets_r: [MaybeUninit<u8>; BLOCK] = uninitialized_array![u8; BLOCK];\n \n     // FIXME: When we get VLAs, try creating one array of length `min(v.len(), 2 * BLOCK)` rather\n     // than two fixed-size arrays of length `BLOCK`. VLAs might be more cache-efficient.\n@@ -262,8 +262,8 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n \n         if start_l == end_l {\n             // Trace `block_l` elements from the left side.\n-            start_l = offsets_l.as_mut_ptr() as *mut u8;\n-            end_l = offsets_l.as_mut_ptr() as *mut u8;\n+            start_l = MaybeUninit::first_ptr_mut(&mut offsets_l);\n+            end_l = MaybeUninit::first_ptr_mut(&mut offsets_l);\n             let mut elem = l;\n \n             for i in 0..block_l {\n@@ -278,8 +278,8 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n \n         if start_r == end_r {\n             // Trace `block_r` elements from the right side.\n-            start_r = offsets_r.as_mut_ptr() as *mut u8;\n-            end_r = offsets_r.as_mut_ptr() as *mut u8;\n+            start_r = MaybeUninit::first_ptr_mut(&mut offsets_r);\n+            end_r = MaybeUninit::first_ptr_mut(&mut offsets_r);\n             let mut elem = r;\n \n             for i in 0..block_r {"}, {"sha": "1e10329bb55ce97d2a9cf4ea47f2d12b31863008", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -362,6 +362,10 @@ struct Foo1 { x: &bool }\n               // ^ expected lifetime parameter\n struct Foo2<'a> { x: &'a bool } // correct\n \n+impl Foo2 {}\n+  // ^^^^ expected lifetime parameter\n+impl<'a> Foo2<'a> {} // correct\n+\n struct Bar1 { x: Foo2 }\n               // ^^^^ expected lifetime parameter\n struct Bar2<'a> { x: Foo2<'a> } // correct\n@@ -766,11 +770,40 @@ struct Foo {\n These can be fixed by declaring lifetime parameters:\n \n ```\n+struct Foo<'a> {\n+    x: &'a str,\n+}\n+\n fn foo<'a>(x: &'a str) {}\n+```\n \n+Impl blocks declare lifetime parameters separately. You need to add lifetime\n+parameters to an impl block if you're implementing a type that has a lifetime\n+parameter of its own.\n+For example:\n+\n+```compile_fail,E0261\n struct Foo<'a> {\n     x: &'a str,\n }\n+\n+// error,  use of undeclared lifetime name `'a`\n+impl Foo<'a> {\n+    fn foo<'a>(x: &'a str) {}\n+}\n+```\n+\n+This is fixed by declaring the impl block like this:\n+\n+```\n+struct Foo<'a> {\n+    x: &'a str,\n+}\n+\n+// correct\n+impl<'a> Foo<'a> {\n+    fn foo(x: &'a str) {}\n+}\n ```\n \"##,\n "}, {"sha": "da7e021b2d54b79d1bd12cc59b1af888f940de88", "filename": "src/librustc/ty/erase_regions.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibrustc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibrustc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferase_regions.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -1,4 +1,4 @@\n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, Ty, TyCtxt, TypeFlags};\n use ty::fold::{TypeFolder, TypeFoldable};\n \n pub(super) fn provide(providers: &mut ty::query::Providers<'_>) {\n@@ -21,6 +21,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn erase_regions<T>(self, value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n+        // If there's nothing to erase avoid performing the query at all\n+        if !value.has_type_flags(TypeFlags::HAS_RE_LATE_BOUND | TypeFlags::HAS_FREE_REGIONS) {\n+            return value.clone();\n+        }\n+\n         let value1 = value.fold_with(&mut RegionEraserVisitor { tcx: self });\n         debug!(\"erase_regions({:?}) = {:?}\", value, value1);\n         value1"}, {"sha": "abf575aed672538166871f377c4e2e52a56d9743", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 70, "deletions": 10, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -15,11 +15,13 @@ use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy};\n-use syntax::ext::base::{Annotatable, MacroKind, SyntaxExtension};\n+use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, Mark};\n use syntax::ext::tt::macro_rules;\n-use syntax::feature_gate::{feature_err, is_builtin_attr_name, GateIssue};\n+use syntax::feature_gate::{\n+    feature_err, is_builtin_attr_name, AttributeGate, GateIssue, Stability, BUILTIN_ATTRIBUTES,\n+};\n use syntax::symbol::{Symbol, keywords};\n use syntax::visit::Visitor;\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -127,9 +129,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n         mark\n     }\n \n-    fn resolve_dollar_crates(&mut self, annotatable: &Annotatable) {\n-        pub struct ResolveDollarCrates<'a, 'b: 'a> {\n-            pub resolver: &'a mut Resolver<'b>,\n+    fn resolve_dollar_crates(&mut self, fragment: &AstFragment) {\n+        struct ResolveDollarCrates<'a, 'b: 'a> {\n+            resolver: &'a mut Resolver<'b>\n         }\n         impl<'a> Visitor<'a> for ResolveDollarCrates<'a, '_> {\n             fn visit_ident(&mut self, ident: Ident) {\n@@ -144,7 +146,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             fn visit_mac(&mut self, _: &ast::Mac) {}\n         }\n \n-        annotatable.visit_with(&mut ResolveDollarCrates { resolver: self });\n+        fragment.visit_with(&mut ResolveDollarCrates { resolver: self });\n     }\n \n     fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n@@ -310,15 +312,18 @@ impl<'a> Resolver<'a> {\n                             if !features.rustc_attrs {\n                                 let msg = \"unless otherwise specified, attributes with the prefix \\\n                                            `rustc_` are reserved for internal compiler diagnostics\";\n-                                feature_err(&self.session.parse_sess, \"rustc_attrs\", path.span,\n-                                            GateIssue::Language, &msg).emit();\n+                                self.report_unknown_attribute(path.span, &name, msg, \"rustc_attrs\");\n                             }\n                         } else if !features.custom_attribute {\n                             let msg = format!(\"The attribute `{}` is currently unknown to the \\\n                                                compiler and may have meaning added to it in the \\\n                                                future\", path);\n-                            feature_err(&self.session.parse_sess, \"custom_attribute\", path.span,\n-                                        GateIssue::Language, &msg).emit();\n+                            self.report_unknown_attribute(\n+                                path.span,\n+                                &name,\n+                                &msg,\n+                                \"custom_attribute\",\n+                            );\n                         }\n                     }\n                 } else {\n@@ -339,6 +344,61 @@ impl<'a> Resolver<'a> {\n         Ok((def, self.get_macro(def)))\n     }\n \n+    fn report_unknown_attribute(&self, span: Span, name: &str, msg: &str, feature: &str) {\n+        let mut err = feature_err(\n+            &self.session.parse_sess,\n+            feature,\n+            span,\n+            GateIssue::Language,\n+            &msg,\n+        );\n+\n+        let features = self.session.features_untracked();\n+\n+        let attr_candidates = BUILTIN_ATTRIBUTES\n+            .iter()\n+            .filter_map(|(name, _, _, gate)| {\n+                if name.starts_with(\"rustc_\") && !features.rustc_attrs {\n+                    return None;\n+                }\n+\n+                match gate {\n+                    AttributeGate::Gated(Stability::Unstable, ..)\n+                        if self.session.opts.unstable_features.is_nightly_build() =>\n+                    {\n+                        Some(name)\n+                    }\n+                    AttributeGate::Gated(Stability::Deprecated(..), ..) => Some(name),\n+                    AttributeGate::Ungated => Some(name),\n+                    _ => None,\n+                }\n+            })\n+            .map(|name| Symbol::intern(name))\n+            .chain(\n+                // Add built-in macro attributes as well.\n+                self.builtin_macros.iter().filter_map(|(name, binding)| {\n+                    match binding.macro_kind() {\n+                        Some(MacroKind::Attr) => Some(*name),\n+                        _ => None,\n+                    }\n+                }),\n+            )\n+            .collect::<Vec<_>>();\n+\n+        let lev_suggestion = find_best_match_for_name(attr_candidates.iter(), &name, None);\n+\n+        if let Some(suggestion) = lev_suggestion {\n+            err.span_suggestion(\n+                span,\n+                \"a built-in attribute with a similar name exists\",\n+                suggestion.to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+\n+        err.emit();\n+    }\n+\n     pub fn resolve_macro_to_def_inner(\n         &mut self,\n         path: &ast::Path,"}, {"sha": "9a04c9d60b86822d21b4cf165ed09d4e4bd228b4", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -537,11 +537,8 @@ impl<'a> Resolver<'a> {\n                  primary_binding: &'a NameBinding<'a>, secondary_binding: &'a NameBinding<'a>)\n                  -> &'a NameBinding<'a> {\n         self.arenas.alloc_name_binding(NameBinding {\n-            kind: primary_binding.kind.clone(),\n             ambiguity: Some((secondary_binding, kind)),\n-            vis: primary_binding.vis,\n-            span: primary_binding.span,\n-            expansion: primary_binding.expansion,\n+            ..primary_binding.clone()\n         })\n     }\n "}, {"sha": "6935ecde791f8901bc99d07c483668fee8fbb133", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -410,10 +410,6 @@ kbd {\n \tcolor: #ccc;\n }\n \n-.impl-items code {\n-\tbackground-color: rgba(0, 0, 0, 0);\n-}\n-\n #sidebar-toggle {\n \tbackground-color: #565656;\n }"}, {"sha": "306e8dc15d89327b31e24f4ab615a24de15eff9c", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -405,10 +405,6 @@ kbd {\n \tcolor: #999;\n }\n \n-.impl-items code {\n-\tbackground-color: rgba(0, 0, 0, 0);\n-}\n-\n #sidebar-toggle {\n \tbackground-color: #F1F1F1;\n }"}, {"sha": "eb8e0c1c8ac66777d1b774b67c90d101b41fdeba", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -607,7 +607,7 @@ impl Builder {\n pub fn spawn<F, T>(f: F) -> JoinHandle<T> where\n     F: FnOnce() -> T, F: Send + 'static, T: Send + 'static\n {\n-    Builder::new().spawn(f).unwrap()\n+    Builder::new().spawn(f).expect(\"failed to spawn thread\")\n }\n \n /// Gets a handle to the thread that invokes it."}, {"sha": "09e7e57f78cfa8643f72e658b384db3ec96b4814", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -14,7 +14,6 @@ use parse::token;\n use ptr::P;\n use smallvec::SmallVec;\n use symbol::{keywords, Ident, Symbol};\n-use visit::Visitor;\n use ThinVec;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -136,17 +135,6 @@ impl Annotatable {\n             _ => false,\n         }\n     }\n-\n-    pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n-        match self {\n-            Annotatable::Item(item) => visitor.visit_item(item),\n-            Annotatable::TraitItem(trait_item) => visitor.visit_trait_item(trait_item),\n-            Annotatable::ImplItem(impl_item) => visitor.visit_impl_item(impl_item),\n-            Annotatable::ForeignItem(foreign_item) => visitor.visit_foreign_item(foreign_item),\n-            Annotatable::Stmt(stmt) => visitor.visit_stmt(stmt),\n-            Annotatable::Expr(expr) => visitor.visit_expr(expr),\n-        }\n-    }\n }\n \n // A more flexible ItemDecorator.\n@@ -742,7 +730,7 @@ pub trait Resolver {\n     fn next_node_id(&mut self) -> ast::NodeId;\n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark;\n \n-    fn resolve_dollar_crates(&mut self, annotatable: &Annotatable);\n+    fn resolve_dollar_crates(&mut self, fragment: &AstFragment);\n     fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n                                             derives: &[Mark]);\n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n@@ -776,7 +764,7 @@ impl Resolver for DummyResolver {\n     fn next_node_id(&mut self) -> ast::NodeId { ast::DUMMY_NODE_ID }\n     fn get_module_scope(&mut self, _id: ast::NodeId) -> Mark { Mark::root() }\n \n-    fn resolve_dollar_crates(&mut self, _annotatable: &Annotatable) {}\n+    fn resolve_dollar_crates(&mut self, _fragment: &AstFragment) {}\n     fn visit_ast_fragment_with_placeholders(&mut self, _invoc: Mark, _fragment: &AstFragment,\n                                             _derives: &[Mark]) {}\n     fn add_builtin(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}"}, {"sha": "1b4b44270ad0601f4108d76d6ea211bef5c60547", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -443,6 +443,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// prepares data for resolving paths of macro invocations.\n     fn collect_invocations(&mut self, fragment: AstFragment, derives: &[Mark])\n                            -> (AstFragment, Vec<Invocation>) {\n+        // Resolve `$crate`s in the fragment for pretty-printing.\n+        self.cx.resolver.resolve_dollar_crates(&fragment);\n+\n         let (fragment_with_placeholders, invocations) = {\n             let mut collector = InvocationCollector {\n                 cfg: StripUnconfigured {\n@@ -574,8 +577,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             AttrProcMacro(ref mac, ..) => {\n-                // Resolve `$crate`s in case we have to go though stringification.\n-                self.cx.resolver.resolve_dollar_crates(&item);\n                 self.gate_proc_macro_attr_item(attr.span, &item);\n                 let item_tok = TokenTree::Token(DUMMY_SP, Token::interpolated(match item {\n                     Annotatable::Item(item) => token::NtItem(item),\n@@ -917,8 +918,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         match *ext {\n             ProcMacroDerive(ref ext, ..) => {\n-                // Resolve `$crate`s in case we have to go though stringification.\n-                self.cx.resolver.resolve_dollar_crates(&item);\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n                 let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this"}, {"sha": "3d2d949be2b2e1dc78e6d68bf88f439c76885521", "filename": "src/test/pretty/dollar-crate.pp", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Ftest%2Fpretty%2Fdollar-crate.pp", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Ftest%2Fpretty%2Fdollar-crate.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdollar-crate.pp?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -0,0 +1,18 @@\n+#![feature(prelude_import)]\n+#![no_std]\n+#[prelude_import]\n+use ::std::prelude::v1::*;\n+#[macro_use]\n+extern crate std;\n+// pretty-compare-only\n+// pretty-mode:expanded\n+// pp-exact:dollar-crate.pp\n+\n+fn main() {\n+    {\n+        ::std::io::_print(::std::fmt::Arguments::new_v1(&[\"rust\\n\"],\n+                                                        &match () {\n+                                                             () => [],\n+                                                         }));\n+    };\n+}"}, {"sha": "e46bc7f4859a77bfcf657312d5da1f26996a39b0", "filename": "src/test/pretty/dollar-crate.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Ftest%2Fpretty%2Fdollar-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Ftest%2Fpretty%2Fdollar-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdollar-crate.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -0,0 +1,7 @@\n+// pretty-compare-only\n+// pretty-mode:expanded\n+// pp-exact:dollar-crate.pp\n+\n+fn main() {\n+    println!(\"rust\");\n+}"}, {"sha": "a25d8ee352686be56a4464ab286becef308d1e12", "filename": "src/test/ui/issues/issue-49074.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -2,7 +2,7 @@ error[E0658]: The attribute `marco_use` is currently unknown to the compiler and\n   --> $DIR/issue-49074.rs:3:3\n    |\n LL | #[marco_use] // typo\n-   |   ^^^^^^^^^\n+   |   ^^^^^^^^^ help: a built-in attribute with a similar name exists: `macro_use`\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n "}, {"sha": "6cfec3ee762dda92f291422d51c47488a4068f75", "filename": "src/test/ui/macros/macro-reexport-removed.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.stderr?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -14,7 +14,7 @@ error[E0658]: The attribute `macro_reexport` is currently unknown to the compile\n   --> $DIR/macro-reexport-removed.rs:5:3\n    |\n LL | #[macro_reexport(macro_one)] //~ ERROR attribute `macro_reexport` is currently unknown\n-   |   ^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^^^^^^ help: a built-in attribute with a similar name exists: `macro_export`\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n "}, {"sha": "ece1b6212914db7a82e7b94cd9a1d46b49020927", "filename": "src/test/ui/proc-macro/derive-still-gated.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.stderr?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -2,7 +2,7 @@ error[E0658]: The attribute `derive_A` is currently unknown to the compiler and\n   --> $DIR/derive-still-gated.rs:8:3\n    |\n LL | #[derive_A] //~ ERROR attribute `derive_A` is currently unknown\n-   |   ^^^^^^^^\n+   |   ^^^^^^^^ help: a built-in attribute with a similar name exists: `derive`\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n "}, {"sha": "13c6308b97e85d4e2e021f965a9c4eabd5064086", "filename": "src/test/ui/suggestions/attribute-typos.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.rs?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -0,0 +1,13 @@\n+#[deprcated]    //~ ERROR E0658\n+fn foo() {}     //~| HELP a built-in attribute with a similar name exists\n+                //~| SUGGESTION deprecated\n+                //~| HELP add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+#[tests]        //~ ERROR E0658\n+fn bar() {}     //~| HELP a built-in attribute with a similar name exists\n+                //~| SUGGESTION test\n+                //~| HELP add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+#[rustc_err]    //~ ERROR E0658\n+fn main() {}    //~| HELP add #![feature(rustc_attrs)] to the crate attributes to enable\n+                // don't suggest rustc attributes"}, {"sha": "e40da787e96ca5aaf2a0e7ac61ac9c8fbdaa56e6", "filename": "src/test/ui/suggestions/attribute-typos.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f60208ba11171c249284f8fe0ea6b3e9b63383c/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr?ref=5f60208ba11171c249284f8fe0ea6b3e9b63383c", "patch": "@@ -0,0 +1,27 @@\n+error[E0658]: unless otherwise specified, attributes with the prefix `rustc_` are reserved for internal compiler diagnostics (see issue #29642)\n+  --> $DIR/attribute-typos.rs:11:3\n+   |\n+LL | #[rustc_err]    //~ ERROR E0658\n+   |   ^^^^^^^^^\n+   |\n+   = help: add #![feature(rustc_attrs)] to the crate attributes to enable\n+\n+error[E0658]: The attribute `tests` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/attribute-typos.rs:6:3\n+   |\n+LL | #[tests]        //~ ERROR E0658\n+   |   ^^^^^ help: a built-in attribute with a similar name exists: `test`\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error[E0658]: The attribute `deprcated` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/attribute-typos.rs:1:3\n+   |\n+LL | #[deprcated]    //~ ERROR E0658\n+   |   ^^^^^^^^^ help: a built-in attribute with a similar name exists: `deprecated`\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}]}