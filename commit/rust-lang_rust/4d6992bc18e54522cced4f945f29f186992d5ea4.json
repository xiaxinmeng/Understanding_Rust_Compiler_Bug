{"sha": "4d6992bc18e54522cced4f945f29f186992d5ea4", "node_id": "C_kwDOAAsO6NoAKDRkNjk5MmJjMThlNTQ1MjJjY2VkNGY5NDVmMjlmMTg2OTkyZDVlYTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-20T01:05:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-20T01:05:53Z"}, "message": "Auto merge of #97027 - cuviper:yesalias-refcell, r=thomcc\n\nUse pointers in `cell::{Ref,RefMut}` to avoid `noalias`\n\nWhen `Ref` and `RefMut` were based on references, they would get LLVM `noalias` attributes that were incorrect, because that alias guarantee is only true until the guard drops. A `&RefCell` on the same value can get a new borrow that aliases the previous guard, possibly leading to miscompilation. Using `NonNull` pointers in `Ref` and `RefCell` avoids `noalias`.\n\nFixes the library side of #63787, but we still might want to explore language solutions there.", "tree": {"sha": "b792b7921a20c181db9ae50451a8093887ae5cba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b792b7921a20c181db9ae50451a8093887ae5cba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d6992bc18e54522cced4f945f29f186992d5ea4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d6992bc18e54522cced4f945f29f186992d5ea4", "html_url": "https://github.com/rust-lang/rust/commit/4d6992bc18e54522cced4f945f29f186992d5ea4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d6992bc18e54522cced4f945f29f186992d5ea4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a09d36deae2e25f2eb4a0ee5d95519042ebd66a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a09d36deae2e25f2eb4a0ee5d95519042ebd66a2", "html_url": "https://github.com/rust-lang/rust/commit/a09d36deae2e25f2eb4a0ee5d95519042ebd66a2"}, {"sha": "1c3921fa43ecc6438a1f4d5365d2f99caad7b847", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c3921fa43ecc6438a1f4d5365d2f99caad7b847", "html_url": "https://github.com/rust-lang/rust/commit/1c3921fa43ecc6438a1f4d5365d2f99caad7b847"}], "stats": {"total": 141, "additions": 103, "deletions": 38}, "files": [{"sha": "5448ced803a09f6ca568aa7b1d314a738dc4725d", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 49, "deletions": 34, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4d6992bc18e54522cced4f945f29f186992d5ea4/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d6992bc18e54522cced4f945f29f186992d5ea4/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=4d6992bc18e54522cced4f945f29f186992d5ea4", "patch": "@@ -194,10 +194,10 @@\n \n use crate::cmp::Ordering;\n use crate::fmt::{self, Debug, Display};\n-use crate::marker::Unsize;\n+use crate::marker::{PhantomData, Unsize};\n use crate::mem;\n use crate::ops::{CoerceUnsized, Deref, DerefMut};\n-use crate::ptr;\n+use crate::ptr::{self, NonNull};\n \n /// A mutable memory location.\n ///\n@@ -896,7 +896,8 @@ impl<T: ?Sized> RefCell<T> {\n \n                 // SAFETY: `BorrowRef` ensures that there is only immutable access\n                 // to the value while borrowed.\n-                Ok(Ref { value: unsafe { &*self.value.get() }, borrow: b })\n+                let value = unsafe { NonNull::new_unchecked(self.value.get()) };\n+                Ok(Ref { value, borrow: b })\n             }\n             None => Err(BorrowError {\n                 // If a borrow occurred, then we must already have an outstanding borrow,\n@@ -980,8 +981,9 @@ impl<T: ?Sized> RefCell<T> {\n                     self.borrowed_at.set(Some(crate::panic::Location::caller()));\n                 }\n \n-                // SAFETY: `BorrowRef` guarantees unique access.\n-                Ok(RefMut { value: unsafe { &mut *self.value.get() }, borrow: b })\n+                // SAFETY: `BorrowRefMut` guarantees unique access.\n+                let value = unsafe { NonNull::new_unchecked(self.value.get()) };\n+                Ok(RefMut { value, borrow: b, marker: PhantomData })\n             }\n             None => Err(BorrowMutError {\n                 // If a borrow occurred, then we must already have an outstanding borrow,\n@@ -1314,7 +1316,10 @@ impl Clone for BorrowRef<'_> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[must_not_suspend = \"holding a Ref across suspend points can cause BorrowErrors\"]\n pub struct Ref<'b, T: ?Sized + 'b> {\n-    value: &'b T,\n+    // NB: we use a pointer instead of `&'b T` to avoid `noalias` violations, because a\n+    // `Ref` argument doesn't hold immutability for its whole scope, only until it drops.\n+    // `NonNull` is also covariant over `T`, just like we would have with `&T`.\n+    value: NonNull<T>,\n     borrow: BorrowRef<'b>,\n }\n \n@@ -1324,7 +1329,8 @@ impl<T: ?Sized> Deref for Ref<'_, T> {\n \n     #[inline]\n     fn deref(&self) -> &T {\n-        self.value\n+        // SAFETY: the value is accessible as long as we hold our borrow.\n+        unsafe { self.value.as_ref() }\n     }\n }\n \n@@ -1368,7 +1374,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     where\n         F: FnOnce(&T) -> &U,\n     {\n-        Ref { value: f(orig.value), borrow: orig.borrow }\n+        Ref { value: NonNull::from(f(&*orig)), borrow: orig.borrow }\n     }\n \n     /// Makes a new `Ref` for an optional component of the borrowed data. The\n@@ -1399,8 +1405,8 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     where\n         F: FnOnce(&T) -> Option<&U>,\n     {\n-        match f(orig.value) {\n-            Some(value) => Ok(Ref { value, borrow: orig.borrow }),\n+        match f(&*orig) {\n+            Some(value) => Ok(Ref { value: NonNull::from(value), borrow: orig.borrow }),\n             None => Err(orig),\n         }\n     }\n@@ -1431,9 +1437,12 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     where\n         F: FnOnce(&T) -> (&U, &V),\n     {\n-        let (a, b) = f(orig.value);\n+        let (a, b) = f(&*orig);\n         let borrow = orig.borrow.clone();\n-        (Ref { value: a, borrow }, Ref { value: b, borrow: orig.borrow })\n+        (\n+            Ref { value: NonNull::from(a), borrow },\n+            Ref { value: NonNull::from(b), borrow: orig.borrow },\n+        )\n     }\n \n     /// Convert into a reference to the underlying data.\n@@ -1467,7 +1476,8 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         // unique reference to the borrowed RefCell. No further mutable references can be created\n         // from the original cell.\n         mem::forget(orig.borrow);\n-        orig.value\n+        // SAFETY: after forgetting, we can form a reference for the rest of lifetime `'b`.\n+        unsafe { orig.value.as_ref() }\n     }\n }\n \n@@ -1507,13 +1517,12 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     /// ```\n     #[stable(feature = \"cell_map\", since = \"1.8.0\")]\n     #[inline]\n-    pub fn map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> RefMut<'b, U>\n+    pub fn map<U: ?Sized, F>(mut orig: RefMut<'b, T>, f: F) -> RefMut<'b, U>\n     where\n         F: FnOnce(&mut T) -> &mut U,\n     {\n-        // FIXME(nll-rfc#40): fix borrow-check\n-        let RefMut { value, borrow } = orig;\n-        RefMut { value: f(value), borrow }\n+        let value = NonNull::from(f(&mut *orig));\n+        RefMut { value, borrow: orig.borrow, marker: PhantomData }\n     }\n \n     /// Makes a new `RefMut` for an optional component of the borrowed data. The\n@@ -1548,23 +1557,19 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     /// ```\n     #[unstable(feature = \"cell_filter_map\", reason = \"recently added\", issue = \"81061\")]\n     #[inline]\n-    pub fn filter_map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> Result<RefMut<'b, U>, Self>\n+    pub fn filter_map<U: ?Sized, F>(mut orig: RefMut<'b, T>, f: F) -> Result<RefMut<'b, U>, Self>\n     where\n         F: FnOnce(&mut T) -> Option<&mut U>,\n     {\n-        // FIXME(nll-rfc#40): fix borrow-check\n-        let RefMut { value, borrow } = orig;\n-        let value = value as *mut T;\n         // SAFETY: function holds onto an exclusive reference for the duration\n         // of its call through `orig`, and the pointer is only de-referenced\n         // inside of the function call never allowing the exclusive reference to\n         // escape.\n-        match f(unsafe { &mut *value }) {\n-            Some(value) => Ok(RefMut { value, borrow }),\n-            None => {\n-                // SAFETY: same as above.\n-                Err(RefMut { value: unsafe { &mut *value }, borrow })\n+        match f(&mut *orig) {\n+            Some(value) => {\n+                Ok(RefMut { value: NonNull::from(value), borrow: orig.borrow, marker: PhantomData })\n             }\n+            None => Err(orig),\n         }\n     }\n \n@@ -1596,15 +1601,18 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     #[stable(feature = \"refcell_map_split\", since = \"1.35.0\")]\n     #[inline]\n     pub fn map_split<U: ?Sized, V: ?Sized, F>(\n-        orig: RefMut<'b, T>,\n+        mut orig: RefMut<'b, T>,\n         f: F,\n     ) -> (RefMut<'b, U>, RefMut<'b, V>)\n     where\n         F: FnOnce(&mut T) -> (&mut U, &mut V),\n     {\n-        let (a, b) = f(orig.value);\n         let borrow = orig.borrow.clone();\n-        (RefMut { value: a, borrow }, RefMut { value: b, borrow: orig.borrow })\n+        let (a, b) = f(&mut *orig);\n+        (\n+            RefMut { value: NonNull::from(a), borrow, marker: PhantomData },\n+            RefMut { value: NonNull::from(b), borrow: orig.borrow, marker: PhantomData },\n+        )\n     }\n \n     /// Convert into a mutable reference to the underlying data.\n@@ -1630,14 +1638,15 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     /// assert!(cell.try_borrow_mut().is_err());\n     /// ```\n     #[unstable(feature = \"cell_leak\", issue = \"69099\")]\n-    pub fn leak(orig: RefMut<'b, T>) -> &'b mut T {\n+    pub fn leak(mut orig: RefMut<'b, T>) -> &'b mut T {\n         // By forgetting this BorrowRefMut we ensure that the borrow counter in the RefCell can't\n         // go back to UNUSED within the lifetime `'b`. Resetting the reference tracking state would\n         // require a unique reference to the borrowed RefCell. No further references can be created\n         // from the original cell within that lifetime, making the current borrow the only\n         // reference for the remaining lifetime.\n         mem::forget(orig.borrow);\n-        orig.value\n+        // SAFETY: after forgetting, we can form a reference for the rest of lifetime `'b`.\n+        unsafe { orig.value.as_mut() }\n     }\n }\n \n@@ -1692,8 +1701,12 @@ impl<'b> BorrowRefMut<'b> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[must_not_suspend = \"holding a RefMut across suspend points can cause BorrowErrors\"]\n pub struct RefMut<'b, T: ?Sized + 'b> {\n-    value: &'b mut T,\n+    // NB: we use a pointer instead of `&'b mut T` to avoid `noalias` violations, because a\n+    // `RefMut` argument doesn't hold exclusivity for its whole scope, only until it drops.\n+    value: NonNull<T>,\n     borrow: BorrowRefMut<'b>,\n+    // `NonNull` is covariant over `T`, so we need to reintroduce invariance.\n+    marker: PhantomData<&'b mut T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1702,15 +1715,17 @@ impl<T: ?Sized> Deref for RefMut<'_, T> {\n \n     #[inline]\n     fn deref(&self) -> &T {\n-        self.value\n+        // SAFETY: the value is accessible as long as we hold our borrow.\n+        unsafe { self.value.as_ref() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> DerefMut for RefMut<'_, T> {\n     #[inline]\n     fn deref_mut(&mut self) -> &mut T {\n-        self.value\n+        // SAFETY: the value is accessible as long as we hold our borrow.\n+        unsafe { self.value.as_mut() }\n     }\n }\n "}, {"sha": "a4e8a57e4b16d50b7152caab9b50bb0ee89a12f4", "filename": "src/etc/natvis/libcore.natvis", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d6992bc18e54522cced4f945f29f186992d5ea4/src%2Fetc%2Fnatvis%2Flibcore.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/4d6992bc18e54522cced4f945f29f186992d5ea4/src%2Fetc%2Fnatvis%2Flibcore.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Flibcore.natvis?ref=4d6992bc18e54522cced4f945f29f186992d5ea4", "patch": "@@ -7,15 +7,15 @@\n     </Expand>\n   </Type>\n   <Type Name=\"core::cell::Ref&lt;*&gt;\">\n-    <DisplayString>{value}</DisplayString>\n+    <DisplayString>{value.pointer}</DisplayString>\n     <Expand>\n-      <ExpandedItem>value</ExpandedItem>\n+      <ExpandedItem>value.pointer</ExpandedItem>\n     </Expand>\n   </Type>\n   <Type Name=\"core::cell::RefMut&lt;*&gt;\">\n-    <DisplayString>{value}</DisplayString>\n+    <DisplayString>{value.pointer}</DisplayString>\n     <Expand>\n-      <ExpandedItem>value</ExpandedItem>\n+      <ExpandedItem>value.pointer</ExpandedItem>\n     </Expand>\n   </Type>\n   <Type Name=\"core::cell::RefCell&lt;*&gt;\">"}, {"sha": "dba73937abf178e09124e649c9ab504501cf2463", "filename": "src/test/codegen/noalias-refcell.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4d6992bc18e54522cced4f945f29f186992d5ea4/src%2Ftest%2Fcodegen%2Fnoalias-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d6992bc18e54522cced4f945f29f186992d5ea4/src%2Ftest%2Fcodegen%2Fnoalias-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnoalias-refcell.rs?ref=4d6992bc18e54522cced4f945f29f186992d5ea4", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -O -C no-prepopulate-passes -Z mutable-noalias=yes\n+\n+#![crate_type = \"lib\"]\n+\n+use std::cell::{Ref, RefCell, RefMut};\n+\n+// Make sure that none of the arguments get a `noalias` attribute, because\n+// the `RefCell` might alias writes after either `Ref`/`RefMut` is dropped.\n+\n+// CHECK-LABEL: @maybe_aliased(\n+// CHECK-NOT: noalias\n+// CHECK-SAME: %_refcell\n+#[no_mangle]\n+pub unsafe fn maybe_aliased(_: Ref<'_, i32>, _: RefMut<'_, i32>, _refcell: &RefCell<i32>) {}"}, {"sha": "cba079b2315225d453f813982beb2d1279a26fd1", "filename": "src/test/ui/issues/issue-63787.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4d6992bc18e54522cced4f945f29f186992d5ea4/src%2Ftest%2Fui%2Fissues%2Fissue-63787.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d6992bc18e54522cced4f945f29f186992d5ea4/src%2Ftest%2Fui%2Fissues%2Fissue-63787.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-63787.rs?ref=4d6992bc18e54522cced4f945f29f186992d5ea4", "patch": "@@ -0,0 +1,36 @@\n+// run-pass\n+// compile-flags: -O\n+\n+// Make sure that `Ref` and `RefMut` do not make false promises about aliasing,\n+// because once they drop, their reference/pointer can alias other writes.\n+\n+// Adapted from comex's proof of concept:\n+// https://github.com/rust-lang/rust/issues/63787#issuecomment-523588164\n+\n+use std::cell::RefCell;\n+use std::ops::Deref;\n+\n+pub fn break_if_r_is_noalias(rc: &RefCell<i32>, r: impl Deref<Target = i32>) -> i32 {\n+    let ptr1 = &*r as *const i32;\n+    let a = *r;\n+    drop(r);\n+    *rc.borrow_mut() = 2;\n+    let r2 = rc.borrow();\n+    let ptr2 = &*r2 as *const i32;\n+    if ptr2 != ptr1 {\n+        panic!();\n+    }\n+    // If LLVM knows the pointers are the same, and if `r` was `noalias`,\n+    // then it may replace this with `a + a`, ignoring the earlier write.\n+    a + *r2\n+}\n+\n+fn main() {\n+    let mut rc = RefCell::new(1);\n+    let res = break_if_r_is_noalias(&rc, rc.borrow());\n+    assert_eq!(res, 3);\n+\n+    *rc.get_mut() = 1;\n+    let res = break_if_r_is_noalias(&rc, rc.borrow_mut());\n+    assert_eq!(res, 3);\n+}"}]}