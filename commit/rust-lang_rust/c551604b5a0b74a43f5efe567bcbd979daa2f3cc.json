{"sha": "c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1NTE2MDRiNWEwYjc0YTQzZjVlZmU1NjdiY2JkOTc5ZGFhMmYzY2M=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-03T11:08:29Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-03T11:08:29Z"}, "message": "Rename Ty::interned to Ty::kind\n\n... since that's the actual method on Chalk side that matches the signature.", "tree": {"sha": "aba0fc8a8b9dcd3456f47ae5cd28fa672a7a6911", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aba0fc8a8b9dcd3456f47ae5cd28fa672a7a6911"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "html_url": "https://github.com/rust-lang/rust/commit/c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "html_url": "https://github.com/rust-lang/rust/commit/8289b96216b5d4ddd0b6cf9feccb7af574d022a8"}], "stats": {"total": 148, "additions": 73, "deletions": 75}, "files": [{"sha": "29010191b5e675799d252b0f9b09a590580b0430", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -1711,22 +1711,22 @@ impl Type {\n     }\n \n     pub fn is_unit(&self) -> bool {\n-        matches!(self.ty.interned(&Interner), TyKind::Tuple(0, ..))\n+        matches!(self.ty.kind(&Interner), TyKind::Tuple(0, ..))\n     }\n     pub fn is_bool(&self) -> bool {\n-        matches!(self.ty.interned(&Interner), TyKind::Scalar(Scalar::Bool))\n+        matches!(self.ty.kind(&Interner), TyKind::Scalar(Scalar::Bool))\n     }\n \n     pub fn is_mutable_reference(&self) -> bool {\n-        matches!(self.ty.interned(&Interner), TyKind::Ref(hir_ty::Mutability::Mut, ..))\n+        matches!(self.ty.kind(&Interner), TyKind::Ref(hir_ty::Mutability::Mut, ..))\n     }\n \n     pub fn is_usize(&self) -> bool {\n-        matches!(self.ty.interned(&Interner), TyKind::Scalar(Scalar::Uint(UintTy::Usize)))\n+        matches!(self.ty.kind(&Interner), TyKind::Scalar(Scalar::Uint(UintTy::Usize)))\n     }\n \n     pub fn remove_ref(&self) -> Option<Type> {\n-        match &self.ty.interned(&Interner) {\n+        match &self.ty.kind(&Interner) {\n             TyKind::Ref(.., ty) => Some(self.derived(ty.clone())),\n             _ => None,\n         }\n@@ -1855,15 +1855,15 @@ impl Type {\n     }\n \n     pub fn is_closure(&self) -> bool {\n-        matches!(&self.ty.interned(&Interner), TyKind::Closure { .. })\n+        matches!(&self.ty.kind(&Interner), TyKind::Closure { .. })\n     }\n \n     pub fn is_fn(&self) -> bool {\n-        matches!(&self.ty.interned(&Interner), TyKind::FnDef(..) | TyKind::Function { .. })\n+        matches!(&self.ty.kind(&Interner), TyKind::FnDef(..) | TyKind::Function { .. })\n     }\n \n     pub fn is_packed(&self, db: &dyn HirDatabase) -> bool {\n-        let adt_id = match self.ty.interned(&Interner) {\n+        let adt_id = match self.ty.kind(&Interner) {\n             &TyKind::Adt(hir_ty::AdtId(adt_id), ..) => adt_id,\n             _ => return false,\n         };\n@@ -1876,14 +1876,14 @@ impl Type {\n     }\n \n     pub fn is_raw_ptr(&self) -> bool {\n-        matches!(&self.ty.interned(&Interner), TyKind::Raw(..))\n+        matches!(&self.ty.kind(&Interner), TyKind::Raw(..))\n     }\n \n     pub fn contains_unknown(&self) -> bool {\n         return go(&self.ty);\n \n         fn go(ty: &Ty) -> bool {\n-            match ty.interned(&Interner) {\n+            match ty.kind(&Interner) {\n                 TyKind::Unknown => true,\n \n                 TyKind::Adt(_, substs)\n@@ -1914,7 +1914,7 @@ impl Type {\n     }\n \n     pub fn fields(&self, db: &dyn HirDatabase) -> Vec<(Field, Type)> {\n-        let (variant_id, substs) = match self.ty.interned(&Interner) {\n+        let (variant_id, substs) = match self.ty.kind(&Interner) {\n             &TyKind::Adt(hir_ty::AdtId(AdtId::StructId(s)), ref substs) => (s.into(), substs),\n             &TyKind::Adt(hir_ty::AdtId(AdtId::UnionId(u)), ref substs) => (u.into(), substs),\n             _ => return Vec::new(),\n@@ -1931,7 +1931,7 @@ impl Type {\n     }\n \n     pub fn tuple_fields(&self, _db: &dyn HirDatabase) -> Vec<Type> {\n-        if let TyKind::Tuple(_, substs) = &self.ty.interned(&Interner) {\n+        if let TyKind::Tuple(_, substs) = &self.ty.kind(&Interner) {\n             substs\n                 .iter(&Interner)\n                 .map(|ty| self.derived(ty.assert_ty_ref(&Interner).clone()))\n@@ -2120,7 +2120,7 @@ impl Type {\n \n         fn walk_type(db: &dyn HirDatabase, type_: &Type, cb: &mut impl FnMut(Type)) {\n             let ty = type_.ty.strip_references();\n-            match ty.interned(&Interner) {\n+            match ty.kind(&Interner) {\n                 TyKind::Adt(..) => {\n                     cb(type_.derived(ty.clone()));\n                 }"}, {"sha": "c859f94912ba09081628773488daa01981774a54", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -131,7 +131,7 @@ fn deref_by_trait(\n             // new variables in that case\n \n             for i in 1..vars.0.binders.len(&Interner) {\n-                if vars.0.value.at(&Interner, i - 1).assert_ty_ref(&Interner).interned(&Interner)\n+                if vars.0.value.at(&Interner, i - 1).assert_ty_ref(&Interner).kind(&Interner)\n                     != &TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n                 {\n                     warn!(\"complex solution for derefing {:?}: {:?}, ignoring\", ty.goal, solution);"}, {"sha": "ad1259b345df089ae80a78d9b2fc48bf2494709c", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -378,7 +378,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             _ => return,\n         };\n \n-        let (params, required) = match mismatch.expected.interned(&Interner) {\n+        let (params, required) = match mismatch.expected.kind(&Interner) {\n             TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ref parameters)\n                 if *enum_id == core_result_enum =>\n             {"}, {"sha": "34291578aa07d158ed5549c420620886fbffe8c2", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -626,7 +626,7 @@ pub(super) fn is_useful(\n     // - enum with no variants\n     // - `!` type\n     // In those cases, no match arm is useful.\n-    match cx.infer[cx.match_expr].strip_references().interned(&Interner) {\n+    match cx.infer[cx.match_expr].strip_references().kind(&Interner) {\n         TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ..) => {\n             if cx.db.enum_data(*enum_id).variants.is_empty() {\n                 return Ok(Usefulness::NotUseful);"}, {"sha": "a71eebc6fa4a8395f5ea504781b7e1c8f7ebaf9d", "filename": "crates/hir_ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -110,7 +110,7 @@ fn walk_unsafe(\n             }\n         }\n         Expr::UnaryOp { expr, op: UnaryOp::Deref } => {\n-            if let TyKind::Raw(..) = &infer[*expr].interned(&Interner) {\n+            if let TyKind::Raw(..) = &infer[*expr].kind(&Interner) {\n                 unsafe_exprs.push(UnsafeExpr { expr: current, inside_unsafe_block });\n             }\n         }"}, {"sha": "97f1092c6fadc59097cc0c1803f20bbe138cd805", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -292,7 +292,7 @@ impl HirDisplay for Ty {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n \n-        match self.interned(&Interner) {\n+        match self.kind(&Interner) {\n             TyKind::Never => write!(f, \"!\")?,\n             TyKind::Str => write!(f, \"str\")?,\n             TyKind::Scalar(Scalar::Bool) => write!(f, \"bool\")?,\n@@ -314,7 +314,7 @@ impl HirDisplay for Ty {\n                 let ty_display =\n                     t.into_displayable(f.db, f.max_size, f.omit_verbose_types, f.display_target);\n \n-                if matches!(self.interned(&Interner), TyKind::Raw(..)) {\n+                if matches!(self.kind(&Interner), TyKind::Raw(..)) {\n                     write!(\n                         f,\n                         \"*{}\",\n@@ -336,7 +336,7 @@ impl HirDisplay for Ty {\n \n                 // FIXME: all this just to decide whether to use parentheses...\n                 let datas;\n-                let predicates: Vec<_> = match t.interned(&Interner) {\n+                let predicates: Vec<_> = match t.kind(&Interner) {\n                     TyKind::Dyn(dyn_ty) if dyn_ty.bounds.skip_binders().interned().len() > 1 => {\n                         dyn_ty.bounds.skip_binders().interned().iter().cloned().collect()\n                     }\n@@ -473,7 +473,7 @@ impl HirDisplay for Ty {\n                                 let mut default_from = 0;\n                                 for (i, parameter) in parameters.iter(&Interner).enumerate() {\n                                     match (\n-                                        parameter.assert_ty_ref(&Interner).interned(&Interner),\n+                                        parameter.assert_ty_ref(&Interner).kind(&Interner),\n                                         default_parameters.get(i),\n                                     ) {\n                                         (&TyKind::Unknown, _) | (_, None) => {"}, {"sha": "b871594bdbe12bb7f62252b47e6385b8904f0083", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -325,7 +325,7 @@ impl<'a> InferenceContext<'a> {\n \n     /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n-        match ty.interned(&Interner) {\n+        match ty.kind(&Interner) {\n             TyKind::Unknown => self.table.new_type_var(),\n             _ => ty,\n         }\n@@ -438,7 +438,7 @@ impl<'a> InferenceContext<'a> {\n     /// to do it as well.\n     fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n         let ty = self.resolve_ty_as_possible(ty);\n-        ty.fold(&mut |ty| match ty.interned(&Interner) {\n+        ty.fold(&mut |ty| match ty.kind(&Interner) {\n             TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n                 self.normalize_projection_ty(proj_ty.clone())\n             }"}, {"sha": "d887e21a2efd9da4d884a3d5520e89b9250605d5", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -36,7 +36,7 @@ impl<'a> InferenceContext<'a> {\n             ty1.clone()\n         } else {\n             if let (TyKind::FnDef(..), TyKind::FnDef(..)) =\n-                (ty1.interned(&Interner), ty2.interned(&Interner))\n+                (ty1.kind(&Interner), ty2.kind(&Interner))\n             {\n                 cov_mark::hit!(coerce_fn_reification);\n                 // Special case: two function types. Try to coerce both to\n@@ -55,7 +55,7 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn coerce_inner(&mut self, mut from_ty: Ty, to_ty: &Ty) -> bool {\n-        match (from_ty.interned(&Interner), to_ty.interned(&Interner)) {\n+        match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n             // Never type will make type variable to fallback to Never Type instead of Unknown.\n             (TyKind::Never, TyKind::InferenceVar(tv, TyVariableKind::General)) => {\n                 self.table.type_variable_table.set_diverging(*tv, true);\n@@ -73,7 +73,7 @@ impl<'a> InferenceContext<'a> {\n         }\n \n         // Pointer weakening and function to pointer\n-        match (from_ty.interned_mut(), to_ty.interned(&Interner)) {\n+        match (from_ty.interned_mut(), to_ty.kind(&Interner)) {\n             // `*mut T` -> `*const T`\n             // `&mut T` -> `&T`\n             (TyKind::Raw(m1, ..), TyKind::Raw(m2 @ Mutability::Not, ..))\n@@ -111,7 +111,7 @@ impl<'a> InferenceContext<'a> {\n         }\n \n         // Auto Deref if cannot coerce\n-        match (from_ty.interned(&Interner), to_ty.interned(&Interner)) {\n+        match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n             // FIXME: DerefMut\n             (TyKind::Ref(_, st1), TyKind::Ref(_, st2)) => self.unify_autoderef_behind_ref(st1, st2),\n "}, {"sha": "dd3914ec3f7d4364574474e55ab1659184c47581", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -455,7 +455,7 @@ impl<'a> InferenceContext<'a> {\n                             })\n                             .unwrap_or(true)\n                     };\n-                    match canonicalized.decanonicalize_ty(derefed_ty.value).interned(&Interner) {\n+                    match canonicalized.decanonicalize_ty(derefed_ty.value).kind(&Interner) {\n                         TyKind::Tuple(_, substs) => name.as_tuple_index().and_then(|idx| {\n                             substs\n                                 .interned(&Interner)\n@@ -577,7 +577,7 @@ impl<'a> InferenceContext<'a> {\n                         None => self.err_ty(),\n                     },\n                     UnaryOp::Neg => {\n-                        match inner_ty.interned(&Interner) {\n+                        match inner_ty.kind(&Interner) {\n                             // Fast path for builtins\n                             TyKind::Scalar(Scalar::Int(_))\n                             | TyKind::Scalar(Scalar::Uint(_))\n@@ -590,7 +590,7 @@ impl<'a> InferenceContext<'a> {\n                         }\n                     }\n                     UnaryOp::Not => {\n-                        match inner_ty.interned(&Interner) {\n+                        match inner_ty.kind(&Interner) {\n                             // Fast path for builtins\n                             TyKind::Scalar(Scalar::Bool)\n                             | TyKind::Scalar(Scalar::Int(_))\n@@ -696,7 +696,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n             Expr::Tuple { exprs } => {\n-                let mut tys = match expected.ty.interned(&Interner) {\n+                let mut tys = match expected.ty.kind(&Interner) {\n                     TyKind::Tuple(_, substs) => substs\n                         .iter(&Interner)\n                         .map(|a| a.assert_ty_ref(&Interner).clone())\n@@ -713,7 +713,7 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::Tuple(tys.len(), Substitution::from_iter(&Interner, tys)).intern(&Interner)\n             }\n             Expr::Array(array) => {\n-                let elem_ty = match expected.ty.interned(&Interner) {\n+                let elem_ty = match expected.ty.kind(&Interner) {\n                     TyKind::Array(st) | TyKind::Slice(st) => st.clone(),\n                     _ => self.table.new_type_var(),\n                 };\n@@ -961,7 +961,7 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn register_obligations_for_call(&mut self, callable_ty: &Ty) {\n-        if let TyKind::FnDef(fn_def, parameters) = callable_ty.interned(&Interner) {\n+        if let TyKind::FnDef(fn_def, parameters) = callable_ty.kind(&Interner) {\n             let def: CallableDefId = from_chalk(self.db, *fn_def);\n             let generic_predicates = self.db.generic_predicates(def.into());\n             for predicate in generic_predicates.iter() {"}, {"sha": "10df8d8cbfd3486b100ace825463051d25a4994b", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -211,7 +211,7 @@ impl<'a> InferenceContext<'a> {\n                 return inner_ty;\n             }\n             Pat::Slice { prefix, slice, suffix } => {\n-                let (container_ty, elem_ty): (fn(_) -> _, _) = match expected.interned(&Interner) {\n+                let (container_ty, elem_ty): (fn(_) -> _, _) = match expected.kind(&Interner) {\n                     TyKind::Array(st) => (TyKind::Array, st.clone()),\n                     TyKind::Slice(st) => (TyKind::Slice, st.clone()),\n                     _ => (TyKind::Slice, self.err_ty()),"}, {"sha": "1ba15f737983dc0791996283264a95f024c073db", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -147,7 +147,7 @@ impl<'a> InferenceContext<'a> {\n                     remaining_segments_for_ty,\n                     true,\n                 );\n-                if let TyKind::Unknown = ty.interned(&Interner) {\n+                if let TyKind::Unknown = ty.kind(&Interner) {\n                     return None;\n                 }\n \n@@ -212,7 +212,7 @@ impl<'a> InferenceContext<'a> {\n         name: &Name,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substitution>)> {\n-        if let TyKind::Unknown = ty.interned(&Interner) {\n+        if let TyKind::Unknown = ty.kind(&Interner) {\n             return None;\n         }\n "}, {"sha": "d2496db3ba4c82e0a812d136bfe06ada05dae79d", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n \n     fn do_canonicalize<T: TypeWalk>(&mut self, t: T, binders: DebruijnIndex) -> T {\n         t.fold_binders(\n-            &mut |ty, binders| match ty.interned(&Interner) {\n+            &mut |ty, binders| match ty.kind(&Interner) {\n                 &TyKind::InferenceVar(var, kind) => {\n                     let inner = var.to_inner();\n                     if self.var_stack.contains(&inner) {\n@@ -304,7 +304,7 @@ impl InferenceTable {\n         let ty1 = self.resolve_ty_shallow(ty1);\n         let ty2 = self.resolve_ty_shallow(ty2);\n         if ty1.equals_ctor(&ty2) {\n-            match (ty1.interned(&Interner), ty2.interned(&Interner)) {\n+            match (ty1.kind(&Interner), ty2.kind(&Interner)) {\n                 (TyKind::Adt(_, substs1), TyKind::Adt(_, substs2))\n                 | (TyKind::FnDef(_, substs1), TyKind::FnDef(_, substs2))\n                 | (\n@@ -329,7 +329,7 @@ impl InferenceTable {\n     }\n \n     pub(super) fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n-        match (ty1.interned(&Interner), ty2.interned(&Interner)) {\n+        match (ty1.kind(&Interner), ty2.kind(&Interner)) {\n             (TyKind::Unknown, _) | (_, TyKind::Unknown) => true,\n \n             (TyKind::Placeholder(p1), TyKind::Placeholder(p2)) if *p1 == *p2 => true,\n@@ -458,7 +458,7 @@ impl InferenceTable {\n             if i > 0 {\n                 cov_mark::hit!(type_var_resolves_to_int_var);\n             }\n-            match ty.interned(&Interner) {\n+            match ty.kind(&Interner) {\n                 TyKind::InferenceVar(tv, _) => {\n                     let inner = tv.to_inner();\n                     match self.var_unification_table.inlined_probe_value(inner).known() {\n@@ -481,7 +481,7 @@ impl InferenceTable {\n     /// be resolved as far as possible, i.e. contain no type variables with\n     /// known type.\n     fn resolve_ty_as_possible_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty.interned(&Interner) {\n+        ty.fold(&mut |ty| match ty.kind(&Interner) {\n             &TyKind::InferenceVar(tv, kind) => {\n                 let inner = tv.to_inner();\n                 if tv_stack.contains(&inner) {\n@@ -508,7 +508,7 @@ impl InferenceTable {\n     /// Resolves the type completely; type variables without known type are\n     /// replaced by TyKind::Unknown.\n     fn resolve_ty_completely_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty.interned(&Interner) {\n+        ty.fold(&mut |ty| match ty.kind(&Interner) {\n             &TyKind::InferenceVar(tv, kind) => {\n                 let inner = tv.to_inner();\n                 if tv_stack.contains(&inner) {"}, {"sha": "4c3d904bf9c43d72380173c2589fbcce3a3ba28a", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -312,7 +312,7 @@ impl TyKind {\n }\n \n impl Ty {\n-    pub fn interned(&self, _interner: &Interner) -> &TyKind {\n+    pub fn kind(&self, _interner: &Interner) -> &TyKind {\n         &self.0\n     }\n \n@@ -846,14 +846,14 @@ impl Ty {\n     }\n \n     pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n-        match self.interned(&Interner) {\n+        match self.kind(&Interner) {\n             TyKind::Ref(mutability, ty) => Some((ty, *mutability)),\n             _ => None,\n         }\n     }\n \n     pub fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)> {\n-        match self.interned(&Interner) {\n+        match self.kind(&Interner) {\n             TyKind::Ref(mutability, ty) => Some((ty, Rawness::Ref, *mutability)),\n             TyKind::Raw(mutability, ty) => Some((ty, Rawness::RawPtr, *mutability)),\n             _ => None,\n@@ -863,29 +863,29 @@ impl Ty {\n     pub fn strip_references(&self) -> &Ty {\n         let mut t: &Ty = self;\n \n-        while let TyKind::Ref(_mutability, ty) = t.interned(&Interner) {\n+        while let TyKind::Ref(_mutability, ty) = t.kind(&Interner) {\n             t = ty;\n         }\n \n         t\n     }\n \n     pub fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)> {\n-        match self.interned(&Interner) {\n+        match self.kind(&Interner) {\n             TyKind::Adt(AdtId(adt), parameters) => Some((*adt, parameters)),\n             _ => None,\n         }\n     }\n \n     pub fn as_tuple(&self) -> Option<&Substitution> {\n-        match self.interned(&Interner) {\n+        match self.kind(&Interner) {\n             TyKind::Tuple(_, substs) => Some(substs),\n             _ => None,\n         }\n     }\n \n     pub fn as_generic_def(&self, db: &dyn HirDatabase) -> Option<GenericDefId> {\n-        match *self.interned(&Interner) {\n+        match *self.kind(&Interner) {\n             TyKind::Adt(AdtId(adt), ..) => Some(adt.into()),\n             TyKind::FnDef(callable, ..) => {\n                 Some(db.lookup_intern_callable_def(callable.into()).into())\n@@ -897,15 +897,15 @@ impl Ty {\n     }\n \n     pub fn is_never(&self) -> bool {\n-        matches!(self.interned(&Interner), TyKind::Never)\n+        matches!(self.kind(&Interner), TyKind::Never)\n     }\n \n     pub fn is_unknown(&self) -> bool {\n-        matches!(self.interned(&Interner), TyKind::Unknown)\n+        matches!(self.kind(&Interner), TyKind::Unknown)\n     }\n \n     pub fn equals_ctor(&self, other: &Ty) -> bool {\n-        match (self.interned(&Interner), other.interned(&Interner)) {\n+        match (self.kind(&Interner), other.kind(&Interner)) {\n             (TyKind::Adt(adt, ..), TyKind::Adt(adt2, ..)) => adt == adt2,\n             (TyKind::Slice(_), TyKind::Slice(_)) | (TyKind::Array(_), TyKind::Array(_)) => true,\n             (TyKind::FnDef(def_id, ..), TyKind::FnDef(def_id2, ..)) => def_id == def_id2,\n@@ -934,7 +934,7 @@ impl Ty {\n \n     /// If this is a `dyn Trait` type, this returns the `Trait` part.\n     fn dyn_trait_ref(&self) -> Option<&TraitRef> {\n-        match self.interned(&Interner) {\n+        match self.kind(&Interner) {\n             TyKind::Dyn(dyn_ty) => {\n                 dyn_ty.bounds.value.interned().get(0).and_then(|b| match b.skip_binders() {\n                     WhereClause::Implemented(trait_ref) => Some(trait_ref),\n@@ -951,15 +951,15 @@ impl Ty {\n     }\n \n     fn builtin_deref(&self) -> Option<Ty> {\n-        match self.interned(&Interner) {\n+        match self.kind(&Interner) {\n             TyKind::Ref(.., ty) => Some(ty.clone()),\n             TyKind::Raw(.., ty) => Some(ty.clone()),\n             _ => None,\n         }\n     }\n \n     pub fn callable_def(&self, db: &dyn HirDatabase) -> Option<CallableDefId> {\n-        match self.interned(&Interner) {\n+        match self.kind(&Interner) {\n             &TyKind::FnDef(def, ..) => Some(db.lookup_intern_callable_def(def.into())),\n             _ => None,\n         }\n@@ -974,7 +974,7 @@ impl Ty {\n     }\n \n     pub fn callable_sig(&self, db: &dyn HirDatabase) -> Option<CallableSig> {\n-        match self.interned(&Interner) {\n+        match self.kind(&Interner) {\n             TyKind::Function(fn_ptr) => Some(CallableSig::from_fn_ptr(fn_ptr)),\n             TyKind::FnDef(def, parameters) => {\n                 let callable_def = db.lookup_intern_callable_def((*def).into());\n@@ -992,7 +992,7 @@ impl Ty {\n     /// Returns the type parameters of this type if it has some (i.e. is an ADT\n     /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n     pub fn substs(&self) -> Option<&Substitution> {\n-        match self.interned(&Interner) {\n+        match self.kind(&Interner) {\n             TyKind::Adt(_, substs)\n             | TyKind::FnDef(_, substs)\n             | TyKind::Function(FnPointer { substs, .. })\n@@ -1018,7 +1018,7 @@ impl Ty {\n     }\n \n     pub fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<QuantifiedWhereClause>> {\n-        match self.interned(&Interner) {\n+        match self.kind(&Interner) {\n             TyKind::OpaqueType(opaque_ty_id, ..) => {\n                 match db.lookup_intern_impl_trait_id((*opaque_ty_id).into()) {\n                     ImplTraitId::AsyncBlockTypeImplTrait(def, _expr) => {\n@@ -1093,7 +1093,7 @@ impl Ty {\n     }\n \n     pub fn associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<TraitId> {\n-        match self.interned(&Interner) {\n+        match self.kind(&Interner) {\n             TyKind::AssociatedType(id, ..) => {\n                 match from_assoc_type_id(*id).lookup(db.upcast()).container {\n                     AssocContainerId::TraitId(trait_id) => Some(trait_id),\n@@ -1201,7 +1201,7 @@ pub trait TypeWalk {\n         Self: Sized,\n     {\n         self.fold_binders(\n-            &mut |ty, binders| match ty.interned(&Interner) {\n+            &mut |ty, binders| match ty.kind(&Interner) {\n                 TyKind::BoundVar(bound) if bound.debruijn >= binders => {\n                     TyKind::BoundVar(bound.shifted_in_from(n)).intern(&Interner)\n                 }\n@@ -1217,7 +1217,7 @@ pub trait TypeWalk {\n         Self: Sized + std::fmt::Debug,\n     {\n         self.fold_binders(\n-            &mut |ty, binders| match ty.interned(&Interner) {\n+            &mut |ty, binders| match ty.kind(&Interner) {\n                 TyKind::BoundVar(bound) if bound.debruijn >= binders => {\n                     TyKind::BoundVar(bound.shifted_out_to(n).unwrap_or(bound.clone()))\n                         .intern(&Interner)\n@@ -1231,7 +1231,7 @@ pub trait TypeWalk {\n \n impl TypeWalk for Ty {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self.interned(&Interner) {\n+        match self.kind(&Interner) {\n             TyKind::Alias(AliasTy::Projection(p_ty)) => {\n                 for t in p_ty.substitution.iter(&Interner) {\n                     t.walk(f);"}, {"sha": "338851fa81dca8e18e59587776a192e7653c7aaa", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -47,7 +47,7 @@ impl TyFingerprint {\n     /// have impls: if we have some `struct S`, we can have an `impl S`, but not\n     /// `impl &S`. Hence, this will return `None` for reference types and such.\n     pub fn for_impl(ty: &Ty) -> Option<TyFingerprint> {\n-        let fp = match *ty.interned(&Interner) {\n+        let fp = match *ty.kind(&Interner) {\n             TyKind::Str => TyFingerprint::Str,\n             TyKind::Never => TyFingerprint::Never,\n             TyKind::Slice(..) => TyFingerprint::Slice,\n@@ -243,7 +243,7 @@ impl Ty {\n \n         let mod_to_crate_ids = |module: ModuleId| Some(std::iter::once(module.krate()).collect());\n \n-        let lang_item_targets = match self.interned(&Interner) {\n+        let lang_item_targets = match self.kind(&Interner) {\n             TyKind::Adt(AdtId(def_id), _) => {\n                 return mod_to_crate_ids(def_id.module(db.upcast()));\n             }\n@@ -563,7 +563,7 @@ fn iterate_trait_method_candidates(\n     // if ty is `dyn Trait`, the trait doesn't need to be in scope\n     let inherent_trait =\n         self_ty.value.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n-    let env_traits = if let TyKind::Placeholder(_) = self_ty.value.interned(&Interner) {\n+    let env_traits = if let TyKind::Placeholder(_) = self_ty.value.kind(&Interner) {\n         // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n         env.traits_in_scope_from_clauses(&self_ty.value)\n             .flat_map(|t| all_super_traits(db.upcast(), t))\n@@ -741,7 +741,7 @@ pub(crate) fn inherent_impl_substs(\n fn fallback_bound_vars(s: Substitution, num_vars_to_keep: usize) -> Substitution {\n     s.fold_binders(\n         &mut |ty, binders| {\n-            if let TyKind::BoundVar(bound) = ty.interned(&Interner) {\n+            if let TyKind::BoundVar(bound) = ty.kind(&Interner) {\n                 if bound.index >= num_vars_to_keep && bound.debruijn >= binders {\n                     TyKind::Unknown.intern(&Interner)\n                 } else {\n@@ -839,9 +839,7 @@ fn autoderef_method_receiver(\n ) -> Vec<Canonical<Ty>> {\n     let mut deref_chain: Vec<_> = autoderef::autoderef(db, Some(krate), ty).collect();\n     // As a last step, we can do array unsizing (that's the only unsizing that rustc does for method receivers!)\n-    if let Some(TyKind::Array(parameters)) =\n-        deref_chain.last().map(|ty| ty.value.interned(&Interner))\n-    {\n+    if let Some(TyKind::Array(parameters)) = deref_chain.last().map(|ty| ty.value.kind(&Interner)) {\n         let kinds = deref_chain.last().unwrap().binders.clone();\n         let unsized_ty = TyKind::Slice(parameters.clone()).intern(&Interner);\n         deref_chain.push(Canonical { value: unsized_ty, binders: kinds })"}, {"sha": "8533e1ed87e88c33039cd35ffdfaeb74fa8de16c", "filename": "crates/hir_ty/src/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fop.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -9,7 +9,7 @@ pub(super) fn binary_op_return_ty(op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Ty {\n         BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n         BinaryOp::Assignment { .. } => Ty::unit(),\n         BinaryOp::ArithOp(ArithOp::Shl) | BinaryOp::ArithOp(ArithOp::Shr) => {\n-            match lhs_ty.interned(&Interner) {\n+            match lhs_ty.kind(&Interner) {\n                 TyKind::Scalar(Scalar::Int(_))\n                 | TyKind::Scalar(Scalar::Uint(_))\n                 | TyKind::Scalar(Scalar::Float(_)) => lhs_ty,\n@@ -18,7 +18,7 @@ pub(super) fn binary_op_return_ty(op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Ty {\n                 _ => TyKind::Unknown.intern(&Interner),\n             }\n         }\n-        BinaryOp::ArithOp(_) => match rhs_ty.interned(&Interner) {\n+        BinaryOp::ArithOp(_) => match rhs_ty.kind(&Interner) {\n             TyKind::Scalar(Scalar::Int(_))\n             | TyKind::Scalar(Scalar::Uint(_))\n             | TyKind::Scalar(Scalar::Float(_)) => rhs_ty,\n@@ -33,7 +33,7 @@ pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n     match op {\n         BinaryOp::LogicOp(..) => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n         BinaryOp::Assignment { op: None } => lhs_ty,\n-        BinaryOp::CmpOp(CmpOp::Eq { .. }) => match lhs_ty.interned(&Interner) {\n+        BinaryOp::CmpOp(CmpOp::Eq { .. }) => match lhs_ty.kind(&Interner) {\n             TyKind::Scalar(_) | TyKind::Str => lhs_ty,\n             TyKind::InferenceVar(_, TyVariableKind::Integer)\n             | TyKind::InferenceVar(_, TyVariableKind::Float) => lhs_ty,\n@@ -44,7 +44,7 @@ pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n         }\n         BinaryOp::CmpOp(CmpOp::Ord { .. })\n         | BinaryOp::Assignment { op: Some(_) }\n-        | BinaryOp::ArithOp(_) => match lhs_ty.interned(&Interner) {\n+        | BinaryOp::ArithOp(_) => match lhs_ty.kind(&Interner) {\n             TyKind::Scalar(Scalar::Int(_))\n             | TyKind::Scalar(Scalar::Uint(_))\n             | TyKind::Scalar(Scalar::Float(_)) => lhs_ty,"}, {"sha": "e5e8cff33021e696e70354c91afa799dbd0de18c", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -138,7 +138,7 @@ pub(crate) fn trait_solve_query(\n         ..\n     })) = &goal.value.goal\n     {\n-        if let TyKind::BoundVar(_) = projection_ty.self_type_parameter().interned(&Interner) {\n+        if let TyKind::BoundVar(_) = projection_ty.self_type_parameter().kind(&Interner) {\n             // Hack: don't ask Chalk to normalize with an unknown self type, it'll say that's impossible\n             return Some(Solution::Ambig(Guidance::Unknown));\n         }"}, {"sha": "fbac51b055d46711efe8d941fbc87138bfd3bea1", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c551604b5a0b74a43f5efe567bcbd979daa2f3cc/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=c551604b5a0b74a43f5efe567bcbd979daa2f3cc", "patch": "@@ -92,7 +92,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             ty: &Ty,\n             binders: &CanonicalVarKinds<Interner>,\n         ) -> Option<chalk_ir::TyVariableKind> {\n-            if let TyKind::BoundVar(bv) = ty.interned(&Interner) {\n+            if let TyKind::BoundVar(bv) = ty.kind(&Interner) {\n                 let binders = binders.as_slice(&Interner);\n                 if bv.debruijn == DebruijnIndex::INNERMOST {\n                     if let chalk_ir::VariableKind::Ty(tk) = binders[bv.index].kind {"}]}