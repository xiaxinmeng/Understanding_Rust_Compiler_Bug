{"sha": "385a233f1836191837e1a7e575425cf0ce1c9843", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NWEyMzNmMTgzNjE5MTgzN2UxYTdlNTc1NDI1Y2YwY2UxYzk4NDM=", "commit": {"author": {"name": "asquared31415", "email": "34665709+asquared31415@users.noreply.github.com", "date": "2021-08-15T01:38:37Z"}, "committer": {"name": "asquared31415", "email": "34665709+asquared31415@users.noreply.github.com", "date": "2021-08-23T14:15:25Z"}, "message": "Detect incorrect number of lang item generics", "tree": {"sha": "80b379ac05e4c9a2df78beae94fe8f1c986667aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80b379ac05e4c9a2df78beae94fe8f1c986667aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/385a233f1836191837e1a7e575425cf0ce1c9843", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/385a233f1836191837e1a7e575425cf0ce1c9843", "html_url": "https://github.com/rust-lang/rust/commit/385a233f1836191837e1a7e575425cf0ce1c9843", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/385a233f1836191837e1a7e575425cf0ce1c9843/comments", "author": {"login": "asquared31415", "id": 34665709, "node_id": "MDQ6VXNlcjM0NjY1NzA5", "avatar_url": "https://avatars.githubusercontent.com/u/34665709?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asquared31415", "html_url": "https://github.com/asquared31415", "followers_url": "https://api.github.com/users/asquared31415/followers", "following_url": "https://api.github.com/users/asquared31415/following{/other_user}", "gists_url": "https://api.github.com/users/asquared31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/asquared31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asquared31415/subscriptions", "organizations_url": "https://api.github.com/users/asquared31415/orgs", "repos_url": "https://api.github.com/users/asquared31415/repos", "events_url": "https://api.github.com/users/asquared31415/events{/privacy}", "received_events_url": "https://api.github.com/users/asquared31415/received_events", "type": "User", "site_admin": false}, "committer": {"login": "asquared31415", "id": 34665709, "node_id": "MDQ6VXNlcjM0NjY1NzA5", "avatar_url": "https://avatars.githubusercontent.com/u/34665709?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asquared31415", "html_url": "https://github.com/asquared31415", "followers_url": "https://api.github.com/users/asquared31415/followers", "following_url": "https://api.github.com/users/asquared31415/following{/other_user}", "gists_url": "https://api.github.com/users/asquared31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/asquared31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asquared31415/subscriptions", "organizations_url": "https://api.github.com/users/asquared31415/orgs", "repos_url": "https://api.github.com/users/asquared31415/repos", "events_url": "https://api.github.com/users/asquared31415/events{/privacy}", "received_events_url": "https://api.github.com/users/asquared31415/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "558553272d5f80ca6484ed3de961fe4f1a9d411d", "url": "https://api.github.com/repos/rust-lang/rust/commits/558553272d5f80ca6484ed3de961fe4f1a9d411d", "html_url": "https://github.com/rust-lang/rust/commit/558553272d5f80ca6484ed3de961fe4f1a9d411d"}], "stats": {"total": 649, "additions": 330, "deletions": 319}, "files": [{"sha": "ef17b8b4c75c980dbc5cb93a3247bbd9d1d3cc9f", "filename": "compiler/rustc_error_codes/src/error_codes/E0152.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385a233f1836191837e1a7e575425cf0ce1c9843/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0152.md", "raw_url": "https://github.com/rust-lang/rust/raw/385a233f1836191837e1a7e575425cf0ce1c9843/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0152.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0152.md?ref=385a233f1836191837e1a7e575425cf0ce1c9843", "patch": "@@ -6,7 +6,7 @@ Erroneous code example:\n #![feature(lang_items)]\n \n #[lang = \"owned_box\"]\n-struct Foo; // error: duplicate lang item found: `owned_box`\n+struct Foo<T>(T); // error: duplicate lang item found: `owned_box`\n ```\n \n Lang items are already implemented in the standard library. Unless you are"}, {"sha": "b85ed0cb4bbe59ecc1b2e707342cea7aefbc4eb2", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 163, "deletions": 151, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/385a233f1836191837e1a7e575425cf0ce1c9843/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385a233f1836191837e1a7e575425cf0ce1c9843/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=385a233f1836191837e1a7e575425cf0ce1c9843", "patch": "@@ -38,7 +38,7 @@ macro_rules! expand_group {\n // So you probably just want to nip down to the end.\n macro_rules! language_item_table {\n     (\n-        $( $(#[$attr:meta])* $variant:ident $($group:expr)?, $module:ident :: $name:ident, $method:ident, $target:expr; )*\n+        $( $(#[$attr:meta])* $variant:ident $($group:expr)?, $module:ident :: $name:ident, $method:ident, $target:expr, $generics:expr; )*\n     ) => {\n \n         enum_from_u32! {\n@@ -72,6 +72,12 @@ macro_rules! language_item_table {\n                     $( LangItem::$variant => expand_group!($($group)*), )*\n                 }\n             }\n+\n+            pub fn required_generics(&self) -> GenericRequirement {\n+                match self {\n+                    $( LangItem::$variant => $generics, )*\n+                }\n+            }\n         }\n \n         /// All of the language items, defined or not.\n@@ -165,108 +171,108 @@ where\n }\n \n language_item_table! {\n-//  Variant name,            Name,                     Method name,                Target;\n-    Bool,                    sym::bool,                bool_impl,                  Target::Impl;\n-    Char,                    sym::char,                char_impl,                  Target::Impl;\n-    Str,                     sym::str,                 str_impl,                   Target::Impl;\n-    Array,                   sym::array,               array_impl,                 Target::Impl;\n-    Slice,                   sym::slice,               slice_impl,                 Target::Impl;\n-    SliceU8,                 sym::slice_u8,            slice_u8_impl,              Target::Impl;\n-    StrAlloc,                sym::str_alloc,           str_alloc_impl,             Target::Impl;\n-    SliceAlloc,              sym::slice_alloc,         slice_alloc_impl,           Target::Impl;\n-    SliceU8Alloc,            sym::slice_u8_alloc,      slice_u8_alloc_impl,        Target::Impl;\n-    ConstPtr,                sym::const_ptr,           const_ptr_impl,             Target::Impl;\n-    MutPtr,                  sym::mut_ptr,             mut_ptr_impl,               Target::Impl;\n-    ConstSlicePtr,           sym::const_slice_ptr,     const_slice_ptr_impl,       Target::Impl;\n-    MutSlicePtr,             sym::mut_slice_ptr,       mut_slice_ptr_impl,         Target::Impl;\n-    I8,                      sym::i8,                  i8_impl,                    Target::Impl;\n-    I16,                     sym::i16,                 i16_impl,                   Target::Impl;\n-    I32,                     sym::i32,                 i32_impl,                   Target::Impl;\n-    I64,                     sym::i64,                 i64_impl,                   Target::Impl;\n-    I128,                    sym::i128,                i128_impl,                  Target::Impl;\n-    Isize,                   sym::isize,               isize_impl,                 Target::Impl;\n-    U8,                      sym::u8,                  u8_impl,                    Target::Impl;\n-    U16,                     sym::u16,                 u16_impl,                   Target::Impl;\n-    U32,                     sym::u32,                 u32_impl,                   Target::Impl;\n-    U64,                     sym::u64,                 u64_impl,                   Target::Impl;\n-    U128,                    sym::u128,                u128_impl,                  Target::Impl;\n-    Usize,                   sym::usize,               usize_impl,                 Target::Impl;\n-    F32,                     sym::f32,                 f32_impl,                   Target::Impl;\n-    F64,                     sym::f64,                 f64_impl,                   Target::Impl;\n-    F32Runtime,              sym::f32_runtime,         f32_runtime_impl,           Target::Impl;\n-    F64Runtime,              sym::f64_runtime,         f64_runtime_impl,           Target::Impl;\n-\n-    Sized,                   sym::sized,               sized_trait,                Target::Trait;\n-    Unsize,                  sym::unsize,              unsize_trait,               Target::Trait;\n+//  Variant name,            Name,                     Method name,                Target                  Generic requirements;\n+    Bool,                    sym::bool,                bool_impl,                  Target::Impl,           GenericRequirement::None;\n+    Char,                    sym::char,                char_impl,                  Target::Impl,           GenericRequirement::None;\n+    Str,                     sym::str,                 str_impl,                   Target::Impl,           GenericRequirement::None;\n+    Array,                   sym::array,               array_impl,                 Target::Impl,           GenericRequirement::None;\n+    Slice,                   sym::slice,               slice_impl,                 Target::Impl,           GenericRequirement::None;\n+    SliceU8,                 sym::slice_u8,            slice_u8_impl,              Target::Impl,           GenericRequirement::None;\n+    StrAlloc,                sym::str_alloc,           str_alloc_impl,             Target::Impl,           GenericRequirement::None;\n+    SliceAlloc,              sym::slice_alloc,         slice_alloc_impl,           Target::Impl,           GenericRequirement::None;\n+    SliceU8Alloc,            sym::slice_u8_alloc,      slice_u8_alloc_impl,        Target::Impl,           GenericRequirement::None;\n+    ConstPtr,                sym::const_ptr,           const_ptr_impl,             Target::Impl,           GenericRequirement::None;\n+    MutPtr,                  sym::mut_ptr,             mut_ptr_impl,               Target::Impl,           GenericRequirement::None;\n+    ConstSlicePtr,           sym::const_slice_ptr,     const_slice_ptr_impl,       Target::Impl,           GenericRequirement::None;\n+    MutSlicePtr,             sym::mut_slice_ptr,       mut_slice_ptr_impl,         Target::Impl,           GenericRequirement::None;\n+    I8,                      sym::i8,                  i8_impl,                    Target::Impl,           GenericRequirement::None;\n+    I16,                     sym::i16,                 i16_impl,                   Target::Impl,           GenericRequirement::None;\n+    I32,                     sym::i32,                 i32_impl,                   Target::Impl,           GenericRequirement::None;\n+    I64,                     sym::i64,                 i64_impl,                   Target::Impl,           GenericRequirement::None;\n+    I128,                    sym::i128,                i128_impl,                  Target::Impl,           GenericRequirement::None;\n+    Isize,                   sym::isize,               isize_impl,                 Target::Impl,           GenericRequirement::None;\n+    U8,                      sym::u8,                  u8_impl,                    Target::Impl,           GenericRequirement::None;\n+    U16,                     sym::u16,                 u16_impl,                   Target::Impl,           GenericRequirement::None;\n+    U32,                     sym::u32,                 u32_impl,                   Target::Impl,           GenericRequirement::None;\n+    U64,                     sym::u64,                 u64_impl,                   Target::Impl,           GenericRequirement::None;\n+    U128,                    sym::u128,                u128_impl,                  Target::Impl,           GenericRequirement::None;\n+    Usize,                   sym::usize,               usize_impl,                 Target::Impl,           GenericRequirement::None;\n+    F32,                     sym::f32,                 f32_impl,                   Target::Impl,           GenericRequirement::None;\n+    F64,                     sym::f64,                 f64_impl,                   Target::Impl,           GenericRequirement::None;\n+    F32Runtime,              sym::f32_runtime,         f32_runtime_impl,           Target::Impl,           GenericRequirement::None;\n+    F64Runtime,              sym::f64_runtime,         f64_runtime_impl,           Target::Impl,           GenericRequirement::None;\n+\n+    Sized,                   sym::sized,               sized_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+    Unsize,                  sym::unsize,              unsize_trait,               Target::Trait,          GenericRequirement::Minimum(1);\n     /// Trait injected by `#[derive(PartialEq)]`, (i.e. \"Partial EQ\").\n-    StructuralPeq,           sym::structural_peq,      structural_peq_trait,       Target::Trait;\n+    StructuralPeq,           sym::structural_peq,      structural_peq_trait,       Target::Trait,          GenericRequirement::None;\n     /// Trait injected by `#[derive(Eq)]`, (i.e. \"Total EQ\"; no, I will not apologize).\n-    StructuralTeq,           sym::structural_teq,      structural_teq_trait,       Target::Trait;\n-    Copy,                    sym::copy,                copy_trait,                 Target::Trait;\n-    Clone,                   sym::clone,               clone_trait,                Target::Trait;\n-    Sync,                    sym::sync,                sync_trait,                 Target::Trait;\n-    DiscriminantKind,        sym::discriminant_kind,   discriminant_kind_trait,    Target::Trait;\n+    StructuralTeq,           sym::structural_teq,      structural_teq_trait,       Target::Trait,          GenericRequirement::None;\n+    Copy,                    sym::copy,                copy_trait,                 Target::Trait,          GenericRequirement::Exact(0);\n+    Clone,                   sym::clone,               clone_trait,                Target::Trait,          GenericRequirement::None;\n+    Sync,                    sym::sync,                sync_trait,                 Target::Trait,          GenericRequirement::Exact(0);\n+    DiscriminantKind,        sym::discriminant_kind,   discriminant_kind_trait,    Target::Trait,          GenericRequirement::None;\n     /// The associated item of the [`DiscriminantKind`] trait.\n-    Discriminant,            sym::discriminant_type,   discriminant_type,          Target::AssocTy;\n-\n-    PointeeTrait,            sym::pointee_trait,       pointee_trait,              Target::Trait;\n-    Metadata,                sym::metadata_type,       metadata_type,              Target::AssocTy;\n-    DynMetadata,             sym::dyn_metadata,        dyn_metadata,               Target::Struct;\n-\n-    Freeze,                  sym::freeze,              freeze_trait,               Target::Trait;\n-\n-    Drop,                    sym::drop,                drop_trait,                 Target::Trait;\n-\n-    CoerceUnsized,           sym::coerce_unsized,      coerce_unsized_trait,       Target::Trait;\n-    DispatchFromDyn,         sym::dispatch_from_dyn,   dispatch_from_dyn_trait,    Target::Trait;\n-\n-    Add(Op),                 sym::add,                 add_trait,                  Target::Trait;\n-    Sub(Op),                 sym::sub,                 sub_trait,                  Target::Trait;\n-    Mul(Op),                 sym::mul,                 mul_trait,                  Target::Trait;\n-    Div(Op),                 sym::div,                 div_trait,                  Target::Trait;\n-    Rem(Op),                 sym::rem,                 rem_trait,                  Target::Trait;\n-    Neg(Op),                 sym::neg,                 neg_trait,                  Target::Trait;\n-    Not(Op),                 sym::not,                 not_trait,                  Target::Trait;\n-    BitXor(Op),              sym::bitxor,              bitxor_trait,               Target::Trait;\n-    BitAnd(Op),              sym::bitand,              bitand_trait,               Target::Trait;\n-    BitOr(Op),               sym::bitor,               bitor_trait,                Target::Trait;\n-    Shl(Op),                 sym::shl,                 shl_trait,                  Target::Trait;\n-    Shr(Op),                 sym::shr,                 shr_trait,                  Target::Trait;\n-    AddAssign(Op),           sym::add_assign,          add_assign_trait,           Target::Trait;\n-    SubAssign(Op),           sym::sub_assign,          sub_assign_trait,           Target::Trait;\n-    MulAssign(Op),           sym::mul_assign,          mul_assign_trait,           Target::Trait;\n-    DivAssign(Op),           sym::div_assign,          div_assign_trait,           Target::Trait;\n-    RemAssign(Op),           sym::rem_assign,          rem_assign_trait,           Target::Trait;\n-    BitXorAssign(Op),        sym::bitxor_assign,       bitxor_assign_trait,        Target::Trait;\n-    BitAndAssign(Op),        sym::bitand_assign,       bitand_assign_trait,        Target::Trait;\n-    BitOrAssign(Op),         sym::bitor_assign,        bitor_assign_trait,         Target::Trait;\n-    ShlAssign(Op),           sym::shl_assign,          shl_assign_trait,           Target::Trait;\n-    ShrAssign(Op),           sym::shr_assign,          shr_assign_trait,           Target::Trait;\n-    Index(Op),               sym::index,               index_trait,                Target::Trait;\n-    IndexMut(Op),            sym::index_mut,           index_mut_trait,            Target::Trait;\n-\n-    UnsafeCell,              sym::unsafe_cell,         unsafe_cell_type,           Target::Struct;\n-    VaList,                  sym::va_list,             va_list,                    Target::Struct;\n-\n-    Deref,                   sym::deref,               deref_trait,                Target::Trait;\n-    DerefMut,                sym::deref_mut,           deref_mut_trait,            Target::Trait;\n-    DerefTarget,             sym::deref_target,        deref_target,               Target::AssocTy;\n-    Receiver,                sym::receiver,            receiver_trait,             Target::Trait;\n-\n-    Fn,                      kw::Fn,                   fn_trait,                   Target::Trait;\n-    FnMut,                   sym::fn_mut,              fn_mut_trait,               Target::Trait;\n-    FnOnce,                  sym::fn_once,             fn_once_trait,              Target::Trait;\n-\n-    FnOnceOutput,            sym::fn_once_output,      fn_once_output,             Target::AssocTy;\n-\n-    Future,                  sym::future_trait,        future_trait,               Target::Trait;\n-    GeneratorState,          sym::generator_state,     gen_state,                  Target::Enum;\n-    Generator,               sym::generator,           gen_trait,                  Target::Trait;\n-    Unpin,                   sym::unpin,               unpin_trait,                Target::Trait;\n-    Pin,                     sym::pin,                 pin_type,                   Target::Struct;\n-\n-    PartialEq,               sym::eq,                  eq_trait,                   Target::Trait;\n-    PartialOrd,              sym::partial_ord,         partial_ord_trait,          Target::Trait;\n+    Discriminant,            sym::discriminant_type,   discriminant_type,          Target::AssocTy,        GenericRequirement::None;\n+\n+    PointeeTrait,            sym::pointee_trait,       pointee_trait,              Target::Trait,          GenericRequirement::None;\n+    Metadata,                sym::metadata_type,       metadata_type,              Target::AssocTy,        GenericRequirement::None;\n+    DynMetadata,             sym::dyn_metadata,        dyn_metadata,               Target::Struct,         GenericRequirement::None;\n+\n+    Freeze,                  sym::freeze,              freeze_trait,               Target::Trait,          GenericRequirement::Exact(0);\n+\n+    Drop,                    sym::drop,                drop_trait,                 Target::Trait,          GenericRequirement::None;\n+\n+    CoerceUnsized,           sym::coerce_unsized,      coerce_unsized_trait,       Target::Trait,          GenericRequirement::Minimum(1);\n+    DispatchFromDyn,         sym::dispatch_from_dyn,   dispatch_from_dyn_trait,    Target::Trait,          GenericRequirement::Minimum(1);\n+\n+    Add(Op),                 sym::add,                 add_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Sub(Op),                 sym::sub,                 sub_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Mul(Op),                 sym::mul,                 mul_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Div(Op),                 sym::div,                 div_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Rem(Op),                 sym::rem,                 rem_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Neg(Op),                 sym::neg,                 neg_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n+    Not(Op),                 sym::not,                 not_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n+    BitXor(Op),              sym::bitxor,              bitxor_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    BitAnd(Op),              sym::bitand,              bitand_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    BitOr(Op),               sym::bitor,               bitor_trait,                Target::Trait,          GenericRequirement::Exact(1);\n+    Shl(Op),                 sym::shl,                 shl_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Shr(Op),                 sym::shr,                 shr_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    AddAssign(Op),           sym::add_assign,          add_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    SubAssign(Op),           sym::sub_assign,          sub_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    MulAssign(Op),           sym::mul_assign,          mul_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    DivAssign(Op),           sym::div_assign,          div_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    RemAssign(Op),           sym::rem_assign,          rem_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    BitXorAssign(Op),        sym::bitxor_assign,       bitxor_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n+    BitAndAssign(Op),        sym::bitand_assign,       bitand_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n+    BitOrAssign(Op),         sym::bitor_assign,        bitor_assign_trait,         Target::Trait,          GenericRequirement::Exact(1);\n+    ShlAssign(Op),           sym::shl_assign,          shl_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    ShrAssign(Op),           sym::shr_assign,          shr_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    Index(Op),               sym::index,               index_trait,                Target::Trait,          GenericRequirement::Exact(1);\n+    IndexMut(Op),            sym::index_mut,           index_mut_trait,            Target::Trait,          GenericRequirement::Exact(1);\n+\n+    UnsafeCell,              sym::unsafe_cell,         unsafe_cell_type,           Target::Struct,         GenericRequirement::None;\n+    VaList,                  sym::va_list,             va_list,                    Target::Struct,         GenericRequirement::None;\n+\n+    Deref,                   sym::deref,               deref_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+    DerefMut,                sym::deref_mut,           deref_mut_trait,            Target::Trait,          GenericRequirement::Exact(0);\n+    DerefTarget,             sym::deref_target,        deref_target,               Target::AssocTy,        GenericRequirement::None;\n+    Receiver,                sym::receiver,            receiver_trait,             Target::Trait,          GenericRequirement::None;\n+\n+    Fn,                      kw::Fn,                   fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    FnMut,                   sym::fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    FnOnce,                  sym::fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n+\n+    FnOnceOutput,            sym::fn_once_output,      fn_once_output,             Target::AssocTy,        GenericRequirement::None;\n+\n+    Future,                  sym::future_trait,        future_trait,               Target::Trait,          GenericRequirement::Exact(0);\n+    GeneratorState,          sym::generator_state,     gen_state,                  Target::Enum,           GenericRequirement::None;\n+    Generator,               sym::generator,           gen_trait,                  Target::Trait,          GenericRequirement::Minimum(1);\n+    Unpin,                   sym::unpin,               unpin_trait,                Target::Trait,          GenericRequirement::None;\n+    Pin,                     sym::pin,                 pin_type,                   Target::Struct,         GenericRequirement::None;\n+\n+    PartialEq,               sym::eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    PartialOrd,              sym::partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n \n     // A number of panic-related lang items. The `panic` item corresponds to divide-by-zero and\n     // various panic cases with `match`. The `panic_bounds_check` item is for indexing arrays.\n@@ -275,80 +281,86 @@ language_item_table! {\n     // in the sense that a crate is not required to have it defined to use it, but a final product\n     // is required to define it somewhere. Additionally, there are restrictions on crates that use\n     // a weak lang item, but do not have it defined.\n-    Panic,                   sym::panic,               panic_fn,                   Target::Fn;\n-    PanicFmt,                sym::panic_fmt,           panic_fmt,                  Target::Fn;\n-    PanicStr,                sym::panic_str,           panic_str,                  Target::Fn;\n-    ConstPanicFmt,           sym::const_panic_fmt,     const_panic_fmt,            Target::Fn;\n-    PanicBoundsCheck,        sym::panic_bounds_check,  panic_bounds_check_fn,      Target::Fn;\n-    PanicInfo,               sym::panic_info,          panic_info,                 Target::Struct;\n-    PanicLocation,           sym::panic_location,      panic_location,             Target::Struct;\n-    PanicImpl,               sym::panic_impl,          panic_impl,                 Target::Fn;\n+    Panic,                   sym::panic,               panic_fn,                   Target::Fn,             GenericRequirement::None;\n+    PanicFmt,                sym::panic_fmt,           panic_fmt,                  Target::Fn,             GenericRequirement::None;\n+    PanicStr,                sym::panic_str,           panic_str,                  Target::Fn,             GenericRequirement::None;\n+    ConstPanicFmt,           sym::const_panic_fmt,     const_panic_fmt,            Target::Fn,             GenericRequirement::None;\n+    PanicBoundsCheck,        sym::panic_bounds_check,  panic_bounds_check_fn,      Target::Fn,             GenericRequirement::None;\n+    PanicInfo,               sym::panic_info,          panic_info,                 Target::Struct,         GenericRequirement::None;\n+    PanicLocation,           sym::panic_location,      panic_location,             Target::Struct,         GenericRequirement::None;\n+    PanicImpl,               sym::panic_impl,          panic_impl,                 Target::Fn,             GenericRequirement::None;\n     /// libstd panic entry point. Necessary for const eval to be able to catch it\n-    BeginPanic,              sym::begin_panic,         begin_panic_fn,             Target::Fn;\n-    BeginPanicFmt,           sym::begin_panic_fmt,     begin_panic_fmt,            Target::Fn;\n+    BeginPanic,              sym::begin_panic,         begin_panic_fn,             Target::Fn,             GenericRequirement::None;\n+    BeginPanicFmt,           sym::begin_panic_fmt,     begin_panic_fmt,            Target::Fn,             GenericRequirement::None;\n \n-    ExchangeMalloc,          sym::exchange_malloc,     exchange_malloc_fn,         Target::Fn;\n-    BoxFree,                 sym::box_free,            box_free_fn,                Target::Fn;\n-    DropInPlace,             sym::drop_in_place,       drop_in_place_fn,           Target::Fn;\n-    Oom,                     sym::oom,                 oom,                        Target::Fn;\n-    AllocLayout,             sym::alloc_layout,        alloc_layout,               Target::Struct;\n+    ExchangeMalloc,          sym::exchange_malloc,     exchange_malloc_fn,         Target::Fn,             GenericRequirement::None;\n+    BoxFree,                 sym::box_free,            box_free_fn,                Target::Fn,             GenericRequirement::Minimum(1);\n+    DropInPlace,             sym::drop_in_place,       drop_in_place_fn,           Target::Fn,             GenericRequirement::Minimum(1);\n+    Oom,                     sym::oom,                 oom,                        Target::Fn,             GenericRequirement::None;\n+    AllocLayout,             sym::alloc_layout,        alloc_layout,               Target::Struct,         GenericRequirement::None;\n \n-    Start,                   sym::start,               start_fn,                   Target::Fn;\n+    Start,                   sym::start,               start_fn,                   Target::Fn,             GenericRequirement::None;\n \n-    EhPersonality,           sym::eh_personality,      eh_personality,             Target::Fn;\n-    EhCatchTypeinfo,         sym::eh_catch_typeinfo,   eh_catch_typeinfo,          Target::Static;\n+    EhPersonality,           sym::eh_personality,      eh_personality,             Target::Fn,             GenericRequirement::None;\n+    EhCatchTypeinfo,         sym::eh_catch_typeinfo,   eh_catch_typeinfo,          Target::Static,         GenericRequirement::None;\n \n-    OwnedBox,                sym::owned_box,           owned_box,                  Target::Struct;\n+    OwnedBox,                sym::owned_box,           owned_box,                  Target::Struct,         GenericRequirement::Minimum(1);\n \n-    PhantomData,             sym::phantom_data,        phantom_data,               Target::Struct;\n+    PhantomData,             sym::phantom_data,        phantom_data,               Target::Struct,         GenericRequirement::Exact(1);\n \n-    ManuallyDrop,            sym::manually_drop,       manually_drop,              Target::Struct;\n+    ManuallyDrop,            sym::manually_drop,       manually_drop,              Target::Struct,         GenericRequirement::None;\n \n-    MaybeUninit,             sym::maybe_uninit,        maybe_uninit,               Target::Union;\n+    MaybeUninit,             sym::maybe_uninit,        maybe_uninit,               Target::Union,          GenericRequirement::None;\n \n     /// Align offset for stride != 1; must not panic.\n-    AlignOffset,             sym::align_offset,        align_offset_fn,            Target::Fn;\n+    AlignOffset,             sym::align_offset,        align_offset_fn,            Target::Fn,             GenericRequirement::None;\n \n-    Termination,             sym::termination,         termination,                Target::Trait;\n+    Termination,             sym::termination,         termination,                Target::Trait,          GenericRequirement::None;\n \n-    Try,                     sym::Try,                 try_trait,                  Target::Trait;\n+    Try,                     sym::Try,                 try_trait,                  Target::Trait,          GenericRequirement::None;\n \n-    SliceLen,                sym::slice_len_fn,        slice_len_fn,               Target::Method(MethodKind::Inherent);\n+    SliceLen,                sym::slice_len_fn,        slice_len_fn,               Target::Method(MethodKind::Inherent), GenericRequirement::None;\n \n     // Language items from AST lowering\n-    TryTraitFromResidual,    sym::from_residual,       from_residual_fn,           Target::Method(MethodKind::Trait { body: false });\n-    TryTraitFromOutput,      sym::from_output,         from_output_fn,             Target::Method(MethodKind::Trait { body: false });\n-    TryTraitBranch,          sym::branch,              branch_fn,                  Target::Method(MethodKind::Trait { body: false });\n+    TryTraitFromResidual,    sym::from_residual,       from_residual_fn,           Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    TryTraitFromOutput,      sym::from_output,         from_output_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    TryTraitBranch,          sym::branch,              branch_fn,                  Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+\n+    PollReady,               sym::Ready,               poll_ready_variant,         Target::Variant,        GenericRequirement::None;\n+    PollPending,             sym::Pending,             poll_pending_variant,       Target::Variant,        GenericRequirement::None;\n \n-    PollReady,               sym::Ready,               poll_ready_variant,         Target::Variant;\n-    PollPending,             sym::Pending,             poll_pending_variant,       Target::Variant;\n+    FromGenerator,           sym::from_generator,      from_generator_fn,          Target::Fn,             GenericRequirement::None;\n+    GetContext,              sym::get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n \n-    FromGenerator,           sym::from_generator,      from_generator_fn,          Target::Fn;\n-    GetContext,              sym::get_context,         get_context_fn,             Target::Fn;\n+    FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n \n-    FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false });\n+    FromFrom,                sym::from,                from_fn,                    Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n \n-    FromFrom,                sym::from,                from_fn,                    Target::Method(MethodKind::Trait { body: false });\n+    OptionSome,              sym::Some,                option_some_variant,        Target::Variant,        GenericRequirement::None;\n+    OptionNone,              sym::None,                option_none_variant,        Target::Variant,        GenericRequirement::None;\n \n-    OptionSome,              sym::Some,                option_some_variant,        Target::Variant;\n-    OptionNone,              sym::None,                option_none_variant,        Target::Variant;\n+    ResultOk,                sym::Ok,                  result_ok_variant,          Target::Variant,        GenericRequirement::None;\n+    ResultErr,               sym::Err,                 result_err_variant,         Target::Variant,        GenericRequirement::None;\n \n-    ResultOk,                sym::Ok,                  result_ok_variant,          Target::Variant;\n-    ResultErr,               sym::Err,                 result_err_variant,         Target::Variant;\n+    ControlFlowContinue,     sym::Continue,            cf_continue_variant,        Target::Variant,        GenericRequirement::None;\n+    ControlFlowBreak,        sym::Break,               cf_break_variant,           Target::Variant,        GenericRequirement::None;\n \n-    ControlFlowContinue,     sym::Continue,            cf_continue_variant,        Target::Variant;\n-    ControlFlowBreak,        sym::Break,               cf_break_variant,           Target::Variant;\n+    IntoIterIntoIter,        sym::into_iter,           into_iter_fn,               Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    IteratorNext,            sym::next,                next_fn,                    Target::Method(MethodKind::Trait { body: false}), GenericRequirement::None;\n \n-    IntoIterIntoIter,        sym::into_iter,           into_iter_fn,               Target::Method(MethodKind::Trait { body: false });\n-    IteratorNext,            sym::next,                next_fn,                    Target::Method(MethodKind::Trait { body: false});\n+    PinNewUnchecked,         sym::new_unchecked,       new_unchecked_fn,           Target::Method(MethodKind::Inherent), GenericRequirement::None;\n \n-    PinNewUnchecked,         sym::new_unchecked,       new_unchecked_fn,           Target::Method(MethodKind::Inherent);\n+    RangeFrom,               sym::RangeFrom,           range_from_struct,          Target::Struct,         GenericRequirement::None;\n+    RangeFull,               sym::RangeFull,           range_full_struct,          Target::Struct,         GenericRequirement::None;\n+    RangeInclusiveStruct,    sym::RangeInclusive,      range_inclusive_struct,     Target::Struct,         GenericRequirement::None;\n+    RangeInclusiveNew,       sym::range_inclusive_new, range_inclusive_new_method, Target::Method(MethodKind::Inherent), GenericRequirement::None;\n+    Range,                   sym::Range,               range_struct,               Target::Struct,         GenericRequirement::None;\n+    RangeToInclusive,        sym::RangeToInclusive,    range_to_inclusive_struct,  Target::Struct,         GenericRequirement::None;\n+    RangeTo,                 sym::RangeTo,             range_to_struct,            Target::Struct,         GenericRequirement::None;\n+}\n \n-    RangeFrom,               sym::RangeFrom,           range_from_struct,          Target::Struct;\n-    RangeFull,               sym::RangeFull,           range_full_struct,          Target::Struct;\n-    RangeInclusiveStruct,    sym::RangeInclusive,      range_inclusive_struct,     Target::Struct;\n-    RangeInclusiveNew,       sym::range_inclusive_new, range_inclusive_new_method, Target::Method(MethodKind::Inherent);\n-    Range,                   sym::Range,               range_struct,               Target::Struct;\n-    RangeToInclusive,        sym::RangeToInclusive,    range_to_inclusive_struct,  Target::Struct;\n-    RangeTo,                 sym::RangeTo,             range_to_struct,            Target::Struct;\n+pub enum GenericRequirement {\n+    None,\n+    Minimum(usize),\n+    Exact(usize),\n }"}, {"sha": "9d449589b162471d582cfe13e2a10fc21233e820", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 35, "deletions": 87, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/385a233f1836191837e1a7e575425cf0ce1c9843/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385a233f1836191837e1a7e575425cf0ce1c9843/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=385a233f1836191837e1a7e575425cf0ce1c9843", "patch": "@@ -17,7 +17,7 @@ use rustc_errors::{pluralize, struct_span_err};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::lang_items::{extract, ITEM_REFS};\n+use rustc_hir::lang_items::{extract, GenericRequirement, ITEM_REFS};\n use rustc_hir::{HirId, LangItem, LanguageItems, Target};\n use rustc_span::Span;\n \n@@ -182,121 +182,69 @@ impl LanguageItemCollector<'tcx> {\n     }\n \n     // Like collect_item() above, but also checks whether the lang item is declared\n-    // with the right number of generic arguments if it is a trait.\n+    // with the right number of generic arguments.\n     fn collect_item_extended(&mut self, item_index: usize, hir_id: HirId, span: Span) {\n         let item_def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n         let lang_item = LangItem::from_u32(item_index as u32).unwrap();\n         let name = lang_item.name();\n \n-        self.collect_item(item_index, item_def_id);\n-\n         // Now check whether the lang_item has the expected number of generic\n-        // arguments if it is a trait. Generally speaking, binary and indexing\n-        // operations have one (for the RHS/index), unary operations have none,\n-        // and the rest also have none except for the closure traits (one for\n-        // the argument list), generators (one for the resume argument),\n-        // ordering/equality relations (one for the RHS), and various conversion\n-        // traits.\n-\n-        let expected_num = match lang_item {\n-            // Binary operations\n-            LangItem::Add\n-            | LangItem::Sub\n-            | LangItem::Mul\n-            | LangItem::Div\n-            | LangItem::Rem\n-            | LangItem::BitXor\n-            | LangItem::BitAnd\n-            | LangItem::BitOr\n-            | LangItem::Shl\n-            | LangItem::Shr\n-            | LangItem::AddAssign\n-            | LangItem::SubAssign\n-            | LangItem::MulAssign\n-            | LangItem::DivAssign\n-            | LangItem::RemAssign\n-            | LangItem::BitXorAssign\n-            | LangItem::BitAndAssign\n-            | LangItem::BitOrAssign\n-            | LangItem::ShlAssign\n-            | LangItem::ShrAssign\n-            | LangItem::Index\n-            | LangItem::IndexMut\n-\n-            // Miscellaneous\n-            | LangItem::Unsize\n-            | LangItem::CoerceUnsized\n-            | LangItem::DispatchFromDyn\n-            | LangItem::Fn\n-            | LangItem::FnMut\n-            | LangItem::FnOnce\n-            | LangItem::Generator\n-            | LangItem::PartialEq\n-            | LangItem::PartialOrd\n-                => Some(1),\n-\n-            // Unary operations\n-            LangItem::Neg\n-            | LangItem::Not\n-\n-            // Miscellaneous\n-            | LangItem::Deref\n-            | LangItem::DerefMut\n-            | LangItem::Sized\n-            | LangItem::StructuralPeq\n-            | LangItem::StructuralTeq\n-            | LangItem::Copy\n-            | LangItem::Clone\n-            | LangItem::Sync\n-            | LangItem::DiscriminantKind\n-            | LangItem::PointeeTrait\n-            | LangItem::Freeze\n-            | LangItem::Drop\n-            | LangItem::Receiver\n-            | LangItem::Future\n-            | LangItem::Unpin\n-            | LangItem::Termination\n-            | LangItem::Try\n-                => Some(0),\n+        // arguments. Generally speaking, binary and indexing operations have\n+        // one (for the RHS/index), unary operations have none, the closure\n+        // traits have one for the argument list, generators have one for the\n+        // resume argument, and ordering/equality relations have one for the RHS\n+        // Some other types like Box and various functions like drop_in_place\n+        // have minimum requirements.\n \n-            // Not a trait\n-            _ => None,\n-        };\n+        if let hir::Node::Item(hir::Item { kind, span: item_span, .. }) = self.tcx.hir().get(hir_id)\n+        {\n+            let (actual_num, generics_span) = match kind.generics() {\n+                Some(generics) => (generics.params.len(), generics.span),\n+                None => (0, *item_span),\n+            };\n \n-        if let Some(expected_num) = expected_num {\n-            let (actual_num, generics_span) = match self.tcx.hir().get(hir_id) {\n-                hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Trait(_, _, generics, ..),\n-                    ..\n-                }) => (generics.params.len(), generics.span),\n-                _ => bug!(\"op/index/deref lang item target is not a trait: {:?}\", lang_item),\n+            let required = match lang_item.required_generics() {\n+                GenericRequirement::Exact(num) if num != actual_num => {\n+                    Some((format!(\"{}\", num), pluralize!(num)))\n+                }\n+                GenericRequirement::Minimum(num) if actual_num < num => {\n+                    Some((format!(\"at least {}\", num), pluralize!(num)))\n+                }\n+                // If the number matches, or there is no requirement, handle it normally\n+                _ => None,\n             };\n \n-            if expected_num != actual_num {\n+            if let Some((range_str, pluralized)) = required {\n                 // We are issuing E0718 \"incorrect target\" here, because while the\n                 // item kind of the target is correct, the target is still wrong\n                 // because of the wrong number of generic arguments.\n                 struct_span_err!(\n                     self.tcx.sess,\n                     span,\n                     E0718,\n-                    \"`{}` language item must be applied to a trait with {} generic argument{}\",\n+                    \"`{}` language item must be applied to a {} with {} generic argument{}\",\n                     name,\n-                    expected_num,\n-                    pluralize!(expected_num)\n+                    kind.descr(),\n+                    range_str,\n+                    pluralized,\n                 )\n                 .span_label(\n                     generics_span,\n                     format!(\n-                        \"this trait has {} generic argument{}, not {}\",\n+                        \"this {} has {} generic argument{}\",\n+                        kind.descr(),\n                         actual_num,\n                         pluralize!(actual_num),\n-                        expected_num\n                     ),\n                 )\n                 .emit();\n+\n+                // return early to not collect the lang item\n+                return;\n             }\n         }\n+\n+        self.collect_item(item_index, item_def_id);\n     }\n }\n "}, {"sha": "ee8e5e6dffee3c619d69f3deb9d119a10ba16c36", "filename": "src/test/ui/error-codes/E0152.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385a233f1836191837e1a7e575425cf0ce1c9843/src%2Ftest%2Fui%2Ferror-codes%2FE0152.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385a233f1836191837e1a7e575425cf0ce1c9843/src%2Ftest%2Fui%2Ferror-codes%2FE0152.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0152.rs?ref=385a233f1836191837e1a7e575425cf0ce1c9843", "patch": "@@ -2,7 +2,7 @@\n #![feature(lang_items)]\n \n #[lang = \"owned_box\"]\n-struct Foo; //~ ERROR E0152\n+struct Foo<T>(T); //~ ERROR E0152\n \n fn main() {\n }"}, {"sha": "5cdfe1cc5562d408e166bd3aa8aa391564953f6f", "filename": "src/test/ui/error-codes/E0152.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/385a233f1836191837e1a7e575425cf0ce1c9843/src%2Ftest%2Fui%2Ferror-codes%2FE0152.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/385a233f1836191837e1a7e575425cf0ce1c9843/src%2Ftest%2Fui%2Ferror-codes%2FE0152.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0152.stderr?ref=385a233f1836191837e1a7e575425cf0ce1c9843", "patch": "@@ -1,8 +1,8 @@\n error[E0152]: found duplicate lang item `owned_box`\n   --> $DIR/E0152.rs:5:1\n    |\n-LL | struct Foo;\n-   | ^^^^^^^^^^^\n+LL | struct Foo<T>(T);\n+   | ^^^^^^^^^^^^^^^^^\n    |\n    = note: the lang item is first defined in crate `alloc` (which `std` depends on)\n    = note: first definition in `alloc` loaded from SYSROOT/liballoc-*.rlib"}, {"sha": "a3287db74e7338382b635ecade8e4133e8d0de4b", "filename": "src/test/ui/lang-items/lang-item-correct-generics.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/385a233f1836191837e1a7e575425cf0ce1c9843/src%2Ftest%2Fui%2Flang-items%2Flang-item-correct-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385a233f1836191837e1a7e575425cf0ce1c9843/src%2Ftest%2Fui%2Flang-items%2Flang-item-correct-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Flang-item-correct-generics.rs?ref=385a233f1836191837e1a7e575425cf0ce1c9843", "patch": "@@ -0,0 +1,28 @@\n+// build-pass\n+\n+#![feature(lang_items,no_core)]\n+#![no_core]\n+#![crate_type=\"lib\"]\n+\n+#[lang = \"sized\"]\n+trait MySized {}\n+\n+#[lang = \"copy\"]\n+trait MyCopy {}\n+\n+#[lang = \"drop\"]\n+trait MyDrop<T> {}\n+\n+struct S;\n+\n+impl<T> MyDrop<T> for S {}\n+\n+#[lang = \"i32\"]\n+impl<'a> i32 {\n+    fn foo() {}\n+}\n+\n+fn bar() {\n+    i32::foo();\n+    S;\n+}"}, {"sha": "d785749afc9c20ad47e8a91c4b38e919f1a921fb", "filename": "src/test/ui/lang-items/lang-item-generic-requirements.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/385a233f1836191837e1a7e575425cf0ce1c9843/src%2Ftest%2Fui%2Flang-items%2Flang-item-generic-requirements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385a233f1836191837e1a7e575425cf0ce1c9843/src%2Ftest%2Fui%2Flang-items%2Flang-item-generic-requirements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Flang-item-generic-requirements.rs?ref=385a233f1836191837e1a7e575425cf0ce1c9843", "patch": "@@ -0,0 +1,44 @@\n+// Checks whether declaring a lang item with the wrong number\n+// of generic arguments crashes the compiler (issue #83893, #87573, and part of #9307).\n+\n+#![feature(lang_items, no_core)]\n+#![no_core]\n+#![crate_type = \"lib\"]\n+\n+#[lang = \"sized\"]\n+trait MySized {}\n+\n+#[lang = \"add\"]\n+trait MyAdd<'a, T> {}\n+//~^^ ERROR: `add` language item must be applied to a trait with 1 generic argument [E0718]\n+\n+#[lang = \"drop_in_place\"]\n+//~^ ERROR `drop_in_place` language item must be applied to a function with at least 1 generic\n+fn my_ptr_drop() {}\n+\n+#[lang = \"index\"]\n+trait MyIndex<'a, T> {}\n+//~^^ ERROR: `index` language item must be applied to a trait with 1 generic argument [E0718]\n+\n+#[lang = \"phantom_data\"]\n+//~^ ERROR `phantom_data` language item must be applied to a struct with 1 generic argument\n+struct MyPhantomData<T, U>;\n+//~^ ERROR parameter `T` is never used\n+//~| ERROR parameter `U` is never used\n+\n+fn ice() {\n+    // Use add\n+    let r = 5;\n+    let a = 6;\n+    r + a;\n+\n+    // Use drop in place\n+    my_ptr_drop();\n+\n+    // Use index\n+    let arr = [0; 5];\n+    let _ = arr[2];\n+\n+    // Use phantomdata\n+    let _ = MyPhantomData::<(), i32>;\n+}"}, {"sha": "add5938811c28635b04aecbdc798679a0cbb577d", "filename": "src/test/ui/lang-items/lang-item-generic-requirements.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/385a233f1836191837e1a7e575425cf0ce1c9843/src%2Ftest%2Fui%2Flang-items%2Flang-item-generic-requirements.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/385a233f1836191837e1a7e575425cf0ce1c9843/src%2Ftest%2Fui%2Flang-items%2Flang-item-generic-requirements.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Flang-item-generic-requirements.stderr?ref=385a233f1836191837e1a7e575425cf0ce1c9843", "patch": "@@ -0,0 +1,56 @@\n+error[E0718]: `add` language item must be applied to a trait with 1 generic argument\n+  --> $DIR/lang-item-generic-requirements.rs:11:1\n+   |\n+LL | #[lang = \"add\"]\n+   | ^^^^^^^^^^^^^^^\n+LL | trait MyAdd<'a, T> {}\n+   |            ------- this trait has 2 generic arguments\n+\n+error[E0718]: `drop_in_place` language item must be applied to a function with at least 1 generic argument\n+  --> $DIR/lang-item-generic-requirements.rs:15:1\n+   |\n+LL | #[lang = \"drop_in_place\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | fn my_ptr_drop() {}\n+   |               - this function has 0 generic arguments\n+\n+error[E0718]: `index` language item must be applied to a trait with 1 generic argument\n+  --> $DIR/lang-item-generic-requirements.rs:19:1\n+   |\n+LL | #[lang = \"index\"]\n+   | ^^^^^^^^^^^^^^^^^\n+LL | trait MyIndex<'a, T> {}\n+   |              ------- this trait has 2 generic arguments\n+\n+error[E0718]: `phantom_data` language item must be applied to a struct with 1 generic argument\n+  --> $DIR/lang-item-generic-requirements.rs:23:1\n+   |\n+LL | #[lang = \"phantom_data\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | struct MyPhantomData<T, U>;\n+   |                     ------ this struct has 2 generic arguments\n+\n+error[E0392]: parameter `T` is never used\n+  --> $DIR/lang-item-generic-requirements.rs:25:22\n+   |\n+LL | struct MyPhantomData<T, U>;\n+   |                      ^ unused parameter\n+   |\n+   = help: consider removing `T` or referring to it in a field\n+   = help: if you intended `T` to be a const parameter, use `const T: usize` instead\n+\n+error[E0392]: parameter `U` is never used\n+  --> $DIR/lang-item-generic-requirements.rs:25:25\n+   |\n+LL | struct MyPhantomData<T, U>;\n+   |                         ^ unused parameter\n+   |\n+   = help: consider removing `U` or referring to it in a field\n+   = help: if you intended `U` to be a const parameter, use `const U: usize` instead\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0392, E0718.\n+For more information about an error, try `rustc --explain E0392`."}, {"sha": "9f4f2464a1e65db1f9d119abc7b30def5aaf17ff", "filename": "src/test/ui/lang-items/wrong-number-generic-args-add.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/558553272d5f80ca6484ed3de961fe4f1a9d411d/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/558553272d5f80ca6484ed3de961fe4f1a9d411d/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-add.rs?ref=558553272d5f80ca6484ed3de961fe4f1a9d411d", "patch": "@@ -1,20 +0,0 @@\n-// Checks whether declaring a lang item with the wrong number\n-// of generic arguments crashes the compiler (issue #83893).\n-\n-#![feature(lang_items,no_core)]\n-#![no_core]\n-#![crate_type=\"lib\"]\n-\n-#[lang = \"sized\"]\n-trait MySized {}\n-\n-#[lang = \"add\"]\n-trait MyAdd<'a, T> {}\n-//~^^ ERROR: `add` language item must be applied to a trait with 1 generic argument [E0718]\n-\n-fn ice() {\n-    let r = 5;\n-    let a = 6;\n-    r + a\n-    //~^ ERROR: cannot add `{integer}` to `{integer}` [E0369]\n-}"}, {"sha": "6f89441fd285d978b460319a62592b4893a7af5f", "filename": "src/test/ui/lang-items/wrong-number-generic-args-add.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/558553272d5f80ca6484ed3de961fe4f1a9d411d/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-add.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/558553272d5f80ca6484ed3de961fe4f1a9d411d/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-add.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-add.stderr?ref=558553272d5f80ca6484ed3de961fe4f1a9d411d", "patch": "@@ -1,20 +0,0 @@\n-error[E0718]: `add` language item must be applied to a trait with 1 generic argument\n-  --> $DIR/wrong-number-generic-args-add.rs:11:1\n-   |\n-LL | #[lang = \"add\"]\n-   | ^^^^^^^^^^^^^^^\n-LL | trait MyAdd<'a, T> {}\n-   |            ------- this trait has 2 generic arguments, not 1\n-\n-error[E0369]: cannot add `{integer}` to `{integer}`\n-  --> $DIR/wrong-number-generic-args-add.rs:18:7\n-   |\n-LL |     r + a\n-   |     - ^ - {integer}\n-   |     |\n-   |     {integer}\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0369, E0718.\n-For more information about an error, try `rustc --explain E0369`."}, {"sha": "1d90e63dc5470749fccfd178df32cdc640449f74", "filename": "src/test/ui/lang-items/wrong-number-generic-args-index.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/558553272d5f80ca6484ed3de961fe4f1a9d411d/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/558553272d5f80ca6484ed3de961fe4f1a9d411d/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-index.rs?ref=558553272d5f80ca6484ed3de961fe4f1a9d411d", "patch": "@@ -1,19 +0,0 @@\n-// Checks whether declaring a lang item with the wrong number\n-// of generic arguments crashes the compiler (issue #83893).\n-\n-#![feature(lang_items,no_core)]\n-#![no_core]\n-#![crate_type=\"lib\"]\n-\n-#[lang = \"sized\"]\n-trait MySized {}\n-\n-#[lang = \"index\"]\n-trait MyIndex<'a, T> {}\n-//~^^ ERROR: `index` language item must be applied to a trait with 1 generic argument [E0718]\n-\n-fn ice() {\n-    let arr = [0; 5];\n-    let _ = arr[2];\n-    //~^ ERROR: cannot index into a value of type `[{integer}; 5]` [E0608]\n-}"}, {"sha": "bc3f19ff276239284b9cbbe75d353fc12c264185", "filename": "src/test/ui/lang-items/wrong-number-generic-args-index.stderr", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/558553272d5f80ca6484ed3de961fe4f1a9d411d/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/558553272d5f80ca6484ed3de961fe4f1a9d411d/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Fwrong-number-generic-args-index.stderr?ref=558553272d5f80ca6484ed3de961fe4f1a9d411d", "patch": "@@ -1,18 +0,0 @@\n-error[E0718]: `index` language item must be applied to a trait with 1 generic argument\n-  --> $DIR/wrong-number-generic-args-index.rs:11:1\n-   |\n-LL | #[lang = \"index\"]\n-   | ^^^^^^^^^^^^^^^^^\n-LL | trait MyIndex<'a, T> {}\n-   |              ------- this trait has 2 generic arguments, not 1\n-\n-error[E0608]: cannot index into a value of type `[{integer}; 5]`\n-  --> $DIR/wrong-number-generic-args-index.rs:17:13\n-   |\n-LL |     let _ = arr[2];\n-   |             ^^^^^^\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0608, E0718.\n-For more information about an error, try `rustc --explain E0608`."}]}