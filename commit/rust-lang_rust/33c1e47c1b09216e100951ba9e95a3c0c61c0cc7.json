{"sha": "33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYzFlNDdjMWIwOTIxNmUxMDA5NTFiYTllOTVhM2MwYzYxYzBjYzc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-12-04T23:38:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-12-04T23:38:04Z"}, "message": "librustc: Implement moves based on type. r=nmatsakis", "tree": {"sha": "71733e209b790593e72388b908add93877b25a87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71733e209b790593e72388b908add93877b25a87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "html_url": "https://github.com/rust-lang/rust/commit/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f02e9db212199e7d7e70b0330b8ea76caaaa0ea9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f02e9db212199e7d7e70b0330b8ea76caaaa0ea9", "html_url": "https://github.com/rust-lang/rust/commit/f02e9db212199e7d7e70b0330b8ea76caaaa0ea9"}], "stats": {"total": 410, "additions": 363, "deletions": 47}, "files": [{"sha": "09e35b1037b2d5d846735247dc3384a5af86911f", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -150,8 +150,8 @@ pub pure fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n     /*!\n      * Returns the leftmost some() value, or none if both are none.\n      */\n-    match opta {\n-        Some(_) => move opta,\n+    match move opta {\n+        Some(move opta) => Some(move opta),\n         _ => move optb\n     }\n }"}, {"sha": "ec204ca67365d2268e2f7bf501f78481252a90bb", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -1029,9 +1029,9 @@ impl<T: Send> Port<T>: Recv<T> {\n     pure fn peek() -> bool unsafe {\n         let mut endp = None;\n         endp <-> self.endp;\n-        let peek = match endp {\n-          Some(ref endp) => pipes::peek(endp),\n-          None => fail ~\"peeking empty stream\"\n+        let peek = match &endp {\n+          &Some(ref endp) => pipes::peek(endp),\n+          &None => fail ~\"peeking empty stream\"\n         };\n         self.endp <-> endp;\n         peek"}, {"sha": "ccc7b1508e79b943659297c68916a695725648c9", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -251,6 +251,9 @@ fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n         time(time_passes, ~\"alt checking\", ||\n              middle::check_alt::check_crate(ty_cx, crate));\n \n+        time(time_passes, ~\"mode computation\", ||\n+             middle::mode::compute_modes(ty_cx, method_map, crate));\n+\n         let last_use_map =\n             time(time_passes, ~\"liveness checking\", ||\n                  middle::liveness::check_crate(ty_cx, method_map, crate));"}, {"sha": "0584886e6a01d0937712fca634427b8bfff66825", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -131,7 +131,8 @@ enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_method_map = 0x60,\n     tag_table_vtable_map = 0x61,\n     tag_table_adjustments = 0x62,\n-    tag_table_legacy_boxed_trait = 0x63\n+    tag_table_legacy_boxed_trait = 0x63,\n+    tag_table_value_mode = 0x64\n }\n \n const tag_item_trait_method_sort: uint = 0x70;"}, {"sha": "e3b451219fc08efe42e3d8dfc9ecf38ff34a2a45", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -856,6 +856,15 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n             ebml_w.id(id);\n         }\n     }\n+\n+    do option::iter(&tcx.value_modes.find(id)) |vm| {\n+        do ebml_w.tag(c::tag_table_value_mode) {\n+            ebml_w.id(id);\n+            do ebml_w.tag(c::tag_table_val) {\n+                (*vm).serialize(&ebml_w)\n+            }\n+        }\n+    }\n }\n \n trait doc_decoder_helpers {\n@@ -990,6 +999,9 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 let adj: @ty::AutoAdjustment = @deserialize(val_dsr);\n                 adj.tr(xcx);\n                 dcx.tcx.adjustments.insert(id, adj);\n+            } else if tag == (c::tag_table_value_mode as uint) {\n+                let vm: ty::ValueMode = deserialize(val_dsr);\n+                dcx.tcx.value_modes.insert(id, vm);\n             } else {\n                 xcx.dcx.tcx.sess.bug(\n                     fmt!(\"unknown tag found in side tables: %x\", tag));"}, {"sha": "cb7aa60cc0962f4d57f4ca8dedad6f5fa5905be5", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -12,6 +12,7 @@ use syntax::{visit, ast_util};\n use syntax::ast::*;\n use syntax::codemap::span;\n use middle::ty::{Kind, kind_copyable, kind_noncopyable, kind_const};\n+use middle::ty::{CopyValue, MoveValue, ReadValue};\n use std::map::HashMap;\n use util::ppaux::{ty_to_str, tys_to_str};\n use syntax::print::pprust::expr_to_str;\n@@ -480,8 +481,16 @@ fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool,\n         // borrowed unique value isn't really a copy\n         !is_autorefd(cx, ex)\n     {\n-        let ty = ty::expr_ty(cx.tcx, ex);\n-        check_copy(cx, ex.id, ty, ex.span, implicit_copy, why);\n+        match cx.tcx.value_modes.find(ex.id) {\n+            None => cx.tcx.sess.span_bug(ex.span, ~\"no value mode for lval\"),\n+            Some(MoveValue) | Some(ReadValue) => {} // Won't be a copy.\n+            Some(CopyValue) => {\n+                debug!(\"(kind checking) is a copy value: `%s`\",\n+                       expr_to_str(ex, cx.tcx.sess.intr()));\n+                let ty = ty::expr_ty(cx.tcx, ex);\n+                check_copy(cx, ex.id, ty, ex.span, implicit_copy, why);\n+            }\n+        }\n     }\n \n     fn is_autorefd(cx: ctx, ex: @expr) -> bool {"}, {"sha": "636a24f7ed7f599e0f00cfffeb14c86cabcdf46e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -111,6 +111,7 @@ use syntax::codemap::span;\n use syntax::ast::*;\n use io::WriterUtil;\n use capture::{cap_move, cap_drop, cap_copy, cap_ref};\n+use middle::ty::MoveValue;\n \n export check_crate;\n export last_use_map;\n@@ -1533,6 +1534,22 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n         for self.variable_from_def_map(expr.id, expr.span).each |var| {\n             let ln = self.live_node(expr.id, expr.span);\n             self.consider_last_use(expr, ln, *var);\n+\n+            match self.tcx.value_modes.find(expr.id) {\n+                Some(MoveValue) => {\n+                    debug!(\"(checking expr) is a move: `%s`\",\n+                           expr_to_str(expr, self.tcx.sess.intr()));\n+                    self.check_move_from_var(expr.span, ln, *var);\n+                }\n+                Some(v) => {\n+                    debug!(\"(checking expr) not a move (%?): `%s`\",\n+                           v,\n+                           expr_to_str(expr, self.tcx.sess.intr()));\n+                }\n+                None => {\n+                    fail ~\"no mode for lval\";\n+                }\n+            }\n         }\n \n         visit::visit_expr(expr, self, vt);"}, {"sha": "b3125077ec2df3f31bca01fbd3a44c721db37420", "filename": "src/librustc/middle/mode.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Fmode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Fmode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmode.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -0,0 +1,181 @@\n+use middle::ty;\n+use middle::ty::{CopyValue, MoveValue, ReadValue, ValueMode, ctxt};\n+use middle::typeck::{method_map, method_map_entry};\n+\n+use core::vec;\n+use std::map::HashMap;\n+use syntax::ast::{by_copy, by_move, by_ref, by_val, crate, expr, expr_assign};\n+use syntax::ast::{expr_addr_of, expr_assign_op, expr_binary, expr_call};\n+use syntax::ast::{expr_copy, expr_field, expr_index, expr_method_call};\n+use syntax::ast::{expr_path, expr_swap, expr_unary, node_id, sty_uniq};\n+use syntax::ast::{sty_value};\n+use syntax::ast::{box, uniq, deref, not, neg, expr_paren};\n+use syntax::visit;\n+use syntax::visit::vt;\n+\n+struct VisitContext {\n+    tcx: ctxt,\n+    method_map: HashMap<node_id,method_map_entry>,\n+    mode: ValueMode,\n+}\n+\n+fn compute_modes_for_fn_args(callee_id: node_id,\n+                             args: &[@expr],\n+                             &&cx: VisitContext,\n+                             v: vt<VisitContext>) {\n+    let arg_tys = ty::ty_fn_args(ty::node_id_to_type(cx.tcx, callee_id));\n+    for vec::each2(args, arg_tys) |arg, arg_ty| {\n+        match ty::resolved_mode(cx.tcx, arg_ty.mode) {\n+            by_ref => {\n+                let arg_cx = VisitContext { mode: ReadValue, ..cx };\n+                compute_modes_for_expr(*arg, arg_cx, v);\n+            }\n+            by_val | by_move | by_copy => compute_modes_for_expr(*arg, cx, v)\n+        }\n+    }\n+}\n+\n+fn record_mode_for_expr(expr: @expr, &&cx: VisitContext) {\n+    match cx.mode {\n+        ReadValue | CopyValue => {\n+            cx.tcx.value_modes.insert(expr.id, cx.mode);\n+        }\n+        MoveValue => {\n+            // This is, contextually, a move, but if this expression\n+            // is implicitly copyable it's cheaper to copy.\n+            let e_ty = ty::expr_ty(cx.tcx, expr);\n+            if ty::type_implicitly_moves(cx.tcx, e_ty) {\n+                cx.tcx.value_modes.insert(expr.id, MoveValue);\n+            } else {\n+                cx.tcx.value_modes.insert(expr.id, CopyValue);\n+            }\n+        }\n+    }\n+}\n+\n+fn compute_modes_for_expr(expr: @expr,\n+                          &&cx: VisitContext,\n+                          v: vt<VisitContext>) {\n+    // Adjust the mode if there was an implicit reference here.\n+    let cx = match cx.tcx.adjustments.find(expr.id) {\n+        None => cx,\n+        Some(adjustment) => {\n+            if adjustment.autoref.is_some() {\n+                VisitContext { mode: ReadValue, ..cx }\n+            } else {\n+                cx\n+            }\n+        }\n+    };\n+\n+    match expr.node {\n+        expr_call(callee, args, _) => {\n+            let callee_cx = VisitContext { mode: ReadValue, ..cx };\n+            compute_modes_for_expr(callee, callee_cx, v);\n+            compute_modes_for_fn_args(callee.id, args, cx, v);\n+        }\n+        expr_path(*) => {\n+            record_mode_for_expr(expr, cx);\n+        }\n+        expr_copy(expr) => {\n+            let callee_cx = VisitContext { mode: CopyValue, ..cx };\n+            compute_modes_for_expr(expr, callee_cx, v);\n+        }\n+        expr_method_call(callee, _, _, args, _) => {\n+            // The LHS of the dot may or may not result in a move, depending\n+            // on the method map entry.\n+            let callee_mode;\n+            match cx.method_map.find(expr.id) {\n+                Some(ref method_map_entry) => {\n+                    match method_map_entry.explicit_self {\n+                        sty_uniq(_) | sty_value => callee_mode = MoveValue,\n+                        _ => callee_mode = ReadValue\n+                    }\n+                }\n+                None => {\n+                    cx.tcx.sess.span_bug(expr.span, ~\"no method map entry\");\n+                }\n+            }\n+\n+            let callee_cx = VisitContext { mode: callee_mode, ..cx };\n+            compute_modes_for_expr(callee, callee_cx, v);\n+\n+            compute_modes_for_fn_args(expr.callee_id, args, cx, v);\n+        }\n+        expr_binary(_, lhs, rhs) | expr_assign_op(_, lhs, rhs) => {\n+            // The signatures of these take their arguments by-ref, so they\n+            // don't copy or move.\n+            let arg_cx = VisitContext { mode: ReadValue, ..cx };\n+            compute_modes_for_expr(lhs, arg_cx, v);\n+            compute_modes_for_expr(rhs, arg_cx, v);\n+        }\n+        expr_addr_of(_, arg) => {\n+            // Takes its argument by-ref, so it doesn't copy or move.\n+            let arg_cx = VisitContext { mode: ReadValue, ..cx };\n+            compute_modes_for_expr(arg, arg_cx, v);\n+        }\n+        expr_unary(unop, arg) => {\n+            // Ditto.\n+            let arg_cx = VisitContext { mode: ReadValue, ..cx };\n+            compute_modes_for_expr(arg, arg_cx, v);\n+\n+            match unop {\n+                deref => {\n+                    // This is an lvalue, so it needs a value mode recorded\n+                    // for it.\n+                    record_mode_for_expr(expr, cx);\n+                }\n+                box(_) | uniq(_) | not | neg => {}\n+            }\n+        }\n+        expr_field(arg, _, _) => {\n+            let arg_cx = VisitContext { mode: ReadValue, ..cx };\n+            compute_modes_for_expr(arg, arg_cx, v);\n+\n+            record_mode_for_expr(expr, cx);\n+        }\n+        expr_assign(lhs, rhs) => {\n+            // The signatures of these take their arguments by-ref, so they\n+            // don't copy or move.\n+            let arg_cx = VisitContext { mode: ReadValue, ..cx };\n+            compute_modes_for_expr(lhs, arg_cx, v);\n+            compute_modes_for_expr(rhs, cx, v);\n+        }\n+        expr_swap(lhs, rhs) => {\n+            let arg_cx = VisitContext { mode: ReadValue, ..cx };\n+            compute_modes_for_expr(lhs, arg_cx, v);\n+            compute_modes_for_expr(rhs, arg_cx, v);\n+        }\n+        expr_index(lhs, rhs) => {\n+            let lhs_cx = VisitContext { mode: ReadValue, ..cx };\n+            compute_modes_for_expr(lhs, lhs_cx, v);\n+            let rhs_cx = VisitContext { mode: MoveValue, ..cx };\n+            compute_modes_for_expr(rhs, rhs_cx, v);\n+\n+            record_mode_for_expr(expr, cx);\n+        }\n+        expr_paren(arg) => {\n+            compute_modes_for_expr(arg, cx, v);\n+            record_mode_for_expr(expr, cx);\n+        }\n+        _ => {\n+            // XXX: Spell out every expression above so when we add them we\n+            // don't forget to update this file.\n+            visit::visit_expr(expr, cx, v)\n+        }\n+    }\n+}\n+\n+pub fn compute_modes(tcx: ctxt, method_map: method_map, crate: @crate) {\n+    let visitor = visit::mk_vt(@{\n+        visit_expr: compute_modes_for_expr,\n+        .. *visit::default_visitor()\n+    });\n+    let callee_cx = VisitContext {\n+        tcx: tcx,\n+        method_map: method_map,\n+        mode: MoveValue\n+    };\n+    visit::visit_crate(*crate, callee_cx, visitor);\n+}\n+"}, {"sha": "2796cca68388f2f76a6f7a476b3372972d3e21f9", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -270,7 +270,7 @@ fn build_closure(bcx0: block,\n     let mut env_vals = ~[];\n     for vec::each(cap_vars) |cap_var| {\n         debug!(\"Building closure: captured variable %?\", *cap_var);\n-        let datum = expr::trans_local_var(bcx, cap_var.def);\n+        let datum = expr::trans_local_var(bcx, cap_var.def, None);\n         match cap_var.mode {\n             capture::cap_ref => {\n                 assert proto == ast::ProtoBorrowed;"}, {"sha": "750efb2ecf72dc50b788ff1e4f233857a6b57314", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -509,13 +509,17 @@ impl Datum {\n         }\n     }\n \n-    fn GEPi(bcx: block, ixs: &[uint], ty: ty::t) -> Datum {\n+    fn GEPi(bcx: block,\n+            ixs: &[uint],\n+            ty: ty::t,\n+            source: DatumSource)\n+         -> Datum {\n         let base_val = self.to_ref_llval(bcx);\n         Datum {\n             val: GEPi(bcx, base_val, ixs),\n             mode: ByRef,\n             ty: ty,\n-            source: FromLvalue\n+            source: source\n         }\n     }\n "}, {"sha": "0ea5ded53f435fc643658785531042681acc791c", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 53, "deletions": 16, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -121,6 +121,7 @@ use util::ppaux::ty_to_str;\n use util::common::indenter;\n use ty::{AutoPtr, AutoBorrowVec, AutoBorrowFn};\n use callee::{AutorefArg, DoAutorefArg, DontAutorefArg};\n+use middle::ty::MoveValue;\n \n // The primary two functions for translating expressions:\n export trans_to_datum, trans_into;\n@@ -736,7 +737,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                 return trans_def_lvalue(bcx, expr, bcx.def(expr.id));\n             }\n             ast::expr_field(base, ident, _) => {\n-                return trans_rec_field(bcx, base, ident);\n+                return trans_rec_field(bcx, base, ident, expr.id);\n             }\n             ast::expr_index(base, idx) => {\n                 return trans_index(bcx, expr, base, idx);\n@@ -756,8 +757,10 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     }\n }\n \n-fn trans_def_lvalue(bcx: block, ref_expr: @ast::expr,\n-                    def: ast::def) -> DatumBlock {\n+fn trans_def_lvalue(bcx: block,\n+                    ref_expr: @ast::expr,\n+                    def: ast::def)\n+                 -> DatumBlock {\n     let _icx = bcx.insn_ctxt(\"trans_def_lvalue\");\n     let ccx = bcx.ccx();\n     match def {\n@@ -779,17 +782,21 @@ fn trans_def_lvalue(bcx: block, ref_expr: @ast::expr,\n         _ => {\n             DatumBlock {\n                 bcx: bcx,\n-                datum: trans_local_var(bcx, def)\n+                datum: trans_local_var(bcx, def, Some(ref_expr.id))\n             }\n         }\n     }\n }\n \n-fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n+fn trans_local_var(bcx: block,\n+                   def: ast::def,\n+                   expr_id_opt: Option<ast::node_id>)\n+                -> Datum {\n     let _icx = bcx.insn_ctxt(\"trans_local_var\");\n \n     return match def {\n         ast::def_upvar(nid, _, _, _) => {\n+            // Can't move upvars, so this is never a FromLvalueLastUse.\n             let local_ty = node_id_type(bcx, nid);\n             match bcx.fcx.llupvars.find(nid) {\n                 Some(val) => {\n@@ -807,10 +814,10 @@ fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n             }\n         }\n         ast::def_arg(nid, _) => {\n-            take_local(bcx, bcx.fcx.llargs, nid)\n+            take_local(bcx, bcx.fcx.llargs, nid, expr_id_opt)\n         }\n         ast::def_local(nid, _) | ast::def_binding(nid, _) => {\n-            take_local(bcx, bcx.fcx.lllocals, nid)\n+            take_local(bcx, bcx.fcx.lllocals, nid, expr_id_opt)\n         }\n         ast::def_self(nid) => {\n             let self_info: ValSelfData = match bcx.fcx.llself {\n@@ -832,7 +839,7 @@ fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n                 val: casted_val,\n                 ty: self_info.t,\n                 mode: ByRef,\n-                source: FromLvalue\n+                source: source_from_opt_lvalue_type(bcx.tcx(), expr_id_opt)\n             }\n         }\n         _ => {\n@@ -843,8 +850,8 @@ fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n \n     fn take_local(bcx: block,\n                   table: HashMap<ast::node_id, local_val>,\n-                  nid: ast::node_id) -> Datum {\n-\n+                  nid: ast::node_id,\n+                  expr_id_opt: Option<ast::node_id>) -> Datum {\n         let (v, mode) = match table.find(nid) {\n             Some(local_mem(v)) => (v, ByRef),\n             Some(local_imm(v)) => (v, ByValue),\n@@ -858,7 +865,12 @@ fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n         debug!(\"take_local(nid=%?, v=%s, mode=%?, ty=%s)\",\n                nid, bcx.val_str(v), mode, bcx.ty_to_str(ty));\n \n-        Datum { val: v, ty: ty, mode: mode, source: FromLvalue }\n+        Datum {\n+            val: v,\n+            ty: ty,\n+            mode: mode,\n+            source: source_from_opt_lvalue_type(bcx.tcx(), expr_id_opt)\n+        }\n     }\n }\n \n@@ -943,20 +955,39 @@ fn with_field_tys<R>(tcx: ty::ctxt,\n \n fn trans_rec_field(bcx: block,\n                    base: @ast::expr,\n-                   field: ast::ident) -> DatumBlock {\n+                   field: ast::ident,\n+                   expr_id: ast::node_id) -> DatumBlock {\n     let mut bcx = bcx;\n     let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n \n     let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n     do with_field_tys(bcx.tcx(), base_datum.ty, None) |_dtor, field_tys| {\n         let ix = ty::field_idx_strict(bcx.tcx(), field, field_tys);\n         DatumBlock {\n-            datum: base_datum.GEPi(bcx, [0u, 0u, ix], field_tys[ix].mt.ty),\n+            datum: base_datum.GEPi(bcx,\n+                                   [0u, 0u, ix],\n+                                   field_tys[ix].mt.ty,\n+                                   source_from_opt_lvalue_type(\n+                                        bcx.tcx(), Some(expr_id))),\n             bcx: bcx\n         }\n     }\n }\n \n+fn source_from_opt_lvalue_type(tcx: ty::ctxt,\n+                               expr_id_opt: Option<ast::node_id>)\n+                            -> DatumSource {\n+    match expr_id_opt {\n+        None => FromLvalue,\n+        Some(expr_id) => {\n+            match tcx.value_modes.find(expr_id) {\n+                Some(MoveValue) => FromLastUseLvalue,\n+                Some(_) | None => FromLvalue,\n+            }\n+        }\n+    }\n+}\n+\n fn trans_index(bcx: block,\n                index_expr: @ast::expr,\n                base: @ast::expr,\n@@ -1010,8 +1041,11 @@ fn trans_index(bcx: block,\n     let elt = PointerCast(bcx, elt, T_ptr(vt.llunit_ty));\n     return DatumBlock {\n         bcx: bcx,\n-        datum: Datum {val: elt, ty: vt.unit_ty,\n-                      mode: ByRef, source: FromLvalue}\n+        datum: Datum {val: elt,\n+                      ty: vt.unit_ty,\n+                      mode: ByRef,\n+                      source: source_from_opt_lvalue_type(\n+                            bcx.tcx(), Some(index_expr.id))}\n     };\n }\n \n@@ -1101,7 +1135,10 @@ fn trans_rec_or_struct(bcx: block,\n                 if !fields.any(|f| f.node.ident == field_ty.ident) {\n                     let dest = GEPi(bcx, addr, struct_field(i));\n                     let base_field =\n-                        base_datum.GEPi(bcx, struct_field(i), field_ty.mt.ty);\n+                        base_datum.GEPi(bcx,\n+                                        struct_field(i),\n+                                        field_ty.mt.ty,\n+                                        FromLvalue);\n                     bcx = base_field.store_to(bcx, INIT, dest);\n                 }\n             }"}, {"sha": "adc8500c1ba23edacaf7993293ba76d12992fd52", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -65,7 +65,7 @@ fn is_sse(++c: x86_64_reg_class) -> bool {\n     };\n }\n \n-fn is_ymm(cls: ~[x86_64_reg_class]) -> bool {\n+fn is_ymm(cls: &[x86_64_reg_class]) -> bool {\n     let len = vec::len(cls);\n     return (len > 2u &&\n          is_sse(cls[0]) &&\n@@ -136,13 +136,13 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         };\n     }\n \n-    fn all_mem(cls: ~[mut x86_64_reg_class]) {\n+    fn all_mem(cls: &[mut x86_64_reg_class]) {\n         for uint::range(0, cls.len()) |i| {\n             cls[i] = memory_class;\n         }\n     }\n \n-    fn unify(cls: ~[mut x86_64_reg_class],\n+    fn unify(cls: &[mut x86_64_reg_class],\n              i: uint,\n              newv: x86_64_reg_class) {\n         if cls[i] == newv {\n@@ -167,8 +167,8 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         }\n     }\n \n-    fn classify_struct(tys: ~[TypeRef],\n-                       cls: ~[mut x86_64_reg_class], i: uint,\n+    fn classify_struct(tys: &[TypeRef],\n+                       cls: &[mut x86_64_reg_class], i: uint,\n                        off: uint) {\n         if vec::is_empty(tys) {\n             classify(T_i64(), cls, i, off);\n@@ -183,7 +183,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     }\n \n     fn classify(ty: TypeRef,\n-                cls: ~[mut x86_64_reg_class], ix: uint,\n+                cls: &[mut x86_64_reg_class], ix: uint,\n                 off: uint) {\n         let t_align = ty_align(ty);\n         let t_size = ty_size(ty);\n@@ -231,7 +231,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         }\n     }\n \n-    fn fixup(ty: TypeRef, cls: ~[mut x86_64_reg_class]) {\n+    fn fixup(ty: TypeRef, cls: &[mut x86_64_reg_class]) {\n         let mut i = 0u;\n         let llty = llvm::LLVMGetTypeKind(ty) as int;\n         let e = vec::len(cls);\n@@ -289,8 +289,8 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     return vec::from_mut(move cls);\n }\n \n-fn llreg_ty(cls: ~[x86_64_reg_class]) -> TypeRef {\n-    fn llvec_len(cls: ~[x86_64_reg_class]) -> uint {\n+fn llreg_ty(cls: &[x86_64_reg_class]) -> TypeRef {\n+    fn llvec_len(cls: &[x86_64_reg_class]) -> uint {\n         let mut len = 1u;\n         for vec::each(cls) |c| {\n             if *c != sseup_class {\n@@ -342,7 +342,7 @@ type x86_64_tys = {\n     sret: bool\n };\n \n-fn x86_64_tys(atys: ~[TypeRef],\n+fn x86_64_tys(atys: &[TypeRef],\n               rty: TypeRef,\n               ret_def: bool) -> x86_64_tys {\n     fn is_reg_ty(ty: TypeRef) -> bool {\n@@ -355,18 +355,18 @@ fn x86_64_tys(atys: ~[TypeRef],\n         };\n     }\n \n-    fn is_pass_byval(cls: ~[x86_64_reg_class]) -> bool {\n+    fn is_pass_byval(cls: &[x86_64_reg_class]) -> bool {\n         return cls[0] == memory_class ||\n             cls[0] == x87_class ||\n             cls[0] == complex_x87_class;\n     }\n \n-    fn is_ret_bysret(cls: ~[x86_64_reg_class]) -> bool {\n+    fn is_ret_bysret(cls: &[x86_64_reg_class]) -> bool {\n         return cls[0] == memory_class;\n     }\n \n     fn x86_64_ty(ty: TypeRef,\n-                 is_mem_cls: fn(cls: ~[x86_64_reg_class]) -> bool,\n+                 is_mem_cls: fn(cls: &[x86_64_reg_class]) -> bool,\n                  attr: Attribute) -> (x86_64_llty, Option<Attribute>) {\n         let mut cast = false;\n         let mut ty_attr = option::None;"}, {"sha": "9e002d2d69e6d0c9740139cbd31f87088909860d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -117,6 +117,7 @@ export ty_uint, mk_uint, mk_mach_uint;\n export ty_uniq, mk_uniq, mk_imm_uniq, type_is_unique_box;\n export ty_infer, mk_infer, type_is_ty_var, mk_var, mk_int_var, mk_float_var;\n export InferTy, TyVar, IntVar, FloatVar;\n+export ValueMode, ReadValue, CopyValue, MoveValue;\n export ty_self, mk_self, type_has_self;\n export ty_class;\n export Region, bound_region, encl_region;\n@@ -134,6 +135,7 @@ export ty_region;\n export Kind, kind_implicitly_copyable, kind_send_copy, kind_copyable;\n export kind_noncopyable, kind_const;\n export kind_can_be_copied, kind_can_be_sent, kind_can_be_implicitly_copied;\n+export type_implicitly_moves;\n export kind_is_safe_for_default_mode;\n export kind_is_owned;\n export meta_kind, kind_lteq, type_kind;\n@@ -251,6 +253,15 @@ type field_ty = {\n   mutability: ast::class_mutability\n };\n \n+/// How an lvalue is to be used.\n+#[auto_serialize]\n+#[auto_deserialize]\n+pub enum ValueMode {\n+    ReadValue,  // Non-destructively read the value; do not copy or move.\n+    CopyValue,  // Copy the value.\n+    MoveValue,  // Move the value.\n+}\n+\n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n type creader_cache_key = {cnum: int, pos: uint, len: uint};\n@@ -429,7 +440,10 @@ type ctxt =\n       destructor_for_type: HashMap<ast::def_id, ast::def_id>,\n \n       // A method will be in this list if and only if it is a destructor.\n-      destructors: HashMap<ast::def_id, ()>\n+      destructors: HashMap<ast::def_id, ()>,\n+\n+      // Records the value mode (read, copy, or move) for every value.\n+      value_modes: HashMap<ast::node_id, ValueMode>,\n       };\n \n enum tbox_flag {\n@@ -968,7 +982,8 @@ fn mk_ctxt(s: session::Session,\n       automatically_derived_methods: HashMap(),\n       automatically_derived_methods_for_impl: HashMap(),\n       destructor_for_type: HashMap(),\n-      destructors: HashMap()}\n+      destructors: HashMap(),\n+      value_modes: HashMap()}\n }\n \n \n@@ -2258,6 +2273,11 @@ fn type_kind(cx: ctxt, ty: t) -> Kind {\n     return result;\n }\n \n+fn type_implicitly_moves(cx: ctxt, ty: t) -> bool {\n+    let kind = type_kind(cx, ty);\n+    !(kind_can_be_copied(kind) && kind_can_be_implicitly_copied(kind))\n+}\n+\n /// gives a rough estimate of how much space it takes to represent\n /// an instance of `ty`.  Used for the mode transition.\n fn type_size(cx: ctxt, ty: t) -> uint {"}, {"sha": "543bff8a234cec16e517db1c17971967974797dd", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -181,6 +181,8 @@ mod middle {\n     #[legacy_exports]\n     #[path = \"middle/privacy.rs\"]\n     mod privacy;\n+    #[path = \"middle/mode.rs\"]\n+    mod mode;\n }\n \n mod front {"}, {"sha": "4ae2601ebe722041324411e08695147ed9a7f8fb", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -610,9 +610,9 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n         kill_ch: kill_ch,\n         on_connect_cb: move on_connect_cb,\n         iotask: iotask,\n-        ipv6: match host_ip {\n-            ip::Ipv4(_) => { false }\n-            ip::Ipv6(_) => { true }\n+        ipv6: match &host_ip {\n+            &ip::Ipv4(_) => { false }\n+            &ip::Ipv6(_) => { true }\n         },\n         mut active: true\n     };"}, {"sha": "e782a1834309df98b2d5b9aeafecf3fde38947b4", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -100,8 +100,8 @@ enum matcher_pos_up { /* to break a circularity */\n }\n \n fn is_some(&&mpu: matcher_pos_up) -> bool {\n-    match mpu {\n-      matcher_pos_up(None) => false,\n+    match &mpu {\n+      &matcher_pos_up(None) => false,\n       _ => true\n     }\n }"}, {"sha": "b189565bf44a1e3432a8cfded160009f6b328ba1", "filename": "src/test/auxiliary/moves_based_on_type_lib.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Ftest%2Fauxiliary%2Fmoves_based_on_type_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Ftest%2Fauxiliary%2Fmoves_based_on_type_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmoves_based_on_type_lib.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -0,0 +1,15 @@\n+#[crate_type=\"lib\"];\n+\n+pub struct S {\n+    x: int,\n+    drop {\n+        io::println(\"goodbye\");\n+    }\n+}\n+\n+pub fn f() {\n+    let x = S { x: 1 };\n+    let y = x;\n+    let z = y;\n+}\n+"}, {"sha": "3d42bf76230141f04f0e6295c61b14a5cdcedee8", "filename": "src/test/compile-fail/use-after-move-based-on-type.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Ftest%2Fcompile-fail%2Fuse-after-move-based-on-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Ftest%2Fcompile-fail%2Fuse-after-move-based-on-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-based-on-type.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let x = ~\"Hello!\";\n+    let _y = x;\n+    io::println(x); //~ ERROR use of moved variable\n+}\n+"}, {"sha": "08dbd555cd408dd6640217d5effa38bba2403866", "filename": "src/test/run-pass/moves-based-on-type-cross-crate.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c1e47c1b09216e100951ba9e95a3c0c61c0cc7/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-cross-crate.rs?ref=33c1e47c1b09216e100951ba9e95a3c0c61c0cc7", "patch": "@@ -0,0 +1,9 @@\n+// xfail-fast\n+// aux-build:moves_based_on_type_lib.rs\n+\n+extern mod moves_based_on_type_lib;\n+use moves_based_on_type_lib::f;\n+\n+fn main() {\n+    f();\n+}"}]}