{"sha": "b8b4150c042b06c46e29a9d12101f91fe13996e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YjQxNTBjMDQyYjA2YzQ2ZTI5YTlkMTIxMDFmOTFmZTEzOTk2ZTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-11T11:57:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-11T11:57:06Z"}, "message": "Auto merge of #54911 - ljedrz:cleanup_codegen_llvm_top, r=michaelwoerister\n\nCleanup top-level codegen_llvm\n\n- improve allocations\n- improve common patterns\n- remove explicit returns\n- fix spelling & grammatical errors\n- whitespace & formatting improvements", "tree": {"sha": "5533cfe2ed05144e77ab5811237ecd047f32d4d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5533cfe2ed05144e77ab5811237ecd047f32d4d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8b4150c042b06c46e29a9d12101f91fe13996e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8b4150c042b06c46e29a9d12101f91fe13996e0", "html_url": "https://github.com/rust-lang/rust/commit/b8b4150c042b06c46e29a9d12101f91fe13996e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8b4150c042b06c46e29a9d12101f91fe13996e0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a534216fa6d518088ae4468f1cdc519cd79e6247", "url": "https://api.github.com/repos/rust-lang/rust/commits/a534216fa6d518088ae4468f1cdc519cd79e6247", "html_url": "https://github.com/rust-lang/rust/commit/a534216fa6d518088ae4468f1cdc519cd79e6247"}, {"sha": "a0fc2e6ddc1ebf3cc8be8b0dc2faee8f95f95f09", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0fc2e6ddc1ebf3cc8be8b0dc2faee8f95f95f09", "html_url": "https://github.com/rust-lang/rust/commit/a0fc2e6ddc1ebf3cc8be8b0dc2faee8f95f95f09"}], "stats": {"total": 405, "additions": 189, "deletions": 216}, "files": [{"sha": "c8e8d0dc84ef038027ffc589c558923721a253d2", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -150,7 +150,7 @@ impl LlvmType for CastTarget {\n         // Create list of fields in the main structure\n         let mut args: Vec<_> =\n             self.prefix.iter().flat_map(|option_kind| option_kind.map(\n-                    |kind| Reg { kind: kind, size: self.prefix_chunk }.llvm_type(cx)))\n+                |kind| Reg { kind: kind, size: self.prefix_chunk }.llvm_type(cx)))\n             .chain((0..rest_count).map(|_| rest_ll_unit))\n             .collect();\n \n@@ -259,8 +259,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n }\n \n pub trait FnTypeExt<'tcx> {\n-    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>)\n-                   -> Self;\n+    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>) -> Self;\n     fn new(cx: &CodegenCx<'ll, 'tcx>,\n            sig: ty::FnSig<'tcx>,\n            extra_args: &[Ty<'tcx>]) -> Self;\n@@ -283,25 +282,24 @@ pub trait FnTypeExt<'tcx> {\n }\n \n impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n-    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>)\n-                       -> Self {\n+    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>) -> Self {\n         let fn_ty = instance.ty(cx.tcx);\n         let sig = ty_fn_sig(cx, fn_ty);\n         let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n         FnType::new(cx, sig, &[])\n     }\n \n     fn new(cx: &CodegenCx<'ll, 'tcx>,\n-               sig: ty::FnSig<'tcx>,\n-               extra_args: &[Ty<'tcx>]) -> Self {\n+           sig: ty::FnSig<'tcx>,\n+           extra_args: &[Ty<'tcx>]) -> Self {\n         FnType::new_internal(cx, sig, extra_args, |ty, _| {\n             ArgType::new(cx.layout_of(ty))\n         })\n     }\n \n     fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n-                      sig: ty::FnSig<'tcx>,\n-                      extra_args: &[Ty<'tcx>]) -> Self {\n+                  sig: ty::FnSig<'tcx>,\n+                  extra_args: &[Ty<'tcx>]) -> Self {\n         FnType::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n             let mut layout = cx.layout_of(ty);\n             // Don't pass the vtable, it's not an argument of the virtual fn.\n@@ -338,7 +336,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             RustIntrinsic | PlatformIntrinsic |\n             Rust | RustCall => Conv::C,\n \n-            // It's the ABI's job to select this, not us.\n+            // It's the ABI's job to select this, not ours.\n             System => bug!(\"system abi should be selected elsewhere\"),\n \n             Stdcall => Conv::X86Stdcall,\n@@ -697,14 +695,13 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             // If the value is a boolean, the range is 0..2 and that ultimately\n             // become 0..0 when the type becomes i1, which would be rejected\n             // by the LLVM verifier.\n-            match scalar.value {\n-                layout::Int(..) if !scalar.is_bool() => {\n+            if let layout::Int(..) = scalar.value {\n+                if !scalar.is_bool() {\n                     let range = scalar.valid_range_exclusive(bx.cx);\n                     if range.start != range.end {\n                         bx.range_metadata(callsite, range);\n                     }\n                 }\n-                _ => {}\n             }\n         }\n         for arg in &self.args {"}, {"sha": "7c237407c8f54b219a903b0e360392f18ff87761", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -33,7 +33,7 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind\n     let void = llvm::LLVMVoidTypeInContext(llcx);\n \n     for method in ALLOCATOR_METHODS {\n-        let mut args = Vec::new();\n+        let mut args = Vec::with_capacity(method.inputs.len());\n         for ty in method.inputs.iter() {\n             match *ty {\n                 AllocatorTy::Layout => {"}, {"sha": "0abc26d6cfbc44fc452715a465c04348e42405bb", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -94,9 +94,8 @@ pub fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     // Currently stack probes seem somewhat incompatible with the address\n     // sanitizer. With asan we're already protected from stack overflow anyway\n     // so we don't really need stack probes regardless.\n-    match cx.sess().opts.debugging_opts.sanitizer {\n-        Some(Sanitizer::Address) => return,\n-        _ => {}\n+    if let Some(Sanitizer::Address) = cx.sess().opts.debugging_opts.sanitizer {\n+        return\n     }\n \n     // probestack doesn't play nice either with pgo-gen.\n@@ -280,12 +279,14 @@ pub fn provide_extern(providers: &mut Providers) {\n         // `NativeLibrary` internally contains information about\n         // `#[link(wasm_import_module = \"...\")]` for example.\n         let native_libs = tcx.native_libraries(cnum);\n-        let mut def_id_to_native_lib = FxHashMap();\n-        for lib in native_libs.iter() {\n+\n+        let def_id_to_native_lib = native_libs.iter().filter_map(|lib|\n             if let Some(id) = lib.foreign_module {\n-                def_id_to_native_lib.insert(id, lib);\n+                Some((id, lib))\n+            } else {\n+                None\n             }\n-        }\n+        ).collect::<FxHashMap<_, _>>();\n \n         let mut ret = FxHashMap();\n         for lib in tcx.foreign_modules(cnum).iter() {\n@@ -296,10 +297,10 @@ pub fn provide_extern(providers: &mut Providers) {\n                 Some(s) => s,\n                 None => continue,\n             };\n-            for id in lib.foreign_items.iter() {\n+            ret.extend(lib.foreign_items.iter().map(|id| {\n                 assert_eq!(id.krate, cnum);\n-                ret.insert(*id, module.to_string());\n-            }\n+                (*id, module.to_string())\n+            }));\n         }\n \n         Lrc::new(ret)"}, {"sha": "c814ab4ab6710123e8e69069ad7690761134ea7d", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -213,8 +213,8 @@ pub fn unsized_info(\n                             vtable_ptr.llvm_type(cx))\n         }\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n-                                     source,\n-                                     target),\n+                  source,\n+                  target),\n     }\n }\n \n@@ -340,11 +340,11 @@ pub fn cast_shift_expr_rhs(\n }\n \n fn cast_shift_rhs<'ll, F, G>(op: hir::BinOpKind,\n-                        lhs: &'ll Value,\n-                        rhs: &'ll Value,\n-                        trunc: F,\n-                        zext: G)\n-                        -> &'ll Value\n+                             lhs: &'ll Value,\n+                             rhs: &'ll Value,\n+                             trunc: F,\n+                             zext: G)\n+                             -> &'ll Value\n     where F: FnOnce(&'ll Value, &'ll Type) -> &'ll Value,\n           G: FnOnce(&'ll Value, &'ll Type) -> &'ll Value\n {\n@@ -363,8 +363,8 @@ fn cast_shift_rhs<'ll, F, G>(op: hir::BinOpKind,\n         if lhs_sz < rhs_sz {\n             trunc(rhs, lhs_llty)\n         } else if lhs_sz > rhs_sz {\n-            // FIXME (#1877: If shifting by negative\n-            // values becomes not undefined then this is wrong.\n+            // FIXME (#1877: If in the future shifting by negative\n+            // values is no longer undefined then this is wrong.\n             zext(rhs, lhs_llty)\n         } else {\n             rhs\n@@ -495,10 +495,8 @@ pub fn codegen_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'\n     let sig = common::ty_fn_sig(cx, fn_ty);\n     let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n \n-    let lldecl = match cx.instances.borrow().get(&instance) {\n-        Some(&val) => val,\n-        None => bug!(\"Instance `{:?}` not already declared\", instance)\n-    };\n+    let lldecl = cx.instances.borrow().get(&instance).cloned().unwrap_or_else(||\n+        bug!(\"Instance `{:?}` not already declared\", instance));\n \n     cx.stats.borrow_mut().n_closures += 1;\n \n@@ -566,8 +564,8 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n         if declare::get_defined_value(cx, \"main\").is_some() {\n             // FIXME: We should be smart and show a better diagnostic here.\n             cx.sess().struct_span_err(sp, \"entry symbol `main` defined multiple times\")\n-                      .help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\")\n-                      .emit();\n+                     .help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\")\n+                     .emit();\n             cx.sess().abort_if_errors();\n             bug!();\n         }\n@@ -736,9 +734,9 @@ fn determine_cgu_reuse<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             rx: mpsc::Receiver<Box<dyn Any + Send>>)\n-                             -> OngoingCodegen {\n-\n+                               rx: mpsc::Receiver<Box<dyn Any + Send>>)\n+                               -> OngoingCodegen\n+{\n     check_for_rustc_errors_attr(tcx);\n \n     if let Some(true) = tcx.sess.opts.debugging_opts.thinlto {\n@@ -803,8 +801,7 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Run the monomorphization collector and partition the collected items into\n     // codegen units.\n-    let codegen_units =\n-        tcx.collect_and_partition_mono_items(LOCAL_CRATE).1;\n+    let codegen_units = tcx.collect_and_partition_mono_items(LOCAL_CRATE).1;\n     let codegen_units = (*codegen_units).clone();\n \n     // Force all codegen_unit queries so they are already either red or green\n@@ -837,12 +834,7 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         .iter()\n         .any(|(_, list)| {\n             use rustc::middle::dependency_format::Linkage;\n-            list.iter().any(|linkage| {\n-                match linkage {\n-                    Linkage::Dynamic => true,\n-                    _ => false,\n-                }\n-            })\n+            list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n         });\n     let allocator_module = if any_dynamic_crate {\n         None\n@@ -988,7 +980,7 @@ fn collect_and_partition_mono_items<'a, 'tcx>(\n                 if mode_string != \"lazy\" {\n                     let message = format!(\"Unknown codegen-item collection mode '{}'. \\\n                                            Falling back to 'lazy' mode.\",\n-                                           mode_string);\n+                                          mode_string);\n                     tcx.sess.warn(&message);\n                 }\n \n@@ -1123,7 +1115,15 @@ impl CrateInfo {\n             info.load_wasm_imports(tcx, LOCAL_CRATE);\n         }\n \n-        for &cnum in tcx.crates().iter() {\n+        let crates = tcx.crates();\n+\n+        let n_crates = crates.len();\n+        info.native_libraries.reserve(n_crates);\n+        info.crate_name.reserve(n_crates);\n+        info.used_crate_source.reserve(n_crates);\n+        info.missing_lang_items.reserve(n_crates);\n+\n+        for &cnum in crates.iter() {\n             info.native_libraries.insert(cnum, tcx.native_libraries(cnum));\n             info.crate_name.insert(cnum, tcx.crate_name(cnum).to_string());\n             info.used_crate_source.insert(cnum, tcx.used_crate_source(cnum));\n@@ -1165,11 +1165,12 @@ impl CrateInfo {\n     }\n \n     fn load_wasm_imports(&mut self, tcx: TyCtxt, cnum: CrateNum) {\n-        for (&id, module) in tcx.wasm_import_module_map(cnum).iter() {\n+        self.wasm_imports.extend(tcx.wasm_import_module_map(cnum).iter().map(|(&id, module)| {\n             let instance = Instance::mono(tcx, id);\n             let import_name = tcx.symbol_name(instance);\n-            self.wasm_imports.insert(import_name.to_string(), module.clone());\n-        }\n+\n+            (import_name.to_string(), module.clone())\n+        }));\n     }\n }\n "}, {"sha": "df9c4e874bd95b61ce2bdf20d6690c940b7d4e41", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -110,10 +110,10 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n         if self.cx.sess().count_llvm_insns() {\n             *self.cx.stats\n-                .borrow_mut()\n-                .llvm_insns\n-                .entry(category.to_string())\n-                .or_insert(0) += 1;\n+                    .borrow_mut()\n+                    .llvm_insns\n+                    .entry(category.to_string())\n+                    .or_insert(0) += 1;\n         }\n     }\n \n@@ -735,9 +735,9 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     pub fn inline_asm_call(&self, asm: *const c_char, cons: *const c_char,\n-                         inputs: &[&'ll Value], output: &'ll Type,\n-                         volatile: bool, alignstack: bool,\n-                         dia: AsmDialect) -> Option<&'ll Value> {\n+                           inputs: &[&'ll Value], output: &'ll Type,\n+                           volatile: bool, alignstack: bool,\n+                           dia: AsmDialect) -> Option<&'ll Value> {\n         self.count_insn(\"inlineasm\");\n \n         let volatile = if volatile { llvm::True }\n@@ -1093,7 +1093,7 @@ impl Builder<'a, 'll, 'tcx> {\n     ) -> &'ll Value {\n         unsafe {\n             llvm::LLVMRustBuildAtomicCmpXchg(self.llbuilder, dst, cmp, src,\n-                                         order, failure_order, weak)\n+                                             order, failure_order, weak)\n         }\n     }\n     pub fn atomic_rmw(\n@@ -1194,7 +1194,7 @@ impl Builder<'a, 'll, 'tcx> {\n             })\n             .collect();\n \n-        return Cow::Owned(casted_args);\n+        Cow::Owned(casted_args)\n     }\n \n     pub fn lifetime_start(&self, ptr: &'ll Value, size: Size) {"}, {"sha": "c08937fa9b9162669bcb04f021cbde86c2aa6736", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -336,16 +336,13 @@ pub fn langcall(tcx: TyCtxt,\n                 msg: &str,\n                 li: LangItem)\n                 -> DefId {\n-    match tcx.lang_items().require(li) {\n-        Ok(id) => id,\n-        Err(s) => {\n-            let msg = format!(\"{} {}\", msg, s);\n-            match span {\n-                Some(span) => tcx.sess.span_fatal(span, &msg[..]),\n-                None => tcx.sess.fatal(&msg[..]),\n-            }\n+    tcx.lang_items().require(li).unwrap_or_else(|s| {\n+        let msg = format!(\"{} {}\", msg, s);\n+        match span {\n+            Some(span) => tcx.sess.span_fatal(span, &msg[..]),\n+            None => tcx.sess.fatal(&msg[..]),\n         }\n-    }\n+    })\n }\n \n // To avoid UB from LLVM, these two functions mask RHS with an"}, {"sha": "9228870bf3a5c2105d84fe298aca420e165524fb", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -124,7 +124,7 @@ pub fn get_static(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll Value {\n     assert!(!defined_in_current_codegen_unit,\n             \"consts::get_static() should always hit the cache for \\\n              statics defined in the same CGU, but did not for `{:?}`\",\n-             def_id);\n+            def_id);\n \n     let ty = instance.ty(cx.tcx);\n     let sym = cx.tcx.symbol_name(instance).as_str();\n@@ -249,14 +249,13 @@ fn check_and_apply_linkage(\n         // extern \"C\" fn() from being non-null, so we can't just declare a\n         // static and call it a day. Some linkages (like weak) will make it such\n         // that the static actually has a null value.\n-        let llty2 = match ty.sty {\n-            ty::RawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n-            _ => {\n-                if span.is_some() {\n-                    cx.sess().span_fatal(span.unwrap(), \"must have type `*const T` or `*mut T`\")\n-                } else {\n-                    bug!(\"must have type `*const T` or `*mut T`\")\n-                }\n+        let llty2 = if let ty::RawPtr(ref mt) = ty.sty {\n+            cx.layout_of(mt.ty).llvm_type(cx)\n+        } else {\n+            if let Some(span) = span {\n+                cx.sess().span_fatal(span, \"must have type `*const T` or `*mut T`\")\n+            } else {\n+                bug!(\"must have type `*const T` or `*mut T`\")\n             }\n         };\n         unsafe {\n@@ -273,9 +272,9 @@ fn check_and_apply_linkage(\n             let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n             real_name.push_str(&sym);\n             let g2 = declare::define_global(cx, &real_name, llty).unwrap_or_else(||{\n-                if span.is_some() {\n+                if let Some(span) = span {\n                     cx.sess().span_fatal(\n-                        span.unwrap(),\n+                        span,\n                         &format!(\"symbol `{}` is already defined\", &sym)\n                     )\n                 } else {"}, {"sha": "208649c143afe72f95f3b9d85d72f266ace5024b", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -59,8 +59,8 @@ pub struct CodegenCx<'a, 'tcx: 'a> {\n     /// Cache instances of monomorphic and polymorphic items\n     pub instances: RefCell<FxHashMap<Instance<'tcx>, &'a Value>>,\n     /// Cache generated vtables\n-    pub vtables: RefCell<FxHashMap<(Ty<'tcx>,\n-                                Option<ty::PolyExistentialTraitRef<'tcx>>), &'a Value>>,\n+    pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>),\n+                                   &'a Value>>,\n     /// Cache of constant strings,\n     pub const_cstr_cache: RefCell<FxHashMap<LocalInternedString, &'a Value>>,\n \n@@ -213,9 +213,9 @@ pub unsafe fn create_module(\n \n impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n     crate fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               codegen_unit: Arc<CodegenUnit<'tcx>>,\n-               llvm_module: &'a ::ModuleLlvm)\n-               -> CodegenCx<'a, 'tcx> {\n+                 codegen_unit: Arc<CodegenUnit<'tcx>>,\n+                 llvm_module: &'a ::ModuleLlvm)\n+                 -> CodegenCx<'a, 'tcx> {\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n         // attributes in LLVM IR as well as native dependencies (in C these\n@@ -270,8 +270,8 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n         let dbg_cx = if tcx.sess.opts.debuginfo != DebugInfo::None {\n             let dctx = debuginfo::CrateDebugContext::new(llmod);\n             debuginfo::metadata::compile_unit_metadata(tcx,\n-                                                        &codegen_unit.name().as_str(),\n-                                                        &dctx);\n+                                                       &codegen_unit.name().as_str(),\n+                                                       &dctx);\n             Some(dctx)\n         } else {\n             None\n@@ -318,10 +318,8 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n         if let Some(v) = self.intrinsics.borrow().get(key).cloned() {\n             return v;\n         }\n-        match declare_intrinsic(self, key) {\n-            Some(v) => return v,\n-            None => bug!(\"unknown intrinsic '{}'\", key)\n-        }\n+\n+        declare_intrinsic(self, key).unwrap_or_else(|| bug!(\"unknown intrinsic '{}'\", key))\n     }\n \n     /// Generate a new symbol name with the given prefix. This symbol name must\n@@ -465,9 +463,10 @@ impl LayoutOf for &'a CodegenCx<'ll, 'tcx> {\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         self.tcx.layout_of(ty::ParamEnv::reveal_all().and(ty))\n-            .unwrap_or_else(|e| match e {\n-                LayoutError::SizeOverflow(_) => self.sess().fatal(&e.to_string()),\n-                _ => bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+            .unwrap_or_else(|e| if let LayoutError::SizeOverflow(_) = e {\n+                self.sess().fatal(&e.to_string())\n+            } else {\n+                bug!(\"failed to get layout for `{}`: {}\", ty, e)\n             })\n     }\n }\n@@ -772,5 +771,6 @@ fn declare_intrinsic(cx: &CodegenCx<'ll, '_>, key: &str) -> Option<&'ll Value> {\n         ifn!(\"llvm.dbg.declare\", fn(Type::metadata(cx), Type::metadata(cx)) -> void);\n         ifn!(\"llvm.dbg.value\", fn(Type::metadata(cx), t_i64, Type::metadata(cx)) -> void);\n     }\n-    return None;\n+\n+    None\n }"}, {"sha": "842bdf3cb493ff1b01772c5d4026c8388ae440e3", "filename": "src/librustc_codegen_llvm/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fglue.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -97,8 +97,8 @@ pub fn size_and_align_of_dst(bx: &Builder<'_, 'll, 'tcx>, t: Ty<'tcx>, info: Opt\n                     C_usize(cx, std::cmp::max(sized_align, unsized_align) as u64)\n                 }\n                 _ => bx.select(bx.icmp(llvm::IntUGT, sized_align, unsized_align),\n-                                sized_align,\n-                                unsized_align)\n+                               sized_align,\n+                               unsized_align)\n             };\n \n             // Issue #27023: must add any necessary padding to `size`"}, {"sha": "272196afa6f92bdf6ce3ee50a99b6170abe269ff", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 72, "deletions": 94, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -115,8 +115,8 @@ pub fn codegen_intrinsic_call(\n     let llval = match name {\n         _ if simple.is_some() => {\n             bx.call(simple.unwrap(),\n-                     &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n-                     None)\n+                    &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n+                    None)\n         }\n         \"unreachable\" => {\n             return;\n@@ -373,7 +373,6 @@ pub fn codegen_intrinsic_call(\n                     return;\n                 }\n             }\n-\n         },\n         \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n             let sty = &arg_tys[0].sty;\n@@ -540,10 +539,9 @@ pub fn codegen_intrinsic_call(\n         }\n \n         _ => {\n-            let intr = match Intrinsic::find(&name) {\n-                Some(intr) => intr,\n-                None => bug!(\"unknown intrinsic '{}'\", name),\n-            };\n+            let intr = Intrinsic::find(&name).unwrap_or_else(||\n+                bug!(\"unknown intrinsic '{}'\", name));\n+\n             fn one<T>(x: Vec<T>) -> T {\n                 assert_eq!(x.len(), 1);\n                 x.into_iter().next().unwrap()\n@@ -822,8 +820,7 @@ fn codegen_msvc_try(\n         let i64p = Type::i64(cx).ptr_to();\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         let slot = bx.alloca(i64p, \"slot\", ptr_align);\n-        bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n-            None);\n+        bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n         normal.ret(C_i32(cx, 0));\n \n@@ -911,8 +908,7 @@ fn codegen_gnu_try(\n         // being thrown.  The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n         // rust_try ignores the selector.\n-        let lpad_ty = Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)],\n-                                    false);\n+        let lpad_ty = Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)], false);\n         let vals = catch.landing_pad(lpad_ty, bx.cx.eh_personality(), 1);\n         catch.add_clause(vals, C_null(Type::i8p(cx)));\n         let ptr = catch.extract_value(vals, 0);\n@@ -976,7 +972,7 @@ fn get_rust_try_fn<'ll, 'tcx>(\n     let output = tcx.types.i32;\n     let rust_try = gen_fn(cx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, codegen);\n     cx.rust_try_fn.set(Some(rust_try));\n-    return rust_try\n+    rust_try\n }\n \n fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n@@ -1000,11 +996,11 @@ fn generic_simd_intrinsic(\n         ($msg: tt, $($fmt: tt)*) => {\n             span_invalid_monomorphization_error(\n                 bx.sess(), span,\n-                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \",\n-                                 $msg),\n+                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n                          name, $($fmt)*));\n         }\n     }\n+\n     macro_rules! return_error {\n         ($($fmt: tt)*) => {\n             {\n@@ -1021,14 +1017,13 @@ fn generic_simd_intrinsic(\n             }\n         };\n     }\n+\n     macro_rules! require_simd {\n         ($ty: expr, $position: expr) => {\n             require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n         }\n     }\n \n-\n-\n     let tcx = bx.tcx();\n     let sig = tcx.normalize_erasing_late_bound_regions(\n         ty::ParamEnv::reveal_all(),\n@@ -1075,11 +1070,8 @@ fn generic_simd_intrinsic(\n     }\n \n     if name.starts_with(\"simd_shuffle\") {\n-        let n: usize = match name[\"simd_shuffle\".len()..].parse() {\n-            Ok(n) => n,\n-            Err(_) => span_bug!(span,\n-                                \"bad `simd_shuffle` instruction only caught in codegen?\")\n-        };\n+        let n: usize = name[\"simd_shuffle\".len()..].parse().unwrap_or_else(|_|\n+            span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\"));\n \n         require_simd!(ret_ty, \"return\");\n \n@@ -1121,17 +1113,17 @@ fn generic_simd_intrinsic(\n         };\n \n         return Ok(bx.shuffle_vector(args[0].immediate(),\n-                                     args[1].immediate(),\n-                                     C_vector(&indices)))\n+                                    args[1].immediate(),\n+                                    C_vector(&indices)))\n     }\n \n     if name == \"simd_insert\" {\n         require!(in_elem == arg_tys[2],\n                  \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n                  in_elem, in_ty, arg_tys[2]);\n         return Ok(bx.insert_element(args[0].immediate(),\n-                                     args[2].immediate(),\n-                                     args[1].immediate()))\n+                                    args[2].immediate(),\n+                                    args[1].immediate()))\n     }\n     if name == \"simd_extract\" {\n         require!(ret_ty == in_elem,\n@@ -1150,9 +1142,7 @@ fn generic_simd_intrinsic(\n         );\n         match m_elem_ty.sty {\n             ty::Int(_) => {},\n-            _ => {\n-                return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty);\n-            }\n+            _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty)\n         }\n         // truncate the mask to a vector of i1s\n         let i1 = Type::i1(bx.cx);\n@@ -1177,8 +1167,7 @@ fn generic_simd_intrinsic(\n             ($msg: tt, $($fmt: tt)*) => {\n                 span_invalid_monomorphization_error(\n                     bx.sess(), span,\n-                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \",\n-                                     $msg),\n+                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n                              name, $($fmt)*));\n             }\n         }\n@@ -1223,63 +1212,53 @@ fn generic_simd_intrinsic(\n                         &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n                         None);\n         unsafe { llvm::LLVMRustSetHasUnsafeAlgebra(c) };\n-        return Ok(c);\n-    }\n-\n-    if name == \"simd_fsqrt\" {\n-        return simd_simple_float_intrinsic(\"sqrt\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fsin\" {\n-        return simd_simple_float_intrinsic(\"sin\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fcos\" {\n-        return simd_simple_float_intrinsic(\"cos\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fabs\" {\n-        return simd_simple_float_intrinsic(\"fabs\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_floor\" {\n-        return simd_simple_float_intrinsic(\"floor\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_ceil\" {\n-        return simd_simple_float_intrinsic(\"ceil\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fexp\" {\n-        return simd_simple_float_intrinsic(\"exp\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fexp2\" {\n-        return simd_simple_float_intrinsic(\"exp2\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_flog10\" {\n-        return simd_simple_float_intrinsic(\"log10\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_flog2\" {\n-        return simd_simple_float_intrinsic(\"log2\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_flog\" {\n-        return simd_simple_float_intrinsic(\"log\", in_elem, in_ty, in_len, bx, span, args);\n+        Ok(c)\n     }\n \n-    if name == \"simd_fpowi\" {\n-        return simd_simple_float_intrinsic(\"powi\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fpow\"  {\n-        return simd_simple_float_intrinsic(\"pow\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fma\" {\n-        return simd_simple_float_intrinsic(\"fma\", in_elem, in_ty, in_len, bx, span, args);\n+    match name {\n+        \"simd_fsqrt\" => {\n+            return simd_simple_float_intrinsic(\"sqrt\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fsin\" => {\n+            return simd_simple_float_intrinsic(\"sin\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fcos\" => {\n+            return simd_simple_float_intrinsic(\"cos\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fabs\" => {\n+            return simd_simple_float_intrinsic(\"fabs\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_floor\" => {\n+            return simd_simple_float_intrinsic(\"floor\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_ceil\" => {\n+            return simd_simple_float_intrinsic(\"ceil\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fexp\" => {\n+            return simd_simple_float_intrinsic(\"exp\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fexp2\" => {\n+            return simd_simple_float_intrinsic(\"exp2\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_flog10\" => {\n+            return simd_simple_float_intrinsic(\"log10\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_flog2\" => {\n+            return simd_simple_float_intrinsic(\"log2\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_flog\" => {\n+            return simd_simple_float_intrinsic(\"log\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fpowi\" => {\n+            return simd_simple_float_intrinsic(\"powi\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fpow\" => {\n+            return simd_simple_float_intrinsic(\"pow\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fma\" => {\n+            return simd_simple_float_intrinsic(\"fma\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        _ => { /* fallthrough */ }\n     }\n \n     // FIXME: use:\n@@ -1312,7 +1291,7 @@ fn generic_simd_intrinsic(\n     }\n \n \n-    if name == \"simd_gather\"  {\n+    if name == \"simd_gather\" {\n         // simd_gather(values: <N x T>, pointers: <N x *_ T>,\n         //             mask: <N x i{M}>) -> <N x T>\n         // * N: number of elements in the input vectors\n@@ -1360,7 +1339,7 @@ fn generic_simd_intrinsic(\n         // to the element type of the first argument\n         let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).sty {\n             ty::RawPtr(p) if p.ty == in_elem => (ptr_count(arg_tys[1].simd_type(tcx)),\n-                                                   non_ptr(arg_tys[1].simd_type(tcx))),\n+                                                 non_ptr(arg_tys[1].simd_type(tcx))),\n             _ => {\n                 require!(false, \"expected element type `{}` of second argument `{}` \\\n                                  to be a pointer to the element type `{}` of the first \\\n@@ -1371,7 +1350,7 @@ fn generic_simd_intrinsic(\n             }\n         };\n         assert!(pointer_count > 0);\n-        assert!(pointer_count - 1 == ptr_count(arg_tys[0].simd_type(tcx)));\n+        assert_eq!(pointer_count - 1, ptr_count(arg_tys[0].simd_type(tcx)));\n         assert_eq!(underlying_ty, non_ptr(arg_tys[0].simd_type(tcx)));\n \n         // The element type of the third argument must be a signed integer type of any width:\n@@ -1414,7 +1393,7 @@ fn generic_simd_intrinsic(\n         return Ok(v);\n     }\n \n-    if name == \"simd_scatter\"  {\n+    if name == \"simd_scatter\" {\n         // simd_scatter(values: <N x T>, pointers: <N x *mut T>,\n         //             mask: <N x i{M}>) -> ()\n         // * N: number of elements in the input vectors\n@@ -1468,7 +1447,7 @@ fn generic_simd_intrinsic(\n             }\n         };\n         assert!(pointer_count > 0);\n-        assert!(pointer_count - 1 == ptr_count(arg_tys[0].simd_type(tcx)));\n+        assert_eq!(pointer_count - 1, ptr_count(arg_tys[0].simd_type(tcx)));\n         assert_eq!(underlying_ty, non_ptr(arg_tys[0].simd_type(tcx)));\n \n         // The element type of the third argument must be a signed integer type of any width:\n@@ -1570,7 +1549,6 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                                     )\n                                 }\n                             }\n-\n                         };\n                         Ok(bx.$float_reduce(acc, args[0].immediate()))\n                     }\n@@ -1750,9 +1728,9 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     _ => {},\n                 }\n                 require!(false,\n-                            \"unsupported operation on `{}` with element `{}`\",\n-                            in_ty,\n-                            in_elem)\n+                         \"unsupported operation on `{}` with element `{}`\",\n+                         in_ty,\n+                         in_elem)\n             })*\n         }\n     }"}, {"sha": "63a8ab077e5ae494c90d00c14ce0b24da08288a0", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -306,7 +306,7 @@ impl ModuleCodegen {\n         };\n         let bytecode_compressed = if emit_bc_compressed {\n             Some(outputs.temp_path(OutputType::Bitcode, Some(&self.name))\n-                    .with_extension(RLIB_BYTECODE_EXTENSION))\n+                        .with_extension(RLIB_BYTECODE_EXTENSION))\n         } else {\n             None\n         };"}, {"sha": "8456cf2f4805912400e12160e8fc41183139ca33", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -52,8 +52,9 @@ fn require_inited() {\n }\n \n unsafe fn configure_llvm(sess: &Session) {\n-    let mut llvm_c_strs = Vec::new();\n-    let mut llvm_args = Vec::new();\n+    let n_args = sess.opts.cg.llvm_args.len();\n+    let mut llvm_c_strs = Vec::with_capacity(n_args + 1);\n+    let mut llvm_args = Vec::with_capacity(n_args + 1);\n \n     {\n         let mut add = |arg: &str| {"}, {"sha": "7752465d885bbff47574b533b7bc8cc4f669af29", "filename": "src/librustc_codegen_llvm/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmetadata.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -63,7 +63,7 @@ impl MetadataLoader for LlvmMetadataLoader {\n             let of = ObjectFile::new(mb)\n                 .map(|of| OwningRef::new(box of))\n                 .ok_or_else(|| format!(\"provided path not an object file: '{}'\",\n-                                        filename.display()))?;\n+                                       filename.display()))?;\n             let buf = of.try_map(|of| search_meta_section(of, target, filename))?;\n             Ok(rustc_erase_owner!(buf))\n         }"}, {"sha": "a0d6cc4629589da5572e08bfac18c963e6e1ab70", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -151,9 +151,9 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n     }\n \n     fn visit_place(&mut self,\n-                    place: &mir::Place<'tcx>,\n-                    context: PlaceContext<'tcx>,\n-                    location: Location) {\n+                   place: &mir::Place<'tcx>,\n+                   context: PlaceContext<'tcx>,\n+                   location: Location) {\n         debug!(\"visit_place(place={:?}, context={:?})\", place, context);\n         let cx = self.fx.cx;\n "}, {"sha": "5be176f75c96a7ef88ed3b31d18b5ed92d8fa29c", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -49,9 +49,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n \n     fn codegen_terminator(&mut self,\n-                        mut bx: Builder<'a, 'll, 'tcx>,\n-                        bb: mir::BasicBlock,\n-                        terminator: &mir::Terminator<'tcx>)\n+                          mut bx: Builder<'a, 'll, 'tcx>,\n+                          bb: mir::BasicBlock,\n+                          terminator: &mir::Terminator<'tcx>)\n     {\n         debug!(\"codegen_terminator: {:?}\", terminator);\n "}, {"sha": "dab9b147cc0708d055dba215493bbc6d58842f12", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -108,8 +108,8 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n         match *self.as_mono_item() {\n             MonoItem::Fn(instance) => {\n                 format!(\"Fn({:?}, {})\",\n-                         instance.def,\n-                         instance.substs.as_ptr() as usize)\n+                        instance.def,\n+                        instance.substs.as_ptr() as usize)\n             }\n             MonoItem::Static(id) => {\n                 format!(\"Static({:?})\", id)"}, {"sha": "03ded64e642355706e8c7b5471028a0ec8a5e30e", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -65,13 +65,12 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             let mut name = String::with_capacity(32);\n             let printer = DefPathBasedNames::new(cx.tcx, true, true);\n             printer.push_type_name(layout.ty, &mut name);\n-            match (&layout.ty.sty, &layout.variants) {\n-                (&ty::Adt(def, _), &layout::Variants::Single { index }) => {\n-                    if def.is_enum() && !def.variants.is_empty() {\n-                        write!(&mut name, \"::{}\", def.variants[index].name).unwrap();\n-                    }\n+            if let (&ty::Adt(def, _), &layout::Variants::Single { index })\n+                 = (&layout.ty.sty, &layout.variants)\n+            {\n+                if def.is_enum() && !def.variants.is_empty() {\n+                    write!(&mut name, \"::{}\", def.variants[index].name).unwrap();\n                 }\n-                _ => {}\n             }\n             Some(name)\n         }\n@@ -132,7 +131,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n         debug!(\"struct_llfields: {}: {:?} offset: {:?} target_offset: {:?} \\\n                 effective_field_align: {}\",\n-            i, field, offset, target_offset, effective_field_align.abi());\n+               i, field, offset, target_offset, effective_field_align.abi());\n         assert!(target_offset >= offset);\n         let padding = target_offset - offset;\n         let padding_align = prev_effective_align.min(effective_field_align);\n@@ -155,7 +154,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n                padding, offset, layout.size);\n         result.push(Type::padding_filler(cx, padding, padding_align));\n-        assert!(result.len() == 1 + field_count * 2);\n+        assert_eq!(result.len(), 1 + field_count * 2);\n     } else {\n         debug!(\"struct_llfields: offset: {:?} stride: {:?}\",\n                offset, layout.size);"}, {"sha": "4bf5b09baa6294ffbfd022bdb4bc8e5646f3cdfa", "filename": "src/librustc_codegen_llvm/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b4150c042b06c46e29a9d12101f91fe13996e0/src%2Flibrustc_codegen_llvm%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fvalue.rs?ref=b8b4150c042b06c46e29a9d12101f91fe13996e0", "patch": "@@ -34,6 +34,6 @@ impl fmt::Debug for Value {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(&llvm::build_string(|s| unsafe {\n             llvm::LLVMRustWriteValueToString(self, s);\n-        }).expect(\"nun-UTF8 value description from LLVM\"))\n+        }).expect(\"non-UTF8 value description from LLVM\"))\n     }\n }"}]}