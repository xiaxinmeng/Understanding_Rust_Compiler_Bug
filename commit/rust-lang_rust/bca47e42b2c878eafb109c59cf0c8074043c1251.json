{"sha": "bca47e42b2c878eafb109c59cf0c8074043c1251", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYTQ3ZTQyYjJjODc4ZWFmYjEwOWM1OWNmMGM4MDc0MDQzYzEyNTE=", "commit": {"author": {"name": "Dustin Speckhals", "email": "dustin1114@gmail.com", "date": "2017-10-24T23:37:15Z"}, "committer": {"name": "Dustin Speckhals", "email": "dustin1114@gmail.com", "date": "2017-10-24T23:37:15Z"}, "message": "Merge branch 'master' into update-rls-data-for-save-analysis", "tree": {"sha": "968a99f37f9099c4ed0b68b8020400322e94b667", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/968a99f37f9099c4ed0b68b8020400322e94b667"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bca47e42b2c878eafb109c59cf0c8074043c1251", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bca47e42b2c878eafb109c59cf0c8074043c1251", "html_url": "https://github.com/rust-lang/rust/commit/bca47e42b2c878eafb109c59cf0c8074043c1251", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bca47e42b2c878eafb109c59cf0c8074043c1251/comments", "author": {"login": "DSpeckhals", "id": 3310769, "node_id": "MDQ6VXNlcjMzMTA3Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/3310769?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DSpeckhals", "html_url": "https://github.com/DSpeckhals", "followers_url": "https://api.github.com/users/DSpeckhals/followers", "following_url": "https://api.github.com/users/DSpeckhals/following{/other_user}", "gists_url": "https://api.github.com/users/DSpeckhals/gists{/gist_id}", "starred_url": "https://api.github.com/users/DSpeckhals/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DSpeckhals/subscriptions", "organizations_url": "https://api.github.com/users/DSpeckhals/orgs", "repos_url": "https://api.github.com/users/DSpeckhals/repos", "events_url": "https://api.github.com/users/DSpeckhals/events{/privacy}", "received_events_url": "https://api.github.com/users/DSpeckhals/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DSpeckhals", "id": 3310769, "node_id": "MDQ6VXNlcjMzMTA3Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/3310769?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DSpeckhals", "html_url": "https://github.com/DSpeckhals", "followers_url": "https://api.github.com/users/DSpeckhals/followers", "following_url": "https://api.github.com/users/DSpeckhals/following{/other_user}", "gists_url": "https://api.github.com/users/DSpeckhals/gists{/gist_id}", "starred_url": "https://api.github.com/users/DSpeckhals/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DSpeckhals/subscriptions", "organizations_url": "https://api.github.com/users/DSpeckhals/orgs", "repos_url": "https://api.github.com/users/DSpeckhals/repos", "events_url": "https://api.github.com/users/DSpeckhals/events{/privacy}", "received_events_url": "https://api.github.com/users/DSpeckhals/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69ba6738eb6bf9b6d11ebb81af2599648eb0bc04", "url": "https://api.github.com/repos/rust-lang/rust/commits/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04", "html_url": "https://github.com/rust-lang/rust/commit/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04"}, {"sha": "c2799fc9a5c631a790744ceb9cd08259af338c0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2799fc9a5c631a790744ceb9cd08259af338c0c", "html_url": "https://github.com/rust-lang/rust/commit/c2799fc9a5c631a790744ceb9cd08259af338c0c"}], "stats": {"total": 21891, "additions": 15135, "deletions": 6756}, "files": [{"sha": "c76e17a27d188c264686e3225d8260398f318a51", "filename": ".travis.yml", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -12,7 +12,7 @@ matrix:\n   fast_finish: true\n   include:\n     # Images used in testing PR and try-build should be run first.\n-    - env: IMAGE=x86_64-gnu-llvm-3.7 RUST_BACKTRACE=1\n+    - env: IMAGE=x86_64-gnu-llvm-3.9 RUST_BACKTRACE=1\n       if: type = pull_request OR branch = auto\n \n     - env: IMAGE=dist-x86_64-linux DEPLOY=1\n@@ -36,7 +36,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode7\n+      osx_image: xcode7.3\n       if: branch = auto\n \n     # macOS builders. These are placed near the beginning because they are very\n@@ -57,7 +57,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode8.2\n+      osx_image: xcode8.3\n       if: branch = auto\n \n     - env: >\n@@ -71,7 +71,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode8.2\n+      osx_image: xcode8.3\n       if: branch = auto\n \n     # OSX builders producing releases. These do not run the full test suite and\n@@ -91,7 +91,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode7\n+      osx_image: xcode7.3\n       if: branch = auto\n \n     - env: >\n@@ -105,7 +105,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode7\n+      osx_image: xcode7.3\n       if: branch = auto\n \n     # Linux builders, remaining docker images\n@@ -115,6 +115,8 @@ matrix:\n       if: branch = auto\n     - env: IMAGE=cross DEPLOY=1\n       if: branch = auto\n+    - env: IMAGE=cross2 DEPLOY=1\n+      if: branch = auto\n     - env: IMAGE=dist-aarch64-linux DEPLOY=1\n       if: branch = auto\n     - env: IMAGE=dist-android DEPLOY=1\n@@ -125,8 +127,6 @@ matrix:\n       if: branch = auto\n     - env: IMAGE=dist-armv7-linux DEPLOY=1\n       if: branch = auto\n-    - env: IMAGE=dist-fuchsia DEPLOY=1\n-      if: branch = auto\n     - env: IMAGE=dist-i586-gnu-i686-musl DEPLOY=1\n       if: branch = auto\n     - env: IMAGE=dist-i686-freebsd DEPLOY=1"}, {"sha": "d42476bc4130dd8e1b14d23ce936de657955debe", "filename": "CODE_OF_CONDUCT.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/CODE_OF_CONDUCT.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/CODE_OF_CONDUCT.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CODE_OF_CONDUCT.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -6,7 +6,7 @@ A version of this document [can be found online](https://www.rust-lang.org/condu\n \n **Contact**: [rust-mods@rust-lang.org](mailto:rust-mods@rust-lang.org)\n \n-* We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.\n+* We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.\n * On IRC, please avoid using overtly sexual nicknames or other nicknames that might detract from a friendly, safe and welcoming environment for all.\n * Please be kind and courteous. There's no need to be mean or rude.\n * Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer."}, {"sha": "4c296a28e90b4a2f8e19b8e6bfefe5a61040feef", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 114, "deletions": 2, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -360,8 +360,120 @@ git add path/to/submodule\n \n outside the submodule.\n \n-It can also be more convenient during development to set `submodules = false`\n-in the `config.toml` to prevent `x.py` from resetting to the original branch.\n+In order to prepare your PR, you can run the build locally by doing\n+`./x.py build src/tools/TOOL`. If you will be editing the sources\n+there, you may wish to set `submodules = false` in the `config.toml`\n+to prevent `x.py` from resetting to the original branch.\n+\n+#### Breaking Tools Built With The Compiler\n+[breaking-tools-built-with-the-compiler]: #breaking-tools-built-with-the-compiler\n+\n+Rust's build system builds a number of tools that make use of the\n+internals of the compiler. This includes clippy,\n+[RLS](https://github.com/rust-lang-nursery/rls) and\n+[rustfmt](https://github.com/rust-lang-nursery/rustfmt). If these tools\n+break because of your changes, you may run into a sort of \"chicken and egg\"\n+problem. These tools rely on the latest compiler to be built so you can't update\n+them to reflect your changes to the compiler until those changes are merged into\n+the compiler. At the same time, you can't get your changes merged into the compiler\n+because the rust-lang/rust build won't pass until those tools build and pass their\n+tests.\n+\n+That means that, in the default state, you can't update the compiler without first\n+fixing rustfmt, rls and the other tools that the compiler builds.\n+\n+Luckily, a feature was [added to Rust's build](https://github.com/rust-lang/rust/pull/45243)\n+to make all of this easy to handle. The idea is that you mark the tools as \"broken\",\n+so that the rust-lang/rust build passes without trying to build them, then land the change\n+in the compiler, wait for a nightly, and go update the tools that you broke. Once you're done\n+and the tools are working again, you go back in the compiler and change the tools back\n+from \"broken\".\n+\n+This should avoid a bunch of synchronization dances and is also much easier on contributors as\n+there's no need to block on rls/rustfmt/other tools changes going upstream.\n+\n+Here are those same steps in detail:\n+\n+1. (optional) First, if it doesn't exist already, create a `config.toml` by copying\n+   `config.toml.example` in the root directory of the Rust repository.\n+   Set `submodules = false` in the `[build]` section. This will prevent `x.py`\n+   from resetting to the original branch after you make your changes. If you\n+   need to [update any submodules to their latest versions][updating-submodules],\n+   see the section of this file about that for more information.\n+2. (optional) Run `./x.py test src/tools/rustfmt` (substituting the submodule\n+   that broke for `rustfmt`). Fix any errors in the submodule (and possibly others).\n+3. (optional) Make commits for your changes and send them to upstream repositories as a PR.\n+4. (optional) Maintainers of these submodules will **not** merge the PR. The PR can't be\n+   merged because CI will be broken. You'll want to write a message on the PR referencing\n+   your change, and how the PR should be merged once your change makes it into a nightly.\n+5. Update `src/tools/toolstate.toml` to indicate that the tool in question is \"broken\",\n+   that will disable building it on CI. See the documentation in that file for the exact\n+   configuration values you can use.\n+6. Commit the changes to `src/tools/toolstate.toml`, **do not update submodules in your commit**,\n+   and then update the PR you have for rust-lang/rust.\n+7. Wait for your PR to merge.\n+8. Wait for a nightly\n+9. (optional) Help land your PR on the upstream repository now that your changes are in nightly.\n+10. (optional) Send a PR to rust-lang/rust updating the submodule, reverting `src/tools/toolstate.toml` back to a \"building\" or \"testing\" state.\n+\n+#### Updating submodules\n+[updating-submodules]: #updating-submodules\n+\n+These instructions are specific to updating `rustfmt`, however they may apply\n+to the other submodules as well. Please help by improving these instructions\n+if you find any discrepencies or special cases that need to be addressed.\n+\n+To update the `rustfmt` submodule, start by running the appropriate\n+[`git submodule` command](https://git-scm.com/book/en/v2/Git-Tools-Submodules).\n+For example, to update to the latest commit on the remote master branch,\n+you may want to run:\n+```\n+git submodule update --remote src/tools/rustfmt\n+```\n+If you run `./x.py build` now, and you are lucky, it may just work. If you see\n+an error message about patches that did not resolve to any crates, you will need\n+to complete a few more steps which are outlined with their rationale below.\n+\n+*(This error may change in the future to include more information.)*\n+```\n+error: failed to resolve patches for `https://github.com/rust-lang-nursery/rustfmt`\n+\n+Caused by:\n+  patch for `rustfmt-nightly` in `https://github.com/rust-lang-nursery/rustfmt` did not resolve to any crates\n+failed to run: ~/rust/build/x86_64-unknown-linux-gnu/stage0/bin/cargo build --manifest-path ~/rust/src/bootstrap/Cargo.toml\n+```\n+\n+If you haven't used the `[patch]`\n+section of `Cargo.toml` before, there is [some relevant documentation about it\n+in the cargo docs](http://doc.crates.io/manifest.html#the-patch-section). In\n+addition to that, you should read the \n+[Overriding dependencies](http://doc.crates.io/specifying-dependencies.html#overriding-dependencies)\n+section of the documentation as well.\n+\n+Specifically, the following [section in Overriding dependencies](http://doc.crates.io/specifying-dependencies.html#testing-a-bugfix) reveals what the problem is:\n+\n+> Next up we need to ensure that our lock file is updated to use this new version of uuid so our project uses the locally checked out copy instead of one from crates.io. The way [patch] works is that it'll load the dependency at ../path/to/uuid and then whenever crates.io is queried for versions of uuid it'll also return the local version.\n+> \n+> This means that the version number of the local checkout is significant and will affect whether the patch is used. Our manifest declared uuid = \"1.0\" which means we'll only resolve to >= 1.0.0, < 2.0.0, and Cargo's greedy resolution algorithm also means that we'll resolve to the maximum version within that range. Typically this doesn't matter as the version of the git repository will already be greater or match the maximum version published on crates.io, but it's important to keep this in mind!\n+\n+This says that when we updated the submodule, the version number in our\n+`src/tools/rustfmt/Cargo.toml` changed. The new version is different from\n+the version in `Cargo.lock`, so the build can no longer continue.\n+\n+To resolve this, we need to update `Cargo.lock`. Luckily, cargo provides a\n+command to do this easily.\n+\n+First, go into the `src/` directory since that is where `Cargo.toml` is in\n+the rust repository. Then run, `cargo update -p rustfmt-nightly` to solve\n+the problem.\n+\n+```\n+$ cd src\n+$ cargo update -p rustfmt-nightly\n+```\n+\n+This should change the version listed in `src/Cargo.lock` to the new version you updated\n+the submodule to. Running `./x.py build` should work now.\n \n ## Writing Documentation\n [writing-documentation]: #writing-documentation"}, {"sha": "4fc003036e9b3601a79f18815dd48385d3e97f04", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -16,6 +16,7 @@ Read [\"Installation\"] from [The Book].\n ## Building from Source\n [building-from-source]: #building-from-source\n \n+### Building on *nix\n 1. Make sure you have installed the dependencies:\n \n    * `g++` 4.7 or later or `clang++` 3.x or later\n@@ -193,7 +194,7 @@ Snapshot binaries are currently built and tested on several platforms:\n You may find that other platforms work, but these are our officially\n supported build environments that are most likely to work.\n \n-Rust currently needs between 600MiB and 1.5GiB to build, depending on platform.\n+Rust currently needs between 600MiB and 1.5GiB of RAM to build, depending on platform.\n If it hits swap, it will take a very long time to build.\n \n There is more advice about hacking on Rust in [CONTRIBUTING.md]."}, {"sha": "194745d9caad4062dbf1593703c72f0a76aeabb6", "filename": "RELEASES.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -3,19 +3,19 @@ Version 1.21.0 (2017-10-12)\n \n Language\n --------\n-- [Relaxed path syntax. You can now add type parameters to values][43540]\n-  Example:\n-  ```rust\n-  my_macro!(Vec<i32>::new); // Always worked\n-  my_macro!(Vec::<i32>::new); // Now works\n-  ```\n - [You can now use static references for literals.][43838]\n   Example:\n   ```rust\n   fn main() {\n       let x: &'static u32 = &0;\n   }\n   ```\n+- [Relaxed path syntax. Optional `::` before `<` is now allowed in all contexts.][43540]\n+  Example:\n+  ```rust\n+  my_macro!(Vec<i32>::new); // Always worked\n+  my_macro!(Vec::<i32>::new); // Now works\n+  ```\n \n Compiler\n --------"}, {"sha": "261fe2053879f004fd2ffeecc23d49c43ceb8467", "filename": "config.toml.example", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -35,7 +35,7 @@\n # If an external LLVM root is specified, we automatically check the version by\n # default to make sure it's within the range that we're expecting, but setting\n # this flag will indicate that this version check should not be done.\n-#version-check = false\n+#version-check = true\n \n # Link libstdc++ statically into the librustc_llvm instead of relying on a\n # dynamic version to be available.\n@@ -250,14 +250,11 @@\n # Whether or not `panic!`s generate backtraces (RUST_BACKTRACE)\n #backtrace = true\n \n-# The default linker that will be used by the generated compiler. Note that this\n-# is not the linker used to link said compiler.\n+# The default linker that will be hard-coded into the generated compiler for\n+# targets that don't specify linker explicitly in their target specifications.\n+# Note that this is not the linker used to link said compiler.\n #default-linker = \"cc\"\n \n-# The default ar utility that will be used by the generated compiler if LLVM\n-# cannot be used. Note that this is not used to assemble said compiler.\n-#default-ar = \"ar\"\n-\n # The \"channel\" for the Rust build to produce. The stable/beta channels only\n # allow using stable features, whereas the nightly and dev channels allow using\n # nightly features\n@@ -303,7 +300,7 @@\n # =============================================================================\n [target.x86_64-unknown-linux-gnu]\n \n-# C compiler to be used to compiler C code and link Rust code. Note that the\n+# C compiler to be used to compiler C code. Note that the\n # default value is platform specific, and if not specified it may also depend on\n # what platform is crossing to what platform.\n #cc = \"cc\"\n@@ -312,6 +309,15 @@\n # This is only used for host targets.\n #cxx = \"c++\"\n \n+# Archiver to be used to assemble static libraries compiled from C/C++ code.\n+# Note: an absolute path should be used, otherwise LLVM build will break.\n+#ar = \"ar\"\n+\n+# Linker to be used to link Rust code. Note that the\n+# default value is platform specific, and if not specified it may also depend on\n+# what platform is crossing to what platform.\n+#linker = \"cc\"\n+\n # Path to the `llvm-config` binary of the installation of a custom LLVM to link\n # against. Note that if this is specifed we don't compile LLVM at all for this\n # target."}, {"sha": "42705a0261d4fac6fd2610783df1c5eeb86555d4", "filename": "src/Cargo.lock", "status": "modified", "additions": 186, "deletions": 36, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -1,7 +1,3 @@\n-[root]\n-name = \"workspace_symbol\"\n-version = \"0.1.0\"\n-\n [[package]]\n name = \"advapi32-sys\"\n version = \"0.2.0\"\n@@ -42,7 +38,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"libc 0.0.0\",\n ]\n@@ -99,7 +95,7 @@ name = \"backtrace-sys\"\n version = \"0.1.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -132,7 +128,7 @@ name = \"bootstrap\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -195,7 +191,7 @@ dependencies = [\n  \"hex 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"home 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ignore 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"jobserver 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libgit2-sys 0.6.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -220,6 +216,16 @@ dependencies = [\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"cargo_metadata\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"cargotest\"\n version = \"0.1.0\"\n@@ -242,7 +248,7 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.0\"\n+version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -267,26 +273,55 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"cmake\"\n-version = \"0.1.26\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+name = \"clippy\"\n+version = \"0.0.166\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cargo_metadata 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clippy-mini-macro-test 0.1.0\",\n+ \"clippy_lints 0.0.166\",\n+ \"compiletest_rs 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"duct 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n-name = \"collections\"\n-version = \"0.0.0\"\n+name = \"clippy-mini-macro-test\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"clippy_lints\"\n+version = \"0.0.166\"\n dependencies = [\n- \"alloc 0.0.0\",\n- \"core 0.0.0\",\n+ \"itertools 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"pulldown-cmark 0.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"semver 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-normalization 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"cmake\"\n+version = \"0.1.26\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"compiler_builtins\"\n version = \"0.0.0\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -303,6 +338,15 @@ dependencies = [\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"compiletest_rs\"\n+version = \"0.2.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"completion\"\n version = \"0.1.0\"\n@@ -403,7 +447,7 @@ name = \"curl-sys\"\n version = \"0.3.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -465,6 +509,22 @@ name = \"dtoa\"\n version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"duct\"\n+version = \"0.8.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"error-chain 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazycell 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"os_pipe 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"shared_child 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"either\"\n+version = \"1.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"enum_primitive\"\n version = \"0.1.1\"\n@@ -491,6 +551,14 @@ dependencies = [\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"error-chain\"\n+version = \"0.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"backtrace 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"error-chain\"\n version = \"0.11.0\"\n@@ -736,14 +804,22 @@ dependencies = [\n  \"xz2 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"itertools\"\n+version = \"0.6.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"either 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"itoa\"\n version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"jobserver\"\n-version = \"0.1.6\"\n+version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -800,6 +876,11 @@ name = \"lazy_static\"\n version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"lazycell\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"libc\"\n version = \"0.0.0\"\n@@ -817,7 +898,7 @@ name = \"libgit2-sys\"\n version = \"0.6.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl-sys 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -844,7 +925,7 @@ name = \"libz-sys\"\n version = \"1.0.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -864,7 +945,7 @@ name = \"lzma-sys\"\n version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -952,7 +1033,7 @@ name = \"miniz-sys\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -983,6 +1064,17 @@ dependencies = [\n  \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"nix\"\n+version = \"0.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"num\"\n version = \"0.1.40\"\n@@ -1084,12 +1176,22 @@ name = \"openssl-sys\"\n version = \"0.9.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"os_pipe\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"nix 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"owning_ref\"\n version = \"0.3.3\"\n@@ -1188,7 +1290,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"profiler_builtins\"\n version = \"0.0.0\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -1209,6 +1311,15 @@ dependencies = [\n  \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"pulldown-cmark\"\n+version = \"0.0.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"pulldown-cmark\"\n version = \"0.1.0\"\n@@ -1223,6 +1334,11 @@ name = \"quick-error\"\n version = \"1.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"quine-mc_cluskey\"\n+version = \"0.2.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"quote\"\n version = \"0.2.3\"\n@@ -1405,7 +1521,7 @@ dependencies = [\n  \"flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n- \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"jobserver 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_back 0.0.0\",\n@@ -1480,6 +1596,7 @@ dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -1587,7 +1704,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc_back 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -1599,7 +1715,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"build_helper 0.1.0\",\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n ]\n \n@@ -1731,9 +1847,9 @@ name = \"rustc_trans\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"jobserver 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1763,6 +1879,7 @@ dependencies = [\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -1800,7 +1917,7 @@ name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"html-diff 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1869,6 +1986,14 @@ dependencies = [\n  \"smallvec 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"semver\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"semver\"\n version = \"0.8.0\"\n@@ -1930,6 +2055,16 @@ dependencies = [\n name = \"serialize\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"shared_child\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"shell-escape\"\n version = \"0.1.3\"\n@@ -1970,8 +2105,6 @@ dependencies = [\n  \"alloc_jemalloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"collections 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n  \"libc 0.0.0\",\n@@ -2413,6 +2546,10 @@ dependencies = [\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"workspace_symbol\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"ws2_32-sys\"\n version = \"0.2.1\"\n@@ -2457,10 +2594,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4efd02e230a02e18f92fc2735f44597385ed02ad8f831e7c1c1156ee5e1ab3a5\"\n \"checksum bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f5cde24d1b2e2216a726368b2363a273739c91f4e3eb4e0dd12d672d396ad989\"\n \"checksum bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f2f382711e76b9de6c744cc00d0497baba02fb00a787f088c879f01d09468e32\"\n-\"checksum cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7db2f146208d7e0fbee761b09cd65a7f51ccc38705d4e7262dad4d73b12a76b1\"\n+\"checksum cargo_metadata 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be1057b8462184f634c3a208ee35b0f935cfd94b694b26deadccd98732088d7b\"\n+\"checksum cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2c674f0870e3dbd4105184ea035acb1c32c8ae69939c9e228d2b11bbfe29efad\"\n \"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n \"checksum clap 2.26.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3451e409013178663435d6f15fdb212f14ee4424a3d74f979d081d0a66b6f1f2\"\n \"checksum cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\" = \"357c07e7a1fc95732793c1edb5901e1a1f305cfcf63a90eb12dbd22bdb6b789d\"\n+\"checksum compiletest_rs 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2741d378feb7a434dba54228c89a70b4e427fee521de67cdda3750b8a0265f5a\"\n \"checksum conv 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"78ff10625fd0ac447827aa30ea8b861fead473bb60aeb73af6c1c58caf0d1299\"\n \"checksum core-foundation 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5909502e547762013619f4c4e01cc7393c20fe2d52d7fa471c1210adb2320dc7\"\n \"checksum core-foundation-sys 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc9fb3d6cb663e6fd7cf1c63f9b144ee2b1e4a78595a0451dd34bff85b9a3387\"\n@@ -2477,10 +2616,13 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a515461b6c8c08419850ced27bc29e86166dcdcde8fbe76f8b1f0589bb49472\"\n \"checksum docopt 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b5b93718f8b3e5544fcc914c43de828ca6c6ace23e0332c6080a2977b49787a\"\n \"checksum dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09c3753c3db574d215cba4ea76018483895d7bff25a31b49ba45db21c48e50ab\"\n+\"checksum duct 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e45aa15fe0a8a8f511e6d834626afd55e49b62e5c8802e18328a87e8a8f6065c\"\n+\"checksum either 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e311a7479512fbdf858fb54d91ec59f3b9f85bc0113659f46bba12b199d273ce\"\n \"checksum enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be4551092f4d519593039259a9ed8daedf0da12e5109c5280338073eaeb81180\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n \"checksum error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff511d5dc435d703f4971bc399647c9bc38e20cb41452e3b9feb4765419ed3f3\"\n+\"checksum error-chain 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6930e04918388a9a2e41d518c25cf679ccafe26733fb4127dbf21993f2575d46\"\n \"checksum filetime 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ab199bf38537c6f38792669e081e0bb278b9b7405bba2642e4e5d15bf732c0e\"\n \"checksum flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e6234dd4468ae5d1e2dbb06fe2b058696fdc50a339c68a393aefbf00bc81e423\"\n \"checksum fnv 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6cc484842f1e2884faf56f529f960cc12ad8c71ce96cc7abba0a067c98fee344\"\n@@ -2501,13 +2643,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum html5ever 0.18.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a49d5001dd1bddf042ea41ed4e0a671d50b1bf187e66b349d7ec613bdce4ad90\"\n \"checksum idna 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"014b298351066f1512874135335d62a789ffe78a9974f94b43ed5621951eaf7d\"\n \"checksum ignore 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b3fcaf2365eb14b28ec7603c98c06cc531f19de9eb283d89a3dff8417c8c99f5\"\n+\"checksum itertools 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3f2be4da1690a039e9ae5fd575f706a63ad5a2120f161b1d653c9da3930dd21\"\n \"checksum itoa 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8324a32baf01e2ae060e9de58ed0bc2320c9a2833491ee36cd3b4c414de4db8c\"\n-\"checksum jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"443ae8bc0af6c106e6e8b77e04684faecc1a5ce94e058f4c2b0a037b0ea1b133\"\n+\"checksum jobserver 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"931b04e5e57d88cc909528f0d701db36a870b72a052648ded8baf80f9f445e0f\"\n \"checksum jsonrpc-core 7.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b1acd0f9934da94466d2370f36832b9b19271b4abdfdb5e69f0bcd991ebcd515\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum kuchiki 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef2ea4f2f7883cd7c6772b06c14abca01a2cc1f75c426cebffcf6b3b925ef9fc\"\n \"checksum languageserver-types 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d52e477b23bf52cd3ca0f9fc6c5d14be954eec97e3b9cdfbd962d911bd533caf\"\n \"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n+\"checksum lazycell 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b585b7a6811fb03aa10e74b278a0f00f8dd9b45dc681f148bb29fa5cb61859b\"\n \"checksum libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d1419b2939a0bc44b77feb34661583c7546b532b192feab36249ab584b86856c\"\n \"checksum libgit2-sys 0.6.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"205fc37e829c5b36de63d14c8dc8b62c5a6a2519b16318ed0977079ca97256a9\"\n \"checksum libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0db4ec23611747ef772db1c4d650f8bd762f07b461727ec998f953c614024b75\"\n@@ -2525,6 +2669,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum miniz-sys 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"609ce024854aeb19a0ef7567d348aaa5a746b32fb72e336df7fcc16869d7e2b4\"\n \"checksum miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f2f3b1cf331de6896aabf6e9d55dca90356cc9960cca7eaaf408a355ae919\"\n \"checksum net2 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a80f842784ef6c9a958b68b7516bc7e35883c614004dd94959a4dca1b716c09\"\n+\"checksum nix 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"47e49f6982987135c5e9620ab317623e723bd06738fd85377e8d55f57c8b6487\"\n \"checksum num 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a311b77ebdc5dd4cf6449d81e4135d9f0e3b153839ac90e648a8ef538f923525\"\n \"checksum num-bigint 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8fd0f8dbb4c0960998958a796281d88c16fbe68d87b1baa6f31e2979e81fd0bd\"\n \"checksum num-complex 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"503e668405c5492d67cf662a81e05be40efe2e6bcf10f7794a07bd9865e704e6\"\n@@ -2537,6 +2682,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum openssl 0.9.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"816914b22eb15671d62c73442a51978f311e911d6a6f6cbdafa6abce1b5038fc\"\n \"checksum openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d98df0270d404ccd3c050a41d579c52d1db15375168bb3471e04ec0f5f378daf\"\n \"checksum openssl-sys 0.9.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1e4c63a7d559c1e5afa6d6a9e6fa34bbc5f800ffc9ae08b72c605420b0c4f5e8\"\n+\"checksum os_pipe 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"998bfbb3042e715190fe2a41abfa047d7e8cb81374d2977d7f100eacd8619cb1\"\n \"checksum owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdf84f41639e037b484f93433aa3897863b561ed65c6e59c7073d7c561710f37\"\n \"checksum percent-encoding 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"de154f638187706bde41d9b4738748933d64e6b37bdbffc0b47a97d16a6ae356\"\n \"checksum pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a6dda33d67c26f0aac90d324ab2eb7239c819fc7b2552fe9faa4fe88441edc8\"\n@@ -2549,8 +2695,10 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum procedural-masquerade 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c93cdc1fb30af9ddf3debc4afbdb0f35126cbd99daa229dd76cdd5349b41d989\"\n \"checksum psapi-sys 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"abcd5d1a07d360e29727f757a9decb3ce8bc6e0efa8969cfaad669a8317a2478\"\n \"checksum pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9ab1e588ef8efd702c7ed9d2bd774db5e6f4d878bb5a1a9f371828fbdff6973\"\n+\"checksum pulldown-cmark 0.0.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"378e941dbd392c101f2cb88097fa4d7167bc421d4b88de3ff7dbee503bc3233b\"\n \"checksum pulldown-cmark 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a656fdb8b6848f896df5e478a0eb9083681663e37dcb77dd16981ff65329fe8b\"\n \"checksum quick-error 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eda5fe9b71976e62bc81b781206aaa076401769b2143379d3eb2118388babac4\"\n+\"checksum quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07589615d719a60c8dd8a4622e7946465dfef20d1a428f969e3443e7386d5f45\"\n \"checksum quote 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c5cf478fe1006dbcc72567121d23dbdae5f1632386068c5c86ff4f645628504\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n \"checksum racer 2.0.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f120c7510ef7aff254aeb06067fb6fac573ec96a1660e194787cf9dced412bf0\"\n@@ -2571,13 +2719,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum scoped-tls 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f417c22df063e9450888a7561788e9bd46d3bb3c1466435b4eccb903807f147d\"\n \"checksum scopeguard 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"59a076157c1e2dc561d8de585151ee6965d910dd4dcb5dabb7ae3e83981a6c57\"\n \"checksum selectors 0.18.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e3c89b1c6a3c029c82263f7dd2d44d0005ee7374eb09e254ab59dede4353a8c0\"\n+\"checksum semver 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a3186ec9e65071a2095434b1f5bb24838d4e8e130f584c790f6033c79943537\"\n \"checksum semver 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bee2bc909ab2d8d60dab26e8cad85b25d795b14603a0dcb627b78b9d30b6454b\"\n \"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \"checksum serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a7046c9d4c6c522d10b2d098f9bebe2bef227e0e74044d8c1bfcf6b476af799\"\n \"checksum serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1afcaae083fd1c46952a315062326bc9957f182358eb7da03b57ef1c688f7aa9\"\n \"checksum serde_derive_internals 0.16.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bd381f6d01a6616cdba8530492d453b7761b456ba974e98768a18cad2cd76f58\"\n \"checksum serde_ignored 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"190e9765dcedb56be63b6e0993a006c7e3b071a016a304736e4a315dc01fb142\"\n \"checksum serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d243424e06f9f9c39e3cd36147470fd340db785825e367625f79298a6ac6b7ac\"\n+\"checksum shared_child 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"099b38928dbe4a0a01fcd8c233183072f14a7d126a34bed05880869be66e14cc\"\n \"checksum shell-escape 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd5cc96481d54583947bfe88bf30c23d53f883c6cd0145368b69989d97b84ef8\"\n \"checksum siphasher 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0df90a788073e8d0235a67e50441d47db7c8ad9debd91cbf43736a2a92d36537\"\n \"checksum smallvec 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4f8266519bc1d17d0b5b16f6c21295625d562841c708f6376f49028a43e9c11e\""}, {"sha": "39904927ca650aa1911db8dba404ffe689d15229", "filename": "src/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -5,6 +5,7 @@ members = [\n   \"libstd\",\n   \"libtest\",\n   \"tools/cargotest\",\n+  \"tools/clippy\",\n   \"tools/compiletest\",\n   \"tools/error_index_generator\",\n   \"tools/linkchecker\","}, {"sha": "bbbbf0e1915555c419039a827eb1703a8c267c4e", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -34,7 +34,7 @@ cmake = \"0.1.23\"\n filetime = \"0.1\"\n num_cpus = \"1.0\"\n getopts = \"0.2\"\n-cc = \"1.0\"\n+cc = \"1.0.1\"\n libc = \"0.2\"\n serde = \"1.0.8\"\n serde_derive = \"1.0.8\""}, {"sha": "9ff681ac680874b09b35122160f7807025d4b1cc", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -39,7 +39,7 @@ The script accepts commands, flags, and arguments to determine what to do:\n   ```\n \n   If files are dirty that would normally be rebuilt from stage 0, that can be\n-  overidden using `--keep-stage 0`. Using `--keep-stage n` will skip all steps\n+  overridden using `--keep-stage 0`. Using `--keep-stage n` will skip all steps\n   that belong to stage n or earlier:\n \n   ```\n@@ -126,17 +126,17 @@ install a nightly, presumably using `rustup`. You will then want to\n configure your directory to use this build, like so:\n \n ```\n-# configure to use local rust instead of downloding a beta.\n+# configure to use local rust instead of downloading a beta.\n # `--local-rust-root` is optional here. If elided, we will\n # use whatever rustc we find on your PATH.\n-> configure --enable-rustbuild --local-rust-root=~/.cargo/ --enable-local-rebuild\n+> ./configure --local-rust-root=~/.cargo/ --enable-local-rebuild\n ```\n \n After that, you can use the `--incremental` flag to actually do\n incremental builds:\n \n ```\n-> ../x.py build --incremental\n+> ./x.py build --incremental\n ```\n \n The `--incremental` flag will store incremental compilation artifacts"}, {"sha": "16a23eb364a3822b9e7d55d6d1bbd88754e57a70", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -31,8 +31,6 @@ extern crate bootstrap;\n \n use std::env;\n use std::ffi::OsString;\n-use std::io;\n-use std::io::prelude::*;\n use std::str::FromStr;\n use std::path::PathBuf;\n use std::process::{Command, ExitStatus};\n@@ -122,19 +120,14 @@ fn main() {\n             cmd.arg(\"-L\").arg(&root);\n         }\n \n-        // Pass down extra flags, commonly used to configure `-Clinker` when\n-        // cross compiling.\n-        if let Ok(s) = env::var(\"RUSTC_FLAGS\") {\n-            cmd.args(&s.split(\" \").filter(|s| !s.is_empty()).collect::<Vec<_>>());\n+        // Override linker if necessary.\n+        if let Ok(target_linker) = env::var(\"RUSTC_TARGET_LINKER\") {\n+            cmd.arg(format!(\"-Clinker={}\", target_linker));\n         }\n \n         // Pass down incremental directory, if any.\n         if let Ok(dir) = env::var(\"RUSTC_INCREMENTAL\") {\n             cmd.arg(format!(\"-Zincremental={}\", dir));\n-\n-            if verbose > 0 {\n-                cmd.arg(\"-Zincremental-info\");\n-            }\n         }\n \n         let crate_name = args.windows(2)\n@@ -182,6 +175,9 @@ fn main() {\n         if let Ok(s) = env::var(\"RUSTC_CODEGEN_UNITS\") {\n             cmd.arg(\"-C\").arg(format!(\"codegen-units={}\", s));\n         }\n+        if stage != \"0\" && env::var(\"RUSTC_THINLTO\").is_ok() {\n+            cmd.arg(\"-Ccodegen-units=16\").arg(\"-Zthinlto\");\n+        }\n \n         // Emit save-analysis info.\n         if env::var(\"RUSTC_SAVE_ANALYSIS\") == Ok(\"api\".to_string()) {\n@@ -258,6 +254,11 @@ fn main() {\n         if env::var_os(\"RUSTC_FORCE_UNSTABLE\").is_some() {\n             cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n         }\n+    } else {\n+        // Override linker if necessary.\n+        if let Ok(host_linker) = env::var(\"RUSTC_HOST_LINKER\") {\n+            cmd.arg(format!(\"-Clinker={}\", host_linker));\n+        }\n     }\n \n     let color = match env::var(\"RUSTC_COLOR\") {\n@@ -270,7 +271,7 @@ fn main() {\n     }\n \n     if verbose > 1 {\n-        writeln!(&mut io::stderr(), \"rustc command: {:?}\", cmd).unwrap();\n+        eprintln!(\"rustc command: {:?}\", cmd);\n     }\n \n     // Actually run the compiler!"}, {"sha": "4e975adc9721cdef87aac309521056c7816ba39c", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -47,6 +47,17 @@ fn main() {\n     if env::var_os(\"RUSTC_FORCE_UNSTABLE\").is_some() {\n         cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n     }\n+    if let Some(linker) = env::var_os(\"RUSTC_TARGET_LINKER\") {\n+        cmd.arg(\"--linker\").arg(linker).arg(\"-Z\").arg(\"unstable-options\");\n+    }\n+\n+    // Bootstrap's Cargo-command builder sets this variable to the current Rust version; let's pick\n+    // it up so we can make rustdoc print this into the docs\n+    if let Some(version) = env::var_os(\"RUSTDOC_CRATE_VERSION\") {\n+        // This \"unstable-options\" can be removed when `--crate-version` is stabilized\n+        cmd.arg(\"-Z\").arg(\"unstable-options\")\n+           .arg(\"--crate-version\").arg(version);\n+    }\n \n     std::process::exit(match cmd.status() {\n         Ok(s) => s.code().unwrap_or(1),"}, {"sha": "0ab4c79e3b236df03426d27690c6f0edfa43c93a", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -8,7 +8,7 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-from __future__ import print_function\n+from __future__ import absolute_import, division, print_function\n import argparse\n import contextlib\n import datetime\n@@ -302,6 +302,7 @@ def default_build_triple():\n \n     return \"{}-{}\".format(cputype, ostype)\n \n+\n class RustBuild(object):\n     \"\"\"Provide all the methods required to build Rust\"\"\"\n     def __init__(self):\n@@ -498,7 +499,7 @@ def get_toml(self, key):\n \n         If the key does not exists, the result is None:\n \n-        >>> rb.get_toml(\"key3\") == None\n+        >>> rb.get_toml(\"key3\") is None\n         True\n         \"\"\"\n         for line in self.config_toml.splitlines():\n@@ -531,7 +532,7 @@ def program_config(self, program):\n         \"\"\"\n         config = self.get_toml(program)\n         if config:\n-            return config\n+            return os.path.expanduser(config)\n         return os.path.join(self.bin_root(), \"bin\", \"{}{}\".format(\n             program, self.exe_suffix()))\n \n@@ -647,7 +648,8 @@ def update_submodules(self):\n                       if not ((module.endswith(\"llvm\") and\n                                self.get_toml('llvm-config')) or\n                               (module.endswith(\"jemalloc\") and\n-                               self.get_toml('jemalloc')))]\n+                               (self.get_toml('use-jemalloc') == \"false\" or\n+                                self.get_toml('jemalloc'))))]\n         run([\"git\", \"submodule\", \"update\",\n              \"--init\", \"--recursive\"] + submodules,\n             cwd=self.rust_root, verbose=self.verbose)"}, {"sha": "4db7e2ec016f0c5ef145ba850a3f0bc86cd9c8e9", "filename": "src/bootstrap/bootstrap_test.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fbootstrap_test.py", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fbootstrap_test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap_test.py?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -10,6 +10,7 @@\n \n \"\"\"Bootstrap tests\"\"\"\n \n+from __future__ import absolute_import, division, print_function\n import os\n import doctest\n import unittest"}, {"sha": "0dca395fa1fdbfe8f48d8ff709a247e8813351fb", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 57, "deletions": 17, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -413,12 +413,15 @@ impl<'a> Builder<'a> {\n     pub fn rustdoc_cmd(&self, host: Interned<String>) -> Command {\n         let mut cmd = Command::new(&self.out.join(\"bootstrap/debug/rustdoc\"));\n         let compiler = self.compiler(self.top_stage, host);\n-        cmd\n-            .env(\"RUSTC_STAGE\", compiler.stage.to_string())\n-            .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n-            .env(\"RUSTC_LIBDIR\", self.sysroot_libdir(compiler, self.build.build))\n-            .env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel)\n-            .env(\"RUSTDOC_REAL\", self.rustdoc(host));\n+        cmd.env(\"RUSTC_STAGE\", compiler.stage.to_string())\n+           .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n+           .env(\"RUSTC_LIBDIR\", self.sysroot_libdir(compiler, self.build.build))\n+           .env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel)\n+           .env(\"RUSTDOC_REAL\", self.rustdoc(host))\n+           .env(\"RUSTDOC_CRATE_VERSION\", self.build.rust_version());\n+        if let Some(linker) = self.build.linker(host) {\n+            cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n+        }\n         cmd\n     }\n \n@@ -468,8 +471,6 @@ impl<'a> Builder<'a> {\n              .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n              .env(\"RUSTC_REAL\", self.rustc(compiler))\n              .env(\"RUSTC_STAGE\", stage.to_string())\n-             .env(\"RUSTC_CODEGEN_UNITS\",\n-                  self.config.rust_codegen_units.to_string())\n              .env(\"RUSTC_DEBUG_ASSERTIONS\",\n                   self.config.rust_debug_assertions.to_string())\n              .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n@@ -481,8 +482,18 @@ impl<'a> Builder<'a> {\n              } else {\n                  PathBuf::from(\"/path/to/nowhere/rustdoc/not/required\")\n              })\n-             .env(\"TEST_MIRI\", self.config.test_miri.to_string())\n-             .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n+             .env(\"TEST_MIRI\", self.config.test_miri.to_string());\n+\n+        if let Some(n) = self.config.rust_codegen_units {\n+            cargo.env(\"RUSTC_CODEGEN_UNITS\", n.to_string());\n+        }\n+\n+        if let Some(host_linker) = self.build.linker(compiler.host) {\n+            cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n+        }\n+        if let Some(target_linker) = self.build.linker(target) {\n+            cargo.env(\"RUSTC_TARGET_LINKER\", target_linker);\n+        }\n \n         if mode != Mode::Tool {\n             // Tools don't get debuginfo right now, e.g. cargo and rls don't\n@@ -556,24 +567,45 @@ impl<'a> Builder<'a> {\n \n         cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", self.verbosity));\n \n-        // Specify some various options for build scripts used throughout\n-        // the build.\n+        // Throughout the build Cargo can execute a number of build scripts\n+        // compiling C/C++ code and we need to pass compilers, archivers, flags, etc\n+        // obtained previously to those build scripts.\n+        // Build scripts use either the `cc` crate or `configure/make` so we pass\n+        // the options through environment variables that are fetched and understood by both.\n         //\n         // FIXME: the guard against msvc shouldn't need to be here\n         if !target.contains(\"msvc\") {\n-            cargo.env(format!(\"CC_{}\", target), self.cc(target))\n-                 .env(format!(\"AR_{}\", target), self.ar(target).unwrap()) // only msvc is None\n-                 .env(format!(\"CFLAGS_{}\", target), self.cflags(target).join(\" \"));\n+            let cc = self.cc(target);\n+            cargo.env(format!(\"CC_{}\", target), cc)\n+                 .env(\"CC\", cc);\n+\n+            let cflags = self.cflags(target).join(\" \");\n+            cargo.env(format!(\"CFLAGS_{}\", target), cflags.clone())\n+                 .env(\"CFLAGS\", cflags.clone());\n+\n+            if let Some(ar) = self.ar(target) {\n+                let ranlib = format!(\"{} s\", ar.display());\n+                cargo.env(format!(\"AR_{}\", target), ar)\n+                     .env(\"AR\", ar)\n+                     .env(format!(\"RANLIB_{}\", target), ranlib.clone())\n+                     .env(\"RANLIB\", ranlib);\n+            }\n \n             if let Ok(cxx) = self.cxx(target) {\n-                 cargo.env(format!(\"CXX_{}\", target), cxx);\n+                cargo.env(format!(\"CXX_{}\", target), cxx)\n+                     .env(\"CXX\", cxx)\n+                     .env(format!(\"CXXFLAGS_{}\", target), cflags.clone())\n+                     .env(\"CXXFLAGS\", cflags);\n             }\n         }\n \n         if mode == Mode::Libstd && self.config.extended && compiler.is_final_stage(self) {\n             cargo.env(\"RUSTC_SAVE_ANALYSIS\", \"api\".to_string());\n         }\n \n+        // For `cargo doc` invocations, make rustdoc print the Rust version into the docs\n+        cargo.env(\"RUSTDOC_CRATE_VERSION\", self.build.rust_version());\n+\n         // Environment variables *required* throughout the build\n         //\n         // FIXME: should update code to not require this env var\n@@ -582,12 +614,20 @@ impl<'a> Builder<'a> {\n         // Set this for all builds to make sure doc builds also get it.\n         cargo.env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel);\n \n-        if self.is_verbose() {\n+        if self.is_very_verbose() {\n             cargo.arg(\"-v\");\n         }\n         // FIXME: cargo bench does not accept `--release`\n         if self.config.rust_optimize && cmd != \"bench\" {\n             cargo.arg(\"--release\");\n+\n+            if mode != Mode::Libstd &&\n+               self.config.rust_codegen_units.is_none() &&\n+               self.build.is_rust_llvm(compiler.host)\n+\n+            {\n+                cargo.env(\"RUSTC_THINLTO\", \"1\");\n+            }\n         }\n         if self.config.locked_deps {\n             cargo.arg(\"--locked\");"}, {"sha": "6e3e3c920291d00e51738f284ce8498e699bb8d5", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -31,20 +31,51 @@\n //! ever be probed for. Instead the compilers found here will be used for\n //! everything.\n \n+use std::collections::HashSet;\n+use std::{env, iter};\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n-use std::iter;\n \n-use build_helper::{cc2ar, output};\n+use build_helper::output;\n use cc;\n \n use Build;\n use config::Target;\n use cache::Interned;\n \n+// The `cc` crate doesn't provide a way to obtain a path to the detected archiver,\n+// so use some simplified logic here. First we respect the environment variable `AR`, then\n+// try to infer the archiver path from the C compiler path.\n+// In the future this logic should be replaced by calling into the `cc` crate.\n+fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n+    if let Some(ar) = env::var_os(\"AR\") {\n+        Some(PathBuf::from(ar))\n+    } else if target.contains(\"msvc\") {\n+        None\n+    } else if target.contains(\"musl\") {\n+        Some(PathBuf::from(\"ar\"))\n+    } else if target.contains(\"openbsd\") {\n+        Some(PathBuf::from(\"ar\"))\n+    } else {\n+        let parent = cc.parent().unwrap();\n+        let file = cc.file_name().unwrap().to_str().unwrap();\n+        for suffix in &[\"gcc\", \"cc\", \"clang\"] {\n+            if let Some(idx) = file.rfind(suffix) {\n+                let mut file = file[..idx].to_owned();\n+                file.push_str(\"ar\");\n+                return Some(parent.join(&file));\n+            }\n+        }\n+        Some(parent.join(file))\n+    }\n+}\n+\n pub fn find(build: &mut Build) {\n     // For all targets we're going to need a C compiler for building some shims\n     // and such as well as for being a linker for Rust code.\n-    for target in build.targets.iter().chain(&build.hosts).cloned().chain(iter::once(build.build)) {\n+    let targets = build.targets.iter().chain(&build.hosts).cloned().chain(iter::once(build.build))\n+                               .collect::<HashSet<_>>();\n+    for target in targets.into_iter() {\n         let mut cfg = cc::Build::new();\n         cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false)\n            .target(&target).host(&build.build);\n@@ -57,16 +88,23 @@ pub fn find(build: &mut Build) {\n         }\n \n         let compiler = cfg.get_compiler();\n-        let ar = cc2ar(compiler.path(), &target);\n+        let ar = if let ar @ Some(..) = config.and_then(|c| c.ar.clone()) {\n+            ar\n+        } else {\n+            cc2ar(compiler.path(), &target)\n+        };\n+\n         build.verbose(&format!(\"CC_{} = {:?}\", &target, compiler.path()));\n-        if let Some(ref ar) = ar {\n+        build.cc.insert(target, compiler);\n+        if let Some(ar) = ar {\n             build.verbose(&format!(\"AR_{} = {:?}\", &target, ar));\n+            build.ar.insert(target, ar);\n         }\n-        build.cc.insert(target, (compiler, ar));\n     }\n \n     // For all host triples we need to find a C++ compiler as well\n-    for host in build.hosts.iter().cloned().chain(iter::once(build.build)) {\n+    let hosts = build.hosts.iter().cloned().chain(iter::once(build.build)).collect::<HashSet<_>>();\n+    for host in hosts.into_iter() {\n         let mut cfg = cc::Build::new();\n         cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false).cpp(true)\n            .target(&host).host(&build.build);"}, {"sha": "11bc9f7d217721b83252ce26e12a34bdbb9c5034", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 64, "deletions": 42, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -246,8 +246,11 @@ impl Step for Rls {\n         let compiler = builder.compiler(stage, host);\n \n         builder.ensure(tool::Rls { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/rls/Cargo.toml\"));\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/rls\");\n \n         // Don't build tests dynamically, just a pain to work with\n         cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n@@ -291,8 +294,11 @@ impl Step for Rustfmt {\n         let compiler = builder.compiler(stage, host);\n \n         builder.ensure(tool::Rustfmt { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/rustfmt/Cargo.toml\"));\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/rustfmt\");\n \n         // Don't build tests dynamically, just a pain to work with\n         cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n@@ -334,30 +340,34 @@ impl Step for Miri {\n         let host = self.host;\n         let compiler = builder.compiler(1, host);\n \n-        let miri = builder.ensure(tool::Miri { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n-\n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-        // miri tests need to know about the stage sysroot\n-        cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n-        cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n-        cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-        cargo.env(\"MIRI_PATH\", miri);\n-\n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n-\n-        try_run_expecting(\n-            build,\n-            &mut cargo,\n-            builder.build.config.toolstate.miri.passes(ToolState::Testing),\n-        );\n+        if let Some(miri) = builder.ensure(tool::Miri { compiler, target: self.host }) {\n+            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n+            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n+\n+            // Don't build tests dynamically, just a pain to work with\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+            // miri tests need to know about the stage sysroot\n+            cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n+            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n+            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+            cargo.env(\"MIRI_PATH\", miri);\n+\n+            builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+            try_run_expecting(\n+                build,\n+                &mut cargo,\n+                builder.build.config.toolstate.miri.passes(ToolState::Testing),\n+            );\n+        } else {\n+            eprintln!(\"failed to test miri: could not build\");\n+        }\n     }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Clippy {\n+    stage: u32,\n     host: Interned<String>,\n }\n \n@@ -372,32 +382,39 @@ impl Step for Clippy {\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Clippy {\n+            stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for clippy.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n+        let stage = self.stage;\n         let host = self.host;\n-        let compiler = builder.compiler(1, host);\n+        let compiler = builder.compiler(stage, host);\n \n-        let _clippy = builder.ensure(tool::Clippy { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n+        if let Some(clippy) = builder.ensure(tool::Clippy { compiler, target: self.host }) {\n+            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n+            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n \n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-        // clippy tests need to know about the stage sysroot\n-        cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n+            // Don't build tests dynamically, just a pain to work with\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+            // clippy tests need to know about the stage sysroot\n+            cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n+            // clippy tests need to find the driver\n+            cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n \n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n+            builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-        try_run_expecting(\n-            build,\n-            &mut cargo,\n-            builder.build.config.toolstate.clippy.passes(ToolState::Testing),\n-        );\n+            try_run_expecting(\n+                build,\n+                &mut cargo,\n+                builder.build.config.toolstate.clippy.passes(ToolState::Testing),\n+            );\n+        } else {\n+            eprintln!(\"failed to test clippy: could not build\");\n+        }\n     }\n }\n \n@@ -736,12 +753,14 @@ impl Step for Compiletest {\n             flags.push(\"-g\".to_string());\n         }\n \n-        let mut hostflags = build.rustc_flags(compiler.host);\n-        hostflags.extend(flags.clone());\n+        if let Some(linker) = build.linker(target) {\n+            cmd.arg(\"--linker\").arg(linker);\n+        }\n+\n+        let hostflags = flags.clone();\n         cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n \n-        let mut targetflags = build.rustc_flags(target);\n-        targetflags.extend(flags);\n+        let mut targetflags = flags.clone();\n         targetflags.push(format!(\"-Lnative={}\",\n                                  build.test_helpers_out(target).display()));\n         cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n@@ -795,6 +814,9 @@ impl Step for Compiletest {\n                 .arg(\"--cflags\").arg(build.cflags(target).join(\" \"))\n                 .arg(\"--llvm-components\").arg(llvm_components.trim())\n                 .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n+                if let Some(ar) = build.ar(target) {\n+                    cmd.arg(\"--ar\").arg(ar);\n+                }\n             }\n         }\n         if suite == \"run-make\" && !build.config.llvm_enabled {\n@@ -820,7 +842,7 @@ impl Step for Compiletest {\n         // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n         // rather than stomp over it.\n         if target.contains(\"msvc\") {\n-            for &(ref k, ref v) in build.cc[&target].0.env() {\n+            for &(ref k, ref v) in build.cc[&target].env() {\n                 if k != \"PATH\" {\n                     cmd.env(k, v);\n                 }"}, {"sha": "a8162f0a92fb304d0e666834b980c84b2caa2edc", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -29,7 +29,7 @@ use build_helper::{output, mtime, up_to_date};\n use filetime::FileTime;\n use serde_json;\n \n-use util::{exe, libdir, is_dylib, copy};\n+use util::{exe, libdir, is_dylib, copy, read_stamp_file, CiEnv};\n use {Build, Compiler, Mode};\n use native;\n use tool;\n@@ -102,7 +102,7 @@ impl Step for Std {\n             copy_musl_third_party_objects(build, target, &libdir);\n         }\n \n-        let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n+        let out_dir = build.stage_out(compiler, Mode::Libstd);\n         build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"build\");\n         std_cargo(build, &compiler, target, &mut cargo);\n@@ -354,7 +354,7 @@ impl Step for Test {\n         let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n         println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target);\n-        let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n+        let out_dir = build.stage_out(compiler, Mode::Libtest);\n         build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"build\");\n         test_cargo(build, &compiler, target, &mut cargo);\n@@ -480,8 +480,9 @@ impl Step for Rustc {\n         println!(\"Building stage{} compiler artifacts ({} -> {})\",\n                  compiler.stage, &compiler.host, target);\n \n-        let out_dir = build.cargo_out(compiler, Mode::Librustc, target);\n-        build.clear_if_dirty(&out_dir, &libtest_stamp(build, compiler, target));\n+        let stage_out = builder.stage_out(compiler, Mode::Librustc);\n+        build.clear_if_dirty(&stage_out, &libstd_stamp(build, compiler, target));\n+        build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"build\");\n         rustc_cargo(build, &compiler, target, &mut cargo);\n@@ -560,9 +561,6 @@ pub fn rustc_cargo(build: &Build,\n     if let Some(ref s) = build.config.rustc_default_linker {\n         cargo.env(\"CFG_DEFAULT_LINKER\", s);\n     }\n-    if let Some(ref s) = build.config.rustc_default_ar {\n-        cargo.env(\"CFG_DEFAULT_AR\", s);\n-    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -760,15 +758,7 @@ impl Step for Assemble {\n /// `sysroot_dst` provided.\n fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n-    let mut contents = Vec::new();\n-    t!(t!(File::open(stamp)).read_to_end(&mut contents));\n-    // This is the method we use for extracting paths from the stamp file passed to us. See\n-    // run_cargo for more information (in this file).\n-    for part in contents.split(|b| *b == 0) {\n-        if part.is_empty() {\n-            continue\n-        }\n-        let path = Path::new(t!(str::from_utf8(part)));\n+    for path in read_stamp_file(stamp) {\n         copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n     }\n }\n@@ -802,7 +792,7 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n     cargo.arg(\"--message-format\").arg(\"json\")\n          .stdout(Stdio::piped());\n \n-    if stderr_isatty() {\n+    if stderr_isatty() && build.ci_env == CiEnv::None {\n         // since we pass message-format=json to cargo, we need to tell the rustc\n         // wrapper to give us colored output if necessary. This is because we\n         // only want Cargo's JSON output, not rustcs.\n@@ -941,6 +931,8 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n     let max = max.unwrap();\n     let max_path = max_path.unwrap();\n     if stamp_contents == new_contents && max <= stamp_mtime {\n+        build.verbose(&format!(\"not updating {:?}; contents equal and {} <= {}\",\n+                stamp, max, stamp_mtime));\n         return\n     }\n     if max > stamp_mtime {"}, {"sha": "66e5efcea4e809e9b8ee025604a37a9d6f00a7fc", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -81,14 +81,13 @@ pub struct Config {\n \n     // rust codegen options\n     pub rust_optimize: bool,\n-    pub rust_codegen_units: u32,\n+    pub rust_codegen_units: Option<u32>,\n     pub rust_debug_assertions: bool,\n     pub rust_debuginfo: bool,\n     pub rust_debuginfo_lines: bool,\n     pub rust_debuginfo_only_std: bool,\n     pub rust_rpath: bool,\n     pub rustc_default_linker: Option<String>,\n-    pub rustc_default_ar: Option<String>,\n     pub rust_optimize_tests: bool,\n     pub rust_debuginfo_tests: bool,\n     pub rust_dist_src: bool,\n@@ -144,6 +143,8 @@ pub struct Target {\n     pub jemalloc: Option<PathBuf>,\n     pub cc: Option<PathBuf>,\n     pub cxx: Option<PathBuf>,\n+    pub ar: Option<PathBuf>,\n+    pub linker: Option<PathBuf>,\n     pub ndk: Option<PathBuf>,\n     pub crt_static: Option<bool>,\n     pub musl_root: Option<PathBuf>,\n@@ -262,7 +263,6 @@ struct Rust {\n     use_jemalloc: Option<bool>,\n     backtrace: Option<bool>,\n     default_linker: Option<String>,\n-    default_ar: Option<String>,\n     channel: Option<String>,\n     musl_root: Option<String>,\n     rpath: Option<bool>,\n@@ -284,6 +284,8 @@ struct TomlTarget {\n     jemalloc: Option<String>,\n     cc: Option<String>,\n     cxx: Option<String>,\n+    ar: Option<String>,\n+    linker: Option<String>,\n     android_ndk: Option<String>,\n     crt_static: Option<bool>,\n     musl_root: Option<String>,\n@@ -297,14 +299,14 @@ impl Config {\n         let mut config = Config::default();\n         config.llvm_enabled = true;\n         config.llvm_optimize = true;\n+        config.llvm_version_check = true;\n         config.use_jemalloc = true;\n         config.backtrace = true;\n         config.rust_optimize = true;\n         config.rust_optimize_tests = true;\n         config.submodules = true;\n         config.docs = true;\n         config.rust_rpath = true;\n-        config.rust_codegen_units = 1;\n         config.channel = \"dev\".to_string();\n         config.codegen_tests = true;\n         config.ignore_git = false;\n@@ -464,12 +466,11 @@ impl Config {\n             set(&mut config.quiet_tests, rust.quiet_tests);\n             set(&mut config.test_miri, rust.test_miri);\n             config.rustc_default_linker = rust.default_linker.clone();\n-            config.rustc_default_ar = rust.default_ar.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n \n             match rust.codegen_units {\n-                Some(0) => config.rust_codegen_units = num_cpus::get() as u32,\n-                Some(n) => config.rust_codegen_units = n,\n+                Some(0) => config.rust_codegen_units = Some(num_cpus::get() as u32),\n+                Some(n) => config.rust_codegen_units = Some(n),\n                 None => {}\n             }\n         }\n@@ -487,8 +488,10 @@ impl Config {\n                 if let Some(ref s) = cfg.android_ndk {\n                     target.ndk = Some(env::current_dir().unwrap().join(s));\n                 }\n-                target.cxx = cfg.cxx.clone().map(PathBuf::from);\n                 target.cc = cfg.cc.clone().map(PathBuf::from);\n+                target.cxx = cfg.cxx.clone().map(PathBuf::from);\n+                target.ar = cfg.ar.clone().map(PathBuf::from);\n+                target.linker = cfg.linker.clone().map(PathBuf::from);\n                 target.crt_static = cfg.crt_static.clone();\n                 target.musl_root = cfg.musl_root.clone().map(PathBuf::from);\n                 target.qemu_rootfs = cfg.qemu_rootfs.clone().map(PathBuf::from);"}, {"sha": "42425a164a20ef3f2335aa304f9fef6aee6d1eef", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -11,6 +11,7 @@\n \n # ignore-tidy-linelength\n \n+from __future__ import absolute_import, division, print_function\n import sys\n import os\n rust_dir = os.path.dirname(os.path.abspath(__file__))\n@@ -19,21 +20,26 @@\n sys.path.append(os.path.join(rust_dir, \"src\", \"bootstrap\"))\n import bootstrap\n \n-class Option:\n+\n+class Option(object):\n     def __init__(self, name, rustbuild, desc, value):\n         self.name = name\n         self.rustbuild = rustbuild\n         self.desc = desc\n         self.value = value\n \n+\n options = []\n \n+\n def o(*args):\n     options.append(Option(*args, value=False))\n \n+\n def v(*args):\n     options.append(Option(*args, value=True))\n \n+\n o(\"debug\", \"rust.debug\", \"debug mode; disables optimization unless `--enable-optimize` given\")\n o(\"docs\", \"build.docs\", \"build standard library documentation\")\n o(\"compiler-docs\", \"build.compiler-docs\", \"build compiler documentation\")\n@@ -119,9 +125,8 @@ def v(*args):\n   \"experimental LLVM targets to build\")\n v(\"release-channel\", \"rust.channel\", \"the name of the release channel to build\")\n \n-# Used on systems where \"cc\" and \"ar\" are unavailable\n+# Used on systems where \"cc\" is unavailable\n v(\"default-linker\", \"rust.default-linker\", \"the default linker\")\n-v(\"default-ar\", \"rust.default-ar\", \"the default ar\")\n \n # Many of these are saved below during the \"writing configuration\" step\n # (others are conditionally saved).\n@@ -136,13 +141,16 @@ def v(*args):\n \n v(\"set\", None, \"set arbitrary key/value pairs in TOML configuration\")\n \n+\n def p(msg):\n     print(\"configure: \" + msg)\n \n+\n def err(msg):\n     print(\"configure: error: \" + msg)\n     sys.exit(1)\n \n+\n if '--help' in sys.argv or '-h' in sys.argv:\n     print('Usage: ./configure [options]')\n     print('')\n@@ -208,7 +216,7 @@ def err(msg):\n                 continue\n \n         found = True\n-        if not option.name in known_args:\n+        if option.name not in known_args:\n             known_args[option.name] = []\n         known_args[option.name].append((option, value))\n         break\n@@ -227,27 +235,30 @@ def err(msg):\n # TOML we're going to write out\n config = {}\n \n+\n def build():\n     if 'build' in known_args:\n         return known_args['build'][0][1]\n     return bootstrap.default_build_triple()\n \n+\n def set(key, value):\n-      s = \"{:20} := {}\".format(key, value)\n-      if len(s) < 70:\n-          p(s)\n-      else:\n-          p(s[:70] + \" ...\")\n-\n-      arr = config\n-      parts = key.split('.')\n-      for i, part in enumerate(parts):\n-          if i == len(parts) - 1:\n-              arr[part] = value\n-          else:\n-              if not part in arr:\n-                  arr[part] = {}\n-              arr = arr[part]\n+    s = \"{:20} := {}\".format(key, value)\n+    if len(s) < 70:\n+        p(s)\n+    else:\n+        p(s[:70] + \" ...\")\n+\n+    arr = config\n+    parts = key.split('.')\n+    for i, part in enumerate(parts):\n+        if i == len(parts) - 1:\n+            arr[part] = value\n+        else:\n+            if part not in arr:\n+                arr[part] = {}\n+            arr = arr[part]\n+\n \n for key in known_args:\n     # The `set` option is special and can be passed a bunch of times\n@@ -345,8 +356,9 @@ def set(key, value):\n     targets[target] = sections['target'][:]\n     targets[target][0] = targets[target][0].replace(\"x86_64-unknown-linux-gnu\", target)\n \n+\n # Here we walk through the constructed configuration we have from the parsed\n-# command line arguemnts. We then apply each piece of configuration by\n+# command line arguments. We then apply each piece of configuration by\n # basically just doing a `sed` to change the various configuration line to what\n # we've got configure.\n def to_toml(value):\n@@ -360,7 +372,8 @@ def to_toml(value):\n     elif isinstance(value, str):\n         return \"'\" + value + \"'\"\n     else:\n-        raise 'no toml'\n+        raise RuntimeError('no toml')\n+\n \n def configure_section(lines, config):\n     for key in config:\n@@ -375,10 +388,11 @@ def configure_section(lines, config):\n         if not found:\n             raise RuntimeError(\"failed to find config line for {}\".format(key))\n \n+\n for section_key in config:\n     section_config = config[section_key]\n-    if not section_key in sections:\n-        raise RuntimeError(\"config key {} not in sections\".format(key))\n+    if section_key not in sections:\n+        raise RuntimeError(\"config key {} not in sections\".format(section_key))\n \n     if section_key == 'target':\n         for target in section_config:\n@@ -407,11 +421,6 @@ def configure_section(lines, config):\n     contents = contents.replace(\"$(CFG_PYTHON)\", sys.executable)\n     f.write(contents)\n \n-# Finally, clean up with a bit of a help message\n-relpath = os.path.dirname(__file__)\n-if relpath == '':\n-    relpath = '.'\n-\n p(\"\")\n-p(\"run `python {}/x.py --help`\".format(relpath))\n+p(\"run `python {}/x.py --help`\".format(rust_dir))\n p(\"\")"}, {"sha": "e79f6e086ae04a64662595b48e5e2f205749bcab", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 113, "deletions": 92, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -176,7 +176,7 @@ fn make_win_dist(\n         }\n     }\n \n-    let target_tools = [\"gcc.exe\", \"ld.exe\", \"ar.exe\", \"dlltool.exe\", \"libwinpthread-1.dll\"];\n+    let target_tools = [\"gcc.exe\", \"ld.exe\", \"dlltool.exe\", \"libwinpthread-1.dll\"];\n     let mut rustc_dlls = vec![\"libstdc++-6.dll\", \"libwinpthread-1.dll\"];\n     if target_triple.starts_with(\"i686-\") {\n         rustc_dlls.push(\"libgcc_s_dw2-1.dll\");\n@@ -630,7 +630,7 @@ impl Step for Analysis {\n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n \n         let src = build.stage_out(compiler, Mode::Libstd)\n-            .join(target).join(\"release\").join(\"deps\");\n+            .join(target).join(build.cargo_dir()).join(\"deps\");\n \n         let image_src = src.join(\"save-analysis\");\n         let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n@@ -738,7 +738,6 @@ impl Step for Src {\n             \"src/liballoc_jemalloc\",\n             \"src/liballoc_system\",\n             \"src/libbacktrace\",\n-            \"src/libcollections\",\n             \"src/libcompiler_builtins\",\n             \"src/libcore\",\n             \"src/liblibc\",\n@@ -1035,7 +1034,7 @@ pub struct Rls {\n }\n \n impl Step for Rls {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -1050,12 +1049,17 @@ impl Step for Rls {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n         assert!(build.config.extended);\n \n+        if !builder.config.toolstate.rls.testing() {\n+            println!(\"skipping Dist RLS stage{} ({})\", stage, target);\n+            return None\n+        }\n+\n         println!(\"Dist RLS stage{} ({})\", stage, target);\n         let src = build.src.join(\"src/tools/rls\");\n         let release_num = build.release_num(\"rls\");\n@@ -1068,10 +1072,12 @@ impl Step for Rls {\n         t!(fs::create_dir_all(&image));\n \n         // Prepare the image directory\n+        // We expect RLS to build, because we've exited this step above if tool\n+        // state for RLS isn't testing.\n         let rls = builder.ensure(tool::Rls {\n             compiler: builder.compiler(stage, build.build),\n             target\n-        });\n+        }).expect(\"Rls to build: toolstate is testing\");\n         install(&rls, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rls\");\n         install(&src.join(\"README.md\"), &doc, 0o644);\n@@ -1102,7 +1108,7 @@ impl Step for Rls {\n            .arg(\"--component-name=rls-preview\");\n \n         build.run(&mut cmd);\n-        distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n+        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n \n@@ -1202,8 +1208,12 @@ impl Step for Extended {\n         // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n         // the std files during uninstall. To do this ensure that rustc comes\n         // before rust-std in the list below.\n-        let mut tarballs = vec![rustc_installer, cargo_installer, rls_installer,\n-                                analysis_installer, std_installer];\n+        let mut tarballs = Vec::new();\n+        tarballs.push(rustc_installer);\n+        tarballs.push(cargo_installer);\n+        tarballs.extend(rls_installer.clone());\n+        tarballs.push(analysis_installer);\n+        tarballs.push(std_installer);\n         if build.config.docs {\n             tarballs.push(docs_installer);\n         }\n@@ -1245,35 +1255,38 @@ impl Step for Extended {\n         }\n         rtf.push_str(\"}\");\n \n+        fn filter(contents: &str, marker: &str) -> String {\n+            let start = format!(\"tool-{}-start\", marker);\n+            let end = format!(\"tool-{}-end\", marker);\n+            let mut lines = Vec::new();\n+            let mut omitted = false;\n+            for line in contents.lines() {\n+                if line.contains(&start) {\n+                    omitted = true;\n+                } else if line.contains(&end) {\n+                    omitted = false;\n+                } else if !omitted {\n+                    lines.push(line);\n+                }\n+            }\n+\n+            lines.join(\"\\n\")\n+        }\n+\n+        let xform = |p: &Path| {\n+            let mut contents = String::new();\n+            t!(t!(File::open(p)).read_to_string(&mut contents));\n+            if rls_installer.is_none() {\n+                contents = filter(&contents, \"rls\");\n+            }\n+            let ret = tmp.join(p.file_name().unwrap());\n+            t!(t!(File::create(&ret)).write_all(contents.as_bytes()));\n+            return ret\n+        };\n+\n         if target.contains(\"apple-darwin\") {\n             let pkg = tmp.join(\"pkg\");\n             let _ = fs::remove_dir_all(&pkg);\n-            t!(fs::create_dir_all(pkg.join(\"rustc\")));\n-            t!(fs::create_dir_all(pkg.join(\"cargo\")));\n-            t!(fs::create_dir_all(pkg.join(\"rust-docs\")));\n-            t!(fs::create_dir_all(pkg.join(\"rust-std\")));\n-            t!(fs::create_dir_all(pkg.join(\"rls\")));\n-            t!(fs::create_dir_all(pkg.join(\"rust-analysis\")));\n-\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rustc\"), target)),\n-                    &pkg.join(\"rustc\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"cargo\"), target)),\n-                    &pkg.join(\"cargo\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-docs\"), target)),\n-                    &pkg.join(\"rust-docs\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-std\"), target)),\n-                    &pkg.join(\"rust-std\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rls\"), target)),\n-                    &pkg.join(\"rls\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-analysis\"), target)),\n-                    &pkg.join(\"rust-analysis\"));\n-\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rustc\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"cargo\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-docs\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-std\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rls\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-analysis\"), 0o755);\n \n             let pkgbuild = |component: &str| {\n                 let mut cmd = Command::new(\"pkgbuild\");\n@@ -1283,12 +1296,23 @@ impl Step for Extended {\n                     .arg(pkg.join(component).with_extension(\"pkg\"));\n                 build.run(&mut cmd);\n             };\n-            pkgbuild(\"rustc\");\n-            pkgbuild(\"cargo\");\n-            pkgbuild(\"rust-docs\");\n-            pkgbuild(\"rust-std\");\n-            pkgbuild(\"rls\");\n-            pkgbuild(\"rust-analysis\");\n+\n+            let prepare = |name: &str| {\n+                t!(fs::create_dir_all(pkg.join(name)));\n+                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target)),\n+                        &pkg.join(name));\n+                install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n+                pkgbuild(name);\n+            };\n+            prepare(\"rustc\");\n+            prepare(\"cargo\");\n+            prepare(\"rust-docs\");\n+            prepare(\"rust-std\");\n+            prepare(\"rust-analysis\");\n+\n+            if rls_installer.is_some() {\n+                prepare(\"rls\");\n+            }\n \n             // create an 'uninstall' package\n             install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n@@ -1298,7 +1322,7 @@ impl Step for Extended {\n             t!(t!(File::create(pkg.join(\"res/LICENSE.txt\"))).write_all(license.as_bytes()));\n             install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n             let mut cmd = Command::new(\"productbuild\");\n-            cmd.arg(\"--distribution\").arg(etc.join(\"pkg/Distribution.xml\"))\n+            cmd.arg(\"--distribution\").arg(xform(&etc.join(\"pkg/Distribution.xml\")))\n                 .arg(\"--resources\").arg(pkg.join(\"res\"))\n                 .arg(distdir(build).join(format!(\"{}-{}.pkg\",\n                                                     pkgname(build, \"rust\"),\n@@ -1310,46 +1334,34 @@ impl Step for Extended {\n         if target.contains(\"windows\") {\n             let exe = tmp.join(\"exe\");\n             let _ = fs::remove_dir_all(&exe);\n-            t!(fs::create_dir_all(exe.join(\"rustc\")));\n-            t!(fs::create_dir_all(exe.join(\"cargo\")));\n-            t!(fs::create_dir_all(exe.join(\"rls\")));\n-            t!(fs::create_dir_all(exe.join(\"rust-analysis\")));\n-            t!(fs::create_dir_all(exe.join(\"rust-docs\")));\n-            t!(fs::create_dir_all(exe.join(\"rust-std\")));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rustc\"), target))\n-                        .join(\"rustc\"),\n-                    &exe.join(\"rustc\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"cargo\"), target))\n-                        .join(\"cargo\"),\n-                    &exe.join(\"cargo\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-docs\"), target))\n-                        .join(\"rust-docs\"),\n-                    &exe.join(\"rust-docs\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-std\"), target))\n-                        .join(format!(\"rust-std-{}\", target)),\n-                    &exe.join(\"rust-std\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rls\"), target)).join(\"rls-preview\"),\n-                 &exe.join(\"rls\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-analysis\"), target))\n-                        .join(format!(\"rust-analysis-{}\", target)),\n-                    &exe.join(\"rust-analysis\"));\n-\n-            t!(fs::remove_file(exe.join(\"rustc/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"cargo/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"rust-docs/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"rust-std/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"rls/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"rust-analysis/manifest.in\")));\n \n+            let prepare = |name: &str| {\n+                t!(fs::create_dir_all(exe.join(name)));\n+                let dir = if name == \"rust-std\" || name == \"rust-analysis\" {\n+                    format!(\"{}-{}\", name, target)\n+                } else if name == \"rls\" {\n+                    \"rls-preview\".to_string()\n+                } else {\n+                    name.to_string()\n+                };\n+                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target))\n+                            .join(dir),\n+                        &exe.join(name));\n+                t!(fs::remove_file(exe.join(name).join(\"manifest.in\")));\n+            };\n+            prepare(\"rustc\");\n+            prepare(\"cargo\");\n+            prepare(\"rust-analysis\");\n+            prepare(\"rust-docs\");\n+            prepare(\"rust-std\");\n+            if rls_installer.is_some() {\n+                prepare(\"rls\");\n+            }\n             if target.contains(\"windows-gnu\") {\n-                t!(fs::create_dir_all(exe.join(\"rust-mingw\")));\n-                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-mingw\"), target))\n-                            .join(\"rust-mingw\"),\n-                        &exe.join(\"rust-mingw\"));\n-                t!(fs::remove_file(exe.join(\"rust-mingw/manifest.in\")));\n+                prepare(\"rust-mingw\");\n             }\n \n-            install(&etc.join(\"exe/rust.iss\"), &exe, 0o644);\n+            install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n             install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n             install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n             install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n@@ -1413,16 +1425,18 @@ impl Step for Extended {\n                             .arg(\"-dr\").arg(\"Std\")\n                             .arg(\"-var\").arg(\"var.StdDir\")\n                             .arg(\"-out\").arg(exe.join(\"StdGroup.wxs\")));\n-            build.run(Command::new(&heat)\n-                            .current_dir(&exe)\n-                            .arg(\"dir\")\n-                            .arg(\"rls\")\n-                            .args(&heat_flags)\n-                            .arg(\"-cg\").arg(\"RlsGroup\")\n-                            .arg(\"-dr\").arg(\"Rls\")\n-                            .arg(\"-var\").arg(\"var.RlsDir\")\n-                            .arg(\"-out\").arg(exe.join(\"RlsGroup.wxs\"))\n-                            .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+            if rls_installer.is_some() {\n+                build.run(Command::new(&heat)\n+                                .current_dir(&exe)\n+                                .arg(\"dir\")\n+                                .arg(\"rls\")\n+                                .args(&heat_flags)\n+                                .arg(\"-cg\").arg(\"RlsGroup\")\n+                                .arg(\"-dr\").arg(\"Rls\")\n+                                .arg(\"-var\").arg(\"var.RlsDir\")\n+                                .arg(\"-out\").arg(exe.join(\"RlsGroup.wxs\"))\n+                                .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+            }\n             build.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n@@ -1456,26 +1470,30 @@ impl Step for Extended {\n                     .arg(\"-dDocsDir=rust-docs\")\n                     .arg(\"-dCargoDir=cargo\")\n                     .arg(\"-dStdDir=rust-std\")\n-                    .arg(\"-dRlsDir=rls\")\n                     .arg(\"-dAnalysisDir=rust-analysis\")\n                     .arg(\"-arch\").arg(&arch)\n                     .arg(\"-out\").arg(&output)\n                     .arg(&input);\n                 add_env(build, &mut cmd, target);\n \n+                if rls_installer.is_some() {\n+                    cmd.arg(\"-dRlsDir=rls\");\n+                }\n                 if target.contains(\"windows-gnu\") {\n                     cmd.arg(\"-dGccDir=rust-mingw\");\n                 }\n                 build.run(&mut cmd);\n             };\n-            candle(&etc.join(\"msi/rust.wxs\"));\n+            candle(&xform(&etc.join(\"msi/rust.wxs\")));\n             candle(&etc.join(\"msi/ui.wxs\"));\n             candle(&etc.join(\"msi/rustwelcomedlg.wxs\"));\n             candle(\"RustcGroup.wxs\".as_ref());\n             candle(\"DocsGroup.wxs\".as_ref());\n             candle(\"CargoGroup.wxs\".as_ref());\n             candle(\"StdGroup.wxs\".as_ref());\n-            candle(\"RlsGroup.wxs\".as_ref());\n+            if rls_installer.is_some() {\n+                candle(\"RlsGroup.wxs\".as_ref());\n+            }\n             candle(\"AnalysisGroup.wxs\".as_ref());\n \n             if target.contains(\"windows-gnu\") {\n@@ -1499,10 +1517,13 @@ impl Step for Extended {\n                 .arg(\"DocsGroup.wixobj\")\n                 .arg(\"CargoGroup.wixobj\")\n                 .arg(\"StdGroup.wixobj\")\n-                .arg(\"RlsGroup.wixobj\")\n                 .arg(\"AnalysisGroup.wixobj\")\n                 .current_dir(&exe);\n \n+            if rls_installer.is_some() {\n+                cmd.arg(\"RlsGroup.wixobj\");\n+            }\n+\n             if target.contains(\"windows-gnu\") {\n                 cmd.arg(\"GccGroup.wixobj\");\n             }"}, {"sha": "16e8ee182bd8ea106ccc594fd373868411b2dc94", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -66,7 +66,7 @@ macro_rules! book {\n }\n \n book!(\n-    Nomicon, \"src/doc/book\", \"nomicon\";\n+    Nomicon, \"src/doc/nomicon\", \"nomicon\";\n     Reference, \"src/doc/reference\", \"reference\";\n     Rustdoc, \"src/doc/rustdoc\", \"rustdoc\";\n );\n@@ -490,7 +490,7 @@ impl Step for Std {\n         // for which docs must be built.\n         if !build.config.compiler_docs {\n             cargo.arg(\"--no-deps\");\n-            for krate in &[\"alloc\", \"collections\", \"core\", \"std\", \"std_unicode\"] {\n+            for krate in &[\"alloc\", \"core\", \"std\", \"std_unicode\"] {\n                 cargo.arg(\"-p\").arg(krate);\n                 // Create all crate output directories first to make sure rustdoc uses\n                 // relative links.\n@@ -623,11 +623,9 @@ impl Step for Rustc {\n         compile::rustc_cargo(build, &compiler, target, &mut cargo);\n \n         if build.config.compiler_docs {\n-            // src/rustc/Cargo.toml contains bin crates called rustc and rustdoc\n-            // which would otherwise overwrite the docs for the real rustc and\n-            // rustdoc lib crates.\n-            cargo.arg(\"-p\").arg(\"rustc_driver\")\n-                 .arg(\"-p\").arg(\"rustdoc\");\n+            // src/rustc/Cargo.toml contains a bin crate called rustc which\n+            // would otherwise overwrite the docs for the real rustc lib crate.\n+            cargo.arg(\"-p\").arg(\"rustc_driver\");\n         } else {\n             // Like with libstd above if compiler docs aren't enabled then we're not\n             // documenting internal dependencies, so we have a whitelist."}, {"sha": "479283b3595548adf366c437e7ff80a74e63f415", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -240,10 +240,11 @@ pub struct Build {\n     lldb_python_dir: Option<String>,\n \n     // Runtime state filled in later on\n-    // target -> (cc, ar)\n-    cc: HashMap<Interned<String>, (cc::Tool, Option<PathBuf>)>,\n-    // host -> (cc, ar)\n+    // C/C++ compilers and archiver for all targets\n+    cc: HashMap<Interned<String>, cc::Tool>,\n     cxx: HashMap<Interned<String>, cc::Tool>,\n+    ar: HashMap<Interned<String>, PathBuf>,\n+    // Misc\n     crates: HashMap<Interned<String>, Crate>,\n     is_sudo: bool,\n     ci_env: CiEnv,\n@@ -324,6 +325,7 @@ impl Build {\n             rls_info,\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n+            ar: HashMap::new(),\n             crates: HashMap::new(),\n             lldb_version: None,\n             lldb_python_dir: None,\n@@ -383,16 +385,19 @@ impl Build {\n     /// Clear out `dir` if `input` is newer.\n     ///\n     /// After this executes, it will also ensure that `dir` exists.\n-    fn clear_if_dirty(&self, dir: &Path, input: &Path) {\n+    fn clear_if_dirty(&self, dir: &Path, input: &Path) -> bool {\n         let stamp = dir.join(\".stamp\");\n+        let mut cleared = false;\n         if mtime(&stamp) < mtime(input) {\n             self.verbose(&format!(\"Dirty - {}\", dir.display()));\n             let _ = fs::remove_dir_all(dir);\n+            cleared = true;\n         } else if stamp.exists() {\n-            return\n+            return cleared;\n         }\n         t!(fs::create_dir_all(dir));\n         t!(File::create(stamp));\n+        cleared\n     }\n \n     /// Get the space-separated set of activated features for the standard\n@@ -433,6 +438,12 @@ impl Build {\n         if self.config.rust_optimize {\"release\"} else {\"debug\"}\n     }\n \n+    fn tools_dir(&self, compiler: Compiler) -> PathBuf {\n+        let out = self.out.join(&*compiler.host).join(format!(\"stage{}-tools-bin\", compiler.stage));\n+        t!(fs::create_dir_all(&out));\n+        out\n+    }\n+\n     /// Get the directory for incremental by-products when using the\n     /// given compiler.\n     fn incremental_dir(&self, compiler: Compiler) -> PathBuf {\n@@ -612,15 +623,15 @@ impl Build {\n \n     /// Returns the path to the C compiler for the target specified.\n     fn cc(&self, target: Interned<String>) -> &Path {\n-        self.cc[&target].0.path()\n+        self.cc[&target].path()\n     }\n \n     /// Returns a list of flags to pass to the C compiler for the target\n     /// specified.\n     fn cflags(&self, target: Interned<String>) -> Vec<String> {\n         // Filter out -O and /O (the optimization flags) that we picked up from\n         // cc-rs because the build scripts will determine that for themselves.\n-        let mut base = self.cc[&target].0.args().iter()\n+        let mut base = self.cc[&target].args().iter()\n                            .map(|s| s.to_string_lossy().into_owned())\n                            .filter(|s| !s.starts_with(\"-O\") && !s.starts_with(\"/O\"))\n                            .collect::<Vec<_>>();\n@@ -644,7 +655,7 @@ impl Build {\n \n     /// Returns the path to the `ar` archive utility for the target specified.\n     fn ar(&self, target: Interned<String>) -> Option<&Path> {\n-        self.cc[&target].1.as_ref().map(|p| &**p)\n+        self.ar.get(&target).map(|p| &**p)\n     }\n \n     /// Returns the path to the C++ compiler for the target specified.\n@@ -657,21 +668,17 @@ impl Build {\n         }\n     }\n \n-    /// Returns flags to pass to the compiler to generate code for `target`.\n-    fn rustc_flags(&self, target: Interned<String>) -> Vec<String> {\n-        // New flags should be added here with great caution!\n-        //\n-        // It's quite unfortunate to **require** flags to generate code for a\n-        // target, so it should only be passed here if absolutely necessary!\n-        // Most default configuration should be done through target specs rather\n-        // than an entry here.\n-\n-        let mut base = Vec::new();\n-        if target != self.config.build && !target.contains(\"msvc\") &&\n-            !target.contains(\"emscripten\") {\n-            base.push(format!(\"-Clinker={}\", self.cc(target).display()));\n+    /// Returns the path to the linker for the given target if it needs to be overriden.\n+    fn linker(&self, target: Interned<String>) -> Option<&Path> {\n+        if let Some(linker) = self.config.target_config.get(&target)\n+                                                       .and_then(|c| c.linker.as_ref()) {\n+            Some(linker)\n+        } else if target != self.config.build &&\n+                  !target.contains(\"msvc\") && !target.contains(\"emscripten\") {\n+            Some(self.cc(target))\n+        } else {\n+            None\n         }\n-        base\n     }\n \n     /// Returns if this target should statically link the C runtime, if specified"}, {"sha": "c37b1dad4c687cd9698543861ec74433206c3ab0", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -227,6 +227,13 @@ impl Step for Llvm {\n             cfg.build_arg(\"-j\").build_arg(build.jobs().to_string());\n             cfg.define(\"CMAKE_C_FLAGS\", build.cflags(target).join(\" \"));\n             cfg.define(\"CMAKE_CXX_FLAGS\", build.cflags(target).join(\" \"));\n+            if let Some(ar) = build.ar(target) {\n+                if ar.is_absolute() {\n+                    // LLVM build breaks if `CMAKE_AR` is a relative path, for some reason it\n+                    // tries to resolve this path in the LLVM build directory.\n+                    cfg.define(\"CMAKE_AR\", sanitize_cc(ar));\n+                }\n+            }\n         };\n \n         configure_compilers(&mut cfg);\n@@ -252,11 +259,14 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n \n     let mut cmd = Command::new(llvm_config);\n     let version = output(cmd.arg(\"--version\"));\n-    if version.starts_with(\"3.5\") || version.starts_with(\"3.6\") ||\n-       version.starts_with(\"3.7\") {\n-        return\n+    let mut parts = version.split('.').take(2)\n+        .filter_map(|s| s.parse::<u32>().ok());\n+    if let (Some(major), Some(minor)) = (parts.next(), parts.next()) {\n+        if major > 3 || (major == 3 && minor >= 9) {\n+            return\n+        }\n     }\n-    panic!(\"\\n\\nbad LLVM version: {}, need >=3.5\\n\\n\", version)\n+    panic!(\"\\n\\nbad LLVM version: {}, need >=3.9\\n\\n\", version)\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -352,34 +362,51 @@ impl Step for Openssl {\n             // originally from https://www.openssl.org/source/...\n             let url = format!(\"https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/{}\",\n                               name);\n-            let mut ok = false;\n+            let mut last_error = None;\n             for _ in 0..3 {\n                 let status = Command::new(\"curl\")\n                                 .arg(\"-o\").arg(&tmp)\n+                                .arg(\"-f\")  // make curl fail if the URL does not return HTTP 200\n                                 .arg(&url)\n                                 .status()\n                                 .expect(\"failed to spawn curl\");\n-                if status.success() {\n-                    ok = true;\n-                    break\n+\n+                // Retry if download failed.\n+                if !status.success() {\n+                    last_error = Some(status.to_string());\n+                    continue;\n                 }\n+\n+                // Ensure the hash is correct.\n+                let mut shasum = if target.contains(\"apple\") || build.build.contains(\"netbsd\") {\n+                    let mut cmd = Command::new(\"shasum\");\n+                    cmd.arg(\"-a\").arg(\"256\");\n+                    cmd\n+                } else {\n+                    Command::new(\"sha256sum\")\n+                };\n+                let output = output(&mut shasum.arg(&tmp));\n+                let found = output.split_whitespace().next().unwrap();\n+\n+                // If the hash is wrong, probably the download is incomplete or S3 served an error\n+                // page. In any case, retry.\n+                if found != OPENSSL_SHA256 {\n+                    last_error = Some(format!(\n+                        \"downloaded openssl sha256 different\\n\\\n+                         expected: {}\\n\\\n+                         found:    {}\\n\",\n+                        OPENSSL_SHA256,\n+                        found\n+                    ));\n+                    continue;\n+                }\n+\n+                // Everything is fine, so exit the retry loop.\n+                last_error = None;\n+                break;\n             }\n-            if !ok {\n-                panic!(\"failed to download openssl source\")\n-            }\n-            let mut shasum = if target.contains(\"apple\") || build.build.contains(\"netbsd\") {\n-                let mut cmd = Command::new(\"shasum\");\n-                cmd.arg(\"-a\").arg(\"256\");\n-                cmd\n-            } else {\n-                Command::new(\"sha256sum\")\n-            };\n-            let output = output(&mut shasum.arg(&tmp));\n-            let found = output.split_whitespace().next().unwrap();\n-            if found != OPENSSL_SHA256 {\n-                panic!(\"downloaded openssl sha256 different\\n\\\n-                        expected: {}\\n\\\n-                        found:    {}\\n\", OPENSSL_SHA256, found);\n+            if let Some(error) = last_error {\n+                panic!(\"failed to download openssl source: {}\", error);\n             }\n             t!(fs::rename(&tmp, &tarball));\n         }"}, {"sha": "688ee6ba295fa286f13ff57c26a21c9c78c9018a", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 57, "deletions": 33, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -38,24 +38,40 @@ impl Step for CleanTools {\n         run.never()\n     }\n \n-    /// Build a tool in `src/tools`\n-    ///\n-    /// This will build the specified tool with the specified `host` compiler in\n-    /// `stage` into the normal cargo output directory.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n         let mode = self.mode;\n \n-        let stamp = match mode {\n-            Mode::Libstd => libstd_stamp(build, compiler, target),\n-            Mode::Libtest => libtest_stamp(build, compiler, target),\n-            Mode::Librustc => librustc_stamp(build, compiler, target),\n-            _ => panic!(),\n+        // This is for the original compiler, but if we're forced to use stage 1, then\n+        // std/test/rustc stamps won't exist in stage 2, so we need to get those from stage 1, since\n+        // we copy the libs forward.\n+        let tools_dir = build.stage_out(compiler, Mode::Tool);\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n+        } else {\n+            compiler\n         };\n-        let out_dir = build.cargo_out(compiler, Mode::Tool, target);\n-        build.clear_if_dirty(&out_dir, &stamp);\n+\n+        for &cur_mode in &[Mode::Libstd, Mode::Libtest, Mode::Librustc] {\n+            let stamp = match cur_mode {\n+                Mode::Libstd => libstd_stamp(build, compiler, target),\n+                Mode::Libtest => libtest_stamp(build, compiler, target),\n+                Mode::Librustc => librustc_stamp(build, compiler, target),\n+                _ => panic!(),\n+            };\n+\n+            if build.clear_if_dirty(&tools_dir, &stamp) {\n+                break;\n+            }\n+\n+            // If we are a rustc tool, and std changed, we also need to clear ourselves out -- our\n+            // dependencies depend on std. Therefore, we iterate up until our own mode.\n+            if mode == cur_mode {\n+                break;\n+            }\n+        }\n     }\n }\n \n@@ -70,7 +86,7 @@ struct ToolBuild {\n }\n \n impl Step for ToolBuild {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.never()\n@@ -80,7 +96,7 @@ impl Step for ToolBuild {\n     ///\n     /// This will build the specified tool with the specified `host` compiler in\n     /// `stage` into the normal cargo output directory.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n@@ -100,7 +116,15 @@ impl Step for ToolBuild {\n \n         let mut cargo = prepare_tool_cargo(builder, compiler, target, \"build\", path);\n         build.run_expecting(&mut cargo, expectation);\n-        build.cargo_out(compiler, Mode::Tool, target).join(exe(tool, &compiler.host))\n+        if expectation == BuildExpectation::Succeeding || expectation == BuildExpectation::None {\n+            let cargo_out = build.cargo_out(compiler, Mode::Tool, target)\n+                .join(exe(tool, &compiler.host));\n+            let bin = build.tools_dir(compiler).join(exe(tool, &compiler.host));\n+            copy(&cargo_out, &bin);\n+            Some(bin)\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -169,12 +193,12 @@ macro_rules! tool {\n             }\n \n             pub fn tool_default_stage(&self, tool: Tool) -> u32 {\n-                // Compile the error-index in the top stage as it depends on\n-                // rustdoc, so we want to avoid recompiling rustdoc twice if we\n-                // can. Otherwise compile everything else in stage0 as there's\n-                // no need to rebootstrap everything\n+                // Compile the error-index in the same stage as rustdoc to avoid\n+                // recompiling rustdoc twice if we can. Otherwise compile\n+                // everything else in stage0 as there's no need to rebootstrap\n+                // everything.\n                 match tool {\n-                    Tool::ErrorIndex => self.top_stage,\n+                    Tool::ErrorIndex if self.top_stage >= 2 => self.top_stage,\n                     _ => 0,\n                 }\n             }\n@@ -209,7 +233,7 @@ macro_rules! tool {\n                     mode: $mode,\n                     path: $path,\n                     expectation: BuildExpectation::None,\n-                })\n+                }).expect(\"expected to build -- BuildExpectation::None\")\n             }\n         }\n         )+\n@@ -257,7 +281,7 @@ impl Step for RemoteTestServer {\n             mode: Mode::Libstd,\n             path: \"src/tools/remote-test-server\",\n             expectation: BuildExpectation::None,\n-        })\n+        }).expect(\"expected to build -- BuildExpectation::None\")\n     }\n }\n \n@@ -375,7 +399,7 @@ impl Step for Cargo {\n             mode: Mode::Librustc,\n             path: \"src/tools/cargo\",\n             expectation: BuildExpectation::None,\n-        })\n+        }).expect(\"BuildExpectation::None - expected to build\")\n     }\n }\n \n@@ -386,8 +410,8 @@ pub struct Clippy {\n }\n \n impl Step for Clippy {\n-    type Output = PathBuf;\n-    const DEFAULT: bool = false;\n+    type Output = Option<PathBuf>;\n+    const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -401,7 +425,7 @@ impl Step for Clippy {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         // Clippy depends on procedural macros (serde), which requires a full host\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(compile::Rustc {\n@@ -411,7 +435,7 @@ impl Step for Clippy {\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,\n-            tool: \"clippy\",\n+            tool: \"clippy-driver\",\n             mode: Mode::Librustc,\n             path: \"src/tools/clippy\",\n             expectation: builder.build.config.toolstate.clippy.passes(ToolState::Compiling),\n@@ -426,7 +450,7 @@ pub struct Rls {\n }\n \n impl Step for Rls {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -442,7 +466,7 @@ impl Step for Rls {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         builder.ensure(native::Openssl {\n             target: self.target,\n         });\n@@ -470,7 +494,7 @@ pub struct Rustfmt {\n }\n \n impl Step for Rustfmt {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -486,7 +510,7 @@ impl Step for Rustfmt {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,\n@@ -506,7 +530,7 @@ pub struct Miri {\n }\n \n impl Step for Miri {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -522,7 +546,7 @@ impl Step for Miri {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,\n@@ -561,7 +585,7 @@ impl<'a> Builder<'a> {\n         if compiler.host.contains(\"msvc\") {\n             let curpaths = env::var_os(\"PATH\").unwrap_or_default();\n             let curpaths = env::split_paths(&curpaths).collect::<Vec<_>>();\n-            for &(ref k, ref v) in self.cc[&compiler.host].0.env() {\n+            for &(ref k, ref v) in self.cc[&compiler.host].env() {\n                 if k != \"PATH\" {\n                     continue\n                 }"}, {"sha": "328cbf0e5d7102e35fdd143131994719935bbe4f", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -31,6 +31,13 @@ impl ToolState {\n             BuildExpectation::Failing\n         }\n     }\n+\n+    pub fn testing(&self) -> bool {\n+        match *self {\n+            ToolState::Testing => true,\n+            _ => false,\n+        }\n+    }\n }\n \n impl Default for ToolState {"}, {"sha": "2506048858f2b67dadf83f970214815c062cc2a8", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -14,8 +14,9 @@\n //! not a lot of interesting happenings here unfortunately.\n \n use std::env;\n-use std::fs;\n-use std::io::{self, Write};\n+use std::str;\n+use std::fs::{self, File};\n+use std::io::{self, Read, Write};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{SystemTime, Instant};\n@@ -50,6 +51,22 @@ pub fn copy(src: &Path, dst: &Path) {\n     t!(filetime::set_file_times(dst, atime, mtime));\n }\n \n+pub fn read_stamp_file(stamp: &Path) -> Vec<PathBuf> {\n+    let mut paths = Vec::new();\n+    let mut contents = Vec::new();\n+    t!(t!(File::open(stamp)).read_to_end(&mut contents));\n+    // This is the method we use for extracting paths from the stamp file passed to us. See\n+    // run_cargo for more information (in compile.rs).\n+    for part in contents.split(|b| *b == 0) {\n+        if part.is_empty() {\n+            continue\n+        }\n+        let path = PathBuf::from(t!(str::from_utf8(part)));\n+        paths.push(path);\n+    }\n+    paths\n+}\n+\n /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n /// when this function is called.\n pub fn cp_r(src: &Path, dst: &Path) {"}, {"sha": "97723e260f6cb4404aa04618a546f474db70b024", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -138,27 +138,6 @@ pub fn gnu_target(target: &str) -> String {\n     }\n }\n \n-pub fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n-    if target.contains(\"msvc\") {\n-        None\n-    } else if target.contains(\"musl\") {\n-        Some(PathBuf::from(\"ar\"))\n-    } else if target.contains(\"openbsd\") {\n-        Some(PathBuf::from(\"ar\"))\n-    } else {\n-        let parent = cc.parent().unwrap();\n-        let file = cc.file_name().unwrap().to_str().unwrap();\n-        for suffix in &[\"gcc\", \"cc\", \"clang\"] {\n-            if let Some(idx) = file.rfind(suffix) {\n-                let mut file = file[..idx].to_owned();\n-                file.push_str(\"ar\");\n-                return Some(parent.join(&file));\n-            }\n-        }\n-        Some(parent.join(file))\n-    }\n-}\n-\n pub fn make(host: &str) -> PathBuf {\n     if host.contains(\"bitrig\") || host.contains(\"dragonfly\") ||\n         host.contains(\"freebsd\") || host.contains(\"netbsd\") ||"}, {"sha": "c0bf689e39db967ece1aa2aef81d95f6a177064a", "filename": "src/ci/docker/asmjs/Dockerfile", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -16,6 +16,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY scripts/emscripten.sh /scripts/\n RUN bash /scripts/emscripten.sh\n \n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n ENV PATH=$PATH:/emsdk-portable\n ENV PATH=$PATH:/emsdk-portable/clang/e1.37.13_64bit/\n ENV PATH=$PATH:/emsdk-portable/emscripten/1.37.13/\n@@ -28,7 +31,4 @@ ENV TARGETS=asmjs-unknown-emscripten\n \n ENV RUST_CONFIGURE_ARGS --target=$TARGETS\n \n-ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n+ENV SCRIPT python2.7 ../x.py test --target $TARGETS src/test/run-pass"}, {"sha": "567e5d9ac9863ffa4911bfc1693443687f977679", "filename": "src/ci/docker/cross/build-arm-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fcross%2Fbuild-arm-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fcross%2Fbuild-arm-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2Fbuild-arm-musl.sh?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -11,7 +11,7 @@\n \n set -ex\n \n-MUSL=1.1.16\n+MUSL=1.1.17\n \n hide_output() {\n   set +x"}, {"sha": "cc260382f494628102f7c2f59bc7f8f56ea5f4fc", "filename": "src/ci/docker/cross2/Dockerfile", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fcross2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fcross2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross2%2FDockerfile?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -0,0 +1,54 @@\n+FROM ubuntu:16.04\n+\n+COPY scripts/cross-apt-packages.sh /scripts/\n+RUN sh /scripts/cross-apt-packages.sh\n+\n+RUN apt-get build-dep -y clang llvm && apt-get install -y --no-install-recommends \\\n+  build-essential \\\n+  gcc-multilib \\\n+  libedit-dev \\\n+  libgmp-dev \\\n+  libisl-dev \\\n+  libmpc-dev \\\n+  libmpfr-dev \\\n+  ninja-build \\\n+  nodejs \\\n+  python2.7-dev \\\n+  software-properties-common \\\n+  unzip\n+\n+RUN apt-key adv --batch --yes --keyserver keyserver.ubuntu.com --recv-keys 74DA7924C5513486\n+RUN add-apt-repository -y 'deb http://apt.dilos.org/dilos dilos2-testing main'\n+\n+WORKDIR /tmp\n+COPY cross2/shared.sh cross2/build-fuchsia-toolchain.sh /tmp/\n+COPY cross2/build-solaris-toolchain.sh /tmp/\n+RUN /tmp/build-fuchsia-toolchain.sh\n+RUN /tmp/build-solaris-toolchain.sh x86_64  amd64   solaris-i386\n+RUN /tmp/build-solaris-toolchain.sh sparcv9 sparcv9 solaris-sparc\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV \\\n+    AR_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-ar \\\n+    CC_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-clang \\\n+    CXX_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-clang++ \\\n+    AR_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-ar \\\n+    CC_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang \\\n+    CXX_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang++ \\\n+    AR_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-ar \\\n+    CC_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-gcc \\\n+    CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n+    AR_x86_64_sun_solaris=x86_64-sun-solaris2.10-ar \\\n+    CC_x86_64_sun_solaris=x86_64-sun-solaris2.10-gcc \\\n+    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++\n+\n+ENV TARGETS=x86_64-unknown-fuchsia\n+ENV TARGETS=$TARGETS,aarch64-unknown-fuchsia\n+ENV TARGETS=$TARGETS,sparcv9-sun-solaris\n+ENV TARGETS=$TARGETS,x86_64-sun-solaris\n+ENV TARGETS=$TARGETS,x86_64-unknown-linux-gnux32\n+\n+ENV RUST_CONFIGURE_ARGS --target=$TARGETS --enable-extended\n+ENV SCRIPT python2.7 ../x.py dist --target $TARGETS"}, {"sha": "756013a235cc15ce3d9a4d6d9fbfe2e283209b58", "filename": "src/ci/docker/cross2/build-fuchsia-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fcross2%2Fbuild-fuchsia-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fcross2%2Fbuild-fuchsia-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross2%2Fbuild-fuchsia-toolchain.sh?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "previous_filename": "src/ci/docker/dist-fuchsia/build-toolchain.sh"}, {"sha": "71ab998aab20dd1f7f8fc1552525c10bbb6d9b77", "filename": "src/ci/docker/cross2/build-solaris-toolchain.sh", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fcross2%2Fbuild-solaris-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fcross2%2Fbuild-solaris-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross2%2Fbuild-solaris-toolchain.sh?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -0,0 +1,107 @@\n+#!/bin/bash\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+source shared.sh\n+\n+ARCH=$1\n+LIB_ARCH=$2\n+APT_ARCH=$3\n+BINUTILS=2.28.1\n+GCC=6.4.0\n+\n+# First up, build binutils\n+mkdir binutils\n+cd binutils\n+\n+curl https://ftp.gnu.org/gnu/binutils/binutils-$BINUTILS.tar.xz | tar xJf -\n+mkdir binutils-build\n+cd binutils-build\n+hide_output ../binutils-$BINUTILS/configure --target=$ARCH-sun-solaris2.10\n+hide_output make -j10\n+hide_output make install\n+\n+cd ../..\n+rm -rf binutils\n+\n+# Next, download and install the relevant solaris packages\n+mkdir solaris\n+cd solaris\n+\n+dpkg --add-architecture $APT_ARCH\n+apt-get update\n+apt-get download $(apt-cache depends --recurse --no-replaces \\\n+  libc-dev:$APT_ARCH       \\\n+  libm-dev:$APT_ARCH       \\\n+  libpthread-dev:$APT_ARCH \\\n+  libresolv-dev:$APT_ARCH  \\\n+  librt-dev:$APT_ARCH      \\\n+  libsocket-dev:$APT_ARCH  \\\n+  system-crt:$APT_ARCH     \\\n+  system-header:$APT_ARCH  \\\n+  | grep \"^\\w\")\n+\n+for deb in *$APT_ARCH.deb; do\n+  dpkg -x $deb .\n+done\n+\n+# Remove Solaris 11 functions that are optionally used by libbacktrace.\n+# This is for Solaris 10 compatibility.\n+rm usr/include/link.h\n+patch -p0  << 'EOF'\n+--- usr/include/string.h\n++++ usr/include/string10.h\n+@@ -93 +92,0 @@\n+-extern size_t strnlen(const char *, size_t);\n+EOF\n+\n+mkdir                  /usr/local/$ARCH-sun-solaris2.10/usr\n+mv usr/include         /usr/local/$ARCH-sun-solaris2.10/usr/include\n+mv usr/lib/$LIB_ARCH/* /usr/local/$ARCH-sun-solaris2.10/lib\n+mv     lib/$LIB_ARCH/* /usr/local/$ARCH-sun-solaris2.10/lib\n+\n+ln -s usr/include /usr/local/$ARCH-sun-solaris2.10/sys-include\n+ln -s usr/include /usr/local/$ARCH-sun-solaris2.10/include\n+\n+cd ..\n+rm -rf solaris\n+\n+# Finally, download and build gcc to target solaris\n+mkdir gcc\n+cd gcc\n+\n+curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.xz | tar xJf -\n+cd gcc-$GCC\n+\n+mkdir ../gcc-build\n+cd ../gcc-build\n+hide_output ../gcc-$GCC/configure \\\n+  --enable-languages=c,c++        \\\n+  --target=$ARCH-sun-solaris2.10  \\\n+  --with-gnu-as                   \\\n+  --with-gnu-ld                   \\\n+  --disable-multilib              \\\n+  --disable-nls                   \\\n+  --disable-libgomp               \\\n+  --disable-libquadmath           \\\n+  --disable-libssp                \\\n+  --disable-libvtv                \\\n+  --disable-libcilkrts            \\\n+  --disable-libada                \\\n+  --disable-libsanitizer          \\\n+  --disable-libquadmath-support   \\\n+  --disable-lto\n+\n+hide_output make -j10\n+hide_output make install\n+\n+cd ../..\n+rm -rf gcc"}, {"sha": "e26c6eb6645781c70b1948a53b8b5e1532d359d7", "filename": "src/ci/docker/cross2/shared.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fcross2%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fcross2%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross2%2Fshared.sh?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "previous_filename": "src/ci/docker/dist-fuchsia/shared.sh"}, {"sha": "bcd95924b427f80600bff1d2acfa20488d7a6d91", "filename": "src/ci/docker/dist-fuchsia/Dockerfile", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile?ref=69ba6738eb6bf9b6d11ebb81af2599648eb0bc04", "patch": "@@ -1,41 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get build-dep -y clang llvm && apt-get install -y \\\n-  build-essential \\\n-  bzip2 \\\n-  ca-certificates \\\n-  cmake \\\n-  curl \\\n-  file \\\n-  g++ \\\n-  gdb \\\n-  git \\\n-  libedit-dev \\\n-  make \\\n-  ninja-build \\\n-  nodejs \\\n-  python2.7-dev \\\n-  sudo \\\n-  xz-utils \\\n-  unzip\n-\n-WORKDIR /tmp\n-COPY dist-fuchsia/shared.sh dist-fuchsia/build-toolchain.sh /tmp/\n-RUN /tmp/build-toolchain.sh\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV \\\n-    AR_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-ar \\\n-    CC_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-clang \\\n-    CXX_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-clang++ \\\n-    AR_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-ar \\\n-    CC_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang \\\n-    CXX_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang++\n-\n-ENV TARGETS=x86_64-unknown-fuchsia\n-ENV TARGETS=$TARGETS,aarch64-unknown-fuchsia\n-\n-ENV RUST_CONFIGURE_ARGS --target=$TARGETS --enable-extended\n-ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n\\ No newline at end of file"}, {"sha": "883859d1fa64e89cd09c9c5917255589fd8926c0", "filename": "src/ci/docker/dist-i586-gnu-i686-musl/build-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2Fbuild-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2Fbuild-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2Fbuild-musl.sh?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -15,7 +15,7 @@ set -ex\n export CFLAGS=\"-fPIC -Wa,-mrelax-relocations=no\"\n export CXXFLAGS=\"-Wa,-mrelax-relocations=no\"\n \n-MUSL=musl-1.1.16\n+MUSL=musl-1.1.17\n curl https://www.musl-libc.org/releases/$MUSL.tar.gz | tar xzf -\n cd $MUSL\n CC=gcc \\"}, {"sha": "9be8d001149e9d10788ab6c416cedfa0d2cd010a", "filename": "src/ci/docker/dist-x86_64-musl/build-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2Fbuild-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2Fbuild-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2Fbuild-musl.sh?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -15,7 +15,7 @@ set -ex\n export CFLAGS=\"-fPIC -Wa,-mrelax-relocations=no\"\n export CXXFLAGS=\"-Wa,-mrelax-relocations=no\"\n \n-MUSL=musl-1.1.16\n+MUSL=musl-1.1.17\n curl https://www.musl-libc.org/releases/$MUSL.tar.gz | tar xzf -\n cd $MUSL\n ./configure --prefix=/musl-x86_64 --disable-shared"}, {"sha": "3aa2b9d58d57afe921423acea218aef31f4f994a", "filename": "src/ci/docker/scripts/android-sdk.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -31,7 +31,7 @@ download_sysimage() {\n     # Keep printing yes to accept the licenses\n     while true; do echo yes; sleep 10; done | \\\n         /android/sdk/tools/android update sdk -a --no-ui \\\n-            --filter \"$filter\"\n+            --filter \"$filter\" --no-https\n }\n \n create_avd() {"}, {"sha": "6b8186048988d089a08c9e8bc8c4aa393c466f82", "filename": "src/ci/docker/x86_64-gnu-llvm-3.9/Dockerfile", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.9%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.9%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.9%2FDockerfile?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -11,15 +11,17 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n-  llvm-3.7-tools \\\n+  llvm-3.9-tools \\\n   libedit-dev \\\n   zlib1g-dev \\\n   xz-utils\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+# using llvm-link-shared due to libffi issues -- see #34486\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n-      --llvm-root=/usr/lib/llvm-3.7\n+      --llvm-root=/usr/lib/llvm-3.9 \\\n+      --enable-llvm-link-shared\n ENV RUST_CHECK_TARGET check", "previous_filename": "src/ci/docker/x86_64-gnu-llvm-3.7/Dockerfile"}, {"sha": "0bb41cee2c518fbed9a7196bd2eb2f1cd373cc4c", "filename": "src/doc/man/rustc.1", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Fman%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Fman%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fman%2Frustc.1?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -152,9 +152,6 @@ never colorize output.\n \n .SH CODEGEN OPTIONS\n \n-.TP\n-\\fBar\\fR=\\fI/path/to/ar\\fR\n-Path to the archive utility to use when assembling archives.\n .TP\n \\fBlinker\\fR=\\fI/path/to/cc\\fR\n Path to the linker utility to use when linking libraries, executables, and"}, {"sha": "8e8e2a7ff1dd5c00b33eb1682eced73fb91dce29", "filename": "src/doc/rustdoc/src/command-line-arguments.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -96,11 +96,11 @@ Using this flag looks like this:\n $ rustdoc src/lib.rs --crate-name mycrate\n ```\n \n-By default, `rustodc` assumes that the name of your crate is the same name\n+By default, `rustdoc` assumes that the name of your crate is the same name\n as the `.rs` file. `--crate-name` lets you override this assumption with\n whatever name you choose.\n \n-## `-L`/`--library-path`: \n+## `-L`/`--library-path`: where to look for dependencies\n \n Using this flag looks like this:\n \n@@ -186,7 +186,7 @@ on documentation tests](documentation-tests.html).\n \n See also `--test-args`.\n \n-## `--test-args`: \n+## `--test-args`: pass options to test runner\n \n Using this flag looks like this:\n \n@@ -199,7 +199,7 @@ For more, see [the chapter on documentation tests](documentation-tests.html).\n \n See also `--test`.\n \n-## `--target`: \n+## `--target`: generate documentation for the specified target triple\n \n Using this flag looks like this:\n \n@@ -253,7 +253,7 @@ $ rustdoc README.md --html-before-content extra.html\n ```\n \n This flag takes a list of files, and inserts them inside the `<body>` tag but\n-before the other content `rustodc` would normally produce in the rendered\n+before the other content `rustdoc` would normally produce in the rendered\n documentation.\n \n ## `--html-after-content`: include more HTML after the content\n@@ -266,7 +266,7 @@ $ rustdoc README.md --html-after-content extra.html\n ```\n \n This flag takes a list of files, and inserts them before the `</body>` tag but\n-after the other content `rustodc` would normally produce in the rendered\n+after the other content `rustdoc` would normally produce in the rendered\n documentation.\n \n "}, {"sha": "11b3ee8edf0b1a13329f818ba7e27f16be297f03", "filename": "src/doc/unstable-book/src/language-features/crate-visibility-modifier.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcrate-visibility-modifier.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcrate-visibility-modifier.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcrate-visibility-modifier.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -0,0 +1,20 @@\n+# `crate_visibility_modifier`\n+\n+The tracking issue for this feature is: [#45388]\n+\n+[#45388]: https://github.com/rust-lang/rust/issues/45388\n+\n+-----\n+\n+The `crate_visibility_modifier` feature allows the `crate` keyword to be used\n+as a visibility modifier synonymous to `pub(crate)`, indicating that a type\n+(function, _&c._) is to be visible to the entire enclosing crate, but not to\n+other crates.\n+\n+```rust\n+#![feature(crate_visibility_modifier)]\n+\n+crate struct Foo {\n+    bar: usize,\n+}\n+```"}, {"sha": "0137a052a62d868f02fcfded212f49fc0e634ba9", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -227,3 +227,95 @@ A third function, `rust_eh_unwind_resume`, is also needed if the `custom_unwind_\n flag is set in the options of the compilation target. It allows customizing the\n process of resuming unwind at the end of the landing pads. The language item's name\n is `eh_unwind_resume`.\n+\n+## List of all language items\n+\n+This is a list of all language items in Rust along with where they are located in\n+the source code.\n+\n+- Primitives\n+  - `i8`: `libcore/num/mod.rs`\n+  - `i16`: `libcore/num/mod.rs`\n+  - `i32`: `libcore/num/mod.rs`\n+  - `i64`: `libcore/num/mod.rs`\n+  - `i128`: `libcore/num/mod.rs`\n+  - `isize`: `libcore/num/mod.rs`\n+  - `u8`: `libcore/num/mod.rs`\n+  - `u16`: `libcore/num/mod.rs`\n+  - `u32`: `libcore/num/mod.rs`\n+  - `u64`: `libcore/num/mod.rs`\n+  - `u128`: `libcore/num/mod.rs`\n+  - `usize`: `libcore/num/mod.rs`\n+  - `f32`: `libstd/f32.rs`\n+  - `f64`: `libstd/f64.rs`\n+  - `char`: `libstd_unicode/char.rs`\n+  - `slice`: `liballoc/slice.rs`\n+  - `str`: `liballoc/str.rs`\n+  - `const_ptr`: `libcore/ptr.rs`\n+  - `mut_ptr`: `libcore/ptr.rs`\n+  - `unsafe_cell`: `libcore/cell.rs`\n+- Runtime\n+  - `start`: `libstd/rt.rs`\n+  - `eh_personality`: `libpanic_unwind/emcc.rs` (EMCC)\n+  - `eh_personality`: `libpanic_unwind/seh64_gnu.rs` (SEH64 GNU)\n+  - `eh_personality`: `libpanic_unwind/seh.rs` (SEH)\n+  - `eh_unwind_resume`: `libpanic_unwind/seh64_gnu.rs` (SEH64 GNU)\n+  - `eh_unwind_resume`: `libpanic_unwind/gcc.rs` (GCC)\n+  - `msvc_try_filter`: `libpanic_unwind/seh.rs` (SEH)\n+  - `panic`: `libcore/panicking.rs`\n+  - `panic_bounds_check`: `libcore/panicking.rs`\n+  - `panic_fmt`: `libcore/panicking.rs`\n+  - `panic_fmt`: `libstd/panicking.rs`\n+- Allocations\n+  - `owned_box`: `liballoc/boxed.rs`\n+  - `exchange_malloc`: `liballoc/heap.rs`\n+  - `box_free`: `liballoc/heap.rs`\n+- Operands\n+  - `not`: `libcore/ops/bit.rs`\n+  - `bitand`: `libcore/ops/bit.rs`\n+  - `bitor`: `libcore/ops/bit.rs`\n+  - `bitxor`: `libcore/ops/bit.rs`\n+  - `shl`: `libcore/ops/bit.rs`\n+  - `shr`: `libcore/ops/bit.rs`\n+  - `bitand_assign`: `libcore/ops/bit.rs`\n+  - `bitor_assign`: `libcore/ops/bit.rs`\n+  - `bitxor_assign`: `libcore/ops/bit.rs`\n+  - `shl_assign`: `libcore/ops/bit.rs`\n+  - `shr_assign`: `libcore/ops/bit.rs`\n+  - `deref`: `libcore/ops/deref.rs`\n+  - `deref_mut`: `libcore/ops/deref.rs`\n+  - `index`: `libcore/ops/index.rs`\n+  - `index_mut`: `libcore/ops/index.rs`\n+  - `add`: `libcore/ops/arith.rs`\n+  - `sub`: `libcore/ops/arith.rs`\n+  - `mul`: `libcore/ops/arith.rs`\n+  - `div`: `libcore/ops/arith.rs`\n+  - `rem`: `libcore/ops/arith.rs`\n+  - `neg`: `libcore/ops/arith.rs`\n+  - `add_assign`: `libcore/ops/arith.rs`\n+  - `sub_assign`: `libcore/ops/arith.rs`\n+  - `mul_assign`: `libcore/ops/arith.rs`\n+  - `div_assign`: `libcore/ops/arith.rs`\n+  - `rem_assign`: `libcore/ops/arith.rs`\n+  - `eq`: `libcore/cmp.rs`\n+  - `ord`: `libcore/cmp.rs`\n+- Functions\n+  - `fn`: `libcore/ops/function.rs`\n+  - `fn_mut`: `libcore/ops/function.rs`\n+  - `fn_once`: `libcore/ops/function.rs`\n+  - `generator_state`: `libcore/ops/generator.rs`\n+  - `generator`: `libcore/ops/generator.rs`\n+- Other\n+  - `coerce_unsized`: `libcore/ops/unsize.rs`\n+  - `drop`: `libcore/ops/drop.rs`\n+  - `drop_in_place`: `libcore/ptr.rs`\n+  - `clone`: `libcore/clone.rs`\n+  - `copy`: `libcore/marker.rs`\n+  - `send`: `libcore/marker.rs`\n+  - `sized`: `libcore/marker.rs`\n+  - `unsize`: `libcore/marker.rs`\n+  - `sync`: `libcore/marker.rs`\n+  - `phantom_data`: `libcore/marker.rs`\n+  - `freeze`: `libcore/marker.rs`\n+  - `debug_trait`: `libcore/fmt/mod.rs`\n+  - `non_zero`: `libcore/nonzero.rs`\n\\ No newline at end of file"}, {"sha": "efb5495fe26acf32334ddd188aaa9db53c644a0b", "filename": "src/doc/unstable-book/src/language-features/non-ascii-idents.md", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -15,4 +15,34 @@ The `non_ascii_idents` feature adds support for non-ASCII identifiers.\n \n const \u03b5: f64 = 0.00001f64;\n const \u03a0: f64 = 3.14f64;\n-```\n\\ No newline at end of file\n+```\n+\n+## Changes to the language reference\n+\n+> **<sup>Lexer:<sup>**  \n+> IDENTIFIER :  \n+> &nbsp;&nbsp; &nbsp;&nbsp; XID_start XID_continue<sup>\\*</sup>  \n+> &nbsp;&nbsp; | `_` XID_continue<sup>+</sup>  \n+\n+An identifier is any nonempty Unicode string of the following form:\n+\n+Either\n+\n+   * The first character has property [`XID_start`]\n+   * The remaining characters have property [`XID_continue`]\n+\n+Or\n+\n+   * The first character is `_`\n+   * The identifier is more than one character, `_` alone is not an identifier\n+   * The remaining characters have property [`XID_continue`]\n+\n+that does _not_ occur in the set of [strict keywords].\n+\n+> **Note**: [`XID_start`] and [`XID_continue`] as character properties cover the\n+> character ranges used to form the more familiar C and Java language-family\n+> identifiers.\n+\n+[`XID_start`]:  http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=\n+[`XID_continue`]: http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=\n+[strict keywords]: ../reference/keywords.html#strict-keywords"}, {"sha": "ee24dd87d90c38a5438f1ec96c1027697c16cb06", "filename": "src/doc/unstable-book/src/language-features/optin-builtin-traits.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -0,0 +1,47 @@\n+# `optin_builtin_traits`\n+\n+The tracking issue for this feature is [#13231] \n+\n+[#13231]: https://github.com/rust-lang/rust/issues/13231\n+\n+----\n+\n+The `optin_builtin_traits` feature gate allows you to define auto traits.\n+\n+Auto traits, like [`Send`] or [`Sync`] in the standard library, are marker traits\n+that are automatically implemented for every type, unless the type, or a type it contains, \n+has explictly opted out via a negative impl. \n+\n+[`Send`]: https://doc.rust-lang.org/std/marker/trait.Send.html\n+[`Sync`]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n+\n+```rust,ignore\n+impl !Type for Trait\n+```\n+\n+Example:\n+\n+```rust\n+#![feature(optin_builtin_traits)]\n+\n+trait Valid {}\n+\n+impl Valid for .. {}\n+\n+struct True;\n+struct False;\n+\n+impl !Valid for False {}\n+\n+struct MaybeValid<T>(T);\n+\n+fn must_be_valid<T: Valid>(_t: T) { }\n+\n+fn main() {\n+    // works\n+    must_be_valid( MaybeValid(True) );\n+                \n+    // compiler error - trait bound not satisfied\n+    // must_be_valid( MaybeValid(False) );\n+}\n+```"}, {"sha": "0eaed7a1989c5ba0304b31c56fbfaa0fa4ad1aa3", "filename": "src/doc/unstable-book/src/language-features/unboxed-closures.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -0,0 +1,25 @@\n+# `unboxed_closures`\n+\n+The tracking issue for this feature is [#29625]\n+\n+See Also: [`fn_traits`](library-features/fn-traits.html)\n+\n+[#29625]: https://github.com/rust-lang/rust/issues/29625\n+\n+----\n+\n+The `unboxed_closures` feature allows you to write functions using the `\"rust-call\"` ABI,\n+required for implmenting the [`Fn*`] family of traits. `\"rust-call\"` functions must have \n+exactly one (non self) argument, a tuple representing the argument list.\n+\n+[`Fn*`]: https://doc.rust-lang.org/std/ops/trait.Fn.html\n+\n+```rust\n+#![feature(unboxed_closures)]\n+\n+extern \"rust-call\" fn add_args(args: (u32, u32)) -> u32 {\n+    args.0 + args.1\n+}\n+\n+fn main() {}\n+```"}, {"sha": "425d4cb79b2df7e359fbd0c05edd3c8155d3156c", "filename": "src/doc/unstable-book/src/library-features/alloc-jemalloc.md", "status": "modified", "additions": 2, "deletions": 51, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -8,55 +8,6 @@ See also [`alloc_system`](library-features/alloc-system.html).\n \n ------------------------\n \n-The compiler currently ships two default allocators: `alloc_system` and\n-`alloc_jemalloc` (some targets don't have jemalloc, however). These allocators\n-are normal Rust crates and contain an implementation of the routines to\n-allocate and deallocate memory. The standard library is not compiled assuming\n-either one, and the compiler will decide which allocator is in use at\n-compile-time depending on the type of output artifact being produced.\n-\n-Binaries generated by the compiler will use `alloc_jemalloc` by default (where\n-available). In this situation the compiler \"controls the world\" in the sense of\n-it has power over the final link. Primarily this means that the allocator\n-decision can be left up the compiler.\n-\n-Dynamic and static libraries, however, will use `alloc_system` by default. Here\n-Rust is typically a 'guest' in another application or another world where it\n-cannot authoritatively decide what allocator is in use. As a result it resorts\n-back to the standard APIs (e.g. `malloc` and `free`) for acquiring and releasing\n-memory.\n-\n-# Switching Allocators\n-\n-Although the compiler's default choices may work most of the time, it's often\n-necessary to tweak certain aspects. Overriding the compiler's decision about\n-which allocator is in use is done simply by linking to the desired allocator:\n-\n-```rust,no_run\n-#![feature(alloc_system)]\n-\n-extern crate alloc_system;\n-\n-fn main() {\n-    let a = Box::new(4); // Allocates from the system allocator.\n-    println!(\"{}\", a);\n-}\n-```\n-\n-In this example the binary generated will not link to jemalloc by default but\n-instead use the system allocator. Conversely to generate a dynamic library which\n-uses jemalloc by default one would write:\n-\n-```rust,ignore\n-#![feature(alloc_jemalloc)]\n-#![crate_type = \"dylib\"]\n-\n-extern crate alloc_jemalloc;\n-\n-pub fn foo() {\n-    let a = Box::new(4); // Allocates from jemalloc.\n-    println!(\"{}\", a);\n-}\n-# fn main() {}\n-```\n+This feature has been replaced by [the `jemallocator` crate on crates.io.][jemallocator].\n \n+[jemallocator]: https://crates.io/crates/jemallocator"}, {"sha": "9effab202cabd909b8c270110f2ff1df5f7fa568", "filename": "src/doc/unstable-book/src/library-features/alloc-system.md", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -1,10 +1,10 @@\n # `alloc_system`\n \n-The tracking issue for this feature is: [#33082]\n+The tracking issue for this feature is: [#32838]\n \n-[#33082]: https://github.com/rust-lang/rust/issues/33082\n+[#32838]: https://github.com/rust-lang/rust/issues/32838\n \n-See also [`alloc_jemalloc`](library-features/alloc-jemalloc.html).\n+See also [`global_allocator`](language-features/global-allocator.html).\n \n ------------------------\n \n@@ -30,13 +30,18 @@ memory.\n \n Although the compiler's default choices may work most of the time, it's often\n necessary to tweak certain aspects. Overriding the compiler's decision about\n-which allocator is in use is done simply by linking to the desired allocator:\n+which allocator is in use is done through the `#[global_allocator]` attribute:\n \n ```rust,no_run\n-#![feature(alloc_system)]\n+#![feature(alloc_system, global_allocator, allocator_api)]\n \n extern crate alloc_system;\n \n+use alloc_system::System;\n+\n+#[global_allocator]\n+static A: System = System;\n+\n fn main() {\n     let a = Box::new(4); // Allocates from the system allocator.\n     println!(\"{}\", a);\n@@ -47,16 +52,26 @@ In this example the binary generated will not link to jemalloc by default but\n instead use the system allocator. Conversely to generate a dynamic library which\n uses jemalloc by default one would write:\n \n+(The `alloc_jemalloc` crate cannot be used to control the global allocator,\n+crate.io\u2019s `jemallocator` crate provides equivalent functionality.)\n+\n+```toml\n+# Cargo.toml\n+[dependencies]\n+jemallocator = \"0.1\"\n+```\n ```rust,ignore\n-#![feature(alloc_jemalloc)]\n+#![feature(global_allocator)]\n #![crate_type = \"dylib\"]\n \n-extern crate alloc_jemalloc;\n+extern crate jemallocator;\n+\n+#[global_allocator]\n+static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;\n \n pub fn foo() {\n     let a = Box::new(4); // Allocates from jemalloc.\n     println!(\"{}\", a);\n }\n # fn main() {}\n ```\n-"}, {"sha": "5c937833c9e26a4489893b4680a58285f3833a37", "filename": "src/doc/unstable-book/src/library-features/collections.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollections.md", "raw_url": "https://github.com/rust-lang/rust/raw/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollections.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollections.md?ref=69ba6738eb6bf9b6d11ebb81af2599648eb0bc04", "patch": "@@ -1,5 +0,0 @@\n-# `collections`\n-\n-This feature is internal to the Rust compiler and is not intended for general use.\n-\n-------------------------"}, {"sha": "72a3f36c10b69ed1d6acc28e9577c085d71e9cd1", "filename": "src/doc/unstable-book/src/library-features/fn-traits.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -0,0 +1,35 @@\n+# `fn_traits`\n+\n+The tracking issue for this feature is [#29625]\n+\n+See Also: [`unboxed_closures`](language-features/unboxed-closures.html)\n+\n+[#29625]: https://github.com/rust-lang/rust/issues/29625\n+\n+----\n+\n+The `fn_traits` feature allows for implementation of the [`Fn*`] traits\n+for creating custom closure-like types.\n+\n+[`Fn*`]: https://doc.rust-lang.org/std/ops/trait.Fn.html\n+\n+```rust\n+#![feature(unboxed_closures)]\n+#![feature(fn_traits)]\n+\n+struct Adder {\n+    a: u32\n+}\n+\n+impl FnOnce<(u32, )> for Adder {\n+    type Output = u32;\n+    extern \"rust-call\" fn call_once(self, b: (u32, )) -> Self::Output {\n+        self.a + b.0\n+    }\n+}\n+\n+fn main() {\n+    let adder = Adder { a: 3 };\n+    assert_eq!(adder(2), 5);\n+}\n+```"}, {"sha": "0612873e28153b445964ccaffb52021098ddf915", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -248,7 +248,10 @@ def __init__(self, val):\n     def to_string(self):\n         (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n         raw_ptr = data_ptr.get_wrapped_value()\n-        return '\"%s\"' % raw_ptr.string(encoding=\"utf-8\", length=length)\n+        return raw_ptr.lazy_string(encoding=\"utf-8\", length=length)\n+\n+    def display_hint(self):\n+        return \"string\"\n \n \n class RustStdVecPrinter(object):\n@@ -278,9 +281,11 @@ def __init__(self, val):\n     def to_string(self):\n         vec = self.__val.get_child_at_index(0)\n         (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(vec)\n-        return '\"%s\"' % data_ptr.get_wrapped_value().string(encoding=\"utf-8\",\n-                                                            length=length)\n+        return data_ptr.get_wrapped_value().lazy_string(encoding=\"utf-8\",\n+                                                        length=length)\n \n+    def display_hint(self):\n+        return \"string\"\n \n class RustOsStringPrinter(object):\n     def __init__(self, val):\n@@ -294,8 +299,10 @@ def to_string(self):\n \n         (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(\n             vec)\n-        return '\"%s\"' % data_ptr.get_wrapped_value().string(length=length)\n+        return data_ptr.get_wrapped_value().lazy_string(length=length)\n \n+    def display_hint(self):\n+        return \"string\"\n \n class RustCStyleVariantPrinter(object):\n     def __init__(self, val):"}, {"sha": "c22d60b6c5df1031313c4ed4e30c3c6e9e6d69de", "filename": "src/etc/installer/exe/rust.iss", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fetc%2Finstaller%2Fexe%2Frust.iss", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fetc%2Finstaller%2Fexe%2Frust.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fexe%2Frust.iss?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -46,7 +46,9 @@ Name: gcc; Description: \"Linker and platform libraries\"; Types: full\n Name: docs; Description: \"HTML documentation\"; Types: full\n Name: cargo; Description: \"Cargo, the Rust package manager\"; Types: full\n Name: std; Description: \"The Rust Standard Library\"; Types: full\n+// tool-rls-start\n Name: rls; Description: \"RLS, the Rust Language Server\"\n+// tool-rls-end\n \n [Files]\n Source: \"rustc/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rust\n@@ -56,8 +58,10 @@ Source: \"rust-mingw/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs;\n Source: \"rust-docs/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: docs\n Source: \"cargo/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: cargo\n Source: \"rust-std/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: std\n+// tool-rls-start\n Source: \"rls/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rls\n Source: \"rust-analysis/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rls\n+// tool-rls-end\n \n [Code]\n const"}, {"sha": "d95b096d732f41ede7743ff8d08341b2d54392fc", "filename": "src/etc/installer/msi/rust.wxs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -170,8 +170,10 @@\n                     <Directory Id=\"Docs\" Name=\".\" />\n                     <Directory Id=\"Cargo\" Name=\".\" />\n                     <Directory Id=\"Std\" Name=\".\" />\n+                    <!-- tool-rls-start -->\n                     <Directory Id=\"Rls\" Name=\".\" />\n                     <Directory Id=\"Analysis\" Name=\".\" />\n+                    <!-- tool-rls-end -->\n                 </Directory>\n             </Directory>\n \n@@ -275,6 +277,7 @@\n                  <ComponentRef Id=\"PathEnvPerMachine\" />\n                  <ComponentRef Id=\"PathEnvPerUser\" />\n         </Feature>\n+        <!-- tool-rls-start -->\n         <Feature Id=\"RLS\"\n                  Title=\"RLS, the Rust Language Server\"\n                  Display=\"7\"\n@@ -283,6 +286,7 @@\n                  <ComponentGroupRef Id=\"RlsGroup\" />\n                  <ComponentGroupRef Id=\"AnalysisGroup\" />\n         </Feature>\n+        <!-- tool-rls-end -->\n \n         <UIRef Id=\"RustUI\" />\n     </Product>"}, {"sha": "077ee17511655b9018ee0fe5e2270d911edb805a", "filename": "src/etc/installer/pkg/Distribution.xml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fetc%2Finstaller%2Fpkg%2FDistribution.xml", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fetc%2Finstaller%2Fpkg%2FDistribution.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fpkg%2FDistribution.xml?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -16,7 +16,9 @@\n       <line choice=\"rust-std\"/>\n       <line choice=\"cargo\"/>\n       <line choice=\"rust-docs\"/>\n+      <!-- tool-rls-start -->\n       <line choice=\"rls\"/>\n+      <!-- tool-rls-end -->\n       </line>\n       <line choice=\"uninstall\" />\n     </choices-outline>\n@@ -62,6 +64,7 @@\n         >\n         <pkg-ref id=\"org.rust-lang.rust-docs\"/>\n     </choice>\n+    <!-- tool-rls-start -->\n     <choice id=\"rls\" visible=\"true\"\n         title=\"RLS\" description=\"RLS, the Rust Language Server\"\n         selected=\"(!choices.uninstall.selected &amp;&amp; choices['rls'].selected) || (choices.uninstall.selected &amp;&amp; choices.install.selected)\"\n@@ -70,11 +73,14 @@\n         <pkg-ref id=\"org.rust-lang.rls\"/>\n         <pkg-ref id=\"org.rust-lang.rust-analysis\"/>\n     </choice>\n+    <!-- tool-rls-end -->\n     <pkg-ref id=\"org.rust-lang.rustc\" version=\"0\" onConclusion=\"none\">rustc.pkg</pkg-ref>\n     <pkg-ref id=\"org.rust-lang.cargo\" version=\"0\" onConclusion=\"none\">cargo.pkg</pkg-ref>\n     <pkg-ref id=\"org.rust-lang.rust-docs\" version=\"0\" onConclusion=\"none\">rust-docs.pkg</pkg-ref>\n     <pkg-ref id=\"org.rust-lang.rust-std\" version=\"0\" onConclusion=\"none\">rust-std.pkg</pkg-ref>\n+    <!-- tool-rls-start -->\n     <pkg-ref id=\"org.rust-lang.rls\" version=\"0\" onConclusion=\"none\">rls.pkg</pkg-ref>\n+    <!-- tool-rls-end -->\n     <pkg-ref id=\"org.rust-lang.rust-analysis\" version=\"0\" onConclusion=\"none\">rust-analysis.pkg</pkg-ref>\n     <pkg-ref id=\"org.rust-lang.uninstall\" version=\"0\" onConclusion=\"none\">uninstall.pkg</pkg-ref>\n     <background file=\"rust-logo.png\" mime-type=\"image/png\""}, {"sha": "24a0ce0ac3611270cd6630a26b1595d48afcc40d", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -81,7 +81,7 @@ def execute_command(command_interpreter, command):\n \n     if res.Succeeded():\n         if res.HasResult():\n-            print(normalize_whitespace(res.GetOutput()), end='\\n')\n+            print(normalize_whitespace(res.GetOutput() or ''), end='\\n')\n \n         # If the command introduced any breakpoints, make sure to register\n         # them with the breakpoint"}, {"sha": "2f282c8281d6eeba11b412101461aef4a2f3baa3", "filename": "src/grammar/lexer.l", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -85,43 +85,60 @@ ident [a-zA-Z\\x80-\\xff_][a-zA-Z0-9\\x80-\\xff_]*\n <blockcomment>(.|\\n)   { }\n \n _        { return UNDERSCORE; }\n+abstract { return ABSTRACT; }\n+alignof  { return ALIGNOF; }\n as       { return AS; }\n+become   { return BECOME; }\n box      { return BOX; }\n break    { return BREAK; }\n+catch    { return CATCH; }\n const    { return CONST; }\n continue { return CONTINUE; }\n crate    { return CRATE; }\n+default  { return DEFAULT; }\n+do       { return DO; }\n else     { return ELSE; }\n enum     { return ENUM; }\n extern   { return EXTERN; }\n false    { return FALSE; }\n+final    { return FINAL; }\n fn       { return FN; }\n for      { return FOR; }\n if       { return IF; }\n impl     { return IMPL; }\n in       { return IN; }\n let      { return LET; }\n loop     { return LOOP; }\n+macro    { return MACRO; }\n match    { return MATCH; }\n mod      { return MOD; }\n move     { return MOVE; }\n mut      { return MUT; }\n+offsetof { return OFFSETOF; }\n+override { return OVERRIDE; }\n priv     { return PRIV; }\n proc     { return PROC; }\n+pure     { return PURE; }\n pub      { return PUB; }\n ref      { return REF; }\n return   { return RETURN; }\n self     { return SELF; }\n+sizeof   { return SIZEOF; }\n static   { return STATIC; }\n struct   { return STRUCT; }\n+super    { return SUPER; }\n trait    { return TRAIT; }\n true     { return TRUE; }\n type     { return TYPE; }\n typeof   { return TYPEOF; }\n+union    { return UNION; }\n unsafe   { return UNSAFE; }\n+unsized  { return UNSIZED; }\n use      { return USE; }\n+virtual  { return VIRTUAL; }\n where    { return WHERE; }\n while    { return WHILE; }\n+yield    { return YIELD; }\n \n {ident}  { return IDENT; }\n \n@@ -189,25 +206,25 @@ while    { return WHILE; }\n \\>\\>= { return SHREQ; }\n \\>    { return '>'; }\n \n-\\x27                                  { BEGIN(ltorchar); yymore(); }\n-<ltorchar>static                      { BEGIN(INITIAL); return STATIC_LIFETIME; }\n-<ltorchar>{ident}                     { BEGIN(INITIAL); return LIFETIME; }\n-<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27      { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27       { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\u\\{[0-9a-fA-F]?{6}\\}\\x27  { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>.\\x27                       { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>[\\x80-\\xff]{2,4}\\x27        { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar><<EOF>>                     { BEGIN(INITIAL); return -1; }\n+\\x27                                      { BEGIN(ltorchar); yymore(); }\n+<ltorchar>static                          { BEGIN(INITIAL); return STATIC_LIFETIME; }\n+<ltorchar>{ident}                         { BEGIN(INITIAL); return LIFETIME; }\n+<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27          { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27           { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>\\\\u\\{([0-9a-fA-F]_*){1,6}\\}\\x27 { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>.\\x27                           { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>[\\x80-\\xff]{2,4}\\x27            { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar><<EOF>>                         { BEGIN(INITIAL); return -1; }\n \n b\\x22              { BEGIN(bytestr); yymore(); }\n <bytestr>\\x22      { BEGIN(suffix); return LIT_BYTE_STR; }\n \n-<bytestr><<EOF>>                { return -1; }\n-<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]   { yymore(); }\n-<bytestr>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n-<bytestr>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n-<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n-<bytestr>(.|\\n)                 { yymore(); }\n+<bytestr><<EOF>>                     { return -1; }\n+<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]        { yymore(); }\n+<bytestr>\\\\x[0-9a-fA-F]{2}           { yymore(); }\n+<bytestr>\\\\u\\{([0-9a-fA-F]_*){1,6}\\} { yymore(); }\n+<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]       { return -1; }\n+<bytestr>(.|\\n)                      { yymore(); }\n \n br\\x22                      { BEGIN(rawbytestr_nohash); yymore(); }\n <rawbytestr_nohash>\\x22     { BEGIN(suffix); return LIT_BYTE_STR_RAW; }\n@@ -252,13 +269,13 @@ br/# {\n }\n <rawbytestr><<EOF>> { return -1; }\n \n-b\\x27                        { BEGIN(byte); yymore(); }\n-<byte>\\\\[nrt\\\\\\x27\\x220]\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\x[0-9a-fA-F]{2}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\u[0-9a-fA-F]{4}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\U[0-9a-fA-F]{8}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>.\\x27                  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte><<EOF>>                { BEGIN(INITIAL); return -1; }\n+b\\x27                           { BEGIN(byte); yymore(); }\n+<byte>\\\\[nrt\\\\\\x27\\x220]\\x27    { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\x[0-9a-fA-F]{2}\\x27     { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\u([0-9a-fA-F]_*){4}\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\U([0-9a-fA-F]_*){8}\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>.\\x27                     { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte><<EOF>>                   { BEGIN(INITIAL); return -1; }\n \n r\\x22           { BEGIN(rawstr); yymore(); }\n <rawstr>\\x22    { BEGIN(suffix); return LIT_STR_RAW; }\n@@ -310,12 +327,12 @@ r/#             {\n \\x22                     { BEGIN(str); yymore(); }\n <str>\\x22                { BEGIN(suffix); return LIT_STR; }\n \n-<str><<EOF>>                { return -1; }\n-<str>\\\\[n\\nr\\rt\\\\\\x27\\x220] { yymore(); }\n-<str>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n-<str>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n-<str>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n-<str>(.|\\n)                 { yymore(); }\n+<str><<EOF>>                     { return -1; }\n+<str>\\\\[n\\nr\\rt\\\\\\x27\\x220]      { yymore(); }\n+<str>\\\\x[0-9a-fA-F]{2}           { yymore(); }\n+<str>\\\\u\\{([0-9a-fA-F]_*){1,6}\\} { yymore(); }\n+<str>\\\\[^n\\nrt\\\\\\x27\\x220]       { return -1; }\n+<str>(.|\\n)                      { yymore(); }\n \n \\<-  { return LARROW; }\n -\\>  { return RARROW; }"}, {"sha": "de1f96aac504653db2d440a8426ea623143abc29", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 208, "deletions": 158, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -62,33 +62,49 @@ extern char *yytext;\n // keywords\n %token SELF\n %token STATIC\n+%token ABSTRACT\n+%token ALIGNOF\n %token AS\n+%token BECOME\n %token BREAK\n+%token CATCH\n %token CRATE\n+%token DO\n %token ELSE\n %token ENUM\n %token EXTERN\n %token FALSE\n+%token FINAL\n %token FN\n %token FOR\n %token IF\n %token IMPL\n %token IN\n %token LET\n %token LOOP\n+%token MACRO\n %token MATCH\n %token MOD\n %token MOVE\n %token MUT\n+%token OFFSETOF\n+%token OVERRIDE\n %token PRIV\n %token PUB\n+%token PURE\n %token REF\n %token RETURN\n+%token SIZEOF\n %token STRUCT\n+%token SUPER\n+%token UNION\n+%token UNSIZED\n %token TRUE\n %token TRAIT\n %token TYPE\n %token UNSAFE\n+%token VIRTUAL\n+%token YIELD\n %token DEFAULT\n %token USE\n %token WHILE\n@@ -141,6 +157,10 @@ extern char *yytext;\n // 'foo:bar . <' is shifted (in a trait reference occurring in a\n // bounds list), parsing as foo:(bar<baz>) rather than (foo:bar)<baz>.\n %precedence IDENT\n+ // Put the weak keywords that can be used as idents here as well\n+%precedence CATCH\n+%precedence DEFAULT\n+%precedence UNION\n \n // A couple fake-precedence symbols to use in rules associated with +\n // and < in trailing type contexts. These come up when you have a type\n@@ -161,13 +181,13 @@ extern char *yytext;\n %precedence FOR\n \n // Binops & unops, and their precedences\n+%precedence '?'\n %precedence BOX\n-%precedence BOXPLACE\n %nonassoc DOTDOT\n \n // RETURN needs to be lower-precedence than tokens that start\n // prefix_exprs\n-%precedence RETURN\n+%precedence RETURN YIELD\n \n %right '=' SHLEQ SHREQ MINUSEQ ANDEQ OREQ PLUSEQ STAREQ SLASHEQ CARETEQ PERCENTEQ\n %right LARROW\n@@ -321,6 +341,8 @@ view_path\n | path_no_types_allowed MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n |                       MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $3); }\n | path_no_types_allowed MOD_SEP '*'                        { $$ = mk_node(\"ViewPathGlob\", 1, $1); }\n+|                       MOD_SEP '*'                        { $$ = mk_atom(\"ViewPathGlob\"); }\n+|                               '*'                        { $$ = mk_atom(\"ViewPathGlob\"); }\n |                               '{'                '}'     { $$ = mk_atom(\"ViewPathListEmpty\"); }\n |                               '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $2); }\n |                               '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $2); }\n@@ -334,6 +356,7 @@ block_item\n | item_foreign_mod          { $$ = mk_node(\"ItemForeignMod\", 1, $1); }\n | item_struct\n | item_enum\n+| item_union\n | item_trait\n | item_impl\n ;\n@@ -387,6 +410,7 @@ struct_decl_field\n struct_tuple_fields\n : struct_tuple_field                          { $$ = mk_node(\"StructFields\", 1, $1); }\n | struct_tuple_fields ',' struct_tuple_field  { $$ = ext_node($1, 1, $3); }\n+| %empty                                      { $$ = mk_none(); }\n ;\n \n struct_tuple_field\n@@ -417,6 +441,11 @@ enum_args\n | %empty                         { $$ = mk_none(); }\n ;\n \n+// unions\n+item_union\n+: UNION ident generic_params maybe_where_clause '{' struct_decl_fields '}'     { $$ = mk_node(\"ItemUnion\", 0); }\n+| UNION ident generic_params maybe_where_clause '{' struct_decl_fields ',' '}' { $$ = mk_node(\"ItemUnion\", 0); }\n+\n item_mod\n : MOD ident ';'                                 { $$ = mk_node(\"ItemMod\", 1, $2); }\n | MOD ident '{' maybe_mod_items '}'             { $$ = mk_node(\"ItemMod\", 2, $2, $4); }\n@@ -475,7 +504,7 @@ visibility\n \n idents_or_self\n : ident_or_self                    { $$ = mk_node(\"IdentsOrSelf\", 1, $1); }\n-| ident_or_self AS ident           { $$ = mk_node(\"IdentsOrSelf\", 2, $1, $3); }\n+| idents_or_self AS ident          { $$ = mk_node(\"IdentsOrSelf\", 2, $1, $3); }\n | idents_or_self ',' ident_or_self { $$ = ext_node($1, 1, $3); }\n ;\n \n@@ -515,6 +544,7 @@ trait_item\n : trait_const\n | trait_type\n | trait_method\n+| maybe_outer_attrs item_macro { $$ = mk_node(\"TraitMacroItem\", 2, $1, $2); }\n ;\n \n trait_const\n@@ -547,36 +577,48 @@ trait_method\n ;\n \n type_method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+: maybe_outer_attrs maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n {\n   $$ = mk_node(\"TypeMethod\", 6, $1, $2, $4, $5, $6, $7);\n }\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+| maybe_outer_attrs CONST maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"TypeMethod\", 6, $1, $3, $5, $6, $7, $8);\n+}\n+| maybe_outer_attrs maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n {\n   $$ = mk_node(\"TypeMethod\", 7, $1, $2, $4, $6, $7, $8, $9);\n }\n ;\n \n method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+: maybe_outer_attrs maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n }\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+| maybe_outer_attrs CONST maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 7, $1, $3, $5, $6, $7, $8, $9);\n+}\n+| maybe_outer_attrs maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n }\n ;\n \n impl_method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+: attrs_and_vis maybe_default maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n {\n-  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n+  $$ = mk_node(\"Method\", 8, $1, $2, $3, $5, $6, $7, $8, $9);\n }\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+| attrs_and_vis maybe_default CONST maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n }\n+| attrs_and_vis maybe_default maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 9, $1, $2, $3, $5, $7, $8, $9, $10, $11);\n+}\n ;\n \n // There are two forms of impl:\n@@ -638,26 +680,39 @@ impl_item\n | impl_type\n ;\n \n+maybe_default\n+: DEFAULT { $$ = mk_atom(\"Default\"); }\n+| %empty { $$ = mk_none(); }\n+;\n+\n impl_const\n-: attrs_and_vis item_const { $$ = mk_node(\"ImplConst\", 1, $1, $2); }\n+: attrs_and_vis maybe_default item_const { $$ = mk_node(\"ImplConst\", 3, $1, $2, $3); }\n ;\n \n impl_type\n-: attrs_and_vis TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 4, $1, $3, $4, $6); }\n+: attrs_and_vis maybe_default TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 5, $1, $2, $4, $5, $7); }\n ;\n \n item_fn\n : FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"ItemFn\", 5, $2, $3, $4, $5, $6);\n }\n+| CONST FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemFn\", 5, $3, $4, $5, $6, $7);\n+}\n ;\n \n item_unsafe_fn\n : UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"ItemUnsafeFn\", 5, $3, $4, $5, $6, $7);\n }\n+| CONST UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemUnsafeFn\", 5, $4, $5, $6, $7, $8);\n+}\n | UNSAFE EXTERN maybe_abi FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"ItemUnsafeFn\", 6, $3, $5, $6, $7, $8, $9);\n@@ -723,12 +778,6 @@ inferrable_param\n : pat maybe_ty_ascription { $$ = mk_node(\"InferrableParam\", 2, $1, $2); }\n ;\n \n-maybe_unboxed_closure_kind\n-: %empty\n-| ':'\n-| '&' maybe_mut ':'\n-;\n-\n maybe_comma_params\n : ','            { $$ = mk_none(); }\n | ',' params     { $$ = $2; }\n@@ -784,7 +833,8 @@ ret_ty\n ;\n \n generic_params\n-: '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+: '<' '>'                             { $$ = mk_node(\"Generics\", 2, mk_none(), mk_none()); }\n+| '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n | '<' lifetimes ',' '>'               { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n | '<' lifetimes SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n | '<' lifetimes ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n@@ -837,6 +887,8 @@ path_no_types_allowed\n | MOD_SEP ident                       { $$ = mk_node(\"ViewPath\", 1, $2); }\n | SELF                                { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n | MOD_SEP SELF                        { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n+| SUPER                               { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Super\")); }\n+| MOD_SEP SUPER                       { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Super\")); }\n | path_no_types_allowed MOD_SEP ident { $$ = ext_node($1, 1, $3); }\n ;\n \n@@ -882,7 +934,7 @@ generic_args\n ;\n \n generic_values\n-: maybe_lifetimes maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 2, $1, $2); }\n+: maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 1, $1); }\n ;\n \n maybe_ty_sums_and_or_bindings\n@@ -910,12 +962,11 @@ pat\n | ANDAND pat                                      { $$ = mk_node(\"PatRegion\", 1, mk_node(\"PatRegion\", 1, $2)); }\n | '(' ')'                                         { $$ = mk_atom(\"PatUnit\"); }\n | '(' pat_tup ')'                                 { $$ = mk_node(\"PatTup\", 1, $2); }\n-| '(' pat_tup ',' ')'                             { $$ = mk_node(\"PatTup\", 1, $2); }\n | '[' pat_vec ']'                                 { $$ = mk_node(\"PatVec\", 1, $2); }\n | lit_or_path\n | lit_or_path DOTDOTDOT lit_or_path               { $$ = mk_node(\"PatRange\", 2, $1, $3); }\n | path_expr '{' pat_struct '}'                    { $$ = mk_node(\"PatStruct\", 2, $1, $3); }\n-| path_expr '(' DOTDOT ')'                        { $$ = mk_node(\"PatEnum\", 1, $1); }\n+| path_expr '(' ')'                               { $$ = mk_node(\"PatEnum\", 2, $1, mk_none()); }\n | path_expr '(' pat_tup ')'                       { $$ = mk_node(\"PatEnum\", 2, $1, $3); }\n | path_expr '!' maybe_ident delimited_token_trees { $$ = mk_node(\"PatMac\", 3, $1, $3, $4); }\n | binding_mode ident                              { $$ = mk_node(\"PatIdent\", 2, $1, $2); }\n@@ -953,6 +1004,7 @@ pat_field\n | BOX binding_mode ident        { $$ = mk_node(\"PatField\", 3, mk_atom(\"box\"), $2, $3); }\n |              ident ':' pat    { $$ = mk_node(\"PatField\", 2, $1, $3); }\n | binding_mode ident ':' pat    { $$ = mk_node(\"PatField\", 3, $1, $2, $4); }\n+|        LIT_INTEGER ':' pat    { $$ = mk_node(\"PatField\", 2, mk_atom(yytext), $3); }\n ;\n \n pat_fields\n@@ -965,11 +1017,26 @@ pat_struct\n | pat_fields ','             { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n | pat_fields ',' DOTDOT      { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"true\")); }\n | DOTDOT                     { $$ = mk_node(\"PatStruct\", 1, mk_atom(\"true\")); }\n+| %empty                     { $$ = mk_node(\"PatStruct\", 1, mk_none()); }\n ;\n \n pat_tup\n-: pat               { $$ = mk_node(\"pat_tup\", 1, $1); }\n-| pat_tup ',' pat   { $$ = ext_node($1, 1, $3); }\n+: pat_tup_elts                                  { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts                             ','  { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts     DOTDOT                       { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts ',' DOTDOT                       { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts     DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, $1, $4); }\n+| pat_tup_elts     DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, $1, $4); }\n+| pat_tup_elts ',' DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, $1, $5); }\n+| pat_tup_elts ',' DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, $1, $5); }\n+|                  DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, mk_none(), $3); }\n+|                  DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, mk_none(), $3); }\n+|                  DOTDOT                       { $$ = mk_node(\"PatTup\", 2, mk_none(), mk_none()); }\n+;\n+\n+pat_tup_elts\n+: pat                    { $$ = mk_node(\"PatTupElts\", 1, $1); }\n+| pat_tup_elts ',' pat   { $$ = ext_node($1, 1, $3); }\n ;\n \n pat_vec\n@@ -1007,24 +1074,25 @@ ty\n ;\n \n ty_prim\n-: %prec IDENT path_generic_args_without_colons              { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n-| %prec IDENT MOD_SEP path_generic_args_without_colons      { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n-| %prec IDENT SELF MOD_SEP path_generic_args_without_colons { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n-| BOX ty                                                    { $$ = mk_node(\"TyBox\", 1, $2); }\n-| '*' maybe_mut_or_const ty                                 { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n-| '&' ty                                                    { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n-| '&' MUT ty                                                { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n-| ANDAND ty                                                 { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n-| ANDAND MUT ty                                             { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n-| '&' lifetime maybe_mut ty                                 { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n-| ANDAND lifetime maybe_mut ty                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n-| '[' ty ']'                                                { $$ = mk_node(\"TyVec\", 1, $2); }\n-| '[' ty ',' DOTDOT expr ']'                                { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n-| '[' ty ';' expr ']'                                       { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n-| TYPEOF '(' expr ')'                                       { $$ = mk_node(\"TyTypeof\", 1, $3); }\n-| UNDERSCORE                                                { $$ = mk_atom(\"TyInfer\"); }\n+: %prec IDENT path_generic_args_without_colons                                               { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n+| %prec IDENT MOD_SEP path_generic_args_without_colons                                       { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n+| %prec IDENT SELF MOD_SEP path_generic_args_without_colons                                  { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n+| %prec IDENT path_generic_args_without_colons '!' maybe_ident delimited_token_trees         { $$ = mk_node(\"TyMacro\", 3, $1, $3, $4); }\n+| %prec IDENT MOD_SEP path_generic_args_without_colons '!' maybe_ident delimited_token_trees { $$ = mk_node(\"TyMacro\", 3, $2, $4, $5); }\n+| BOX ty                                                                                     { $$ = mk_node(\"TyBox\", 1, $2); }\n+| '*' maybe_mut_or_const ty                                                                  { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n+| '&' ty                                                                                     { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n+| '&' MUT ty                                                                                 { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n+| ANDAND ty                                                                                  { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n+| ANDAND MUT ty                                                                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n+| '&' lifetime maybe_mut ty                                                                  { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n+| ANDAND lifetime maybe_mut ty                                                               { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n+| '[' ty ']'                                                                                 { $$ = mk_node(\"TyVec\", 1, $2); }\n+| '[' ty ',' DOTDOT expr ']'                                                                 { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n+| '[' ty ';' expr ']'                                                                        { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n+| TYPEOF '(' expr ')'                                                                        { $$ = mk_node(\"TyTypeof\", 1, $3); }\n+| UNDERSCORE                                                                                 { $$ = mk_atom(\"TyInfer\"); }\n | ty_bare_fn\n-| ty_proc\n | for_in_type\n ;\n \n@@ -1046,17 +1114,12 @@ ty_closure\n |        OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $2, $3); }\n ;\n \n-ty_proc\n-: PROC generic_params fn_params maybe_bounds ret_ty { $$ = mk_node(\"TyProc\", 4, $2, $3, $4, $5); }\n-;\n-\n for_in_type\n : FOR '<' maybe_lifetimes '>' for_in_type_suffix { $$ = mk_node(\"ForInType\", 2, $3, $5); }\n ;\n \n for_in_type_suffix\n-: ty_proc\n-| ty_bare_fn\n+: ty_bare_fn\n | trait_ref\n | ty_closure\n ;\n@@ -1100,13 +1163,23 @@ ty_sums\n ;\n \n ty_sum\n-: ty                     { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n+: ty_sum_elt            { $$ = mk_node(\"TySum\", 1, $1); }\n+| ty_sum '+' ty_sum_elt { $$ = ext_node($1, 1, $3); }\n+;\n+\n+ty_sum_elt\n+: ty\n+| lifetime\n ;\n \n ty_prim_sum\n-: ty_prim                     { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty_prim '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n+: ty_prim_sum_elt                 { $$ = mk_node(\"TySum\", 1, $1); }\n+| ty_prim_sum '+' ty_prim_sum_elt { $$ = ext_node($1, 1, $3); }\n+;\n+\n+ty_prim_sum_elt\n+: ty_prim\n+| lifetime\n ;\n \n maybe_ty_param_bounds\n@@ -1127,6 +1200,7 @@ boundseq\n polybound\n : FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $3, $5); }\n | bound\n+| '?' FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $4, $6); }\n | '?' bound { $$ = $2; }\n ;\n \n@@ -1244,26 +1318,22 @@ maybe_stmts\n // block, nonblock-prefix, and nonblock-nonprefix.\n //\n // In non-stmts contexts, expr can relax this trichotomy.\n-//\n-// There is also one other expr subtype: nonparen_expr disallows exprs\n-// surrounded by parens (including tuple expressions), this is\n-// necessary for BOX (place) expressions, so a parens expr following\n-// the BOX is always parsed as the place.\n \n stmts\n : stmt           { $$ = mk_node(\"stmts\", 1, $1); }\n | stmts stmt     { $$ = ext_node($1, 1, $2); }\n ;\n \n stmt\n-: let\n+: maybe_outer_attrs let     { $$ = $2; }\n |                 stmt_item\n |             PUB stmt_item { $$ = $2; }\n | outer_attrs     stmt_item { $$ = $2; }\n | outer_attrs PUB stmt_item { $$ = $3; }\n | full_block_expr\n-| block\n-| nonblock_expr ';'\n+| maybe_outer_attrs block   { $$ = $2; }\n+|             nonblock_expr ';'\n+| outer_attrs nonblock_expr ';' { $$ = $2; }\n | ';'                   { $$ = mk_none(); }\n ;\n \n@@ -1296,7 +1366,9 @@ path_expr\n // expressions.\n path_generic_args_with_colons\n : ident                                              { $$ = mk_node(\"components\", 1, $1); }\n+| SUPER                                              { $$ = mk_atom(\"Super\"); }\n | path_generic_args_with_colons MOD_SEP ident        { $$ = ext_node($1, 1, $3); }\n+| path_generic_args_with_colons MOD_SEP SUPER        { $$ = ext_node($1, 1, mk_atom(\"Super\")); }\n | path_generic_args_with_colons MOD_SEP generic_args { $$ = ext_node($1, 1, $3); }\n ;\n \n@@ -1313,6 +1385,7 @@ nonblock_expr\n | SELF                                                          { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n | macro_expr                                                    { $$ = mk_node(\"ExprMac\", 1, $1); }\n | path_expr '{' struct_expr_fields '}'                          { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| nonblock_expr '?'                                             { $$ = mk_node(\"ExprTry\", 1, $1); }\n | nonblock_expr '.' path_generic_args_with_colons               { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n | nonblock_expr '.' LIT_INTEGER                                 { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n | nonblock_expr '[' maybe_expr ']'                              { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n@@ -1325,6 +1398,8 @@ nonblock_expr\n | RETURN expr                                                   { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                                         { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| YIELD                                                         { $$ = mk_node(\"ExprYield\", 0); }\n+| YIELD expr                                                    { $$ = mk_node(\"ExprYield\", 1, $2); }\n | nonblock_expr LARROW expr                                     { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n@@ -1360,8 +1435,8 @@ nonblock_expr\n |               DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n |               DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n | nonblock_expr AS ty                                           { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                             { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' nonblock_expr           { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n+| nonblock_expr ':' ty                                          { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n+| BOX expr                                                      { $$ = mk_node(\"ExprBox\", 1, $2); }\n | expr_qualified_path\n | nonblock_prefix_expr\n ;\n@@ -1373,6 +1448,7 @@ expr\n | SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n | macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n | path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| expr '?'                                            { $$ = mk_node(\"ExprTry\", 1, $1); }\n | expr '.' path_generic_args_with_colons              { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n | expr '.' LIT_INTEGER                                { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n | expr '[' maybe_expr ']'                             { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n@@ -1385,6 +1461,8 @@ expr\n | RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n+| YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n | expr LARROW expr                                    { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n@@ -1420,69 +1498,8 @@ expr\n |      DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n |      DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n | expr AS ty                                          { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n-| expr_qualified_path\n-| block_expr\n-| block\n-| nonblock_prefix_expr\n-;\n-\n-nonparen_expr\n-: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n-| nonparen_expr '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| nonparen_expr '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| nonparen_expr '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| nonparen_expr '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| nonparen_expr LARROW nonparen_expr                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n-| nonparen_expr '=' nonparen_expr                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| nonparen_expr SHLEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| nonparen_expr SHREQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| nonparen_expr MINUSEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| nonparen_expr ANDEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| nonparen_expr OREQ nonparen_expr                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| nonparen_expr PLUSEQ nonparen_expr                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| nonparen_expr STAREQ nonparen_expr                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| nonparen_expr SLASHEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| nonparen_expr CARETEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| nonparen_expr PERCENTEQ nonparen_expr               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| nonparen_expr OROR nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| nonparen_expr ANDAND nonparen_expr                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| nonparen_expr EQEQ nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| nonparen_expr NE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| nonparen_expr '<' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| nonparen_expr '>' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| nonparen_expr LE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| nonparen_expr GE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| nonparen_expr '|' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| nonparen_expr '^' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| nonparen_expr '&' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| nonparen_expr SHL nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| nonparen_expr SHR nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| nonparen_expr '+' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| nonparen_expr '-' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| nonparen_expr '*' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| nonparen_expr '/' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| nonparen_expr '%' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| nonparen_expr DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| nonparen_expr DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|               DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| nonparen_expr AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n+| expr ':' ty                                         { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n+| BOX expr                                            { $$ = mk_node(\"ExprBox\", 1, $2); }\n | expr_qualified_path\n | block_expr\n | block\n@@ -1495,6 +1512,7 @@ expr_nostruct\n   path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n | SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n | macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| expr_nostruct '?'                                   { $$ = mk_node(\"ExprTry\", 1, $1); }\n | expr_nostruct '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n | expr_nostruct '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n | expr_nostruct '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n@@ -1507,6 +1525,8 @@ expr_nostruct\n | RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n+| YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n | expr_nostruct LARROW expr_nostruct                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n@@ -1542,8 +1562,8 @@ expr_nostruct\n |               DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n |               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n | expr_nostruct AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr_nostruct { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n+| expr_nostruct ':' ty                                { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n+| BOX expr                                            { $$ = mk_node(\"ExprBox\", 1, $2); }\n | expr_qualified_path\n | block_expr\n | block\n@@ -1558,7 +1578,6 @@ nonblock_prefix_expr_nostruct\n | ANDAND maybe_mut expr_nostruct            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n | lambda_expr_nostruct\n | MOVE lambda_expr_nostruct                 { $$ = $2; }\n-| proc_expr_nostruct\n ;\n \n nonblock_prefix_expr\n@@ -1569,7 +1588,6 @@ nonblock_prefix_expr\n | ANDAND maybe_mut expr            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n | lambda_expr\n | MOVE lambda_expr                 { $$ = $2; }\n-| proc_expr\n ;\n \n expr_qualified_path\n@@ -1606,43 +1624,42 @@ maybe_as_trait_ref\n \n lambda_expr\n : %prec LAMBDA\n-  OROR ret_ty expr                                        { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n-| %prec LAMBDA\n-  '|' maybe_unboxed_closure_kind '|' ret_ty expr          { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $4, $5); }\n+  OROR ret_ty expr                                    { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n | %prec LAMBDA\n-  '|' inferrable_params '|' ret_ty expr                   { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n+  '|' '|' ret_ty expr                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $3, $4); }\n | %prec LAMBDA\n-  '|' '&' maybe_mut ':' inferrable_params '|' ret_ty expr { $$ = mk_node(\"ExprFnBlock\", 3, $5, $7, $8); }\n+  '|' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n | %prec LAMBDA\n-  '|' ':' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $3, $5, $6); }\n+  '|' inferrable_params OROR lambda_expr_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $2, mk_none(), $4); }\n ;\n \n-lambda_expr_nostruct\n+lambda_expr_no_first_bar\n : %prec LAMBDA\n-  OROR expr_nostruct                                        { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n-| %prec LAMBDA\n-  '|' maybe_unboxed_closure_kind '|'  expr_nostruct         { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $4); }\n+  '|' ret_ty expr                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n | %prec LAMBDA\n-  '|' inferrable_params '|' expr_nostruct                   { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n+  inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $1, $3, $4); }\n | %prec LAMBDA\n-  '|' '&' maybe_mut ':' inferrable_params '|' expr_nostruct { $$ = mk_node(\"ExprFnBlock\", 2, $5, $7); }\n-| %prec LAMBDA\n-  '|' ':' inferrable_params '|' expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 2, $3, $5); }\n-\n+  inferrable_params OROR lambda_expr_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $1, mk_none(), $3); }\n ;\n \n-proc_expr\n+lambda_expr_nostruct\n : %prec LAMBDA\n-  PROC '(' ')' expr                         { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n+  OROR expr_nostruct                                           { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n+| %prec LAMBDA\n+  '|' '|' ret_ty expr_nostruct                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $3, $4); }\n | %prec LAMBDA\n-  PROC '(' inferrable_params ')' expr       { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n+  '|' inferrable_params '|' expr_nostruct                      { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n+| %prec LAMBDA\n+  '|' inferrable_params OROR lambda_expr_nostruct_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $2, mk_none(), $4); }\n ;\n \n-proc_expr_nostruct\n+lambda_expr_nostruct_no_first_bar\n : %prec LAMBDA\n-  PROC '(' ')' expr_nostruct                     { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n+  '|' ret_ty expr_nostruct                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n+| %prec LAMBDA\n+  inferrable_params '|' ret_ty expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 3, $1, $3, $4); }\n | %prec LAMBDA\n-  PROC '(' inferrable_params ')' expr_nostruct   { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n+  inferrable_params OROR lambda_expr_nostruct_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $1, mk_none(), $3); }\n ;\n \n vec_expr\n@@ -1654,6 +1671,7 @@ struct_expr_fields\n : field_inits\n | field_inits ','\n | maybe_field_inits default_field_init { $$ = ext_node($1, 1, $2); }\n+| %empty                               { $$ = mk_none(); }\n ;\n \n maybe_field_inits\n@@ -1668,7 +1686,9 @@ field_inits\n ;\n \n field_init\n-: ident ':' expr   { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n+: ident                { $$ = mk_node(\"FieldInit\", 1, $1); }\n+| ident ':' expr       { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n+| LIT_INTEGER ':' expr { $$ = mk_node(\"FieldInit\", 2, mk_atom(yytext), $3); }\n ;\n \n default_field_init\n@@ -1689,10 +1709,18 @@ block_expr\n \n full_block_expr\n : block_expr\n-| full_block_expr '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| full_block_expr '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n-| full_block_expr '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n-| full_block_expr '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| block_expr_dot\n+;\n+\n+block_expr_dot\n+: block_expr     '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| block_expr_dot '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| block_expr     '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n+| block_expr_dot '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n+| block_expr     '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n+| block_expr_dot '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n+| block_expr     '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| block_expr_dot '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n ;\n \n expr_match\n@@ -1714,12 +1742,13 @@ match_clause\n ;\n \n nonblock_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr   { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n-| maybe_outer_attrs pats_or maybe_guard FAT_ARROW full_block_expr { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr  { $$ = mk_node(\"ArmNonblock\", 4, $1, $2, $3, $5); }\n+| maybe_outer_attrs pats_or maybe_guard FAT_ARROW block_expr_dot { $$ = mk_node(\"ArmNonblock\", 4, $1, $2, $3, $5); }\n ;\n \n block_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block      { $$ = mk_node(\"ArmBlock\", 4, $1, $2, $3, $5); }\n+| maybe_outer_attrs pats_or maybe_guard FAT_ARROW block_expr { $$ = mk_node(\"ArmBlock\", 4, $1, $2, $3, $5); }\n ;\n \n maybe_guard\n@@ -1796,6 +1825,10 @@ maybe_ident\n \n ident\n : IDENT                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+// Weak keywords that can be used as identifiers\n+| CATCH                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+| DEFAULT                    { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+| UNION                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n ;\n \n unpaired_token\n@@ -1836,35 +1869,52 @@ unpaired_token\n | LIFETIME                   { $$ = mk_atom(yytext); }\n | SELF                       { $$ = mk_atom(yytext); }\n | STATIC                     { $$ = mk_atom(yytext); }\n+| ABSTRACT                   { $$ = mk_atom(yytext); }\n+| ALIGNOF                    { $$ = mk_atom(yytext); }\n | AS                         { $$ = mk_atom(yytext); }\n+| BECOME                     { $$ = mk_atom(yytext); }\n | BREAK                      { $$ = mk_atom(yytext); }\n+| CATCH                      { $$ = mk_atom(yytext); }\n | CRATE                      { $$ = mk_atom(yytext); }\n+| DEFAULT                    { $$ = mk_atom(yytext); }\n+| DO                         { $$ = mk_atom(yytext); }\n | ELSE                       { $$ = mk_atom(yytext); }\n | ENUM                       { $$ = mk_atom(yytext); }\n | EXTERN                     { $$ = mk_atom(yytext); }\n | FALSE                      { $$ = mk_atom(yytext); }\n+| FINAL                      { $$ = mk_atom(yytext); }\n | FN                         { $$ = mk_atom(yytext); }\n | FOR                        { $$ = mk_atom(yytext); }\n | IF                         { $$ = mk_atom(yytext); }\n | IMPL                       { $$ = mk_atom(yytext); }\n | IN                         { $$ = mk_atom(yytext); }\n | LET                        { $$ = mk_atom(yytext); }\n | LOOP                       { $$ = mk_atom(yytext); }\n+| MACRO                      { $$ = mk_atom(yytext); }\n | MATCH                      { $$ = mk_atom(yytext); }\n | MOD                        { $$ = mk_atom(yytext); }\n | MOVE                       { $$ = mk_atom(yytext); }\n | MUT                        { $$ = mk_atom(yytext); }\n+| OFFSETOF                   { $$ = mk_atom(yytext); }\n+| OVERRIDE                   { $$ = mk_atom(yytext); }\n | PRIV                       { $$ = mk_atom(yytext); }\n | PUB                        { $$ = mk_atom(yytext); }\n+| PURE                       { $$ = mk_atom(yytext); }\n | REF                        { $$ = mk_atom(yytext); }\n | RETURN                     { $$ = mk_atom(yytext); }\n | STRUCT                     { $$ = mk_atom(yytext); }\n+| SIZEOF                     { $$ = mk_atom(yytext); }\n+| SUPER                      { $$ = mk_atom(yytext); }\n | TRUE                       { $$ = mk_atom(yytext); }\n | TRAIT                      { $$ = mk_atom(yytext); }\n | TYPE                       { $$ = mk_atom(yytext); }\n+| UNION                      { $$ = mk_atom(yytext); }\n | UNSAFE                     { $$ = mk_atom(yytext); }\n+| UNSIZED                    { $$ = mk_atom(yytext); }\n | USE                        { $$ = mk_atom(yytext); }\n+| VIRTUAL                    { $$ = mk_atom(yytext); }\n | WHILE                      { $$ = mk_atom(yytext); }\n+| YIELD                      { $$ = mk_atom(yytext); }\n | CONTINUE                   { $$ = mk_atom(yytext); }\n | PROC                       { $$ = mk_atom(yytext); }\n | BOX                        { $$ = mk_atom(yytext); }\n@@ -1942,4 +1992,4 @@ brackets_delimited_token_trees\n                $2,\n                mk_node(\"TTTok\", 1, mk_atom(\"]\")));\n }\n-;\n\\ No newline at end of file\n+;"}, {"sha": "15ea738ed0057edd741da93228106a9c3aa8fca8", "filename": "src/grammar/tokens.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fgrammar%2Ftokens.h", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fgrammar%2Ftokens.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftokens.h?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -30,6 +30,7 @@ enum Token {\n   DOTDOT,\n   DOTDOTDOT,\n   MOD_SEP,\n+  LARROW,\n   RARROW,\n   FAT_ARROW,\n   LIT_BYTE,\n@@ -47,35 +48,52 @@ enum Token {\n   // keywords\n   SELF,\n   STATIC,\n+  ABSTRACT,\n+  ALIGNOF,\n   AS,\n+  BECOME,\n   BREAK,\n+  CATCH,\n   CRATE,\n+  DEFAULT,\n+  DO,\n   ELSE,\n   ENUM,\n   EXTERN,\n   FALSE,\n+  FINAL,\n   FN,\n   FOR,\n   IF,\n   IMPL,\n   IN,\n   LET,\n   LOOP,\n+  MACRO,\n   MATCH,\n   MOD,\n   MOVE,\n   MUT,\n+  OFFSETOF,\n+  OVERRIDE,\n   PRIV,\n   PUB,\n+  PURE,\n   REF,\n   RETURN,\n+  SIZEOF,\n   STRUCT,\n+  SUPER,\n+  UNION,\n   TRUE,\n   TRAIT,\n   TYPE,\n   UNSAFE,\n+  UNSIZED,\n   USE,\n+  VIRTUAL,\n   WHILE,\n+  YIELD,\n   CONTINUE,\n   PROC,\n   BOX,"}, {"sha": "3a2022ad429f7ef85150138ac6e83e81c699b4a5", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -70,7 +70,7 @@ impl Layout {\n     ///\n     /// * `align` must be a power of two,\n     ///\n-    /// * `align` must not exceed 2^31 (i.e. `1 << 31`),\n+    /// * `align` must not exceed 2<sup>31</sup> (i.e. `1 << 31`),\n     ///\n     /// * `size`, when rounded up to the nearest multiple of `align`,\n     ///    must not overflow (i.e. the rounded value must be less than\n@@ -113,7 +113,7 @@ impl Layout {\n     /// # Safety\n     ///\n     /// This function is unsafe as it does not verify that `align` is\n-    /// a power-of-two that is also less than or equal to 2^31, nor\n+    /// a power-of-two that is also less than or equal to 2<sup>31</sup>, nor\n     /// that `size` aligned to `align` fits within the address space\n     /// (i.e. the `Layout::from_size_align` preconditions).\n     #[inline]\n@@ -227,7 +227,7 @@ impl Layout {\n         };\n \n         // We can assume that `self.align` is a power-of-two that does\n-        // not exceed 2^31. Furthermore, `alloc_size` has already been\n+        // not exceed 2<sup>31</sup>. Furthermore, `alloc_size` has already been\n         // rounded up to a multiple of `self.align`; therefore, the\n         // call to `Layout::from_size_align` below should never panic.\n         Some((Layout::from_size_align(alloc_size, self.align).unwrap(), padded_size))"}, {"sha": "9481cd4e1a4f170c242d4340b6548dd18618438d", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -52,8 +52,10 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// also destroyed.\n ///\n /// Shared references in Rust disallow mutation by default, and `Arc` is no\n-/// exception. If you need to mutate through an `Arc`, use [`Mutex`][mutex],\n-/// [`RwLock`][rwlock], or one of the [`Atomic`][atomic] types.\n+/// exception: you cannot generally obtain a mutable reference to something\n+/// inside an `Arc`. If you need to mutate through an `Arc`, use\n+/// [`Mutex`][mutex], [`RwLock`][rwlock], or one of the [`Atomic`][atomic]\n+/// types.\n ///\n /// ## Thread Safety\n ///"}, {"sha": "79292d390e5d25b71059656be8383835b13a9cfe", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -269,7 +269,38 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n-        mem::transmute(raw)\n+        Box::from_unique(Unique::new_unchecked(raw))\n+    }\n+\n+    /// Constructs a `Box` from a `Unique<T>` pointer.\n+    ///\n+    /// After calling this function, the memory is owned by a `Box` and `T` can\n+    /// then be destroyed and released upon drop.\n+    ///\n+    /// # Safety\n+    ///\n+    /// A `Unique<T>` can be safely created via [`Unique::new`] and thus doesn't\n+    /// necessarily own the data pointed to nor is the data guaranteed to live\n+    /// as long as the pointer.\n+    ///\n+    /// [`Unique::new`]: ../../core/ptr/struct.Unique.html#method.new\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(unique)]\n+    ///\n+    /// fn main() {\n+    ///     let x = Box::new(5);\n+    ///     let ptr = Box::into_unique(x);\n+    ///     let x = unsafe { Box::from_unique(ptr) };\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n+               issue = \"27730\")]\n+    #[inline]\n+    pub unsafe fn from_unique(u: Unique<T>) -> Self {\n+        mem::transmute(u)\n     }\n \n     /// Consumes the `Box`, returning the wrapped raw pointer.\n@@ -295,21 +326,26 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_raw(b: Box<T>) -> *mut T {\n-        unsafe { mem::transmute(b) }\n+        Box::into_unique(b).as_ptr()\n     }\n \n     /// Consumes the `Box`, returning the wrapped pointer as `Unique<T>`.\n     ///\n     /// After calling this function, the caller is responsible for the\n     /// memory previously managed by the `Box`. In particular, the\n     /// caller should properly destroy `T` and release the memory. The\n-    /// proper way to do so is to convert the raw pointer back into a\n-    /// `Box` with the [`Box::from_raw`] function.\n+    /// proper way to do so is to either convert the `Unique<T>` pointer:\n+    ///\n+    /// - Into a `Box` with the [`Box::from_unique`] function.\n+    ///\n+    /// - Into a raw pointer and back into a `Box` with the [`Box::from_raw`]\n+    ///   function.\n     ///\n     /// Note: this is an associated function, which means that you have\n     /// to call it as `Box::into_unique(b)` instead of `b.into_unique()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     ///\n+    /// [`Box::from_unique`]: struct.Box.html#method.from_unique\n     /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n     ///\n     /// # Examples"}, {"sha": "58299d5d8361eec7f8e1240e79de2c82708d3481", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -475,7 +475,6 @@\n //! them with the same character. For example, the `{` character is escaped with\n //! `{{` and the `}` character is escaped with `}}`.\n //!\n-//! [`format!`]: ../../macro.format.html\n //! [`usize`]: ../../std/primitive.usize.html\n //! [`isize`]: ../../std/primitive.isize.html\n //! [`i8`]: ../../std/primitive.i8.html"}, {"sha": "0cbfc9e9dacbb3f04d7f9f30f3c89e0d44d9bf4b", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -121,6 +121,7 @@\n #![feature(unique)]\n #![feature(unsize)]\n #![feature(allocator_internals)]\n+#![feature(on_unimplemented)]\n \n #![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice, i128))]\n #![cfg_attr(test, feature(test, box_heap))]"}, {"sha": "2f8620cc75051e4bb10cbdc3bec5ae343ba08ad4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -19,7 +19,7 @@\n //! given value is destroyed, the pointed-to value is also destroyed.\n //!\n //! Shared references in Rust disallow mutation by default, and [`Rc`]\n-//! is no exception: you cannot obtain a mutable reference to\n+//! is no exception: you cannot generally obtain a mutable reference to\n //! something inside an [`Rc`]. If you need mutability, put a [`Cell`]\n //! or [`RefCell`] inside the [`Rc`]; see [an example of mutability\n //! inside an Rc][mutability]."}, {"sha": "895607ff8d4f0cdd2f85d4f009f419da48ef4dbc", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -959,13 +959,15 @@ impl str {\n     /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n     /// ```\n     ///\n-    /// More complex patterns with closures:\n+    /// More complex patterns using point-free style and closures:\n     ///\n     /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.find(char::is_whitespace), Some(5));\n     /// assert_eq!(s.find(char::is_lowercase), Some(1));\n+    /// assert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));\n+    /// assert_eq!(s.find(|c: char| (c < 'o') && (c > 'a')), Some(4));\n     /// ```\n     ///\n     /// Not finding the pattern:"}, {"sha": "cf34e195dea76fe1d8262d412eab2823cb965e87", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -1543,6 +1543,7 @@ impl<T: Hash> Hash for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> Index<usize> for Vec<T> {\n     type Output = T;\n \n@@ -1554,6 +1555,7 @@ impl<T> Index<usize> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> IndexMut<usize> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: usize) -> &mut T {\n@@ -1562,8 +1564,8 @@ impl<T> IndexMut<usize> for Vec<T> {\n     }\n }\n \n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1572,7 +1574,9 @@ impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1581,7 +1585,9 @@ impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1590,7 +1596,9 @@ impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n     type Output = [T];\n \n@@ -1599,7 +1607,9 @@ impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n         self\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeInclusive<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1608,7 +1618,9 @@ impl<T> ops::Index<ops::RangeInclusive<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeToInclusive<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1619,41 +1631,52 @@ impl<T> ops::Index<ops::RangeToInclusive<usize>> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, _index: ops::RangeFull) -> &mut [T] {\n         self\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeInclusive<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut [T] {"}, {"sha": "6d7d83dd99388aa10145a78c4b7b663dd38af802", "filename": "src/liballoc_jemalloc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc_jemalloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc_jemalloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2FCargo.toml?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -19,7 +19,7 @@ libc = { path = \"../rustc/libc_shim\" }\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n-cc = \"1.0\"\n+cc = \"1.0.1\"\n \n [features]\n debug = []"}, {"sha": "65e035d4ffdef39bde2246c1fb80d36dd31806f3", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -63,24 +63,13 @@ fn main() {\n         _ => return,\n     };\n \n-    let compiler = cc::Build::new().get_compiler();\n-    // only msvc returns None for ar so unwrap is okay\n-    let ar = build_helper::cc2ar(compiler.path(), &target).unwrap();\n-    let cflags = compiler.args()\n-        .iter()\n-        .map(|s| s.to_str().unwrap())\n-        .collect::<Vec<_>>()\n-        .join(\" \");\n-\n     let mut cmd = Command::new(\"sh\");\n     cmd.arg(native.src_dir.join(\"configure\")\n                           .to_str()\n                           .unwrap()\n                           .replace(\"C:\\\\\", \"/c/\")\n                           .replace(\"\\\\\", \"/\"))\n        .current_dir(&native.out_dir)\n-       .env(\"CC\", compiler.path())\n-       .env(\"EXTRA_CFLAGS\", cflags.clone())\n        // jemalloc generates Makefile deps using GCC's \"-MM\" flag. This means\n        // that GCC will run the preprocessor, and only the preprocessor, over\n        // jemalloc's source files. If we don't specify CPPFLAGS, then at least\n@@ -89,9 +78,7 @@ fn main() {\n        // passed to GCC, and then GCC won't define the\n        // \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4\" macro that jemalloc needs to\n        // select an atomic operation implementation.\n-       .env(\"CPPFLAGS\", cflags.clone())\n-       .env(\"AR\", &ar)\n-       .env(\"RANLIB\", format!(\"{} s\", ar.display()));\n+       .env(\"CPPFLAGS\", env::var_os(\"CFLAGS\").unwrap_or_default());\n \n     if target.contains(\"ios\") {\n         cmd.arg(\"--disable-tls\");"}, {"sha": "7aa5f8a9186b0a229412e370e1faa93b08a61e80", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -14,7 +14,7 @@\n #![unstable(feature = \"alloc_system\",\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\",\n-            issue = \"27783\")]\n+            issue = \"32838\")]\n #![feature(global_allocator)]\n #![feature(allocator_api)]\n #![feature(alloc)]"}, {"sha": "800e36161d245b39f36c3e33e8c0bc1daaa91641", "filename": "src/libcollections/Cargo.toml", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04/src%2Flibcollections%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04/src%2Flibcollections%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2FCargo.toml?ref=69ba6738eb6bf9b6d11ebb81af2599648eb0bc04", "patch": "@@ -1,12 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"collections\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"collections\"\n-path = \"lib.rs\"\n-\n-[dependencies]\n-alloc = { path = \"../liballoc\" }\n-core = { path = \"../libcore\" }"}, {"sha": "55316db3d5a4358f6582328f9951fa489e227113", "filename": "src/libcollections/lib.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=69ba6738eb6bf9b6d11ebb81af2599648eb0bc04", "patch": "@@ -1,68 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(unused_attributes)]\n-#![unstable(feature = \"collections\",\n-            reason = \"this library is unlikely to be stabilized in its current \\\n-                      form or name\",\n-            issue = \"27783\")]\n-#![rustc_deprecated(since = \"1.20.0\",\n-                    reason = \"collections moved to `alloc`\")]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n-       test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n-#![no_std]\n-#![deny(warnings)]\n-\n-#![feature(alloc)]\n-#![feature(collections_range)]\n-#![feature(macro_reexport)]\n-#![feature(staged_api)]\n-\n-//! Collection types\n-//!\n-//! See [`std::collections`](../std/collections/index.html) for a detailed\n-//! discussion of collections in Rust.\n-\n-#[macro_reexport(vec, format)]\n-extern crate alloc;\n-\n-pub use alloc::Bound;\n-\n-pub use alloc::binary_heap;\n-pub use alloc::borrow;\n-pub use alloc::fmt;\n-pub use alloc::linked_list;\n-pub use alloc::range;\n-pub use alloc::slice;\n-pub use alloc::str;\n-pub use alloc::string;\n-pub use alloc::vec;\n-pub use alloc::vec_deque;\n-\n-pub use alloc::btree_map;\n-pub use alloc::btree_set;\n-\n-#[doc(no_inline)]\n-pub use alloc::binary_heap::BinaryHeap;\n-#[doc(no_inline)]\n-pub use alloc::btree_map::BTreeMap;\n-#[doc(no_inline)]\n-pub use alloc::btree_set::BTreeSet;\n-#[doc(no_inline)]\n-pub use alloc::linked_list::LinkedList;\n-#[doc(no_inline)]\n-pub use alloc::vec_deque::VecDeque;\n-#[doc(no_inline)]\n-pub use alloc::string::String;\n-#[doc(no_inline)]\n-pub use alloc::vec::Vec;"}, {"sha": "60b9eeb1283cdd3223cf9c568a93289541b8f731", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use fmt::{self, FlagV1};\n+use fmt;\n \n struct PadAdapter<'a, 'b: 'a> {\n     fmt: &'a mut fmt::Formatter<'b>,\n@@ -140,7 +140,7 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n     }\n \n     fn is_pretty(&self) -> bool {\n-        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+        self.fmt.alternate()\n     }\n }\n \n@@ -233,7 +233,7 @@ impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n     }\n \n     fn is_pretty(&self) -> bool {\n-        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+        self.fmt.alternate()\n     }\n }\n \n@@ -277,7 +277,7 @@ impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n     }\n \n     fn is_pretty(&self) -> bool {\n-        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+        self.fmt.alternate()\n     }\n }\n \n@@ -519,6 +519,6 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     }\n \n     fn is_pretty(&self) -> bool {\n-        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+        self.fmt.alternate()\n     }\n }"}, {"sha": "1e45af5b105c9ca2c50f448bcbee27c394ba1f5a", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -322,7 +322,6 @@ impl<'a> ArgumentV1<'a> {\n \n // flags available in the v1 format of format_args\n #[derive(Copy, Clone)]\n-#[allow(dead_code)] // SignMinus isn't currently used\n enum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, }\n \n impl<'a> Arguments<'a> {\n@@ -427,7 +426,7 @@ impl<'a> Display for Arguments<'a> {\n     }\n }\n \n-/// Format trait for the `?` character.\n+/// `?` formatting.\n ///\n /// `Debug` should format the output in a programmer-facing, debugging context.\n ///\n@@ -593,7 +592,7 @@ pub trait Display {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `o` character.\n+/// `o` formatting.\n ///\n /// The `Octal` trait should format its output as a number in base-8.\n ///\n@@ -640,7 +639,7 @@ pub trait Octal {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `b` character.\n+/// `b` formatting.\n ///\n /// The `Binary` trait should format its output as a number in binary.\n ///\n@@ -687,7 +686,7 @@ pub trait Binary {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `x` character.\n+/// `x` formatting.\n ///\n /// The `LowerHex` trait should format its output as a number in hexadecimal, with `a` through `f`\n /// in lower case.\n@@ -735,7 +734,7 @@ pub trait LowerHex {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `X` character.\n+/// `X` formatting.\n ///\n /// The `UpperHex` trait should format its output as a number in hexadecimal, with `A` through `F`\n /// in upper case.\n@@ -783,7 +782,7 @@ pub trait UpperHex {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `p` character.\n+/// `p` formatting.\n ///\n /// The `Pointer` trait should format its output as a memory location. This is commonly presented\n /// as hexadecimal.\n@@ -828,7 +827,7 @@ pub trait Pointer {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `e` character.\n+/// `e` formatting.\n ///\n /// The `LowerExp` trait should format its output in scientific notation with a lower-case `e`.\n ///\n@@ -871,7 +870,7 @@ pub trait LowerExp {\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `E` character.\n+/// `E` formatting.\n ///\n /// The `UpperExp` trait should format its output in scientific notation with an upper-case `E`.\n ///\n@@ -1276,7 +1275,7 @@ impl<'a> Formatter<'a> {\n         write(self.buf, fmt)\n     }\n \n-    /// Flags for formatting (packed version of rt::Flag)\n+    /// Flags for formatting\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn flags(&self) -> u32 { self.flags }\n "}, {"sha": "4e4d9b3f1e2f0585cfc9c3be3c366bb973268f27", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -22,7 +22,7 @@ use mem;\n /// This is currently the default hashing function used by standard library\n /// (eg. `collections::HashMap` uses it by default).\n ///\n-/// See: https://131002.net/siphash/\n+/// See: <https://131002.net/siphash>\n #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n #[rustc_deprecated(since = \"1.13.0\",\n                    reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n@@ -33,7 +33,7 @@ pub struct SipHasher13 {\n \n /// An implementation of SipHash 2-4.\n ///\n-/// See: https://131002.net/siphash/\n+/// See: <https://131002.net/siphash/>\n #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n #[rustc_deprecated(since = \"1.13.0\",\n                    reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n@@ -44,7 +44,7 @@ pub struct SipHasher24 {\n \n /// An implementation of SipHash 2-4.\n ///\n-/// See: https://131002.net/siphash/\n+/// See: <https://131002.net/siphash/>\n ///\n /// SipHash is a general-purpose hashing function: it runs at a good\n /// speed (competitive with Spooky and City) and permits strong _keyed_\n@@ -72,6 +72,7 @@ struct Hasher<S: Sip> {\n }\n \n #[derive(Debug, Clone, Copy)]\n+#[repr(C)]\n struct State {\n     // v0, v2 and v1, v3 show up in pairs in the algorithm,\n     // and simd implementations of SipHash will use vectors"}, {"sha": "79767b37601f8e91c55d8b1a3f34dd95cda7ced1", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 114, "deletions": 72, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -2059,14 +2059,23 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return Ordering::Equal,\n-                (None, _   ) => return Ordering::Less,\n-                (_   , None) => return Ordering::Greater,\n-                (Some(x), Some(y)) => match x.cmp(&y) {\n-                    Ordering::Equal => (),\n-                    non_eq => return non_eq,\n+            let x = match self.next() {\n+                None => if other.next().is_none() {\n+                    return Ordering::Equal\n+                } else {\n+                    return Ordering::Less\n                 },\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return Ordering::Greater,\n+                Some(val) => val,\n+            };\n+\n+            match x.cmp(&y) {\n+                Ordering::Equal => (),\n+                non_eq => return non_eq,\n             }\n         }\n     }\n@@ -2082,14 +2091,23 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return Some(Ordering::Equal),\n-                (None, _   ) => return Some(Ordering::Less),\n-                (_   , None) => return Some(Ordering::Greater),\n-                (Some(x), Some(y)) => match x.partial_cmp(&y) {\n-                    Some(Ordering::Equal) => (),\n-                    non_eq => return non_eq,\n+            let x = match self.next() {\n+                None => if other.next().is_none() {\n+                    return Some(Ordering::Equal)\n+                } else {\n+                    return Some(Ordering::Less)\n                 },\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return Some(Ordering::Greater),\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Equal) => (),\n+                non_eq => return non_eq,\n             }\n         }\n     }\n@@ -2105,11 +2123,17 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return true,\n-                (None, _) | (_, None) => return false,\n-                (Some(x), Some(y)) => if x != y { return false },\n-            }\n+            let x = match self.next() {\n+                None => return other.next().is_none(),\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return false,\n+                Some(val) => val,\n+            };\n+\n+            if x != y { return false }\n         }\n     }\n \n@@ -2124,11 +2148,17 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return false,\n-                (None, _) | (_, None) => return true,\n-                (Some(x), Some(y)) => if x.ne(&y) { return true },\n-            }\n+            let x = match self.next() {\n+                None => return other.next().is_some(),\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return true,\n+                Some(val) => val,\n+            };\n+\n+            if x != y { return true }\n         }\n     }\n \n@@ -2143,18 +2173,21 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return false,\n-                (None, _   ) => return true,\n-                (_   , None) => return false,\n-                (Some(x), Some(y)) => {\n-                    match x.partial_cmp(&y) {\n-                        Some(Ordering::Less) => return true,\n-                        Some(Ordering::Equal) => {}\n-                        Some(Ordering::Greater) => return false,\n-                        None => return false,\n-                    }\n-                },\n+            let x = match self.next() {\n+                None => return other.next().is_some(),\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return false,\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Less) => return true,\n+                Some(Ordering::Equal) => (),\n+                Some(Ordering::Greater) => return false,\n+                None => return false,\n             }\n         }\n     }\n@@ -2170,18 +2203,21 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return true,\n-                (None, _   ) => return true,\n-                (_   , None) => return false,\n-                (Some(x), Some(y)) => {\n-                    match x.partial_cmp(&y) {\n-                        Some(Ordering::Less) => return true,\n-                        Some(Ordering::Equal) => {}\n-                        Some(Ordering::Greater) => return false,\n-                        None => return false,\n-                    }\n-                },\n+            let x = match self.next() {\n+                None => { other.next(); return true; },\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return false,\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Less) => return true,\n+                Some(Ordering::Equal) => (),\n+                Some(Ordering::Greater) => return false,\n+                None => return false,\n             }\n         }\n     }\n@@ -2197,18 +2233,21 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return false,\n-                (None, _   ) => return false,\n-                (_   , None) => return true,\n-                (Some(x), Some(y)) => {\n-                    match x.partial_cmp(&y) {\n-                        Some(Ordering::Less) => return false,\n-                        Some(Ordering::Equal) => {}\n-                        Some(Ordering::Greater) => return true,\n-                        None => return false,\n-                    }\n-                }\n+            let x = match self.next() {\n+                None => { other.next(); return false; },\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return true,\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Less) => return false,\n+                Some(Ordering::Equal) => (),\n+                Some(Ordering::Greater) => return true,\n+                None => return false,\n             }\n         }\n     }\n@@ -2224,18 +2263,21 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return true,\n-                (None, _   ) => return false,\n-                (_   , None) => return true,\n-                (Some(x), Some(y)) => {\n-                    match x.partial_cmp(&y) {\n-                        Some(Ordering::Less) => return false,\n-                        Some(Ordering::Equal) => {}\n-                        Some(Ordering::Greater) => return true,\n-                        None => return false,\n-                    }\n-                },\n+            let x = match self.next() {\n+                None => return other.next().is_none(),\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return true,\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Less) => return false,\n+                Some(Ordering::Equal) => (),\n+                Some(Ordering::Greater) => return true,\n+                None => return false,\n             }\n         }\n     }"}, {"sha": "12667036444e63ce4d8091f04085737c5312f3c9", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -682,15 +682,15 @@ mod builtin {\n     #[cfg(dox)]\n     macro_rules! file { () => ({ /* compiler built-in */ }) }\n \n-    /// A macro which stringifies its argument.\n+    /// A macro which stringifies its arguments.\n     ///\n     /// For more information, see the documentation for [`std::stringify!`].\n     ///\n     /// [`std::stringify!`]: ../std/macro.stringify.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! stringify { ($t:tt) => ({ /* compiler built-in */ }) }\n+    macro_rules! stringify { ($($t:tt)*) => ({ /* compiler built-in */ }) }\n \n     /// Includes a utf8-encoded file as a string.\n     ///"}, {"sha": "16d5fadc53620f60e243d017331c440d6086147a", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -429,9 +429,11 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n \n /// Returns whether dropping values of type `T` matters.\n ///\n-/// This is purely an optimization hint, and may be implemented conservatively.\n-/// For instance, always returning `true` would be a valid implementation of\n-/// this function.\n+/// This is purely an optimization hint, and may be implemented conservatively:\n+/// it may return `true` for types that don't actually need to be dropped.\n+/// As such always returning `true` would be a valid implementation of\n+/// this function. However if this function actually returns `false`, then you\n+/// can be certain dropping `T` has no side effect.\n ///\n /// Low level implementations of things like collections, which need to manually\n /// drop their data, should use this function to avoid unnecessarily\n@@ -836,7 +838,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n ///\n /// See the `discriminant` function in this module for more information.\n #[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-pub struct Discriminant<T>(u64, PhantomData<*const T>);\n+pub struct Discriminant<T>(u64, PhantomData<fn() -> T>);\n \n // N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n "}, {"sha": "01990f61feeb3cbda9babdccf1e2f651e31f3d41", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -551,7 +551,7 @@ impl<T: ?Sized> *const T {\n     ///\n     /// Most platforms fundamentally can't even construct such an allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2^63 bytes due to page-table limitations or splitting the address space.\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n     /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n     /// more than `isize::MAX` bytes with things like Physical Address\n     /// Extension. As such, memory acquired directly from allocators or memory\n@@ -684,7 +684,7 @@ impl<T: ?Sized> *const T {\n     ///\n     /// Most platforms fundamentally can't even construct such an allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2^63 bytes due to page-table limitations or splitting the address space.\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n     /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n     /// more than `isize::MAX` bytes with things like Physical Address\n     /// Extension. As such, memory acquired directly from allocators or memory\n@@ -743,7 +743,7 @@ impl<T: ?Sized> *const T {\n     ///\n     /// Most platforms fundamentally can't even construct such an allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2^63 bytes due to page-table limitations or splitting the address space.\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n     /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n     /// more than `isize::MAX` bytes with things like Physical Address\n     /// Extension. As such, memory acquired directly from allocators or memory\n@@ -1182,7 +1182,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// Most platforms fundamentally can't even construct such an allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2^63 bytes due to page-table limitations or splitting the address space.\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n     /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n     /// more than `isize::MAX` bytes with things like Physical Address\n     /// Extension. As such, memory acquired directly from allocators or memory\n@@ -1382,7 +1382,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// Most platforms fundamentally can't even construct such an allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2^63 bytes due to page-table limitations or splitting the address space.\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n     /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n     /// more than `isize::MAX` bytes with things like Physical Address\n     /// Extension. As such, memory acquired directly from allocators or memory\n@@ -1441,7 +1441,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// Most platforms fundamentally can't even construct such an allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2^63 bytes due to page-table limitations or splitting the address space.\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n     /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n     /// more than `isize::MAX` bytes with things like Physical Address\n     /// Extension. As such, memory acquired directly from allocators or memory"}, {"sha": "db5bffced10cce609149f61088e049930e1dd615", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -1060,7 +1060,7 @@ unsafe impl<'a, A> TrustedLen for IterMut<'a, A> {}\n /// [`Result`]: enum.Result.html\n /// [`into_iter`]: ../iter/trait.IntoIterator.html#tymethod.into_iter\n /// [`IntoIterator`]: ../iter/trait.IntoIterator.html\n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> { inner: Option<T> }\n "}, {"sha": "670c2afa66f8597ae24e597cc6dff2faceefaf6e", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -1405,16 +1405,6 @@ impl<'a> DoubleEndedIterator for LinesAny<'a> {\n #[allow(deprecated)]\n impl<'a> FusedIterator for LinesAny<'a> {}\n \n-/*\n-Section: Comparing strings\n-*/\n-\n-/// Bytewise slice equality\n-#[inline]\n-fn eq_slice(a: &str, b: &str) -> bool {\n-    a.as_bytes() == b.as_bytes()\n-}\n-\n /*\n Section: UTF-8 validation\n */\n@@ -1590,7 +1580,6 @@ mod traits {\n     use cmp::Ordering;\n     use ops;\n     use slice::{self, SliceIndex};\n-    use str::eq_slice;\n \n     /// Implements ordering of strings.\n     ///\n@@ -1611,7 +1600,7 @@ mod traits {\n     impl PartialEq for str {\n         #[inline]\n         fn eq(&self, other: &str) -> bool {\n-            eq_slice(self, other)\n+            self.as_bytes() == other.as_bytes()\n         }\n         #[inline]\n         fn ne(&self, other: &str) -> bool { !(*self).eq(other) }"}, {"sha": "524f4508c9b1a8e4c8a532f16912c951d64dc81b", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -119,7 +119,9 @@ pub fn hint_core_should_pause()\n \n /// A boolean type which can be safely shared between threads.\n ///\n-/// This type has the same in-memory representation as a `bool`.\n+/// This type has the same in-memory representation as a [`bool`].\n+///\n+/// [`bool`]: ../../../std/primitive.bool.html\n #[cfg(target_has_atomic = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicBool {\n@@ -246,11 +248,13 @@ impl AtomicBool {\n         AtomicBool { v: UnsafeCell::new(v as u8) }\n     }\n \n-    /// Returns a mutable reference to the underlying `bool`.\n+    /// Returns a mutable reference to the underlying [`bool`].\n     ///\n     /// This is safe because the mutable reference guarantees that no other threads are\n     /// concurrently accessing the atomic data.\n     ///\n+    /// [`bool`]: ../../../std/primitive.bool.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -369,7 +373,7 @@ impl AtomicBool {\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n     }\n \n-    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n+    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n     ///\n     /// The return value is always the previous value. If it is equal to `current`, then the value\n     /// was updated.\n@@ -378,6 +382,7 @@ impl AtomicBool {\n     /// ordering of this operation.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`bool`]: ../../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -401,7 +406,7 @@ impl AtomicBool {\n         }\n     }\n \n-    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n+    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n     ///\n     /// The return value is a result indicating whether the new value was written and containing\n     /// the previous value. On success this value is guaranteed to be equal to `current`.\n@@ -412,6 +417,7 @@ impl AtomicBool {\n     /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and must\n     /// be equivalent or weaker than the success ordering.\n     ///\n+    /// [`bool`]: ../../../std/primitive.bool.html\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Release`]: enum.Ordering.html#variant.Release\n     /// [`AcqRel`]: enum.Ordering.html#variant.Release\n@@ -452,7 +458,7 @@ impl AtomicBool {\n         }\n     }\n \n-    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n+    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n     ///\n     /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n@@ -465,6 +471,7 @@ impl AtomicBool {\n     /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n     /// weaker than the success ordering.\n     ///\n+    /// [`bool`]: ../../../std/primitive.bool.html\n     /// [`compare_exchange`]: #method.compare_exchange\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Release`]: enum.Ordering.html#variant.Release"}, {"sha": "c6dd41798f2a7ad388ee9b9b3c312a9019a68f9a", "filename": "src/libcore/tests/hash/sip.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -243,24 +243,22 @@ fn test_siphash_2_4() {\n         t += 1;\n     }\n }\n-#[test] #[cfg(target_arch = \"arm\")]\n+\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n fn test_hash_usize() {\n     let val = 0xdeadbeef_deadbeef_u64;\n     assert!(hash(&(val as u64)) != hash(&(val as usize)));\n     assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n }\n-#[test] #[cfg(target_arch = \"x86_64\")]\n+\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n fn test_hash_usize() {\n     let val = 0xdeadbeef_deadbeef_u64;\n     assert_eq!(hash(&(val as u64)), hash(&(val as usize)));\n     assert!(hash(&(val as u32)) != hash(&(val as usize)));\n }\n-#[test] #[cfg(target_arch = \"x86\")]\n-fn test_hash_usize() {\n-    let val = 0xdeadbeef_deadbeef_u64;\n-    assert!(hash(&(val as u64)) != hash(&(val as usize)));\n-    assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n-}\n \n #[test]\n fn test_hash_idempotent() {"}, {"sha": "f55a1c81463f77ab0a8a6dd7c1946ae3c0c33a4a", "filename": "src/libcore/tests/mem.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fmem.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -121,3 +121,19 @@ fn test_transmute() {\n     }\n }\n \n+#[test]\n+#[allow(dead_code)]\n+fn test_discriminant_send_sync() {\n+    enum Regular {\n+        A,\n+        B(i32)\n+    }\n+    enum NotSendSync {\n+        A(*const i32)\n+    }\n+\n+    fn is_send_sync<T: Send + Sync>() { }\n+\n+    is_send_sync::<Discriminant<Regular>>();\n+    is_send_sync::<Discriminant<NotSendSync>>();\n+}"}, {"sha": "857aae72c8a5bd5d92a0088a36bbe3c37fc58b37", "filename": "src/libcore/tests/num/flt2dec/estimator.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -8,11 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME https://github.com/kripken/emscripten/issues/4563\n-// NB we have to actually not compile this test to avoid\n-// an undefined symbol error\n-#![cfg(not(target_os = \"emscripten\"))]\n-\n use core::num::flt2dec::estimator::*;\n \n #[test]"}, {"sha": "7e33065ce49759958c0d1c04fcadef961032a943", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -1 +1 @@\n-Subproject commit 44e4018e1a37716286ec98cb5b7dd7d33ecaf940\n+Subproject commit 7e33065ce49759958c0d1c04fcadef961032a943"}, {"sha": "cf30966fa89715c2ff695069b5ca9f00321df21f", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -488,7 +488,7 @@ impl Literal {\n     pub fn string(string: &str) -> Literal {\n         let mut escaped = String::new();\n         for ch in string.chars() {\n-            escaped.extend(ch.escape_unicode());\n+            escaped.extend(ch.escape_debug());\n         }\n         Literal(token::Literal(token::Lit::Str_(Symbol::intern(&escaped)), None))\n     }"}, {"sha": "04f456917b95703b5eebe33a62e81baa864a36d7", "filename": "src/libprofiler_builtins/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibprofiler_builtins%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibprofiler_builtins%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2FCargo.toml?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -15,4 +15,4 @@ doc = false\n core = { path = \"../libcore\" }\n \n [build-dependencies]\n-cc = \"1.0\"\n+cc = \"1.0.1\""}, {"sha": "ddf71a06d607c7f7016546b0cc6fdb7da8ee3bef", "filename": "src/librustc/README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -98,7 +98,7 @@ entire program, and each did a particular check of transformation.\n We are gradually replacing this pass-based code with an alternative\n setup based on on-demand **queries**. In the query-model, we work\n backwards, executing a *query* that expresses our ultimate goal (e.g.,\n-\"compiler this crate\"). This query in turn may make other queries\n+\"compile this crate\"). This query in turn may make other queries\n (e.g., \"get me a list of all modules in the crate\"). Those queries\n make other queries that ultimately bottom out in the base operations,\n like parsing the input, running the type-checker, and so forth. This\n@@ -162,7 +162,7 @@ The compiler uses a number of...idiosyncratic abbreviations and\n things. This glossary attempts to list them and give you a few\n pointers for understanding them better.\n \n-- AST -- the **abstract syntax tree** produced the `syntax` crate; reflects user syntax\n+- AST -- the **abstract syntax tree** produced by the `syntax` crate; reflects user syntax\n   very closely. \n - codegen unit -- when we produce LLVM IR, we group the Rust code into a number of codegen\n   units. Each of these units is processed by LLVM independently from one another,"}, {"sha": "56b218889854d0a49121b063c42018359575c297", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -65,7 +65,7 @@ use hir::map::DefPathHash;\n use hir::{HirId, ItemLocalId};\n \n use ich::Fingerprint;\n-use ty::{TyCtxt, Instance, InstanceDef, ParamEnvAnd, Ty};\n+use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n use ty::subst::Substs;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use ich::StableHashingContext;\n@@ -339,6 +339,25 @@ macro_rules! define_dep_nodes {\n                     Ok(DepNode::new_no_params(kind))\n                 }\n             }\n+\n+            /// Used in testing\n+            pub fn has_label_string(label: &str) -> bool {\n+                match label {\n+                    $(\n+                        stringify!($variant) => true,\n+                    )*\n+                    _ => false,\n+                }\n+            }\n+        }\n+\n+        /// Contains variant => str representations for constructing\n+        /// DepNode groups for tests.\n+        #[allow(dead_code, non_upper_case_globals)]\n+        pub mod label_strs {\n+           $(\n+                pub const $variant: &'static str = stringify!($variant);\n+            )*\n         }\n     );\n }\n@@ -356,7 +375,7 @@ impl fmt::Debug for DepNode {\n         ::ty::tls::with_opt(|opt_tcx| {\n             if let Some(tcx) = opt_tcx {\n                 if let Some(def_id) = self.extract_def_id(tcx) {\n-                    write!(f, \"{}\", tcx.def_path(def_id).to_string(tcx))?;\n+                    write!(f, \"{}\", tcx.def_path_debug_str(def_id))?;\n                 } else if let Some(ref s) = tcx.dep_graph.dep_node_debug_str(*self) {\n                     write!(f, \"{}\", s)?;\n                 } else {\n@@ -457,6 +476,7 @@ define_dep_nodes!( <'tcx>\n     [] TypeOfItem(DefId),\n     [] GenericsOfItem(DefId),\n     [] PredicatesOfItem(DefId),\n+    [] InferredOutlivesOf(DefId),\n     [] SuperPredicatesOfItem(DefId),\n     [] TraitDefOfItem(DefId),\n     [] AdtDefOfItem(DefId),\n@@ -480,12 +500,15 @@ define_dep_nodes!( <'tcx>\n     [] InherentImpls(DefId),\n     [] TypeckBodiesKrate,\n     [] TypeckTables(DefId),\n+    [] UsedTraitImports(DefId),\n     [] HasTypeckTables(DefId),\n     [] ConstEval { param_env: ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)> },\n     [] SymbolName(DefId),\n     [] InstanceSymbolName { instance: Instance<'tcx> },\n     [] SpecializationGraph(DefId),\n     [] ObjectSafety(DefId),\n+    [] FulfillObligation { param_env: ParamEnv<'tcx>, trait_ref: PolyTraitRef<'tcx> },\n+    [] VtableMethods { trait_ref: PolyTraitRef<'tcx> },\n \n     [] IsCopy { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },\n     [] IsSized { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },\n@@ -532,6 +555,7 @@ define_dep_nodes!( <'tcx>\n     [] LookupDeprecationEntry(DefId),\n     [] ItemBodyNestedBodies(DefId),\n     [] ConstIsRvaluePromotableToStatic(DefId),\n+    [] RvaluePromotableMap(DefId),\n     [] ImplParent(DefId),\n     [] TraitOfItem(DefId),\n     [] IsExportedSymbol(DefId),\n@@ -588,6 +612,14 @@ define_dep_nodes!( <'tcx>\n     [] HasCloneClosures(CrateNum),\n     [] HasCopyClosures(CrateNum),\n \n+    // This query is not expected to have inputs -- as a result, it's\n+    // not a good candidate for \"replay\" because it's essentially a\n+    // pure function of its input (and hence the expectation is that\n+    // no caller would be green **apart** from just this\n+    // query). Making it anonymous avoids hashing the result, which\n+    // may save a bit of time.\n+    [anon] EraseRegionsTy { ty: Ty<'tcx> },\n+\n     [] Freevars(DefId),\n     [] MaybeUnusedTraitImport(DefId),\n     [] MaybeUnusedExternCrates,\n@@ -601,7 +633,7 @@ define_dep_nodes!( <'tcx>\n     [] CodegenUnit(InternedString),\n     [] CompileCodegenUnit(InternedString),\n     [] OutputFilenames,\n-\n+    [anon] NormalizeTy,\n     // We use this for most things when incr. comp. is turned off.\n     [] Null,\n );\n@@ -700,8 +732,8 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, De\n         let (def_id_0, def_id_1) = *self;\n \n         format!(\"({}, {})\",\n-                tcx.def_path(def_id_0).to_string(tcx),\n-                tcx.def_path(def_id_1).to_string(tcx))\n+                tcx.def_path_debug_str(def_id_0),\n+                tcx.def_path_debug_str(def_id_1))\n     }\n }\n "}, {"sha": "0fdb6dc068dd985f9fb143b5f1a228a391bb9e74", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -12,7 +12,6 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHashingContextProvider};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::env;\n use std::hash::Hash;\n@@ -577,7 +576,7 @@ impl DepGraph {\n                       \"DepGraph::try_mark_green() - Duplicate DepNodeColor \\\n                       insertion for {:?}\", dep_node);\n \n-        debug!(\"try_mark_green({:?}) - END - successfully marked as green\", dep_node.kind);\n+        debug!(\"try_mark_green({:?}) - END - successfully marked as green\", dep_node);\n         Some(dep_node_index)\n     }\n \n@@ -647,7 +646,14 @@ impl DepGraph {\n pub struct WorkProduct {\n     pub cgu_name: String,\n     /// Saved files associated with this CGU\n-    pub saved_files: Vec<(OutputType, String)>,\n+    pub saved_files: Vec<(WorkProductFileKind, String)>,\n+}\n+\n+#[derive(Clone, Copy, Debug, RustcEncodable, RustcDecodable)]\n+pub enum WorkProductFileKind {\n+    Object,\n+    Bytecode,\n+    BytecodeCompressed,\n }\n \n pub(super) struct CurrentDepGraph {"}, {"sha": "fe0212423f6efcd0d5ce95ac390cd96bb0cd309c", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -19,8 +19,9 @@ mod safe;\n mod serialized;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n-pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId};\n+pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId, label_strs};\n pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor};\n+pub use self::graph::WorkProductFileKind;\n pub use self::prev::PreviousDepGraph;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;"}, {"sha": "e283fc40c50a345fc9ed5658753bc45eb9d6836a", "filename": "src/librustc/hir/README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2FREADME.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -57,7 +57,7 @@ carry around references into the HIR, but rather to carry around\n *identifier numbers* (or just \"ids\"). Right now, you will find four\n sorts of identifiers in active use:\n \n-- `DefId`, which primarily name \"definitions\" or top-level items.\n+- `DefId`, which primarily names \"definitions\" or top-level items.\n   - You can think of a `DefId` as being shorthand for a very explicit\n     and complete path, like `std::collections::HashMap`. However,\n     these paths are able to name things that are not nameable in\n@@ -114,6 +114,6 @@ A **body** represents some kind of executable code, such as the body\n of a function/closure or the definition of a constant. Bodies are\n associated with an **owner**, which is typically some kind of item\n (e.g., a `fn()` or `const`), but could also be a closure expression\n-(e.g., `|x, y| x + y`). You can use the HIR map to find find the body\n+(e.g., `|x, y| x + y`). You can use the HIR map to find the body\n associated with a given def-id (`maybe_body_owned_by()`) or to find\n the owner of a body (`body_owner_def_id()`)."}, {"sha": "69d23504cdae00a818d855cc5ef5346c53c78ea7", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -197,12 +197,12 @@ pub struct DefId {\n \n impl fmt::Debug for DefId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"DefId {{ krate: {:?}, node: {:?}\",\n+        write!(f, \"DefId {{ krate: {:?}, index: {:?}\",\n                self.krate, self.index)?;\n \n         ty::tls::with_opt(|opt_tcx| {\n             if let Some(tcx) = opt_tcx {\n-                write!(f, \" => {}\", tcx.def_path(*self).to_string(tcx))?;\n+                write!(f, \" => {}\", tcx.def_path_debug_str(*self))?;\n             }\n             Ok(())\n         })?;"}, {"sha": "d99d7cd897b9fe2ea3aa3b9c46f9184880c3bc0c", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -780,9 +780,7 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n         FnKind::ItemFn(_, generics, ..) => {\n             visitor.visit_generics(generics);\n         }\n-        FnKind::Method(_, sig, ..) => {\n-            visitor.visit_generics(&sig.generics);\n-        }\n+        FnKind::Method(..) |\n         FnKind::Closure(_) => {}\n     }\n }\n@@ -802,6 +800,7 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n     visitor.visit_name(trait_item.span, trait_item.name);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n+    visitor.visit_generics(&trait_item.generics);\n     match trait_item.node {\n         TraitItemKind::Const(ref ty, default) => {\n             visitor.visit_id(trait_item.id);\n@@ -810,7 +809,6 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n         }\n         TraitItemKind::Method(ref sig, TraitMethod::Required(ref names)) => {\n             visitor.visit_id(trait_item.id);\n-            visitor.visit_generics(&sig.generics);\n             visitor.visit_fn_decl(&sig.decl);\n             for name in names {\n                 visitor.visit_name(name.span, name.node);\n@@ -852,6 +850,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n         ref vis,\n         ref defaultness,\n         ref attrs,\n+        ref generics,\n         ref node,\n         span\n     } = *impl_item;\n@@ -860,6 +859,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     visitor.visit_vis(vis);\n     visitor.visit_defaultness(defaultness);\n     walk_list!(visitor, visit_attribute, attrs);\n+    visitor.visit_generics(generics);\n     match *node {\n         ImplItemKind::Const(ref ty, body) => {\n             visitor.visit_id(impl_item.id);"}, {"sha": "2221ecf07b434913b079643d283b48afeeed7d5f", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -41,7 +41,7 @@ use super::intravisit::Visitor;\n ///    - Example: Lifetime resolution, which wants to bring lifetimes declared on the\n ///      impl into scope while visiting the impl-items, and then back out again.\n ///    - How: Implement `intravisit::Visitor` and override the\n-///      `visit_nested_map()` methods to return\n+///      `nested_visit_map()` methods to return\n ///      `NestedVisitorMap::All`. Walk your crate with\n ///      `intravisit::walk_crate()` invoked on `tcx.hir.krate()`.\n ///    - Pro: Visitor methods for any kind of HIR node, not just item-like things."}, {"sha": "184e66465587093e5ac94a941d49c006ec1654bd", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -673,6 +673,7 @@ impl<'a> LoweringContext<'a> {\n                     unsafety: self.lower_unsafety(f.unsafety),\n                     abi: f.abi,\n                     decl: self.lower_fn_decl(&f.decl),\n+                    arg_names: self.lower_fn_args_to_names(&f.decl),\n                 }))\n             }\n             TyKind::Never => hir::TyNever,\n@@ -704,7 +705,7 @@ impl<'a> LoweringContext<'a> {\n                 let expr = self.lower_body(None, |this| this.lower_expr(expr));\n                 hir::TyTypeof(expr)\n             }\n-            TyKind::TraitObject(ref bounds) => {\n+            TyKind::TraitObject(ref bounds, ..) => {\n                 let mut lifetime_bound = None;\n                 let bounds = bounds.iter().filter_map(|bound| {\n                     match *bound {\n@@ -1538,6 +1539,7 @@ impl<'a> LoweringContext<'a> {\n                 hir_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n+                generics: this.lower_generics(&i.generics),\n                 node: match i.node {\n                     TraitItemKind::Const(ref ty, ref default) => {\n                         hir::TraitItemKind::Const(this.lower_ty(ty),\n@@ -1602,6 +1604,7 @@ impl<'a> LoweringContext<'a> {\n                 hir_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n+                generics: this.lower_generics(&i.generics),\n                 vis: this.lower_visibility(&i.vis, None),\n                 defaultness: this.lower_defaultness(i.defaultness, true /* [1] */),\n                 node: match i.node {\n@@ -1728,7 +1731,6 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_method_sig(&mut self, sig: &MethodSig) -> hir::MethodSig {\n         hir::MethodSig {\n-            generics: self.lower_generics(&sig.generics),\n             abi: sig.abi,\n             unsafety: self.lower_unsafety(sig.unsafety),\n             constness: self.lower_constness(sig.constness),\n@@ -2546,7 +2548,7 @@ impl<'a> LoweringContext<'a> {\n                 };\n \n                 // Err(err) => #[allow(unreachable_code)]\n-                //             return Carrier::from_error(From::from(err)),\n+                //             return Try::from_error(From::from(err)),\n                 let err_arm = {\n                     let err_ident = self.str_to_ident(\"err\");\n                     let err_local = self.pat_ident(e.span, err_ident);\n@@ -2665,7 +2667,7 @@ impl<'a> LoweringContext<'a> {\n                         -> hir::Visibility {\n         match *v {\n             Visibility::Public => hir::Public,\n-            Visibility::Crate(_) => hir::Visibility::Crate,\n+            Visibility::Crate(..) => hir::Visibility::Crate,\n             Visibility::Restricted { ref path, id } => {\n                 hir::Visibility::Restricted {\n                     path: P(self.lower_path(id, path, ParamMode::Explicit, true)),"}, {"sha": "8bc7cf2faba0492e76fbd1f6286cd97941c70349", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -27,7 +27,6 @@ use std::hash::Hash;\n use syntax::ast;\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::{Symbol, InternedString};\n-use ty::TyCtxt;\n use util::nodemap::NodeMap;\n \n /// The DefPathTable maps DefIndexes to DefKeys and vice versa.\n@@ -296,26 +295,6 @@ impl DefPath {\n         DefPath { data: data, krate: krate }\n     }\n \n-    pub fn to_string(&self, tcx: TyCtxt) -> String {\n-        let mut s = String::with_capacity(self.data.len() * 16);\n-\n-        s.push_str(&tcx.original_crate_name(self.krate).as_str());\n-        s.push_str(\"/\");\n-        // Don't print the whole crate disambiguator. That's just annoying in\n-        // debug output.\n-        s.push_str(&tcx.crate_disambiguator(self.krate).as_str()[..7]);\n-\n-        for component in &self.data {\n-            write!(s,\n-                   \"::{}[{}]\",\n-                   component.data.as_interned_str(),\n-                   component.disambiguator)\n-                .unwrap();\n-        }\n-\n-        s\n-    }\n-\n     /// Returns a string representation of the DefPath without\n     /// the crate-prefix. This method is useful if you don't have\n     /// a TyCtxt available."}, {"sha": "fb3fc8a2da4f3ed00ac5aea67fa24e33dfabc588", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -1295,7 +1295,6 @@ pub struct MethodSig {\n     pub constness: Constness,\n     pub abi: Abi,\n     pub decl: P<FnDecl>,\n-    pub generics: Generics,\n }\n \n // The bodies for items are stored \"out of line\", in a separate\n@@ -1316,6 +1315,7 @@ pub struct TraitItem {\n     pub name: Name,\n     pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n+    pub generics: Generics,\n     pub node: TraitItemKind,\n     pub span: Span,\n }\n@@ -1360,6 +1360,7 @@ pub struct ImplItem {\n     pub vis: Visibility,\n     pub defaultness: Defaultness,\n     pub attrs: HirVec<Attribute>,\n+    pub generics: Generics,\n     pub node: ImplItemKind,\n     pub span: Span,\n }\n@@ -1418,6 +1419,7 @@ pub struct BareFnTy {\n     pub abi: Abi,\n     pub lifetimes: HirVec<LifetimeDef>,\n     pub decl: P<FnDecl>,\n+    pub arg_names: HirVec<Spanned<Name>>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "b461487355007e68f11c4e19f884c6f222f37683", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -399,7 +399,8 @@ impl<'a> State<'a> {\n                     },\n                     span: syntax_pos::DUMMY_SP,\n                 };\n-                self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &generics)?;\n+                self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &generics,\n+                                 &f.arg_names[..])?;\n             }\n             hir::TyPath(ref qpath) => {\n                 self.print_qpath(qpath, false)?\n@@ -879,6 +880,7 @@ impl<'a> State<'a> {\n     pub fn print_method_sig(&mut self,\n                             name: ast::Name,\n                             m: &hir::MethodSig,\n+                            generics: &hir::Generics,\n                             vis: &hir::Visibility,\n                             arg_names: &[Spanned<ast::Name>],\n                             body_id: Option<hir::BodyId>)\n@@ -888,7 +890,7 @@ impl<'a> State<'a> {\n                       m.constness,\n                       m.abi,\n                       Some(name),\n-                      &m.generics,\n+                      generics,\n                       vis,\n                       arg_names,\n                       body_id)\n@@ -904,12 +906,14 @@ impl<'a> State<'a> {\n                 self.print_associated_const(ti.name, &ty, default, &hir::Inherited)?;\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(ref arg_names)) => {\n-                self.print_method_sig(ti.name, sig, &hir::Inherited, arg_names, None)?;\n+                self.print_method_sig(ti.name, sig, &ti.generics, &hir::Inherited, arg_names,\n+                    None)?;\n                 self.s.word(\";\")?;\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n                 self.head(\"\")?;\n-                self.print_method_sig(ti.name, sig, &hir::Inherited, &[], Some(body))?;\n+                self.print_method_sig(ti.name, sig, &ti.generics, &hir::Inherited, &[],\n+                    Some(body))?;\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n@@ -937,7 +941,7 @@ impl<'a> State<'a> {\n             }\n             hir::ImplItemKind::Method(ref sig, body) => {\n                 self.head(\"\")?;\n-                self.print_method_sig(ii.name, sig, &ii.vis, &[], Some(body))?;\n+                self.print_method_sig(ii.name, sig, &ii.generics, &ii.vis, &[], Some(body))?;\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n@@ -2140,7 +2144,8 @@ impl<'a> State<'a> {\n                        unsafety: hir::Unsafety,\n                        decl: &hir::FnDecl,\n                        name: Option<ast::Name>,\n-                       generics: &hir::Generics)\n+                       generics: &hir::Generics,\n+                       arg_names: &[Spanned<ast::Name>])\n                        -> io::Result<()> {\n         self.ibox(indent_unit)?;\n         if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n@@ -2163,7 +2168,7 @@ impl<'a> State<'a> {\n                       name,\n                       &generics,\n                       &hir::Inherited,\n-                      &[],\n+                      arg_names,\n                       None)?;\n         self.end()\n     }"}, {"sha": "f3bb3b385667ed041d768cf584e49eb0007dc620", "filename": "src/librustc/ich/fingerprint.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Ffingerprint.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n use rustc_data_structures::stable_hasher;\n-use std::mem;\n-use std::slice;\n \n #[derive(Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Clone, Copy, RustcEncodable, RustcDecodable)]\n pub struct Fingerprint(u64, u64);\n@@ -54,16 +52,9 @@ impl ::std::fmt::Display for Fingerprint {\n }\n \n impl stable_hasher::StableHasherResult for Fingerprint {\n-    fn finish(mut hasher: stable_hasher::StableHasher<Self>) -> Self {\n-        let hash_bytes: &[u8] = hasher.finalize();\n-\n-        assert!(hash_bytes.len() >= mem::size_of::<u64>() * 2);\n-        let hash_bytes: &[u64] = unsafe {\n-            slice::from_raw_parts(hash_bytes.as_ptr() as *const u64, 2)\n-        };\n-\n-        // The bytes returned bytes the Blake2B hasher are always little-endian.\n-        Fingerprint(u64::from_le(hash_bytes[0]), u64::from_le(hash_bytes[1]))\n+    fn finish(hasher: stable_hasher::StableHasher<Self>) -> Self {\n+        let (_0, _1) = hasher.finalize();\n+        Fingerprint(_0, _1)\n     }\n }\n "}, {"sha": "994f0bd16b1f85094756bdebacdd07cd6cc94ecc", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -232,8 +232,7 @@ impl_stable_hash_for!(struct hir::MethodSig {\n     unsafety,\n     constness,\n     abi,\n-    decl,\n-    generics\n+    decl\n });\n \n impl_stable_hash_for!(struct hir::TypeBinding {\n@@ -274,7 +273,8 @@ impl_stable_hash_for!(struct hir::BareFnTy {\n     unsafety,\n     abi,\n     lifetimes,\n-    decl\n+    decl,\n+    arg_names\n });\n \n impl_stable_hash_for!(enum hir::Ty_ {\n@@ -708,13 +708,15 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItem {\n             hir_id: _,\n             name,\n             ref attrs,\n+            ref generics,\n             ref node,\n             span\n         } = *self;\n \n         hcx.hash_hir_item_like(attrs, |hcx| {\n             name.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n+            generics.hash_stable(hcx, hasher);\n             node.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n         });\n@@ -743,6 +745,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItem {\n             ref vis,\n             defaultness,\n             ref attrs,\n+            ref generics,\n             ref node,\n             span\n         } = *self;\n@@ -752,6 +755,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItem {\n             vis.hash_stable(hcx, hasher);\n             defaultness.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n+            generics.hash_stable(hcx, hasher);\n             node.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n         });"}, {"sha": "50f7e4ba176e5ddf6d3236bb5576485d21962b29", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 130, "deletions": 1, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -61,6 +61,9 @@ for ty::RegionKind {\n                 def_id.hash_stable(hcx, hasher);\n                 name.hash_stable(hcx, hasher);\n             }\n+            ty::ReLateBound(db, ty::BrEnv) => {\n+                db.depth.hash_stable(hcx, hasher);\n+            }\n             ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, index, name }) => {\n                 def_id.hash_stable(hcx, hasher);\n                 index.hash_stable(hcx, hasher);\n@@ -515,7 +518,7 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl_stable_hash_for!(struct ::middle::region::FirstStatementIndex { idx });\n+impl_stable_hash_for!(tuple_struct ::middle::region::FirstStatementIndex { idx });\n impl_stable_hash_for!(struct ::middle::region::Scope { id, code });\n \n impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for region::Scope {\n@@ -841,3 +844,129 @@ impl_stable_hash_for!(struct ::util::common::ErrorReported {});\n impl_stable_hash_for!(tuple_struct ::middle::reachable::ReachableSet {\n     reachable_set\n });\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::Vtable::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match self {\n+            &VtableImpl(ref table_impl) => table_impl.hash_stable(hcx, hasher),\n+            &VtableDefaultImpl(ref table_def_impl) => table_def_impl.hash_stable(hcx, hasher),\n+            &VtableParam(ref table_param) => table_param.hash_stable(hcx, hasher),\n+            &VtableObject(ref table_obj) => table_obj.hash_stable(hcx, hasher),\n+            &VtableBuiltin(ref table_builtin) => table_builtin.hash_stable(hcx, hasher),\n+            &VtableClosure(ref table_closure) => table_closure.hash_stable(hcx, hasher),\n+            &VtableFnPointer(ref table_fn_pointer) => table_fn_pointer.hash_stable(hcx, hasher),\n+            &VtableGenerator(ref table_generator) => table_generator.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableImplData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableImplData {\n+            impl_def_id,\n+            substs,\n+            ref nested,\n+        } = *self;\n+        impl_def_id.hash_stable(hcx, hasher);\n+        substs.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableDefaultImplData<N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableDefaultImplData {\n+            trait_def_id,\n+            ref nested,\n+        } = *self;\n+        trait_def_id.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableObjectData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableObjectData {\n+            upcast_trait_ref,\n+            vtable_base,\n+            ref nested,\n+        } = *self;\n+        upcast_trait_ref.hash_stable(hcx, hasher);\n+        vtable_base.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableBuiltinData<N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableBuiltinData {\n+            ref nested,\n+        } = *self;\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableClosureData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableClosureData {\n+            closure_def_id,\n+            substs,\n+            ref nested,\n+        } = *self;\n+        closure_def_id.hash_stable(hcx, hasher);\n+        substs.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableFnPointerData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableFnPointerData {\n+            fn_ty,\n+            ref nested,\n+        } = *self;\n+        fn_ty.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableGeneratorData {\n+            closure_def_id,\n+            substs,\n+            ref nested,\n+        } = *self;\n+        closure_def_id.hash_stable(hcx, hasher);\n+        substs.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "79eeebfb250316c5a4d598ae3948b05561f55f7b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -480,16 +480,16 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     {\n         assert!(!value.needs_subst());\n         let value = self.erase_late_bound_regions(value);\n-        self.normalize_associated_type(&value)\n+        self.fully_normalize_associated_types_in(&value)\n     }\n \n     /// Fully normalizes any associated types in `value`, using an\n     /// empty environment and `Reveal::All` mode (therefore, suitable\n     /// only for monomorphized code during trans, basically).\n-    pub fn normalize_associated_type<T>(self, value: &T) -> T\n+    pub fn fully_normalize_associated_types_in<T>(self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n-        debug!(\"normalize_associated_type(t={:?})\", value);\n+        debug!(\"fully_normalize_associated_types_in(t={:?})\", value);\n \n         let param_env = ty::ParamEnv::empty(Reveal::All);\n         let value = self.erase_regions(value);"}, {"sha": "64fe4626d6ee69e4a31ba10043fb396348949624", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -60,7 +60,7 @@\n #![cfg_attr(stage0, feature(const_fn))]\n #![cfg_attr(not(stage0), feature(const_atomic_bool_new))]\n \n-#![recursion_limit=\"256\"]\n+#![recursion_limit=\"512\"]\n \n extern crate arena;\n #[macro_use] extern crate bitflags;\n@@ -106,6 +106,7 @@ pub mod lint;\n \n pub mod middle {\n     pub mod allocator;\n+    pub mod borrowck;\n     pub mod expr_use_visitor;\n     pub mod const_val;\n     pub mod cstore;"}, {"sha": "d28963fc726abf5b6ffd9b89845d27dc12fdbeb3", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -222,6 +222,12 @@ declare_lint! {\n     \"unnecessary use of an `unsafe` block\"\n }\n \n+declare_lint! {\n+    pub UNUSED_MUT,\n+    Warn,\n+    \"detect mut variables which don't need to be mutable\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -263,7 +269,8 @@ impl LintPass for HardwiredLints {\n             PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n             LATE_BOUND_LIFETIME_ARGUMENTS,\n             DEPRECATED,\n-            UNUSED_UNSAFE\n+            UNUSED_UNSAFE,\n+            UNUSED_MUT\n         )\n     }\n }"}, {"sha": "c8690422b189302eea4ee2e4e4fed304cbe39eec", "filename": "src/librustc/middle/borrowck.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ich::StableHashingContext;\n+use hir::HirId;\n+use util::nodemap::FxHashSet;\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+\n+pub struct BorrowCheckResult {\n+    pub used_mut_nodes: FxHashSet<HirId>,\n+}\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for BorrowCheckResult {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let BorrowCheckResult {\n+            ref used_mut_nodes,\n+        } = *self;\n+        used_mut_nodes.hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "5c86554f9079011e12b1244f40dce588c6f84309", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -171,7 +171,7 @@ fn build_local_id_to_index(body: Option<&hir::Body>,\n                            -> FxHashMap<hir::ItemLocalId, Vec<CFGIndex>> {\n     let mut index = FxHashMap();\n \n-    // FIXME (#6298): Would it be better to fold formals from decl\n+    // FIXME(#15020) Would it be better to fold formals from decl\n     // into cfg itself?  i.e. introduce a fn-based flow-graph in\n     // addition to the current block-based flow-graph, rather than\n     // have to put traversals like this here?"}, {"sha": "e62cc2a658a474cf6f1d75da9956ebc627afa813", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -27,10 +27,11 @@ use middle::region;\n use ty::{self, TyCtxt, adjustment};\n \n use hir::{self, PatKind};\n-\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n+use util::nodemap::ItemLocalMap;\n \n ///////////////////////////////////////////////////////////////////////////\n // The Delegate trait\n@@ -262,15 +263,30 @@ macro_rules! return_if_err {\n }\n \n impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n+    /// Creates the ExprUseVisitor, configuring it with the various options provided:\n+    ///\n+    /// - `delegate` -- who receives the callbacks\n+    /// - `param_env` --- parameter environment for trait lookups (esp. pertaining to `Copy`)\n+    /// - `region_scope_tree` --- region scope tree for the code being analyzed\n+    /// - `tables` --- typeck results for the code being analyzed\n+    /// - `rvalue_promotable_map` --- if you care about rvalue promotion, then provide\n+    ///   the map here (it can be computed with `tcx.rvalue_promotable_map(def_id)`).\n+    ///   `None` means that rvalues will be given more conservative lifetimes.\n+    ///\n+    /// See also `with_infer`, which is used *during* typeck.\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                param_env: ty::ParamEnv<'tcx>,\n                region_scope_tree: &'a region::ScopeTree,\n-               tables: &'a ty::TypeckTables<'tcx>)\n+               tables: &'a ty::TypeckTables<'tcx>,\n+               rvalue_promotable_map: Option<Rc<ItemLocalMap<bool>>>)\n                -> Self\n     {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::new(tcx, region_scope_tree, tables),\n+            mc: mc::MemCategorizationContext::new(tcx,\n+                                                  region_scope_tree,\n+                                                  tables,\n+                                                  rvalue_promotable_map),\n             delegate,\n             param_env,\n         }"}, {"sha": "e0e30f8831676aa28cb69b3a062a156b2a819ea8", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -86,6 +86,7 @@ use syntax_pos::Span;\n \n use std::fmt;\n use std::rc::Rc;\n+use util::nodemap::ItemLocalMap;\n \n #[derive(Clone, PartialEq)]\n pub enum Categorization<'tcx> {\n@@ -285,6 +286,7 @@ pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub region_scope_tree: &'a region::ScopeTree,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n+    rvalue_promotable_map: Option<Rc<ItemLocalMap<bool>>>,\n     infcx: Option<&'a InferCtxt<'a, 'gcx, 'tcx>>,\n }\n \n@@ -392,21 +394,46 @@ impl MutabilityCategory {\n impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                region_scope_tree: &'a region::ScopeTree,\n-               tables: &'a ty::TypeckTables<'tcx>)\n+               tables: &'a ty::TypeckTables<'tcx>,\n+               rvalue_promotable_map: Option<Rc<ItemLocalMap<bool>>>)\n                -> MemCategorizationContext<'a, 'tcx, 'tcx> {\n-        MemCategorizationContext { tcx, region_scope_tree, tables, infcx: None }\n+        MemCategorizationContext {\n+            tcx,\n+            region_scope_tree,\n+            tables,\n+            rvalue_promotable_map,\n+            infcx: None\n+        }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+    /// Creates a `MemCategorizationContext` during type inference.\n+    /// This is used during upvar analysis and a few other places.\n+    /// Because the typeck tables are not yet complete, the results\n+    /// from the analysis must be used with caution:\n+    ///\n+    /// - rvalue promotions are not known, so the lifetimes of\n+    ///   temporaries may be overly conservative;\n+    /// - similarly, as the results of upvar analysis are not yet\n+    ///   known, the results around upvar accesses may be incorrect.\n     pub fn with_infer(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n                       region_scope_tree: &'a region::ScopeTree,\n                       tables: &'a ty::TypeckTables<'tcx>)\n                       -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+        let tcx = infcx.tcx;\n+\n+        // Subtle: we can't do rvalue promotion analysis until the\n+        // typeck phase is complete, which means that you can't trust\n+        // the rvalue lifetimes that result, but that's ok, since we\n+        // don't need to know those during type inference.\n+        let rvalue_promotable_map = None;\n+\n         MemCategorizationContext {\n-            tcx: infcx.tcx,\n+            tcx,\n             region_scope_tree,\n             tables,\n+            rvalue_promotable_map,\n             infcx: Some(infcx),\n         }\n     }\n@@ -477,10 +504,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n     fn pat_ty(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n         let base_ty = self.node_ty(pat.hir_id)?;\n-        // FIXME (Issue #18207): This code detects whether we are\n-        // looking at a `ref x`, and if so, figures out what the type\n-        // *being borrowed* is.  But ideally we would put in a more\n-        // fundamental fix to this conflated use of the node id.\n+        // This code detects whether we are looking at a `ref x`,\n+        // and if so, figures out what the type *being borrowed* is.\n         let ret_ty = match pat.node {\n             PatKind::Binding(..) => {\n                 let bm = *self.tables\n@@ -871,8 +896,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                            span: Span,\n                            expr_ty: Ty<'tcx>)\n                            -> cmt<'tcx> {\n-        let promotable = self.tcx.rvalue_promotable_to_static.borrow().get(&id).cloned()\n-                                   .unwrap_or(false);\n+        let hir_id = self.tcx.hir.node_to_hir_id(id);\n+        let promotable = self.rvalue_promotable_map.as_ref().map(|m| m[&hir_id.local_id])\n+                                                            .unwrap_or(false);\n \n         // Always promote `[T; 0]` (even when e.g. borrowed mutably).\n         let promotable = match expr_ty.sty {\n@@ -887,7 +913,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let re = if promotable {\n             self.tcx.types.re_static\n         } else {\n-            self.temporary_scope(self.tcx.hir.node_to_hir_id(id).local_id)\n+            self.temporary_scope(hir_id.local_id)\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n         debug!(\"cat_rvalue_node ret {:?}\", ret);"}, {"sha": "2037bc01a5bc94a5bfe513a48f1b865e5fb3b0b9", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -58,11 +58,10 @@ fn item_might_be_inlined(item: &hir::Item) -> bool {\n }\n \n fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     sig: &hir::MethodSig,\n                                      impl_item: &hir::ImplItem,\n                                      impl_src: DefId) -> bool {\n     if attr::requests_inline(&impl_item.attrs) ||\n-        generics_require_inlining(&sig.generics) {\n+        generics_require_inlining(&impl_item.generics) {\n         return true\n     }\n     if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n@@ -176,8 +175,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Some(hir_map::NodeImplItem(impl_item)) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(..) => true,\n-                    hir::ImplItemKind::Method(ref sig, _) => {\n-                        if generics_require_inlining(&sig.generics) ||\n+                    hir::ImplItemKind::Method(..) => {\n+                        if generics_require_inlining(&impl_item.generics) ||\n                                 attr::requests_inline(&impl_item.attrs) {\n                             true\n                         } else {\n@@ -293,9 +292,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Const(_, body) => {\n                         self.visit_nested_body(body);\n                     }\n-                    hir::ImplItemKind::Method(ref sig, body) => {\n+                    hir::ImplItemKind::Method(_, body) => {\n                         let did = self.tcx.hir.get_parent_did(search_item);\n-                        if method_might_be_inlined(self.tcx, sig, impl_item, did) {\n+                        if method_might_be_inlined(self.tcx, impl_item, did) {\n                             self.visit_nested_body(body)\n                         }\n                     }\n@@ -336,6 +335,12 @@ struct CollectPrivateImplItemsVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n+        // Anything which has custom linkage gets thrown on the worklist no\n+        // matter where it is in the crate.\n+        if attr::contains_name(&item.attrs, \"linkage\") {\n+            self.worklist.push(item.id);\n+        }\n+\n         // We need only trait impls here, not inherent impls, and only non-exported ones\n         if let hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n             if !self.access_levels.is_reachable(item.id) {"}, {"sha": "fa4ee7c00929152db196d7ec8b431e42cbf5d27d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -156,26 +156,11 @@ pub struct BlockRemainder {\n     pub first_statement_index: FirstStatementIndex,\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n-         RustcDecodable, Copy)]\n-pub struct FirstStatementIndex { pub idx: u32 }\n-\n-impl Idx for FirstStatementIndex {\n-    fn new(idx: usize) -> Self {\n-        assert!(idx <= SCOPE_DATA_REMAINDER_MAX as usize);\n-        FirstStatementIndex { idx: idx as u32 }\n-    }\n-\n-    fn index(self) -> usize {\n-        self.idx as usize\n-    }\n-}\n-\n-impl fmt::Debug for FirstStatementIndex {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.index(), formatter)\n-    }\n-}\n+newtype_index!(FirstStatementIndex\n+    {\n+        DEBUG_NAME = \"\",\n+        MAX = SCOPE_DATA_REMAINDER_MAX,\n+    });\n \n impl From<ScopeData> for Scope {\n     #[inline]\n@@ -208,7 +193,7 @@ impl Scope {\n             SCOPE_DATA_DESTRUCTION => ScopeData::Destruction(self.id),\n             idx => ScopeData::Remainder(BlockRemainder {\n                 block: self.id,\n-                first_statement_index: FirstStatementIndex { idx }\n+                first_statement_index: FirstStatementIndex::new(idx as usize)\n             })\n         }\n     }\n@@ -960,7 +945,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n \n             hir::ExprAssignOp(..) | hir::ExprIndex(..) |\n             hir::ExprUnary(..) | hir::ExprCall(..) | hir::ExprMethodCall(..) => {\n-                // FIXME(#6268) Nested method calls\n+                // FIXME(https://github.com/rust-lang/rfcs/issues/811) Nested method calls\n                 //\n                 // The lifetimes for a call or method call look as follows:\n                 //\n@@ -1081,8 +1066,6 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     // Here, the expression `[...]` has an extended lifetime due to rule\n     // A, but the inner rvalues `a()` and `b()` have an extended lifetime\n     // due to rule C.\n-    //\n-    // FIXME(#6308) -- Note that `[]` patterns work more smoothly post-DST.\n \n     if let Some(expr) = init {\n         record_rvalue_scope_if_borrow_expr(visitor, &expr, blk_scope);"}, {"sha": "dc912f1c1b6165a918fdb708f4b330e258053f60", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -412,7 +412,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         if let hir::TraitItemKind::Method(ref sig, _) = trait_item.node {\n             self.visit_early_late(\n                 Some(self.hir_map.get_parent(trait_item.id)),\n-                &sig.decl, &sig.generics,\n+                &sig.decl, &trait_item.generics,\n                 |this| intravisit::walk_trait_item(this, trait_item))\n         } else {\n             intravisit::walk_trait_item(self, trait_item);\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n             self.visit_early_late(\n                 Some(self.hir_map.get_parent(impl_item.id)),\n-                &sig.decl, &sig.generics,\n+                &sig.decl, &impl_item.generics,\n                 |this| intravisit::walk_impl_item(this, impl_item))\n         } else {\n             intravisit::walk_impl_item(self, impl_item);"}, {"sha": "4e4fc8b3118ffd53ed3632afb9441485a40cf8ad", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -429,7 +429,7 @@ impl<'a, 'tcx> Index<'tcx> {\n             // while maintaining the invariant that all sysroot crates are unstable\n             // by default and are unable to be used.\n             if tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n-                let reason = \"this crate is being loaded from the sysroot, and \\\n+                let reason = \"this crate is being loaded from the sysroot, an \\\n                               unstable location; did you mean to load this crate \\\n                               from crates.io via `Cargo.toml` instead?\";\n                 let stability = tcx.intern_stability(Stability {"}, {"sha": "fb0c7ce1df23dd38a3be7a1c37f33b969701d39d", "filename": "src/librustc/mir/README.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2FREADME.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -6,7 +6,7 @@ register and define new MIR transformations and analyses.\n \n Most of the code that operates on MIR can be found in the\n `librustc_mir` crate or other crates. The code found here in\n-`librustc` is just the datatype definitions, alonging the functions\n+`librustc` is just the datatype definitions, along with the functions\n which operate on MIR to be placed everywhere else.\n \n ## MIR Data Types and visitor\n@@ -27,7 +27,7 @@ As a MIR *consumer*, you are expected to use one of the queries that\n returns a \"final MIR\". As of the time of this writing, there is only\n one: `optimized_mir(def_id)`, but more are expected to come in the\n future. For foreign def-ids, we simply read the MIR from the other\n-crate's metadata. But for local query, this query will construct the\n+crate's metadata. But for local def-ids, the query will construct the\n MIR and then iteratively optimize it by putting it through various\n pipeline stages. This section describes those pipeline stages and how\n you can extend them.\n@@ -51,7 +51,7 @@ a `&'tcx Steal<Mir<'tcx>>`, allocated using\n **stolen** by the next suite of optimizations -- this is an\n optimization to avoid cloning the MIR. Attempting to use a stolen\n result will cause a panic in the compiler. Therefore, it is important\n-that you not read directly from these intermediate queries except as\n+that you do not read directly from these intermediate queries except as\n part of the MIR processing pipeline.\n \n Because of this stealing mechanism, some care must also be taken to"}, {"sha": "0159a198bc64744db417eb1e329e0ef590434867", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -260,6 +260,19 @@ impl<'tcx> Mir<'tcx> {\n         debug_assert!(location.statement_index < block.statements.len());\n         block.statements[location.statement_index].make_nop()\n     }\n+\n+    /// Returns the source info associated with `location`.\n+    pub fn source_info(&self, location: Location) -> &SourceInfo {\n+        let block = &self[location.block];\n+        let stmts = &block.statements;\n+        let idx = location.statement_index;\n+        if location.statement_index < stmts.len() {\n+            &stmts[idx].source_info\n+        } else {\n+            assert!(location.statement_index == stmts.len());\n+            &block.terminator().source_info\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -402,9 +415,11 @@ pub enum BorrowKind {\n ///////////////////////////////////////////////////////////////////////////\n // Variables and temps\n \n-newtype_index!(Local, \"_\");\n-\n-pub const RETURN_POINTER: Local = Local(0);\n+newtype_index!(Local\n+    {\n+        DEBUG_NAME = \"_\",\n+        const RETURN_POINTER = 0,\n+    });\n \n /// Classifies locals into categories. See `Mir::local_kind`.\n #[derive(PartialEq, Eq, Debug)]\n@@ -538,7 +553,7 @@ pub struct UpvarDecl {\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlock\n \n-newtype_index!(BasicBlock, \"bb\");\n+newtype_index!(BasicBlock { DEBUG_NAME = \"bb\" });\n \n ///////////////////////////////////////////////////////////////////////////\n // BasicBlockData and Terminator\n@@ -1118,7 +1133,7 @@ pub type LvalueProjection<'tcx> = Projection<'tcx, Lvalue<'tcx>, Local, Ty<'tcx>\n /// and the index is a local.\n pub type LvalueElem<'tcx> = ProjectionElem<'tcx, Local, Ty<'tcx>>;\n \n-newtype_index!(Field, \"field\");\n+newtype_index!(Field { DEBUG_NAME = \"field\" });\n \n impl<'tcx> Lvalue<'tcx> {\n     pub fn field(self, f: Field, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n@@ -1183,8 +1198,11 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Scopes\n \n-newtype_index!(VisibilityScope, \"scope\");\n-pub const ARGUMENT_VISIBILITY_SCOPE : VisibilityScope = VisibilityScope(0);\n+newtype_index!(VisibilityScope\n+    {\n+        DEBUG_NAME = \"scope\",\n+        const ARGUMENT_VISIBILITY_SCOPE = 0,\n+    });\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct VisibilityScopeData {\n@@ -1509,7 +1527,7 @@ pub struct Constant<'tcx> {\n     pub literal: Literal<'tcx>,\n }\n \n-newtype_index!(Promoted, \"promoted\");\n+newtype_index!(Promoted { DEBUG_NAME = \"promoted\" });\n \n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {"}, {"sha": "f9a4b5bb9a537b113077d79b7aa30025a3c5b65f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 14, "deletions": 46, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -352,7 +352,7 @@ top_level_options!(\n         actually_rustdoc: bool [TRACKED],\n \n         // Number of object files/codegen units to produce on the backend\n-        codegen_units: usize [UNTRACKED],\n+        cli_forced_codegen_units: Option<usize> [UNTRACKED],\n     }\n );\n \n@@ -409,9 +409,7 @@ impl_stable_hash_for!(struct self::OutputFilenames {\n     outputs\n });\n \n-/// Codegen unit names generated by the numbered naming scheme will contain this\n-/// marker right before the index of the codegen unit.\n-pub const NUMBERED_CODEGEN_UNIT_MARKER: &'static str = \".cgu-\";\n+pub const RUST_CGU_EXT: &str = \"rust-cgu\";\n \n impl OutputFilenames {\n     pub fn path(&self, flavor: OutputType) -> PathBuf {\n@@ -442,22 +440,14 @@ impl OutputFilenames {\n         let mut extension = String::new();\n \n         if let Some(codegen_unit_name) = codegen_unit_name {\n-            if codegen_unit_name.contains(NUMBERED_CODEGEN_UNIT_MARKER) {\n-                // If we use the numbered naming scheme for modules, we don't want\n-                // the files to look like <crate-name><extra>.<crate-name>.<index>.<ext>\n-                // but simply <crate-name><extra>.<index>.<ext>\n-                let marker_offset = codegen_unit_name.rfind(NUMBERED_CODEGEN_UNIT_MARKER)\n-                                                     .unwrap();\n-                let index_offset = marker_offset + NUMBERED_CODEGEN_UNIT_MARKER.len();\n-                extension.push_str(&codegen_unit_name[index_offset .. ]);\n-            } else {\n-                extension.push_str(codegen_unit_name);\n-            };\n+            extension.push_str(codegen_unit_name);\n         }\n \n         if !ext.is_empty() {\n             if !extension.is_empty() {\n                 extension.push_str(\".\");\n+                extension.push_str(RUST_CGU_EXT);\n+                extension.push_str(\".\");\n             }\n \n             extension.push_str(ext);\n@@ -515,7 +505,7 @@ pub fn basic_options() -> Options {\n         unstable_features: UnstableFeatures::Disallow,\n         debug_assertions: true,\n         actually_rustdoc: false,\n-        codegen_units: 1,\n+        cli_forced_codegen_units: None,\n     }\n }\n \n@@ -874,7 +864,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n          build_codegen_options, \"C\", \"codegen\",\n          CG_OPTIONS, cg_type_desc, cgsetters,\n     ar: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"tool to assemble archives with\"),\n+        \"this option is deprecated and does nothing\"),\n     linker: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"system linker to link outputs with\"),\n     link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n@@ -1060,6 +1050,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"print the result of the translation item collection pass\"),\n     mir_opt_level: usize = (1, parse_uint, [TRACKED],\n           \"set the MIR optimization level (0-3, default: 1)\"),\n+    mutable_noalias: bool = (false, parse_bool, [UNTRACKED],\n+          \"emit noalias metadata for mutable references\"),\n     dump_mir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"dump MIR state at various points in translation\"),\n     dump_mir_dir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n@@ -1105,6 +1097,10 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n                  \"run the non-lexical lifetimes MIR pass\"),\n     trans_time_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"generate a graphical HTML report of time spent in trans and LLVM\"),\n+    thinlto: bool = (false, parse_bool, [TRACKED],\n+        \"enable ThinLTO when possible\"),\n+    inline_in_all_cgus: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"control whether #[inline] functions are in all cgus\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -1714,34 +1710,6 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n \n     let incremental = debugging_opts.incremental.as_ref().map(|m| PathBuf::from(m));\n \n-    let codegen_units = codegen_units.unwrap_or_else(|| {\n-        match opt_level {\n-            // If we're compiling at `-O0` then default to 32 codegen units.\n-            // The number here shouldn't matter too too much as debug mode\n-            // builds don't rely on performance at all, meaning that lost\n-            // opportunities for inlining through multiple codegen units is\n-            // a non-issue.\n-            //\n-            // Note that the high number here doesn't mean that we'll be\n-            // spawning a large number of threads in parallel. The backend\n-            // of rustc contains global rate limiting through the\n-            // `jobserver` crate so we'll never overload the system with too\n-            // much work, but rather we'll only be optimizing when we're\n-            // otherwise cooperating with other instances of rustc.\n-            //\n-            // Rather the high number here means that we should be able to\n-            // keep a lot of idle cpus busy. By ensuring that no codegen\n-            // unit takes *too* long to build we'll be guaranteed that all\n-            // cpus will finish pretty closely to one another and we should\n-            // make relatively optimal use of system resources\n-            OptLevel::No => 32,\n-\n-            // All other optimization levels default use one codegen unit,\n-            // the historical default in Rust for a Long Time.\n-            _ => 1,\n-        }\n-    });\n-\n     (Options {\n         crate_types,\n         optimize: opt_level,\n@@ -1766,7 +1734,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         unstable_features: UnstableFeatures::from_environment(),\n         debug_assertions,\n         actually_rustdoc: false,\n-        codegen_units,\n+        cli_forced_codegen_units: codegen_units,\n     },\n     cfg)\n }"}, {"sha": "b636fc6c9950a7241b9f2071b7ac57a99bf57df2", "filename": "src/librustc/session/filesearch.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Ffilesearch.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -28,8 +28,6 @@ pub enum FileMatch {\n }\n \n // A module for searching for libraries\n-// FIXME (#2658): I'm not happy how this module turned out. Should\n-// probably just be folded into cstore.\n \n pub struct FileSearch<'a> {\n     pub sysroot: &'a Path,"}, {"sha": "2634ab10007032eb48021aede921626346ee6c76", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 64, "deletions": 27, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -54,24 +54,24 @@ pub mod config;\n pub mod filesearch;\n pub mod search_paths;\n \n-// Represents the data associated with a compilation\n-// session for a single crate.\n+/// Represents the data associated with a compilation\n+/// session for a single crate.\n pub struct Session {\n     pub target: config::Config,\n     pub host: Target,\n     pub opts: config::Options,\n     pub parse_sess: ParseSess,\n-    // For a library crate, this is always none\n+    /// For a library crate, this is always none\n     pub entry_fn: RefCell<Option<(NodeId, Span)>>,\n     pub entry_type: Cell<Option<config::EntryFnType>>,\n     pub plugin_registrar_fn: Cell<Option<ast::NodeId>>,\n     pub derive_registrar_fn: Cell<Option<ast::NodeId>>,\n     pub default_sysroot: Option<PathBuf>,\n-    // The name of the root source file of the crate, in the local file system.\n-    // `None` means that there is no source file.\n+    /// The name of the root source file of the crate, in the local file system.\n+    /// `None` means that there is no source file.\n     pub local_crate_source_file: Option<String>,\n-    // The directory the compiler has been executed in plus a flag indicating\n-    // if the value stored here has been affected by path remapping.\n+    /// The directory the compiler has been executed in plus a flag indicating\n+    /// if the value stored here has been affected by path remapping.\n     pub working_dir: (String, bool),\n     pub lint_store: RefCell<lint::LintStore>,\n     pub buffered_lints: RefCell<Option<lint::LintBuffer>>,\n@@ -83,11 +83,11 @@ pub struct Session {\n     pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n-    // The crate_disambiguator is constructed out of all the `-C metadata`\n-    // arguments passed to the compiler. Its value together with the crate-name\n-    // forms a unique global identifier for the crate. It is used to allow\n-    // multiple crates with the same name to coexist. See the\n-    // trans::back::symbol_names module for more information.\n+    /// The crate_disambiguator is constructed out of all the `-C metadata`\n+    /// arguments passed to the compiler. Its value together with the crate-name\n+    /// forms a unique global identifier for the crate. It is used to allow\n+    /// multiple crates with the same name to coexist. See the\n+    /// trans::back::symbol_names module for more information.\n     pub crate_disambiguator: RefCell<Option<Symbol>>,\n     pub features: RefCell<feature_gate::Features>,\n \n@@ -143,17 +143,17 @@ pub struct Session {\n }\n \n pub struct PerfStats {\n-    // The accumulated time needed for computing the SVH of the crate\n+    /// The accumulated time needed for computing the SVH of the crate\n     pub svh_time: Cell<Duration>,\n-    // The accumulated time spent on computing incr. comp. hashes\n+    /// The accumulated time spent on computing incr. comp. hashes\n     pub incr_comp_hashes_time: Cell<Duration>,\n-    // The number of incr. comp. hash computations performed\n+    /// The number of incr. comp. hash computations performed\n     pub incr_comp_hashes_count: Cell<u64>,\n-    // The number of bytes hashed when computing ICH values\n+    /// The number of bytes hashed when computing ICH values\n     pub incr_comp_bytes_hashed: Cell<u64>,\n-    // The accumulated time spent on computing symbol hashes\n+    /// The accumulated time spent on computing symbol hashes\n     pub symbol_hash_time: Cell<Duration>,\n-    // The accumulated time spent decoding def path tables from metadata\n+    /// The accumulated time spent decoding def path tables from metadata\n     pub decode_def_path_tables_time: Cell<Duration>,\n }\n \n@@ -636,6 +636,43 @@ impl Session {\n         }\n         ret\n     }\n+\n+    /// Returns the number of codegen units that should be used for this\n+    /// compilation\n+    pub fn codegen_units(&self) -> usize {\n+        if let Some(n) = self.opts.cli_forced_codegen_units {\n+            return n\n+        }\n+        if let Some(n) = self.target.target.options.default_codegen_units {\n+            return n as usize\n+        }\n+\n+        match self.opts.optimize {\n+            // If we're compiling at `-O0` then default to 16 codegen units.\n+            // The number here shouldn't matter too too much as debug mode\n+            // builds don't rely on performance at all, meaning that lost\n+            // opportunities for inlining through multiple codegen units is\n+            // a non-issue.\n+            //\n+            // Note that the high number here doesn't mean that we'll be\n+            // spawning a large number of threads in parallel. The backend\n+            // of rustc contains global rate limiting through the\n+            // `jobserver` crate so we'll never overload the system with too\n+            // much work, but rather we'll only be optimizing when we're\n+            // otherwise cooperating with other instances of rustc.\n+            //\n+            // Rather the high number here means that we should be able to\n+            // keep a lot of idle cpus busy. By ensuring that no codegen\n+            // unit takes *too* long to build we'll be guaranteed that all\n+            // cpus will finish pretty closely to one another and we should\n+            // make relatively optimal use of system resources\n+            config::OptLevel::No => 16,\n+\n+            // All other optimization levels default use one codegen unit,\n+            // the historical default in Rust for a Long Time.\n+            _ => 1,\n+        }\n+    }\n }\n \n pub fn build_session(sopts: config::Options,\n@@ -804,24 +841,24 @@ pub fn build_session_(sopts: config::Options,\n /// Holds data on the current incremental compilation session, if there is one.\n #[derive(Debug)]\n pub enum IncrCompSession {\n-    // This is the state the session will be in until the incr. comp. dir is\n-    // needed.\n+    /// This is the state the session will be in until the incr. comp. dir is\n+    /// needed.\n     NotInitialized,\n-    // This is the state during which the session directory is private and can\n-    // be modified.\n+    /// This is the state during which the session directory is private and can\n+    /// be modified.\n     Active {\n         session_directory: PathBuf,\n         lock_file: flock::Lock,\n         load_dep_graph: bool,\n     },\n-    // This is the state after the session directory has been finalized. In this\n-    // state, the contents of the directory must not be modified any more.\n+    /// This is the state after the session directory has been finalized. In this\n+    /// state, the contents of the directory must not be modified any more.\n     Finalized {\n         session_directory: PathBuf,\n     },\n-    // This is an error state that is reached when some compilation error has\n-    // occurred. It indicates that the contents of the session directory must\n-    // not be used, since they might be invalid.\n+    /// This is an error state that is reached when some compilation error has\n+    /// occurred. It indicates that the contents of the session directory must\n+    /// not be used, since they might be invalid.\n     InvalidBecauseOfErrors {\n         session_directory: PathBuf,\n     }"}, {"sha": "dc5ce7353246ab8e7972f309508073f4549f1286", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -252,7 +252,6 @@ fn uncovered_tys<'tcx>(tcx: TyCtxt, ty: Ty<'tcx>, infer_is_local: InferIsLocal)\n \n fn is_type_parameter(ty: Ty) -> bool {\n     match ty.sty {\n-        // FIXME(#20590) straighten story about projection types\n         ty::TyProjection(..) | ty::TyParam(..) => true,\n         _ => false,\n     }"}, {"sha": "030b7e4f646f924d8360e18af59113a512f282f9", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 172, "deletions": 43, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -711,41 +711,105 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, _) => {\n+            OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n+                let found_trait_ref = self.resolve_type_vars_if_possible(&*found_trait_ref);\n                 let expected_trait_ref = self.resolve_type_vars_if_possible(&*expected_trait_ref);\n-                let actual_trait_ref = self.resolve_type_vars_if_possible(&*actual_trait_ref);\n-                if actual_trait_ref.self_ty().references_error() {\n+                if expected_trait_ref.self_ty().references_error() {\n                     return;\n                 }\n-                let expected_trait_ty = expected_trait_ref.self_ty();\n-                let found_span = expected_trait_ty.ty_to_def_id().and_then(|did| {\n+                let found_trait_ty = found_trait_ref.self_ty();\n+\n+                let found_did = found_trait_ty.ty_to_def_id();\n+                let found_span = found_did.and_then(|did| {\n                     self.tcx.hir.span_if_local(did)\n                 });\n \n-                let self_ty_count =\n-                    match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n+                let found_ty_count =\n+                    match found_trait_ref.skip_binder().substs.type_at(1).sty {\n                         ty::TyTuple(ref tys, _) => tys.len(),\n                         _ => 1,\n                     };\n-                let arg_ty_count =\n-                    match actual_trait_ref.skip_binder().substs.type_at(1).sty {\n-                        ty::TyTuple(ref tys, _) => tys.len(),\n-                        _ => 1,\n+                let (expected_tys, expected_ty_count) =\n+                    match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n+                        ty::TyTuple(ref tys, _) =>\n+                            (tys.iter().map(|t| &t.sty).collect(), tys.len()),\n+                        ref sty => (vec![sty], 1),\n                     };\n-                if self_ty_count == arg_ty_count {\n+                if found_ty_count == expected_ty_count {\n                     self.report_closure_arg_mismatch(span,\n                                                      found_span,\n-                                                     expected_trait_ref,\n-                                                     actual_trait_ref)\n+                                                     found_trait_ref,\n+                                                     expected_trait_ref)\n                 } else {\n-                    // Expected `|| { }`, found `|x, y| { }`\n-                    // Expected `fn(x) -> ()`, found `|| { }`\n+                    let expected_tuple = if expected_ty_count == 1 {\n+                        expected_tys.first().and_then(|t| {\n+                            if let &&ty::TyTuple(ref tuptys, _) = t {\n+                                Some(tuptys.len())\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                    } else {\n+                        None\n+                    };\n+\n+                    // FIXME(#44150): Expand this to \"N args expected but a N-tuple found.\"\n+                    // Type of the 1st expected argument is somehow provided as type of a\n+                    // found one in that case.\n+                    //\n+                    // ```\n+                    // [1i32, 2, 3].sort_by(|(a, b)| ..)\n+                    // //                   ^^^^^^^^\n+                    // // expected_trait_ref:  std::ops::FnMut<(&i32, &i32)>\n+                    // //    found_trait_ref:  std::ops::FnMut<(&i32,)>\n+                    // ```\n+\n+                    let (closure_span, closure_args) = found_did\n+                        .and_then(|did| self.tcx.hir.get_if_local(did))\n+                        .and_then(|node| {\n+                            if let hir::map::NodeExpr(\n+                                &hir::Expr {\n+                                    node: hir::ExprClosure(_, ref decl, id, span, _),\n+                                    ..\n+                                }) = node\n+                            {\n+                                let ty_snips = decl.inputs.iter()\n+                                    .map(|ty| {\n+                                        self.tcx.sess.codemap().span_to_snippet(ty.span).ok()\n+                                            .and_then(|snip| {\n+                                                // filter out dummy spans\n+                                                if snip == \",\" || snip == \"|\" {\n+                                                    None\n+                                                } else {\n+                                                    Some(snip)\n+                                                }\n+                                            })\n+                                    })\n+                                    .collect::<Vec<Option<String>>>();\n+\n+                                let body = self.tcx.hir.body(id);\n+                                let pat_snips = body.arguments.iter()\n+                                    .map(|arg|\n+                                        self.tcx.sess.codemap().span_to_snippet(arg.pat.span).ok())\n+                                    .collect::<Option<Vec<String>>>();\n+\n+                                Some((span, pat_snips, ty_snips))\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .map(|(span, pat, ty)| (Some(span), Some((pat, ty))))\n+                        .unwrap_or((None, None));\n+                    let closure_args = closure_args.and_then(|(pat, ty)| Some((pat?, ty)));\n+\n                     self.report_arg_count_mismatch(\n                         span,\n-                        found_span,\n-                        arg_ty_count,\n-                        self_ty_count,\n-                        expected_trait_ty.is_closure()\n+                        closure_span.or(found_span),\n+                        expected_ty_count,\n+                        expected_tuple,\n+                        found_ty_count,\n+                        closure_args,\n+                        found_trait_ty.is_closure()\n                     )\n                 }\n             }\n@@ -767,32 +831,97 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_arg_count_mismatch(&self,\n-                                 span: Span,\n-                                 found_span: Option<Span>,\n-                                 expected: usize,\n-                                 found: usize,\n-                                 is_closure: bool)\n-        -> DiagnosticBuilder<'tcx>\n-    {\n+    fn report_arg_count_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected: usize,\n+        expected_tuple: Option<usize>,\n+        found: usize,\n+        closure_args: Option<(Vec<String>, Vec<Option<String>>)>,\n+        is_closure: bool\n+    ) -> DiagnosticBuilder<'tcx> {\n+        use std::borrow::Cow;\n+\n+        let kind = if is_closure { \"closure\" } else { \"function\" };\n+\n+        let args_str = |n, distinct| format!(\n+                \"{} {}argument{}\",\n+                n,\n+                if distinct && n >= 2 { \"distinct \" } else { \"\" },\n+                if n == 1 { \"\" } else { \"s\" },\n+            );\n+\n+        let expected_str = if let Some(n) = expected_tuple {\n+            assert!(expected == 1);\n+            if closure_args.as_ref().map(|&(ref pats, _)| pats.len()) == Some(n) {\n+                Cow::from(\"a single tuple as argument\")\n+            } else {\n+                // be verbose when numbers differ\n+                Cow::from(format!(\"a single {}-tuple as argument\", n))\n+            }\n+        } else {\n+            Cow::from(args_str(expected, false))\n+        };\n+\n+        let found_str = if expected_tuple.is_some() {\n+            args_str(found, true)\n+        } else {\n+            args_str(found, false)\n+        };\n+\n+\n         let mut err = struct_span_err!(self.tcx.sess, span, E0593,\n-            \"{} takes {} argument{} but {} argument{} {} required\",\n-            if is_closure { \"closure\" } else { \"function\" },\n-            found,\n-            if found == 1 { \"\" } else { \"s\" },\n-            expected,\n-            if expected == 1 { \"\" } else { \"s\" },\n-            if expected == 1 { \"is\" } else { \"are\" });\n-\n-        err.span_label(span, format!(\"expected {} that takes {} argument{}\",\n-                                      if is_closure { \"closure\" } else { \"function\" },\n-                                      expected,\n-                                      if expected == 1 { \"\" } else { \"s\" }));\n+            \"{} is expected to take {}, but it takes {}\",\n+            kind,\n+            expected_str,\n+            found_str,\n+        );\n+\n+        err.span_label(\n+            span,\n+            format!(\n+                \"expected {} that takes {}\",\n+                kind,\n+                expected_str,\n+            )\n+        );\n+\n         if let Some(span) = found_span {\n-            err.span_label(span, format!(\"takes {} argument{}\",\n-                                          found,\n-                                          if found == 1 { \"\" } else { \"s\" }));\n+            if let (Some(expected_tuple), Some((pats, tys))) = (expected_tuple, closure_args) {\n+                if expected_tuple != found || pats.len() != found {\n+                    err.span_label(span, format!(\"takes {}\", found_str));\n+                } else {\n+                    let sugg = format!(\n+                        \"|({}){}|\",\n+                        pats.join(\", \"),\n+\n+                        // add type annotations if available\n+                        if tys.iter().any(|ty| ty.is_some()) {\n+                            Cow::from(format!(\n+                                \": ({})\",\n+                                tys.into_iter().map(|ty| if let Some(ty) = ty {\n+                                    ty\n+                                } else {\n+                                    \"_\".to_string()\n+                                }).collect::<Vec<String>>().join(\", \")\n+                            ))\n+                        } else {\n+                            Cow::from(\"\")\n+                        },\n+                    );\n+\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider changing the closure to accept a tuple\",\n+                        sugg\n+                    );\n+                }\n+            } else {\n+                err.span_label(span, format!(\"takes {}\", found_str));\n+            }\n         }\n+\n         err\n     }\n "}, {"sha": "1fddb1864175f0752b2043d7101dbb9f3edcd8f7", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 50, "deletions": 44, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -650,53 +650,55 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Given a trait `trait_ref`, iterates the vtable entries\n /// that come from `trait_ref`, including its supertraits.\n #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n-pub fn get_vtable_methods<'a, 'tcx>(\n+fn vtable_methods<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>)\n-    -> impl Iterator<Item=Option<(DefId, &'tcx Substs<'tcx>)>> + 'a\n+    -> Rc<Vec<Option<(DefId, &'tcx Substs<'tcx>)>>>\n {\n-    debug!(\"get_vtable_methods({:?})\", trait_ref);\n-\n-    supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n-        let trait_methods = tcx.associated_items(trait_ref.def_id())\n-            .filter(|item| item.kind == ty::AssociatedKind::Method);\n-\n-        // Now list each method's DefId and Substs (for within its trait).\n-        // If the method can never be called from this object, produce None.\n-        trait_methods.map(move |trait_method| {\n-            debug!(\"get_vtable_methods: trait_method={:?}\", trait_method);\n-            let def_id = trait_method.def_id;\n-\n-            // Some methods cannot be called on an object; skip those.\n-            if !tcx.is_vtable_safe_method(trait_ref.def_id(), &trait_method) {\n-                debug!(\"get_vtable_methods: not vtable safe\");\n-                return None;\n-            }\n-\n-            // the method may have some early-bound lifetimes, add\n-            // regions for those\n-            let substs = Substs::for_item(tcx, def_id,\n-                                          |_, _| tcx.types.re_erased,\n-                                          |def, _| trait_ref.substs().type_for_def(def));\n-\n-            // the trait type may have higher-ranked lifetimes in it;\n-            // so erase them if they appear, so that we get the type\n-            // at some particular call site\n-            let substs = tcx.erase_late_bound_regions_and_normalize(&ty::Binder(substs));\n-\n-            // It's possible that the method relies on where clauses that\n-            // do not hold for this particular set of type parameters.\n-            // Note that this method could then never be called, so we\n-            // do not want to try and trans it, in that case (see #23435).\n-            let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-            if !normalize_and_test_predicates(tcx, predicates.predicates) {\n-                debug!(\"get_vtable_methods: predicates do not hold\");\n-                return None;\n-            }\n-\n-            Some((def_id, substs))\n-        })\n-    })\n+    debug!(\"vtable_methods({:?})\", trait_ref);\n+\n+    Rc::new(\n+        supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n+            let trait_methods = tcx.associated_items(trait_ref.def_id())\n+                .filter(|item| item.kind == ty::AssociatedKind::Method);\n+\n+            // Now list each method's DefId and Substs (for within its trait).\n+            // If the method can never be called from this object, produce None.\n+            trait_methods.map(move |trait_method| {\n+                debug!(\"vtable_methods: trait_method={:?}\", trait_method);\n+                let def_id = trait_method.def_id;\n+\n+                // Some methods cannot be called on an object; skip those.\n+                if !tcx.is_vtable_safe_method(trait_ref.def_id(), &trait_method) {\n+                    debug!(\"vtable_methods: not vtable safe\");\n+                    return None;\n+                }\n+\n+                // the method may have some early-bound lifetimes, add\n+                // regions for those\n+                let substs = Substs::for_item(tcx, def_id,\n+                                              |_, _| tcx.types.re_erased,\n+                                              |def, _| trait_ref.substs().type_for_def(def));\n+\n+                // the trait type may have higher-ranked lifetimes in it;\n+                // so erase them if they appear, so that we get the type\n+                // at some particular call site\n+                let substs = tcx.erase_late_bound_regions_and_normalize(&ty::Binder(substs));\n+\n+                // It's possible that the method relies on where clauses that\n+                // do not hold for this particular set of type parameters.\n+                // Note that this method could then never be called, so we\n+                // do not want to try and trans it, in that case (see #23435).\n+                let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n+                if !normalize_and_test_predicates(tcx, predicates.predicates) {\n+                    debug!(\"vtable_methods: predicates do not hold\");\n+                    return None;\n+                }\n+\n+                Some((def_id, substs))\n+            })\n+        }).collect()\n+    )\n }\n \n impl<'tcx,O> Obligation<'tcx,O> {\n@@ -835,6 +837,8 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         is_object_safe: object_safety::is_object_safe_provider,\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n+        trans_fulfill_obligation: trans::trans_fulfill_obligation,\n+        vtable_methods,\n         ..*providers\n     };\n }\n@@ -844,6 +848,8 @@ pub fn provide_extern(providers: &mut ty::maps::Providers) {\n         is_object_safe: object_safety::is_object_safe_provider,\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n+        trans_fulfill_obligation: trans::trans_fulfill_obligation,\n+        vtable_methods,\n         ..*providers\n     };\n }"}, {"sha": "cec79faff315d6fb4034f9f6e3d089d17d7f675d", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -1309,13 +1309,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         };\n \n         if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n-            // FIXME(#20297): Self is a type variable (e.g. `_: AsRef<str>`).\n+            // Self is a type variable (e.g. `_: AsRef<str>`).\n             //\n             // This is somewhat problematic, as the current scheme can't really\n             // handle it turning to be a projection. This does end up as truly\n             // ambiguous in most cases anyway.\n             //\n-            // Until this is fixed, take the fast path out - this also improves\n+            // Take the fast path out - this also improves\n             // performance by preventing assemble_candidates_from_impls from\n             // matching every impl for this trait.\n             return Ok(SelectionCandidateSet { vec: vec![], ambiguous: true });\n@@ -1383,8 +1383,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         debug!(\"assemble_candidates_for_projected_tys({:?})\", obligation);\n \n-        // FIXME(#20297) -- just examining the self-type is very simplistic\n-\n         // before we go into the whole skolemization thing, just\n         // quickly check if the self-type is a projection at all.\n         match obligation.predicate.0.trait_ref.self_ty().sty {\n@@ -2174,14 +2172,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             ty::TyClosure(def_id, ref substs) => {\n-                // FIXME(#27086). We are invariant w/r/t our\n-                // func_substs, but we don't see them as\n-                // constituent types; this seems RIGHT but also like\n-                // something that a normal type couldn't simulate. Is\n-                // this just a gap with the way that PhantomData and\n-                // OIBIT interact? That is, there is no way to say\n-                // \"make me invariant with respect to this TYPE, but\n-                // do not act as though I can reach it\"\n                 substs.upvar_tys(def_id, self.tcx()).collect()\n             }\n "}, {"sha": "761e7259204bff0b32ff75ff7fab3883431bfd4f", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 67, "deletions": 95, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -13,89 +13,79 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use dep_graph::{DepGraph, DepKind, DepTrackingMap, DepTrackingMapConfig};\n+use dep_graph::{DepKind, DepTrackingMapConfig};\n use infer::TransNormalize;\n-use std::cell::RefCell;\n use std::marker::PhantomData;\n-use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::DUMMY_SP;\n use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext, Vtable};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::{Subst, Substs};\n use ty::fold::{TypeFoldable, TypeFolder};\n-use util::common::MemoizationMap;\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n-    /// Attempts to resolve an obligation to a vtable.. The result is\n-    /// a shallow vtable resolution -- meaning that we do not\n-    /// (necessarily) resolve all nested obligations on the impl. Note\n-    /// that type check should guarantee to us that all nested\n-    /// obligations *could be* resolved if we wanted to.\n-    /// Assumes that this is run after the entire crate has been successfully type-checked.\n-    pub fn trans_fulfill_obligation(self,\n-                                    span: Span,\n-                                    param_env: ty::ParamEnv<'tcx>,\n-                                    trait_ref: ty::PolyTraitRef<'tcx>)\n-                                    -> Vtable<'tcx, ()>\n-    {\n-        // Remove any references to regions; this helps improve caching.\n-        let trait_ref = self.erase_regions(&trait_ref);\n-\n-        self.trans_trait_caches.trait_cache.memoize((param_env, trait_ref), || {\n-            debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n-                   (param_env, trait_ref), trait_ref.def_id());\n-\n-            // Do the initial selection for the obligation. This yields the\n-            // shallow result we are looking for -- that is, what specific impl.\n-            self.infer_ctxt().enter(|infcx| {\n-                let mut selcx = SelectionContext::new(&infcx);\n-\n-                let obligation_cause = ObligationCause::misc(span,\n-                                                             ast::DUMMY_NODE_ID);\n-                let obligation = Obligation::new(obligation_cause,\n-                                                 param_env,\n-                                                 trait_ref.to_poly_trait_predicate());\n-\n-                let selection = match selcx.select(&obligation) {\n-                    Ok(Some(selection)) => selection,\n-                    Ok(None) => {\n-                        // Ambiguity can happen when monomorphizing during trans\n-                        // expands to some humongo type that never occurred\n-                        // statically -- this humongo type can then overflow,\n-                        // leading to an ambiguous result. So report this as an\n-                        // overflow bug, since I believe this is the only case\n-                        // where ambiguity can result.\n-                        debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n-                                presuming due to overflow\",\n-                               trait_ref);\n-                        self.sess.span_fatal(span,\n-                                            \"reached the recursion limit during monomorphization \\\n-                                             (selection ambiguity)\");\n-                    }\n-                    Err(e) => {\n-                        span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                                  e, trait_ref)\n-                    }\n-                };\n-\n-                debug!(\"fulfill_obligation: selection={:?}\", selection);\n-\n-                // Currently, we use a fulfillment context to completely resolve\n-                // all nested obligations. This is because they can inform the\n-                // inference of the impl's type parameters.\n-                let mut fulfill_cx = FulfillmentContext::new();\n-                let vtable = selection.map(|predicate| {\n-                    debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n-                    fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-                });\n-                let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n-\n-                info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n-                vtable\n-            })\n-        })\n-    }\n+/// Attempts to resolve an obligation to a vtable.. The result is\n+/// a shallow vtable resolution -- meaning that we do not\n+/// (necessarily) resolve all nested obligations on the impl. Note\n+/// that type check should guarantee to us that all nested\n+/// obligations *could be* resolved if we wanted to.\n+/// Assumes that this is run after the entire crate has been successfully type-checked.\n+pub fn trans_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'a, 'tcx, 'tcx>,\n+                                          (param_env, trait_ref):\n+                                          (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>))\n+                                          -> Vtable<'tcx, ()>\n+{\n+    // Remove any references to regions; this helps improve caching.\n+    let trait_ref = ty.erase_regions(&trait_ref);\n+\n+    debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n+            (param_env, trait_ref), trait_ref.def_id());\n+\n+    // Do the initial selection for the obligation. This yields the\n+    // shallow result we are looking for -- that is, what specific impl.\n+    ty.infer_ctxt().enter(|infcx| {\n+        let mut selcx = SelectionContext::new(&infcx);\n+\n+        let obligation_cause = ObligationCause::dummy();\n+        let obligation = Obligation::new(obligation_cause,\n+                                            param_env,\n+                                            trait_ref.to_poly_trait_predicate());\n+\n+        let selection = match selcx.select(&obligation) {\n+            Ok(Some(selection)) => selection,\n+            Ok(None) => {\n+                // Ambiguity can happen when monomorphizing during trans\n+                // expands to some humongo type that never occurred\n+                // statically -- this humongo type can then overflow,\n+                // leading to an ambiguous result. So report this as an\n+                // overflow bug, since I believe this is the only case\n+                // where ambiguity can result.\n+                bug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                        presuming due to overflow\",\n+                        trait_ref)\n+            }\n+            Err(e) => {\n+                bug!(\"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                            e, trait_ref)\n+            }\n+        };\n+\n+        debug!(\"fulfill_obligation: selection={:?}\", selection);\n+\n+        // Currently, we use a fulfillment context to completely resolve\n+        // all nested obligations. This is because they can inform the\n+        // inference of the impl's type parameters.\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        let vtable = selection.map(|predicate| {\n+            debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n+            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+        });\n+        let vtable = infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &vtable);\n+\n+        info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n+        vtable\n+    })\n+}\n \n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// Monomorphizes a type from the AST by first applying the in-scope\n     /// substitutions and then normalizing any associated types.\n     pub fn trans_apply_param_substs<T>(self,\n@@ -138,26 +128,8 @@ impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'gcx> {\n         if !ty.has_projections() {\n             ty\n         } else {\n-            self.tcx.trans_trait_caches.project_cache.memoize(ty, || {\n-                debug!(\"AssociatedTypeNormalizer: ty={:?}\", ty);\n-                self.tcx.normalize_associated_type(&ty)\n-            })\n-        }\n-    }\n-}\n-\n-/// Specializes caches used in trans -- in particular, they assume all\n-/// types are fully monomorphized and that free regions can be erased.\n-pub struct TransTraitCaches<'tcx> {\n-    trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n-    project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n-}\n-\n-impl<'tcx> TransTraitCaches<'tcx> {\n-    pub fn new(graph: DepGraph) -> Self {\n-        TransTraitCaches {\n-            trait_cache: RefCell::new(DepTrackingMap::new(graph.clone())),\n-            project_cache: RefCell::new(DepTrackingMap::new(graph)),\n+            debug!(\"AssociatedTypeNormalizer: ty={:?}\", ty);\n+            self.tcx.fully_normalize_monormophic_ty(ty)\n         }\n     }\n }"}, {"sha": "3fd956ecfb87dea7f60567b9cf192103b7b5c8e2", "filename": "src/librustc/ty/README.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2FREADME.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -42,7 +42,7 @@ wasteful.\n Often, we wish to write code that explicitly asserts that it is not\n taking place during inference. In that case, there is no \"local\"\n arena, and all the types that you can access are allocated in the\n-global arena.  To express this, the idea is to us the same lifetime\n+global arena.  To express this, the idea is to use the same lifetime\n for the `'gcx` and `'tcx` parameters of `TyCtxt`. Just to be a touch\n confusing, we tend to use the name `'tcx` in such contexts. Here is an\n example:\n@@ -100,10 +100,10 @@ fn test_type<'tcx>(ty: Ty<'tcx>) {\n \n The `sty` field (the origin of this name is unclear to me; perhaps\n structural type?) is of type `TypeVariants<'tcx>`, which is an enum\n-definined all of the different kinds of types in the compiler.\n+defining all of the different kinds of types in the compiler.\n \n > NB: inspecting the `sty` field on types during type inference can be\n-> risky, as there are may be inference variables and other things to\n+> risky, as there may be inference variables and other things to\n > consider, or sometimes types are not yet known that will become\n > known later.).\n \n@@ -132,7 +132,7 @@ a safe approximation, so that is what you get back.\n > you are going to be testing for type equality, you probably need to\n > start looking into the inference code to do it right.\n \n-You can also find various common types in the tcx itself by accessing\n+You can also find various common types in the `tcx` itself by accessing\n `tcx.types.bool`, `tcx.types.char`, etc (see `CommonTypes` for more).\n \n ### Beyond types: Other kinds of arena-allocated data structures\n@@ -143,7 +143,7 @@ module. Here are a few examples:\n \n - `Substs`, allocated with `mk_substs` -- this will intern a slice of types, often used to\n   specify the values to be substituted for generics (e.g., `HashMap<i32, u32>`\n-  would be represented as a slice `&'tcx [tcx.types.i32, tcx.types.u32]`.\n+  would be represented as a slice `&'tcx [tcx.types.i32, tcx.types.u32]`).\n - `TraitRef`, typically passed by value -- a **trait reference**\n   consists of a reference to a trait along with its various type\n   parameters (including `Self`), like `i32: Display` (here, the def-id"}, {"sha": "47ca7b11731e71ecae8781ffbf520ae5e42cbe5e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -43,7 +43,6 @@ use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n-use ty::inhabitedness::DefIdForest;\n use ty::maps;\n use ty::steal::Steal;\n use ty::BindingMode;\n@@ -387,8 +386,10 @@ pub struct TypeckTables<'tcx> {\n     cast_kinds: ItemLocalMap<ty::cast::CastKind>,\n \n     /// Set of trait imports actually used in the method resolution.\n-    /// This is used for warning unused imports.\n-    pub used_trait_imports: DefIdSet,\n+    /// This is used for warning unused imports. During type\n+    /// checking, this `Rc` should not be cloned: it must have a ref-count\n+    /// of 1 so that we can insert things into the set mutably.\n+    pub used_trait_imports: Rc<DefIdSet>,\n \n     /// If any errors occurred while type-checking this body,\n     /// this field will be set to `true`.\n@@ -418,7 +419,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             liberated_fn_sigs: ItemLocalMap(),\n             fru_field_types: ItemLocalMap(),\n             cast_kinds: ItemLocalMap(),\n-            used_trait_imports: DefIdSet(),\n+            used_trait_imports: Rc::new(DefIdSet()),\n             tainted_by_errors: false,\n             free_region_map: FreeRegionMap::new(),\n         }\n@@ -852,9 +853,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub sess: &'tcx Session,\n \n-\n-    pub trans_trait_caches: traits::trans::TransTraitCaches<'tcx>,\n-\n     pub dep_graph: DepGraph,\n \n     /// Common types, pre-interned for your convenience.\n@@ -893,16 +891,6 @@ pub struct GlobalCtxt<'tcx> {\n     // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n \n-    // FIXME dep tracking -- should be harmless enough\n-    pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n-\n-    pub inhabitedness_cache: RefCell<FxHashMap<Ty<'tcx>, DefIdForest>>,\n-\n-    /// Set of nodes which mark locals as mutable which end up getting used at\n-    /// some point. Local variable definitions not in this set can be warned\n-    /// about.\n-    pub used_mut_nodes: RefCell<NodeSet>,\n-\n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n@@ -912,9 +900,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Merge this with `selection_cache`?\n     pub evaluation_cache: traits::EvaluationCache<'tcx>,\n \n-    /// Maps Expr NodeId's to `true` iff `&expr` can have 'static lifetime.\n-    pub rvalue_promotable_to_static: RefCell<NodeMap<bool>>,\n-\n     /// The definite name of the current crate after taking into account\n     /// attributes, commandline parameters, etc.\n     pub crate_name: Symbol,\n@@ -1151,7 +1136,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         tls::enter_global(GlobalCtxt {\n             sess: s,\n             cstore,\n-            trans_trait_caches: traits::trans::TransTraitCaches::new(dep_graph.clone()),\n             global_arenas: arenas,\n             global_interners: interners,\n             dep_graph: dep_graph.clone(),\n@@ -1183,12 +1167,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             maps: maps::Maps::new(providers),\n             mir_passes,\n             rcache: RefCell::new(FxHashMap()),\n-            normalized_cache: RefCell::new(FxHashMap()),\n-            inhabitedness_cache: RefCell::new(FxHashMap()),\n-            used_mut_nodes: RefCell::new(NodeSet()),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n-            rvalue_promotable_to_static: RefCell::new(NodeMap()),\n             crate_name: Symbol::intern(crate_name),\n             data_layout,\n             layout_interner: RefCell::new(FxHashSet()),\n@@ -1252,6 +1232,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn def_path_debug_str(self, def_id: DefId) -> String {\n+        // We are explicitly not going through queries here in order to get\n+        // crate name and disambiguator since this code is called from debug!()\n+        // statements within the query system and we'd run into endless\n+        // recursion otherwise.\n+        let (crate_name, crate_disambiguator) = if def_id.is_local() {\n+            (self.crate_name.clone(),\n+             self.sess.local_crate_disambiguator())\n+        } else {\n+            (self.cstore.crate_name_untracked(def_id.krate),\n+             self.cstore.crate_disambiguator_untracked(def_id.krate))\n+        };\n+\n+        format!(\"{}[{}]{}\",\n+                crate_name,\n+                // Don't print the whole crate disambiguator. That's just\n+                // annoying in debug output.\n+                &(crate_disambiguator.as_str())[..4],\n+                self.def_path(def_id).to_string_no_crate())\n+    }\n+\n     pub fn metadata_encoding_version(self) -> Vec<u8> {\n         self.cstore.metadata_encoding_version().to_vec()\n     }\n@@ -2319,4 +2320,7 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         assert_eq!(cnum, LOCAL_CRATE);\n         tcx.sess.features.borrow().clone_closures\n     };\n+    providers.fully_normalize_monormophic_ty = |tcx, ty| {\n+        tcx.fully_normalize_associated_types_in(&ty)\n+    };\n }"}, {"sha": "4f8fca67949b5ddd645ffba529ec183e74290184", "filename": "src/librustc/ty/erase_regions.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferase_regions.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ty::{self, Ty, TyCtxt};\n+use ty::fold::{TypeFolder, TypeFoldable};\n+\n+pub(super) fn provide(providers: &mut ty::maps::Providers) {\n+    *providers = ty::maps::Providers {\n+        erase_regions_ty,\n+        ..*providers\n+    };\n+}\n+\n+fn erase_regions_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    // NB: use `super_fold_with` here. If we used `fold_with`, it\n+    // could invoke the `erase_regions_ty` query recursively.\n+    ty.super_fold_with(&mut RegionEraserVisitor { tcx })\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    /// Returns an equivalent value with all free regions removed (note\n+    /// that late-bound regions remain, because they are important for\n+    /// subtyping, but they are anonymized and normalized as well)..\n+    pub fn erase_regions<T>(self, value: &T) -> T\n+        where T : TypeFoldable<'tcx>\n+    {\n+        let value1 = value.fold_with(&mut RegionEraserVisitor { tcx: self });\n+        debug!(\"erase_regions({:?}) = {:?}\", value, value1);\n+        value1\n+    }\n+}\n+\n+struct RegionEraserVisitor<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionEraserVisitor<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if let Some(ty_lifted) = self.tcx.lift_to_global(&ty) {\n+            self.tcx.erase_regions_ty(ty_lifted)\n+        } else {\n+            ty.super_fold_with(self)\n+        }\n+    }\n+\n+    fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        let u = self.tcx.anonymize_late_bound_regions(t);\n+        u.super_fold_with(self)\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        // because late-bound regions affect subtyping, we can't\n+        // erase the bound/free distinction, but we can replace\n+        // all free regions with 'erased.\n+        //\n+        // Note that we *CAN* replace early-bound regions -- the\n+        // type system never \"sees\" those, they get substituted\n+        // away. In trans, they will always be erased to 'erased\n+        // whenever a substitution occurs.\n+        match *r {\n+            ty::ReLateBound(..) => r,\n+            _ => self.tcx.types.re_erased\n+        }\n+    }\n+}\n+"}, {"sha": "edd4329fa419c39f03cbd4e1dd443d8271e705d7", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -444,67 +444,6 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Region eraser\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Returns an equivalent value with all free regions removed (note\n-    /// that late-bound regions remain, because they are important for\n-    /// subtyping, but they are anonymized and normalized as well)..\n-    pub fn erase_regions<T>(self, value: &T) -> T\n-        where T : TypeFoldable<'tcx>\n-    {\n-        let value1 = value.fold_with(&mut RegionEraser(self));\n-        debug!(\"erase_regions({:?}) = {:?}\",\n-               value, value1);\n-        return value1;\n-\n-        struct RegionEraser<'a, 'gcx: 'a+'tcx, 'tcx: 'a>(TyCtxt<'a, 'gcx, 'tcx>);\n-\n-        impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionEraser<'a, 'gcx, 'tcx> {\n-            fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.0 }\n-\n-            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-                if let Some(u) = self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n-                    return u;\n-                }\n-\n-                // FIXME(eddyb) should local contexts have a cache too?\n-                if let Some(ty_lifted) = self.tcx().lift_to_global(&ty) {\n-                    let tcx = self.tcx().global_tcx();\n-                    let t_norm = ty_lifted.super_fold_with(&mut RegionEraser(tcx));\n-                    tcx.normalized_cache.borrow_mut().insert(ty_lifted, t_norm);\n-                    t_norm\n-                } else {\n-                    ty.super_fold_with(self)\n-                }\n-            }\n-\n-            fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n-                where T : TypeFoldable<'tcx>\n-            {\n-                let u = self.tcx().anonymize_late_bound_regions(t);\n-                u.super_fold_with(self)\n-            }\n-\n-            fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-                // because late-bound regions affect subtyping, we can't\n-                // erase the bound/free distinction, but we can replace\n-                // all free regions with 'erased.\n-                //\n-                // Note that we *CAN* replace early-bound regions -- the\n-                // type system never \"sees\" those, they get substituted\n-                // away. In trans, they will always be erased to 'erased\n-                // whenever a substitution occurs.\n-                match *r {\n-                    ty::ReLateBound(..) => r,\n-                    _ => self.tcx().types.re_erased\n-                }\n-            }\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Region shifter\n //"}, {"sha": "0072512464a0e95406d9d7ab3a9dde4b29efcb4a", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 104, "deletions": 47, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -10,7 +10,7 @@\n \n use util::nodemap::{FxHashMap, FxHashSet};\n use ty::context::TyCtxt;\n-use ty::{AdtDef, VariantDef, FieldDef, TyS};\n+use ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n use ty::{DefId, Substs};\n use ty::{AdtKind, Visibility};\n use ty::TypeVariants::*;\n@@ -62,13 +62,95 @@ mod def_id_forest;\n // This code should only compile in modules where the uninhabitedness of Foo is\n // visible.\n \n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    /// Checks whether a type is visibly uninhabited from a particular module.\n+    /// # Example\n+    /// ```rust\n+    /// enum Void {}\n+    /// mod a {\n+    ///     pub mod b {\n+    ///         pub struct SecretlyUninhabited {\n+    ///             _priv: !,\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// mod c {\n+    ///     pub struct AlsoSecretlyUninhabited {\n+    ///         _priv: Void,\n+    ///     }\n+    ///     mod d {\n+    ///     }\n+    /// }\n+    ///\n+    /// struct Foo {\n+    ///     x: a::b::SecretlyUninhabited,\n+    ///     y: c::AlsoSecretlyUninhabited,\n+    /// }\n+    /// ```\n+    /// In this code, the type `Foo` will only be visibly uninhabited inside the\n+    /// modules b, c and d. This effects pattern-matching on `Foo` or types that\n+    /// contain `Foo`.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// let foo_result: Result<T, Foo> = ... ;\n+    /// let Ok(t) = foo_result;\n+    /// ```\n+    /// This code should only compile in modules where the uninhabitedness of Foo is\n+    /// visible.\n+    pub fn is_ty_uninhabited_from(self, module: DefId, ty: Ty<'tcx>) -> bool {\n+        // To check whether this type is uninhabited at all (not just from the\n+        // given node) you could check whether the forest is empty.\n+        // ```\n+        // forest.is_empty()\n+        // ```\n+        self.ty_inhabitedness_forest(ty).contains(self, module)\n+    }\n+\n+    pub fn is_ty_uninhabited_from_all_modules(self, ty: Ty<'tcx>) -> bool {\n+        !self.ty_inhabitedness_forest(ty).is_empty()\n+    }\n+\n+    fn ty_inhabitedness_forest(self, ty: Ty<'tcx>) -> DefIdForest {\n+        ty.uninhabited_from(&mut FxHashMap(), self)\n+    }\n+\n+    pub fn is_enum_variant_uninhabited_from(self,\n+                                            module: DefId,\n+                                            variant: &'tcx VariantDef,\n+                                            substs: &'tcx Substs<'tcx>)\n+                                            -> bool\n+    {\n+        self.variant_inhabitedness_forest(variant, substs).contains(self, module)\n+    }\n+\n+    pub fn is_variant_uninhabited_from_all_modules(self,\n+                                                   variant: &'tcx VariantDef,\n+                                                   substs: &'tcx Substs<'tcx>)\n+                                                   -> bool\n+    {\n+        !self.variant_inhabitedness_forest(variant, substs).is_empty()\n+    }\n+\n+    fn variant_inhabitedness_forest(self, variant: &'tcx VariantDef, substs: &'tcx Substs<'tcx>)\n+                                    -> DefIdForest {\n+        // Determine the ADT kind:\n+        let adt_def_id = self.adt_def_id_of_variant(variant);\n+        let adt_kind = self.adt_def(adt_def_id).adt_kind();\n+\n+        // Compute inhabitedness forest:\n+        variant.uninhabited_from(&mut FxHashMap(), self, substs, adt_kind)\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n-    pub fn uninhabited_from(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                substs: &'tcx Substs<'tcx>) -> DefIdForest\n+    fn uninhabited_from(\n+        &self,\n+        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        substs: &'tcx Substs<'tcx>) -> DefIdForest\n     {\n         DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n             v.uninhabited_from(visited, tcx, substs, self.adt_kind())\n@@ -78,12 +160,12 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n     /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n-    pub fn uninhabited_from(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                substs: &'tcx Substs<'tcx>,\n-                adt_kind: AdtKind) -> DefIdForest\n+    fn uninhabited_from(\n+        &self,\n+        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        substs: &'tcx Substs<'tcx>,\n+        adt_kind: AdtKind) -> DefIdForest\n     {\n         match adt_kind {\n             AdtKind::Union => {\n@@ -107,12 +189,12 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n \n impl<'a, 'gcx, 'tcx> FieldDef {\n     /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n-    pub fn uninhabited_from(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                substs: &'tcx Substs<'tcx>,\n-                is_enum: bool) -> DefIdForest\n+    fn uninhabited_from(\n+        &self,\n+        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        substs: &'tcx Substs<'tcx>,\n+        is_enum: bool) -> DefIdForest\n     {\n         let mut data_uninhabitedness = move || {\n             self.ty(tcx, substs).uninhabited_from(visited, tcx)\n@@ -138,35 +220,10 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n \n impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n-    pub fn uninhabited_from(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n-    {\n-        match tcx.lift_to_global(&self) {\n-            Some(global_ty) => {\n-                {\n-                    let cache = tcx.inhabitedness_cache.borrow();\n-                    if let Some(forest) = cache.get(&global_ty) {\n-                        return forest.clone();\n-                    }\n-                }\n-                let forest = global_ty.uninhabited_from_inner(visited, tcx);\n-                let mut cache = tcx.inhabitedness_cache.borrow_mut();\n-                cache.insert(global_ty, forest.clone());\n-                forest\n-            },\n-            None => {\n-                let forest = self.uninhabited_from_inner(visited, tcx);\n-                forest\n-            },\n-        }\n-    }\n-\n-    fn uninhabited_from_inner(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n+    fn uninhabited_from(\n+        &self,\n+        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match self.sty {\n             TyAdt(def, substs) => {"}, {"sha": "600b2572f92b858544abdb018f63ab335d90d226", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -13,7 +13,6 @@ use ty::{self, Ty, TypeFoldable, Substs, TyCtxt};\n use ty::subst::{Kind, Subst};\n use traits;\n use syntax::abi::Abi;\n-use syntax::codemap::DUMMY_SP;\n use util::ppaux;\n \n use std::fmt;\n@@ -212,7 +211,7 @@ fn resolve_associated_item<'a, 'tcx>(\n            def_id, trait_id, rcvr_substs);\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = tcx.trans_fulfill_obligation(DUMMY_SP, param_env, ty::Binder(trait_ref));\n+    let vtbl = tcx.trans_fulfill_obligation((param_env, ty::Binder(trait_ref)));\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:"}, {"sha": "8207c18e67791af4507a6b5604cd298ce4ea9863", "filename": "src/librustc/ty/maps/README.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fmaps%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fmaps%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2FREADME.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -169,7 +169,7 @@ That is, they take an `&mut Providers` and mutate it in place. Usually\n we use the formulation above just because it looks nice, but you could\n as well do `providers.type_of = type_of`, which would be equivalent.\n (Here, `type_of` would be a top-level function, defined as we saw\n-before.) So, if we wanted to have add a provider for some other query,\n+before.) So, if we want to add a provider for some other query,\n let's call it `fubar`, into the crate above, we might modify the `provide()`\n function like so:\n \n@@ -185,7 +185,7 @@ pub fn provide(providers: &mut Providers) {\n fn fubar<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx>, key: DefId) -> Fubar<'tcx> { .. }\n ```\n \n-NB. Most of the `rustc_*` crate only provide **local\n+NB. Most of the `rustc_*` crates only provide **local\n providers**. Almost all **extern providers** wind up going through the\n `rustc_metadata` crate, which loads the information from the crate\n metadata.  But in some cases there are crates that provide queries for\n@@ -201,7 +201,7 @@ Well, defining a query takes place in two steps:\n 1. first, you have to specify the query name and arguments; and then,\n 2. you have to supply query providers where needed.\n \n-The specify the query name and arguments, you simply add an entry\n+To specify the query name and arguments, you simply add an entry\n to the big macro invocation in `mod.rs`. This will probably have changed\n by the time you read this README, but at present it looks something\n like:"}, {"sha": "deaafd1efed450a710745e464ddf71eb27fcd625", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -29,7 +29,12 @@ pub(super) trait QueryDescription: QueryConfig {\n \n impl<M: QueryConfig<Key=DefId>> QueryDescription for M {\n     default fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"processing `{}`\", tcx.item_path_str(def_id))\n+        if !tcx.sess.verbose() {\n+            format!(\"processing `{}`\", tcx.item_path_str(def_id))\n+        } else {\n+            let name = unsafe { ::std::intrinsics::type_name::<M>() };\n+            format!(\"processing `{}` applied to `{:?}`\", name, def_id)\n+        }\n     }\n }\n \n@@ -70,6 +75,12 @@ impl<'tcx> QueryDescription for queries::super_predicates_of<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::erase_regions_ty<'tcx> {\n+    fn describe(_tcx: TyCtxt, ty: Ty<'tcx>) -> String {\n+        format!(\"erasing regions from `{:?}`\", ty)\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::type_param_predicates<'tcx> {\n     fn describe(tcx: TyCtxt, (_, def_id): (DefId, DefId)) -> String {\n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n@@ -214,13 +225,26 @@ impl<'tcx> QueryDescription for queries::const_is_rvalue_promotable_to_static<'t\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::rvalue_promotable_map<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"checking which parts of `{}` are promotable to static\",\n+                tcx.item_path_str(def_id))\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::is_mir_available<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"checking if item is mir available: `{}`\",\n             tcx.item_path_str(def_id))\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::trans_fulfill_obligation<'tcx> {\n+    fn describe(tcx: TyCtxt, key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> String {\n+        format!(\"checking if `{}` fulfills its obligations\", tcx.item_path_str(key.1.def_id()))\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::trait_impls_of<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"trait impls of `{}`\", tcx.item_path_str(def_id))\n@@ -497,8 +521,20 @@ impl<'tcx> QueryDescription for queries::has_clone_closures<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::vtable_methods<'tcx> {\n+    fn describe(tcx: TyCtxt, key: ty::PolyTraitRef<'tcx> ) -> String {\n+        format!(\"finding all methods for trait {}\", tcx.item_path_str(key.def_id()))\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::has_copy_closures<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"seeing if the crate has enabled `Copy` closures\")\n     }\n }\n+\n+impl<'tcx> QueryDescription for queries::fully_normalize_monormophic_ty<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: Ty) -> String {\n+        format!(\"normalizing types\")\n+    }\n+}"}, {"sha": "ee4523d6f3e1ef8b148cc4c7605a9e54cfd041f1", "filename": "src/librustc/ty/maps/keys.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -134,6 +134,24 @@ impl Key for (MirSuite, MirPassIndex, DefId) {\n     }\n }\n \n+impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.1.def_id().krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(self.1.def_id())\n+    }\n+}\n+\n+impl<'tcx> Key for ty::PolyTraitRef<'tcx>{\n+    fn map_crate(&self) -> CrateNum {\n+        self.def_id().krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(self.def_id())\n+    }\n+}\n+\n impl<'tcx> Key for Ty<'tcx> {\n     fn map_crate(&self) -> CrateNum {\n         LOCAL_CRATE"}, {"sha": "851d126056c953426d99a43b8208ca10875a4320", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -15,6 +15,7 @@ use hir::def::{Def, Export};\n use hir::{self, TraitCandidate, ItemLocalId};\n use hir::svh::Svh;\n use lint;\n+use middle::borrowck::BorrowCheckResult;\n use middle::const_val;\n use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary,\n                      ExternBodyNestedBodies};\n@@ -30,12 +31,13 @@ use middle::trans::{CodegenUnit, Stats};\n use mir;\n use session::CompileResult;\n use session::config::OutputFilenames;\n+use traits::Vtable;\n use traits::specialization_graph;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use ty::layout::{Layout, LayoutError};\n use ty::steal::Steal;\n use ty::subst::Substs;\n-use util::nodemap::{DefIdSet, DefIdMap};\n+use util::nodemap::{DefIdSet, DefIdMap, ItemLocalMap};\n use util::common::{profq_msg, ProfileQueriesMsg};\n \n use rustc_data_structures::indexed_set::IdxSetBuf;\n@@ -119,6 +121,9 @@ define_maps! { <'tcx>\n     /// (inferred) variance.\n     [] fn variances_of: ItemVariances(DefId) -> Rc<Vec<ty::Variance>>,\n \n+    /// Maps from def-id of a type to its (inferred) outlives.\n+    [] fn inferred_outlives_of: InferredOutlivesOf(DefId) -> Vec<ty::Predicate<'tcx>>,\n+\n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n     [] fn associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n \n@@ -178,11 +183,13 @@ define_maps! { <'tcx>\n \n     [] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n \n+    [] fn used_trait_imports: UsedTraitImports(DefId) -> Rc<DefIdSet>,\n+\n     [] fn has_typeck_tables: HasTypeckTables(DefId) -> bool,\n \n     [] fn coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n-    [] fn borrowck: BorrowCheck(DefId) -> (),\n+    [] fn borrowck: BorrowCheck(DefId) -> Rc<BorrowCheckResult>,\n     // FIXME: shouldn't this return a `Result<(), BorrowckErrors>` instead?\n     [] fn mir_borrowck: MirBorrowCheck(DefId) -> (),\n \n@@ -226,8 +233,13 @@ define_maps! { <'tcx>\n     [] fn is_exported_symbol: IsExportedSymbol(DefId) -> bool,\n     [] fn item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> ExternBodyNestedBodies,\n     [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n+    [] fn rvalue_promotable_map: RvaluePromotableMap(DefId) -> Rc<ItemLocalMap<bool>>,\n     [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n+    [] fn vtable_methods: vtable_methods_node(ty::PolyTraitRef<'tcx>)\n+                          -> Rc<Vec<Option<(DefId, &'tcx Substs<'tcx>)>>>,\n \n+    [] fn trans_fulfill_obligation: fulfill_obligation_dep_node(\n+        (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Vtable<'tcx, ()>,\n     [] fn trait_impls_of: TraitImpls(DefId) -> Rc<ty::trait_def::TraitImpls>,\n     [] fn specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n     [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n@@ -334,19 +346,37 @@ define_maps! { <'tcx>\n \n     [] fn has_copy_closures: HasCopyClosures(CrateNum) -> bool,\n     [] fn has_clone_closures: HasCloneClosures(CrateNum) -> bool,\n+\n+    // Erases regions from `ty` to yield a new type.\n+    // Normally you would just use `tcx.erase_regions(&value)`,\n+    // however, which uses this query as a kind of cache.\n+    [] fn erase_regions_ty: erase_regions_ty(Ty<'tcx>) -> Ty<'tcx>,\n+    [] fn fully_normalize_monormophic_ty: normalize_ty_node(Ty<'tcx>) -> Ty<'tcx>,\n }\n \n //////////////////////////////////////////////////////////////////////\n // These functions are little shims used to find the dep-node for a\n // given query when there is not a *direct* mapping:\n \n+fn erase_regions_ty<'tcx>(ty: Ty<'tcx>) -> DepConstructor<'tcx> {\n+    DepConstructor::EraseRegionsTy { ty }\n+}\n+\n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n     DepConstructor::TypeParamPredicates {\n         item_id,\n         param_id\n     }\n }\n \n+fn fulfill_obligation_dep_node<'tcx>((param_env, trait_ref):\n+    (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> DepConstructor<'tcx> {\n+    DepConstructor::FulfillObligation {\n+        param_env,\n+        trait_ref\n+    }\n+}\n+\n fn coherent_trait_dep_node<'tcx>((_, def_id): (CrateNum, DefId)) -> DepConstructor<'tcx> {\n     DepConstructor::CoherenceCheckTrait(def_id)\n }\n@@ -459,3 +489,10 @@ fn collect_and_partition_translation_items_node<'tcx>(_: CrateNum) -> DepConstru\n fn output_filenames_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::OutputFilenames\n }\n+\n+fn vtable_methods_node<'tcx>(trait_ref: ty::PolyTraitRef<'tcx>) -> DepConstructor<'tcx> {\n+    DepConstructor::VtableMethods{ trait_ref }\n+}\n+fn normalize_ty_node<'tcx>(_: Ty<'tcx>) -> DepConstructor<'tcx> {\n+    DepConstructor::NormalizeTy\n+}"}, {"sha": "7edad824cdcc1e071863664b71e1badb0f849f5f", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 118, "deletions": 122, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -12,7 +12,7 @@\n //! that generate the actual methods on tcx which find and execute the\n //! provider, manage the caches, and so forth.\n \n-use dep_graph::{DepNodeIndex, DepNode, DepKind};\n+use dep_graph::{DepNodeIndex, DepNode, DepKind, DepNodeColor};\n use errors::{Diagnostic, DiagnosticBuilder};\n use ty::{TyCtxt};\n use ty::maps::Query; // NB: actually generated by the macros in this file\n@@ -133,6 +133,40 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         Ok(result)\n     }\n+\n+    /// Try to read a node index for the node dep_node.\n+    /// A node will have an index, when it's already been marked green, or when we can mark it\n+    /// green. This function will mark the current task as a reader of the specified node, when\n+    /// the a node index can be found for that node.\n+    pub(super) fn try_mark_green_and_read(self, dep_node: &DepNode) -> Option<DepNodeIndex> {\n+        match self.dep_graph.node_color(dep_node) {\n+            Some(DepNodeColor::Green(dep_node_index)) => {\n+                self.dep_graph.read_index(dep_node_index);\n+                Some(dep_node_index)\n+            }\n+            Some(DepNodeColor::Red) => {\n+                None\n+            }\n+            None => {\n+                // try_mark_green (called below) will panic when full incremental\n+                // compilation is disabled. If that's the case, we can't try to mark nodes\n+                // as green anyway, so we can safely return None here.\n+                if !self.dep_graph.is_fully_enabled() {\n+                    return None;\n+                }\n+                match self.dep_graph.try_mark_green(self, &dep_node) {\n+                    Some(dep_node_index) => {\n+                        debug_assert!(self.dep_graph.is_green(dep_node_index));\n+                        self.dep_graph.read_index(dep_node_index);\n+                        Some(dep_node_index)\n+                    }\n+                    None => {\n+                        None\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n // If enabled, send a message to the profile-queries thread\n@@ -309,25 +343,8 @@ macro_rules! define_maps {\n                 }\n \n                 if !dep_node.kind.is_input() {\n-                    use dep_graph::DepNodeColor;\n-                    if let Some(DepNodeColor::Green(dep_node_index)) = tcx.dep_graph\n-                                                                          .node_color(&dep_node) {\n+                    if let Some(dep_node_index) = tcx.try_mark_green_and_read(&dep_node) {\n                         profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                        tcx.dep_graph.read_index(dep_node_index);\n-                        return Self::load_from_disk_and_cache_in_memory(tcx,\n-                                                                        key,\n-                                                                        span,\n-                                                                        dep_node_index)\n-                    }\n-\n-                    debug!(\"ty::queries::{}::try_get_with(key={:?}) - running try_mark_green\",\n-                           stringify!($name),\n-                           key);\n-\n-                    if let Some(dep_node_index) = tcx.dep_graph.try_mark_green(tcx, &dep_node) {\n-                        debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n-                        profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                        tcx.dep_graph.read_index(dep_node_index);\n                         return Self::load_from_disk_and_cache_in_memory(tcx,\n                                                                         key,\n                                                                         span,\n@@ -344,6 +361,30 @@ macro_rules! define_maps {\n                 }\n             }\n \n+            /// Ensure that either this query has all green inputs or been executed.\n+            /// Executing query::ensure(D) is considered a read of the dep-node D.\n+            ///\n+            /// This function is particularly useful when executing passes for their\n+            /// side-effects -- e.g., in order to report errors for erroneous programs.\n+            ///\n+            /// Note: The optimization is only available during incr. comp.\n+            pub fn ensure(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> () {\n+                let dep_node = Self::to_dep_node(tcx, &key);\n+\n+                // Ensuring an \"input\" or anonymous query makes no sense\n+                assert!(!dep_node.kind.is_anon());\n+                assert!(!dep_node.kind.is_input());\n+                if tcx.try_mark_green_and_read(&dep_node).is_none() {\n+                    // A None return from `try_mark_green_and_read` means that this is either\n+                    // a new dep node or that the dep node has already been marked red.\n+                    // Either way, we can't call `dep_graph.read()` as we don't have the\n+                    // DepNodeIndex. We must invoke the query itself. The performance cost\n+                    // this introduces should be negligible as we'll immediately hit the\n+                    // in-memory cache, or another query down the line will.\n+                    let _ = tcx.$name(key);\n+                }\n+            }\n+\n             fn compute_result(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> $V {\n                 let provider = tcx.maps.providers[key.map_crate()].$name;\n                 provider(tcx.global_tcx(), key)\n@@ -468,8 +509,7 @@ macro_rules! define_maps {\n \n         define_provider_struct! {\n             tcx: $tcx,\n-            input: ($(([$($modifiers)*] [$name] [$K] [$V]))*),\n-            output: ()\n+            input: ($(([$($modifiers)*] [$name] [$K] [$V]))*)\n         }\n \n         impl<$tcx> Copy for Providers<$tcx> {}\n@@ -480,78 +520,19 @@ macro_rules! define_maps {\n }\n \n macro_rules! define_map_struct {\n-    // Initial state\n-    (tcx: $tcx:tt,\n-     input: $input:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ()\n-        }\n-    };\n-\n-    // Final output\n     (tcx: $tcx:tt,\n-     input: (),\n-     output: ($($output:tt)*)) => {\n+     input: ($(([$(modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n         pub struct Maps<$tcx> {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n             query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n-            $($output)*\n-        }\n-    };\n-\n-    // Field recognized and ready to shift into the output\n-    (tcx: $tcx:tt,\n-     ready: ([$($pub:tt)*] [$($attr:tt)*] [$name:ident]),\n-     input: $input:tt,\n-     output: ($($output:tt)*)) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ($($output)*\n-                     $(#[$attr])* $($pub)* $name: RefCell<QueryMap<queries::$name<$tcx>>>,)\n-        }\n-    };\n-\n-    // No modifiers left? This is a private item.\n-    (tcx: $tcx:tt,\n-     input: (([] $attrs:tt $name:tt) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            ready: ([] $attrs $name),\n-            input: ($($input)*),\n-            output: $output\n-        }\n-    };\n-\n-    // Skip other modifiers\n-    (tcx: $tcx:tt,\n-     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            input: (([$($modifiers)*] $($fields)*) $($input)*),\n-            output: $output\n+            $($(#[$attr])*  $name: RefCell<QueryMap<queries::$name<$tcx>>>,)*\n         }\n     };\n }\n \n macro_rules! define_provider_struct {\n-    // Initial state:\n-    (tcx: $tcx:tt, input: $input:tt) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ()\n-        }\n-    };\n-\n-    // Final state:\n     (tcx: $tcx:tt,\n-     input: (),\n-     output: ($(([$name:ident] [$K:ty] [$R:ty]))*)) => {\n+     input: ($(([$($modifiers:tt)*] [$name:ident] [$K:ty] [$R:ty]))*)) => {\n         pub struct Providers<$tcx> {\n             $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $R,)*\n         }\n@@ -566,43 +547,51 @@ macro_rules! define_provider_struct {\n             }\n         }\n     };\n-\n-    // Something ready to shift:\n-    (tcx: $tcx:tt,\n-     ready: ($name:tt $K:tt $V:tt),\n-     input: $input:tt,\n-     output: ($($output:tt)*)) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ($($output)* ($name $K $V))\n-        }\n-    };\n-\n-    // Regular queries produce a `V` only.\n-    (tcx: $tcx:tt,\n-     input: (([] $name:tt $K:tt $V:tt) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            ready: ($name $K $V),\n-            input: ($($input)*),\n-            output: $output\n-        }\n-    };\n-\n-    // Skip modifiers.\n-    (tcx: $tcx:tt,\n-     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: (([$($modifiers)*] $($fields)*) $($input)*),\n-            output: $output\n-        }\n-    };\n }\n \n+\n+/// The red/green evaluation system will try to mark a specific DepNode in the\n+/// dependency graph as green by recursively trying to mark the dependencies of\n+/// that DepNode as green. While doing so, it will sometimes encounter a DepNode\n+/// where we don't know if it is red or green and we therefore actually have\n+/// to recompute its value in order to find out. Since the only piece of\n+/// information that we have at that point is the DepNode we are trying to\n+/// re-evaluate, we need some way to re-run a query from just that. This is what\n+/// `force_from_dep_node()` implements.\n+///\n+/// In the general case, a DepNode consists of a DepKind and an opaque\n+/// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n+/// is usually constructed by computing a stable hash of the query-key that the\n+/// DepNode corresponds to. Consequently, it is not in general possible to go\n+/// back from hash to query-key (since hash functions are not reversible). For\n+/// this reason `force_from_dep_node()` is expected to fail from time to time\n+/// because we just cannot find out, from the DepNode alone, what the\n+/// corresponding query-key is and therefore cannot re-run the query.\n+///\n+/// The system deals with this case letting `try_mark_green` fail which forces\n+/// the root query to be re-evaluated.\n+///\n+/// Now, if force_from_dep_node() would always fail, it would be pretty useless.\n+/// Fortunately, we can use some contextual information that will allow us to\n+/// reconstruct query-keys for certain kinds of DepNodes. In particular, we\n+/// enforce by construction that the GUID/fingerprint of certain DepNodes is a\n+/// valid DefPathHash. Since we also always build a huge table that maps every\n+/// DefPathHash in the current codebase to the corresponding DefId, we have\n+/// everything we need to re-run the query.\n+///\n+/// Take the `mir_validated` query as an example. Like many other queries, it\n+/// just has a single parameter: the DefId of the item it will compute the\n+/// validated MIR for. Now, when we call `force_from_dep_node()` on a dep-node\n+/// with kind `MirValidated`, we know that the GUID/fingerprint of the dep-node\n+/// is actually a DefPathHash, and can therefore just look up the corresponding\n+/// DefId in `tcx.def_path_hash_to_def_id`.\n+///\n+/// When you implement a new query, it will likely have a corresponding new\n+/// DepKind, and you'll have to support it here in `force_from_dep_node()`. As\n+/// a rule of thumb, if your query takes a DefId or DefIndex as sole parameter,\n+/// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n+/// add it to the \"We don't have enough information to reconstruct...\" group in\n+/// the match below.\n pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n                                            dep_node: &DepNode)\n                                            -> bool {\n@@ -687,16 +676,16 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::Hir |\n \n         // This are anonymous nodes\n+        DepKind::TraitSelect |\n+\n+        // We don't have enough information to reconstruct the query key of\n+        // these\n         DepKind::IsCopy |\n         DepKind::IsSized |\n         DepKind::IsFreeze |\n         DepKind::NeedsDrop |\n         DepKind::Layout |\n-        DepKind::TraitSelect |\n         DepKind::ConstEval |\n-\n-        // We don't have enough information to reconstruct the query key of\n-        // these\n         DepKind::InstanceSymbolName |\n         DepKind::MirShim |\n         DepKind::BorrowCheckKrate |\n@@ -705,6 +694,10 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::TypeParamPredicates |\n         DepKind::CodegenUnit |\n         DepKind::CompileCodegenUnit |\n+        DepKind::FulfillObligation |\n+        DepKind::VtableMethods |\n+        DepKind::EraseRegionsTy |\n+        DepKind::NormalizeTy |\n \n         // These are just odd\n         DepKind::Null |\n@@ -740,6 +733,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::TypeOfItem => { force!(type_of, def_id!()); }\n         DepKind::GenericsOfItem => { force!(generics_of, def_id!()); }\n         DepKind::PredicatesOfItem => { force!(predicates_of, def_id!()); }\n+        DepKind::InferredOutlivesOf => { force!(inferred_outlives_of, def_id!()); }\n         DepKind::SuperPredicatesOfItem => { force!(super_predicates_of, def_id!()); }\n         DepKind::TraitDefOfItem => { force!(trait_def, def_id!()); }\n         DepKind::AdtDefOfItem => { force!(adt_def, def_id!()); }\n@@ -760,6 +754,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::InherentImpls => { force!(inherent_impls, def_id!()); }\n         DepKind::TypeckBodiesKrate => { force!(typeck_item_bodies, LOCAL_CRATE); }\n         DepKind::TypeckTables => { force!(typeck_tables_of, def_id!()); }\n+        DepKind::UsedTraitImports => { force!(used_trait_imports, def_id!()); }\n         DepKind::HasTypeckTables => { force!(has_typeck_tables, def_id!()); }\n         DepKind::SymbolName => { force!(def_symbol_name, def_id!()); }\n         DepKind::SpecializationGraph => { force!(specialization_graph_of, def_id!()); }\n@@ -777,6 +772,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::ConstIsRvaluePromotableToStatic => {\n             force!(const_is_rvalue_promotable_to_static, def_id!());\n         }\n+        DepKind::RvaluePromotableMap => { force!(rvalue_promotable_map, def_id!()); }\n         DepKind::ImplParent => { force!(impl_parent, def_id!()); }\n         DepKind::TraitOfItem => { force!(trait_of_item, def_id!()); }\n         DepKind::IsExportedSymbol => { force!(is_exported_symbol, def_id!()); }"}, {"sha": "129c81c5cd61f75cc0c96b628c324c5b44085973", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -18,6 +18,7 @@ pub use self::fold::TypeFoldable;\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use hir::map::DefPathData;\n use ich::StableHashingContext;\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n@@ -89,6 +90,7 @@ pub mod adjustment;\n pub mod binding;\n pub mod cast;\n pub mod error;\n+mod erase_regions;\n pub mod fast_reject;\n pub mod fold;\n pub mod inhabitedness;\n@@ -2232,6 +2234,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Given a `VariantDef`, returns the def-id of the `AdtDef` of which it is a part.\n+    pub fn adt_def_id_of_variant(self, variant_def: &'tcx VariantDef) -> DefId {\n+        let def_key = self.def_key(variant_def.did);\n+        match def_key.disambiguated_data.data {\n+            // for enum variants and tuple structs, the def-id of the ADT itself\n+            // is the *parent* of the variant\n+            DefPathData::EnumVariant(..) | DefPathData::StructCtor =>\n+                DefId { krate: variant_def.did.krate, index: def_key.parent.unwrap() },\n+\n+            // otherwise, for structs and unions, they share a def-id\n+            _ => variant_def.did,\n+        }\n+    }\n+\n     pub fn item_name(self, id: DefId) -> InternedString {\n         if let Some(id) = self.hir.as_local_node_id(id) {\n             self.hir.name(id).as_str()\n@@ -2560,6 +2576,7 @@ fn original_crate_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn provide(providers: &mut ty::maps::Providers) {\n     util::provide(providers);\n     context::provide(providers);\n+    erase_regions::provide(providers);\n     *providers = ty::maps::Providers {\n         associated_item,\n         associated_item_def_ids,"}, {"sha": "5e1dc485d420f7ba8505511982b925cf00d57e61", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -73,42 +73,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // projection).\n         match ty.sty {\n             ty::TyClosure(def_id, ref substs) => {\n-                // FIXME(#27086). We do not accumulate from substs, since they\n-                // don't represent reachable data. This means that, in\n-                // practice, some of the lifetime parameters might not\n-                // be in scope when the body runs, so long as there is\n-                // no reachable data with that lifetime. For better or\n-                // worse, this is consistent with fn types, however,\n-                // which can also encapsulate data in this fashion\n-                // (though it's somewhat harder, and typically\n-                // requires virtual dispatch).\n-                //\n-                // Note that changing this (in a naive way, at least)\n-                // causes regressions for what appears to be perfectly\n-                // reasonable code like this:\n-                //\n-                // ```\n-                // fn foo<'a>(p: &Data<'a>) {\n-                //    bar(|q: &mut Parser| q.read_addr())\n-                // }\n-                // fn bar(p: Box<FnMut(&mut Parser)+'static>) {\n-                // }\n-                // ```\n-                //\n-                // Note that `p` (and `'a`) are not used in the\n-                // closure at all, but to meet the requirement that\n-                // the closure type `C: 'static` (so it can be coerced\n-                // to the object type), we get the requirement that\n-                // `'a: 'static` since `'a` appears in the closure\n-                // type `C`.\n-                //\n-                // A smarter fix might \"prune\" unused `func_substs` --\n-                // this would avoid breaking simple examples like\n-                // this, but would still break others (which might\n-                // indeed be invalid, depending on your POV). Pruning\n-                // would be a subtle process, since we have to see\n-                // what func/type parameters are used and unused,\n-                // taking into consideration UFCS and so forth.\n \n                 for upvar_ty in substs.upvar_tys(def_id, *self) {\n                     self.compute_components(upvar_ty, out);"}, {"sha": "064627c21bfe64f98cd2e0323e990b2bf5655994", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -24,7 +24,6 @@ use std::cmp::Ordering;\n use syntax::abi;\n use syntax::ast::{self, Name};\n use syntax::symbol::keywords;\n-use util::nodemap::FxHashMap;\n \n use serialize;\n \n@@ -1070,54 +1069,6 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Checks whether a type is visibly uninhabited from a particular module.\n-    /// # Example\n-    /// ```rust\n-    /// enum Void {}\n-    /// mod a {\n-    ///     pub mod b {\n-    ///         pub struct SecretlyUninhabited {\n-    ///             _priv: !,\n-    ///         }\n-    ///     }\n-    /// }\n-    ///\n-    /// mod c {\n-    ///     pub struct AlsoSecretlyUninhabited {\n-    ///         _priv: Void,\n-    ///     }\n-    ///     mod d {\n-    ///     }\n-    /// }\n-    ///\n-    /// struct Foo {\n-    ///     x: a::b::SecretlyUninhabited,\n-    ///     y: c::AlsoSecretlyUninhabited,\n-    /// }\n-    /// ```\n-    /// In this code, the type `Foo` will only be visibly uninhabited inside the\n-    /// modules b, c and d. This effects pattern-matching on `Foo` or types that\n-    /// contain `Foo`.\n-    ///\n-    /// # Example\n-    /// ```rust\n-    /// let foo_result: Result<T, Foo> = ... ;\n-    /// let Ok(t) = foo_result;\n-    /// ```\n-    /// This code should only compile in modules where the uninhabitedness of Foo is\n-    /// visible.\n-    pub fn is_uninhabited_from(&self, module: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        let mut visited = FxHashMap::default();\n-        let forest = self.uninhabited_from(&mut visited, tcx);\n-\n-        // To check whether this type is uninhabited at all (not just from the\n-        // given node) you could check whether the forest is empty.\n-        // ```\n-        // forest.is_empty()\n-        // ```\n-        forest.contains(tcx, module)\n-    }\n-\n     pub fn is_primitive(&self) -> bool {\n         match self.sty {\n             TyBool | TyChar | TyInt(_) | TyUint(_) | TyFloat(_) => true,"}, {"sha": "0eb2c19fe44ddeb72a2013ce0e79638691e64a39", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 989, "deletions": 768, "changes": 1757, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -20,6 +20,7 @@ use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n use ty::{TyClosure, TyGenerator, TyProjection, TyAnon};\n use ty::{TyDynamic, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use util::nodemap::FxHashSet;\n \n use std::cell::Cell;\n use std::fmt;\n@@ -32,310 +33,543 @@ use syntax::ast::CRATE_NODE_ID;\n use syntax::symbol::Symbol;\n use hir;\n \n-pub fn verbose() -> bool {\n-    ty::tls::with(|tcx| tcx.sess.verbose())\n+macro_rules! gen_display_debug_body {\n+    ( $with:path ) => {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            let mut cx = PrintContext::new();\n+            $with(self, f, &mut cx)\n+        }\n+    };\n }\n-\n-pub fn identify_regions() -> bool {\n-    ty::tls::with(|tcx| tcx.sess.opts.debugging_opts.identify_regions)\n+macro_rules! gen_display_debug {\n+    ( ($($x:tt)+) $target:ty, display yes ) => {\n+        impl<$($x)+> fmt::Display for $target {\n+            gen_display_debug_body! { Print::print_display }\n+        }\n+    };\n+    ( () $target:ty, display yes ) => {\n+        impl fmt::Display for $target {\n+            gen_display_debug_body! { Print::print_display }\n+        }\n+    };\n+    ( ($($x:tt)+) $target:ty, debug yes ) => {\n+        impl<$($x)+> fmt::Debug for $target {\n+            gen_display_debug_body! { Print::print_debug }\n+        }\n+    };\n+    ( () $target:ty, debug yes ) => {\n+        impl fmt::Debug for $target {\n+            gen_display_debug_body! { Print::print_debug }\n+        }\n+    };\n+    ( $generic:tt $target:ty, $t:ident no ) => {};\n }\n-\n-fn fn_sig(f: &mut fmt::Formatter,\n-          inputs: &[Ty],\n-          variadic: bool,\n-          output: Ty)\n-          -> fmt::Result {\n-    write!(f, \"(\")?;\n-    let mut inputs = inputs.iter();\n-    if let Some(&ty) = inputs.next() {\n-        write!(f, \"{}\", ty)?;\n-        for &ty in inputs {\n-            write!(f, \", {}\", ty)?;\n+macro_rules! gen_print_impl {\n+    ( ($($x:tt)+) $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n+        impl<$($x)+> Print for $target {\n+            fn print<F: fmt::Write>(&$self, $f: &mut F, $cx: &mut PrintContext) -> fmt::Result {\n+                if $cx.is_debug $dbg\n+                else $disp\n+            }\n         }\n-        if variadic {\n-            write!(f, \", ...\")?;\n+    };\n+    ( () $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n+        impl Print for $target {\n+            fn print<F: fmt::Write>(&$self, $f: &mut F, $cx: &mut PrintContext) -> fmt::Result {\n+                if $cx.is_debug $dbg\n+                else $disp\n+            }\n         }\n+    };\n+    ( $generic:tt $target:ty,\n+      $vars:tt $gendisp:ident $disp:block $gendbg:ident $dbg:block ) => {\n+        gen_print_impl! { $generic $target, $vars $disp $dbg }\n+        gen_display_debug! { $generic $target, display $gendisp }\n+        gen_display_debug! { $generic $target, debug $gendbg }\n     }\n-    write!(f, \")\")?;\n-    if !output.is_nil() {\n-        write!(f, \" -> {}\", output)?;\n+}\n+macro_rules! define_print {\n+    ( $generic:tt $target:ty,\n+      $vars:tt { display $disp:block debug $dbg:block } ) => {\n+        gen_print_impl! { $generic $target, $vars yes $disp yes $dbg }\n+    };\n+    ( $generic:tt $target:ty,\n+      $vars:tt { debug $dbg:block display $disp:block } ) => {\n+        gen_print_impl! { $generic $target, $vars yes $disp yes $dbg }\n+    };\n+    ( $generic:tt $target:ty,\n+      $vars:tt { debug $dbg:block } ) => {\n+        gen_print_impl! { $generic $target, $vars no {\n+            bug!(concat!(\"display not implemented for \", stringify!($target)));\n+        } yes $dbg }\n+    };\n+    ( $generic:tt $target:ty,\n+      ($self:ident, $f:ident, $cx:ident) { display $disp:block } ) => {\n+        gen_print_impl! { $generic $target, ($self, $f, $cx) yes $disp no {\n+            write!($f, \"{:?}\", $self)\n+        } }\n+    };\n+}\n+macro_rules! define_print_multi {\n+    ( [ $($generic:tt $target:ty),* ] $vars:tt $def:tt ) => {\n+        $(define_print! { $generic $target, $vars $def })*\n+    };\n+}\n+macro_rules! print_inner {\n+    ( $f:expr, $cx:expr, write ($($data:expr),+) ) => {\n+        write!($f, $($data),+)\n+    };\n+    ( $f:expr, $cx:expr, $kind:ident ($data:expr) ) => {\n+        $data.$kind($f, $cx)\n+    };\n+}\n+macro_rules! print {\n+    ( $f:expr, $cx:expr $(, $kind:ident $data:tt)+ ) => {\n+        Ok(())$(.and_then(|_| print_inner!($f, $cx, $kind $data)))+\n+    };\n+}\n+\n+\n+struct LateBoundRegionNameCollector(FxHashSet<Symbol>);\n+impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        match *r {\n+            ty::ReLateBound(_, ty::BrNamed(_, name)) => {\n+                self.0.insert(name);\n+            },\n+            _ => {},\n+        }\n+        r.super_visit_with(self)\n     }\n+}\n \n-    Ok(())\n+#[derive(Debug)]\n+pub struct PrintContext {\n+    is_debug: bool,\n+    is_verbose: bool,\n+    identify_regions: bool,\n+    used_region_names: Option<FxHashSet<Symbol>>,\n+    region_index: usize,\n+    binder_depth: usize,\n+}\n+impl PrintContext {\n+    fn new() -> Self {\n+        ty::tls::with_opt(|tcx| {\n+            let (is_verbose, identify_regions) = tcx.map(\n+                |tcx| (tcx.sess.verbose(), tcx.sess.opts.debugging_opts.identify_regions)\n+            ).unwrap_or((false, false));\n+            PrintContext {\n+                is_debug: false,\n+                is_verbose: is_verbose,\n+                identify_regions: identify_regions,\n+                used_region_names: None,\n+                region_index: 0,\n+                binder_depth: 0,\n+            }\n+        })\n+    }\n+    fn prepare_late_bound_region_info<'tcx, T>(&mut self, value: &ty::Binder<T>)\n+    where T: TypeFoldable<'tcx>\n+    {\n+        let mut collector = LateBoundRegionNameCollector(FxHashSet());\n+        value.visit_with(&mut collector);\n+        self.used_region_names = Some(collector.0);\n+        self.region_index = 0;\n+    }\n }\n \n-pub fn parameterized(f: &mut fmt::Formatter,\n-                     substs: &subst::Substs,\n-                     mut did: DefId,\n-                     projections: &[ty::ProjectionPredicate])\n-                     -> fmt::Result {\n-    let key = ty::tls::with(|tcx| tcx.def_key(did));\n-    let mut item_name = if let Some(name) = key.disambiguated_data.data.get_opt_name() {\n-        Some(name)\n-    } else {\n-        did.index = key.parent.unwrap_or_else(\n-            || bug!(\"finding type for {:?}, encountered def-id {:?} with no parent\",\n-                    did, did));\n-        parameterized(f, substs, did, projections)?;\n-        return write!(f, \"::{}\", key.disambiguated_data.data.as_interned_str());\n-    };\n+pub trait Print {\n+    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result;\n+    fn print_to_string(&self, cx: &mut PrintContext) -> String {\n+        let mut result = String::new();\n+        let _ = self.print(&mut result, cx);\n+        result\n+    }\n+    fn print_display<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n+        let old_debug = cx.is_debug;\n+        cx.is_debug = false;\n+        let result = self.print(f, cx);\n+        cx.is_debug = old_debug;\n+        result\n+    }\n+    fn print_display_to_string(&self, cx: &mut PrintContext) -> String {\n+        let mut result = String::new();\n+        let _ = self.print_display(&mut result, cx);\n+        result\n+    }\n+    fn print_debug<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n+        let old_debug = cx.is_debug;\n+        cx.is_debug = true;\n+        let result = self.print(f, cx);\n+        cx.is_debug = old_debug;\n+        result\n+    }\n+    fn print_debug_to_string(&self, cx: &mut PrintContext) -> String {\n+        let mut result = String::new();\n+        let _ = self.print_debug(&mut result, cx);\n+        result\n+    }\n+}\n \n-    let mut verbose = false;\n-    let mut num_supplied_defaults = 0;\n-    let mut has_self = false;\n-    let mut num_regions = 0;\n-    let mut num_types = 0;\n-    let mut is_value_path = false;\n-    let fn_trait_kind = ty::tls::with(|tcx| {\n-        // Unfortunately, some kinds of items (e.g., closures) don't have\n-        // generics. So walk back up the find the closest parent that DOES\n-        // have them.\n-        let mut item_def_id = did;\n-        loop {\n-            let key = tcx.def_key(item_def_id);\n-            match key.disambiguated_data.data {\n-                DefPathData::TypeNs(_) => {\n-                    break;\n-                }\n-                DefPathData::ValueNs(_) | DefPathData::EnumVariant(_) => {\n-                    is_value_path = true;\n-                    break;\n-                }\n-                _ => {\n-                    // if we're making a symbol for something, there ought\n-                    // to be a value or type-def or something in there\n-                    // *somewhere*\n-                    item_def_id.index = key.parent.unwrap_or_else(|| {\n-                        bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                             parent\", did, item_def_id);\n-                    });\n-                }\n+impl PrintContext {\n+    fn fn_sig<F: fmt::Write>(&mut self,\n+                             f: &mut F,\n+                             inputs: &[Ty],\n+                             variadic: bool,\n+                             output: Ty)\n+                             -> fmt::Result {\n+        write!(f, \"(\")?;\n+        let mut inputs = inputs.iter();\n+        if let Some(&ty) = inputs.next() {\n+            print!(f, self, print_display(ty))?;\n+            for &ty in inputs {\n+                print!(f, self, write(\", \"), print_display(ty))?;\n+            }\n+            if variadic {\n+                write!(f, \", ...\")?;\n             }\n         }\n-        let mut generics = tcx.generics_of(item_def_id);\n-        let mut path_def_id = did;\n-        verbose = tcx.sess.verbose();\n-        has_self = generics.has_self;\n-\n-        let mut child_types = 0;\n-        if let Some(def_id) = generics.parent {\n-            // Methods.\n-            assert!(is_value_path);\n-            child_types = generics.types.len();\n-            generics = tcx.generics_of(def_id);\n-            num_regions = generics.regions.len();\n-            num_types = generics.types.len();\n+        write!(f, \")\")?;\n+        if !output.is_nil() {\n+            print!(f, self, write(\" -> \"), print_display(output))?;\n+        }\n \n-            if has_self {\n-                write!(f, \"<{} as \", substs.type_at(0))?;\n-            }\n+        Ok(())\n+    }\n \n-            path_def_id = def_id;\n+    fn parameterized<F: fmt::Write>(&mut self,\n+                                    f: &mut F,\n+                                    substs: &subst::Substs,\n+                                    mut did: DefId,\n+                                    projections: &[ty::ProjectionPredicate])\n+                                    -> fmt::Result {\n+        let key = ty::tls::with(|tcx| tcx.def_key(did));\n+        let mut item_name = if let Some(name) = key.disambiguated_data.data.get_opt_name() {\n+            Some(name)\n         } else {\n-            item_name = None;\n+            did.index = key.parent.unwrap_or_else(\n+                || bug!(\"finding type for {:?}, encountered def-id {:?} with no parent\",\n+                        did, did));\n+            self.parameterized(f, substs, did, projections)?;\n+            return write!(f, \"::{}\", key.disambiguated_data.data.as_interned_str());\n+        };\n \n-            if is_value_path {\n-                // Functions.\n-                assert_eq!(has_self, false);\n-            } else {\n-                // Types and traits.\n+        let verbose = self.is_verbose;\n+        let mut num_supplied_defaults = 0;\n+        let mut has_self = false;\n+        let mut num_regions = 0;\n+        let mut num_types = 0;\n+        let mut is_value_path = false;\n+        let fn_trait_kind = ty::tls::with(|tcx| {\n+            // Unfortunately, some kinds of items (e.g., closures) don't have\n+            // generics. So walk back up the find the closest parent that DOES\n+            // have them.\n+            let mut item_def_id = did;\n+            loop {\n+                let key = tcx.def_key(item_def_id);\n+                match key.disambiguated_data.data {\n+                    DefPathData::TypeNs(_) => {\n+                        break;\n+                    }\n+                    DefPathData::ValueNs(_) | DefPathData::EnumVariant(_) => {\n+                        is_value_path = true;\n+                        break;\n+                    }\n+                    _ => {\n+                        // if we're making a symbol for something, there ought\n+                        // to be a value or type-def or something in there\n+                        // *somewhere*\n+                        item_def_id.index = key.parent.unwrap_or_else(|| {\n+                            bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n+                                 parent\", did, item_def_id);\n+                        });\n+                    }\n+                }\n+            }\n+            let mut generics = tcx.generics_of(item_def_id);\n+            let mut path_def_id = did;\n+            has_self = generics.has_self;\n+\n+            let mut child_types = 0;\n+            if let Some(def_id) = generics.parent {\n+                // Methods.\n+                assert!(is_value_path);\n+                child_types = generics.types.len();\n+                generics = tcx.generics_of(def_id);\n                 num_regions = generics.regions.len();\n                 num_types = generics.types.len();\n+\n+                if has_self {\n+                    print!(f, self, write(\"<\"), print_display(substs.type_at(0)), write(\" as \"))?;\n+                }\n+\n+                path_def_id = def_id;\n+            } else {\n+                item_name = None;\n+\n+                if is_value_path {\n+                    // Functions.\n+                    assert_eq!(has_self, false);\n+                } else {\n+                    // Types and traits.\n+                    num_regions = generics.regions.len();\n+                    num_types = generics.types.len();\n+                }\n             }\n-        }\n \n-        if !verbose {\n-            if generics.types.last().map_or(false, |def| def.has_default) {\n-                if let Some(substs) = tcx.lift(&substs) {\n-                    let tps = substs.types().rev().skip(child_types);\n-                    for (def, actual) in generics.types.iter().rev().zip(tps) {\n-                        if !def.has_default {\n-                            break;\n-                        }\n-                        if tcx.type_of(def.def_id).subst(tcx, substs) != actual {\n-                            break;\n+            if !verbose {\n+                if generics.types.last().map_or(false, |def| def.has_default) {\n+                    if let Some(substs) = tcx.lift(&substs) {\n+                        let tps = substs.types().rev().skip(child_types);\n+                        for (def, actual) in generics.types.iter().rev().zip(tps) {\n+                            if !def.has_default {\n+                                break;\n+                            }\n+                            if tcx.type_of(def.def_id).subst(tcx, substs) != actual {\n+                                break;\n+                            }\n+                            num_supplied_defaults += 1;\n                         }\n-                        num_supplied_defaults += 1;\n                     }\n                 }\n             }\n-        }\n \n-        write!(f, \"{}\", tcx.item_path_str(path_def_id))?;\n-        Ok(tcx.lang_items().fn_trait_kind(path_def_id))\n-    })?;\n+            print!(f, self, write(\"{}\", tcx.item_path_str(path_def_id)))?;\n+            Ok(tcx.lang_items().fn_trait_kind(path_def_id))\n+        })?;\n \n-    if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n-        let projection_ty = projections[0].ty;\n-        if let TyTuple(ref args, _) = substs.type_at(1).sty {\n-            return fn_sig(f, args, false, projection_ty);\n+        if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n+            let projection_ty = projections[0].ty;\n+            if let TyTuple(ref args, _) = substs.type_at(1).sty {\n+                return self.fn_sig(f, args, false, projection_ty);\n+            }\n         }\n-    }\n \n-    let empty = Cell::new(true);\n-    let start_or_continue = |f: &mut fmt::Formatter, start: &str, cont: &str| {\n-        if empty.get() {\n-            empty.set(false);\n-            write!(f, \"{}\", start)\n-        } else {\n-            write!(f, \"{}\", cont)\n-        }\n-    };\n+        let empty = Cell::new(true);\n+        let start_or_continue = |f: &mut F, start: &str, cont: &str| {\n+            if empty.get() {\n+                empty.set(false);\n+                write!(f, \"{}\", start)\n+            } else {\n+                write!(f, \"{}\", cont)\n+            }\n+        };\n \n-    let print_regions = |f: &mut fmt::Formatter, start: &str, skip, count| {\n-        // Don't print any regions if they're all erased.\n-        let regions = || substs.regions().skip(skip).take(count);\n-        if regions().all(|r: ty::Region| *r == ty::ReErased) {\n-            return Ok(());\n-        }\n+        let print_regions = |f: &mut F, start: &str, skip, count| {\n+            // Don't print any regions if they're all erased.\n+            let regions = || substs.regions().skip(skip).take(count);\n+            if regions().all(|r: ty::Region| *r == ty::ReErased) {\n+                return Ok(());\n+            }\n \n-        for region in regions() {\n-            let region: ty::Region = region;\n-            start_or_continue(f, start, \", \")?;\n-            if verbose {\n-                write!(f, \"{:?}\", region)?;\n-            } else {\n-                let s = region.to_string();\n-                if s.is_empty() {\n-                    // This happens when the value of the region\n-                    // parameter is not easily serialized. This may be\n-                    // because the user omitted it in the first place,\n-                    // or because it refers to some block in the code,\n-                    // etc. I'm not sure how best to serialize this.\n-                    write!(f, \"'_\")?;\n+            for region in regions() {\n+                let region: ty::Region = region;\n+                start_or_continue(f, start, \", \")?;\n+                if verbose {\n+                    write!(f, \"{:?}\", region)?;\n                 } else {\n-                    write!(f, \"{}\", s)?;\n+                    let s = region.to_string();\n+                    if s.is_empty() {\n+                        // This happens when the value of the region\n+                        // parameter is not easily serialized. This may be\n+                        // because the user omitted it in the first place,\n+                        // or because it refers to some block in the code,\n+                        // etc. I'm not sure how best to serialize this.\n+                        write!(f, \"'_\")?;\n+                    } else {\n+                        write!(f, \"{}\", s)?;\n+                    }\n                 }\n             }\n+\n+            Ok(())\n+        };\n+\n+        print_regions(f, \"<\", 0, num_regions)?;\n+\n+        let tps = substs.types().take(num_types - num_supplied_defaults)\n+                                .skip(has_self as usize);\n+\n+        for ty in tps {\n+            start_or_continue(f, \"<\", \", \")?;\n+            ty.print_display(f, self)?;\n         }\n \n-        Ok(())\n-    };\n+        for projection in projections {\n+            start_or_continue(f, \"<\", \", \")?;\n+            ty::tls::with(|tcx|\n+                print!(f, self,\n+                       write(\"{}=\",\n+                             tcx.associated_item(projection.projection_ty.item_def_id).name),\n+                       print_display(projection.ty))\n+            )?;\n+        }\n \n-    print_regions(f, \"<\", 0, num_regions)?;\n+        start_or_continue(f, \"\", \">\")?;\n \n-    let tps = substs.types().take(num_types - num_supplied_defaults)\n-                            .skip(has_self as usize);\n+        // For values, also print their name and type parameters.\n+        if is_value_path {\n+            empty.set(true);\n \n-    for ty in tps {\n-        start_or_continue(f, \"<\", \", \")?;\n-        write!(f, \"{}\", ty)?;\n-    }\n+            if has_self {\n+                write!(f, \">\")?;\n+            }\n \n-    for projection in projections {\n-        start_or_continue(f, \"<\", \", \")?;\n-        ty::tls::with(|tcx|\n-            write!(f, \"{}={}\",\n-            tcx.associated_item(projection.projection_ty.item_def_id).name,\n-            projection.ty)\n-        )?;\n-    }\n+            if let Some(item_name) = item_name {\n+                write!(f, \"::{}\", item_name)?;\n+            }\n \n-    start_or_continue(f, \"\", \">\")?;\n+            print_regions(f, \"::<\", num_regions, usize::MAX)?;\n \n-    // For values, also print their name and type parameters.\n-    if is_value_path {\n-        empty.set(true);\n+            // FIXME: consider being smart with defaults here too\n+            for ty in substs.types().skip(num_types) {\n+                start_or_continue(f, \"::<\", \", \")?;\n+                ty.print_display(f, self)?;\n+            }\n \n-        if has_self {\n-            write!(f, \">\")?;\n+            start_or_continue(f, \"\", \">\")?;\n         }\n \n-        if let Some(item_name) = item_name {\n-            write!(f, \"::{}\", item_name)?;\n+        Ok(())\n+    }\n+\n+    fn in_binder<'a, 'gcx, 'tcx, T, U, F>(&mut self,\n+                                          f: &mut F,\n+                                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                          original: &ty::Binder<T>,\n+                                          lifted: Option<ty::Binder<U>>) -> fmt::Result\n+        where T: Print, U: Print + TypeFoldable<'tcx>, F: fmt::Write\n+    {\n+        fn name_by_region_index(index: usize) -> Symbol {\n+            match index {\n+                0 => Symbol::intern(\"'r\"),\n+                1 => Symbol::intern(\"'s\"),\n+                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n+            }\n         }\n \n-        print_regions(f, \"::<\", num_regions, usize::MAX)?;\n+        // Replace any anonymous late-bound regions with named\n+        // variants, using gensym'd identifiers, so that we can\n+        // clearly differentiate between named and unnamed regions in\n+        // the output. We'll probably want to tweak this over time to\n+        // decide just how much information to give.\n+        let value = if let Some(v) = lifted {\n+            v\n+        } else {\n+            return original.0.print_display(f, self);\n+        };\n \n-        // FIXME: consider being smart with defaults here too\n-        for ty in substs.types().skip(num_types) {\n-            start_or_continue(f, \"::<\", \", \")?;\n-            write!(f, \"{}\", ty)?;\n+        if self.binder_depth == 0 {\n+            self.prepare_late_bound_region_info(&value);\n         }\n \n-        start_or_continue(f, \"\", \">\")?;\n+        let mut empty = true;\n+        let mut start_or_continue = |f: &mut F, start: &str, cont: &str| {\n+            if empty {\n+                empty = false;\n+                write!(f, \"{}\", start)\n+            } else {\n+                write!(f, \"{}\", cont)\n+            }\n+        };\n+\n+        let old_region_index = self.region_index;\n+        let mut region_index = old_region_index;\n+        let new_value = tcx.replace_late_bound_regions(&value, |br| {\n+            let _ = start_or_continue(f, \"for<\", \", \");\n+            let br = match br {\n+                ty::BrNamed(_, name) => {\n+                    let _ = write!(f, \"{}\", name);\n+                    br\n+                }\n+                ty::BrAnon(_) |\n+                ty::BrFresh(_) |\n+                ty::BrEnv => {\n+                    let name = loop {\n+                        let name = name_by_region_index(region_index);\n+                        region_index += 1;\n+                        if !self.is_name_used(&name) {\n+                            break name;\n+                        }\n+                    };\n+                    let _ = write!(f, \"{}\", name);\n+                    ty::BrNamed(tcx.hir.local_def_id(CRATE_NODE_ID),\n+                                name)\n+                }\n+            };\n+            tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), br))\n+        }).0;\n+        start_or_continue(f, \"\", \"> \")?;\n+\n+        // Push current state to gcx, and restore after writing new_value.\n+        self.binder_depth += 1;\n+        self.region_index = region_index;\n+        let result = new_value.print_display(f, self);\n+        self.region_index = old_region_index;\n+        self.binder_depth -= 1;\n+        result\n     }\n \n-    Ok(())\n+    fn is_name_used(&self, name: &Symbol) -> bool {\n+        match self.used_region_names {\n+            Some(ref names) => names.contains(name),\n+            None => false,\n+        }\n+    }\n }\n \n-fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n-                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                   original: &ty::Binder<T>,\n-                                   lifted: Option<ty::Binder<U>>) -> fmt::Result\n-    where T: fmt::Display, U: fmt::Display + TypeFoldable<'tcx>\n-{\n-    // Replace any anonymous late-bound regions with named\n-    // variants, using gensym'd identifiers, so that we can\n-    // clearly differentiate between named and unnamed regions in\n-    // the output. We'll probably want to tweak this over time to\n-    // decide just how much information to give.\n-    let value = if let Some(v) = lifted {\n-        v\n-    } else {\n-        return write!(f, \"{}\", original.0);\n-    };\n+pub fn verbose() -> bool {\n+    ty::tls::with(|tcx| tcx.sess.verbose())\n+}\n \n-    let mut empty = true;\n-    let mut start_or_continue = |f: &mut fmt::Formatter, start: &str, cont: &str| {\n-        if empty {\n-            empty = false;\n-            write!(f, \"{}\", start)\n-        } else {\n-            write!(f, \"{}\", cont)\n-        }\n-    };\n+pub fn identify_regions() -> bool {\n+    ty::tls::with(|tcx| tcx.sess.opts.debugging_opts.identify_regions)\n+}\n \n-    let new_value = tcx.replace_late_bound_regions(&value, |br| {\n-        let _ = start_or_continue(f, \"for<\", \", \");\n-        let br = match br {\n-            ty::BrNamed(_, name) => {\n-                let _ = write!(f, \"{}\", name);\n-                br\n-            }\n-            ty::BrAnon(_) |\n-            ty::BrFresh(_) |\n-            ty::BrEnv => {\n-                let name = Symbol::intern(\"'r\");\n-                let _ = write!(f, \"{}\", name);\n-                ty::BrNamed(tcx.hir.local_def_id(CRATE_NODE_ID),\n-                            name)\n-            }\n-        };\n-        tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), br))\n-    }).0;\n+pub fn parameterized<F: fmt::Write>(f: &mut F,\n+                                    substs: &subst::Substs,\n+                                    did: DefId,\n+                                    projections: &[ty::ProjectionPredicate])\n+                                    -> fmt::Result {\n+    PrintContext::new().parameterized(f, substs, did, projections)\n+}\n \n-    start_or_continue(f, \"\", \"> \")?;\n-    write!(f, \"{}\", new_value)\n+\n+impl<'a, T: Print> Print for &'a T {\n+    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n+        (*self).print(f, cx)\n+    }\n }\n \n-impl<'tcx> fmt::Display for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // Generate the main trait ref, including associated types.\n-        ty::tls::with(|tcx| {\n-            // Use a type that can't appear in defaults of type parameters.\n-            let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n-\n-            if let Some(p) = self.principal() {\n-                let principal = tcx.lift(&p).expect(\"could not lift TraitRef for printing\")\n-                    .with_self_ty(tcx, dummy_self);\n-                let projections = self.projection_bounds().map(|p| {\n-                    tcx.lift(&p)\n-                        .expect(\"could not lift projection for printing\")\n-                        .with_self_ty(tcx, dummy_self)\n-                }).collect::<Vec<_>>();\n-                parameterized(f, principal.substs, principal.def_id, &projections)?;\n-            }\n+define_print! {\n+    ('tcx) &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, (self, f, cx) {\n+        display {\n+            // Generate the main trait ref, including associated types.\n+            ty::tls::with(|tcx| {\n+                // Use a type that can't appear in defaults of type parameters.\n+                let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n+\n+                if let Some(p) = self.principal() {\n+                    let principal = tcx.lift(&p).expect(\"could not lift TraitRef for printing\")\n+                        .with_self_ty(tcx, dummy_self);\n+                    let projections = self.projection_bounds().map(|p| {\n+                        tcx.lift(&p)\n+                            .expect(\"could not lift projection for printing\")\n+                            .with_self_ty(tcx, dummy_self)\n+                    }).collect::<Vec<_>>();\n+                    cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n+                }\n \n-            // Builtin bounds.\n-            for did in self.auto_traits() {\n-                write!(f, \" + {}\", tcx.item_path_str(did))?;\n-            }\n+                // Builtin bounds.\n+                for did in self.auto_traits() {\n+                    write!(f, \" + {}\", tcx.item_path_str(did))?;\n+                }\n \n-            Ok(())\n-        })?;\n+                Ok(())\n+            })?;\n \n-        Ok(())\n+            Ok(())\n+        }\n     }\n }\n \n@@ -357,42 +591,6 @@ impl fmt::Debug for ty::RegionParameterDef {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TyS<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", *self)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::TypeAndMut<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}{}\",\n-               if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" },\n-               self.ty)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::TraitRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // when printing out the debug representation, we don't need\n-        // to enumerate the `for<...>` etc because the debruijn index\n-        // tells you everything you need to know.\n-        write!(f, \"<{:?} as {}>\", self.self_ty(), *self)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| {\n-            let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n-\n-            let trait_ref = tcx.lift(&ty::Binder(*self))\n-                               .expect(\"could not lift TraitRef for printing\")\n-                               .with_self_ty(tcx, dummy_self).0;\n-            parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n-        })\n-    }\n-}\n-\n impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| {\n@@ -409,196 +607,226 @@ impl fmt::Debug for ty::AdtDef {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n+impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:?} -> {}\", self.kind, self.target)\n+        write!(f, \"ClosureUpvar({:?},{:?})\",\n+               self.def,\n+               self.ty)\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n+impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::Predicate::Trait(ref a) => write!(f, \"{:?}\", a),\n-            ty::Predicate::Equate(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::Subtype(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::RegionOutlives(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::TypeOutlives(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::Projection(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::WellFormed(ty) => write!(f, \"WF({:?})\", ty),\n-            ty::Predicate::ObjectSafe(trait_def_id) => {\n-                write!(f, \"ObjectSafe({:?})\", trait_def_id)\n-            }\n-            ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-                write!(f, \"ClosureKind({:?}, {:?})\", closure_def_id, kind)\n-            }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n-            }\n-        }\n+        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n+               self.var_id,\n+               ty::tls::with(|tcx| tcx.hir.name(tcx.hir.hir_to_node_id(self.var_id))),\n+               self.closure_expr_id)\n     }\n }\n \n-impl fmt::Display for ty::BoundRegion {\n+impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if verbose() {\n-            return write!(f, \"{:?}\", *self);\n+        write!(f, \"UpvarBorrow({:?}, {:?})\",\n+               self.kind, self.region)\n+    }\n+}\n+\n+define_print! {\n+    ('tcx) ty::TypeAndMut<'tcx>, (self, f, cx) {\n+        display {\n+            print!(f, cx,\n+                   write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n+                   print(self.ty))\n         }\n+    }\n+}\n \n-        match *self {\n-            BrNamed(_, name) => write!(f, \"{}\", name),\n-            BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n+define_print! {\n+    ('tcx) ty::ExistentialTraitRef<'tcx>, (self, f, cx) {\n+        debug {\n+            ty::tls::with(|tcx| {\n+                let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n+\n+                let trait_ref = tcx.lift(&ty::Binder(*self))\n+                                   .expect(\"could not lift TraitRef for printing\")\n+                                   .with_self_ty(tcx, dummy_self).0;\n+                cx.parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n+            })\n         }\n     }\n }\n \n-impl fmt::Debug for ty::BoundRegion {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n-            BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n-            BrNamed(did, name) => {\n-                write!(f, \"BrNamed({:?}:{:?}, {:?})\",\n-                       did.krate, did.index, name)\n-            }\n-            BrEnv => \"BrEnv\".fmt(f),\n+define_print! {\n+    ('tcx) ty::adjustment::Adjustment<'tcx>, (self, f, cx) {\n+        debug {\n+            print!(f, cx, write(\"{:?} -> \", self.kind), print(self.target))\n         }\n     }\n }\n \n-impl fmt::Debug for ty::RegionKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::ReEarlyBound(ref data) => {\n-                write!(f, \"ReEarlyBound({}, {})\",\n-                       data.index,\n-                       data.name)\n+define_print! {\n+    () ty::BoundRegion, (self, f, cx) {\n+        display {\n+            if cx.is_verbose {\n+                return self.print_debug(f, cx);\n             }\n \n-            ty::ReLateBound(binder_id, ref bound_region) => {\n-                write!(f, \"ReLateBound({:?}, {:?})\",\n-                       binder_id,\n-                       bound_region)\n+            match *self {\n+                BrNamed(_, name) => write!(f, \"{}\", name),\n+                BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n             }\n+        }\n+        debug {\n+            return match *self {\n+                BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n+                BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n+                BrNamed(did, name) => {\n+                    write!(f, \"BrNamed({:?}:{:?}, {:?})\",\n+                           did.krate, did.index, name)\n+                }\n+                BrEnv => write!(f, \"BrEnv\"),\n+            };\n+        }\n+    }\n+}\n \n-            ty::ReFree(ref fr) => write!(f, \"{:?}\", fr),\n-\n-            ty::ReScope(id) => {\n-                write!(f, \"ReScope({:?})\", id)\n+define_print! {\n+    () ty::RegionKind, (self, f, cx) {\n+        display {\n+            if cx.is_verbose {\n+                return self.print_debug(f, cx);\n             }\n \n-            ty::ReStatic => write!(f, \"ReStatic\"),\n-\n-            ty::ReVar(ref vid) => {\n-                write!(f, \"{:?}\", vid)\n+            // These printouts are concise.  They do not contain all the information\n+            // the user might want to diagnose an error, but there is basically no way\n+            // to fit that into a short string.  Hence the recommendation to use\n+            // `explain_region()` or `note_and_explain_region()`.\n+            match *self {\n+                ty::ReEarlyBound(ref data) => {\n+                    write!(f, \"{}\", data.name)\n+                }\n+                ty::ReLateBound(_, br) |\n+                ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+                ty::ReSkolemized(_, br) => {\n+                    write!(f, \"{}\", br)\n+                }\n+                ty::ReScope(scope) if cx.identify_regions => {\n+                    match scope.data() {\n+                        region::ScopeData::Node(id) =>\n+                            write!(f, \"'{}s\", id.as_usize()),\n+                        region::ScopeData::CallSite(id) =>\n+                            write!(f, \"'{}cs\", id.as_usize()),\n+                        region::ScopeData::Arguments(id) =>\n+                            write!(f, \"'{}as\", id.as_usize()),\n+                        region::ScopeData::Destruction(id) =>\n+                            write!(f, \"'{}ds\", id.as_usize()),\n+                        region::ScopeData::Remainder(BlockRemainder\n+                                                     { block, first_statement_index }) =>\n+                            write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index.index()),\n+                    }\n+                }\n+                ty::ReVar(region_vid) if cx.identify_regions => {\n+                    write!(f, \"'{}rv\", region_vid.index)\n+                }\n+                ty::ReScope(_) |\n+                ty::ReVar(_) |\n+                ty::ReErased => Ok(()),\n+                ty::ReStatic => write!(f, \"'static\"),\n+                ty::ReEmpty => write!(f, \"'<empty>\"),\n             }\n+        }\n+        debug {\n+            match *self {\n+                ty::ReEarlyBound(ref data) => {\n+                    write!(f, \"ReEarlyBound({}, {})\",\n+                           data.index,\n+                           data.name)\n+                }\n \n-            ty::ReSkolemized(id, ref bound_region) => {\n-                write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n-            }\n+                ty::ReLateBound(binder_id, ref bound_region) => {\n+                    write!(f, \"ReLateBound({:?}, {:?})\",\n+                           binder_id,\n+                           bound_region)\n+                }\n \n-            ty::ReEmpty => write!(f, \"ReEmpty\"),\n+                ty::ReFree(ref fr) => write!(f, \"{:?}\", fr),\n \n-            ty::ReErased => write!(f, \"ReErased\")\n-        }\n-    }\n-}\n+                ty::ReScope(id) => {\n+                    write!(f, \"ReScope({:?})\", id)\n+                }\n \n-impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ClosureUpvar({:?},{:?})\",\n-               self.def,\n-               self.ty)\n-    }\n-}\n+                ty::ReStatic => write!(f, \"ReStatic\"),\n \n-impl fmt::Display for ty::RegionKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if verbose() {\n-            return write!(f, \"{:?}\", *self);\n-        }\n+                ty::ReVar(ref vid) => {\n+                    write!(f, \"{:?}\", vid)\n+                }\n \n-        // These printouts are concise.  They do not contain all the information\n-        // the user might want to diagnose an error, but there is basically no way\n-        // to fit that into a short string.  Hence the recommendation to use\n-        // `explain_region()` or `note_and_explain_region()`.\n-        match *self {\n-            ty::ReEarlyBound(ref data) => {\n-                write!(f, \"{}\", data.name)\n-            }\n-            ty::ReLateBound(_, br) |\n-            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-            ty::ReSkolemized(_, br) => {\n-                write!(f, \"{}\", br)\n-            }\n-            ty::ReScope(scope) if identify_regions() => {\n-                match scope.data() {\n-                    region::ScopeData::Node(id) =>\n-                        write!(f, \"'{}s\", id.as_usize()),\n-                    region::ScopeData::CallSite(id) =>\n-                        write!(f, \"'{}cs\", id.as_usize()),\n-                    region::ScopeData::Arguments(id) =>\n-                        write!(f, \"'{}as\", id.as_usize()),\n-                    region::ScopeData::Destruction(id) =>\n-                        write!(f, \"'{}ds\", id.as_usize()),\n-                    region::ScopeData::Remainder(BlockRemainder { block, first_statement_index }) =>\n-                        write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index.index()),\n+                ty::ReSkolemized(id, ref bound_region) => {\n+                    write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n                 }\n+\n+                ty::ReEmpty => write!(f, \"ReEmpty\"),\n+\n+                ty::ReErased => write!(f, \"ReErased\")\n             }\n-            ty::ReVar(region_vid) if identify_regions() => {\n-                write!(f, \"'{}rv\", region_vid.index)\n-            }\n-            ty::ReScope(_) |\n-            ty::ReVar(_) |\n-            ty::ReErased => Ok(()),\n-            ty::ReStatic => write!(f, \"'static\"),\n-            ty::ReEmpty => write!(f, \"'<empty>\"),\n         }\n     }\n }\n \n-impl fmt::Debug for ty::FreeRegion {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ReFree({:?}, {:?})\",\n-               self.scope, self.bound_region)\n+define_print! {\n+    () ty::FreeRegion, (self, f, cx) {\n+        debug {\n+            write!(f, \"ReFree({:?}, {:?})\", self.scope, self.bound_region)\n+        }\n     }\n }\n \n-impl fmt::Debug for ty::Variance {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(match *self {\n-            ty::Covariant => \"+\",\n-            ty::Contravariant => \"-\",\n-            ty::Invariant => \"o\",\n-            ty::Bivariant => \"*\",\n-        })\n+define_print! {\n+    () ty::Variance, (self, f, cx) {\n+        debug {\n+            f.write_str(match *self {\n+                ty::Covariant => \"+\",\n+                ty::Contravariant => \"-\",\n+                ty::Invariant => \"o\",\n+                ty::Bivariant => \"*\",\n+            })\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::GenericPredicates<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"GenericPredicates({:?})\", self.predicates)\n+define_print! {\n+    ('tcx) ty::GenericPredicates<'tcx>, (self, f, cx) {\n+        debug {\n+            write!(f, \"GenericPredicates({:?})\", self.predicates)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::InstantiatedPredicates<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"InstantiatedPredicates({:?})\",\n-               self.predicates)\n+define_print! {\n+    ('tcx) ty::InstantiatedPredicates<'tcx>, (self, f, cx) {\n+        debug {\n+            write!(f, \"InstantiatedPredicates({:?})\", self.predicates)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.unsafety == hir::Unsafety::Unsafe {\n-            write!(f, \"unsafe \")?;\n-        }\n+define_print! {\n+    ('tcx) ty::FnSig<'tcx>, (self, f, cx) {\n+        display {\n+            if self.unsafety == hir::Unsafety::Unsafe {\n+                write!(f, \"unsafe \")?;\n+            }\n \n-        if self.abi != Abi::Rust {\n-            write!(f, \"extern {} \", self.abi)?;\n-        }\n+            if self.abi != Abi::Rust {\n+                write!(f, \"extern {} \", self.abi)?;\n+            }\n \n-        write!(f, \"fn\")?;\n-        fn_sig(f, self.inputs(), self.variadic, self.output())\n+            write!(f, \"fn\")?;\n+            cx.fn_sig(f, self.inputs(), self.variadic, self.output())\n+        }\n+        debug {\n+            write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs(), self.variadic, self.output())\n+        }\n     }\n }\n \n@@ -626,21 +854,27 @@ impl fmt::Debug for ty::RegionVid {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::FnSig<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs(), self.variadic, self.output())\n-    }\n-}\n-\n-impl fmt::Debug for ty::InferTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::TyVar(ref v) => v.fmt(f),\n-            ty::IntVar(ref v) => v.fmt(f),\n-            ty::FloatVar(ref v) => v.fmt(f),\n-            ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n-            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n-            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n+define_print! {\n+    () ty::InferTy, (self, f, cx) {\n+        display {\n+            match *self {\n+                ty::TyVar(_) => write!(f, \"_\"),\n+                ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n+                ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n+                ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n+                ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n+                ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n+            }\n+        }\n+        debug {\n+            match *self {\n+                ty::TyVar(ref v) => write!(f, \"{:?}\", v),\n+                ty::IntVar(ref v) => write!(f, \"{:?}\", v),\n+                ty::FloatVar(ref v) => write!(f, \"{:?}\", v),\n+                ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n+                ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n+                ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n+            }\n         }\n     }\n }\n@@ -665,406 +899,393 @@ impl fmt::Debug for ty::IntVarValue {\n     }\n }*/\n \n-impl<'tcx> fmt::Display for ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::TraitRef<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::FnSig<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::TraitPredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::EquatePredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::SubtypePredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::ProjectionPredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>,\n-                                                             ty::Region<'tcx>>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n+define_print_multi! {\n+    [\n+    ('tcx) ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>,\n+    ('tcx) ty::Binder<ty::TraitRef<'tcx>>,\n+    ('tcx) ty::Binder<ty::FnSig<'tcx>>,\n+    ('tcx) ty::Binder<ty::TraitPredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::EquatePredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::SubtypePredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::ProjectionPredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n+    ('tcx) ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>\n+    ]\n+    (self, f, cx) {\n+        display {\n+            ty::tls::with(|tcx| cx.in_binder(f, tcx, self, tcx.lift(self)))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        parameterized(f, self.substs, self.def_id, &[])\n+define_print! {\n+    ('tcx) ty::TraitRef<'tcx>, (self, f, cx) {\n+        display {\n+            cx.parameterized(f, self.substs, self.def_id, &[])\n+        }\n+        debug {\n+            // when printing out the debug representation, we don't need\n+            // to enumerate the `for<...>` etc because the debruijn index\n+            // tells you everything you need to know.\n+            print!(f, cx,\n+                   write(\"<\"),\n+                   print(self.self_ty()),\n+                   write(\" as \"))?;\n+            cx.parameterized(f, self.substs, self.def_id, &[])?;\n+            write!(f, \">\")\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::GeneratorInterior<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.witness.fmt(f)\n+define_print! {\n+    ('tcx) ty::GeneratorInterior<'tcx>, (self, f, cx) {\n+        display {\n+            self.witness.print(f, cx)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            TyBool => write!(f, \"bool\"),\n-            TyChar => write!(f, \"char\"),\n-            TyInt(t) => write!(f, \"{}\", t.ty_to_string()),\n-            TyUint(t) => write!(f, \"{}\", t.ty_to_string()),\n-            TyFloat(t) => write!(f, \"{}\", t.ty_to_string()),\n-            TyRawPtr(ref tm) => {\n-                write!(f, \"*{} {}\", match tm.mutbl {\n-                    hir::MutMutable => \"mut\",\n-                    hir::MutImmutable => \"const\",\n-                },  tm.ty)\n-            }\n-            TyRef(r, ref tm) => {\n-                write!(f, \"&\")?;\n-                let s = r.to_string();\n-                write!(f, \"{}\", s)?;\n-                if !s.is_empty() {\n-                    write!(f, \" \")?;\n+define_print! {\n+    ('tcx) ty::TypeVariants<'tcx>, (self, f, cx) {\n+        display {\n+            match *self {\n+                TyBool => write!(f, \"bool\"),\n+                TyChar => write!(f, \"char\"),\n+                TyInt(t) => write!(f, \"{}\", t.ty_to_string()),\n+                TyUint(t) => write!(f, \"{}\", t.ty_to_string()),\n+                TyFloat(t) => write!(f, \"{}\", t.ty_to_string()),\n+                TyRawPtr(ref tm) => {\n+                    write!(f, \"*{} \", match tm.mutbl {\n+                        hir::MutMutable => \"mut\",\n+                        hir::MutImmutable => \"const\",\n+                    })?;\n+                    tm.ty.print(f, cx)\n                 }\n-                write!(f, \"{}\", tm)\n-            }\n-            TyNever => write!(f, \"!\"),\n-            TyTuple(ref tys, _) => {\n-                write!(f, \"(\")?;\n-                let mut tys = tys.iter();\n-                if let Some(&ty) = tys.next() {\n-                    write!(f, \"{},\", ty)?;\n+                TyRef(r, ref tm) => {\n+                    write!(f, \"&\")?;\n+                    let s = r.print_to_string(cx);\n+                    write!(f, \"{}\", s)?;\n+                    if !s.is_empty() {\n+                        write!(f, \" \")?;\n+                    }\n+                    tm.print(f, cx)\n+                }\n+                TyNever => write!(f, \"!\"),\n+                TyTuple(ref tys, _) => {\n+                    write!(f, \"(\")?;\n+                    let mut tys = tys.iter();\n                     if let Some(&ty) = tys.next() {\n-                        write!(f, \" {}\", ty)?;\n-                        for &ty in tys {\n-                            write!(f, \", {}\", ty)?;\n+                        print!(f, cx, print(ty), write(\",\"))?;\n+                        if let Some(&ty) = tys.next() {\n+                            print!(f, cx, write(\" \"), print(ty))?;\n+                            for &ty in tys {\n+                                print!(f, cx, write(\", \"), print(ty))?;\n+                            }\n                         }\n                     }\n+                    write!(f, \")\")\n                 }\n-                write!(f, \")\")\n-            }\n-            TyFnDef(def_id, substs) => {\n-                ty::tls::with(|tcx| {\n-                    let mut sig = tcx.fn_sig(def_id);\n-                    if let Some(substs) = tcx.lift(&substs) {\n-                        sig = sig.subst(tcx, substs);\n+                TyFnDef(def_id, substs) => {\n+                    ty::tls::with(|tcx| {\n+                        let mut sig = tcx.fn_sig(def_id);\n+                        if let Some(substs) = tcx.lift(&substs) {\n+                            sig = sig.subst(tcx, substs);\n+                        }\n+                        print!(f, cx, print(sig), write(\" {{\"))\n+                    })?;\n+                    cx.parameterized(f, substs, def_id, &[])?;\n+                    write!(f, \"}}\")\n+                }\n+                TyFnPtr(ref bare_fn) => {\n+                    bare_fn.print(f, cx)\n+                }\n+                TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n+                TyError => write!(f, \"[type error]\"),\n+                TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n+                TyAdt(def, substs) => cx.parameterized(f, substs, def.did, &[]),\n+                TyDynamic(data, r) => {\n+                    data.print(f, cx)?;\n+                    let r = r.print_to_string(cx);\n+                    if !r.is_empty() {\n+                        write!(f, \" + {}\", r)\n+                    } else {\n+                        Ok(())\n                     }\n-                    write!(f, \"{} {{\", sig.0)\n-                })?;\n-                parameterized(f, substs, def_id, &[])?;\n-                write!(f, \"}}\")\n-            }\n-            TyFnPtr(ref bare_fn) => {\n-                write!(f, \"{}\", bare_fn.0)\n-            }\n-            TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n-            TyError => write!(f, \"[type error]\"),\n-            TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n-            TyAdt(def, substs) => parameterized(f, substs, def.did, &[]),\n-            TyDynamic(data, r) => {\n-                write!(f, \"{}\", data)?;\n-                let r = r.to_string();\n-                if !r.is_empty() {\n-                    write!(f, \" + {}\", r)\n-                } else {\n-                    Ok(())\n                 }\n-            }\n-            TyProjection(ref data) => write!(f, \"{}\", data),\n-            TyAnon(def_id, substs) => {\n-                ty::tls::with(|tcx| {\n-                    // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                    // by looking up the projections associated with the def_id.\n-                    let predicates_of = tcx.predicates_of(def_id);\n-                    let substs = tcx.lift(&substs).unwrap_or_else(|| {\n-                        tcx.intern_substs(&[])\n-                    });\n-                    let bounds = predicates_of.instantiate(tcx, substs);\n-\n-                    let mut first = true;\n-                    let mut is_sized = false;\n-                    write!(f, \"impl\")?;\n-                    for predicate in bounds.predicates {\n-                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n-                            // Don't print +Sized, but rather +?Sized if absent.\n-                            if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n-                                is_sized = true;\n-                                continue;\n+                TyProjection(ref data) => data.print(f, cx),\n+                TyAnon(def_id, substs) => {\n+                    ty::tls::with(|tcx| {\n+                        // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                        // by looking up the projections associated with the def_id.\n+                        let predicates_of = tcx.predicates_of(def_id);\n+                        let substs = tcx.lift(&substs).unwrap_or_else(|| {\n+                            tcx.intern_substs(&[])\n+                        });\n+                        let bounds = predicates_of.instantiate(tcx, substs);\n+\n+                        let mut first = true;\n+                        let mut is_sized = false;\n+                        write!(f, \"impl\")?;\n+                        for predicate in bounds.predicates {\n+                            if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                                // Don't print +Sized, but rather +?Sized if absent.\n+                                if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n+                                    is_sized = true;\n+                                    continue;\n+                                }\n+\n+                                print!(f, cx,\n+                                       write(\"{}\", if first { \" \" } else { \"+\" }),\n+                                       print(trait_ref))?;\n+                                first = false;\n                             }\n-\n-                            write!(f, \"{}{}\", if first { \" \" } else { \"+\" }, trait_ref)?;\n-                            first = false;\n                         }\n-                    }\n-                    if !is_sized {\n-                        write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n-                    }\n-                    Ok(())\n-                })\n-            }\n-            TyStr => write!(f, \"str\"),\n-            TyGenerator(did, substs, interior) => ty::tls::with(|tcx| {\n-                let upvar_tys = substs.upvar_tys(did, tcx);\n-                write!(f, \"[generator\")?;\n-\n-                if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n-                    write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n-                    let mut sep = \" \";\n-                    tcx.with_freevars(node_id, |freevars| {\n-                        for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                            write!(f,\n-                                        \"{}{}:{}\",\n-                                        sep,\n-                                        tcx.hir.name(freevar.var_id()),\n-                                        upvar_ty)?;\n-                            sep = \", \";\n+                        if !is_sized {\n+                            write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n                         }\n                         Ok(())\n-                    })?\n-                } else {\n-                    // cross-crate closure types should only be\n-                    // visible in trans bug reports, I imagine.\n-                    write!(f, \"@{:?}\", did)?;\n-                    let mut sep = \" \";\n-                    for (index, upvar_ty) in upvar_tys.enumerate() {\n-                        write!(f, \"{}{}:{}\", sep, index, upvar_ty)?;\n-                        sep = \", \";\n-                    }\n+                    })\n                 }\n+                TyStr => write!(f, \"str\"),\n+                TyGenerator(did, substs, interior) => ty::tls::with(|tcx| {\n+                    let upvar_tys = substs.upvar_tys(did, tcx);\n+                    write!(f, \"[generator\")?;\n \n-                write!(f, \" {}\", interior)?;\n-\n-                write!(f, \"]\")\n-            }),\n-            TyClosure(did, substs) => ty::tls::with(|tcx| {\n-                let upvar_tys = substs.upvar_tys(did, tcx);\n-                write!(f, \"[closure\")?;\n-\n-                if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n-                    if tcx.sess.opts.debugging_opts.span_free_formats {\n-                        write!(f, \"@{:?}\", node_id)?;\n-                    } else {\n+                    if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n                         write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n-                    }\n-                    let mut sep = \" \";\n-                    tcx.with_freevars(node_id, |freevars| {\n-                        for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                            write!(f,\n-                                        \"{}{}:{}\",\n-                                        sep,\n-                                        tcx.hir.name(freevar.var_id()),\n-                                        upvar_ty)?;\n+                        let mut sep = \" \";\n+                        tcx.with_freevars(node_id, |freevars| {\n+                            for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n+                                print!(f, cx,\n+                                       write(\"{}{}:\",\n+                                             sep,\n+                                             tcx.hir.name(freevar.var_id())),\n+                                       print(upvar_ty))?;\n+                                sep = \", \";\n+                            }\n+                            Ok(())\n+                        })?\n+                    } else {\n+                        // cross-crate closure types should only be\n+                        // visible in trans bug reports, I imagine.\n+                        write!(f, \"@{:?}\", did)?;\n+                        let mut sep = \" \";\n+                        for (index, upvar_ty) in upvar_tys.enumerate() {\n+                            print!(f, cx,\n+                                   write(\"{}{}:\", sep, index),\n+                                   print(upvar_ty))?;\n                             sep = \", \";\n                         }\n-                        Ok(())\n-                    })?\n-                } else {\n-                    // cross-crate closure types should only be\n-                    // visible in trans bug reports, I imagine.\n-                    write!(f, \"@{:?}\", did)?;\n-                    let mut sep = \" \";\n-                    for (index, upvar_ty) in upvar_tys.enumerate() {\n-                        write!(f, \"{}{}:{}\", sep, index, upvar_ty)?;\n-                        sep = \", \";\n                     }\n-                }\n \n-                write!(f, \"]\")\n-            }),\n-            TyArray(ty, sz) => {\n-                write!(f, \"[{}; \", ty)?;\n-                match sz.val {\n-                    ConstVal::Integral(ConstInt::Usize(sz)) => {\n-                        write!(f, \"{}\", sz)?;\n-                    }\n-                    ConstVal::Unevaluated(_def_id, substs) => {\n-                        write!(f, \"<unevaluated{:?}>\", &substs[..])?;\n+                    print!(f, cx, write(\" \"), print(interior), write(\"]\"))\n+                }),\n+                TyClosure(did, substs) => ty::tls::with(|tcx| {\n+                    let upvar_tys = substs.upvar_tys(did, tcx);\n+                    write!(f, \"[closure\")?;\n+\n+                    if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n+                        if tcx.sess.opts.debugging_opts.span_free_formats {\n+                            write!(f, \"@{:?}\", node_id)?;\n+                        } else {\n+                            write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n+                        }\n+                        let mut sep = \" \";\n+                        tcx.with_freevars(node_id, |freevars| {\n+                            for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n+                                print!(f, cx,\n+                                       write(\"{}{}:\",\n+                                             sep,\n+                                             tcx.hir.name(freevar.var_id())),\n+                                       print(upvar_ty))?;\n+                                sep = \", \";\n+                            }\n+                            Ok(())\n+                        })?\n+                    } else {\n+                        // cross-crate closure types should only be\n+                        // visible in trans bug reports, I imagine.\n+                        write!(f, \"@{:?}\", did)?;\n+                        let mut sep = \" \";\n+                        for (index, upvar_ty) in upvar_tys.enumerate() {\n+                            print!(f, cx,\n+                                   write(\"{}{}:\", sep, index),\n+                                   print(upvar_ty))?;\n+                            sep = \", \";\n+                        }\n                     }\n-                    _ => {\n-                        write!(f, \"{:?}\", sz)?;\n+\n+                    write!(f, \"]\")\n+                }),\n+                TyArray(ty, sz) => {\n+                    print!(f, cx, write(\"[\"), print(ty), write(\"; \"))?;\n+                    match sz.val {\n+                        ConstVal::Integral(ConstInt::Usize(sz)) => {\n+                            write!(f, \"{}\", sz)?;\n+                        }\n+                        ConstVal::Unevaluated(_def_id, substs) => {\n+                            write!(f, \"<unevaluated{:?}>\", &substs[..])?;\n+                        }\n+                        _ => {\n+                            write!(f, \"{:?}\", sz)?;\n+                        }\n                     }\n+                    write!(f, \"]\")\n+                }\n+                TySlice(ty) => {\n+                    print!(f, cx, write(\"[\"), print(ty), write(\"]\"))\n                 }\n-                write!(f, \"]\")\n             }\n-            TySlice(ty) => write!(f, \"[{}]\",  ty)\n         }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TyS<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.sty)\n-    }\n-}\n-\n-impl fmt::Debug for ty::UpvarId {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n-               self.var_id,\n-               ty::tls::with(|tcx| tcx.hir.name(tcx.hir.hir_to_node_id(self.var_id))),\n-               self.closure_expr_id)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"UpvarBorrow({:?}, {:?})\",\n-               self.kind, self.region)\n-    }\n-}\n-\n-impl fmt::Display for ty::InferTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let print_var_ids = verbose();\n-        match *self {\n-            ty::TyVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n-            ty::IntVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n-            ty::FloatVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n-            ty::TyVar(_) => write!(f, \"_\"),\n-            ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n-            ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n-            ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n-            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n-            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n+define_print! {\n+    ('tcx) ty::TyS<'tcx>, (self, f, cx) {\n+        display {\n+            self.sty.print(f, cx)\n+        }\n+        debug {\n+            self.sty.print_display(f, cx)\n         }\n     }\n }\n \n-impl fmt::Display for ty::ParamTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.name)\n-    }\n-}\n-\n-impl fmt::Debug for ty::ParamTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}/#{}\", self, self.idx)\n-    }\n-}\n-\n-impl<'tcx, T, U> fmt::Display for ty::OutlivesPredicate<T,U>\n-    where T: fmt::Display, U: fmt::Display\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} : {}\", self.0, self.1)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::EquatePredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} == {}\", self.0, self.1)\n+define_print! {\n+    () ty::ParamTy, (self, f, cx) {\n+        display {\n+            write!(f, \"{}\", self.name)\n+        }\n+        debug {\n+            write!(f, \"{}/#{}\", self.name, self.idx)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::SubtypePredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} <: {}\", self.a, self.b)\n+define_print! {\n+    ('tcx, T: Print + fmt::Debug, U: Print + fmt::Debug) ty::OutlivesPredicate<T, U>,\n+    (self, f, cx) {\n+        display {\n+            print!(f, cx, print(self.0), write(\" : \"), print(self.1))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TraitPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TraitPredicate({:?})\",\n-               self.trait_ref)\n+define_print! {\n+    ('tcx) ty::EquatePredicate<'tcx>, (self, f, cx) {\n+        display {\n+            print!(f, cx, print(self.0), write(\" == \"), print(self.1))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TraitPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}: {}\", self.trait_ref.self_ty(), self.trait_ref)\n+define_print! {\n+    ('tcx) ty::SubtypePredicate<'tcx>, (self, f, cx) {\n+        display {\n+            print!(f, cx, print(self.a), write(\" <: \"), print(self.b))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ProjectionPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ProjectionPredicate({:?}, {:?})\",\n-               self.projection_ty,\n-               self.ty)\n+define_print! {\n+    ('tcx) ty::TraitPredicate<'tcx>, (self, f, cx) {\n+        debug {\n+            write!(f, \"TraitPredicate({:?})\",\n+                   self.trait_ref)\n+        }\n+        display {\n+            print!(f, cx, print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::ProjectionPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} == {}\",\n-               self.projection_ty,\n-               self.ty)\n+define_print! {\n+    ('tcx) ty::ProjectionPredicate<'tcx>, (self, f, cx) {\n+        debug {\n+            print!(f, cx,\n+                   write(\"ProjectionPredicate(\"),\n+                   print(self.projection_ty),\n+                   write(\", \"),\n+                   print(self.ty),\n+                   write(\")\"))\n+        }\n+        display {\n+            print!(f, cx, print(self.projection_ty), write(\" == \"), print(self.ty))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::ProjectionTy<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // FIXME(tschottdorf): use something like\n-        //   parameterized(f, self.substs, self.item_def_id, &[])\n-        // (which currently ICEs).\n-        let (trait_ref, item_name) = ty::tls::with(|tcx|\n-            (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).name)\n-        );\n-        write!(f, \"{:?}::{}\",\n-               trait_ref,\n-               item_name)\n+define_print! {\n+    ('tcx) ty::ProjectionTy<'tcx>, (self, f, cx) {\n+        display {\n+            // FIXME(tschottdorf): use something like\n+            //   parameterized(f, self.substs, self.item_def_id, &[])\n+            // (which currently ICEs).\n+            let (trait_ref, item_name) = ty::tls::with(|tcx|\n+                (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).name)\n+            );\n+            print!(f, cx, print_debug(trait_ref), write(\"::{}\", item_name))\n+        }\n     }\n }\n \n-impl fmt::Display for ty::ClosureKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::ClosureKind::Fn => write!(f, \"Fn\"),\n-            ty::ClosureKind::FnMut => write!(f, \"FnMut\"),\n-            ty::ClosureKind::FnOnce => write!(f, \"FnOnce\"),\n+define_print! {\n+    () ty::ClosureKind, (self, f, cx) {\n+        display {\n+            match *self {\n+                ty::ClosureKind::Fn => write!(f, \"Fn\"),\n+                ty::ClosureKind::FnMut => write!(f, \"FnMut\"),\n+                ty::ClosureKind::FnOnce => write!(f, \"FnOnce\"),\n+            }\n         }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::Predicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::Predicate::Trait(ref data) => write!(f, \"{}\", data),\n-            ty::Predicate::Equate(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::Subtype(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::RegionOutlives(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::TypeOutlives(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::Projection(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::WellFormed(ty) => write!(f, \"{} well-formed\", ty),\n-            ty::Predicate::ObjectSafe(trait_def_id) =>\n-                ty::tls::with(|tcx| {\n-                    write!(f, \"the trait `{}` is object-safe\", tcx.item_path_str(trait_def_id))\n-                }),\n-            ty::Predicate::ClosureKind(closure_def_id, kind) =>\n-                ty::tls::with(|tcx| {\n-                    write!(f, \"the closure `{}` implements the trait `{}`\",\n-                           tcx.item_path_str(closure_def_id), kind)\n-                }),\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                write!(f, \"the constant `\")?;\n-                parameterized(f, substs, def_id, &[])?;\n-                write!(f, \"` can be evaluated\")\n+define_print! {\n+    ('tcx) ty::Predicate<'tcx>, (self, f, cx) {\n+        display {\n+            match *self {\n+                ty::Predicate::Trait(ref data) => data.print(f, cx),\n+                ty::Predicate::Equate(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::Subtype(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::RegionOutlives(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::TypeOutlives(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::Projection(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::WellFormed(ty) => print!(f, cx, print(ty), write(\" well-formed\")),\n+                ty::Predicate::ObjectSafe(trait_def_id) =>\n+                    ty::tls::with(|tcx| {\n+                        write!(f, \"the trait `{}` is object-safe\", tcx.item_path_str(trait_def_id))\n+                    }),\n+                ty::Predicate::ClosureKind(closure_def_id, kind) =>\n+                    ty::tls::with(|tcx| {\n+                        write!(f, \"the closure `{}` implements the trait `{}`\",\n+                               tcx.item_path_str(closure_def_id), kind)\n+                    }),\n+                ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                    write!(f, \"the constant `\")?;\n+                    cx.parameterized(f, substs, def_id, &[])?;\n+                    write!(f, \"` can be evaluated\")\n+                }\n+            }\n+        }\n+        debug {\n+            match *self {\n+                ty::Predicate::Trait(ref a) => a.print(f, cx),\n+                ty::Predicate::Equate(ref pair) => pair.print(f, cx),\n+                ty::Predicate::Subtype(ref pair) => pair.print(f, cx),\n+                ty::Predicate::RegionOutlives(ref pair) => pair.print(f, cx),\n+                ty::Predicate::TypeOutlives(ref pair) => pair.print(f, cx),\n+                ty::Predicate::Projection(ref pair) => pair.print(f, cx),\n+                ty::Predicate::WellFormed(ty) => ty.print(f, cx),\n+                ty::Predicate::ObjectSafe(trait_def_id) => {\n+                    write!(f, \"ObjectSafe({:?})\", trait_def_id)\n+                }\n+                ty::Predicate::ClosureKind(closure_def_id, kind) => {\n+                    write!(f, \"ClosureKind({:?}, {:?})\", closure_def_id, kind)\n+                }\n+                ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                    write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n+                }\n             }\n         }\n     }"}, {"sha": "6f6fde1e9e7786155aad5f994a3b14b220f4b469", "filename": "src/librustc_back/build.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fbuild.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -11,5 +11,4 @@\n fn main() {\n     println!(\"cargo:rerun-if-changed=build.rs\");\n     println!(\"cargo:rerun-if-env-changed=CFG_DEFAULT_LINKER\");\n-    println!(\"cargo:rerun-if-env-changed=CFG_DEFAULT_AR\");\n }"}, {"sha": "ba21b1df032a84dde687a6f5289b5beabb3d75e5", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -14,7 +14,7 @@ use target::{Target, TargetOptions, TargetResult};\n pub fn target() -> TargetResult {\n     let mut base = super::android_base::opts();\n     // https://developer.android.com/ndk/guides/abis.html#armeabi\n-    base.features = \"+v5te\".to_string();\n+    base.features = \"+strict-align,+v5te\".to_string();\n     base.max_atomic_width = Some(64);\n \n     Ok(Target {"}, {"sha": "e630376a67dd093cf65c867e3799454b03fa6d82", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -27,7 +27,7 @@ pub fn target() -> TargetResult {\n         linker_flavor: LinkerFlavor::Gcc,\n \n         options: TargetOptions {\n-            features: \"+v6\".to_string(),\n+            features: \"+strict-align,+v6\".to_string(),\n             abi_blacklist: super::arm_base::abi_blacklist(),\n             .. base\n         },"}, {"sha": "178a948b2b9c8b33c492d2781ec144d26bea143c", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -27,7 +27,7 @@ pub fn target() -> TargetResult {\n         linker_flavor: LinkerFlavor::Gcc,\n \n         options: TargetOptions {\n-            features: \"+v6,+vfp2\".to_string(),\n+            features: \"+strict-align,+v6,+vfp2\".to_string(),\n             abi_blacklist: super::arm_base::abi_blacklist(),\n             .. base\n         }"}, {"sha": "29720ec5efcd758e24a3ad8a7e443fd22345982e", "filename": "src/librustc_back/target/arm_unknown_linux_musleabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabi.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> TargetResult {\n \n     // Most of these settings are copied from the arm_unknown_linux_gnueabi\n     // target.\n-    base.features = \"+v6\".to_string();\n+    base.features = \"+strict-align,+v6\".to_string();\n     base.max_atomic_width = Some(64);\n     Ok(Target {\n         // It's important we use \"gnueabi\" and not \"musleabi\" here. LLVM uses it"}, {"sha": "fc8313877f6409619b8cfe2dba684346976d467a", "filename": "src/librustc_back/target/arm_unknown_linux_musleabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabihf.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> TargetResult {\n \n     // Most of these settings are copied from the arm_unknown_linux_gnueabihf\n     // target.\n-    base.features = \"+v6,+vfp2\".to_string();\n+    base.features = \"+strict-align,+v6,+vfp2\".to_string();\n     base.max_atomic_width = Some(64);\n     Ok(Target {\n         // It's important we use \"gnueabihf\" and not \"musleabihf\" here. LLVM"}, {"sha": "97397ca49622e4d53c5db5d2c1e6ff12fc6d4c96", "filename": "src/librustc_back/target/armv5te_unknown_linux_gnueabi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Farmv5te_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Farmv5te_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv5te_unknown_linux_gnueabi.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -27,8 +27,12 @@ pub fn target() -> TargetResult {\n \n         options: TargetOptions {\n             features: \"+soft-float,+strict-align\".to_string(),\n-            // No atomic instructions on ARMv5\n-            max_atomic_width: Some(0),\n+\n+            // Atomic operations provided when linked with libgcc.\n+            // FIXME: If the following PR is merged, the atomic operations would be\n+            // provided by compiler-builtins instead with no change of behavior:\n+            // https://github.com/rust-lang-nursery/compiler-builtins/pull/115/files\n+            max_atomic_width: Some(32),\n             abi_blacklist: super::arm_base::abi_blacklist(),\n             .. base\n         }"}, {"sha": "a54627279b02c2a4a7179057e3ceae05dc88324b", "filename": "src/librustc_back/target/asmjs_unknown_emscripten.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -20,7 +20,6 @@ pub fn target() -> Result<Target, String> {\n \n     let opts = TargetOptions {\n         linker: cmd(\"emcc\"),\n-        ar: cmd(\"emar\"),\n \n         dynamic_linking: false,\n         executables: true,"}, {"sha": "9af4606f1f1f616a9a8f7117fb97a09b3fa438cf", "filename": "src/librustc_back/target/le32_unknown_nacl.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs?ref=69ba6738eb6bf9b6d11ebb81af2599648eb0bc04", "patch": "@@ -1,51 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use LinkerFlavor;\n-use super::{LinkArgs, Target, TargetOptions, TargetResult};\n-\n-pub fn target() -> TargetResult {\n-    let mut pre_link_args = LinkArgs::new();\n-    pre_link_args.insert(LinkerFlavor::Gcc,\n-                         vec![\"--pnacl-exceptions=sjlj\".to_string(),\n-                              \"--target=le32-unknown-nacl\".to_string(),\n-                              \"-Wl,--start-group\".to_string()]);\n-    let mut post_link_args = LinkArgs::new();\n-    post_link_args.insert(LinkerFlavor::Gcc,\n-                          vec![\"-Wl,--end-group\".to_string()]);\n-\n-    let opts = TargetOptions {\n-        linker: \"pnacl-clang\".to_string(),\n-        ar: \"pnacl-ar\".to_string(),\n-\n-        pre_link_args,\n-        post_link_args,\n-        dynamic_linking: false,\n-        executables: true,\n-        exe_suffix: \".pexe\".to_string(),\n-        linker_is_gnu: true,\n-        allow_asm: false,\n-        max_atomic_width: Some(32),\n-        .. Default::default()\n-    };\n-    Ok(Target {\n-        llvm_target: \"le32-unknown-nacl\".to_string(),\n-        target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n-        target_c_int_width: \"32\".to_string(),\n-        target_os: \"nacl\".to_string(),\n-        target_env: \"newlib\".to_string(),\n-        target_vendor: \"unknown\".to_string(),\n-        data_layout: \"e-i64:64:64-p:32:32:32-v128:32:32\".to_string(),\n-        arch: \"le32\".to_string(),\n-        linker_flavor: LinkerFlavor::Gcc,\n-        options: opts,\n-    })\n-}"}, {"sha": "a56d067815819c9df04f2f814917a2c9caf00af3", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -135,6 +135,7 @@ macro_rules! supported_targets {\n \n supported_targets! {\n     (\"x86_64-unknown-linux-gnu\", x86_64_unknown_linux_gnu),\n+    (\"x86_64-unknown-linux-gnux32\", x86_64_unknown_linux_gnux32),\n     (\"i686-unknown-linux-gnu\", i686_unknown_linux_gnu),\n     (\"i586-unknown-linux-gnu\", i586_unknown_linux_gnu),\n     (\"mips-unknown-linux-gnu\", mips_unknown_linux_gnu),\n@@ -215,7 +216,6 @@ supported_targets! {\n     (\"i686-pc-windows-msvc\", i686_pc_windows_msvc),\n     (\"i586-pc-windows-msvc\", i586_pc_windows_msvc),\n \n-    (\"le32-unknown-nacl\", le32_unknown_nacl),\n     (\"asmjs-unknown-emscripten\", asmjs_unknown_emscripten),\n     (\"wasm32-unknown-emscripten\", wasm32_unknown_emscripten),\n     (\"wasm32-experimental-emscripten\", wasm32_experimental_emscripten),\n@@ -269,8 +269,6 @@ pub struct TargetOptions {\n \n     /// Linker to invoke. Defaults to \"cc\".\n     pub linker: String,\n-    /// Archive utility to use when managing archives. Defaults to \"ar\".\n-    pub ar: String,\n \n     /// Linker arguments that are unconditionally passed *before* any\n     /// user-defined libraries.\n@@ -431,6 +429,9 @@ pub struct TargetOptions {\n \n     /// The minimum alignment for global symbols.\n     pub min_global_align: Option<u64>,\n+\n+    /// Default number of codegen units to use in debug mode\n+    pub default_codegen_units: Option<u64>,\n }\n \n impl Default for TargetOptions {\n@@ -440,7 +441,6 @@ impl Default for TargetOptions {\n         TargetOptions {\n             is_builtin: false,\n             linker: option_env!(\"CFG_DEFAULT_LINKER\").unwrap_or(\"cc\").to_string(),\n-            ar: option_env!(\"CFG_DEFAULT_AR\").unwrap_or(\"ar\").to_string(),\n             pre_link_args: LinkArgs::new(),\n             post_link_args: LinkArgs::new(),\n             asm_args: Vec::new(),\n@@ -493,6 +493,7 @@ impl Default for TargetOptions {\n             crt_static_respected: false,\n             stack_probes: false,\n             min_global_align: None,\n+            default_codegen_units: None,\n         }\n     }\n }\n@@ -681,7 +682,6 @@ impl Target {\n \n         key!(is_builtin, bool);\n         key!(linker);\n-        key!(ar);\n         key!(pre_link_args, link_args);\n         key!(pre_link_objects_exe, list);\n         key!(pre_link_objects_dll, list);\n@@ -733,6 +733,7 @@ impl Target {\n         key!(crt_static_respected, bool);\n         key!(stack_probes, bool);\n         key!(min_global_align, Option<u64>);\n+        key!(default_codegen_units, Option<u64>);\n \n         if let Some(array) = obj.find(\"abi-blacklist\").and_then(Json::as_array) {\n             for name in array.iter().filter_map(|abi| abi.as_string()) {\n@@ -873,7 +874,6 @@ impl ToJson for Target {\n \n         target_option_val!(is_builtin);\n         target_option_val!(linker);\n-        target_option_val!(ar);\n         target_option_val!(link_args - pre_link_args);\n         target_option_val!(pre_link_objects_exe);\n         target_option_val!(pre_link_objects_dll);\n@@ -925,6 +925,7 @@ impl ToJson for Target {\n         target_option_val!(crt_static_respected);\n         target_option_val!(stack_probes);\n         target_option_val!(min_global_align);\n+        target_option_val!(default_codegen_units);\n \n         if default.abi_blacklist != self.options.abi_blacklist {\n             d.insert(\"abi-blacklist\".to_string(), self.options.abi_blacklist.iter()"}, {"sha": "509a7cf5e03234158d70a61ca70ec53cbb749b74", "filename": "src/librustc_back/target/msp430_none_elf.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fmsp430_none_elf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fmsp430_none_elf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmsp430_none_elf.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -48,6 +48,11 @@ pub fn target() -> TargetResult {\n             // code because of the extra costs it involves.\n             relocation_model: \"static\".to_string(),\n \n+            // Right now we invoke an external assembler and this isn't\n+            // compatible with multiple codegen units, and plus we probably\n+            // don't want to invoke that many gcc instances.\n+            default_codegen_units: Some(1),\n+\n             .. Default::default( )\n         }\n     })"}, {"sha": "a261c982b3f2414d14424a28e2471048040873d9", "filename": "src/librustc_back/target/wasm32_experimental_emscripten.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fwasm32_experimental_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fwasm32_experimental_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwasm32_experimental_emscripten.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -25,7 +25,6 @@ pub fn target() -> Result<Target, String> {\n \n     let opts = TargetOptions {\n         linker: cmd(\"emcc\"),\n-        ar: cmd(\"emar\"),\n \n         dynamic_linking: false,\n         executables: true,"}, {"sha": "197c1f7a4da494c2f9f649f69ea57e3aeee5c092", "filename": "src/librustc_back/target/wasm32_unknown_emscripten.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -22,7 +22,6 @@ pub fn target() -> Result<Target, String> {\n \n     let opts = TargetOptions {\n         linker: cmd(\"emcc\"),\n-        ar: cmd(\"emar\"),\n \n         dynamic_linking: false,\n         executables: true,"}, {"sha": "64df6624dd1c23df62a5a696aadb3384d3f7611b", "filename": "src/librustc_back/target/windows_msvc_base.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -21,37 +21,6 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         function_sections: true,\n         linker: \"link.exe\".to_string(),\n-        // When taking a look at the value of this `ar` field, one might expect\n-        // `lib.exe` to be the value here! The `lib.exe` program is the default\n-        // tool for managing `.lib` archives on Windows, but unfortunately the\n-        // compiler cannot use it.\n-        //\n-        // To recap, we use `ar` here to manage rlibs (which are just archives).\n-        // LLVM does not expose bindings for modifying archives so we have to\n-        // invoke this utility for write operations (e.g. deleting files, adding\n-        // files, etc). Normally archives only have object files within them,\n-        // but the compiler also uses archives for storing metadata and\n-        // compressed bytecode, so we don't exactly fall within \"normal use\n-        // cases\".\n-        //\n-        // MSVC's `lib.exe` tool by default will choke when adding a non-object\n-        // file to an archive, which we do on a regular basis, making it\n-        // inoperable for us. Luckily, however, LLVM has already rewritten `ar`\n-        // in the form of `llvm-ar` which is built by default when we build\n-        // LLVM. This tool, unlike `lib.exe`, works just fine with non-object\n-        // files, so we use it instead.\n-        //\n-        // Note that there's a few caveats associated with this:\n-        //\n-        // * This still requires that the *linker* (the consumer of rlibs) will\n-        //   ignore non-object files. Thankfully `link.exe` on Windows does\n-        //   indeed ignore non-object files in archives.\n-        // * This requires `llvm-ar.exe` to be distributed with the compiler\n-        //   itself, but we already make sure of this elsewhere.\n-        //\n-        // Perhaps one day we won't even need this tool at all and we'll just be\n-        // able to make library calls into LLVM!\n-        ar: \"llvm-ar.exe\".to_string(),\n         dynamic_linking: true,\n         executables: true,\n         dll_prefix: \"\".to_string(),"}, {"sha": "18f6380b6eedf17e8ced966c880bd4dbade20dd1", "filename": "src/librustc_back/target/x86_64_rumprun_netbsd.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -16,7 +16,6 @@ pub fn target() -> TargetResult {\n     base.cpu = \"x86-64\".to_string();\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n     base.linker = \"x86_64-rumprun-netbsd-gcc\".to_string();\n-    base.ar = \"x86_64-rumprun-netbsd-ar\".to_string();\n     base.max_atomic_width = Some(64);\n \n     base.dynamic_linking = false;"}, {"sha": "7038203283643e90855d948861f48671375e6ed5", "filename": "src/librustc_back/target/x86_64_unknown_linux_gnux32.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnux32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnux32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnux32.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use LinkerFlavor;\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::linux_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-mx32\".to_string());\n+    base.stack_probes = true;\n+    base.has_elf_tls = false;\n+\n+    Ok(Target {\n+        llvm_target: \"x86_64-unknown-linux-gnux32\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "4c09a9e003ddb8645645d717ce53a5e9cd53dd15", "filename": "src/librustc_borrowck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2FCargo.toml?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -15,5 +15,6 @@ syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n graphviz = { path = \"../libgraphviz\" }\n rustc = { path = \"../librustc\" }\n+rustc_back = { path = \"../librustc_back\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "b877c5a9cbcbcccbb7ec2d8d2b728f41c0a709da", "filename": "src/librustc_borrowck/borrowck/README.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -781,8 +781,9 @@ the base path, it will still be considered freezable.\n \n \n \n-**FIXME #10520: Restrictions against mutating the base pointer.** When\n-an `&mut` pointer is frozen or claimed, we currently pass along the\n+**FIXME [RFC 1751](https://github.com/rust-lang/rfcs/issues/1751)\n+Restrictions against mutating the base pointer.**\n+When an `&mut` pointer is frozen or claimed, we currently pass along the\n restriction against MUTATE to the base pointer. I do not believe this\n restriction is needed. It dates from the days when we had a way to\n mutate that preserved the value being mutated (i.e., swap). Nowadays"}, {"sha": "6fd9ff4012efa6b23732c3161115447fc8c72615", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -206,7 +206,13 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         all_loans,\n         param_env,\n     };\n-    euv::ExprUseVisitor::new(&mut clcx, bccx.tcx, param_env, &bccx.region_scope_tree, bccx.tables)\n+    let rvalue_promotable_map = bccx.tcx.rvalue_promotable_map(def_id);\n+    euv::ExprUseVisitor::new(&mut clcx,\n+                             bccx.tcx,\n+                             param_env,\n+                             &bccx.region_scope_tree,\n+                             bccx.tables,\n+                             Some(rvalue_promotable_map))\n         .consume_body(body);\n }\n \n@@ -659,7 +665,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={:?})\",\n                id, use_kind, lp);\n \n-        // FIXME (22079): if you find yourself tempted to cut and paste\n+        // FIXME: if you find yourself tempted to cut and paste\n         // the body below and then specializing the error reporting,\n         // consider refactoring this instead!\n \n@@ -720,7 +726,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         // the path must be initialized to prevent a case of\n                         // partial reinitialization\n                         //\n-                        // FIXME (22079): could refactor via hypothetical\n+                        // FIXME: could refactor via hypothetical\n                         // generalized check_if_path_is_moved\n                         let loan_path = owned_ptr_base_path_rc(lp_base);\n                         self.move_data.each_move_of(id, &loan_path, |_, _| {\n@@ -770,7 +776,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             let lp = opt_loan_path(&assignee_cmt).unwrap();\n             self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n                 if assignee_cmt.mutbl.is_mutable() {\n-                    self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n+                    let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);\n+                    self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                 } else {\n                     self.bccx.report_reassigned_immutable_variable(\n                         assignment_span,"}, {"sha": "8654f2a50e46bf1c693c328d359feee85dfbba3a", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -48,7 +48,13 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n-    euv::ExprUseVisitor::new(&mut glcx, bccx.tcx, param_env, &bccx.region_scope_tree, bccx.tables)\n+    let rvalue_promotable_map = bccx.tcx.rvalue_promotable_map(def_id);\n+    euv::ExprUseVisitor::new(&mut glcx,\n+                             bccx.tcx,\n+                             param_env,\n+                             &bccx.region_scope_tree,\n+                             bccx.tables,\n+                             Some(rvalue_promotable_map))\n         .consume_body(bccx.body);\n \n     glcx.report_potential_errors();\n@@ -406,7 +412,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         self.all_loans.push(loan);\n \n         // if loan_gen_scope != borrow_id {\n-            // FIXME(#6268) Nested method calls\n+            // FIXME(https://github.com/rust-lang/rfcs/issues/811) Nested method calls\n             //\n             // Typically, the scope of the loan includes the point at\n             // which the loan is originated. This\n@@ -417,9 +423,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             //let restr = restrictions::compute_restrictions(\n             //    self.bccx, borrow_span, cmt, RESTR_EMPTY);\n             //let loan = {\n-            //    let all_loans = &mut *self.all_loans; // FIXME(#5074)\n             //    Loan {\n-            //        index: all_loans.len(),\n+            //        index: self.all_loans.len(),\n             //        loan_path,\n             //        cmt,\n             //        mutbl: ConstMutability,\n@@ -442,13 +447,13 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             wrapped_path = match current_path.kind {\n                 LpVar(local_id) => {\n                     if !through_borrow {\n-                        self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n+                        let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);\n+                        self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                     }\n                     None\n                 }\n                 LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n-                    let local_id = self.tcx().hir.hir_to_node_id(var_id);\n-                    self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n+                    self.bccx.used_mut_nodes.borrow_mut().insert(var_id);\n                     None\n                 }\n                 LpExtend(ref base, mc::McInherited, LpDeref(pointer_kind)) |"}, {"sha": "1f2b917bdb9943154cd6ca5fc5e269f7c00a06e3", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 9, "deletions": 30, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -14,6 +14,7 @@ use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::mem_categorization::NoteClosureEnv;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::ty;\n+use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n use syntax::ast;\n use syntax_pos;\n use errors::DiagnosticBuilder;\n@@ -134,51 +135,29 @@ fn group_errors_with_same_origin<'tcx>(errors: &Vec<MoveError<'tcx>>)\n }\n \n // (keep in sync with gather_moves::check_and_get_illegal_move_origin )\n-fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+fn report_cannot_move_out_of<'a, 'tcx>(bccx: &'a BorrowckCtxt<'a, 'tcx>,\n                                        move_from: mc::cmt<'tcx>)\n                                        -> DiagnosticBuilder<'a> {\n     match move_from.cat {\n         Categorization::Deref(_, mc::BorrowedPtr(..)) |\n         Categorization::Deref(_, mc::Implicit(..)) |\n         Categorization::Deref(_, mc::UnsafePtr(..)) |\n         Categorization::StaticItem => {\n-            let mut err = struct_span_err!(bccx, move_from.span, E0507,\n-                             \"cannot move out of {}\",\n-                             move_from.descriptive_string(bccx.tcx));\n-            err.span_label(\n-                move_from.span,\n-                format!(\"cannot move out of {}\", move_from.descriptive_string(bccx.tcx))\n-                );\n-            err\n+            bccx.cannot_move_out_of(\n+                move_from.span, &move_from.descriptive_string(bccx.tcx), Origin::Ast)\n         }\n-\n         Categorization::Interior(ref b, mc::InteriorElement(ik)) => {\n-            let type_name = match (&b.ty.sty, ik) {\n-                (&ty::TyArray(_, _), Kind::Index) => \"array\",\n-                (&ty::TySlice(_), _) => \"slice\",\n-                _ => {\n-                    span_bug!(move_from.span, \"this path should not cause illegal move\");\n-                },\n-            };\n-            let mut err = struct_span_err!(bccx, move_from.span, E0508,\n-                                           \"cannot move out of type `{}`, \\\n-                                            a non-copy {}\",\n-                                           b.ty, type_name);\n-            err.span_label(move_from.span, \"cannot move out of here\");\n-            err\n+            bccx.cannot_move_out_of_interior_noncopy(\n+                move_from.span, b.ty, ik == Kind::Index, Origin::Ast)\n         }\n \n         Categorization::Downcast(ref b, _) |\n         Categorization::Interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n                 ty::TyAdt(def, _) if def.has_dtor(bccx.tcx) => {\n-                    let mut err = struct_span_err!(bccx, move_from.span, E0509,\n-                                                   \"cannot move out of type `{}`, \\\n-                                                   which implements the `Drop` trait\",\n-                                                   b.ty);\n-                    err.span_label(move_from.span, \"cannot move out of here\");\n-                    err\n-                },\n+                    bccx.cannot_move_out_of_interior_of_drop(\n+                        move_from.span, b.ty, Origin::Ast)\n+                }\n                 _ => {\n                     span_bug!(move_from.span, \"this path should not cause illegal move\");\n                 }"}, {"sha": "d29250ac57cfbeb10e9450046ab28aaf852912fd", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 79, "deletions": 59, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -20,13 +20,15 @@ pub use self::MovedValueUseKind::*;\n \n use self::InteriorKind::*;\n \n+use rustc::hir::HirId;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::cfg;\n use rustc::middle::dataflow::DataFlowContext;\n use rustc::middle::dataflow::BitwiseOperator;\n use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n+use rustc::middle::borrowck::BorrowCheckResult;\n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n@@ -37,7 +39,9 @@ use rustc::middle::free_region::RegionRelations;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n+use rustc::util::nodemap::FxHashSet;\n \n+use std::cell::RefCell;\n use std::fmt;\n use std::rc::Rc;\n use std::hash::{Hash, Hasher};\n@@ -54,6 +58,8 @@ pub mod gather_loans;\n \n pub mod move_data;\n \n+mod unused;\n+\n #[derive(Clone, Copy)]\n pub struct LoanDataFlowOperator;\n \n@@ -79,7 +85,9 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n     pub move_data: move_data::FlowedMoveData<'a, 'tcx>,\n }\n \n-fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n+fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n+    -> Rc<BorrowCheckResult>\n+{\n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n \n     let owner_id = tcx.hir.as_local_node_id(owner_def_id).unwrap();\n@@ -91,7 +99,9 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n             // those things (notably the synthesized constructors from\n             // tuple structs/variants) do not have an associated body\n             // and do not need borrowchecking.\n-            return;\n+            return Rc::new(BorrowCheckResult {\n+                used_mut_nodes: FxHashSet(),\n+            })\n         }\n         _ => { }\n     }\n@@ -100,7 +110,14 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n     let body = tcx.hir.body(body_id);\n-    let bccx = &mut BorrowckCtxt { tcx, tables, region_scope_tree, owner_def_id, body };\n+    let mut bccx = BorrowckCtxt {\n+        tcx,\n+        tables,\n+        region_scope_tree,\n+        owner_def_id,\n+        body,\n+        used_mut_nodes: RefCell::new(FxHashSet()),\n+    };\n \n     // Eventually, borrowck will always read the MIR, but at the\n     // moment we do not. So, for now, we always force MIR to be\n@@ -118,14 +135,19 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n     if let Some(AnalysisData { all_loans,\n                                loans: loan_dfcx,\n                                move_data: flowed_moves }) =\n-        build_borrowck_dataflow_data(bccx, false, body_id,\n+        build_borrowck_dataflow_data(&mut bccx, false, body_id,\n                                      |bccx| {\n                                          cfg = Some(cfg::CFG::new(bccx.tcx, &body));\n                                          cfg.as_mut().unwrap()\n                                      })\n     {\n-        check_loans::check_loans(bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n+        check_loans::check_loans(&mut bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n     }\n+    unused::check(&mut bccx, body);\n+\n+    Rc::new(BorrowCheckResult {\n+        used_mut_nodes: bccx.used_mut_nodes.into_inner(),\n+    })\n }\n \n fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tcx>,\n@@ -198,7 +220,14 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n     let body = tcx.hir.body(body_id);\n-    let mut bccx = BorrowckCtxt { tcx, tables, region_scope_tree, owner_def_id, body };\n+    let mut bccx = BorrowckCtxt {\n+        tcx,\n+        tables,\n+        region_scope_tree,\n+        owner_def_id,\n+        body,\n+        used_mut_nodes: RefCell::new(FxHashSet()),\n+    };\n \n     let dataflow_data = build_borrowck_dataflow_data(&mut bccx, true, body_id, |_| cfg);\n     (bccx, dataflow_data.unwrap())\n@@ -219,6 +248,8 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     owner_def_id: DefId,\n \n     body: &'tcx hir::Body,\n+\n+    used_mut_nodes: RefCell<FxHashSet<HirId>>,\n }\n \n impl<'b, 'tcx: 'b> BorrowckErrors for BorrowckCtxt<'b, 'tcx> {\n@@ -614,11 +645,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let partial = moved_lp.depth() > lp.depth();\n                 let msg = if !has_fork && partial { \"partially \" }\n                           else if has_fork && !has_common { \"collaterally \"}\n-                          else { \"\" };\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess, use_span, E0382,\n-                    \"{} of {}moved value: `{}`\",\n-                    verb, msg, nl);\n+                else { \"\" };\n+                let mut err = self.cannot_act_on_moved_value(use_span,\n+                                                             verb,\n+                                                             msg,\n+                                                             &format!(\"{}\", nl),\n+                                                             Origin::Ast);\n                 let need_note = match lp.ty.sty {\n                     ty::TypeVariants::TyClosure(id, _) => {\n                         let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n@@ -698,10 +730,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             &self,\n             span: Span,\n             lp: &LoanPath<'tcx>) {\n-        span_err!(\n-            self.tcx.sess, span, E0383,\n-            \"partial reinitialization of uninitialized structure `{}`\",\n-            self.loan_path_to_string(lp));\n+        self.cannot_partially_reinit_an_uninit_struct(span,\n+                                                      &self.loan_path_to_string(lp),\n+                                                      Origin::Ast)\n+            .emit();\n     }\n \n     pub fn report_reassigned_immutable_variable(&self,\n@@ -759,11 +791,24 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n                 let mut db = match err.cause {\n                     MutabilityViolation => {\n-                        self.cannot_assign(error_span, &descr, Origin::Ast)\n+                        let mut db = self.cannot_assign(error_span, &descr, Origin::Ast);\n+                        if let mc::NoteClosureEnv(upvar_id) = err.cmt.note {\n+                            let node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_id);\n+                            let sp = self.tcx.hir.span(node_id);\n+                            match self.tcx.sess.codemap().span_to_snippet(sp) {\n+                                Ok(snippet) => {\n+                                    let msg = &format!(\"consider making `{}` mutable\", snippet);\n+                                    db.span_suggestion(sp, msg, format!(\"mut {}\", snippet));\n+                                }\n+                                _ => {\n+                                    db.span_help(sp, \"consider making this binding mutable\");\n+                                }\n+                            }\n+                        }\n+                        db\n                     }\n                     BorrowViolation(euv::ClosureCapture(_)) => {\n-                        struct_span_err!(self.tcx.sess, error_span, E0595,\n-                                         \"closure cannot assign to {}\", descr)\n+                        self.closure_cannot_assign_to_borrowed(error_span, &descr, Origin::Ast)\n                     }\n                     BorrowViolation(euv::OverloadedOperator) |\n                     BorrowViolation(euv::AddrOf) |\n@@ -772,8 +817,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     BorrowViolation(euv::AutoUnsafe) |\n                     BorrowViolation(euv::ForLoop) |\n                     BorrowViolation(euv::MatchDiscriminant) => {\n-                        struct_span_err!(self.tcx.sess, error_span, E0596,\n-                                         \"cannot borrow {} as mutable\", descr)\n+                        self.cannot_borrow_path_as_mutable(error_span, &descr, Origin::Ast)\n                     }\n                     BorrowViolation(euv::ClosureInvocation) => {\n                         span_bug!(err.span,\n@@ -855,21 +899,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n                 if let Some((yield_span, _)) = maybe_borrow_across_yield {\n                     debug!(\"err_out_of_scope: opt_yield_span = {:?}\", yield_span);\n-                    struct_span_err!(self.tcx.sess,\n-                                     error_span,\n-                                     E0626,\n-                                     \"borrow may still be in use when generator yields\")\n-                        .span_label(yield_span, \"possible yield occurs here\")\n+                    self.cannot_borrow_across_generator_yield(error_span, yield_span, Origin::Ast)\n                         .emit();\n                     return;\n                 }\n \n-                let mut db = struct_span_err!(self.tcx.sess,\n-                                              error_span,\n-                                              E0597,\n-                                              \"{} does not live long enough\",\n-                                              msg);\n-\n+                let mut db = self.path_does_not_live_long_enough(error_span, &msg, Origin::Ast);\n                 let (value_kind, value_msg) = match err.cmt.cat {\n                     mc::Categorization::Rvalue(..) =>\n                         (\"temporary value\", \"temporary value created here\"),\n@@ -978,11 +1013,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n             err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n                 let descr = self.cmt_to_path_or_string(&err.cmt);\n-                let mut db = struct_span_err!(self.tcx.sess, error_span, E0598,\n-                                              \"lifetime of {} is too short to guarantee \\\n-                                               its contents can be safely reborrowed\",\n-                                              descr);\n-\n+                let mut db = self.lifetime_too_short_for_reborrow(error_span, &descr, Origin::Ast);\n                 let descr = match opt_loan_path(&err.cmt) {\n                     Some(lp) => {\n                         format!(\"`{}`\", self.loan_path_to_string(&lp))\n@@ -1054,12 +1085,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         let blame = cmt.immutability_blame();\n         let mut err = match blame {\n             Some(ImmutabilityBlame::ClosureEnv(id)) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess, span, E0387,\n-                    \"{} in a captured outer variable in an `Fn` closure\", prefix);\n-\n                 // FIXME: the distinction between these 2 messages looks wrong.\n-                let help = if let BorrowViolation(euv::ClosureCapture(_)) = kind {\n+                let help_msg = if let BorrowViolation(euv::ClosureCapture(_)) = kind {\n                     // The aliasability violation with closure captures can\n                     // happen for nested closures, so we know the enclosing\n                     // closure incorrectly accepts an `Fn` while it needs to\n@@ -1070,15 +1097,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     \"consider changing this closure to take self by mutable reference\"\n                 };\n                 let node_id = self.tcx.hir.def_index_to_node_id(id);\n-                err.span_help(self.tcx.hir.span(node_id), help);\n-                err\n+                let help_span = self.tcx.hir.span(node_id);\n+                self.cannot_act_on_capture_in_sharable_fn(span,\n+                                                          prefix,\n+                                                          (help_span, help_msg),\n+                                                          Origin::Ast)\n             }\n             _ =>  {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess, span, E0389,\n-                    \"{} in a `&` reference\", prefix);\n-                err.span_label(span, \"assignment into an immutable reference\");\n-                err\n+                self.cannot_assign_into_immutable_reference(span, prefix,\n+                                                            Origin::Ast)\n             }\n         };\n         self.note_immutability_blame(&mut err, blame);\n@@ -1230,17 +1257,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 Err(_) => format!(\"move |<args>| <body>\")\n             };\n \n-        struct_span_err!(self.tcx.sess, err.span, E0373,\n-                         \"closure may outlive the current function, \\\n-                          but it borrows {}, \\\n-                          which is owned by the current function\",\n-                         cmt_path_or_string)\n-            .span_label(capture_span,\n-                       format!(\"{} is borrowed here\",\n-                                cmt_path_or_string))\n-            .span_label(err.span,\n-                       format!(\"may outlive borrowed value {}\",\n-                                cmt_path_or_string))\n+        self.cannot_capture_in_long_lived_closure(err.span,\n+                                                  &cmt_path_or_string,\n+                                                  capture_span,\n+                                                  Origin::Ast)\n             .span_suggestion(err.span,\n                              &format!(\"to force the closure to take ownership of {} \\\n                                        (and any other referenced variables), \\"}, {"sha": "228824b663d66ed8114ffd37b048f9815836a117", "filename": "src/librustc_borrowck/borrowck/unused.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -0,0 +1,118 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n+use rustc::hir::{self, HirId};\n+use rustc::lint::builtin::UNUSED_MUT;\n+use rustc::ty;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use rustc_back::slice;\n+use syntax::ptr::P;\n+\n+use borrowck::BorrowckCtxt;\n+\n+pub fn check<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, body: &'tcx hir::Body) {\n+    let mut used_mut = bccx.used_mut_nodes.borrow().clone();\n+    UsedMutFinder {\n+        bccx,\n+        set: &mut used_mut,\n+    }.visit_expr(&body.value);\n+    let mut cx = UnusedMutCx { bccx, used_mut };\n+    for arg in body.arguments.iter() {\n+        cx.check_unused_mut_pat(slice::ref_slice(&arg.pat));\n+    }\n+    cx.visit_expr(&body.value);\n+}\n+\n+struct UsedMutFinder<'a, 'tcx: 'a> {\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n+    set: &'a mut FxHashSet<HirId>,\n+}\n+\n+struct UnusedMutCx<'a, 'tcx: 'a> {\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n+    used_mut: FxHashSet<HirId>,\n+}\n+\n+impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n+    fn check_unused_mut_pat(&self, pats: &[P<hir::Pat>]) {\n+        let tcx = self.bccx.tcx;\n+        let mut mutables = FxHashMap();\n+        for p in pats {\n+            p.each_binding(|_, id, span, path1| {\n+                let name = path1.node;\n+\n+                // Skip anything that looks like `_foo`\n+                if name.as_str().starts_with(\"_\") {\n+                    return\n+                }\n+\n+                // Skip anything that looks like `&foo` or `&mut foo`, only look\n+                // for by-value bindings\n+                let hir_id = tcx.hir.node_to_hir_id(id);\n+                let bm = match self.bccx.tables.pat_binding_modes().get(hir_id) {\n+                    Some(&bm) => bm,\n+                    None => span_bug!(span, \"missing binding mode\"),\n+                };\n+                match bm {\n+                    ty::BindByValue(hir::MutMutable) => {}\n+                    _ => return,\n+                }\n+\n+                mutables.entry(name).or_insert(Vec::new()).push((id, hir_id, span));\n+            });\n+        }\n+\n+        for (_name, ids) in mutables {\n+            // If any id for this name was used mutably then consider them all\n+            // ok, so move on to the next\n+            if ids.iter().any(|&(_, ref id, _)| self.used_mut.contains(id)) {\n+                continue\n+            }\n+\n+            let mut_span = tcx.sess.codemap().span_until_char(ids[0].2, ' ');\n+\n+            // Ok, every name wasn't used mutably, so issue a warning that this\n+            // didn't need to be mutable.\n+            tcx.struct_span_lint_node(UNUSED_MUT,\n+                                      ids[0].0,\n+                                      ids[0].2,\n+                                      \"variable does not need to be mutable\")\n+                .span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned())\n+                .emit();\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for UnusedMutCx<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.hir)\n+    }\n+\n+    fn visit_arm(&mut self, arm: &hir::Arm) {\n+        self.check_unused_mut_pat(&arm.pats)\n+    }\n+\n+    fn visit_local(&mut self, local: &hir::Local) {\n+        self.check_unused_mut_pat(slice::ref_slice(&local.pat));\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for UsedMutFinder<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.hir)\n+    }\n+\n+    fn visit_nested_body(&mut self, id: hir::BodyId) {\n+        let def_id = self.bccx.tcx.hir.body_owner_def_id(id);\n+        self.set.extend(self.bccx.tcx.borrowck(def_id).used_mut_nodes.iter().cloned());\n+        self.visit_body(self.bccx.tcx.hir.body(id));\n+    }\n+}"}, {"sha": "3fea01443be4b9d34fa31d68024bdea9ed4037dd", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 735, "changes": 735, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -9,738 +9,3 @@\n // except according to those terms.\n \n #![allow(non_snake_case)]\n-\n-register_long_diagnostics! {\n-\n-E0373: r##\"\n-This error occurs when an attempt is made to use data captured by a closure,\n-when that data may no longer exist. It's most commonly seen when attempting to\n-return a closure:\n-\n-```compile_fail,E0373\n-fn foo() -> Box<Fn(u32) -> u32> {\n-    let x = 0u32;\n-    Box::new(|y| x + y)\n-}\n-```\n-\n-Notice that `x` is stack-allocated by `foo()`. By default, Rust captures\n-closed-over data by reference. This means that once `foo()` returns, `x` no\n-longer exists. An attempt to access `x` within the closure would thus be\n-unsafe.\n-\n-Another situation where this might be encountered is when spawning threads:\n-\n-```compile_fail,E0373\n-fn foo() {\n-    let x = 0u32;\n-    let y = 1u32;\n-\n-    let thr = std::thread::spawn(|| {\n-        x + y\n-    });\n-}\n-```\n-\n-Since our new thread runs in parallel, the stack frame containing `x` and `y`\n-may well have disappeared by the time we try to use them. Even if we call\n-`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\n-stack frame won't disappear), we will not succeed: the compiler cannot prove\n-that this behaviour is safe, and so won't let us do it.\n-\n-The solution to this problem is usually to switch to using a `move` closure.\n-This approach moves (or copies, where possible) data into the closure, rather\n-than taking references to it. For example:\n-\n-```\n-fn foo() -> Box<Fn(u32) -> u32> {\n-    let x = 0u32;\n-    Box::new(move |y| x + y)\n-}\n-```\n-\n-Now that the closure has its own copy of the data, there's no need to worry\n-about safety.\n-\"##,\n-\n-E0382: r##\"\n-This error occurs when an attempt is made to use a variable after its contents\n-have been moved elsewhere. For example:\n-\n-```compile_fail,E0382\n-struct MyStruct { s: u32 }\n-\n-fn main() {\n-    let mut x = MyStruct{ s: 5u32 };\n-    let y = x;\n-    x.s = 6;\n-    println!(\"{}\", x.s);\n-}\n-```\n-\n-Since `MyStruct` is a type that is not marked `Copy`, the data gets moved out\n-of `x` when we set `y`. This is fundamental to Rust's ownership system: outside\n-of workarounds like `Rc`, a value cannot be owned by more than one variable.\n-\n-If we own the type, the easiest way to address this problem is to implement\n-`Copy` and `Clone` on it, as shown below. This allows `y` to copy the\n-information in `x`, while leaving the original version owned by `x`. Subsequent\n-changes to `x` will not be reflected when accessing `y`.\n-\n-```\n-#[derive(Copy, Clone)]\n-struct MyStruct { s: u32 }\n-\n-fn main() {\n-    let mut x = MyStruct{ s: 5u32 };\n-    let y = x;\n-    x.s = 6;\n-    println!(\"{}\", x.s);\n-}\n-```\n-\n-Alternatively, if we don't control the struct's definition, or mutable shared\n-ownership is truly required, we can use `Rc` and `RefCell`:\n-\n-```\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-\n-struct MyStruct { s: u32 }\n-\n-fn main() {\n-    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n-    let y = x.clone();\n-    x.borrow_mut().s = 6;\n-    println!(\"{}\", x.borrow().s);\n-}\n-```\n-\n-With this approach, x and y share ownership of the data via the `Rc` (reference\n-count type). `RefCell` essentially performs runtime borrow checking: ensuring\n-that at most one writer or multiple readers can access the data at any one time.\n-\n-If you wish to learn more about ownership in Rust, start with the chapter in the\n-Book:\n-\n-https://doc.rust-lang.org/book/first-edition/ownership.html\n-\"##,\n-\n-E0383: r##\"\n-This error occurs when an attempt is made to partially reinitialize a\n-structure that is currently uninitialized.\n-\n-For example, this can happen when a drop has taken place:\n-\n-```compile_fail,E0383\n-struct Foo {\n-    a: u32,\n-}\n-impl Drop for Foo {\n-    fn drop(&mut self) { /* ... */ }\n-}\n-\n-let mut x = Foo { a: 1 };\n-drop(x); // `x` is now uninitialized\n-x.a = 2; // error, partial reinitialization of uninitialized structure `t`\n-```\n-\n-This error can be fixed by fully reinitializing the structure in question:\n-\n-```\n-struct Foo {\n-    a: u32,\n-}\n-impl Drop for Foo {\n-    fn drop(&mut self) { /* ... */ }\n-}\n-\n-let mut x = Foo { a: 1 };\n-drop(x);\n-x = Foo { a: 2 };\n-```\n-\"##,\n-\n-/*E0386: r##\"\n-This error occurs when an attempt is made to mutate the target of a mutable\n-reference stored inside an immutable container.\n-\n-For example, this can happen when storing a `&mut` inside an immutable `Box`:\n-\n-```compile_fail,E0386\n-let mut x: i64 = 1;\n-let y: Box<_> = Box::new(&mut x);\n-**y = 2; // error, cannot assign to data in an immutable container\n-```\n-\n-This error can be fixed by making the container mutable:\n-\n-```\n-let mut x: i64 = 1;\n-let mut y: Box<_> = Box::new(&mut x);\n-**y = 2;\n-```\n-\n-It can also be fixed by using a type with interior mutability, such as `Cell`\n-or `RefCell`:\n-\n-```\n-use std::cell::Cell;\n-\n-let x: i64 = 1;\n-let y: Box<Cell<_>> = Box::new(Cell::new(x));\n-y.set(2);\n-```\n-\"##,*/\n-\n-E0387: r##\"\n-This error occurs when an attempt is made to mutate or mutably reference data\n-that a closure has captured immutably. Examples of this error are shown below:\n-\n-```compile_fail,E0387\n-// Accepts a function or a closure that captures its environment immutably.\n-// Closures passed to foo will not be able to mutate their closed-over state.\n-fn foo<F: Fn()>(f: F) { }\n-\n-// Attempts to mutate closed-over data. Error message reads:\n-// `cannot assign to data in a captured outer variable...`\n-fn mutable() {\n-    let mut x = 0u32;\n-    foo(|| x = 2);\n-}\n-\n-// Attempts to take a mutable reference to closed-over data.  Error message\n-// reads: `cannot borrow data mutably in a captured outer variable...`\n-fn mut_addr() {\n-    let mut x = 0u32;\n-    foo(|| { let y = &mut x; });\n-}\n-```\n-\n-The problem here is that foo is defined as accepting a parameter of type `Fn`.\n-Closures passed into foo will thus be inferred to be of type `Fn`, meaning that\n-they capture their context immutably.\n-\n-If the definition of `foo` is under your control, the simplest solution is to\n-capture the data mutably. This can be done by defining `foo` to take FnMut\n-rather than Fn:\n-\n-```\n-fn foo<F: FnMut()>(f: F) { }\n-```\n-\n-Alternatively, we can consider using the `Cell` and `RefCell` types to achieve\n-interior mutability through a shared reference. Our example's `mutable`\n-function could be redefined as below:\n-\n-```\n-use std::cell::Cell;\n-\n-fn foo<F: Fn()>(f: F) { }\n-\n-fn mutable() {\n-    let x = Cell::new(0u32);\n-    foo(|| x.set(2));\n-}\n-```\n-\n-You can read more about cell types in the API documentation:\n-\n-https://doc.rust-lang.org/std/cell/\n-\"##,\n-\n-E0388: r##\"\n-E0388 was removed and is no longer issued.\n-\"##,\n-\n-E0389: r##\"\n-An attempt was made to mutate data using a non-mutable reference. This\n-commonly occurs when attempting to assign to a non-mutable reference of a\n-mutable reference (`&(&mut T)`).\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0389\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-    let fancy_ref = &(&mut fancy);\n-    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\n-Here, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an\n-immutable reference to a value borrows it immutably. There can be multiple\n-references of type `&(&mut T)` that point to the same value, so they must be\n-immutable to prevent multiple mutable references to the same value.\n-\n-To fix this, either remove the outer reference:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-\n-    let fancy_ref = &mut fancy;\n-    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)\n-\n-    fancy_ref.num = 6; // No error!\n-\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\n-Or make the outer reference mutable:\n-\n-```\n-struct FancyNum {\n-    num: u8\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-\n-    let fancy_ref = &mut (&mut fancy);\n-    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)\n-\n-    fancy_ref.num = 6; // No error!\n-\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\"##,\n-\n-E0507: r##\"\n-You tried to move out of a value which was borrowed. Erroneous code example:\n-\n-```compile_fail,E0507\n-use std::cell::RefCell;\n-\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-\n-    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n-}\n-```\n-\n-Here, the `nothing_is_true` method takes the ownership of `self`. However,\n-`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\n-which is a borrow of the content owned by the `RefCell`. To fix this error,\n-you have three choices:\n-\n-* Try to avoid moving the variable.\n-* Somehow reclaim the ownership.\n-* Implement the `Copy` trait on the type.\n-\n-Examples:\n-\n-```\n-use std::cell::RefCell;\n-\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(&self) {} // First case, we don't take ownership\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-\n-    x.borrow().nothing_is_true(); // ok!\n-}\n-```\n-\n-Or:\n-\n-```\n-use std::cell::RefCell;\n-\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-    let x = x.into_inner(); // we get back ownership\n-\n-    x.nothing_is_true(); // ok!\n-}\n-```\n-\n-Or:\n-\n-```\n-use std::cell::RefCell;\n-\n-#[derive(Clone, Copy)] // we implement the Copy trait\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-\n-    x.borrow().nothing_is_true(); // ok!\n-}\n-```\n-\n-Moving a member out of a mutably borrowed struct will also cause E0507 error:\n-\n-```compile_fail,E0507\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-struct Batcave {\n-    knight: TheDarkKnight\n-}\n-\n-fn main() {\n-    let mut cave = Batcave {\n-        knight: TheDarkKnight\n-    };\n-    let borrowed = &mut cave;\n-\n-    borrowed.knight.nothing_is_true(); // E0507\n-}\n-```\n-\n-It is fine only if you put something back. `mem::replace` can be used for that:\n-\n-```\n-# struct TheDarkKnight;\n-# impl TheDarkKnight { fn nothing_is_true(self) {} }\n-# struct Batcave { knight: TheDarkKnight }\n-use std::mem;\n-\n-let mut cave = Batcave {\n-    knight: TheDarkKnight\n-};\n-let borrowed = &mut cave;\n-\n-mem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n-```\n-\n-You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n-\"##,\n-\n-E0508: r##\"\n-A value was moved out of a non-copy fixed-size array.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0508\n-struct NonCopy;\n-\n-fn main() {\n-    let array = [NonCopy; 1];\n-    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,\n-                           //        a non-copy fixed-size array\n-}\n-```\n-\n-The first element was moved out of the array, but this is not\n-possible because `NonCopy` does not implement the `Copy` trait.\n-\n-Consider borrowing the element instead of moving it:\n-\n-```\n-struct NonCopy;\n-\n-fn main() {\n-    let array = [NonCopy; 1];\n-    let _value = &array[0]; // Borrowing is allowed, unlike moving.\n-}\n-```\n-\n-Alternatively, if your type implements `Clone` and you need to own the value,\n-consider borrowing and then cloning:\n-\n-```\n-#[derive(Clone)]\n-struct NonCopy;\n-\n-fn main() {\n-    let array = [NonCopy; 1];\n-    // Now you can clone the array element.\n-    let _value = array[0].clone();\n-}\n-```\n-\"##,\n-\n-E0509: r##\"\n-This error occurs when an attempt is made to move out of a value whose type\n-implements the `Drop` trait.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0509\n-struct FancyNum {\n-    num: usize\n-}\n-\n-struct DropStruct {\n-    fancy: FancyNum\n-}\n-\n-impl Drop for DropStruct {\n-    fn drop(&mut self) {\n-        // Destruct DropStruct, possibly using FancyNum\n-    }\n-}\n-\n-fn main() {\n-    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n-    let fancy_field = drop_struct.fancy; // Error E0509\n-    println!(\"Fancy: {}\", fancy_field.num);\n-    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n-}\n-```\n-\n-Here, we tried to move a field out of a struct of type `DropStruct` which\n-implements the `Drop` trait. However, a struct cannot be dropped if one or\n-more of its fields have been moved.\n-\n-Structs implementing the `Drop` trait have an implicit destructor that gets\n-called when they go out of scope. This destructor may use the fields of the\n-struct, so moving out of the struct could make it impossible to run the\n-destructor. Therefore, we must think of all values whose type implements the\n-`Drop` trait as single units whose fields cannot be moved.\n-\n-This error can be fixed by creating a reference to the fields of a struct,\n-enum, or tuple using the `ref` keyword:\n-\n-```\n-struct FancyNum {\n-    num: usize\n-}\n-\n-struct DropStruct {\n-    fancy: FancyNum\n-}\n-\n-impl Drop for DropStruct {\n-    fn drop(&mut self) {\n-        // Destruct DropStruct, possibly using FancyNum\n-    }\n-}\n-\n-fn main() {\n-    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n-    let ref fancy_field = drop_struct.fancy; // No more errors!\n-    println!(\"Fancy: {}\", fancy_field.num);\n-    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n-}\n-```\n-\n-Note that this technique can also be used in the arms of a match expression:\n-\n-```\n-struct FancyNum {\n-    num: usize\n-}\n-\n-enum DropEnum {\n-    Fancy(FancyNum)\n-}\n-\n-impl Drop for DropEnum {\n-    fn drop(&mut self) {\n-        // Destruct DropEnum, possibly using FancyNum\n-    }\n-}\n-\n-fn main() {\n-    // Creates and enum of type `DropEnum`, which implements `Drop`\n-    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});\n-    match drop_enum {\n-        // Creates a reference to the inside of `DropEnum::Fancy`\n-        DropEnum::Fancy(ref fancy_field) => // No error!\n-            println!(\"It was fancy-- {}!\", fancy_field.num),\n-    }\n-    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope\n-}\n-```\n-\"##,\n-\n-E0595: r##\"\n-Closures cannot mutate immutable captured variables.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0595\n-let x = 3; // error: closure cannot assign to immutable local variable `x`\n-let mut c = || { x += 1 };\n-```\n-\n-Make the variable binding mutable:\n-\n-```\n-let mut x = 3; // ok!\n-let mut c = || { x += 1 };\n-```\n-\"##,\n-\n-E0596: r##\"\n-This error occurs because you tried to mutably borrow a non-mutable variable.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0596\n-let x = 1;\n-let y = &mut x; // error: cannot borrow mutably\n-```\n-\n-In here, `x` isn't mutable, so when we try to mutably borrow it in `y`, it\n-fails. To fix this error, you need to make `x` mutable:\n-\n-```\n-let mut x = 1;\n-let y = &mut x; // ok!\n-```\n-\"##,\n-\n-E0597: r##\"\n-This error occurs because a borrow was made inside a variable which has a\n-greater lifetime than the borrowed one.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0597\n-struct Foo<'a> {\n-    x: Option<&'a u32>,\n-}\n-\n-let mut x = Foo { x: None };\n-let y = 0;\n-x.x = Some(&y); // error: `y` does not live long enough\n-```\n-\n-In here, `x` is created before `y` and therefore has a greater lifetime. Always\n-keep in mind that values in a scope are dropped in the opposite order they are\n-created. So to fix the previous example, just make the `y` lifetime greater than\n-the `x`'s one:\n-\n-```\n-struct Foo<'a> {\n-    x: Option<&'a u32>,\n-}\n-\n-let y = 0;\n-let mut x = Foo { x: None };\n-x.x = Some(&y);\n-```\n-\"##,\n-\n-E0626: r##\"\n-This error occurs because a borrow in a generator persists across a\n-yield point.\n-\n-```compile_fail,E0626\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-    let a = &String::new(); // <-- This borrow...\n-    yield (); // ...is still in scope here, when the yield occurs.\n-    println!(\"{}\", a);\n-};\n-b.resume();\n-```\n-\n-At present, it is not permitted to have a yield that occurs while a\n-borrow is still in scope. To resolve this error, the borrow must\n-either be \"contained\" to a smaller scope that does not overlap the\n-yield or else eliminated in another way. So, for example, we might\n-resolve the previous example by removing the borrow and just storing\n-the integer by value:\n-\n-```\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-    let a = 3;\n-    yield ();\n-    println!(\"{}\", a);\n-};\n-b.resume();\n-```\n-\n-This is a very simple case, of course. In more complex cases, we may\n-wish to have more than one reference to the value that was borrowed --\n-in those cases, something like the `Rc` or `Arc` types may be useful.\n-\n-This error also frequently arises with iteration:\n-\n-```compile_fail,E0626\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  for &x in &v { // <-- borrow of `v` is still in scope...\n-    yield x; // ...when this yield occurs.\n-  }\n-};\n-b.resume();\n-```\n-\n-Such cases can sometimes be resolved by iterating \"by value\" (or using\n-`into_iter()`) to avoid borrowing:\n-\n-```\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  for x in v { // <-- Take ownership of the values instead!\n-    yield x; // <-- Now yield is OK.\n-  }\n-};\n-b.resume();\n-```\n-\n-If taking ownership is not an option, using indices can work too:\n-\n-```\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  let len = v.len(); // (*)\n-  for i in 0..len {\n-    let x = v[i]; // (*)\n-    yield x; // <-- Now yield is OK.\n-  }\n-};\n-b.resume();\n-\n-// (*) -- Unfortunately, these temporaries are currently required.\n-// See <https://github.com/rust-lang/rust/issues/43122>.\n-```\n-\"##,\n-\n-}\n-\n-register_diagnostics! {\n-//    E0385, // {} in an aliasable location\n-    E0598, // lifetime of {} is too short to guarantee its contents can be...\n-}"}, {"sha": "78aacd49f807dafafc8ae37f7f29db8ed6e81e27", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -16,12 +16,12 @@\n #![allow(non_camel_case_types)]\n \n #![feature(quote)]\n-#![feature(rustc_diagnostic_macros)]\n \n #[macro_use] extern crate log;\n-#[macro_use] extern crate syntax;\n+extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n+extern crate rustc_back;\n \n // for \"clarity\", rename the graphviz crate to dot; graphviz within `borrowck`\n // refers to the borrowck-specific graphviz adapter traits.\n@@ -33,14 +33,8 @@ extern crate rustc_mir;\n pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;\n \n-// NB: This module needs to be declared first so diagnostics are\n-// registered before they are used.\n-mod diagnostics;\n-\n mod borrowck;\n \n pub mod graphviz;\n \n pub use borrowck::provide;\n-\n-__build_diagnostic_array! { librustc_borrowck, DIAGNOSTICS }"}, {"sha": "08f3b0a4c5fd1cfd0e1104fa852a58d7f1c14723", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -25,7 +25,7 @@ use pattern::{PatternFoldable, PatternFolder};\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::RangeEnd;\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rustc::mir::Field;\n use rustc::util::common::ErrorReported;\n@@ -202,21 +202,19 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n \n     fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n         if self.tcx.sess.features.borrow().never_type {\n-            ty.is_uninhabited_from(self.module, self.tcx)\n+            self.tcx.is_ty_uninhabited_from(self.module, ty)\n         } else {\n             false\n         }\n     }\n \n     fn is_variant_uninhabited(&self,\n                               variant: &'tcx ty::VariantDef,\n-                              substs: &'tcx ty::subst::Substs<'tcx>) -> bool\n+                              substs: &'tcx ty::subst::Substs<'tcx>)\n+                              -> bool\n     {\n         if self.tcx.sess.features.borrow().never_type {\n-            let forest = variant.uninhabited_from(\n-                &mut FxHashMap::default(), self.tcx, substs, AdtKind::Enum\n-            );\n-            forest.contains(self.tcx, self.module)\n+            self.tcx.is_enum_variant_uninhabited_from(self.module, variant, substs)\n         } else {\n             false\n         }"}, {"sha": "e6a04c9c57a6c05eba0cf2b049b28beb37546a67", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -192,7 +192,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             let module = self.tcx.hir.get_module_parent(scrut.id);\n             if inlined_arms.is_empty() {\n                 let scrutinee_is_uninhabited = if self.tcx.sess.features.borrow().never_type {\n-                    pat_ty.is_uninhabited_from(module, self.tcx)\n+                    self.tcx.is_ty_uninhabited_from(module, pat_ty)\n                 } else {\n                     self.conservative_is_uninhabited(pat_ty)\n                 };\n@@ -526,7 +526,7 @@ fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n     let mut checker = MutationChecker {\n         cx,\n     };\n-    ExprUseVisitor::new(&mut checker, cx.tcx, cx.param_env, cx.region_scope_tree, cx.tables)\n+    ExprUseVisitor::new(&mut checker, cx.tcx, cx.param_env, cx.region_scope_tree, cx.tables, None)\n         .walk_expr(guard);\n }\n "}, {"sha": "56d5f5ffa3f6c6abe2756878357433892b529e70", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -31,7 +31,7 @@\n //! be indexed by the direction (see the type `Direction`).\n \n use bitvec::BitVector;\n-use std::fmt::{Formatter, Error, Debug};\n+use std::fmt::Debug;\n use std::usize;\n use snapshot_vec::{SnapshotVec, SnapshotVecDelegate};\n \n@@ -48,6 +48,7 @@ pub struct Node<N> {\n     pub data: N,\n }\n \n+#[derive(Debug)]\n pub struct Edge<E> {\n     next_edge: [EdgeIndex; 2], // see module comment\n     source: NodeIndex,\n@@ -69,18 +70,6 @@ impl<N> SnapshotVecDelegate for Edge<N> {\n     fn reverse(_: &mut Vec<Edge<N>>, _: ()) {}\n }\n \n-impl<E: Debug> Debug for Edge<E> {\n-    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n-        write!(f,\n-               \"Edge {{ next_edge: [{:?}, {:?}], source: {:?}, target: {:?}, data: {:?} }}\",\n-               self.next_edge[0],\n-               self.next_edge[1],\n-               self.source,\n-               self.target,\n-               self.data)\n-    }\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub struct NodeIndex(pub usize);\n "}, {"sha": "1d1b367de200eead52088b3b4440ebb678b5b377", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -40,39 +40,80 @@ impl Idx for u32 {\n \n #[macro_export]\n macro_rules! newtype_index {\n+    // ---- public rules ----\n+\n+    // Use default constants\n     ($name:ident) => (\n-        newtype_index!($name, unsafe { ::std::intrinsics::type_name::<$name>() });\n+        newtype_index!(\n+            @type[$name]\n+            @max[::std::u32::MAX]\n+            @debug_name[unsafe {::std::intrinsics::type_name::<$name>() }]);\n+    );\n+\n+    // Define any constants\n+    ($name:ident { $($tokens:tt)+ }) => (\n+        newtype_index!(\n+            @type[$name]\n+            @max[::std::u32::MAX]\n+            @debug_name[unsafe {::std::intrinsics::type_name::<$name>() }]\n+            $($tokens)+);\n     );\n \n-    ($name:ident, $debug_name:expr) => (\n+    // ---- private rules ----\n+\n+    // Base case, user-defined constants (if any) have already been defined\n+    (@type[$type:ident] @max[$max:expr] @debug_name[$debug_name:expr]) => (\n         #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord,\n-         RustcEncodable, RustcDecodable)]\n-        pub struct $name(u32);\n-\n-        impl $name {\n-            // HACK use for constants\n-            #[allow(unused)]\n-            const fn const_new(x: u32) -> Self {\n-                $name(x)\n-            }\n-        }\n+            RustcEncodable, RustcDecodable)]\n+        pub struct $type(pub u32);\n \n-        impl Idx for $name {\n+        impl Idx for $type {\n             fn new(value: usize) -> Self {\n-                assert!(value < (::std::u32::MAX) as usize);\n-                $name(value as u32)\n+                assert!(value < ($max) as usize);\n+                $type(value as u32)\n             }\n             fn index(self) -> usize {\n                 self.0 as usize\n             }\n         }\n \n-        impl ::std::fmt::Debug for $name {\n+        impl ::std::fmt::Debug for $type {\n             fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n                 write!(fmt, \"{}{}\", $debug_name, self.0)\n             }\n         }\n-    )\n+    );\n+\n+    // Rewrite final without comma to one that includes comma\n+    (@type[$type:ident] @max[$max:expr] @debug_name[$debug_name:expr]\n+            $name:ident = $constant:expr) => (\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $name = $constant,);\n+    );\n+\n+    // Rewrite final const without comma to one that includes comma\n+    (@type[$type:ident] @max[$_max:expr] @debug_name[$debug_name:expr]\n+            const $name:ident = $constant:expr) => (\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] const $name = $constant,);\n+    );\n+\n+    // Replace existing default for max\n+    (@type[$type:ident] @max[$_max:expr] @debug_name[$debug_name:expr]\n+            MAX = $max:expr, $($tokens:tt)*) => (\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $($tokens)*);\n+    );\n+\n+    // Replace existing default for debug_name\n+    (@type[$type:ident] @max[$max:expr] @debug_name[$_debug_name:expr]\n+            DEBUG_NAME = $debug_name:expr, $($tokens:tt)*) => (\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $($tokens)*);\n+    );\n+\n+    // Assign a user-defined constant (as final param)\n+    (@type[$type:ident] @max[$max:expr] @debug_name[$debug_name:expr]\n+            const $name:ident = $constant:expr, $($tokens:tt)*) => (\n+        pub const $name: $type = $type($constant);\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $($tokens)*);\n+    );\n }\n \n #[derive(Clone, PartialEq, Eq)]"}, {"sha": "3a20343033c233af91d976973b83e54e0b8ca37c", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -28,6 +28,7 @@\n #![feature(fn_traits)]\n #![feature(unsize)]\n #![feature(i128_type)]\n+#![feature(i128)]\n #![feature(conservative_impl_trait)]\n #![feature(specialization)]\n \n@@ -54,6 +55,7 @@ pub mod graph;\n pub mod indexed_set;\n pub mod indexed_vec;\n pub mod obligation_forest;\n+pub mod sip128;\n pub mod snapshot_map;\n pub mod snapshot_vec;\n pub mod stable_hasher;"}, {"sha": "1f0b0d9cbfb0b54f9c9a6af05aa598805b1c736a", "filename": "src/librustc_data_structures/sip128.rs", "status": "added", "additions": 533, "deletions": 0, "changes": 533, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_data_structures%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_data_structures%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsip128.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -0,0 +1,533 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This is a copy of `core::hash::sip` adapted to providing 128 bit hashes.\n+\n+use std::cmp;\n+use std::hash::Hasher;\n+use std::slice;\n+use std::ptr;\n+use std::mem;\n+\n+#[derive(Debug, Clone)]\n+pub struct SipHasher128 {\n+    k0: u64,\n+    k1: u64,\n+    length: usize, // how many bytes we've processed\n+    state: State, // hash State\n+    tail: u64, // unprocessed bytes le\n+    ntail: usize, // how many bytes in tail are valid\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+#[repr(C)]\n+struct State {\n+    // v0, v2 and v1, v3 show up in pairs in the algorithm,\n+    // and simd implementations of SipHash will use vectors\n+    // of v02 and v13. By placing them in this order in the struct,\n+    // the compiler can pick up on just a few simd optimizations by itself.\n+    v0: u64,\n+    v2: u64,\n+    v1: u64,\n+    v3: u64,\n+}\n+\n+macro_rules! compress {\n+    ($state:expr) => ({\n+        compress!($state.v0, $state.v1, $state.v2, $state.v3)\n+    });\n+    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n+    ({\n+        $v0 = $v0.wrapping_add($v1); $v1 = $v1.rotate_left(13); $v1 ^= $v0;\n+        $v0 = $v0.rotate_left(32);\n+        $v2 = $v2.wrapping_add($v3); $v3 = $v3.rotate_left(16); $v3 ^= $v2;\n+        $v0 = $v0.wrapping_add($v3); $v3 = $v3.rotate_left(21); $v3 ^= $v0;\n+        $v2 = $v2.wrapping_add($v1); $v1 = $v1.rotate_left(17); $v1 ^= $v2;\n+        $v2 = $v2.rotate_left(32);\n+    });\n+}\n+\n+/// Load an integer of the desired type from a byte stream, in LE order. Uses\n+/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n+/// to load it from a possibly unaligned address.\n+///\n+/// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\n+macro_rules! load_int_le {\n+    ($buf:expr, $i:expr, $int_ty:ident) =>\n+    ({\n+       debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n+       let mut data = 0 as $int_ty;\n+       ptr::copy_nonoverlapping($buf.get_unchecked($i),\n+                                &mut data as *mut _ as *mut u8,\n+                                mem::size_of::<$int_ty>());\n+       data.to_le()\n+    });\n+}\n+\n+/// Load an u64 using up to 7 bytes of a byte slice.\n+///\n+/// Unsafe because: unchecked indexing at start..start+len\n+#[inline]\n+unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n+    debug_assert!(len < 8);\n+    let mut i = 0; // current byte index (from LSB) in the output u64\n+    let mut out = 0;\n+    if i + 3 < len {\n+        out = load_int_le!(buf, start + i, u32) as u64;\n+        i += 4;\n+    }\n+    if i + 1 < len {\n+        out |= (load_int_le!(buf, start + i, u16) as u64) << (i * 8);\n+        i += 2\n+    }\n+    if i < len {\n+        out |= (*buf.get_unchecked(start + i) as u64) << (i * 8);\n+        i += 1;\n+    }\n+    debug_assert_eq!(i, len);\n+    out\n+}\n+\n+\n+impl SipHasher128 {\n+    #[inline]\n+    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher128 {\n+        let mut state = SipHasher128 {\n+            k0: key0,\n+            k1: key1,\n+            length: 0,\n+            state: State {\n+                v0: 0,\n+                v1: 0,\n+                v2: 0,\n+                v3: 0,\n+            },\n+            tail: 0,\n+            ntail: 0,\n+        };\n+        state.reset();\n+        state\n+    }\n+\n+    #[inline]\n+    fn reset(&mut self) {\n+        self.length = 0;\n+        self.state.v0 = self.k0 ^ 0x736f6d6570736575;\n+        self.state.v1 = self.k1 ^ 0x646f72616e646f6d;\n+        self.state.v2 = self.k0 ^ 0x6c7967656e657261;\n+        self.state.v3 = self.k1 ^ 0x7465646279746573;\n+        self.ntail = 0;\n+\n+        // This is only done in the 128 bit version:\n+        self.state.v1 ^= 0xee;\n+    }\n+\n+    // Specialized write function that is only valid for buffers with len <= 8.\n+    // It's used to force inlining of write_u8 and write_usize, those would normally be inlined\n+    // except for composite types (that includes slices and str hashing because of delimiter).\n+    // Without this extra push the compiler is very reluctant to inline delimiter writes,\n+    // degrading performance substantially for the most common use cases.\n+    #[inline]\n+    fn short_write(&mut self, msg: &[u8]) {\n+        debug_assert!(msg.len() <= 8);\n+        let length = msg.len();\n+        self.length += length;\n+\n+        let needed = 8 - self.ntail;\n+        let fill = cmp::min(length, needed);\n+        if fill == 8 {\n+            self.tail = unsafe { load_int_le!(msg, 0, u64) };\n+        } else {\n+            self.tail |= unsafe { u8to64_le(msg, 0, fill) } << (8 * self.ntail);\n+            if length < needed {\n+                self.ntail += length;\n+                return;\n+            }\n+        }\n+        self.state.v3 ^= self.tail;\n+        Sip24Rounds::c_rounds(&mut self.state);\n+        self.state.v0 ^= self.tail;\n+\n+        // Buffered tail is now flushed, process new input.\n+        self.ntail = length - needed;\n+        self.tail = unsafe { u8to64_le(msg, needed, self.ntail) };\n+    }\n+\n+    #[inline(always)]\n+    fn short_write_gen<T>(&mut self, x: T) {\n+        let bytes = unsafe {\n+            slice::from_raw_parts(&x as *const T as *const u8, mem::size_of::<T>())\n+        };\n+        self.short_write(bytes);\n+    }\n+\n+    #[inline]\n+    pub fn finish128(mut self) -> (u64, u64) {\n+        let b: u64 = ((self.length as u64 & 0xff) << 56) | self.tail;\n+\n+        self.state.v3 ^= b;\n+        Sip24Rounds::c_rounds(&mut self.state);\n+        self.state.v0 ^= b;\n+\n+        self.state.v2 ^= 0xee;\n+        Sip24Rounds::d_rounds(&mut self.state);\n+        let _0 = self.state.v0 ^ self.state.v1 ^ self.state.v2 ^ self.state.v3;\n+\n+        self.state.v1 ^= 0xdd;\n+        Sip24Rounds::d_rounds(&mut self.state);\n+        let _1 = self.state.v0 ^ self.state.v1 ^ self.state.v2 ^ self.state.v3;\n+        (_0, _1)\n+    }\n+}\n+\n+impl Hasher for SipHasher128 {\n+    #[inline]\n+    fn write_u8(&mut self, i: u8) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_i8(&mut self, i: i8) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_i16(&mut self, i: i16) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_i32(&mut self, i: i32) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_i64(&mut self, i: i64) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_isize(&mut self, i: isize) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write(&mut self, msg: &[u8]) {\n+        let length = msg.len();\n+        self.length += length;\n+\n+        let mut needed = 0;\n+\n+        if self.ntail != 0 {\n+            needed = 8 - self.ntail;\n+            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << 8 * self.ntail;\n+            if length < needed {\n+                self.ntail += length;\n+                return\n+            } else {\n+                self.state.v3 ^= self.tail;\n+                Sip24Rounds::c_rounds(&mut self.state);\n+                self.state.v0 ^= self.tail;\n+                self.ntail = 0;\n+            }\n+        }\n+\n+        // Buffered tail is now flushed, process new input.\n+        let len = length - needed;\n+        let left = len & 0x7;\n+\n+        let mut i = needed;\n+        while i < len - left {\n+            let mi = unsafe { load_int_le!(msg, i, u64) };\n+\n+            self.state.v3 ^= mi;\n+            Sip24Rounds::c_rounds(&mut self.state);\n+            self.state.v0 ^= mi;\n+\n+            i += 8;\n+        }\n+\n+        self.tail = unsafe { u8to64_le(msg, i, left) };\n+        self.ntail = left;\n+    }\n+\n+    fn finish(&self) -> u64 {\n+        panic!(\"SipHasher128 cannot provide valid 64 bit hashes\")\n+    }\n+}\n+\n+#[derive(Debug, Clone, Default)]\n+struct Sip24Rounds;\n+\n+impl Sip24Rounds {\n+    #[inline]\n+    fn c_rounds(state: &mut State) {\n+        compress!(state);\n+        compress!(state);\n+    }\n+\n+    #[inline]\n+    fn d_rounds(state: &mut State) {\n+        compress!(state);\n+        compress!(state);\n+        compress!(state);\n+        compress!(state);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use std::hash::{Hash, Hasher};\n+    use std::{slice, mem};\n+    use super::SipHasher128;\n+\n+    // Hash just the bytes of the slice, without length prefix\n+    struct Bytes<'a>(&'a [u8]);\n+\n+    impl<'a> Hash for Bytes<'a> {\n+        #[allow(unused_must_use)]\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            for byte in self.0 {\n+                state.write_u8(*byte);\n+            }\n+        }\n+    }\n+\n+    fn hash_with<T: Hash>(mut st: SipHasher128, x: &T) -> (u64, u64) {\n+        x.hash(&mut st);\n+        st.finish128()\n+    }\n+\n+    fn hash<T: Hash>(x: &T) -> (u64, u64) {\n+        hash_with(SipHasher128::new_with_keys(0, 0), x)\n+    }\n+\n+    const TEST_VECTOR : [[u8; 16]; 64] = [\n+        [0xa3,0x81,0x7f,0x04,0xba,0x25,0xa8,0xe6,0x6d,0xf6,0x72,0x14,0xc7,0x55,0x02,0x93],\n+        [0xda,0x87,0xc1,0xd8,0x6b,0x99,0xaf,0x44,0x34,0x76,0x59,0x11,0x9b,0x22,0xfc,0x45],\n+        [0x81,0x77,0x22,0x8d,0xa4,0xa4,0x5d,0xc7,0xfc,0xa3,0x8b,0xde,0xf6,0x0a,0xff,0xe4],\n+        [0x9c,0x70,0xb6,0x0c,0x52,0x67,0xa9,0x4e,0x5f,0x33,0xb6,0xb0,0x29,0x85,0xed,0x51],\n+        [0xf8,0x81,0x64,0xc1,0x2d,0x9c,0x8f,0xaf,0x7d,0x0f,0x6e,0x7c,0x7b,0xcd,0x55,0x79],\n+        [0x13,0x68,0x87,0x59,0x80,0x77,0x6f,0x88,0x54,0x52,0x7a,0x07,0x69,0x0e,0x96,0x27],\n+        [0x14,0xee,0xca,0x33,0x8b,0x20,0x86,0x13,0x48,0x5e,0xa0,0x30,0x8f,0xd7,0xa1,0x5e],\n+        [0xa1,0xf1,0xeb,0xbe,0xd8,0xdb,0xc1,0x53,0xc0,0xb8,0x4a,0xa6,0x1f,0xf0,0x82,0x39],\n+        [0x3b,0x62,0xa9,0xba,0x62,0x58,0xf5,0x61,0x0f,0x83,0xe2,0x64,0xf3,0x14,0x97,0xb4],\n+        [0x26,0x44,0x99,0x06,0x0a,0xd9,0xba,0xab,0xc4,0x7f,0x8b,0x02,0xbb,0x6d,0x71,0xed],\n+        [0x00,0x11,0x0d,0xc3,0x78,0x14,0x69,0x56,0xc9,0x54,0x47,0xd3,0xf3,0xd0,0xfb,0xba],\n+        [0x01,0x51,0xc5,0x68,0x38,0x6b,0x66,0x77,0xa2,0xb4,0xdc,0x6f,0x81,0xe5,0xdc,0x18],\n+        [0xd6,0x26,0xb2,0x66,0x90,0x5e,0xf3,0x58,0x82,0x63,0x4d,0xf6,0x85,0x32,0xc1,0x25],\n+        [0x98,0x69,0xe2,0x47,0xe9,0xc0,0x8b,0x10,0xd0,0x29,0x93,0x4f,0xc4,0xb9,0x52,0xf7],\n+        [0x31,0xfc,0xef,0xac,0x66,0xd7,0xde,0x9c,0x7e,0xc7,0x48,0x5f,0xe4,0x49,0x49,0x02],\n+        [0x54,0x93,0xe9,0x99,0x33,0xb0,0xa8,0x11,0x7e,0x08,0xec,0x0f,0x97,0xcf,0xc3,0xd9],\n+        [0x6e,0xe2,0xa4,0xca,0x67,0xb0,0x54,0xbb,0xfd,0x33,0x15,0xbf,0x85,0x23,0x05,0x77],\n+        [0x47,0x3d,0x06,0xe8,0x73,0x8d,0xb8,0x98,0x54,0xc0,0x66,0xc4,0x7a,0xe4,0x77,0x40],\n+        [0xa4,0x26,0xe5,0xe4,0x23,0xbf,0x48,0x85,0x29,0x4d,0xa4,0x81,0xfe,0xae,0xf7,0x23],\n+        [0x78,0x01,0x77,0x31,0xcf,0x65,0xfa,0xb0,0x74,0xd5,0x20,0x89,0x52,0x51,0x2e,0xb1],\n+        [0x9e,0x25,0xfc,0x83,0x3f,0x22,0x90,0x73,0x3e,0x93,0x44,0xa5,0xe8,0x38,0x39,0xeb],\n+        [0x56,0x8e,0x49,0x5a,0xbe,0x52,0x5a,0x21,0x8a,0x22,0x14,0xcd,0x3e,0x07,0x1d,0x12],\n+        [0x4a,0x29,0xb5,0x45,0x52,0xd1,0x6b,0x9a,0x46,0x9c,0x10,0x52,0x8e,0xff,0x0a,0xae],\n+        [0xc9,0xd1,0x84,0xdd,0xd5,0xa9,0xf5,0xe0,0xcf,0x8c,0xe2,0x9a,0x9a,0xbf,0x69,0x1c],\n+        [0x2d,0xb4,0x79,0xae,0x78,0xbd,0x50,0xd8,0x88,0x2a,0x8a,0x17,0x8a,0x61,0x32,0xad],\n+        [0x8e,0xce,0x5f,0x04,0x2d,0x5e,0x44,0x7b,0x50,0x51,0xb9,0xea,0xcb,0x8d,0x8f,0x6f],\n+        [0x9c,0x0b,0x53,0xb4,0xb3,0xc3,0x07,0xe8,0x7e,0xae,0xe0,0x86,0x78,0x14,0x1f,0x66],\n+        [0xab,0xf2,0x48,0xaf,0x69,0xa6,0xea,0xe4,0xbf,0xd3,0xeb,0x2f,0x12,0x9e,0xeb,0x94],\n+        [0x06,0x64,0xda,0x16,0x68,0x57,0x4b,0x88,0xb9,0x35,0xf3,0x02,0x73,0x58,0xae,0xf4],\n+        [0xaa,0x4b,0x9d,0xc4,0xbf,0x33,0x7d,0xe9,0x0c,0xd4,0xfd,0x3c,0x46,0x7c,0x6a,0xb7],\n+        [0xea,0x5c,0x7f,0x47,0x1f,0xaf,0x6b,0xde,0x2b,0x1a,0xd7,0xd4,0x68,0x6d,0x22,0x87],\n+        [0x29,0x39,0xb0,0x18,0x32,0x23,0xfa,0xfc,0x17,0x23,0xde,0x4f,0x52,0xc4,0x3d,0x35],\n+        [0x7c,0x39,0x56,0xca,0x5e,0xea,0xfc,0x3e,0x36,0x3e,0x9d,0x55,0x65,0x46,0xeb,0x68],\n+        [0x77,0xc6,0x07,0x71,0x46,0xf0,0x1c,0x32,0xb6,0xb6,0x9d,0x5f,0x4e,0xa9,0xff,0xcf],\n+        [0x37,0xa6,0x98,0x6c,0xb8,0x84,0x7e,0xdf,0x09,0x25,0xf0,0xf1,0x30,0x9b,0x54,0xde],\n+        [0xa7,0x05,0xf0,0xe6,0x9d,0xa9,0xa8,0xf9,0x07,0x24,0x1a,0x2e,0x92,0x3c,0x8c,0xc8],\n+        [0x3d,0xc4,0x7d,0x1f,0x29,0xc4,0x48,0x46,0x1e,0x9e,0x76,0xed,0x90,0x4f,0x67,0x11],\n+        [0x0d,0x62,0xbf,0x01,0xe6,0xfc,0x0e,0x1a,0x0d,0x3c,0x47,0x51,0xc5,0xd3,0x69,0x2b],\n+        [0x8c,0x03,0x46,0x8b,0xca,0x7c,0x66,0x9e,0xe4,0xfd,0x5e,0x08,0x4b,0xbe,0xe7,0xb5],\n+        [0x52,0x8a,0x5b,0xb9,0x3b,0xaf,0x2c,0x9c,0x44,0x73,0xcc,0xe5,0xd0,0xd2,0x2b,0xd9],\n+        [0xdf,0x6a,0x30,0x1e,0x95,0xc9,0x5d,0xad,0x97,0xae,0x0c,0xc8,0xc6,0x91,0x3b,0xd8],\n+        [0x80,0x11,0x89,0x90,0x2c,0x85,0x7f,0x39,0xe7,0x35,0x91,0x28,0x5e,0x70,0xb6,0xdb],\n+        [0xe6,0x17,0x34,0x6a,0xc9,0xc2,0x31,0xbb,0x36,0x50,0xae,0x34,0xcc,0xca,0x0c,0x5b],\n+        [0x27,0xd9,0x34,0x37,0xef,0xb7,0x21,0xaa,0x40,0x18,0x21,0xdc,0xec,0x5a,0xdf,0x89],\n+        [0x89,0x23,0x7d,0x9d,0xed,0x9c,0x5e,0x78,0xd8,0xb1,0xc9,0xb1,0x66,0xcc,0x73,0x42],\n+        [0x4a,0x6d,0x80,0x91,0xbf,0x5e,0x7d,0x65,0x11,0x89,0xfa,0x94,0xa2,0x50,0xb1,0x4c],\n+        [0x0e,0x33,0xf9,0x60,0x55,0xe7,0xae,0x89,0x3f,0xfc,0x0e,0x3d,0xcf,0x49,0x29,0x02],\n+        [0xe6,0x1c,0x43,0x2b,0x72,0x0b,0x19,0xd1,0x8e,0xc8,0xd8,0x4b,0xdc,0x63,0x15,0x1b],\n+        [0xf7,0xe5,0xae,0xf5,0x49,0xf7,0x82,0xcf,0x37,0x90,0x55,0xa6,0x08,0x26,0x9b,0x16],\n+        [0x43,0x8d,0x03,0x0f,0xd0,0xb7,0xa5,0x4f,0xa8,0x37,0xf2,0xad,0x20,0x1a,0x64,0x03],\n+        [0xa5,0x90,0xd3,0xee,0x4f,0xbf,0x04,0xe3,0x24,0x7e,0x0d,0x27,0xf2,0x86,0x42,0x3f],\n+        [0x5f,0xe2,0xc1,0xa1,0x72,0xfe,0x93,0xc4,0xb1,0x5c,0xd3,0x7c,0xae,0xf9,0xf5,0x38],\n+        [0x2c,0x97,0x32,0x5c,0xbd,0x06,0xb3,0x6e,0xb2,0x13,0x3d,0xd0,0x8b,0x3a,0x01,0x7c],\n+        [0x92,0xc8,0x14,0x22,0x7a,0x6b,0xca,0x94,0x9f,0xf0,0x65,0x9f,0x00,0x2a,0xd3,0x9e],\n+        [0xdc,0xe8,0x50,0x11,0x0b,0xd8,0x32,0x8c,0xfb,0xd5,0x08,0x41,0xd6,0x91,0x1d,0x87],\n+        [0x67,0xf1,0x49,0x84,0xc7,0xda,0x79,0x12,0x48,0xe3,0x2b,0xb5,0x92,0x25,0x83,0xda],\n+        [0x19,0x38,0xf2,0xcf,0x72,0xd5,0x4e,0xe9,0x7e,0x94,0x16,0x6f,0xa9,0x1d,0x2a,0x36],\n+        [0x74,0x48,0x1e,0x96,0x46,0xed,0x49,0xfe,0x0f,0x62,0x24,0x30,0x16,0x04,0x69,0x8e],\n+        [0x57,0xfc,0xa5,0xde,0x98,0xa9,0xd6,0xd8,0x00,0x64,0x38,0xd0,0x58,0x3d,0x8a,0x1d],\n+        [0x9f,0xec,0xde,0x1c,0xef,0xdc,0x1c,0xbe,0xd4,0x76,0x36,0x74,0xd9,0x57,0x53,0x59],\n+        [0xe3,0x04,0x0c,0x00,0xeb,0x28,0xf1,0x53,0x66,0xca,0x73,0xcb,0xd8,0x72,0xe7,0x40],\n+        [0x76,0x97,0x00,0x9a,0x6a,0x83,0x1d,0xfe,0xcc,0xa9,0x1c,0x59,0x93,0x67,0x0f,0x7a],\n+        [0x58,0x53,0x54,0x23,0x21,0xf5,0x67,0xa0,0x05,0xd5,0x47,0xa4,0xf0,0x47,0x59,0xbd],\n+        [0x51,0x50,0xd1,0x77,0x2f,0x50,0x83,0x4a,0x50,0x3e,0x06,0x9a,0x97,0x3f,0xbd,0x7c],\n+    ];\n+\n+    // Test vector from reference implementation\n+    #[test]\n+    fn test_siphash_2_4_test_vector() {\n+        let k0 = 0x_07_06_05_04_03_02_01_00;\n+        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n+\n+        let mut input: Vec<u8> = Vec::new();\n+\n+        for i in 0 .. 64 {\n+            let out = hash_with(SipHasher128::new_with_keys(k0, k1),\n+                                &Bytes(&input[..]));\n+            let expected = (\n+                ((TEST_VECTOR[i][0] as u64) <<  0) |\n+                ((TEST_VECTOR[i][1] as u64) <<  8) |\n+                ((TEST_VECTOR[i][2] as u64) << 16) |\n+                ((TEST_VECTOR[i][3] as u64) << 24) |\n+                ((TEST_VECTOR[i][4] as u64) << 32) |\n+                ((TEST_VECTOR[i][5] as u64) << 40) |\n+                ((TEST_VECTOR[i][6] as u64) << 48) |\n+                ((TEST_VECTOR[i][7] as u64) << 56),\n+\n+                ((TEST_VECTOR[i][8] as u64) <<  0) |\n+                ((TEST_VECTOR[i][9] as u64) <<  8) |\n+                ((TEST_VECTOR[i][10] as u64) << 16) |\n+                ((TEST_VECTOR[i][11] as u64) << 24) |\n+                ((TEST_VECTOR[i][12] as u64) << 32) |\n+                ((TEST_VECTOR[i][13] as u64) << 40) |\n+                ((TEST_VECTOR[i][14] as u64) << 48) |\n+                ((TEST_VECTOR[i][15] as u64) << 56),\n+            );\n+\n+            assert_eq!(out, expected);\n+            input.push(i as u8);\n+        }\n+    }\n+\n+    #[test] #[cfg(target_arch = \"arm\")]\n+    fn test_hash_usize() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+        assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n+    }\n+    #[test] #[cfg(target_arch = \"x86_64\")]\n+    fn test_hash_usize() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert_eq!(hash(&(val as u64)), hash(&(val as usize)));\n+        assert!(hash(&(val as u32)) != hash(&(val as usize)));\n+    }\n+    #[test] #[cfg(target_arch = \"x86\")]\n+    fn test_hash_usize() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+        assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n+    }\n+\n+    #[test]\n+    fn test_hash_idempotent() {\n+        let val64 = 0xdeadbeef_deadbeef_u64;\n+        assert_eq!(hash(&val64), hash(&val64));\n+        let val32 = 0xdeadbeef_u32;\n+        assert_eq!(hash(&val32), hash(&val32));\n+    }\n+\n+    #[test]\n+    fn test_hash_no_bytes_dropped_64() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+\n+        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 4)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 5)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 6)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 7)));\n+\n+        fn zero_byte(val: u64, byte: usize) -> u64 {\n+            assert!(byte < 8);\n+            val & !(0xff << (byte * 8))\n+        }\n+    }\n+\n+    #[test]\n+    fn test_hash_no_bytes_dropped_32() {\n+        let val = 0xdeadbeef_u32;\n+\n+        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n+\n+        fn zero_byte(val: u32, byte: usize) -> u32 {\n+            assert!(byte < 4);\n+            val & !(0xff << (byte * 8))\n+        }\n+    }\n+\n+    #[test]\n+    fn test_hash_no_concat_alias() {\n+        let s = (\"aa\", \"bb\");\n+        let t = (\"aabb\", \"\");\n+        let u = (\"a\", \"abb\");\n+\n+        assert!(s != t && t != u);\n+        assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n+\n+        let u = [1, 0, 0, 0];\n+        let v = (&u[..1], &u[1..3], &u[3..]);\n+        let w = (&u[..], &u[4..4], &u[4..4]);\n+\n+        assert!(v != w);\n+        assert!(hash(&v) != hash(&w));\n+    }\n+\n+    #[test]\n+    fn test_write_short_works() {\n+        let test_usize = 0xd0c0b0a0usize;\n+        let mut h1 = SipHasher128::new_with_keys(0, 0);\n+        h1.write_usize(test_usize);\n+        h1.write(b\"bytes\");\n+        h1.write(b\"string\");\n+        h1.write_u8(0xFFu8);\n+        h1.write_u8(0x01u8);\n+        let mut h2 = SipHasher128::new_with_keys(0, 0);\n+        h2.write(unsafe {\n+            slice::from_raw_parts(&test_usize as *const _ as *const u8,\n+                                  mem::size_of::<usize>())\n+        });\n+        h2.write(b\"bytes\");\n+        h2.write(b\"string\");\n+        h2.write(&[0xFFu8, 0x01u8]);\n+        assert_eq!(h1.finish128(), h2.finish128());\n+    }\n+\n+}"}, {"sha": "831e113016fd903728c5fe3a8c54301dea745f43", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 39, "deletions": 57, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -11,16 +11,7 @@\n use std::hash::{Hash, Hasher, BuildHasher};\n use std::marker::PhantomData;\n use std::mem;\n-use blake2b::Blake2bHasher;\n-use rustc_serialize::leb128;\n-\n-fn write_unsigned_leb128_to_buf(buf: &mut [u8; 16], value: u64) -> usize {\n-    leb128::write_unsigned_leb128_to(value as u128, |i, v| buf[i] = v)\n-}\n-\n-fn write_signed_leb128_to_buf(buf: &mut [u8; 16], value: i64) -> usize {\n-    leb128::write_signed_leb128_to(value as i128, |i, v| buf[i] = v)\n-}\n+use sip128::SipHasher128;\n \n /// When hashing something that ends up affecting properties like symbol names. We\n /// want these symbol names to be calculated independent of other factors like\n@@ -41,7 +32,7 @@ fn write_signed_leb128_to_buf(buf: &mut [u8; 16], value: i64) -> usize {\n /// and allows for variable output lengths through its type\n /// parameter.\n pub struct StableHasher<W> {\n-    state: Blake2bHasher,\n+    state: SipHasher128,\n     bytes_hashed: u64,\n     width: PhantomData<W>,\n }\n@@ -59,7 +50,7 @@ pub trait StableHasherResult: Sized {\n impl<W: StableHasherResult> StableHasher<W> {\n     pub fn new() -> Self {\n         StableHasher {\n-            state: Blake2bHasher::new(mem::size_of::<W>(), &[]),\n+            state: SipHasher128::new_with_keys(0, 0),\n             bytes_hashed: 0,\n             width: PhantomData,\n         }\n@@ -70,66 +61,37 @@ impl<W: StableHasherResult> StableHasher<W> {\n     }\n }\n \n-impl StableHasherResult for [u8; 20] {\n-    fn finish(mut hasher: StableHasher<Self>) -> Self {\n-        let mut result: [u8; 20] = [0; 20];\n-        result.copy_from_slice(hasher.state.finalize());\n-        result\n-    }\n-}\n-\n impl StableHasherResult for u128 {\n-    fn finish(mut hasher: StableHasher<Self>) -> Self {\n-        let hash_bytes: &[u8] = hasher.finalize();\n-        assert!(hash_bytes.len() >= mem::size_of::<u128>());\n-\n-        unsafe {\n-            ::std::ptr::read_unaligned(hash_bytes.as_ptr() as *const u128)\n-        }\n+    fn finish(hasher: StableHasher<Self>) -> Self {\n+        let (_0, _1) = hasher.finalize();\n+        (_0 as u128) | ((_1 as u128) << 64)\n     }\n }\n \n impl StableHasherResult for u64 {\n-    fn finish(mut hasher: StableHasher<Self>) -> Self {\n-        hasher.state.finalize();\n-        hasher.state.finish()\n+    fn finish(hasher: StableHasher<Self>) -> Self {\n+        hasher.finalize().0\n     }\n }\n \n impl<W> StableHasher<W> {\n     #[inline]\n-    pub fn finalize(&mut self) -> &[u8] {\n-        self.state.finalize()\n+    pub fn finalize(self) -> (u64, u64) {\n+        self.state.finish128()\n     }\n \n     #[inline]\n     pub fn bytes_hashed(&self) -> u64 {\n         self.bytes_hashed\n     }\n-\n-    #[inline]\n-    fn write_uleb128(&mut self, value: u64) {\n-        let mut buf = [0; 16];\n-        let len = write_unsigned_leb128_to_buf(&mut buf, value);\n-        self.state.write(&buf[..len]);\n-        self.bytes_hashed += len as u64;\n-    }\n-\n-    #[inline]\n-    fn write_ileb128(&mut self, value: i64) {\n-        let mut buf = [0; 16];\n-        let len = write_signed_leb128_to_buf(&mut buf, value);\n-        self.state.write(&buf[..len]);\n-        self.bytes_hashed += len as u64;\n-    }\n }\n \n // For the non-u8 integer cases we leb128 encode them first. Because small\n // integers dominate, this significantly and cheaply reduces the number of\n // bytes hashed, which is good because blake2b is expensive.\n impl<W> Hasher for StableHasher<W> {\n     fn finish(&self) -> u64 {\n-        panic!(\"use StableHasher::finish instead\");\n+        panic!(\"use StableHasher::finalize instead\");\n     }\n \n     #[inline]\n@@ -146,22 +108,32 @@ impl<W> Hasher for StableHasher<W> {\n \n     #[inline]\n     fn write_u16(&mut self, i: u16) {\n-        self.write_uleb128(i as u64);\n+        self.state.write_u16(i.to_le());\n+        self.bytes_hashed += 2;\n     }\n \n     #[inline]\n     fn write_u32(&mut self, i: u32) {\n-        self.write_uleb128(i as u64);\n+        self.state.write_u32(i.to_le());\n+        self.bytes_hashed += 4;\n     }\n \n     #[inline]\n     fn write_u64(&mut self, i: u64) {\n-        self.write_uleb128(i);\n+        self.state.write_u64(i.to_le());\n+        self.bytes_hashed += 8;\n+    }\n+\n+    #[inline]\n+    fn write_u128(&mut self, i: u128) {\n+        self.state.write_u128(i.to_le());\n+        self.bytes_hashed += 16;\n     }\n \n     #[inline]\n     fn write_usize(&mut self, i: usize) {\n-        self.write_uleb128(i as u64);\n+        self.state.write_usize(i.to_le());\n+        self.bytes_hashed += ::std::mem::size_of::<usize>() as u64;\n     }\n \n     #[inline]\n@@ -172,22 +144,32 @@ impl<W> Hasher for StableHasher<W> {\n \n     #[inline]\n     fn write_i16(&mut self, i: i16) {\n-        self.write_ileb128(i as i64);\n+        self.state.write_i16(i.to_le());\n+        self.bytes_hashed += 2;\n     }\n \n     #[inline]\n     fn write_i32(&mut self, i: i32) {\n-        self.write_ileb128(i as i64);\n+        self.state.write_i32(i.to_le());\n+        self.bytes_hashed += 4;\n     }\n \n     #[inline]\n     fn write_i64(&mut self, i: i64) {\n-        self.write_ileb128(i);\n+        self.state.write_i64(i.to_le());\n+        self.bytes_hashed += 8;\n+    }\n+\n+    #[inline]\n+    fn write_i128(&mut self, i: i128) {\n+        self.state.write_i128(i.to_le());\n+        self.bytes_hashed += 16;\n     }\n \n     #[inline]\n     fn write_isize(&mut self, i: isize) {\n-        self.write_ileb128(i as i64);\n+        self.state.write_isize(i.to_le());\n+        self.bytes_hashed += ::std::mem::size_of::<isize>() as u64;\n     }\n }\n "}, {"sha": "7dbf93da38598d15476770230b867dd46fe1c1d8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -38,7 +38,7 @@ use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n-use rustc_passes::{ast_validation, no_asm, loops, consts, static_recursion, hir_stats};\n+use rustc_passes::{self, ast_validation, no_asm, loops, consts, static_recursion, hir_stats};\n use rustc_const_eval::{self, check_match};\n use super::Compilation;\n use ::DefaultTransCrate;\n@@ -973,6 +973,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     traits::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_const_eval::provide(&mut local_providers);\n+    rustc_passes::provide(&mut local_providers);\n     middle::region::provide(&mut local_providers);\n     cstore::provide_local(&mut local_providers);\n     lint::provide(&mut local_providers);"}, {"sha": "3514302c6c8f3e49ea18c1e6aa700450944b15e1", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -1238,7 +1238,7 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n                              errors::Level::Note);\n             }\n \n-            writeln!(io::stderr(), \"{}\", str::from_utf8(&data.lock().unwrap()).unwrap()).unwrap();\n+            eprintln!(\"{}\", str::from_utf8(&data.lock().unwrap()).unwrap());\n         }\n \n         exit_on_err();\n@@ -1259,7 +1259,6 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     let mut all_errors = Vec::new();\n     all_errors.extend_from_slice(&rustc::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_typeck::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_borrowck::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n     #[cfg(feature=\"llvm\")]"}, {"sha": "0cb920a111dd91ff4df0b25a247a75f6982b1dc0", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 428, "deletions": 30, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -13,12 +13,12 @@\n //! we will compare the fingerprint from the current and from the previous\n //! compilation session as appropriate:\n //!\n-//! - `#[rustc_dirty(label=\"TypeckTables\", cfg=\"rev2\")]` if we are\n+//! - `#[rustc_clean(cfg=\"rev2\", except=\"TypeckTables\")]` if we are\n //!   in `#[cfg(rev2)]`, then the fingerprints associated with\n //!   `DepNode::TypeckTables(X)` must be DIFFERENT (`X` is the def-id of the\n //!   current node).\n-//! - `#[rustc_clean(label=\"TypeckTables\", cfg=\"rev2\")]` same as above,\n-//!   except that the fingerprints must be the SAME.\n+//! - `#[rustc_clean(cfg=\"rev2\")]` same as above, except that the\n+//!   fingerprints must be the SAME (along with all other fingerprints).\n //!\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n@@ -39,8 +39,13 @@\n //! previous revision to compare things to.\n //!\n \n-use rustc::dep_graph::DepNode;\n+use std::collections::HashSet;\n+use std::iter::FromIterator;\n+use std::vec::Vec;\n+use rustc::dep_graph::{DepNode, label_strs};\n use rustc::hir;\n+use rustc::hir::{Item_ as HirItem, ImplItemKind, TraitItemKind};\n+use rustc::hir::map::Node as HirNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit;\n@@ -51,8 +56,182 @@ use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n \n-const LABEL: &'static str = \"label\";\n-const CFG: &'static str = \"cfg\";\n+const EXCEPT: &str = \"except\";\n+const LABEL: &str = \"label\";\n+const CFG: &str = \"cfg\";\n+\n+// Base and Extra labels to build up the labels\n+\n+/// For typedef, constants, and statics\n+const BASE_CONST: &[&str] = &[\n+    label_strs::TypeOfItem,\n+];\n+\n+/// DepNodes for functions + methods\n+const BASE_FN: &[&str] = &[\n+    // Callers will depend on the signature of these items, so we better test\n+    label_strs::FnSignature,\n+    label_strs::GenericsOfItem,\n+    label_strs::PredicatesOfItem,\n+    label_strs::TypeOfItem,\n+\n+    // And a big part of compilation (that we eventually want to cache) is type inference\n+    // information:\n+    label_strs::TypeckTables,\n+];\n+\n+/// DepNodes for Hir, which is pretty much everything\n+const BASE_HIR: &[&str] = &[\n+    // Hir and HirBody should be computed for all nodes\n+    label_strs::Hir,\n+    label_strs::HirBody,\n+];\n+\n+/// `impl` implementation of struct/trait\n+const BASE_IMPL: &[&str] = &[\n+    label_strs::AssociatedItemDefIds,\n+    label_strs::GenericsOfItem,\n+    label_strs::ImplTraitRef,\n+];\n+\n+/// DepNodes for MirValidated/Optimized, which is relevant in \"executable\"\n+/// code, i.e. functions+methods\n+const BASE_MIR: &[&str] = &[\n+    label_strs::MirOptimized,\n+    label_strs::MirValidated,\n+];\n+\n+/// Struct, Enum and Union DepNodes\n+///\n+/// Note that changing the type of a field does not change the type of the struct or enum, but\n+/// adding/removing fields or changing a fields name or visibility does.\n+const BASE_STRUCT: &[&str] = &[\n+    label_strs::GenericsOfItem,\n+    label_strs::PredicatesOfItem,\n+    label_strs::TypeOfItem,\n+];\n+\n+/// Trait Definition DepNodes\n+const BASE_TRAIT_DEF: &[&str] = &[\n+    label_strs::AssociatedItemDefIds,\n+    label_strs::GenericsOfItem,\n+    label_strs::ObjectSafety,\n+    label_strs::PredicatesOfItem,\n+    label_strs::SpecializationGraph,\n+    label_strs::TraitDefOfItem,\n+    label_strs::TraitImpls,\n+];\n+\n+/// extra DepNodes for methods (+fn)\n+const EXTRA_ASSOCIATED: &[&str] = &[\n+    label_strs::AssociatedItems,\n+];\n+\n+const EXTRA_TRAIT: &[&str] = &[\n+    label_strs::TraitOfItem,\n+];\n+\n+// Fully Built Labels\n+\n+const LABELS_CONST: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_CONST,\n+];\n+\n+/// Constant/Typedef in an impl\n+const LABELS_CONST_IN_IMPL: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_CONST,\n+    EXTRA_ASSOCIATED,\n+];\n+\n+/// Trait-Const/Typedef DepNodes\n+const LABELS_CONST_IN_TRAIT: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_CONST,\n+    EXTRA_ASSOCIATED,\n+    EXTRA_TRAIT,\n+];\n+\n+/// Function DepNode\n+const LABELS_FN: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_MIR,\n+    BASE_FN,\n+];\n+\n+/// Method DepNodes\n+const LABELS_FN_IN_IMPL: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_MIR,\n+    BASE_FN,\n+    EXTRA_ASSOCIATED,\n+];\n+\n+/// Trait-Method DepNodes\n+const LABELS_FN_IN_TRAIT: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_MIR,\n+    BASE_FN,\n+    EXTRA_ASSOCIATED,\n+    EXTRA_TRAIT,\n+];\n+\n+/// For generic cases like inline-assemply/mod/etc\n+const LABELS_HIR_ONLY: &[&[&str]] = &[\n+    BASE_HIR,\n+];\n+\n+/// Impl DepNodes\n+const LABELS_IMPL: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_IMPL,\n+];\n+\n+/// Abstract Data Type (Struct, Enum, Unions) DepNodes\n+const LABELS_ADT: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_STRUCT,\n+];\n+\n+/// Trait Definition DepNodes\n+#[allow(dead_code)]\n+const LABELS_TRAIT: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_TRAIT_DEF,\n+];\n+\n+\n+// FIXME: Struct/Enum/Unions Fields (there is currently no way to attach these)\n+//\n+// Fields are kind of separate from their containers, as they can change independently from\n+// them. We should at least check\n+//\n+//     TypeOfItem for these.\n+\n+type Labels = HashSet<String>;\n+\n+/// Represents the requested configuration by rustc_clean/dirty\n+struct Assertion {\n+    clean: Labels,\n+    dirty: Labels,\n+}\n+\n+impl Assertion {\n+    fn from_clean_labels(labels: Labels) -> Assertion {\n+        Assertion {\n+            clean: labels,\n+            dirty: Labels::new(),\n+        }\n+    }\n+\n+    fn from_dirty_labels(labels: Labels) -> Assertion {\n+        Assertion {\n+            clean: Labels::new(),\n+            dirty: labels,\n+        }\n+    }\n+}\n \n pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // can't add `#[rustc_dirty]` etc without opting in to this feature\n@@ -87,23 +266,221 @@ pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n-    fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode {\n-        let def_path_hash = self.tcx.def_path_hash(def_id);\n+\n+    /// Possibly \"deserialize\" the attribute into a clean/dirty assertion\n+    fn assertion_maybe(&mut self, item_id: ast::NodeId, attr: &Attribute)\n+        -> Option<Assertion>\n+    {\n+        let is_clean = if attr.check_name(ATTR_DIRTY) {\n+            false\n+        } else if attr.check_name(ATTR_CLEAN) {\n+            true\n+        } else {\n+            // skip: not rustc_clean/dirty\n+            return None\n+        };\n+        if !check_config(self.tcx, attr) {\n+            // skip: not the correct `cfg=`\n+            return None;\n+        }\n+        let assertion = if let Some(labels) = self.labels(attr) {\n+            if is_clean {\n+                Assertion::from_clean_labels(labels)\n+            } else {\n+                Assertion::from_dirty_labels(labels)\n+            }\n+        } else {\n+            self.assertion_auto(item_id, attr, is_clean)\n+        };\n+        Some(assertion)\n+    }\n+\n+    /// Get the \"auto\" assertion on pre-validated attr, along with the `except` labels\n+    fn assertion_auto(&mut self, item_id: ast::NodeId, attr: &Attribute, is_clean: bool)\n+        -> Assertion\n+    {\n+        let (name, mut auto) = self.auto_labels(item_id, attr);\n+        let except = self.except(attr);\n+        for e in except.iter() {\n+            if !auto.remove(e) {\n+                let msg = format!(\n+                    \"`except` specified DepNodes that can not be affected for \\\"{}\\\": \\\"{}\\\"\",\n+                    name,\n+                    e\n+                );\n+                self.tcx.sess.span_fatal(attr.span, &msg);\n+            }\n+        }\n+        if is_clean {\n+            Assertion {\n+                clean: auto,\n+                dirty: except,\n+            }\n+        } else {\n+            Assertion {\n+                clean: except,\n+                dirty: auto,\n+            }\n+        }\n+    }\n+\n+    fn labels(&self, attr: &Attribute) -> Option<Labels> {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(LABEL) {\n                 let value = expect_associated_value(self.tcx, &item);\n-                match DepNode::from_label_string(&value.as_str(), def_path_hash) {\n-                    Ok(dep_node) => return dep_node,\n-                    Err(()) => {\n-                        self.tcx.sess.span_fatal(\n-                            item.span,\n-                            &format!(\"dep-node label `{}` not recognized\", value));\n-                    }\n+                return Some(self.resolve_labels(&item, value.as_str().as_ref()));\n+            }\n+        }\n+        None\n+    }\n+\n+    /// `except=` attribute value\n+    fn except(&self, attr: &Attribute) -> Labels {\n+        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+            if item.check_name(EXCEPT) {\n+                let value = expect_associated_value(self.tcx, &item);\n+                return self.resolve_labels(&item, value.as_str().as_ref());\n+            }\n+        }\n+        // if no `label` or `except` is given, only the node's group are asserted\n+        Labels::new()\n+    }\n+\n+    /// Return all DepNode labels that should be asserted for this item.\n+    /// index=0 is the \"name\" used for error messages\n+    fn auto_labels(&mut self, item_id: ast::NodeId, attr: &Attribute) -> (&'static str, Labels) {\n+        let node = self.tcx.hir.get(item_id);\n+        let (name, labels) = match node {\n+            HirNode::NodeItem(item) => {\n+                match item.node {\n+                    // note: these are in the same order as hir::Item_;\n+                    // FIXME(michaelwoerister): do commented out ones\n+\n+                    // // An `extern crate` item, with optional original crate name,\n+                    // HirItem::ItemExternCrate(..),  // intentionally no assertions\n+\n+                    // // `use foo::bar::*;` or `use foo::bar::baz as quux;`\n+                    // HirItem::ItemUse(..),  // intentionally no assertions\n+\n+                    // A `static` item\n+                    HirItem::ItemStatic(..) => (\"ItemStatic\", LABELS_CONST),\n+\n+                    // A `const` item\n+                    HirItem::ItemConst(..) => (\"ItemConst\", LABELS_CONST),\n+\n+                    // A function declaration\n+                    HirItem::ItemFn(..) => (\"ItemFn\", LABELS_FN),\n+\n+                    // // A module\n+                    HirItem::ItemMod(..) =>(\"ItemMod\", LABELS_HIR_ONLY),\n+\n+                    // // An external module\n+                    HirItem::ItemForeignMod(..) => (\"ItemForeignMod\", LABELS_HIR_ONLY),\n+\n+                    // Module-level inline assembly (from global_asm!)\n+                    HirItem::ItemGlobalAsm(..) => (\"ItemGlobalAsm\", LABELS_HIR_ONLY),\n+\n+                    // A type alias, e.g. `type Foo = Bar<u8>`\n+                    HirItem::ItemTy(..) => (\"ItemTy\", LABELS_HIR_ONLY),\n+\n+                    // An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n+                    HirItem::ItemEnum(..) => (\"ItemEnum\", LABELS_ADT),\n+\n+                    // A struct definition, e.g. `struct Foo<A> {x: A}`\n+                    HirItem::ItemStruct(..) => (\"ItemStruct\", LABELS_ADT),\n+\n+                    // A union definition, e.g. `union Foo<A, B> {x: A, y: B}`\n+                    HirItem::ItemUnion(..) => (\"ItemUnion\", LABELS_ADT),\n+\n+                    // Represents a Trait Declaration\n+                    // FIXME(michaelwoerister): trait declaration is buggy because sometimes some of\n+                    // the depnodes don't exist (because they legitametely didn't need to be\n+                    // calculated)\n+                    //\n+                    // michaelwoerister and vitiral came up with a possible solution,\n+                    // to just do this before every query\n+                    // ```\n+                    // ::rustc::ty::maps::plumbing::force_from_dep_node(tcx, dep_node)\n+                    // ```\n+                    //\n+                    // However, this did not seem to work effectively and more bugs were hit.\n+                    // Nebie @vitiral gave up :)\n+                    //\n+                    //HirItem::ItemTrait(..) => (\"ItemTrait\", LABELS_TRAIT),\n+\n+                    // `impl Trait for .. {}`\n+                    HirItem::ItemDefaultImpl(..) => (\"ItemDefaultImpl\", LABELS_IMPL),\n+\n+                    // An implementation, eg `impl<A> Trait for Foo { .. }`\n+                    HirItem::ItemImpl(..) => (\"ItemImpl\", LABELS_IMPL),\n+\n+                    _ => self.tcx.sess.span_fatal(\n+                        attr.span,\n+                        &format!(\n+                            \"clean/dirty auto-assertions not yet defined for NodeItem.node={:?}\",\n+                            item.node\n+                        )\n+                    ),\n+                }\n+            },\n+            HirNode::NodeTraitItem(item) => {\n+                match item.node {\n+                    TraitItemKind::Method(..) => (\"NodeTraitItem\", LABELS_FN_IN_TRAIT),\n+                    TraitItemKind::Const(..) => (\"NodeTraitConst\", LABELS_CONST_IN_TRAIT),\n+                    TraitItemKind::Type(..) => (\"NodeTraitType\", LABELS_CONST_IN_TRAIT),\n+                }\n+            },\n+            HirNode::NodeImplItem(item) => {\n+                match item.node {\n+                    ImplItemKind::Method(..) => (\"NodeImplItem\", LABELS_FN_IN_IMPL),\n+                    ImplItemKind::Const(..) => (\"NodeImplConst\", LABELS_CONST_IN_IMPL),\n+                    ImplItemKind::Type(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n+                }\n+            },\n+            _ => self.tcx.sess.span_fatal(\n+                attr.span,\n+                &format!(\n+                    \"clean/dirty auto-assertions not yet defined for {:?}\",\n+                    node\n+                )\n+            ),\n+        };\n+        let labels = Labels::from_iter(\n+            labels.iter().flat_map(|s| s.iter().map(|l| l.to_string()))\n+        );\n+        (name, labels)\n+    }\n+\n+    fn resolve_labels(&self, item: &NestedMetaItem, value: &str) -> Labels {\n+        let mut out: Labels = HashSet::new();\n+        for label in value.split(',') {\n+            let label = label.trim();\n+            if DepNode::has_label_string(label) {\n+                if out.contains(label) {\n+                    self.tcx.sess.span_fatal(\n+                        item.span,\n+                        &format!(\"dep-node label `{}` is repeated\", label));\n                 }\n+                out.insert(label.to_string());\n+            } else {\n+                self.tcx.sess.span_fatal(\n+                    item.span,\n+                    &format!(\"dep-node label `{}` not recognized\", label));\n             }\n         }\n+        out\n+    }\n \n-        self.tcx.sess.span_fatal(attr.span, \"no `label` found\");\n+    fn dep_nodes(&self, labels: &Labels, def_id: DefId) -> Vec<DepNode> {\n+        let mut out = Vec::with_capacity(labels.len());\n+        let def_path_hash = self.tcx.def_path_hash(def_id);\n+        for label in labels.iter() {\n+            match DepNode::from_label_string(label, def_path_hash) {\n+                Ok(dep_node) => out.push(dep_node),\n+                Err(()) => unreachable!(),\n+            }\n+        }\n+        out\n     }\n \n     fn dep_node_str(&self, dep_node: &DepNode) -> String {\n@@ -147,16 +524,16 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     fn check_item(&mut self, item_id: ast::NodeId, item_span: Span) {\n         let def_id = self.tcx.hir.local_def_id(item_id);\n         for attr in self.tcx.get_attrs(def_id).iter() {\n-            if attr.check_name(ATTR_DIRTY) {\n-                if check_config(self.tcx, attr) {\n-                    self.checked_attrs.insert(attr.id);\n-                    self.assert_dirty(item_span, self.dep_node(attr, def_id));\n-                }\n-            } else if attr.check_name(ATTR_CLEAN) {\n-                if check_config(self.tcx, attr) {\n-                    self.checked_attrs.insert(attr.id);\n-                    self.assert_clean(item_span, self.dep_node(attr, def_id));\n-                }\n+            let assertion = match self.assertion_maybe(item_id, attr) {\n+                Some(a) => a,\n+                None => continue,\n+            };\n+            self.checked_attrs.insert(attr.id);\n+            for dep_node in self.dep_nodes(&assertion.clean, def_id) {\n+                self.assert_clean(item_span, dep_node);\n+            }\n+            for dep_node in self.dep_nodes(&assertion.dirty, def_id) {\n+                self.assert_dirty(item_span, dep_node);\n             }\n         }\n     }\n@@ -330,21 +707,42 @@ impl<'a, 'tcx, 'm> DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n /// Given a `#[rustc_dirty]` or `#[rustc_clean]` attribute, scan\n /// for a `cfg=\"foo\"` attribute and check whether we have a cfg\n /// flag called `foo`.\n+///\n+/// Also make sure that the `label` and `except` fields do not\n+/// both exist.\n fn check_config(tcx: TyCtxt, attr: &Attribute) -> bool {\n     debug!(\"check_config(attr={:?})\", attr);\n     let config = &tcx.sess.parse_sess.config;\n     debug!(\"check_config: config={:?}\", config);\n+    let (mut cfg, mut except, mut label) = (None, false, false);\n     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n         if item.check_name(CFG) {\n             let value = expect_associated_value(tcx, &item);\n             debug!(\"check_config: searching for cfg {:?}\", value);\n-            return config.contains(&(value, None));\n+            cfg = Some(config.contains(&(value, None)));\n+        }\n+        if item.check_name(LABEL) {\n+            label = true;\n+        }\n+        if item.check_name(EXCEPT) {\n+            except = true;\n         }\n     }\n \n-    tcx.sess.span_fatal(\n-        attr.span,\n-        \"no cfg attribute\");\n+    if label && except {\n+        tcx.sess.span_fatal(\n+            attr.span,\n+            \"must specify only one of: `label`, `except`\"\n+        );\n+    }\n+\n+    match cfg {\n+        None => tcx.sess.span_fatal(\n+            attr.span,\n+            \"no cfg attribute\"\n+        ),\n+        Some(c) => c,\n+    }\n }\n \n fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> ast::Name {"}, {"sha": "7d1400b6b95a5a423097a361390ed45d63d0e572", "filename": "src/librustc_incremental/persist/file_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -117,7 +117,7 @@ fn report_format_mismatch(sess: &Session, file: &Path, message: &str) {\n     debug!(\"read_file: {}\", message);\n \n     if sess.opts.debugging_opts.incremental_info {\n-        eprintln!(\"incremental: ignoring cache artifact `{}`: {}\",\n+        println!(\"[incremental] ignoring cache artifact `{}`: {}\",\n                   file.file_name().unwrap().to_string_lossy(),\n                   message);\n     }"}, {"sha": "d53ee5c804f601d5190be2d5444568217e71bcc3", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -256,11 +256,12 @@ pub fn prepare_session_directory(sess: &Session,\n         debug!(\"attempting to copy data from source: {}\",\n                source_directory.display());\n \n-        let print_file_copy_stats = sess.opts.debugging_opts.incremental_info;\n+\n \n         // Try copying over all files from the source directory\n-        if let Ok(allows_links) = copy_files(&session_dir, &source_directory,\n-                                             print_file_copy_stats) {\n+        if let Ok(allows_links) = copy_files(sess,\n+                                             &session_dir,\n+                                             &source_directory) {\n             debug!(\"successfully copied data from: {}\",\n                    source_directory.display());\n \n@@ -390,9 +391,9 @@ pub fn delete_all_session_dir_contents(sess: &Session) -> io::Result<()> {\n     Ok(())\n }\n \n-fn copy_files(target_dir: &Path,\n-              source_dir: &Path,\n-              print_stats_on_success: bool)\n+fn copy_files(sess: &Session,\n+              target_dir: &Path,\n+              source_dir: &Path)\n               -> Result<bool, ()> {\n     // We acquire a shared lock on the lock file of the directory, so that\n     // nobody deletes it out from under us while we are reading from it.\n@@ -440,9 +441,11 @@ fn copy_files(target_dir: &Path,\n         }\n     }\n \n-    if print_stats_on_success {\n-        eprintln!(\"incremental: session directory: {} files hard-linked\", files_linked);\n-        eprintln!(\"incremental: session directory: {} files copied\", files_copied);\n+    if sess.opts.debugging_opts.incremental_info {\n+        println!(\"[incremental] session directory: \\\n+                  {} files hard-linked\", files_linked);\n+        println!(\"[incremental] session directory: \\\n+                 {} files copied\", files_copied);\n     }\n \n     Ok(files_linked > 0 || files_copied == 0)"}, {"sha": "63cfbcac1452e0647749f5a9891360f8b5536724", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -177,8 +177,8 @@ pub fn load_dep_graph(sess: &Session) -> PreviousDepGraph {\n \n         if prev_commandline_args_hash != sess.opts.dep_tracking_hash() {\n             if sess.opts.debugging_opts.incremental_info {\n-                eprintln!(\"incremental: completely ignoring cache because of \\\n-                           differing commandline arguments\");\n+                println!(\"[incremental] completely ignoring cache because of \\\n+                          differing commandline arguments\");\n             }\n             // We can't reuse the cache, purge it.\n             debug!(\"load_dep_graph_new: differing commandline arg hashes\");"}, {"sha": "b9f73500e273ba8cbf88ca69c5012c941029da3d", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::dep_graph::DepGraph;\n+use rustc::dep_graph::{DepGraph, DepKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n@@ -170,6 +170,77 @@ fn encode_dep_graph(tcx: TyCtxt,\n \n     // Encode the graph data.\n     let serialized_graph = tcx.dep_graph.serialize();\n+\n+    if tcx.sess.opts.debugging_opts.incremental_info {\n+        #[derive(Clone)]\n+        struct Stat {\n+            kind: DepKind,\n+            node_counter: u64,\n+            edge_counter: u64,\n+        }\n+\n+        let total_node_count = serialized_graph.nodes.len();\n+        let total_edge_count = serialized_graph.edge_list_data.len();\n+\n+        let mut counts: FxHashMap<_, Stat> = FxHashMap();\n+\n+        for (i, &(node, _)) in serialized_graph.nodes.iter_enumerated() {\n+            let stat = counts.entry(node.kind).or_insert(Stat {\n+                kind: node.kind,\n+                node_counter: 0,\n+                edge_counter: 0,\n+            });\n+\n+            stat.node_counter += 1;\n+            let (edge_start, edge_end) = serialized_graph.edge_list_indices[i];\n+            stat.edge_counter += (edge_end - edge_start) as u64;\n+        }\n+\n+        let mut counts: Vec<_> = counts.values().cloned().collect();\n+        counts.sort_by_key(|s| -(s.node_counter as i64));\n+\n+        let percentage_of_all_nodes: Vec<f64> = counts.iter().map(|s| {\n+            (100.0 * (s.node_counter as f64)) / (total_node_count as f64)\n+        }).collect();\n+\n+        let average_edges_per_kind: Vec<f64> = counts.iter().map(|s| {\n+            (s.edge_counter as f64) / (s.node_counter as f64)\n+        }).collect();\n+\n+        println!(\"[incremental]\");\n+        println!(\"[incremental] DepGraph Statistics\");\n+\n+        const SEPARATOR: &str = \"[incremental] --------------------------------\\\n+                                 ----------------------------------------------\\\n+                                 ------------\";\n+\n+        println!(\"{}\", SEPARATOR);\n+        println!(\"[incremental]\");\n+        println!(\"[incremental] Total Node Count: {}\", total_node_count);\n+        println!(\"[incremental] Total Edge Count: {}\", total_edge_count);\n+        println!(\"[incremental]\");\n+        println!(\"[incremental]  {:<36}| {:<17}| {:<12}| {:<17}|\",\n+                 \"Node Kind\",\n+                 \"Node Frequency\",\n+                 \"Node Count\",\n+                 \"Avg. Edge Count\");\n+        println!(\"[incremental] -------------------------------------\\\n+                  |------------------\\\n+                  |-------------\\\n+                  |------------------|\");\n+\n+        for (i, stat) in counts.iter().enumerate() {\n+            println!(\"[incremental]  {:<36}|{:>16.1}% |{:>12} |{:>17.1} |\",\n+                format!(\"{:?}\", stat.kind),\n+                percentage_of_all_nodes[i],\n+                stat.node_counter,\n+                average_edges_per_kind[i]);\n+        }\n+\n+        println!(\"{}\", SEPARATOR);\n+        println!(\"[incremental]\");\n+    }\n+\n     serialized_graph.encode(encoder)?;\n \n     Ok(())"}, {"sha": "f23b8dc85b8bb6de03439f2363cd9abbd899d24d", "filename": "src/librustc_incremental/persist/work_product.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -11,29 +11,33 @@\n //! This module contains files for saving intermediate work-products.\n \n use persist::fs::*;\n-use rustc::dep_graph::{WorkProduct, WorkProductId, DepGraph};\n+use rustc::dep_graph::{WorkProduct, WorkProductId, DepGraph, WorkProductFileKind};\n use rustc::session::Session;\n-use rustc::session::config::OutputType;\n use rustc::util::fs::link_or_copy;\n use std::path::PathBuf;\n use std::fs as std_fs;\n \n pub fn save_trans_partition(sess: &Session,\n                             dep_graph: &DepGraph,\n                             cgu_name: &str,\n-                            files: &[(OutputType, PathBuf)]) {\n+                            files: &[(WorkProductFileKind, PathBuf)]) {\n     debug!(\"save_trans_partition({:?},{:?})\",\n            cgu_name,\n            files);\n     if sess.opts.incremental.is_none() {\n-        return;\n+        return\n     }\n     let work_product_id = WorkProductId::from_cgu_name(cgu_name);\n \n     let saved_files: Option<Vec<_>> =\n         files.iter()\n              .map(|&(kind, ref path)| {\n-                 let file_name = format!(\"cgu-{}.{}\", cgu_name, kind.extension());\n+                 let extension = match kind {\n+                     WorkProductFileKind::Object => \"o\",\n+                     WorkProductFileKind::Bytecode => \"bc\",\n+                     WorkProductFileKind::BytecodeCompressed => \"bc-compressed\",\n+                 };\n+                 let file_name = format!(\"cgu-{}.{}\", cgu_name, extension);\n                  let path_in_incr_dir = in_incr_comp_dir_sess(sess, &file_name);\n                  match link_or_copy(path, &path_in_incr_dir) {\n                      Ok(_) => Some((kind, file_name)),"}, {"sha": "cebf52d5af7a9c2cf4f2686617bb3e60fdb5f1cd", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -12,7 +12,6 @@ test = false\n [dependencies]\n log = \"0.3\"\n rustc = { path = \"../librustc\" }\n-rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "bc2a1f08441d1a57582e645ce8e96ac2613e171c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -44,7 +44,7 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{AttributeGate, AttributeType, Stability, deprecated_attributes};\n-use syntax_pos::{Span, SyntaxContext};\n+use syntax_pos::{BytePos, Span, SyntaxContext};\n use syntax::symbol::keywords;\n \n use rustc::hir::{self, PatKind};\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n declare_lint! {\n     NON_SHORTHAND_FIELD_PATTERNS,\n     Warn,\n-    \"using `Struct { x: x }` instead of `Struct { x }`\"\n+    \"using `Struct { x: x }` instead of `Struct { x }` in a pattern\"\n }\n \n #[derive(Copy, Clone)]\n@@ -174,11 +174,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                 }\n                 if let PatKind::Binding(_, _, ident, None) = fieldpat.node.pat.node {\n                     if ident.node == fieldpat.node.name {\n-                        cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n+                        let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n                                      fieldpat.span,\n-                                     &format!(\"the `{}:` in this pattern is redundant and can \\\n-                                              be removed\",\n-                                              ident.node))\n+                                     &format!(\"the `{}:` in this pattern is redundant\",\n+                                              ident.node));\n+                        let subspan = cx.tcx.sess.codemap().span_through_char(fieldpat.span, ':');\n+                        err.span_suggestion_short(subspan,\n+                                                  \"remove this\",\n+                                                  format!(\"{}\", ident.node));\n+                        err.emit();\n                     }\n                 }\n             }\n@@ -894,7 +898,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             let mut db = cx.struct_span_lint(UNCONDITIONAL_RECURSION,\n                                              sp,\n                                              \"function cannot return without recurring\");\n-            // FIXME #19668: these could be span_lint_note's instead of this manual guard.\n             // offer some help to the programmer.\n             for call in &self_call_spans {\n                 db.span_note(*call, \"recursive call site\");\n@@ -1130,35 +1133,55 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemFn(.., ref generics, _) => {\n-                if attr::contains_name(&it.attrs, \"no_mangle\") &&\n-                   !attr::contains_name(&it.attrs, \"linkage\") {\n+                if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, \"no_mangle\") {\n+                    if attr::contains_name(&it.attrs, \"linkage\") {\n+                        return;\n+                    }\n                     if !cx.access_levels.is_reachable(it.id) {\n-                        let msg = format!(\"function {} is marked #[no_mangle], but not exported\",\n-                                          it.name);\n-                        cx.span_lint(PRIVATE_NO_MANGLE_FNS, it.span, &msg);\n+                        let msg = \"function is marked #[no_mangle], but not exported\";\n+                        let mut err = cx.struct_span_lint(PRIVATE_NO_MANGLE_FNS, it.span, msg);\n+                        let insertion_span = it.span.with_hi(it.span.lo());\n+                        err.span_suggestion(insertion_span,\n+                                            \"try making it public\",\n+                                            \"pub \".to_owned());\n+                        err.emit();\n                     }\n                     if generics.is_type_parameterized() {\n-                        cx.span_lint(NO_MANGLE_GENERIC_ITEMS,\n-                                     it.span,\n-                                     \"functions generic over types must be mangled\");\n+                        let mut err = cx.struct_span_lint(NO_MANGLE_GENERIC_ITEMS,\n+                                                          it.span,\n+                                                          \"functions generic over \\\n+                                                           types must be mangled\");\n+                        err.span_suggestion_short(no_mangle_attr.span,\n+                                                  \"remove this attribute\",\n+                                                  \"\".to_owned());\n+                        err.emit();\n                     }\n                 }\n             }\n             hir::ItemStatic(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n                    !cx.access_levels.is_reachable(it.id) {\n-                    let msg = format!(\"static {} is marked #[no_mangle], but not exported\",\n-                                      it.name);\n-                    cx.span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, &msg);\n+                       let msg = \"static is marked #[no_mangle], but not exported\";\n+                       let mut err = cx.struct_span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, msg);\n+                       let insertion_span = it.span.with_hi(it.span.lo());\n+                       err.span_suggestion(insertion_span,\n+                                           \"try making it public\",\n+                                           \"pub \".to_owned());\n+                       err.emit();\n                 }\n             }\n             hir::ItemConst(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n-                    let msg = \"const items should never be #[no_mangle], consider instead using \\\n-                               `pub static`\";\n-                    cx.span_lint(NO_MANGLE_CONST_ITEMS, it.span, msg);\n+                    let msg = \"const items should never be #[no_mangle]\";\n+                    let mut err = cx.struct_span_lint(NO_MANGLE_CONST_ITEMS, it.span, msg);\n+                    // `const` is 5 chars\n+                    let const_span = it.span.with_hi(BytePos(it.span.lo().0 + 5));\n+                    err.span_suggestion(const_span,\n+                                        \"try a static value\",\n+                                        \"pub static\".to_owned());\n+                    err.emit();\n                 }\n             }\n             _ => {}"}, {"sha": "4ba7f7aa951f75c50de6c82a5c687a1dbe03f482", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -38,7 +38,6 @@ extern crate syntax;\n extern crate rustc;\n #[macro_use]\n extern crate log;\n-extern crate rustc_back;\n extern crate rustc_const_eval;\n extern crate syntax_pos;\n \n@@ -129,7 +128,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  NonUpperCaseGlobals,\n                  NonShorthandFieldPatterns,\n                  UnsafeCode,\n-                 UnusedMut,\n                  UnusedAllocation,\n                  MissingCopyImplementations,\n                  UnstableFeatures,"}, {"sha": "38461b0b36419d0be0b344ce64e92c4c58eed735", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -431,7 +431,9 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         // fields are actually safe.\n                         let mut all_phantom = true;\n                         for field in &def.struct_variant().fields {\n-                            let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n+                            let field_ty = cx.fully_normalize_associated_types_in(\n+                                &field.ty(cx, substs)\n+                            );\n                             let r = self.check_type_for_ffi(cache, field_ty);\n                             match r {\n                                 FfiSafe => {\n@@ -463,7 +465,9 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                         let mut all_phantom = true;\n                         for field in &def.struct_variant().fields {\n-                            let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n+                            let field_ty = cx.fully_normalize_associated_types_in(\n+                                &field.ty(cx, substs)\n+                            );\n                             let r = self.check_type_for_ffi(cache, field_ty);\n                             match r {\n                                 FfiSafe => {\n@@ -516,7 +520,9 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         // Check the contained variants.\n                         for variant in &def.variants {\n                             for field in &variant.fields {\n-                                let arg = cx.normalize_associated_type(&field.ty(cx, substs));\n+                                let arg = cx.fully_normalize_associated_types_in(\n+                                    &field.ty(cx, substs)\n+                                );\n                                 let r = self.check_type_for_ffi(cache, arg);\n                                 match r {\n                                     FfiSafe => {}\n@@ -629,7 +635,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_type_for_ffi_and_report_errors(&mut self, sp: Span, ty: Ty<'tcx>) {\n         // it is only OK to use this function because extern fns cannot have\n         // any generic types right now:\n-        let ty = self.cx.tcx.normalize_associated_type(&ty);\n+        let ty = self.cx.tcx.fully_normalize_associated_types_in(&ty);\n \n         match self.check_type_for_ffi(&mut FxHashSet(), ty) {\n             FfiResult::FfiSafe => {}"}, {"sha": "a058f84e58806da255b7b2ade7159e7263301795", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 88, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -11,105 +11,18 @@\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n use rustc::ty::adjustment;\n-use util::nodemap::FxHashMap;\n use lint::{LateContext, EarlyContext, LintContext, LintArray};\n use lint::{LintPass, EarlyLintPass, LateLintPass};\n \n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n-\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{BUILTIN_ATTRIBUTES, AttributeType};\n-use syntax::symbol::keywords;\n-use syntax::ptr::P;\n use syntax::print::pprust;\n+use syntax::symbol::keywords;\n use syntax::util::parser;\n use syntax_pos::Span;\n \n-use rustc_back::slice;\n use rustc::hir;\n-use rustc::hir::intravisit::FnKind;\n-\n-declare_lint! {\n-    pub UNUSED_MUT,\n-    Warn,\n-    \"detect mut variables which don't need to be mutable\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedMut;\n-\n-impl UnusedMut {\n-    fn check_unused_mut_pat(&self, cx: &LateContext, pats: &[P<hir::Pat>]) {\n-        // collect all mutable pattern and group their NodeIDs by their Identifier to\n-        // avoid false warnings in match arms with multiple patterns\n-\n-        let mut mutables = FxHashMap();\n-        for p in pats {\n-            p.each_binding(|_, id, span, path1| {\n-                let hir_id = cx.tcx.hir.node_to_hir_id(id);\n-                let bm = match cx.tables.pat_binding_modes().get(hir_id) {\n-                    Some(&bm) => bm,\n-                    None => span_bug!(span, \"missing binding mode\"),\n-                };\n-                let name = path1.node;\n-                if let ty::BindByValue(hir::MutMutable) = bm {\n-                    if !name.as_str().starts_with(\"_\") {\n-                        match mutables.entry(name) {\n-                            Vacant(entry) => {\n-                                entry.insert(vec![id]);\n-                            }\n-                            Occupied(mut entry) => {\n-                                entry.get_mut().push(id);\n-                            }\n-                        }\n-                    }\n-                }\n-            });\n-        }\n-\n-        let used_mutables = cx.tcx.used_mut_nodes.borrow();\n-        for (_, v) in &mutables {\n-            if !v.iter().any(|e| used_mutables.contains(e)) {\n-                let binding_span = cx.tcx.hir.span(v[0]);\n-                let mut_span = cx.tcx.sess.codemap().span_until_char(binding_span, ' ');\n-                let mut err = cx.struct_span_lint(UNUSED_MUT,\n-                                                  binding_span,\n-                                                  \"variable does not need to be mutable\");\n-                err.span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned());\n-                err.emit();\n-            }\n-        }\n-    }\n-}\n-\n-impl LintPass for UnusedMut {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_MUT)\n-    }\n-}\n-\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedMut {\n-    fn check_arm(&mut self, cx: &LateContext, a: &hir::Arm) {\n-        self.check_unused_mut_pat(cx, &a.pats)\n-    }\n-\n-    fn check_local(&mut self, cx: &LateContext, l: &hir::Local) {\n-        self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n-    }\n-\n-    fn check_fn(&mut self,\n-                cx: &LateContext,\n-                _: FnKind,\n-                _: &hir::FnDecl,\n-                body: &hir::Body,\n-                _: Span,\n-                _: ast::NodeId) {\n-        for a in &body.arguments {\n-            self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n-        }\n-    }\n-}\n \n declare_lint! {\n     pub UNUSED_MUST_USE,"}, {"sha": "a9566c4bcacd7e791d2ac470632e4c46714b7bdb", "filename": "src/librustc_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2FCargo.toml?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -18,4 +18,4 @@ rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n-cc = \"1.0\"\n+cc = \"1.0.1\""}, {"sha": "75efe135f65e784545dbd7375e100304500e49c3", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -88,7 +88,7 @@ fn main() {\n     let is_crossed = target != host;\n \n     let mut optional_components =\n-        vec![\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\", \"pnacl\",\n+        vec![\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\",\n              \"systemz\", \"jsbackend\", \"webassembly\", \"msp430\", \"sparc\", \"nvptx\"];\n \n     let mut version_cmd = Command::new(&llvm_config);\n@@ -115,6 +115,7 @@ fn main() {\n                                 \"linker\",\n                                 \"asmparser\",\n                                 \"mcjit\",\n+                                \"lto\",\n                                 \"interpreter\",\n                                 \"instrumentation\"];\n "}, {"sha": "3399bf2acd8917c88bab7b3f4a337bc3a2a9ff7e", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -345,6 +345,20 @@ pub enum PassKind {\n     Module,\n }\n \n+/// LLVMRustThinLTOData\n+pub enum ThinLTOData {}\n+\n+/// LLVMRustThinLTOBuffer\n+pub enum ThinLTOBuffer {}\n+\n+/// LLVMRustThinLTOModule\n+#[repr(C)]\n+pub struct ThinLTOModule {\n+    pub identifier: *const c_char,\n+    pub data: *const u8,\n+    pub len: usize,\n+}\n+\n // Opaque pointer types\n #[allow(missing_copy_implementations)]\n pub enum Module_opaque {}\n@@ -1271,6 +1285,9 @@ extern \"C\" {\n                                                         PM: PassManagerRef,\n                                                         Internalize: Bool,\n                                                         RunInliner: Bool);\n+    pub fn LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef) -> bool;\n \n     // Stuff that's in rustllvm/ because it's not upstream yet.\n \n@@ -1685,4 +1702,43 @@ extern \"C\" {\n     pub fn LLVMRustModuleBufferLen(p: *const ModuleBuffer) -> usize;\n     pub fn LLVMRustModuleBufferFree(p: *mut ModuleBuffer);\n     pub fn LLVMRustModuleCost(M: ModuleRef) -> u64;\n+\n+    pub fn LLVMRustThinLTOAvailable() -> bool;\n+    pub fn LLVMRustWriteThinBitcodeToFile(PMR: PassManagerRef,\n+                                          M: ModuleRef,\n+                                          BC: *const c_char) -> bool;\n+    pub fn LLVMRustThinLTOBufferCreate(M: ModuleRef) -> *mut ThinLTOBuffer;\n+    pub fn LLVMRustThinLTOBufferFree(M: *mut ThinLTOBuffer);\n+    pub fn LLVMRustThinLTOBufferPtr(M: *const ThinLTOBuffer) -> *const c_char;\n+    pub fn LLVMRustThinLTOBufferLen(M: *const ThinLTOBuffer) -> size_t;\n+    pub fn LLVMRustCreateThinLTOData(\n+        Modules: *const ThinLTOModule,\n+        NumModules: c_uint,\n+        PreservedSymbols: *const *const c_char,\n+        PreservedSymbolsLen: c_uint,\n+    ) -> *mut ThinLTOData;\n+    pub fn LLVMRustPrepareThinLTORename(\n+        Data: *const ThinLTOData,\n+        Module: ModuleRef,\n+    ) -> bool;\n+    pub fn LLVMRustPrepareThinLTOResolveWeak(\n+        Data: *const ThinLTOData,\n+        Module: ModuleRef,\n+    ) -> bool;\n+    pub fn LLVMRustPrepareThinLTOInternalize(\n+        Data: *const ThinLTOData,\n+        Module: ModuleRef,\n+    ) -> bool;\n+    pub fn LLVMRustPrepareThinLTOImport(\n+        Data: *const ThinLTOData,\n+        Module: ModuleRef,\n+    ) -> bool;\n+    pub fn LLVMRustFreeThinLTOData(Data: *mut ThinLTOData);\n+    pub fn LLVMRustParseBitcodeForThinLTO(\n+        Context: ContextRef,\n+        Data: *const u8,\n+        len: usize,\n+        Identifier: *const c_char,\n+    ) -> ModuleRef;\n+    pub fn LLVMGetModuleIdentifier(M: ModuleRef, size: *mut usize) -> *const c_char;\n }"}, {"sha": "98172bca1778625da8ce88b02513b4788055a9b8", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -346,10 +346,6 @@ pub fn initialize_available_targets() {\n                  LLVMInitializePowerPCTargetMC,\n                  LLVMInitializePowerPCAsmPrinter,\n                  LLVMInitializePowerPCAsmParser);\n-    init_target!(llvm_component = \"pnacl\",\n-                 LLVMInitializePNaClTargetInfo,\n-                 LLVMInitializePNaClTarget,\n-                 LLVMInitializePNaClTargetMC);\n     init_target!(llvm_component = \"systemz\",\n                  LLVMInitializeSystemZTargetInfo,\n                  LLVMInitializeSystemZTarget,"}, {"sha": "722d0cad238f4f3f3eead66a3eb54e39626ce9c9", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -56,7 +56,8 @@ impl<'a, 'b, 'tcx> IsolatedEncoder<'a, 'b, 'tcx> {\n         };\n \n         let lazy_body = self.lazy(body);\n-        let tables = self.tcx.body_tables(body_id);\n+        let body_owner_def_id = self.tcx.hir.body_owner_def_id(body_id);\n+        let tables = self.tcx.typeck_tables_of(body_owner_def_id);\n         let lazy_tables = self.lazy(tables);\n \n         let mut visitor = NestedBodyCollector {\n@@ -67,7 +68,7 @@ impl<'a, 'b, 'tcx> IsolatedEncoder<'a, 'b, 'tcx> {\n         let lazy_nested_bodies = self.lazy_seq_ref_from_slice(&visitor.bodies_found);\n \n         let rvalue_promotable_to_static =\n-            self.tcx.rvalue_promotable_to_static.borrow()[&body.value.id];\n+            self.tcx.const_is_rvalue_promotable_to_static(body_owner_def_id);\n \n         self.lazy(&Ast {\n             body: lazy_body,"}, {"sha": "ff923ce259fb45c904a3d94059657bff8f514feb", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 268, "deletions": 42, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -14,7 +14,7 @@ use rustc::hir::def_id::{DefId};\n use rustc::infer::{InferCtxt};\n use rustc::ty::{self, TyCtxt, ParamEnv};\n use rustc::ty::maps::Providers;\n-use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Lvalue};\n+use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Lvalue, Local};\n use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n use rustc::mir::{Statement, StatementKind, Terminator, TerminatorKind};\n use rustc::mir::transform::{MirSource};\n@@ -30,6 +30,7 @@ use dataflow::{MoveDataParamEnv};\n use dataflow::{BitDenotation, BlockSets, DataflowResults, DataflowResultsConsumer};\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use dataflow::{Borrows, BorrowData, BorrowIndex};\n+use dataflow::move_paths::{MoveError, IllegalMoveOriginKind};\n use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n@@ -59,7 +60,33 @@ fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     let param_env = tcx.param_env(def_id);\n     tcx.infer_ctxt().enter(|_infcx| {\n \n-        let move_data = MoveData::gather_moves(mir, tcx, param_env);\n+        let move_data = match MoveData::gather_moves(mir, tcx, param_env) {\n+            Ok(move_data) => move_data,\n+            Err((move_data, move_errors)) => {\n+                for move_error in move_errors {\n+                    let (span, kind): (Span, IllegalMoveOriginKind) = match move_error {\n+                        MoveError::UnionMove { .. } =>\n+                            unimplemented!(\"dont know how to report union move errors yet.\"),\n+                        MoveError::IllegalMove { cannot_move_out_of: o } => (o.span, o.kind),\n+                    };\n+                    let origin = Origin::Mir;\n+                    let mut err = match kind {\n+                        IllegalMoveOriginKind::Static =>\n+                            tcx.cannot_move_out_of(span, \"static item\", origin),\n+                        IllegalMoveOriginKind::BorrowedContent =>\n+                            tcx.cannot_move_out_of(span, \"borrowed_content\", origin),\n+                        IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } =>\n+                            tcx.cannot_move_out_of_interior_of_drop(span, ty, origin),\n+                        IllegalMoveOriginKind::InteriorOfSlice { elem_ty: ty, is_index } =>\n+                            tcx.cannot_move_out_of_interior_noncopy(span, ty, is_index, origin),\n+                        IllegalMoveOriginKind::InteriorOfArray { elem_ty: ty, is_index } =>\n+                            tcx.cannot_move_out_of_interior_noncopy(span, ty, is_index, origin),\n+                    };\n+                    err.emit();\n+                }\n+                move_data\n+            }\n+        };\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n         let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n         let flow_borrows = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n@@ -559,7 +586,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                                                 context: Context,\n                                                 (lvalue, span): (&Lvalue<'gcx>, Span),\n                                                 flow_state: &InProgress<'b, 'gcx>) {\n-        let move_data = flow_state.inits.base_results.operator().move_data();\n+        let move_data = self.move_data;\n \n         // determine if this path has a non-mut owner (and thus needs checking).\n         let mut l = lvalue;\n@@ -584,7 +611,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             }\n         }\n \n-        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n+        if let Some(mpi) = self.move_path_for_lvalue(lvalue) {\n             if flow_state.inits.curr_state.contains(&mpi) {\n                 // may already be assigned before reaching this statement;\n                 // report error.\n@@ -615,29 +642,115 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         let lvalue = self.base_path(lvalue_span.0);\n \n         let maybe_uninits = &flow_state.uninits;\n-        let move_data = maybe_uninits.base_results.operator().move_data();\n-        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n-            if maybe_uninits.curr_state.contains(&mpi) {\n-                // find and report move(s) that could cause this to be uninitialized\n+\n+        // Bad scenarios:\n+        //\n+        // 1. Move of `a.b.c`, use of `a.b.c`\n+        // 2. Move of `a.b.c`, use of `a.b.c.d` (without first reinitializing `a.b.c.d`)\n+        // 3. Move of `a.b.c`, use of `a` or `a.b`\n+        // 4. Uninitialized `(a.b.c: &_)`, use of `*a.b.c`; note that with\n+        //    partial initialization support, one might have `a.x`\n+        //    initialized but not `a.b`.\n+        //\n+        // OK scenarios:\n+        //\n+        // 5. Move of `a.b.c`, use of `a.b.d`\n+        // 6. Uninitialized `a.x`, initialized `a.b`, use of `a.b`\n+        // 7. Copied `(a.b: &_)`, use of `*(a.b).c`; note that `a.b`\n+        //    must have been initialized for the use to be sound.\n+        // 8. Move of `a.b.c` then reinit of `a.b.c.d`, use of `a.b.c.d`\n+\n+        // The dataflow tracks shallow prefixes distinctly (that is,\n+        // field-accesses on P distinctly from P itself), in order to\n+        // track substructure initialization separately from the whole\n+        // structure.\n+        //\n+        // E.g., when looking at (*a.b.c).d, if the closest prefix for\n+        // which we have a MovePath is `a.b`, then that means that the\n+        // initialization state of `a.b` is all we need to inspect to\n+        // know if `a.b.c` is valid (and from that we infer that the\n+        // dereference and `.d` access is also valid, since we assume\n+        // `a.b.c` is assigned a reference to a initialized and\n+        // well-formed record structure.)\n+\n+        // Therefore, if we seek out the *closest* prefix for which we\n+        // have a MovePath, that should capture the initialization\n+        // state for the lvalue scenario.\n+        //\n+        // This code covers scenarios 1, 2, and 4.\n+\n+        debug!(\"check_if_path_is_moved part1 lvalue: {:?}\", lvalue);\n+        match self.move_path_closest_to(lvalue) {\n+            Ok(mpi) => {\n+                if maybe_uninits.curr_state.contains(&mpi) {\n+                    self.report_use_of_moved(context, desired_action, lvalue_span);\n+                    return; // don't bother finding other problems.\n+                }\n+            }\n+            Err(NoMovePathFound::ReachedStatic) => {\n+                // Okay: we do not build MoveData for static variables\n+            }\n+\n+            // Only query longest prefix with a MovePath, not further\n+            // ancestors; dataflow recurs on children when parents\n+            // move (to support partial (re)inits).\n+            //\n+            // (I.e. querying parents breaks scenario 8; but may want\n+            // to do such a query based on partial-init feature-gate.)\n+        }\n+\n+        // A move of any shallow suffix of `lvalue` also interferes\n+        // with an attempt to use `lvalue`. This is scenario 3 above.\n+        //\n+        // (Distinct from handling of scenarios 1+2+4 above because\n+        // `lvalue` does not interfere with suffixes of its prefixes,\n+        // e.g. `a.b.c` does not interfere with `a.b.d`)\n+\n+        debug!(\"check_if_path_is_moved part2 lvalue: {:?}\", lvalue);\n+        if let Some(mpi) = self.move_path_for_lvalue(lvalue) {\n+            if let Some(_) = maybe_uninits.has_any_child_of(mpi) {\n                 self.report_use_of_moved(context, desired_action, lvalue_span);\n-            } else {\n-                // sanity check: initialized on *some* path, right?\n-                assert!(flow_state.inits.curr_state.contains(&mpi));\n+                return; // don't bother finding other problems.\n             }\n         }\n     }\n \n+    /// Currently MoveData does not store entries for all lvalues in\n+    /// the input MIR. For example it will currently filter out\n+    /// lvalues that are Copy; thus we do not track lvalues of shared\n+    /// reference type. This routine will walk up an lvalue along its\n+    /// prefixes, searching for a foundational lvalue that *is*\n+    /// tracked in the MoveData.\n+    ///\n+    /// An Err result includes a tag indicated why the search failed.\n+    /// Currenly this can only occur if the lvalue is built off of a\n+    /// static variable, as we do not track those in the MoveData.\n+    fn move_path_closest_to(&mut self, lvalue: &Lvalue<'gcx>)\n+                            -> Result<MovePathIndex, NoMovePathFound>\n+    {\n+        let mut last_prefix = lvalue;\n+        for prefix in self.prefixes(lvalue, PrefixSet::All) {\n+            if let Some(mpi) = self.move_path_for_lvalue(prefix) {\n+                return Ok(mpi);\n+            }\n+            last_prefix = prefix;\n+        }\n+        match *last_prefix {\n+            Lvalue::Local(_) => panic!(\"should have move path for every Local\"),\n+            Lvalue::Projection(_) => panic!(\"PrefixSet::All meant dont stop for Projection\"),\n+            Lvalue::Static(_) => return Err(NoMovePathFound::ReachedStatic),\n+        }\n+    }\n+\n     fn move_path_for_lvalue(&mut self,\n-                            _context: Context,\n-                            move_data: &MoveData<'gcx>,\n                             lvalue: &Lvalue<'gcx>)\n                             -> Option<MovePathIndex>\n     {\n         // If returns None, then there is no move path corresponding\n         // to a direct owner of `lvalue` (which means there is nothing\n         // that borrowck tracks for its analysis).\n \n-        match move_data.rev_lookup.find(lvalue) {\n+        match self.move_data.rev_lookup.find(lvalue) {\n             LookupResult::Parent(_) => None,\n             LookupResult::Exact(mpi) => Some(mpi),\n         }\n@@ -706,6 +819,11 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum NoMovePathFound {\n+    ReachedStatic,\n+}\n+\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn each_borrow_involving_path<F>(&mut self,\n                                      _context: Context,\n@@ -819,12 +937,19 @@ mod prefixes {\n \n     #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n     pub(super) enum PrefixSet {\n+        /// Doesn't stop until it returns the base case (a Local or\n+        /// Static prefix).\n         All,\n+        /// Stops at any dereference.\n         Shallow,\n+        /// Stops at the deref of a shared reference.\n         Supporting,\n     }\n \n     impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+        /// Returns an iterator over the prefixes of `lvalue`\n+        /// (inclusive) from longest to smallest, potentially\n+        /// terminating the iteration early based on `kind`.\n         pub(super) fn prefixes<'d>(&self,\n                                    lvalue: &'d Lvalue<'gcx>,\n                                    kind: PrefixSet)\n@@ -1053,49 +1178,52 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     // End-user visible description of `lvalue`\n     fn describe_lvalue(&self, lvalue: &Lvalue) -> String {\n         let mut buf = String::new();\n-        self.append_lvalue_to_string(lvalue, &mut buf);\n+        self.append_lvalue_to_string(lvalue, &mut buf, None);\n         buf\n     }\n \n     // Appends end-user visible description of `lvalue` to `buf`.\n-    fn append_lvalue_to_string(&self, lvalue: &Lvalue, buf: &mut String) {\n+    fn append_lvalue_to_string(&self, lvalue: &Lvalue, buf: &mut String, autoderef: Option<bool>) {\n         match *lvalue {\n             Lvalue::Local(local) => {\n-                let local = &self.mir.local_decls[local];\n-                match local.name {\n-                    Some(name) => buf.push_str(&format!(\"{}\", name)),\n-                    None => buf.push_str(\"_\"),\n-                }\n+                self.append_local_to_string(local, buf, \"_\");\n             }\n             Lvalue::Static(ref static_) => {\n                 buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n             }\n             Lvalue::Projection(ref proj) => {\n+                let mut autoderef = autoderef.unwrap_or(false);\n                 let (prefix, suffix, index_operand) = match proj.elem {\n-                    ProjectionElem::Deref =>\n-                        (\"(*\", format!(\")\"), None),\n+                    ProjectionElem::Deref => {\n+                        if autoderef {\n+                            (\"\", format!(\"\"), None)\n+                        } else {\n+                            (\"(*\", format!(\")\"), None)\n+                        }\n+                    },\n                     ProjectionElem::Downcast(..) =>\n                         (\"\",   format!(\"\"), None), // (dont emit downcast info)\n-                    ProjectionElem::Field(field, _ty) =>\n-                        (\"\",   format!(\".{}\", field.index()), None), // FIXME: report name of field\n-                    ProjectionElem::Index(index) =>\n-                        (\"\",   format!(\"\"), Some(index)),\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n-                        (\"\",   format!(\"[{} of {}]\", offset, min_length), None),\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } =>\n-                        (\"\",   format!(\"[-{} of {}]\", offset, min_length), None),\n-                    ProjectionElem::Subslice { from, to: 0 } =>\n-                        (\"\",   format!(\"[{}:]\", from), None),\n-                    ProjectionElem::Subslice { from: 0, to } =>\n-                        (\"\",   format!(\"[:-{}]\", to), None),\n-                    ProjectionElem::Subslice { from, to } =>\n-                        (\"\",   format!(\"[{}:-{}]\", from, to), None),\n+                    ProjectionElem::Field(field, _ty) => {\n+                        autoderef = true;\n+                        (\"\", format!(\".{}\", self.describe_field(&proj.base, field.index())), None)\n+                    },\n+                    ProjectionElem::Index(index) => {\n+                        autoderef = true;\n+                        (\"\",   format!(\"\"), Some(index))\n+                    },\n+                    ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n+                        autoderef = true;\n+                        // Since it isn't possible to borrow an element on a particular index and\n+                        // then use another while the borrow is held, don't output indices details\n+                        // to avoid confusing the end-user\n+                        (\"\",   format!(\"[..]\"), None)\n+                    },\n                 };\n                 buf.push_str(prefix);\n-                self.append_lvalue_to_string(&proj.base, buf);\n+                self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n                 if let Some(index) = index_operand {\n                     buf.push_str(\"[\");\n-                    self.append_lvalue_to_string(&Lvalue::Local(index), buf);\n+                    self.append_local_to_string(index, buf, \"..\");\n                     buf.push_str(\"]\");\n                 } else {\n                     buf.push_str(&suffix);\n@@ -1104,11 +1232,80 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         }\n     }\n \n+    // Appends end-user visible description of the `local` lvalue to `buf`. If `local` doesn't have\n+    // a name, then `none_string` is appended instead\n+    fn append_local_to_string(&self, local_index: Local, buf: &mut String, none_string: &str) {\n+        let local = &self.mir.local_decls[local_index];\n+        match local.name {\n+            Some(name) => buf.push_str(&format!(\"{}\", name)),\n+            None => buf.push_str(none_string)\n+        }\n+    }\n+\n+    // End-user visible description of the `field_index`nth field of `base`\n+    fn describe_field(&self, base: &Lvalue, field_index: usize) -> String {\n+        match *base {\n+            Lvalue::Local(local) => {\n+                let local = &self.mir.local_decls[local];\n+                self.describe_field_from_ty(&local.ty, field_index)\n+            },\n+            Lvalue::Static(ref static_) => {\n+                self.describe_field_from_ty(&static_.ty, field_index)\n+            },\n+            Lvalue::Projection(ref proj) => {\n+                match proj.elem {\n+                    ProjectionElem::Deref =>\n+                        self.describe_field(&proj.base, field_index),\n+                    ProjectionElem::Downcast(def, variant_index) =>\n+                        format!(\"{}\", def.variants[variant_index].fields[field_index].name),\n+                    ProjectionElem::Field(_, field_type) =>\n+                        self.describe_field_from_ty(&field_type, field_index),\n+                    ProjectionElem::Index(..)\n+                    | ProjectionElem::ConstantIndex { .. }\n+                    | ProjectionElem::Subslice { .. } =>\n+                        format!(\"{}\", self.describe_field(&proj.base, field_index)),\n+                }\n+            }\n+        }\n+    }\n+\n+    // End-user visible description of the `field_index`nth field of `ty`\n+    fn describe_field_from_ty(&self, ty: &ty::Ty, field_index: usize) -> String {\n+        if ty.is_box() {\n+            // If the type is a box, the field is described from the boxed type\n+            self.describe_field_from_ty(&ty.boxed_ty(), field_index)\n+        }\n+        else {\n+            match ty.sty {\n+                ty::TyAdt(def, _) => {\n+                    if def.is_enum() {\n+                        format!(\"{}\", field_index)\n+                    }\n+                    else {\n+                        format!(\"{}\", def.struct_variant().fields[field_index].name)\n+                    }\n+                },\n+                ty::TyTuple(_, _) => {\n+                    format!(\"{}\", field_index)\n+                },\n+                ty::TyRef(_, tnm) | ty::TyRawPtr(tnm) => {\n+                    self.describe_field_from_ty(&tnm.ty, field_index)\n+                },\n+                ty::TyArray(ty, _) | ty::TySlice(ty) => {\n+                    self.describe_field_from_ty(&ty, field_index)\n+                }\n+                _ => {\n+                    // Might need a revision when the fields in trait RFC is implemented\n+                    // (https://github.com/rust-lang/rfcs/pull/1546)\n+                    bug!(\"End-user description not implemented for field access on `{:?}`\", ty.sty);\n+                }\n+            }\n+        }\n+    }\n+\n     // Retrieve span of given borrow from the current MIR representation\n     fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n-        self.mir.basic_blocks()[borrow.location.block]\n-            .statements[borrow.location.statement_index]\n-            .source_info.span\n+        self.mir.source_info(borrow.location).span\n     }\n }\n \n@@ -1241,6 +1438,35 @@ impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n     }\n }\n \n+impl<'b, 'tcx> FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>> {\n+    fn has_any_child_of(&self, mpi: MovePathIndex) -> Option<MovePathIndex> {\n+        let move_data = self.base_results.operator().move_data();\n+\n+        let mut todo = vec![mpi];\n+        let mut push_siblings = false; // don't look at siblings of original `mpi`.\n+        while let Some(mpi) = todo.pop() {\n+            if self.curr_state.contains(&mpi) {\n+                return Some(mpi);\n+            }\n+            let move_path = &move_data.move_paths[mpi];\n+            if let Some(child) = move_path.first_child {\n+                todo.push(child);\n+            }\n+            if push_siblings {\n+                if let Some(sibling) = move_path.next_sibling {\n+                    todo.push(sibling);\n+                }\n+            } else {\n+                // after we've processed the original `mpi`, we should\n+                // always traverse the siblings of any of its\n+                // children.\n+                push_siblings = true;\n+            }\n+        }\n+        return None;\n+    }\n+}\n+\n impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n     fn each_state_bit<F>(&self, f: F) where F: FnMut(BD::Idx) {\n         self.curr_state.each_bit(self.base_results.operator().bits_per_block(), f)"}, {"sha": "56c926eaa615343ee7737abda5f9ac668871c62f", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -21,7 +21,7 @@ use rustc::mir::*;\n use rustc::hir;\n use hair::*;\n use syntax::ast::{Name, NodeId};\n-use syntax_pos::Span;\n+use syntax_pos::{DUMMY_SP, Span};\n \n // helper functions, broken out by category:\n mod simplify;\n@@ -398,10 +398,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             candidates.iter().take_while(|c| c.match_pairs.is_empty()).count();\n         debug!(\"match_candidates: {:?} candidates fully matched\", fully_matched);\n         let mut unmatched_candidates = candidates.split_off(fully_matched);\n-        for candidate in candidates {\n+        for (index, candidate) in candidates.into_iter().enumerate() {\n             // If so, apply any bindings, test the guard (if any), and\n             // branch to the arm.\n-            if let Some(b) = self.bind_and_guard_matched_candidate(block, arm_blocks, candidate) {\n+            let is_last = index == fully_matched - 1;\n+            if let Some(b) = self.bind_and_guard_matched_candidate(block, arm_blocks,\n+                                                                   candidate, is_last) {\n                 block = b;\n             } else {\n                 // if None is returned, then any remaining candidates\n@@ -664,7 +666,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn bind_and_guard_matched_candidate<'pat>(&mut self,\n                                               mut block: BasicBlock,\n                                               arm_blocks: &mut ArmBlocks,\n-                                              candidate: Candidate<'pat, 'tcx>)\n+                                              candidate: Candidate<'pat, 'tcx>,\n+                                              is_last_arm: bool)\n                                               -> Option<BasicBlock> {\n         debug!(\"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n                block, candidate);\n@@ -685,10 +688,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.cfg.terminate(block, source_info,\n                                TerminatorKind::if_(self.hir.tcx(), cond, arm_block, otherwise));\n             Some(otherwise)\n+        } else if !is_last_arm {\n+            // Add always true guard in case of more than one arm\n+            // it creates false edges and allow MIR borrowck detects errors\n+            // FIXME(#45184) -- permit \"false edges\"\n+            let source_info = self.source_info(candidate.span);\n+            let true_expr = Expr {\n+                temp_lifetime: None,\n+                ty: self.hir.tcx().types.bool,\n+                span: DUMMY_SP,\n+                kind: ExprKind::Literal{literal: self.hir.true_literal()},\n+            };\n+            let cond = unpack!(block = self.as_local_operand(block, true_expr));\n+            let otherwise = self.cfg.start_new_block();\n+            self.cfg.terminate(block, source_info,\n+                               TerminatorKind::if_(self.hir.tcx(), cond, arm_block, otherwise));\n+            Some(otherwise)\n         } else {\n             let source_info = self.source_info(candidate.span);\n             self.cfg.terminate(block, source_info,\n-                               TerminatorKind::Goto { target: arm_block });\n+                               TerminatorKind::Goto { target: arm_block  });\n             None\n         }\n     }"}, {"sha": "9b3f16f1ab4326b06369a1301008912449f1bb50", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -26,7 +26,6 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use build::matches::{Binding, MatchPair, Candidate};\n use hair::*;\n use rustc::mir::*;\n-use rustc_data_structures::fx::FxHashMap;\n \n use std::mem;\n \n@@ -102,12 +101,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 if self.hir.tcx().sess.features.borrow().never_type {\n                     let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n                         i == variant_index || {\n-                            let mut visited = FxHashMap::default();\n-                            let node_set = v.uninhabited_from(&mut visited,\n-                                                              self.hir.tcx(),\n-                                                              substs,\n-                                                              adt_def.adt_kind());\n-                            !node_set.is_empty()\n+                            self.hir.tcx().is_variant_uninhabited_from_all_modules(v, substs)\n                         }\n                     });\n                     if irrefutable {"}, {"sha": "b8bb2a404620e1a95d982c73b9ad0bbcc6bc1afe", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -149,7 +149,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             mem::transmute::<Mir, Mir<'tcx>>(mir)\n         };\n \n-        mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n+        mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir, |_, _| Ok(()) );\n \n         mir\n     })\n@@ -227,7 +227,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 mem::transmute::<Mir, Mir<'tcx>>(mir)\n             };\n \n-            mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n+            mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir, |_, _| Ok(()) );\n \n             mir\n         })"}, {"sha": "c0d17a1590f84e01b0ca429ecb79124e14f5f3a5", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 86, "deletions": 53, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -131,6 +131,9 @@ pub struct Scope<'tcx> {\n \n     /// The cache for drop chain on \"generator drop\" exit.\n     cached_generator_drop: Option<BasicBlock>,\n+\n+    /// The cache for drop chain on \"unwind\" exit.\n+    cached_unwind: CachedBlock,\n }\n \n #[derive(Debug)]\n@@ -154,6 +157,11 @@ struct CachedBlock {\n     unwind: Option<BasicBlock>,\n \n     /// The cached block for unwinds during cleanups-on-generator-drop path\n+    ///\n+    /// This is split from the standard unwind path here to prevent drop\n+    /// elaboration from creating drop flags that would have to be captured\n+    /// by the generator. I'm not sure how important this optimization is,\n+    /// but it is here.\n     generator_drop: Option<BasicBlock>,\n }\n \n@@ -217,34 +225,29 @@ impl<'tcx> Scope<'tcx> {\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n     /// larger extent of code.\n     ///\n-    /// `unwind` controls whether caches for the unwind branch are also invalidated.\n-    fn invalidate_cache(&mut self, unwind: bool) {\n+    /// `storage_only` controls whether to invalidate only drop paths run `StorageDead`.\n+    /// `this_scope_only` controls whether to invalidate only drop paths that refer to the current\n+    /// top-of-scope (as opposed to dependent scopes).\n+    fn invalidate_cache(&mut self, storage_only: bool, this_scope_only: bool) {\n+        // FIXME: maybe do shared caching of `cached_exits` etc. to handle functions\n+        // with lots of `try!`?\n+\n+        // cached exits drop storage and refer to the top-of-scope\n         self.cached_exits.clear();\n-        if !unwind { return; }\n-        for dropdata in &mut self.drops {\n-            if let DropKind::Value { ref mut cached_block } = dropdata.kind {\n-                cached_block.invalidate();\n-            }\n+\n+        if !storage_only {\n+            // the current generator drop and unwind ignore\n+            // storage but refer to top-of-scope\n+            self.cached_generator_drop = None;\n+            self.cached_unwind.invalidate();\n         }\n-    }\n \n-    /// Returns the cached entrypoint for diverging exit from this scope.\n-    ///\n-    /// Precondition: the caches must be fully filled (i.e. diverge_cleanup is called) in order for\n-    /// this method to work correctly.\n-    fn cached_block(&self, generator_drop: bool) -> Option<BasicBlock> {\n-        let mut drops = self.drops.iter().rev().filter_map(|data| {\n-            match data.kind {\n-                DropKind::Value { cached_block } => {\n-                    Some(cached_block.get(generator_drop))\n+        if !storage_only && !this_scope_only {\n+            for dropdata in &mut self.drops {\n+                if let DropKind::Value { ref mut cached_block } = dropdata.kind {\n+                    cached_block.invalidate();\n                 }\n-                DropKind::Storage => None\n             }\n-        });\n-        if let Some(cached_block) = drops.next() {\n-            Some(cached_block.expect(\"drop cache is not filled\"))\n-        } else {\n-            None\n         }\n     }\n \n@@ -356,7 +359,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             needs_cleanup: false,\n             drops: vec![],\n             cached_generator_drop: None,\n-            cached_exits: FxHashMap()\n+            cached_exits: FxHashMap(),\n+            cached_unwind: CachedBlock::default(),\n         });\n     }\n \n@@ -482,15 +486,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                    TerminatorKind::Goto { target: b });\n                 b\n             };\n+\n+            // End all regions for scopes out of which we are breaking.\n+            self.cfg.push_end_region(self.hir.tcx(), block, src_info, scope.region_scope);\n+\n             unpack!(block = build_scope_drops(&mut self.cfg,\n                                               scope,\n                                               rest,\n                                               block,\n                                               self.arg_count,\n                                               true));\n-\n-            // End all regions for scopes out of which we are breaking.\n-            self.cfg.push_end_region(self.hir.tcx(), block, src_info, scope.region_scope);\n         }\n \n         self.cfg.terminate(block, src_info, TerminatorKind::GeneratorDrop);\n@@ -672,8 +677,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // invalidating caches of each scope visited. This way bare minimum of the\n             // caches gets invalidated. i.e. if a new drop is added into the middle scope, the\n             // cache of outer scpoe stays intact.\n-            let invalidate_unwind = needs_drop && !this_scope;\n-            scope.invalidate_cache(invalidate_unwind);\n+            scope.invalidate_cache(!needs_drop, this_scope);\n             if this_scope {\n                 if let DropKind::Value { .. } = drop_kind {\n                     scope.needs_cleanup = true;\n@@ -819,30 +823,50 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n                            generator_drop: bool)\n                            -> BlockAnd<()> {\n     debug!(\"build_scope_drops({:?} -> {:?})\", block, scope);\n-    let mut iter = scope.drops.iter().rev().peekable();\n+    let mut iter = scope.drops.iter().rev();\n     while let Some(drop_data) = iter.next() {\n         let source_info = scope.source_info(drop_data.span);\n         match drop_data.kind {\n             DropKind::Value { .. } => {\n-                // Try to find the next block with its cached block\n-                // for us to diverge into in case the drop panics.\n-                let on_diverge = iter.peek().iter().filter_map(|dd| {\n+                // Try to find the next block with its cached block for us to\n+                // diverge into, either a previous block in this current scope or\n+                // the top of the previous scope.\n+                //\n+                // If it wasn't for EndRegion, we could just chain all the DropData\n+                // together and pick the first DropKind::Value. Please do that\n+                // when we replace EndRegion with NLL.\n+                let on_diverge = iter.clone().filter_map(|dd| {\n                     match dd.kind {\n-                        DropKind::Value { cached_block } => {\n-                            let result = cached_block.get(generator_drop);\n-                            if result.is_none() {\n-                                span_bug!(drop_data.span, \"cached block not present?\")\n-                            }\n-                            result\n-                        },\n+                        DropKind::Value { cached_block } => Some(cached_block),\n                         DropKind::Storage => None\n                     }\n-                }).next();\n-                // If there\u2019s no `cached_block`s within current scope,\n-                // we must look for one in the enclosing scope.\n-                let on_diverge = on_diverge.or_else(|| {\n-                    earlier_scopes.iter().rev().flat_map(|s| s.cached_block(generator_drop)).next()\n+                }).next().or_else(|| {\n+                    if earlier_scopes.iter().any(|scope| scope.needs_cleanup) {\n+                        // If *any* scope requires cleanup code to be run,\n+                        // we must use the cached unwind from the *topmost*\n+                        // scope, to ensure all EndRegions from surrounding\n+                        // scopes are executed before the drop code runs.\n+                        Some(earlier_scopes.last().unwrap().cached_unwind)\n+                    } else {\n+                        // We don't need any further cleanup, so return None\n+                        // to avoid creating a landing pad. We can skip\n+                        // EndRegions because all local regions end anyway\n+                        // when the function unwinds.\n+                        //\n+                        // This is an important optimization because LLVM is\n+                        // terrible at optimizing landing pads. FIXME: I think\n+                        // it would be cleaner and better to do this optimization\n+                        // in SimplifyCfg instead of here.\n+                        None\n+                    }\n+                });\n+\n+                let on_diverge = on_diverge.map(|cached_block| {\n+                    cached_block.get(generator_drop).unwrap_or_else(|| {\n+                        span_bug!(drop_data.span, \"cached block not present?\")\n+                    })\n                 });\n+\n                 let next = cfg.start_new_block();\n                 cfg.terminate(block, source_info, TerminatorKind::Drop {\n                     location: drop_data.location.clone(),\n@@ -933,14 +957,23 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         };\n     }\n \n-    // Finally, push the EndRegion block, used by mir-borrowck. (Block\n-    // becomes trivial goto after pass that removes all EndRegions.)\n-    {\n-        let block = cfg.start_new_cleanup_block();\n-        cfg.push_end_region(tcx, block, source_info(span), scope.region_scope);\n-        cfg.terminate(block, source_info(span), TerminatorKind::Goto { target: target });\n-        target = block\n-    }\n+    // Finally, push the EndRegion block, used by mir-borrowck, and set\n+    // `cached_unwind` to point to it (Block becomes trivial goto after\n+    // pass that removes all EndRegions).\n+    target = {\n+        let cached_block = scope.cached_unwind.ref_mut(generator_drop);\n+        if let Some(cached_block) = *cached_block {\n+            cached_block\n+        } else {\n+            let block = cfg.start_new_cleanup_block();\n+            cfg.push_end_region(tcx, block, source_info(span), scope.region_scope);\n+            cfg.terminate(block, source_info(span), TerminatorKind::Goto { target: target });\n+            *cached_block = Some(block);\n+            block\n+        }\n+    };\n+\n+    debug!(\"build_diverge_scope({:?}, {:?}) = {:?}\", scope, span, target);\n \n     target\n }"}, {"sha": "0790d937cebf014df686036a22f07ea2c78658e4", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 102, "deletions": 63, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -22,17 +22,15 @@ use std::mem;\n use super::abs_domain::Lift;\n \n use super::{LocationMap, MoveData, MovePath, MovePathLookup, MovePathIndex, MoveOut, MoveOutIndex};\n+use super::{MoveError};\n+use super::IllegalMoveOriginKind::*;\n \n-pub(super) struct MoveDataBuilder<'a, 'tcx: 'a> {\n+struct MoveDataBuilder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     data: MoveData<'tcx>,\n-}\n-\n-pub enum MovePathError {\n-    IllegalMove,\n-    UnionMove { path: MovePathIndex },\n+    errors: Vec<MoveError<'tcx>>,\n }\n \n impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n@@ -47,6 +45,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             mir,\n             tcx,\n             param_env,\n+            errors: Vec::new(),\n             data: MoveData {\n                 moves: IndexVec::new(),\n                 loc_map: LocationMap::new(mir),\n@@ -85,7 +84,9 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n         assert_eq!(path_map_ent, move_path);\n         move_path\n     }\n+}\n \n+impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     /// This creates a MovePath for a given lvalue, returning an `MovePathError`\n     /// if that lvalue can't be moved from.\n     ///\n@@ -94,13 +95,15 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     ///\n     /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n     fn move_path_for(&mut self, lval: &Lvalue<'tcx>)\n-                     -> Result<MovePathIndex, MovePathError>\n+                     -> Result<MovePathIndex, MoveError<'tcx>>\n     {\n         debug!(\"lookup({:?})\", lval);\n         match *lval {\n-            Lvalue::Local(local) => Ok(self.data.rev_lookup.locals[local]),\n-            // error: can't move out of a static\n-            Lvalue::Static(..) => Err(MovePathError::IllegalMove),\n+            Lvalue::Local(local) => Ok(self.builder.data.rev_lookup.locals[local]),\n+            Lvalue::Static(..) => {\n+                let span = self.builder.mir.source_info(self.loc).span;\n+                Err(MoveError::cannot_move_out_of(span, Static))\n+            }\n             Lvalue::Projection(ref proj) => {\n                 self.move_path_for_projection(lval, proj)\n             }\n@@ -116,37 +119,52 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     fn move_path_for_projection(&mut self,\n                                 lval: &Lvalue<'tcx>,\n                                 proj: &LvalueProjection<'tcx>)\n-                                -> Result<MovePathIndex, MovePathError>\n+                                -> Result<MovePathIndex, MoveError<'tcx>>\n     {\n         let base = try!(self.move_path_for(&proj.base));\n-        let lv_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        let mir = self.builder.mir;\n+        let tcx = self.builder.tcx;\n+        let lv_ty = proj.base.ty(mir, tcx).to_ty(tcx);\n         match lv_ty.sty {\n-            // error: can't move out of borrowed content\n-            ty::TyRef(..) | ty::TyRawPtr(..) => return Err(MovePathError::IllegalMove),\n-            // error: can't move out of struct with destructor\n-            ty::TyAdt(adt, _) if adt.has_dtor(self.tcx) && !adt.is_box() =>\n-                return Err(MovePathError::IllegalMove),\n+            ty::TyRef(..) | ty::TyRawPtr(..) =>\n+                return Err(MoveError::cannot_move_out_of(mir.source_info(self.loc).span,\n+                                                         BorrowedContent)),\n+            ty::TyAdt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n+                return Err(MoveError::cannot_move_out_of(mir.source_info(self.loc).span,\n+                                                         InteriorOfTypeWithDestructor {\n+                    container_ty: lv_ty\n+                })),\n             // move out of union - always move the entire union\n             ty::TyAdt(adt, _) if adt.is_union() =>\n-                return Err(MovePathError::UnionMove { path: base }),\n-            // error: can't move out of a slice\n-            ty::TySlice(..) =>\n-                return Err(MovePathError::IllegalMove),\n-            ty::TyArray(..) => match proj.elem {\n-                // error: can't move out of an array\n-                ProjectionElem::Index(..) => return Err(MovePathError::IllegalMove),\n+                return Err(MoveError::UnionMove { path: base }),\n+            ty::TySlice(elem_ty) =>\n+                return Err(MoveError::cannot_move_out_of(\n+                    mir.source_info(self.loc).span,\n+                    InteriorOfSlice {\n+                        elem_ty, is_index: match proj.elem {\n+                            ProjectionElem::Index(..) => true,\n+                            _ => false\n+                        },\n+                    })),\n+            ty::TyArray(elem_ty, _num_elems) => match proj.elem {\n+                ProjectionElem::Index(..) =>\n+                    return Err(MoveError::cannot_move_out_of(\n+                        mir.source_info(self.loc).span,\n+                        InteriorOfArray {\n+                            elem_ty, is_index: true\n+                        })),\n                 _ => {\n                     // FIXME: still badly broken\n                 }\n             },\n             _ => {}\n         };\n-        match self.data.rev_lookup.projections.entry((base, proj.elem.lift())) {\n+        match self.builder.data.rev_lookup.projections.entry((base, proj.elem.lift())) {\n             Entry::Occupied(ent) => Ok(*ent.get()),\n             Entry::Vacant(ent) => {\n-                let path = Self::new_move_path(\n-                    &mut self.data.move_paths,\n-                    &mut self.data.path_map,\n+                let path = MoveDataBuilder::new_move_path(\n+                    &mut self.builder.data.move_paths,\n+                    &mut self.builder.data.path_map,\n                     Some(base),\n                     lval.clone()\n                 );\n@@ -155,8 +173,10 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             }\n         }\n     }\n+}\n \n-    fn finalize(self) -> MoveData<'tcx> {\n+impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+    fn finalize(self) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<MoveError<'tcx>>)> {\n         debug!(\"{}\", {\n             debug!(\"moves for {:?}:\", self.mir.span);\n             for (j, mo) in self.data.moves.iter_enumerated() {\n@@ -168,14 +188,20 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             }\n             \"done dumping moves\"\n         });\n-        self.data\n+\n+        if self.errors.len() > 0 {\n+            Err((self.data, self.errors))\n+        } else {\n+            Ok(self.data)\n+        }\n     }\n }\n \n pub(super) fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n                                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      param_env: ty::ParamEnv<'tcx>)\n-                                     -> MoveData<'tcx> {\n+                                     -> Result<MoveData<'tcx>,\n+                                               (MoveData<'tcx>, Vec<MoveError<'tcx>>)> {\n     let mut builder = MoveDataBuilder::new(mir, tcx, param_env);\n \n     for (bb, block) in mir.basic_blocks().iter_enumerated() {\n@@ -197,6 +223,22 @@ pub(super) fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     fn gather_statement(&mut self, loc: Location, stmt: &Statement<'tcx>) {\n         debug!(\"gather_statement({:?}, {:?})\", loc, stmt);\n+        (Gatherer { builder: self, loc }).gather_statement(stmt);\n+    }\n+\n+    fn gather_terminator(&mut self, loc: Location, term: &Terminator<'tcx>) {\n+        debug!(\"gather_terminator({:?}, {:?})\", loc, term);\n+        (Gatherer { builder: self, loc }).gather_terminator(term);\n+    }\n+}\n+\n+struct Gatherer<'b, 'a: 'b, 'tcx: 'a> {\n+    builder: &'b mut MoveDataBuilder<'a, 'tcx>,\n+    loc: Location,\n+}\n+\n+impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n+    fn gather_statement(&mut self, stmt: &Statement<'tcx>) {\n         match stmt.kind {\n             StatementKind::Assign(ref lval, ref rval) => {\n                 self.create_move_path(lval);\n@@ -206,7 +248,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                     // the exterior.\n                     self.create_move_path(&lval.clone().deref());\n                 }\n-                self.gather_rvalue(loc, rval);\n+                self.gather_rvalue(rval);\n             }\n             StatementKind::StorageLive(_) |\n             StatementKind::StorageDead(_) => {}\n@@ -221,22 +263,22 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn gather_rvalue(&mut self, loc: Location, rvalue: &Rvalue<'tcx>) {\n+    fn gather_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n         match *rvalue {\n             Rvalue::Use(ref operand) |\n             Rvalue::Repeat(ref operand, _) |\n             Rvalue::Cast(_, ref operand, _) |\n             Rvalue::UnaryOp(_, ref operand) => {\n-                self.gather_operand(loc, operand)\n+                self.gather_operand(operand)\n             }\n             Rvalue::BinaryOp(ref _binop, ref lhs, ref rhs) |\n             Rvalue::CheckedBinaryOp(ref _binop, ref lhs, ref rhs) => {\n-                self.gather_operand(loc, lhs);\n-                self.gather_operand(loc, rhs);\n+                self.gather_operand(lhs);\n+                self.gather_operand(rhs);\n             }\n             Rvalue::Aggregate(ref _kind, ref operands) => {\n                 for operand in operands {\n-                    self.gather_operand(loc, operand);\n+                    self.gather_operand(operand);\n                 }\n             }\n             Rvalue::Ref(..) |\n@@ -258,16 +300,15 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn gather_terminator(&mut self, loc: Location, term: &Terminator<'tcx>) {\n-        debug!(\"gather_terminator({:?}, {:?})\", loc, term);\n+    fn gather_terminator(&mut self, term: &Terminator<'tcx>) {\n         match term.kind {\n             TerminatorKind::Goto { target: _ } |\n             TerminatorKind::Resume |\n             TerminatorKind::GeneratorDrop |\n             TerminatorKind::Unreachable => { }\n \n             TerminatorKind::Return => {\n-                self.gather_move(loc, &Lvalue::Local(RETURN_POINTER));\n+                self.gather_move(&Lvalue::Local(RETURN_POINTER));\n             }\n \n             TerminatorKind::Assert { .. } |\n@@ -276,20 +317,20 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             }\n \n             TerminatorKind::Yield { ref value, .. } => {\n-                self.gather_operand(loc, value);\n+                self.gather_operand(value);\n             }\n \n             TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n-                self.gather_move(loc, location);\n+                self.gather_move(location);\n             }\n             TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n                 self.create_move_path(location);\n-                self.gather_operand(loc, value);\n+                self.gather_operand(value);\n             }\n             TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n-                self.gather_operand(loc, func);\n+                self.gather_operand(func);\n                 for arg in args {\n-                    self.gather_operand(loc, arg);\n+                    self.gather_operand(arg);\n                 }\n                 if let Some((ref destination, _bb)) = *destination {\n                     self.create_move_path(destination);\n@@ -298,40 +339,38 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn gather_operand(&mut self, loc: Location, operand: &Operand<'tcx>) {\n+    fn gather_operand(&mut self, operand: &Operand<'tcx>) {\n         match *operand {\n             Operand::Constant(..) => {} // not-a-move\n             Operand::Consume(ref lval) => { // a move\n-                self.gather_move(loc, lval);\n+                self.gather_move(lval);\n             }\n         }\n     }\n \n-    fn gather_move(&mut self, loc: Location, lval: &Lvalue<'tcx>) {\n-        debug!(\"gather_move({:?}, {:?})\", loc, lval);\n+    fn gather_move(&mut self, lval: &Lvalue<'tcx>) {\n+        debug!(\"gather_move({:?}, {:?})\", self.loc, lval);\n \n-        let lv_ty = lval.ty(self.mir, self.tcx).to_ty(self.tcx);\n-        if !lv_ty.moves_by_default(self.tcx, self.param_env, DUMMY_SP) {\n-            debug!(\"gather_move({:?}, {:?}) - {:?} is Copy. skipping\", loc, lval, lv_ty);\n+        let tcx = self.builder.tcx;\n+        let lv_ty = lval.ty(self.builder.mir, tcx).to_ty(tcx);\n+        if !lv_ty.moves_by_default(tcx, self.builder.param_env, DUMMY_SP) {\n+            debug!(\"gather_move({:?}, {:?}) - {:?} is Copy. skipping\", self.loc, lval, lv_ty);\n             return\n         }\n \n         let path = match self.move_path_for(lval) {\n-            Ok(path) | Err(MovePathError::UnionMove { path }) => path,\n-            Err(MovePathError::IllegalMove) => {\n-                // Moving out of a bad path. Eventually, this should be a MIR\n-                // borrowck error instead of a bug.\n-                span_bug!(self.mir.span,\n-                          \"Broken MIR: moving out of lvalue {:?}: {:?} at {:?}\",\n-                          lval, lv_ty, loc);\n+            Ok(path) | Err(MoveError::UnionMove { path }) => path,\n+            Err(error @ MoveError::IllegalMove { .. }) => {\n+                self.builder.errors.push(error);\n+                return;\n             }\n         };\n-        let move_out = self.data.moves.push(MoveOut { path: path, source: loc });\n+        let move_out = self.builder.data.moves.push(MoveOut { path: path, source: self.loc });\n \n         debug!(\"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n-               loc, lval, move_out, path);\n+               self.loc, lval, move_out, path);\n \n-        self.data.path_map[path].push(move_out);\n-        self.data.loc_map[loc].push(move_out);\n+        self.builder.data.path_map[path].push(move_out);\n+        self.builder.data.loc_map[self.loc].push(move_out);\n     }\n }"}, {"sha": "9369156a223c87e7f6f113ea20a16f72ff847371", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -13,6 +13,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n+use syntax_pos::{Span};\n \n use std::fmt;\n use std::ops::{Index, IndexMut};\n@@ -227,11 +228,39 @@ impl<'tcx> MovePathLookup<'tcx> {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct IllegalMoveOrigin<'tcx> {\n+    pub(crate) span: Span,\n+    pub(crate) kind: IllegalMoveOriginKind<'tcx>,\n+}\n+\n+#[derive(Debug)]\n+pub(crate) enum IllegalMoveOriginKind<'tcx> {\n+    Static,\n+    BorrowedContent,\n+    InteriorOfTypeWithDestructor { container_ty: ty::Ty<'tcx> },\n+    InteriorOfSlice { elem_ty: ty::Ty<'tcx>, is_index: bool, },\n+    InteriorOfArray { elem_ty: ty::Ty<'tcx>, is_index: bool, },\n+}\n+\n+#[derive(Debug)]\n+pub enum MoveError<'tcx> {\n+    IllegalMove { cannot_move_out_of: IllegalMoveOrigin<'tcx> },\n+    UnionMove { path: MovePathIndex },\n+}\n+\n+impl<'tcx> MoveError<'tcx> {\n+    fn cannot_move_out_of(span: Span, kind: IllegalMoveOriginKind<'tcx>) -> Self {\n+        let origin = IllegalMoveOrigin { span, kind };\n+        MoveError::IllegalMove { cannot_move_out_of: origin }\n+    }\n+}\n+\n impl<'a, 'tcx> MoveData<'tcx> {\n     pub fn gather_moves(mir: &Mir<'tcx>,\n                         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         param_env: ty::ParamEnv<'tcx>)\n-                        -> Self {\n+                        -> Result<Self, (Self, Vec<MoveError<'tcx>>)> {\n         builder::gather_moves(mir, tcx, param_env)\n     }\n }"}, {"sha": "0f67f7bf6deb47fe14cdd2881b5d085703036ff0", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 775, "deletions": 0, "changes": 775, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -229,6 +229,57 @@ fn main() {\n See also https://doc.rust-lang.org/book/first-edition/unsafe.html\n \"##,\n \n+E0373: r##\"\n+This error occurs when an attempt is made to use data captured by a closure,\n+when that data may no longer exist. It's most commonly seen when attempting to\n+return a closure:\n+\n+```compile_fail,E0373\n+fn foo() -> Box<Fn(u32) -> u32> {\n+    let x = 0u32;\n+    Box::new(|y| x + y)\n+}\n+```\n+\n+Notice that `x` is stack-allocated by `foo()`. By default, Rust captures\n+closed-over data by reference. This means that once `foo()` returns, `x` no\n+longer exists. An attempt to access `x` within the closure would thus be\n+unsafe.\n+\n+Another situation where this might be encountered is when spawning threads:\n+\n+```compile_fail,E0373\n+fn foo() {\n+    let x = 0u32;\n+    let y = 1u32;\n+\n+    let thr = std::thread::spawn(|| {\n+        x + y\n+    });\n+}\n+```\n+\n+Since our new thread runs in parallel, the stack frame containing `x` and `y`\n+may well have disappeared by the time we try to use them. Even if we call\n+`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\n+stack frame won't disappear), we will not succeed: the compiler cannot prove\n+that this behaviour is safe, and so won't let us do it.\n+\n+The solution to this problem is usually to switch to using a `move` closure.\n+This approach moves (or copies, where possible) data into the closure, rather\n+than taking references to it. For example:\n+\n+```\n+fn foo() -> Box<Fn(u32) -> u32> {\n+    let x = 0u32;\n+    Box::new(move |y| x + y)\n+}\n+```\n+\n+Now that the closure has its own copy of the data, there's no need to worry\n+about safety.\n+\"##,\n+\n E0381: r##\"\n It is not allowed to use or capture an uninitialized variable. For example:\n \n@@ -250,6 +301,152 @@ fn main() {\n ```\n \"##,\n \n+E0382: r##\"\n+This error occurs when an attempt is made to use a variable after its contents\n+have been moved elsewhere. For example:\n+\n+```compile_fail,E0382\n+struct MyStruct { s: u32 }\n+\n+fn main() {\n+    let mut x = MyStruct{ s: 5u32 };\n+    let y = x;\n+    x.s = 6;\n+    println!(\"{}\", x.s);\n+}\n+```\n+\n+Since `MyStruct` is a type that is not marked `Copy`, the data gets moved out\n+of `x` when we set `y`. This is fundamental to Rust's ownership system: outside\n+of workarounds like `Rc`, a value cannot be owned by more than one variable.\n+\n+Sometimes we don't need to move the value. Using a reference, we can let another\n+function borrow the value without changing its ownership. In the example below,\n+we don't actually have to move our string to `calculate_length`, we can give it\n+a reference to it with `&` instead.\n+\n+```\n+fn main() {\n+    let s1 = String::from(\"hello\");\n+\n+    let len = calculate_length(&s1);\n+\n+    println!(\"The length of '{}' is {}.\", s1, len);\n+}\n+\n+fn calculate_length(s: &String) -> usize {\n+    s.len()\n+}\n+```\n+\n+A mutable reference can be created with `&mut`.\n+\n+Sometimes we don't want a reference, but a duplicate. All types marked `Clone`\n+can be duplicated by calling `.clone()`. Subsequent changes to a clone do not\n+affect the original variable.\n+\n+Most types in the standard library are marked `Clone`. The example below\n+demonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\n+copied to `s2`. Then the first character of `s1` is removed, without affecting\n+`s2`. \"any many\" is printed to the console.\n+\n+```\n+fn main() {\n+    let mut s1 = String::from(\"many\");\n+    let s2 = s1.clone();\n+    s1.remove(0);\n+    println!(\"{} {}\", s1, s2);\n+}\n+```\n+\n+If we control the definition of a type, we can implement `Clone` on it ourselves\n+with `#[derive(Clone)]`.\n+\n+Some types have no ownership semantics at all and are trivial to duplicate. An\n+example is `i32` and the other number types. We don't have to call `.clone()` to\n+clone them, because they are marked `Copy` in addition to `Clone`.  Implicit\n+cloning is more convienient in this case. We can mark our own types `Copy` if\n+all their members also are marked `Copy`.\n+\n+In the example below, we implement a `Point` type. Because it only stores two\n+integers, we opt-out of ownership semantics with `Copy`. Then we can\n+`let p2 = p1` without `p1` being moved.\n+\n+```\n+#[derive(Copy, Clone)]\n+struct Point { x: i32, y: i32 }\n+\n+fn main() {\n+    let mut p1 = Point{ x: -1, y: 2 };\n+    let p2 = p1;\n+    p1.x = 1;\n+    println!(\"p1: {}, {}\", p1.x, p1.y);\n+    println!(\"p2: {}, {}\", p2.x, p2.y);\n+}\n+```\n+\n+Alternatively, if we don't control the struct's definition, or mutable shared\n+ownership is truly required, we can use `Rc` and `RefCell`:\n+\n+```\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+struct MyStruct { s: u32 }\n+\n+fn main() {\n+    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n+    let y = x.clone();\n+    x.borrow_mut().s = 6;\n+    println!(\"{}\", x.borrow().s);\n+}\n+```\n+\n+With this approach, x and y share ownership of the data via the `Rc` (reference\n+count type). `RefCell` essentially performs runtime borrow checking: ensuring\n+that at most one writer or multiple readers can access the data at any one time.\n+\n+If you wish to learn more about ownership in Rust, start with the chapter in the\n+Book:\n+\n+https://doc.rust-lang.org/book/first-edition/ownership.html\n+\"##,\n+\n+E0383: r##\"\n+This error occurs when an attempt is made to partially reinitialize a\n+structure that is currently uninitialized.\n+\n+For example, this can happen when a drop has taken place:\n+\n+```compile_fail,E0383\n+struct Foo {\n+    a: u32,\n+}\n+impl Drop for Foo {\n+    fn drop(&mut self) { /* ... */ }\n+}\n+\n+let mut x = Foo { a: 1 };\n+drop(x); // `x` is now uninitialized\n+x.a = 2; // error, partial reinitialization of uninitialized structure `t`\n+```\n+\n+This error can be fixed by fully reinitializing the structure in question:\n+\n+```\n+struct Foo {\n+    a: u32,\n+}\n+impl Drop for Foo {\n+    fn drop(&mut self) { /* ... */ }\n+}\n+\n+let mut x = Foo { a: 1 };\n+drop(x);\n+x = Foo { a: 2 };\n+```\n+\"##,\n+\n E0384: r##\"\n This error occurs when an attempt is made to reassign an immutable variable.\n For example:\n@@ -272,6 +469,161 @@ fn main() {\n ```\n \"##,\n \n+/*E0386: r##\"\n+This error occurs when an attempt is made to mutate the target of a mutable\n+reference stored inside an immutable container.\n+\n+For example, this can happen when storing a `&mut` inside an immutable `Box`:\n+\n+```compile_fail,E0386\n+let mut x: i64 = 1;\n+let y: Box<_> = Box::new(&mut x);\n+**y = 2; // error, cannot assign to data in an immutable container\n+```\n+\n+This error can be fixed by making the container mutable:\n+\n+```\n+let mut x: i64 = 1;\n+let mut y: Box<_> = Box::new(&mut x);\n+**y = 2;\n+```\n+\n+It can also be fixed by using a type with interior mutability, such as `Cell`\n+or `RefCell`:\n+\n+```\n+use std::cell::Cell;\n+\n+let x: i64 = 1;\n+let y: Box<Cell<_>> = Box::new(Cell::new(x));\n+y.set(2);\n+```\n+\"##,*/\n+\n+E0387: r##\"\n+This error occurs when an attempt is made to mutate or mutably reference data\n+that a closure has captured immutably. Examples of this error are shown below:\n+\n+```compile_fail,E0387\n+// Accepts a function or a closure that captures its environment immutably.\n+// Closures passed to foo will not be able to mutate their closed-over state.\n+fn foo<F: Fn()>(f: F) { }\n+\n+// Attempts to mutate closed-over data. Error message reads:\n+// `cannot assign to data in a captured outer variable...`\n+fn mutable() {\n+    let mut x = 0u32;\n+    foo(|| x = 2);\n+}\n+\n+// Attempts to take a mutable reference to closed-over data.  Error message\n+// reads: `cannot borrow data mutably in a captured outer variable...`\n+fn mut_addr() {\n+    let mut x = 0u32;\n+    foo(|| { let y = &mut x; });\n+}\n+```\n+\n+The problem here is that foo is defined as accepting a parameter of type `Fn`.\n+Closures passed into foo will thus be inferred to be of type `Fn`, meaning that\n+they capture their context immutably.\n+\n+If the definition of `foo` is under your control, the simplest solution is to\n+capture the data mutably. This can be done by defining `foo` to take FnMut\n+rather than Fn:\n+\n+```\n+fn foo<F: FnMut()>(f: F) { }\n+```\n+\n+Alternatively, we can consider using the `Cell` and `RefCell` types to achieve\n+interior mutability through a shared reference. Our example's `mutable`\n+function could be redefined as below:\n+\n+```\n+use std::cell::Cell;\n+\n+fn foo<F: Fn()>(f: F) { }\n+\n+fn mutable() {\n+    let x = Cell::new(0u32);\n+    foo(|| x.set(2));\n+}\n+```\n+\n+You can read more about cell types in the API documentation:\n+\n+https://doc.rust-lang.org/std/cell/\n+\"##,\n+\n+E0388: r##\"\n+E0388 was removed and is no longer issued.\n+\"##,\n+\n+E0389: r##\"\n+An attempt was made to mutate data using a non-mutable reference. This\n+commonly occurs when attempting to assign to a non-mutable reference of a\n+mutable reference (`&(&mut T)`).\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0389\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+    let fancy_ref = &(&mut fancy);\n+    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\n+Here, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an\n+immutable reference to a value borrows it immutably. There can be multiple\n+references of type `&(&mut T)` that point to the same value, so they must be\n+immutable to prevent multiple mutable references to the same value.\n+\n+To fix this, either remove the outer reference:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+\n+    let fancy_ref = &mut fancy;\n+    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)\n+\n+    fancy_ref.num = 6; // No error!\n+\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\n+Or make the outer reference mutable:\n+\n+```\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+\n+    let fancy_ref = &mut (&mut fancy);\n+    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)\n+\n+    fancy_ref.num = 6; // No error!\n+\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\"##,\n \n E0394: r##\"\n A static was referred to by value by another static.\n@@ -999,12 +1351,435 @@ fn print_fancy_ref(fancy_ref: &FancyNum){\n ```\n \"##,\n \n+E0507: r##\"\n+You tried to move out of a value which was borrowed. Erroneous code example:\n+\n+```compile_fail,E0507\n+use std::cell::RefCell;\n+\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+\n+    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n+}\n+```\n+\n+Here, the `nothing_is_true` method takes the ownership of `self`. However,\n+`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\n+which is a borrow of the content owned by the `RefCell`. To fix this error,\n+you have three choices:\n+\n+* Try to avoid moving the variable.\n+* Somehow reclaim the ownership.\n+* Implement the `Copy` trait on the type.\n+\n+Examples:\n+\n+```\n+use std::cell::RefCell;\n+\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(&self) {} // First case, we don't take ownership\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+\n+    x.borrow().nothing_is_true(); // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+use std::cell::RefCell;\n+\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+    let x = x.into_inner(); // we get back ownership\n+\n+    x.nothing_is_true(); // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+use std::cell::RefCell;\n+\n+#[derive(Clone, Copy)] // we implement the Copy trait\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+\n+    x.borrow().nothing_is_true(); // ok!\n+}\n+```\n+\n+Moving a member out of a mutably borrowed struct will also cause E0507 error:\n+\n+```compile_fail,E0507\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+struct Batcave {\n+    knight: TheDarkKnight\n+}\n+\n+fn main() {\n+    let mut cave = Batcave {\n+        knight: TheDarkKnight\n+    };\n+    let borrowed = &mut cave;\n+\n+    borrowed.knight.nothing_is_true(); // E0507\n+}\n+```\n+\n+It is fine only if you put something back. `mem::replace` can be used for that:\n+\n+```\n+# struct TheDarkKnight;\n+# impl TheDarkKnight { fn nothing_is_true(self) {} }\n+# struct Batcave { knight: TheDarkKnight }\n+use std::mem;\n+\n+let mut cave = Batcave {\n+    knight: TheDarkKnight\n+};\n+let borrowed = &mut cave;\n+\n+mem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n+```\n+\n+You can find more information about borrowing in the rust-book:\n+http://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n+\"##,\n+\n+E0508: r##\"\n+A value was moved out of a non-copy fixed-size array.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0508\n+struct NonCopy;\n+\n+fn main() {\n+    let array = [NonCopy; 1];\n+    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,\n+                           //        a non-copy fixed-size array\n+}\n+```\n+\n+The first element was moved out of the array, but this is not\n+possible because `NonCopy` does not implement the `Copy` trait.\n+\n+Consider borrowing the element instead of moving it:\n+\n+```\n+struct NonCopy;\n+\n+fn main() {\n+    let array = [NonCopy; 1];\n+    let _value = &array[0]; // Borrowing is allowed, unlike moving.\n+}\n+```\n+\n+Alternatively, if your type implements `Clone` and you need to own the value,\n+consider borrowing and then cloning:\n+\n+```\n+#[derive(Clone)]\n+struct NonCopy;\n+\n+fn main() {\n+    let array = [NonCopy; 1];\n+    // Now you can clone the array element.\n+    let _value = array[0].clone();\n+}\n+```\n+\"##,\n+\n+E0509: r##\"\n+This error occurs when an attempt is made to move out of a value whose type\n+implements the `Drop` trait.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0509\n+struct FancyNum {\n+    num: usize\n+}\n+\n+struct DropStruct {\n+    fancy: FancyNum\n+}\n+\n+impl Drop for DropStruct {\n+    fn drop(&mut self) {\n+        // Destruct DropStruct, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n+    let fancy_field = drop_struct.fancy; // Error E0509\n+    println!(\"Fancy: {}\", fancy_field.num);\n+    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n+}\n+```\n+\n+Here, we tried to move a field out of a struct of type `DropStruct` which\n+implements the `Drop` trait. However, a struct cannot be dropped if one or\n+more of its fields have been moved.\n+\n+Structs implementing the `Drop` trait have an implicit destructor that gets\n+called when they go out of scope. This destructor may use the fields of the\n+struct, so moving out of the struct could make it impossible to run the\n+destructor. Therefore, we must think of all values whose type implements the\n+`Drop` trait as single units whose fields cannot be moved.\n+\n+This error can be fixed by creating a reference to the fields of a struct,\n+enum, or tuple using the `ref` keyword:\n+\n+```\n+struct FancyNum {\n+    num: usize\n+}\n+\n+struct DropStruct {\n+    fancy: FancyNum\n+}\n+\n+impl Drop for DropStruct {\n+    fn drop(&mut self) {\n+        // Destruct DropStruct, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n+    let ref fancy_field = drop_struct.fancy; // No more errors!\n+    println!(\"Fancy: {}\", fancy_field.num);\n+    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n+}\n+```\n+\n+Note that this technique can also be used in the arms of a match expression:\n+\n+```\n+struct FancyNum {\n+    num: usize\n+}\n+\n+enum DropEnum {\n+    Fancy(FancyNum)\n+}\n+\n+impl Drop for DropEnum {\n+    fn drop(&mut self) {\n+        // Destruct DropEnum, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    // Creates and enum of type `DropEnum`, which implements `Drop`\n+    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});\n+    match drop_enum {\n+        // Creates a reference to the inside of `DropEnum::Fancy`\n+        DropEnum::Fancy(ref fancy_field) => // No error!\n+            println!(\"It was fancy-- {}!\", fancy_field.num),\n+    }\n+    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope\n+}\n+```\n+\"##,\n+\n+E0595: r##\"\n+Closures cannot mutate immutable captured variables.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0595\n+let x = 3; // error: closure cannot assign to immutable local variable `x`\n+let mut c = || { x += 1 };\n+```\n+\n+Make the variable binding mutable:\n+\n+```\n+let mut x = 3; // ok!\n+let mut c = || { x += 1 };\n+```\n+\"##,\n+\n+E0596: r##\"\n+This error occurs because you tried to mutably borrow a non-mutable variable.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0596\n+let x = 1;\n+let y = &mut x; // error: cannot borrow mutably\n+```\n+\n+In here, `x` isn't mutable, so when we try to mutably borrow it in `y`, it\n+fails. To fix this error, you need to make `x` mutable:\n+\n+```\n+let mut x = 1;\n+let y = &mut x; // ok!\n+```\n+\"##,\n+\n+E0597: r##\"\n+This error occurs because a borrow was made inside a variable which has a\n+greater lifetime than the borrowed one.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0597\n+struct Foo<'a> {\n+    x: Option<&'a u32>,\n+}\n+\n+let mut x = Foo { x: None };\n+let y = 0;\n+x.x = Some(&y); // error: `y` does not live long enough\n+```\n+\n+In here, `x` is created before `y` and therefore has a greater lifetime. Always\n+keep in mind that values in a scope are dropped in the opposite order they are\n+created. So to fix the previous example, just make the `y` lifetime greater than\n+the `x`'s one:\n+\n+```\n+struct Foo<'a> {\n+    x: Option<&'a u32>,\n+}\n+\n+let y = 0;\n+let mut x = Foo { x: None };\n+x.x = Some(&y);\n+```\n+\"##,\n+\n+E0626: r##\"\n+This error occurs because a borrow in a generator persists across a\n+yield point.\n+\n+```compile_fail,E0626\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+    let a = &String::new(); // <-- This borrow...\n+    yield (); // ...is still in scope here, when the yield occurs.\n+    println!(\"{}\", a);\n+};\n+b.resume();\n+```\n+\n+At present, it is not permitted to have a yield that occurs while a\n+borrow is still in scope. To resolve this error, the borrow must\n+either be \"contained\" to a smaller scope that does not overlap the\n+yield or else eliminated in another way. So, for example, we might\n+resolve the previous example by removing the borrow and just storing\n+the integer by value:\n+\n+```\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+    let a = 3;\n+    yield ();\n+    println!(\"{}\", a);\n+};\n+b.resume();\n+```\n+\n+This is a very simple case, of course. In more complex cases, we may\n+wish to have more than one reference to the value that was borrowed --\n+in those cases, something like the `Rc` or `Arc` types may be useful.\n+\n+This error also frequently arises with iteration:\n+\n+```compile_fail,E0626\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  for &x in &v { // <-- borrow of `v` is still in scope...\n+    yield x; // ...when this yield occurs.\n+  }\n+};\n+b.resume();\n+```\n+\n+Such cases can sometimes be resolved by iterating \"by value\" (or using\n+`into_iter()`) to avoid borrowing:\n+\n+```\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  for x in v { // <-- Take ownership of the values instead!\n+    yield x; // <-- Now yield is OK.\n+  }\n+};\n+b.resume();\n+```\n+\n+If taking ownership is not an option, using indices can work too:\n+\n+```\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  let len = v.len(); // (*)\n+  for i in 0..len {\n+    let x = v[i]; // (*)\n+    yield x; // <-- Now yield is OK.\n+  }\n+};\n+b.resume();\n+\n+// (*) -- Unfortunately, these temporaries are currently required.\n+// See <https://github.com/rust-lang/rust/issues/43122>.\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {\n+//    E0385, // {} in an aliasable location\n     E0493, // destructors cannot be evaluated at compile-time\n     E0524, // two closures require unique access to `..` at the same time\n     E0526, // shuffle indices are not constant\n     E0594, // cannot assign to {}\n+    E0598, // lifetime of {} is too short to guarantee its contents can be...\n     E0625, // thread-local statics cannot be accessed at compile-time\n }"}, {"sha": "cea66837d9aaf9fe857ec0995935cede05b4bdd5", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -65,7 +65,18 @@ impl PassHook for DumpMir {\n                                pass_name,\n                                &Disambiguator { is_after },\n                                source,\n-                               mir);\n+                               mir,\n+                               |_, _| Ok(()) );\n+            for (index, promoted_mir) in mir.promoted.iter_enumerated() {\n+                let promoted_source = MirSource::Promoted(source.item_id(), index);\n+                mir_util::dump_mir(tcx,\n+                                   Some((suite, pass_num)),\n+                                   pass_name,\n+                                   &Disambiguator { is_after },\n+                                   promoted_source,\n+                                   promoted_mir,\n+                                   |_, _| Ok(()) );\n+            }\n         }\n     }\n }"}, {"sha": "be1b794ecdfab698db3816582a3fd4adc2536666", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -45,7 +45,7 @@ impl MirPass for ElaborateDrops {\n         }\n         let id = src.item_id();\n         let param_env = tcx.param_env(tcx.hir.local_def_id(id));\n-        let move_data = MoveData::gather_moves(mir, tcx, param_env);\n+        let move_data = MoveData::gather_moves(mir, tcx, param_env).unwrap();\n         let elaborate_patch = {\n             let mir = &*mir;\n             let env = MoveDataParamEnv {"}, {"sha": "7d0814b67fba5b1e216d236b62a75466c0e792af", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -587,7 +587,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     // unrelated code from the resume part of the function\n     simplify::remove_dead_blocks(&mut mir);\n \n-    dump_mir(tcx, None, \"generator_drop\", &0, source, &mut mir);\n+    dump_mir(tcx, None, \"generator_drop\", &0, source, &mut mir, |_, _| Ok(()) );\n \n     mir\n }\n@@ -673,7 +673,7 @@ fn create_generator_resume_function<'a, 'tcx>(\n     // unrelated code from the drop part of the function\n     simplify::remove_dead_blocks(mir);\n \n-    dump_mir(tcx, None, \"generator_resume\", &0, source, mir);\n+    dump_mir(tcx, None, \"generator_resume\", &0, source, mir, |_, _| Ok(()) );\n }\n \n fn source_info<'a, 'tcx>(mir: &Mir<'tcx>) -> SourceInfo {\n@@ -816,14 +816,14 @@ impl MirPass for StateTransform {\n         // This is expanded to a drop ladder in `elaborate_generator_drops`.\n         let drop_clean = insert_clean_drop(mir);\n \n-        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, mir);\n+        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, mir, |_, _| Ok(()) );\n \n         // Expand `drop(generator_struct)` to a drop ladder which destroys upvars.\n         // If any upvars are moved out of, drop elaboration will handle upvar destruction.\n         // However we need to also elaborate the code generated by `insert_clean_drop`.\n         elaborate_generator_drops(tcx, def_id, mir);\n \n-        dump_mir(tcx, None, \"generator_post-transform\", &0, source, mir);\n+        dump_mir(tcx, None, \"generator_post-transform\", &0, source, mir, |_, _| Ok(()) );\n \n         // Create a copy of our MIR and use it to create the drop shim for the generator\n         let drop_shim = create_generator_drop_shim(tcx,"}, {"sha": "e6e00f295ca11958646338efd680a45d83f29806", "filename": "src/librustc_mir/transform/nll/infer.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Ftransform%2Fnll%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Ftransform%2Fnll%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Finfer.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -0,0 +1,222 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::{Region, RegionIndex};\n+use std::mem;\n+use rustc::infer::InferCtxt;\n+use rustc::mir::{Location, Mir};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::fx::FxHashSet;\n+\n+pub struct InferenceContext {\n+    definitions: IndexVec<RegionIndex, VarDefinition>,\n+    constraints: IndexVec<ConstraintIndex, Constraint>,\n+    errors: IndexVec<InferenceErrorIndex, InferenceError>,\n+}\n+\n+pub struct InferenceError {\n+    pub constraint_point: Location,\n+    pub name: (), // FIXME(nashenas88) RegionName\n+}\n+\n+newtype_index!(InferenceErrorIndex);\n+\n+struct VarDefinition {\n+    name: (), // FIXME(nashenas88) RegionName\n+    value: Region,\n+    capped: bool,\n+}\n+\n+impl VarDefinition {\n+    pub fn new(value: Region) -> Self {\n+        Self {\n+            name: (),\n+            value,\n+            capped: false,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Constraint {\n+    sub: RegionIndex,\n+    sup: RegionIndex,\n+    point: Location,\n+}\n+\n+newtype_index!(ConstraintIndex);\n+\n+impl InferenceContext {\n+    pub fn new(values: IndexVec<RegionIndex, Region>) -> Self {\n+        Self {\n+            definitions: values.into_iter().map(VarDefinition::new).collect(),\n+            constraints: IndexVec::new(),\n+            errors: IndexVec::new(),\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn cap_var(&mut self, v: RegionIndex) {\n+        self.definitions[v].capped = true;\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn add_live_point(&mut self, v: RegionIndex, point: Location) {\n+        debug!(\"add_live_point({:?}, {:?})\", v, point);\n+        let definition = &mut self.definitions[v];\n+        if definition.value.add_point(point) {\n+            if definition.capped {\n+                self.errors.push(InferenceError {\n+                    constraint_point: point,\n+                    name: definition.name,\n+                });\n+            }\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn add_outlives(&mut self, sup: RegionIndex, sub: RegionIndex, point: Location) {\n+        debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n+        self.constraints.push(Constraint { sup, sub, point });\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn region(&self, v: RegionIndex) -> &Region {\n+        &self.definitions[v].value\n+    }\n+\n+    pub fn solve<'a, 'gcx, 'tcx>(\n+        &mut self,\n+        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+        mir: &'a Mir<'tcx>,\n+    ) -> IndexVec<InferenceErrorIndex, InferenceError>\n+    where\n+        'gcx: 'tcx + 'a,\n+        'tcx: 'a,\n+    {\n+        let mut changed = true;\n+        let mut dfs = Dfs::new(infcx, mir);\n+        while changed {\n+            changed = false;\n+            for constraint in &self.constraints {\n+                let sub = &self.definitions[constraint.sub].value.clone();\n+                let sup_def = &mut self.definitions[constraint.sup];\n+                debug!(\"constraint: {:?}\", constraint);\n+                debug!(\"    sub (before): {:?}\", sub);\n+                debug!(\"    sup (before): {:?}\", sup_def.value);\n+\n+                if dfs.copy(sub, &mut sup_def.value, constraint.point) {\n+                    changed = true;\n+                    if sup_def.capped {\n+                        // This is kind of a hack, but when we add a\n+                        // constraint, the \"point\" is always the point\n+                        // AFTER the action that induced the\n+                        // constraint. So report the error on the\n+                        // action BEFORE that.\n+                        assert!(constraint.point.statement_index > 0);\n+                        let p = Location {\n+                            block: constraint.point.block,\n+                            statement_index: constraint.point.statement_index - 1,\n+                        };\n+\n+                        self.errors.push(InferenceError {\n+                            constraint_point: p,\n+                            name: sup_def.name,\n+                        });\n+                    }\n+                }\n+\n+                debug!(\"    sup (after) : {:?}\", sup_def.value);\n+                debug!(\"    changed     : {:?}\", changed);\n+            }\n+            debug!(\"\\n\");\n+        }\n+\n+        mem::replace(&mut self.errors, IndexVec::new())\n+    }\n+}\n+\n+struct Dfs<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> {\n+    #[allow(dead_code)]\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a> Dfs<'a, 'gcx, 'tcx> {\n+    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+        Self { infcx, mir }\n+    }\n+\n+    fn copy(\n+        &mut self,\n+        from_region: &Region,\n+        to_region: &mut Region,\n+        start_point: Location,\n+    ) -> bool {\n+        let mut changed = false;\n+\n+        let mut stack = vec![];\n+        let mut visited = FxHashSet();\n+\n+        stack.push(start_point);\n+        while let Some(p) = stack.pop() {\n+            debug!(\"        dfs: p={:?}\", p);\n+\n+            if !from_region.may_contain(p) {\n+                debug!(\"            not in from-region\");\n+                continue;\n+            }\n+\n+            if !visited.insert(p) {\n+                debug!(\"            already visited\");\n+                continue;\n+            }\n+\n+            changed |= to_region.add_point(p);\n+\n+            let block_data = &self.mir[p.block];\n+            let successor_points = if p.statement_index < block_data.statements.len() {\n+                vec![Location {\n+                    statement_index: p.statement_index + 1,\n+                    ..p\n+                }]\n+            } else {\n+                block_data.terminator()\n+                    .successors()\n+                    .iter()\n+                    .map(|&basic_block| Location {\n+                        statement_index: 0,\n+                        block: basic_block,\n+                    })\n+                    .collect::<Vec<_>>()\n+            };\n+\n+            if successor_points.is_empty() {\n+                // FIXME handle free regions\n+                // If we reach the END point in the graph, then copy\n+                // over any skolemized end points in the `from_region`\n+                // and make sure they are included in the `to_region`.\n+                // for region_decl in self.infcx.tcx.tables.borrow().free_region_map() {\n+                //     // FIXME(nashenas88) figure out skolemized_end points\n+                //     let block = self.env.graph.skolemized_end(region_decl.name);\n+                //     let skolemized_end_point = Location {\n+                //         block,\n+                //         statement_index: 0,\n+                //     };\n+                //     changed |= to_region.add_point(skolemized_end_point);\n+                // }\n+            } else {\n+                stack.extend(successor_points);\n+            }\n+        }\n+\n+        changed\n+    }\n+}"}, {"sha": "805e9c976e4f0ed6774b1ebfb1e14620b7977bab", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -8,42 +8,50 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use self::infer::InferenceContext;\n use rustc::ty::TypeFoldable;\n use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::{Ty, TyCtxt, ClosureSubsts, RegionVid, RegionKind};\n use rustc::mir::{Mir, Location, Rvalue, BasicBlock, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, Lookup};\n use rustc::mir::transform::{MirPass, MirSource};\n-use rustc::infer::{self, InferCtxt};\n+use rustc::infer::{self as rustc_infer, InferCtxt};\n use rustc::util::nodemap::FxHashSet;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use syntax_pos::DUMMY_SP;\n use std::collections::HashMap;\n+use std::fmt;\n+\n+use util as mir_util;\n+use self::mir_util::PassWhere;\n+\n+mod infer;\n \n #[allow(dead_code)]\n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     lookup_map: HashMap<RegionVid, Lookup>,\n     regions: IndexVec<RegionIndex, Region>,\n-    infcx: InferCtxt<'a, 'gcx, 'tcx>,\n+    #[allow(dead_code)]\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n         NLLVisitor {\n             infcx,\n             lookup_map: HashMap::new(),\n             regions: IndexVec::new(),\n         }\n     }\n \n-    pub fn into_results(self) -> HashMap<RegionVid, Lookup> {\n-        self.lookup_map\n+    pub fn into_results(self) -> (HashMap<RegionVid, Lookup>, IndexVec<RegionIndex, Region>) {\n+        (self.lookup_map, self.regions)\n     }\n \n     fn renumber_regions<T>(&mut self, value: &T) -> T where T: TypeFoldable<'tcx> {\n         self.infcx.tcx.fold_regions(value, &mut false, |_region, _depth| {\n             self.regions.push(Region::default());\n-            self.infcx.next_region_var(infer::MiscVariable(DUMMY_SP))\n+            self.infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n         })\n     }\n \n@@ -134,7 +142,7 @@ pub struct NLL;\n impl MirPass for NLL {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _: MirSource,\n+                          source: MirSource,\n                           mir: &mut Mir<'tcx>) {\n         if !tcx.sess.opts.debugging_opts.nll {\n             return;\n@@ -143,16 +151,42 @@ impl MirPass for NLL {\n         tcx.infer_ctxt().enter(|infcx| {\n             // Clone mir so we can mutate it without disturbing the rest of the compiler\n             let mut renumbered_mir = mir.clone();\n-            let mut visitor = NLLVisitor::new(infcx);\n+            let mut visitor = NLLVisitor::new(&infcx);\n             visitor.visit_mir(&mut renumbered_mir);\n-            let _results = visitor.into_results();\n+            mir_util::dump_mir(tcx, None, \"nll\", &0, source, mir, |pass_where, out| {\n+                if let PassWhere::BeforeCFG = pass_where {\n+                    for (index, value) in visitor.regions.iter_enumerated() {\n+                        writeln!(out, \"// R{:03}: {:?}\", index.0, value)?;\n+                    }\n+                }\n+                Ok(())\n+            });\n+            let (_lookup_map, regions) = visitor.into_results();\n+            let mut inference_context = InferenceContext::new(regions);\n+            inference_context.solve(&infcx, &renumbered_mir);\n         })\n     }\n }\n \n-#[derive(Clone, Debug, Default, PartialEq, Eq)]\n-struct Region {\n+#[derive(Clone, Default, PartialEq, Eq)]\n+pub struct Region {\n     points: FxHashSet<Location>,\n }\n \n+impl fmt::Debug for Region {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(formatter, \"{:?}\", self.points)\n+    }\n+}\n+\n+impl Region {\n+    pub fn add_point(&mut self, point: Location) -> bool {\n+        self.points.insert(point)\n+    }\n+\n+    pub fn may_contain(&self, point: Location) -> bool {\n+        self.points.contains(&point)\n+    }\n+}\n+\n newtype_index!(RegionIndex);"}, {"sha": "8d6458d793474e2d414875f30cccffba54d18c44", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -45,7 +45,7 @@ impl MirPass for SanityCheck {\n \n         let attributes = tcx.get_attrs(def_id);\n         let param_env = tcx.param_env(def_id);\n-        let move_data = MoveData::gather_moves(mir, tcx, param_env);\n+        let move_data = MoveData::gather_moves(mir, tcx, param_env).unwrap();\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n         let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n         let flow_inits ="}, {"sha": "216f6e4457096d28d6c51590c46840d579a57f36", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -248,6 +248,185 @@ pub trait BorrowckErrors {\n     {\n         self.cannot_assign(span, &format!(\"immutable static item `{}`\", desc), o)\n     }\n+\n+    fn cannot_move_out_of(&self, move_from_span: Span, move_from_desc: &str, o: Origin)\n+                          -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self, move_from_span, E0507,\n+                                       \"cannot move out of {}{OGN}\",\n+                                       move_from_desc, OGN=o);\n+        err.span_label(\n+            move_from_span,\n+            format!(\"cannot move out of {}\", move_from_desc));\n+        err\n+    }\n+\n+    fn cannot_move_out_of_interior_noncopy(&self,\n+                                           move_from_span: Span,\n+                                           ty: ty::Ty,\n+                                           is_index: bool,\n+                                           o: Origin)\n+                                           -> DiagnosticBuilder\n+    {\n+        let type_name = match (&ty.sty, is_index) {\n+            (&ty::TyArray(_, _), true) => \"array\",\n+            (&ty::TySlice(_),    _) => \"slice\",\n+            _ => span_bug!(move_from_span, \"this path should not cause illegal move\"),\n+        };\n+        let mut err = struct_span_err!(self, move_from_span, E0508,\n+                                       \"cannot move out of type `{}`, \\\n+                                        a non-copy {}{OGN}\",\n+                                       ty, type_name, OGN=o);\n+        err.span_label(move_from_span, \"cannot move out of here\");\n+        err\n+    }\n+\n+    fn cannot_move_out_of_interior_of_drop(&self,\n+                                           move_from_span: Span,\n+                                           container_ty: ty::Ty,\n+                                           o: Origin)\n+                                           -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self, move_from_span, E0509,\n+                                       \"cannot move out of type `{}`, \\\n+                                        which implements the `Drop` trait{OGN}\",\n+                                       container_ty, OGN=o);\n+        err.span_label(move_from_span, \"cannot move out of here\");\n+        err\n+    }\n+\n+    fn cannot_act_on_moved_value(&self,\n+                                 use_span: Span,\n+                                 verb: &str,\n+                                 optional_adverb_for_moved: &str,\n+                                 moved_path: &str,\n+                                 o: Origin)\n+                                 -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, use_span, E0382,\n+                                   \"{} of {}moved value: `{}`{OGN}\",\n+                                   verb, optional_adverb_for_moved, moved_path, OGN=o);\n+        err\n+    }\n+\n+    fn cannot_partially_reinit_an_uninit_struct(&self,\n+                                                span: Span,\n+                                                uninit_path: &str,\n+                                                o: Origin)\n+                                                -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self,\n+                                   span,\n+                                   E0383,\n+                                   \"partial reinitialization of uninitialized structure `{}`{OGN}\",\n+                                   uninit_path, OGN=o);\n+        err\n+    }\n+\n+    fn closure_cannot_assign_to_borrowed(&self,\n+                                         span: Span,\n+                                         descr: &str,\n+                                         o: Origin)\n+                                         -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0595, \"closure cannot assign to {}{OGN}\",\n+                                   descr, OGN=o);\n+        err\n+    }\n+\n+    fn cannot_borrow_path_as_mutable(&self,\n+                                     span: Span,\n+                                     path: &str,\n+                                     o: Origin)\n+                                     -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable{OGN}\",\n+                                   path, OGN=o);\n+        err\n+    }\n+\n+    fn cannot_borrow_across_generator_yield(&self,\n+                                            span: Span,\n+                                            yield_span: Span,\n+                                            o: Origin)\n+                                            -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self,\n+                                       span,\n+                                       E0626,\n+                                       \"borrow may still be in use when generator yields{OGN}\",\n+                                       OGN=o);\n+        err.span_label(yield_span, \"possible yield occurs here\");\n+        err\n+    }\n+\n+    fn path_does_not_live_long_enough(&self,\n+                                      span: Span,\n+                                      path: &str,\n+                                      o: Origin)\n+                                      -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0597, \"{} does not live long enough{OGN}\",\n+                                   path, OGN=o);\n+        err\n+    }\n+\n+    fn lifetime_too_short_for_reborrow(&self,\n+                                       span: Span,\n+                                       path: &str,\n+                                       o: Origin)\n+                                       -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0598,\n+                                   \"lifetime of {} is too short to guarantee \\\n+                                    its contents can be safely reborrowed{OGN}\",\n+                                   path, OGN=o);\n+        err\n+    }\n+\n+    fn cannot_act_on_capture_in_sharable_fn(&self,\n+                                            span: Span,\n+                                            bad_thing: &str,\n+                                            help: (Span, &str),\n+                                            o: Origin)\n+                                            -> DiagnosticBuilder\n+    {\n+        let (help_span, help_msg) = help;\n+        let mut err = struct_span_err!(self, span, E0387,\n+                                       \"{} in a captured outer variable in an `Fn` closure{OGN}\",\n+                                       bad_thing, OGN=o);\n+        err.span_help(help_span, help_msg);\n+        err\n+    }\n+\n+    fn cannot_assign_into_immutable_reference(&self,\n+                                              span: Span,\n+                                              bad_thing: &str,\n+                                              o: Origin)\n+                                              -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self, span, E0389, \"{} in a `&` reference{OGN}\",\n+                                       bad_thing, OGN=o);\n+        err.span_label(span, \"assignment into an immutable reference\");\n+        err\n+    }\n+\n+    fn cannot_capture_in_long_lived_closure(&self,\n+                                            closure_span: Span,\n+                                            borrowed_path: &str,\n+                                            capture_span: Span,\n+                                            o: Origin)\n+                                            -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self, closure_span, E0373,\n+                                       \"closure may outlive the current function, \\\n+                                        but it borrows {}, \\\n+                                        which is owned by the current function{OGN}\",\n+                                       borrowed_path, OGN=o);\n+        err.span_label(capture_span, format!(\"{} is borrowed here\", borrowed_path))\n+            .span_label(closure_span, format!(\"may outlive borrowed value {}\", borrowed_path));\n+        err\n+    }\n }\n \n impl<'b, 'tcx, 'gcx> BorrowckErrors for TyCtxt<'b, 'tcx, 'gcx> {"}, {"sha": "1424c063d73854c43b35102e81af7d14db80d478", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -232,7 +232,7 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             writeln!(w, \"{} {{{}}}\", prefix, live.join(\", \"))\n         };\n         print(w, \"   \", &result.ins)?;\n-        write_basic_block(tcx, block, mir, w)?;\n+        write_basic_block(tcx, block, mir, &mut |_, _| Ok(()), w)?;\n         print(w, \"   \", &result.outs)?;\n         if block.index() + 1 != mir.basic_blocks().len() {\n             writeln!(w, \"\")?;"}, {"sha": "13c14f8920f4ec600fd2a4e4c6768ba5c36438fa", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -17,6 +17,6 @@ mod graphviz;\n mod pretty;\n pub mod liveness;\n \n-pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty};\n+pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty, PassWhere};\n pub use self::graphviz::{write_mir_graphviz};\n pub use self::graphviz::write_node_label as write_graphviz_node_label;"}, {"sha": "8a9047fb4911c66a598dbec20daa0ffd3727f417", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 65, "deletions": 33, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -25,6 +25,22 @@ const INDENT: &'static str = \"    \";\n /// Alignment for lining up comments following MIR statements\n const ALIGN: usize = 40;\n \n+/// An indication of where we are in the control flow graph. Used for printing\n+/// extra information in `dump_mir`\n+pub enum PassWhere {\n+    /// We have not started dumping the control flow graph, but we are about to.\n+    BeforeCFG,\n+\n+    /// We just finished dumping the control flow graph. This is right before EOF\n+    AfterCFG,\n+\n+    /// We are about to start dumping the given basic block.\n+    BeforeBlock(BasicBlock),\n+\n+    /// We are just about to dumpt the given statement or terminator.\n+    InCFG(Location),\n+}\n+\n /// If the session is properly configured, dumps a human-readable\n /// representation of the mir into:\n ///\n@@ -39,12 +55,16 @@ const ALIGN: usize = 40;\n /// - `substring1&substring2,...` -- `&`-separated list of substrings\n ///   that can appear in the pass-name or the `item_path_str` for the given\n ///   node-id. If any one of the substrings match, the data is dumped out.\n-pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          pass_num: Option<(MirSuite, MirPassIndex)>,\n-                          pass_name: &str,\n-                          disambiguator: &Display,\n-                          source: MirSource,\n-                          mir: &Mir<'tcx>) {\n+pub fn dump_mir<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             pass_num: Option<(MirSuite, MirPassIndex)>,\n+                             pass_name: &str,\n+                             disambiguator: &Display,\n+                             source: MirSource,\n+                             mir: &Mir<'tcx>,\n+                             extra_data: F)\n+where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+{\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n     }\n@@ -53,12 +73,7 @@ pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.item_path_str(tcx.hir.local_def_id(source.item_id()))\n     });\n     dump_matched_mir_node(tcx, pass_num, pass_name, &node_path,\n-                          disambiguator, source, mir);\n-    for (index, promoted_mir) in mir.promoted.iter_enumerated() {\n-        let promoted_source = MirSource::Promoted(source.item_id(), index);\n-        dump_matched_mir_node(tcx, pass_num, pass_name, &node_path, disambiguator,\n-                              promoted_source, promoted_mir);\n-    }\n+                          disambiguator, source, mir, extra_data);\n }\n \n pub fn dump_enabled<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -85,13 +100,17 @@ pub fn dump_enabled<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // `item_path_str()` would otherwise trigger `type_of`, and this can\n // run while we are already attempting to evaluate `type_of`.\n \n-fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   pass_num: Option<(MirSuite, MirPassIndex)>,\n-                                   pass_name: &str,\n-                                   node_path: &str,\n-                                   disambiguator: &Display,\n-                                   source: MirSource,\n-                                   mir: &Mir<'tcx>) {\n+fn dump_matched_mir_node<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      pass_num: Option<(MirSuite, MirPassIndex)>,\n+                                      pass_name: &str,\n+                                      node_path: &str,\n+                                      disambiguator: &Display,\n+                                      source: MirSource,\n+                                      mir: &Mir<'tcx>,\n+                                      mut extra_data: F)\n+where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+{\n     let promotion_id = match source {\n         MirSource::Promoted(_, id) => format!(\"-{:?}\", id),\n         MirSource::GeneratorDrop(_) => format!(\"-drop\"),\n@@ -125,7 +144,9 @@ fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             writeln!(file, \"// generator_layout = {:?}\", layout)?;\n         }\n         writeln!(file, \"\")?;\n-        write_mir_fn(tcx, source, mir, &mut file)?;\n+        extra_data(PassWhere::BeforeCFG, &mut file)?;\n+        write_mir_fn(tcx, source, mir, &mut extra_data, &mut file)?;\n+        extra_data(PassWhere::AfterCFG, &mut file)?;\n         Ok(())\n     });\n }\n@@ -152,24 +173,29 @@ pub fn write_mir_pretty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n         let src = MirSource::from_node(tcx, id);\n-        write_mir_fn(tcx, src, mir, w)?;\n+        write_mir_fn(tcx, src, mir, &mut |_, _| Ok(()), w)?;\n \n         for (i, mir) in mir.promoted.iter_enumerated() {\n             writeln!(w, \"\")?;\n-            write_mir_fn(tcx, MirSource::Promoted(id, i), mir, w)?;\n+            write_mir_fn(tcx, MirSource::Promoted(id, i), mir, &mut |_, _| Ok(()), w)?;\n         }\n     }\n     Ok(())\n }\n \n-pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              src: MirSource,\n-                              mir: &Mir<'tcx>,\n-                              w: &mut Write)\n-                              -> io::Result<()> {\n+pub fn write_mir_fn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 src: MirSource,\n+                                 mir: &Mir<'tcx>,\n+                                 extra_data: &mut F,\n+                                 w: &mut Write)\n+                                 -> io::Result<()>\n+where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+{\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n-        write_basic_block(tcx, block, mir, w)?;\n+        extra_data(PassWhere::BeforeBlock(block), w)?;\n+        write_basic_block(tcx, block, mir, extra_data, w)?;\n         if block.index() + 1 != mir.basic_blocks().len() {\n             writeln!(w, \"\")?;\n         }\n@@ -180,11 +206,15 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-pub fn write_basic_block(tcx: TyCtxt,\n-                     block: BasicBlock,\n-                     mir: &Mir,\n-                     w: &mut Write)\n-                     -> io::Result<()> {\n+pub fn write_basic_block<F>(tcx: TyCtxt,\n+                            block: BasicBlock,\n+                            mir: &Mir,\n+                            extra_data: &mut F,\n+                            w: &mut Write)\n+                            -> io::Result<()>\n+where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+{\n     let data = &mir[block];\n \n     // Basic block label at the top.\n@@ -195,6 +225,7 @@ pub fn write_basic_block(tcx: TyCtxt,\n     // List of statements in the middle.\n     let mut current_location = Location { block: block, statement_index: 0 };\n     for statement in &data.statements {\n+        extra_data(PassWhere::InCFG(current_location), w)?;\n         let indented_mir = format!(\"{0}{0}{1:?};\", INDENT, statement);\n         writeln!(w, \"{0:1$} // {2}\",\n                  indented_mir,\n@@ -205,6 +236,7 @@ pub fn write_basic_block(tcx: TyCtxt,\n     }\n \n     // Terminator at the bottom.\n+    extra_data(PassWhere::InCFG(current_location), w)?;\n     let indented_terminator = format!(\"{0}{0}{1:?};\", INDENT, data.terminator().kind);\n     writeln!(w, \"{0:1$} // {2}\",\n              indented_terminator,"}, {"sha": "14e33378969aaa8cd25d1f091917fe7e1740acb2", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -152,7 +152,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     err.emit();\n                 });\n             }\n-            TyKind::TraitObject(ref bounds) => {\n+            TyKind::TraitObject(ref bounds, ..) => {\n                 let mut any_lifetime_bounds = false;\n                 for bound in bounds {\n                     if let RegionTyParamBound(ref lifetime) = *bound {"}, {"sha": "d3202ba4ab53548bad0e0353c30e1eb62ef8e80d", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 76, "deletions": 36, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -39,20 +39,79 @@ use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::mir::transform::MirSource;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::maps::{queries, Providers};\n use rustc::ty::subst::Substs;\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n-use rustc::util::nodemap::NodeSet;\n+use rustc::util::nodemap::{ItemLocalMap, NodeSet};\n use rustc::lint::builtin::CONST_ERR;\n-\n use rustc::hir::{self, PatKind, RangeEnd};\n+use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n-use std::collections::hash_map::Entry;\n use std::cmp::Ordering;\n \n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        rvalue_promotable_map,\n+        const_is_rvalue_promotable_to_static,\n+        ..*providers\n+    };\n+}\n+\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    for &body_id in &tcx.hir.krate().body_ids {\n+        let def_id = tcx.hir.body_owner_def_id(body_id);\n+        tcx.const_is_rvalue_promotable_to_static(def_id);\n+    }\n+    tcx.sess.abort_if_errors();\n+}\n+\n+fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                  def_id: DefId)\n+                                                  -> bool\n+{\n+    assert!(def_id.is_local());\n+\n+    let node_id = tcx.hir.as_local_node_id(def_id)\n+                     .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n+    let body_id = tcx.hir.body_owned_by(node_id);\n+    let body_hir_id = tcx.hir.node_to_hir_id(body_id.node_id);\n+    tcx.rvalue_promotable_map(def_id).contains_key(&body_hir_id.local_id)\n+}\n+\n+fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   def_id: DefId)\n+                                   -> Rc<ItemLocalMap<bool>>\n+{\n+    let outer_def_id = tcx.closure_base_def_id(def_id);\n+    if outer_def_id != def_id {\n+        return tcx.rvalue_promotable_map(outer_def_id);\n+    }\n+\n+    let mut visitor = CheckCrateVisitor {\n+        tcx,\n+        tables: &ty::TypeckTables::empty(None),\n+        in_fn: false,\n+        in_static: false,\n+        promotable: false,\n+        mut_rvalue_borrows: NodeSet(),\n+        param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n+        identity_substs: Substs::empty(),\n+        result_map: ItemLocalMap(),\n+    };\n+\n+    // `def_id` should be a `Body` owner\n+    let node_id = tcx.hir.as_local_node_id(def_id)\n+                     .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n+    let body_id = tcx.hir.body_owned_by(node_id);\n+    visitor.visit_nested_body(body_id);\n+\n+    Rc::new(visitor.result_map)\n+}\n+\n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     in_fn: bool,\n@@ -62,6 +121,7 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     param_env: ty::ParamEnv<'tcx>,\n     identity_substs: &'tcx Substs<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n+    result_map: ItemLocalMap<bool>,\n }\n \n impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n@@ -109,18 +169,11 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        // note that we *do* visit nested bodies, because we override `visit_nested_body` below\n         NestedVisitorMap::None\n     }\n \n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n-        match self.tcx.rvalue_promotable_to_static.borrow_mut().entry(body_id.node_id) {\n-            Entry::Occupied(_) => return,\n-            Entry::Vacant(entry) => {\n-                // Prevent infinite recursion on re-entry.\n-                entry.insert(false);\n-            }\n-        }\n-\n         let item_id = self.tcx.hir.body_owner(body_id);\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n \n@@ -151,7 +204,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         let tcx = self.tcx;\n         let param_env = self.param_env;\n         let region_scope_tree = self.tcx.region_scope_tree(item_def_id);\n-        euv::ExprUseVisitor::new(self, tcx, param_env, &region_scope_tree, self.tables)\n+        euv::ExprUseVisitor::new(self, tcx, param_env, &region_scope_tree, self.tables, None)\n             .consume_body(body);\n \n         self.visit_body(body);\n@@ -270,7 +323,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n             }\n         }\n \n-        self.tcx.rvalue_promotable_to_static.borrow_mut().insert(ex.id, self.promotable);\n+        self.result_map.insert(ex.hir_id.local_id, self.promotable);\n         self.promotable &= outer;\n     }\n }\n@@ -371,16 +424,17 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                     let promotable = if v.tcx.trait_of_item(did).is_some() {\n                         // Don't peek inside trait associated constants.\n                         false\n-                    } else if let Some(node_id) = v.tcx.hir.as_local_node_id(did) {\n-                        match v.tcx.hir.maybe_body_owned_by(node_id) {\n-                            Some(body) => {\n-                                v.visit_nested_body(body);\n-                                v.tcx.rvalue_promotable_to_static.borrow()[&body.node_id]\n-                            }\n-                            None => false\n-                        }\n                     } else {\n-                        v.tcx.const_is_rvalue_promotable_to_static(did)\n+                        queries::const_is_rvalue_promotable_to_static::try_get(v.tcx, e.span, did)\n+                            .unwrap_or_else(|mut err| {\n+                                // A cycle between constants ought to be reported elsewhere.\n+                                err.cancel();\n+                                v.tcx.sess.delay_span_bug(\n+                                    e.span,\n+                                    &format!(\"cycle encountered during const qualification: {:?}\",\n+                                             did));\n+                                false\n+                            })\n                     };\n \n                     // Just in case the type is more specific than the definition,\n@@ -513,20 +567,6 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n     }\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.hir.krate().visit_all_item_likes(&mut CheckCrateVisitor {\n-        tcx,\n-        tables: &ty::TypeckTables::empty(None),\n-        in_fn: false,\n-        in_static: false,\n-        promotable: false,\n-        mut_rvalue_borrows: NodeSet(),\n-        param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n-        identity_substs: Substs::empty(),\n-    }.as_deep_visitor());\n-    tcx.sess.abort_if_errors();\n-}\n-\n impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,"}, {"sha": "9a150abea6691dd912aef649541dec6584df16f4", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -33,6 +33,8 @@ extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n \n+use rustc::ty::maps::Providers;\n+\n mod diagnostics;\n \n pub mod ast_validation;\n@@ -44,3 +46,7 @@ pub mod no_asm;\n pub mod static_recursion;\n \n __build_diagnostic_array! { librustc_passes, DIAGNOSTICS }\n+\n+pub fn provide(providers: &mut Providers) {\n+    consts::provide(providers);\n+}"}, {"sha": "564626ac39885328089f8be721805ed6e8045981", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -43,7 +43,7 @@ parameter if so.\n \"##,\n \n E0154: r##\"\n-## Note: this error code is no longer emitted by the compiler.\n+#### Note: this error code is no longer emitted by the compiler.\n \n Imports (`use` statements) are not allowed after non-item statements, such as\n variable declarations and expression statements.\n@@ -79,7 +79,7 @@ https://doc.rust-lang.org/reference.html#statements\n \"##,\n \n E0251: r##\"\n-## Note: this error code is no longer emitted by the compiler.\n+#### Note: this error code is no longer emitted by the compiler.\n \n Two items of the same name cannot be imported without rebinding one of the\n items under a new local name.\n@@ -268,7 +268,7 @@ fn main() {\n \"##,\n \n E0256: r##\"\n-## Note: this error code is no longer emitted by the compiler.\n+#### Note: this error code is no longer emitted by the compiler.\n \n You can't import a type or module when the name of the item being imported is\n the same as another type or submodule defined in the module."}, {"sha": "0799c4f719012680ab9b240d7bd432116a8980fb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -137,7 +137,7 @@ enum ResolutionError<'a> {\n     /// error E0416: identifier is bound more than once in the same pattern\n     IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n     /// error E0426: use of undeclared label\n-    UndeclaredLabel(&'a str),\n+    UndeclaredLabel(&'a str, Option<Name>),\n     /// error E0429: `self` imports are only allowed within a { } list\n     SelfImportsOnlyAllowedWithin,\n     /// error E0430: `self` import can only appear once in the list\n@@ -263,13 +263,17 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             err.span_label(span, \"used in a pattern more than once\");\n             err\n         }\n-        ResolutionError::UndeclaredLabel(name) => {\n+        ResolutionError::UndeclaredLabel(name, lev_candidate) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0426,\n                                            \"use of undeclared label `{}`\",\n                                            name);\n-            err.span_label(span, format!(\"undeclared label `{}`\", name));\n+            if let Some(lev_candidate) = lev_candidate {\n+                err.span_label(span, format!(\"did you mean `{}`?\", lev_candidate));\n+            } else {\n+                err.span_label(span, format!(\"undeclared label `{}`\", name));\n+            }\n             err\n         }\n         ResolutionError::SelfImportsOnlyAllowedWithin => {\n@@ -714,12 +718,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 _: Span,\n                 node_id: NodeId) {\n         let rib_kind = match function_kind {\n-            FnKind::ItemFn(_, generics, ..) => {\n-                self.visit_generics(generics);\n+            FnKind::ItemFn(..) => {\n                 ItemRibKind\n             }\n             FnKind::Method(_, sig, _, _) => {\n-                self.visit_generics(&sig.generics);\n                 MethodRibKind(!sig.decl.has_self())\n             }\n             FnKind::Closure(_) => ClosureRibKind(node_id),\n@@ -1790,9 +1792,13 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    /// Searches the current set of local scopes for labels.\n+    /// Searches the current set of local scopes for labels. Returns the first non-None label that\n+    /// is returned by the given predicate function\n+    ///\n     /// Stops after meeting a closure.\n-    fn search_label(&self, mut ident: Ident) -> Option<Def> {\n+    fn search_label<P, R>(&self, mut ident: Ident, pred: P) -> Option<R>\n+        where P: Fn(&Rib, Ident) -> Option<R>\n+    {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n                 NormalRibKind => {}\n@@ -1808,9 +1814,9 @@ impl<'a> Resolver<'a> {\n                     return None;\n                 }\n             }\n-            let result = rib.bindings.get(&ident).cloned();\n-            if result.is_some() {\n-                return result;\n+            let r = pred(rib, ident);\n+            if r.is_some() {\n+                return r;\n             }\n         }\n         None\n@@ -1872,7 +1878,7 @@ impl<'a> Resolver<'a> {\n                                 }\n                                 TraitItemKind::Method(ref sig, _) => {\n                                     let type_parameters =\n-                                        HasTypeParameters(&sig.generics,\n+                                        HasTypeParameters(&trait_item.generics,\n                                                           MethodRibKind(!sig.decl.has_self()));\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n                                         visit::walk_trait_item(this, trait_item)\n@@ -2076,7 +2082,9 @@ impl<'a> Resolver<'a> {\n                                                             ValueNS,\n                                                             impl_item.span,\n                                             |n, s| ResolutionError::ConstNotMemberOfTrait(n, s));\n-                                        visit::walk_impl_item(this, impl_item);\n+                                        this.with_constant_rib(|this|\n+                                            visit::walk_impl_item(this, impl_item)\n+                                        );\n                                     }\n                                     ImplItemKind::Method(ref sig, _) => {\n                                         // If this is a trait impl, ensure the method\n@@ -2089,7 +2097,7 @@ impl<'a> Resolver<'a> {\n                                         // We also need a new scope for the method-\n                                         // specific type parameters.\n                                         let type_parameters =\n-                                            HasTypeParameters(&sig.generics,\n+                                            HasTypeParameters(&impl_item.generics,\n                                                             MethodRibKind(!sig.decl.has_self()));\n                                         this.with_type_parameter_rib(type_parameters, |this| {\n                                             visit::walk_impl_item(this, impl_item);\n@@ -3202,12 +3210,20 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n-                match self.search_label(label.node) {\n+                match self.search_label(label.node, |rib, id| rib.bindings.get(&id).cloned()) {\n                     None => {\n+                        // Search again for close matches...\n+                        // Picks the first label that is \"close enough\", which is not necessarily\n+                        // the closest match\n+                        let close_match = self.search_label(label.node, |rib, ident| {\n+                            let names = rib.bindings.iter().map(|(id, _)| &id.name);\n+                            find_best_match_for_name(names, &*ident.name.as_str(), None)\n+                        });\n                         self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,\n                                       label.span,\n-                                      ResolutionError::UndeclaredLabel(&label.node.name.as_str()));\n+                                      ResolutionError::UndeclaredLabel(&label.node.name.as_str(),\n+                                                                       close_match));\n                     }\n                     Some(def @ Def::Label(_)) => {\n                         // Since this def is a label, it is never read."}, {"sha": "ca44a088e237917eaa4b3118da30dbbd67994403", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -354,23 +354,24 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                       body: Option<&'l ast::Block>,\n                       id: ast::NodeId,\n                       name: ast::Ident,\n+                      generics: &'l ast::Generics,\n                       vis: ast::Visibility,\n                       span: Span) {\n         debug!(\"process_method: {}:{}\", id, name);\n \n         if let Some(mut method_data) = self.save_ctxt.get_method_data(id, name.name, span) {\n \n-            let sig_str = ::make_signature(&sig.decl, &sig.generics);\n+            let sig_str = ::make_signature(&sig.decl, &generics);\n             if body.is_some() {\n                 self.nest_tables(id, |v| {\n                     v.process_formals(&sig.decl.inputs, &method_data.qualname)\n                 });\n             }\n \n-            self.process_generic_params(&sig.generics, span, &method_data.qualname, id);\n+            self.process_generic_params(&generics, span, &method_data.qualname, id);\n \n             method_data.value = sig_str;\n-            method_data.sig = sig::method_signature(id, name, sig, &self.save_ctxt);\n+            method_data.sig = sig::method_signature(id, name, generics, sig, &self.save_ctxt);\n             self.dumper.dump_def(vis == ast::Visibility::Public, method_data);\n         }\n \n@@ -1007,6 +1008,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                                     body.as_ref().map(|x| &**x),\n                                     trait_item.id,\n                                     trait_item.ident,\n+                                    &trait_item.generics,\n                                     ast::Visibility::Public,\n                                     trait_item.span);\n             }\n@@ -1066,6 +1068,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                                     Some(body),\n                                     impl_item.id,\n                                     impl_item.ident,\n+                                    &impl_item.generics,\n                                     impl_item.vis.clone(),\n                                     impl_item.span);\n             }"}, {"sha": "88f574d513bd8f7395607b3e87abc3698884948a", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -77,13 +77,14 @@ pub fn variant_signature(variant: &ast::Variant, scx: &SaveContext) -> Option<Si\n \n pub fn method_signature(id: NodeId,\n                         ident: ast::Ident,\n+                        generics: &ast::Generics,\n                         m: &ast::MethodSig,\n                         scx: &SaveContext)\n                         -> Option<Signature> {\n     if !scx.config.signatures {\n         return None;\n     }\n-    make_method_signature(id, ident, m, scx).ok()\n+    make_method_signature(id, ident, generics, m, scx).ok()\n }\n \n pub fn assoc_const_signature(id: NodeId,\n@@ -288,7 +289,7 @@ impl Sig for ast::Ty {\n                     })\n                 }\n             }\n-            ast::TyKind::TraitObject(ref bounds) => {\n+            ast::TyKind::TraitObject(ref bounds, ..) => {\n                 // FIXME recurse into bounds\n                 let nested = pprust::bounds_to_string(bounds);\n                 Ok(text_sig(nested))\n@@ -895,6 +896,7 @@ fn make_assoc_const_signature(id: NodeId,\n \n fn make_method_signature(id: NodeId,\n                          ident: ast::Ident,\n+                         generics: &ast::Generics,\n                          m: &ast::MethodSig,\n                          scx: &SaveContext)\n                          -> Result {\n@@ -915,7 +917,7 @@ fn make_method_signature(id: NodeId,\n \n     let mut sig = name_and_generics(text,\n                                     0,\n-                                    &m.generics,\n+                                    generics,\n                                     id,\n                                     ident,\n                                     scx)?;"}, {"sha": "5b7879ea58ee7e88de2b444d2f112c8c34811f27", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -32,4 +32,4 @@ syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n \n [target.\"cfg(windows)\".dependencies]\n-cc = \"1.0\"\n+cc = \"1.0.1\""}, {"sha": "6df40c34ec54ae7b820434e42a76ebf662c80d00", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -37,6 +37,7 @@ use type_of;\n use rustc::hir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Layout, LayoutTyper, TyLayout, Size};\n+use rustc_back::PanicStrategy;\n \n use libc::c_uint;\n use std::cmp;\n@@ -112,6 +113,10 @@ impl ArgAttributes {\n         self\n     }\n \n+    pub fn contains(&self, attr: ArgAttribute) -> bool {\n+        self.regular.contains(attr)\n+    }\n+\n     pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n         unsafe {\n             self.regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));\n@@ -750,31 +755,32 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 Some(ty.boxed_ty())\n             }\n \n-            ty::TyRef(b, mt) => {\n-                use rustc::ty::{BrAnon, ReLateBound};\n-\n+            ty::TyRef(_, mt) => {\n                 // `&mut` pointer parameters never alias other parameters, or mutable global data\n                 //\n                 // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as\n                 // both `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely\n                 // on memory dependencies rather than pointer equality\n                 let is_freeze = ccx.shared().type_is_freeze(mt.ty);\n \n-                if mt.mutbl != hir::MutMutable && is_freeze {\n+                let no_alias_is_safe =\n+                    if ccx.shared().tcx().sess.opts.debugging_opts.mutable_noalias ||\n+                       ccx.shared().tcx().sess.panic_strategy() == PanicStrategy::Abort {\n+                        // Mutable refrences or immutable shared references\n+                        mt.mutbl == hir::MutMutable || is_freeze\n+                    } else {\n+                        // Only immutable shared references\n+                        mt.mutbl != hir::MutMutable && is_freeze\n+                    };\n+\n+                if no_alias_is_safe {\n                     arg.attrs.set(ArgAttribute::NoAlias);\n                 }\n \n                 if mt.mutbl == hir::MutImmutable && is_freeze {\n                     arg.attrs.set(ArgAttribute::ReadOnly);\n                 }\n \n-                // When a reference in an argument has no named lifetime, it's\n-                // impossible for that reference to escape this function\n-                // (returned or stored beyond the call by a closure).\n-                if let ReLateBound(_, BrAnon(_)) = *b {\n-                    arg.attrs.set(ArgAttribute::NoCapture);\n-                }\n-\n                 Some(mt.ty)\n             }\n             _ => None"}, {"sha": "b06f8e4e671162bc007e4a20392c3d9f43ddb601", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -80,7 +80,7 @@ pub fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n         ty::TyGenerator(def_id, substs, _) => {\n             if variant_index > 0 { bug!(\"{} is a generator, which only has one variant\", t);}\n             substs.field_tys(def_id, cx.tcx()).map(|t| {\n-                cx.tcx().normalize_associated_type(&t)\n+                cx.tcx().fully_normalize_associated_types_in(&t)\n             }).collect()\n         },\n         _ => bug!(\"{} is not a type that can have fields.\", t)"}, {"sha": "775cf3ac4c934b087b1786886170adc3530e7dd8", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -31,8 +31,7 @@ pub struct ArchiveConfig<'a> {\n     pub lib_search_paths: Vec<PathBuf>,\n }\n \n-/// Helper for adding many files to an archive with a single invocation of\n-/// `ar`.\n+/// Helper for adding many files to an archive.\n #[must_use = \"must call build() to finish building the archive\"]\n pub struct ArchiveBuilder<'a> {\n     config: ArchiveConfig<'a>,\n@@ -201,8 +200,8 @@ impl<'a> ArchiveBuilder<'a> {\n         });\n     }\n \n-    /// Indicate that the next call to `build` should updates all symbols in\n-    /// the archive (run 'ar s' over it).\n+    /// Indicate that the next call to `build` should update all symbols in\n+    /// the archive (equivalent to running 'ar s' over it).\n     pub fn update_symbols(&mut self) {\n         self.should_update_symbols = true;\n     }"}, {"sha": "b203bd640cf1467fb79441dcdb83e146b7b06c1f", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 62, "deletions": 93, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -9,13 +9,14 @@\n // except according to those terms.\n \n use super::archive::{ArchiveBuilder, ArchiveConfig};\n-use super::bytecode::{self, RLIB_BYTECODE_EXTENSION};\n+use super::bytecode::RLIB_BYTECODE_EXTENSION;\n use super::linker::Linker;\n use super::command::Command;\n use super::rpath::RPathConfig;\n use super::rpath;\n use metadata::METADATA_FILENAME;\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType, PrintRequest};\n+use rustc::session::config::RUST_CGU_EXT;\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n@@ -36,7 +37,7 @@ use std::env;\n use std::ffi::OsString;\n use std::fmt;\n use std::fs::{self, File};\n-use std::io::{self, Read, Write, BufWriter};\n+use std::io::{self, Write, BufWriter};\n use std::path::{Path, PathBuf};\n use std::process::{Output, Stdio};\n use std::str;\n@@ -45,13 +46,9 @@ use syntax::attr;\n /// The LLVM module name containing crate-metadata. This includes a `.` on\n /// purpose, so it cannot clash with the name of a user-defined module.\n pub const METADATA_MODULE_NAME: &'static str = \"crate.metadata\";\n-/// The name of the crate-metadata object file the compiler generates. Must\n-/// match up with `METADATA_MODULE_NAME`.\n-pub const METADATA_OBJ_NAME: &'static str = \"crate.metadata.o\";\n \n // same as for metadata above, but for allocator shim\n pub const ALLOCATOR_MODULE_NAME: &'static str = \"crate.allocator\";\n-pub const ALLOCATOR_OBJ_NAME: &'static str = \"crate.allocator.o\";\n \n pub use rustc_trans_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n                                   invalid_output_for_target, build_link_meta, out_filename,\n@@ -170,13 +167,23 @@ pub fn link_binary(sess: &Session,\n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.cg.save_temps {\n         if sess.opts.output_types.should_trans() {\n-            for obj in trans.modules.iter() {\n-                remove(sess, &obj.object);\n+            for obj in trans.modules.iter().filter_map(|m| m.object.as_ref()) {\n+                remove(sess, obj);\n             }\n         }\n-        remove(sess, &outputs.with_extension(METADATA_OBJ_NAME));\n-        if trans.allocator_module.is_some() {\n-            remove(sess, &outputs.with_extension(ALLOCATOR_OBJ_NAME));\n+        for obj in trans.modules.iter().filter_map(|m| m.bytecode_compressed.as_ref()) {\n+            remove(sess, obj);\n+        }\n+        if let Some(ref obj) = trans.metadata_module.object {\n+            remove(sess, obj);\n+        }\n+        if let Some(ref allocator) = trans.allocator_module {\n+            if let Some(ref obj) = allocator.object {\n+                remove(sess, obj);\n+            }\n+            if let Some(ref bc) = allocator.bytecode_compressed {\n+                remove(sess, bc);\n+            }\n         }\n     }\n \n@@ -251,8 +258,8 @@ fn link_binary_output(sess: &Session,\n                       crate_type: config::CrateType,\n                       outputs: &OutputFilenames,\n                       crate_name: &str) -> Vec<PathBuf> {\n-    for module in trans.modules.iter() {\n-        check_file_is_writeable(&module.object, sess);\n+    for obj in trans.modules.iter().filter_map(|m| m.object.as_ref()) {\n+        check_file_is_writeable(obj, sess);\n     }\n \n     let tmpdir = match TempDir::new(\"rustc\") {\n@@ -275,20 +282,14 @@ fn link_binary_output(sess: &Session,\n                 link_rlib(sess,\n                           trans,\n                           RlibFlavor::Normal,\n-                          outputs,\n                           &out_filename,\n                           tmpdir.path()).build();\n             }\n             config::CrateTypeStaticlib => {\n-                link_staticlib(sess,\n-                               trans,\n-                               outputs,\n-                               &out_filename,\n-                               tmpdir.path());\n+                link_staticlib(sess, trans, &out_filename, tmpdir.path());\n             }\n             _ => {\n-                link_natively(sess, crate_type, &out_filename,\n-                              trans, outputs, tmpdir.path());\n+                link_natively(sess, crate_type, &out_filename, trans, tmpdir.path());\n             }\n         }\n         out_filenames.push(out_filename);\n@@ -344,14 +345,13 @@ enum RlibFlavor {\n fn link_rlib<'a>(sess: &'a Session,\n                  trans: &CrateTranslation,\n                  flavor: RlibFlavor,\n-                 outputs: &OutputFilenames,\n                  out_filename: &Path,\n                  tmpdir: &Path) -> ArchiveBuilder<'a> {\n     info!(\"preparing rlib to {:?}\", out_filename);\n     let mut ab = ArchiveBuilder::new(archive_config(sess, out_filename, None));\n \n-    for module in trans.modules.iter() {\n-        ab.add_file(&module.object);\n+    for obj in trans.modules.iter().filter_map(|m| m.object.as_ref()) {\n+        ab.add_file(obj);\n     }\n \n     // Note that in this loop we are ignoring the value of `lib.cfg`. That is,\n@@ -416,56 +416,9 @@ fn link_rlib<'a>(sess: &'a Session,\n             ab.add_file(&metadata);\n \n             // For LTO purposes, the bytecode of this library is also inserted\n-            // into the archive.  If codegen_units > 1, we insert each of the\n-            // bitcode files.\n-            for module in trans.modules.iter() {\n-                // Note that we make sure that the bytecode filename in the\n-                // archive is never exactly 16 bytes long by adding a 16 byte\n-                // extension to it. This is to work around a bug in LLDB that\n-                // would cause it to crash if the name of a file in an archive\n-                // was exactly 16 bytes.\n-                let bc_filename = module.object.with_extension(\"bc\");\n-                let bc_encoded_filename = tmpdir.join({\n-                    module.object.with_extension(RLIB_BYTECODE_EXTENSION).file_name().unwrap()\n-                });\n-\n-                let mut bc_data = Vec::new();\n-                match fs::File::open(&bc_filename).and_then(|mut f| {\n-                    f.read_to_end(&mut bc_data)\n-                }) {\n-                    Ok(..) => {}\n-                    Err(e) => sess.fatal(&format!(\"failed to read bytecode: {}\",\n-                                                 e))\n-                }\n-\n-                let encoded = bytecode::encode(&module.llmod_id, &bc_data);\n-\n-                let mut bc_file_deflated = match fs::File::create(&bc_encoded_filename) {\n-                    Ok(file) => file,\n-                    Err(e) => {\n-                        sess.fatal(&format!(\"failed to create compressed \\\n-                                             bytecode file: {}\", e))\n-                    }\n-                };\n-\n-                match bc_file_deflated.write_all(&encoded) {\n-                    Ok(()) => {}\n-                    Err(e) => {\n-                        sess.fatal(&format!(\"failed to write compressed \\\n-                                             bytecode: {}\", e));\n-                    }\n-                };\n-\n-                ab.add_file(&bc_encoded_filename);\n-\n-                // See the bottom of back::write::run_passes for an explanation\n-                // of when we do and don't keep .#module-name#.bc files around.\n-                let user_wants_numbered_bitcode =\n-                        sess.opts.output_types.contains_key(&OutputType::Bitcode) &&\n-                        sess.opts.codegen_units > 1;\n-                if !sess.opts.cg.save_temps && !user_wants_numbered_bitcode {\n-                    remove(sess, &bc_filename);\n-                }\n+            // into the archive.\n+            for bytecode in trans.modules.iter().filter_map(|m| m.bytecode_compressed.as_ref()) {\n+                ab.add_file(bytecode);\n             }\n \n             // After adding all files to the archive, we need to update the\n@@ -477,8 +430,11 @@ fn link_rlib<'a>(sess: &'a Session,\n         }\n \n         RlibFlavor::StaticlibBase => {\n-            if trans.allocator_module.is_some() {\n-                ab.add_file(&outputs.with_extension(ALLOCATOR_OBJ_NAME));\n+            let obj = trans.allocator_module\n+                .as_ref()\n+                .and_then(|m| m.object.as_ref());\n+            if let Some(obj) = obj {\n+                ab.add_file(obj);\n             }\n         }\n     }\n@@ -500,13 +456,11 @@ fn link_rlib<'a>(sess: &'a Session,\n // metadata file).\n fn link_staticlib(sess: &Session,\n                   trans: &CrateTranslation,\n-                  outputs: &OutputFilenames,\n                   out_filename: &Path,\n                   tempdir: &Path) {\n     let mut ab = link_rlib(sess,\n                            trans,\n                            RlibFlavor::StaticlibBase,\n-                           outputs,\n                            out_filename,\n                            tempdir);\n     let mut all_native_libs = vec![];\n@@ -611,7 +565,6 @@ fn link_natively(sess: &Session,\n                  crate_type: config::CrateType,\n                  out_filename: &Path,\n                  trans: &CrateTranslation,\n-                 outputs: &OutputFilenames,\n                  tmpdir: &Path) {\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n     let flavor = sess.linker_flavor();\n@@ -651,7 +604,7 @@ fn link_natively(sess: &Session,\n     {\n         let mut linker = trans.linker_info.to_linker(cmd, &sess);\n         link_args(&mut *linker, sess, crate_type, tmpdir,\n-                  out_filename, outputs, trans);\n+                  out_filename, trans);\n         cmd = linker.finalize();\n     }\n     if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n@@ -873,7 +826,6 @@ fn link_args(cmd: &mut Linker,\n              crate_type: config::CrateType,\n              tmpdir: &Path,\n              out_filename: &Path,\n-             outputs: &OutputFilenames,\n              trans: &CrateTranslation) {\n \n     // The default library location, we need this to find the runtime.\n@@ -884,8 +836,8 @@ fn link_args(cmd: &mut Linker,\n     let t = &sess.target.target;\n \n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n-    for module in trans.modules.iter() {\n-        cmd.add_object(&module.object);\n+    for obj in trans.modules.iter().filter_map(|m| m.object.as_ref()) {\n+        cmd.add_object(obj);\n     }\n     cmd.output_filename(out_filename);\n \n@@ -908,11 +860,16 @@ fn link_args(cmd: &mut Linker,\n     // object file, so we link that in here.\n     if crate_type == config::CrateTypeDylib ||\n        crate_type == config::CrateTypeProcMacro {\n-        cmd.add_object(&outputs.with_extension(METADATA_OBJ_NAME));\n+        if let Some(obj) = trans.metadata_module.object.as_ref() {\n+            cmd.add_object(obj);\n+        }\n     }\n \n-    if trans.allocator_module.is_some() {\n-        cmd.add_object(&outputs.with_extension(ALLOCATOR_OBJ_NAME));\n+    let obj = trans.allocator_module\n+        .as_ref()\n+        .and_then(|m| m.object.as_ref());\n+    if let Some(obj) = obj {\n+        cmd.add_object(obj);\n     }\n \n     // Try to strip as much out of the generated object by removing unused\n@@ -1180,9 +1137,9 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n \n         for f in archive.src_files() {\n             if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n-                    archive.remove_file(&f);\n-                    continue\n-                }\n+                archive.remove_file(&f);\n+                continue\n+            }\n         }\n \n         archive.build();\n@@ -1265,11 +1222,23 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                 let canonical = f.replace(\"-\", \"_\");\n                 let canonical_name = name.replace(\"-\", \"_\");\n \n+                // Look for `.rust-cgu.o` at the end of the filename to conclude\n+                // that this is a Rust-related object file.\n+                fn looks_like_rust(s: &str) -> bool {\n+                    let path = Path::new(s);\n+                    let ext = path.extension().and_then(|s| s.to_str());\n+                    if ext != Some(OutputType::Object.extension()) {\n+                        return false\n+                    }\n+                    let ext2 = path.file_stem()\n+                        .and_then(|s| Path::new(s).extension())\n+                        .and_then(|s| s.to_str());\n+                    ext2 == Some(RUST_CGU_EXT)\n+                }\n+\n                 let is_rust_object =\n-                    canonical.starts_with(&canonical_name) && {\n-                        let num = &f[name.len()..f.len() - 2];\n-                        num.len() > 0 && num[1..].parse::<u32>().is_ok()\n-                    };\n+                    canonical.starts_with(&canonical_name) &&\n+                    looks_like_rust(&f);\n \n                 // If we've been requested to skip all native object files\n                 // (those not generated by the rust compiler) then we can skip"}, {"sha": "48c3fd638c36ba52711b9b2c801bb5360a76fb23", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 422, "deletions": 73, "changes": 495, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -9,23 +9,25 @@\n // except according to those terms.\n \n use back::bytecode::{DecodedBytecode, RLIB_BYTECODE_EXTENSION};\n-use back::write;\n use back::symbol_export;\n-use rustc::session::config;\n+use back::write::{ModuleConfig, with_llvm_pmb, CodegenContext};\n+use back::write;\n use errors::{FatalError, Handler};\n-use llvm;\n use llvm::archive_ro::ArchiveRO;\n use llvm::{ModuleRef, TargetMachineRef, True, False};\n+use llvm;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n+use rustc::session::config;\n use rustc::util::common::time;\n-use rustc::hir::def_id::LOCAL_CRATE;\n-use back::write::{ModuleConfig, with_llvm_pmb, CodegenContext};\n-use {ModuleTranslation, ModuleKind};\n+use time_graph::Timeline;\n+use {ModuleTranslation, ModuleLlvm, ModuleKind, ModuleSource};\n \n use libc;\n \n use std::ffi::CString;\n use std::slice;\n+use std::sync::Arc;\n \n pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     match crate_type {\n@@ -45,14 +47,14 @@ pub enum LtoModuleTranslation {\n         _serialized_bitcode: Vec<SerializedModule>,\n     },\n \n-    // Note the lack of other entries in this enum! Ideally one day this gap is\n-    // intended to be filled with a \"Thin\" LTO variant.\n+    Thin(ThinModule),\n }\n \n impl LtoModuleTranslation {\n     pub fn name(&self) -> &str {\n         match *self {\n             LtoModuleTranslation::Fat { .. } => \"everything\",\n+            LtoModuleTranslation::Thin(ref m) => m.name(),\n         }\n     }\n \n@@ -62,7 +64,9 @@ impl LtoModuleTranslation {\n     /// points to LLVM data structures owned by this `LtoModuleTranslation`.\n     /// It's intended that the module returned is immediately code generated and\n     /// dropped, and then this LTO module is dropped.\n-    pub unsafe fn optimize(&mut self, cgcx: &CodegenContext)\n+    pub unsafe fn optimize(&mut self,\n+                           cgcx: &CodegenContext,\n+                           timeline: &mut Timeline)\n         -> Result<ModuleTranslation, FatalError>\n     {\n         match *self {\n@@ -71,9 +75,11 @@ impl LtoModuleTranslation {\n                 let config = cgcx.config(trans.kind);\n                 let llmod = trans.llvm().unwrap().llmod;\n                 let tm = trans.llvm().unwrap().tm;\n-                run_pass_manager(cgcx, tm, llmod, config);\n+                run_pass_manager(cgcx, tm, llmod, config, false);\n+                timeline.record(\"fat-done\");\n                 Ok(trans)\n             }\n+            LtoModuleTranslation::Thin(ref mut thin) => thin.optimize(cgcx, timeline),\n         }\n     }\n \n@@ -83,33 +89,31 @@ impl LtoModuleTranslation {\n         match *self {\n             // Only one module with fat LTO, so the cost doesn't matter.\n             LtoModuleTranslation::Fat { .. } => 0,\n+            LtoModuleTranslation::Thin(ref m) => m.cost(),\n         }\n     }\n }\n \n-pub fn run(cgcx: &CodegenContext, modules: Vec<ModuleTranslation>)\n+pub enum LTOMode {\n+    WholeCrateGraph,\n+    JustThisCrate,\n+}\n+\n+pub fn run(cgcx: &CodegenContext,\n+           modules: Vec<ModuleTranslation>,\n+           mode: LTOMode,\n+           timeline: &mut Timeline)\n     -> Result<Vec<LtoModuleTranslation>, FatalError>\n {\n     let diag_handler = cgcx.create_diag_handler();\n-    if cgcx.opts.cg.prefer_dynamic {\n-        diag_handler.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n-                    .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n-                           supported with LTO\")\n-                    .emit();\n-        return Err(FatalError)\n-    }\n-\n-    // Make sure we actually can run LTO\n-    for crate_type in cgcx.crate_types.iter() {\n-        if !crate_type_allows_lto(*crate_type) {\n-            let e = diag_handler.fatal(\"lto can only be run for executables, cdylibs and \\\n-                                        static library outputs\");\n-            return Err(e)\n+    let export_threshold = match mode {\n+        LTOMode::WholeCrateGraph => {\n+            symbol_export::crates_export_threshold(&cgcx.crate_types)\n         }\n-    }\n-\n-    let export_threshold =\n-        symbol_export::crates_export_threshold(&cgcx.crate_types);\n+        LTOMode::JustThisCrate => {\n+            SymbolExportLevel::Rust\n+        }\n+    };\n \n     let symbol_filter = &|&(ref name, _, level): &(String, _, SymbolExportLevel)| {\n         if level.is_below_threshold(export_threshold) {\n@@ -121,55 +125,82 @@ pub fn run(cgcx: &CodegenContext, modules: Vec<ModuleTranslation>)\n         }\n     };\n \n-    let mut symbol_white_list: Vec<CString> = cgcx.exported_symbols[&LOCAL_CRATE]\n+    let mut symbol_white_list = cgcx.exported_symbols[&LOCAL_CRATE]\n         .iter()\n         .filter_map(symbol_filter)\n-        .collect();\n-    info!(\"{} symbols in whitelist\", symbol_white_list.len());\n+        .collect::<Vec<CString>>();\n+    timeline.record(\"whitelist\");\n+    info!(\"{} symbols to preserve in this crate\", symbol_white_list.len());\n \n-    // For each of our upstream dependencies, find the corresponding rlib and\n-    // load the bitcode from the archive. Then merge it into the current LLVM\n-    // module that we've got.\n+    // If we're performing LTO for the entire crate graph, then for each of our\n+    // upstream dependencies, find the corresponding rlib and load the bitcode\n+    // from the archive.\n+    //\n+    // We save off all the bytecode and LLVM module ids for later processing\n+    // with either fat or thin LTO\n     let mut upstream_modules = Vec::new();\n-    for &(cnum, ref path) in cgcx.each_linked_rlib_for_lto.iter() {\n-        symbol_white_list.extend(\n-            cgcx.exported_symbols[&cnum]\n-                .iter()\n-                .filter_map(symbol_filter));\n-        info!(\"{} symbols in whitelist after {}\", symbol_white_list.len(), cnum);\n-\n-        let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n-        let bytecodes = archive.iter().filter_map(|child| {\n-            child.ok().and_then(|c| c.name().map(|name| (name, c)))\n-        }).filter(|&(name, _)| name.ends_with(RLIB_BYTECODE_EXTENSION));\n-        for (name, data) in bytecodes {\n-            info!(\"adding bytecode {}\", name);\n-            let bc_encoded = data.data();\n-\n-            let (bc, id) = time(cgcx.time_passes, &format!(\"decode {}\", name), || {\n-                match DecodedBytecode::new(bc_encoded) {\n-                    Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n-                    Err(e) => Err(diag_handler.fatal(&e)),\n-                }\n-            })?;\n-            let bc = SerializedModule::FromRlib(bc);\n-            upstream_modules.push((bc, CString::new(id).unwrap()));\n+    if let LTOMode::WholeCrateGraph = mode {\n+        if cgcx.opts.cg.prefer_dynamic {\n+            diag_handler.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n+                        .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n+                               supported with LTO\")\n+                        .emit();\n+            return Err(FatalError)\n+        }\n+\n+        // Make sure we actually can run LTO\n+        for crate_type in cgcx.crate_types.iter() {\n+            if !crate_type_allows_lto(*crate_type) {\n+                let e = diag_handler.fatal(\"lto can only be run for executables, cdylibs and \\\n+                                            static library outputs\");\n+                return Err(e)\n+            }\n         }\n-    }\n \n-    // Internalize everything but the exported symbols of the current module\n-    let arr: Vec<*const libc::c_char> = symbol_white_list.iter()\n-                                                         .map(|c| c.as_ptr())\n-                                                         .collect();\n+        for &(cnum, ref path) in cgcx.each_linked_rlib_for_lto.iter() {\n+            symbol_white_list.extend(\n+                cgcx.exported_symbols[&cnum]\n+                    .iter()\n+                    .filter_map(symbol_filter));\n+\n+            let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n+            let bytecodes = archive.iter().filter_map(|child| {\n+                child.ok().and_then(|c| c.name().map(|name| (name, c)))\n+            }).filter(|&(name, _)| name.ends_with(RLIB_BYTECODE_EXTENSION));\n+            for (name, data) in bytecodes {\n+                info!(\"adding bytecode {}\", name);\n+                let bc_encoded = data.data();\n+\n+                let (bc, id) = time(cgcx.time_passes, &format!(\"decode {}\", name), || {\n+                    match DecodedBytecode::new(bc_encoded) {\n+                        Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n+                        Err(e) => Err(diag_handler.fatal(&e)),\n+                    }\n+                })?;\n+                let bc = SerializedModule::FromRlib(bc);\n+                upstream_modules.push((bc, CString::new(id).unwrap()));\n+            }\n+            timeline.record(&format!(\"load: {}\", path.display()));\n+        }\n+    }\n \n-    fat_lto(cgcx, &diag_handler, modules, upstream_modules, &arr)\n+    let arr = symbol_white_list.iter().map(|c| c.as_ptr()).collect::<Vec<_>>();\n+    match mode {\n+        LTOMode::WholeCrateGraph if !cgcx.thinlto => {\n+            fat_lto(cgcx, &diag_handler, modules, upstream_modules, &arr, timeline)\n+        }\n+        _ => {\n+            thin_lto(&diag_handler, modules, upstream_modules, &arr, timeline)\n+        }\n+    }\n }\n \n fn fat_lto(cgcx: &CodegenContext,\n            diag_handler: &Handler,\n            mut modules: Vec<ModuleTranslation>,\n            mut serialized_modules: Vec<(SerializedModule, CString)>,\n-           symbol_white_list: &[*const libc::c_char])\n+           symbol_white_list: &[*const libc::c_char],\n+           timeline: &mut Timeline)\n     -> Result<Vec<LtoModuleTranslation>, FatalError>\n {\n     info!(\"going for a fat lto\");\n@@ -228,6 +259,7 @@ fn fat_lto(cgcx: &CodegenContext,\n                 Err(write::llvm_err(&diag_handler, msg))\n             }\n         })?;\n+        timeline.record(&format!(\"link {:?}\", name));\n         serialized_bitcode.push(bc_decoded);\n     }\n     cgcx.save_temp_bitcode(&module, \"lto.input\");\n@@ -248,18 +280,150 @@ fn fat_lto(cgcx: &CodegenContext,\n         }\n         cgcx.save_temp_bitcode(&module, \"lto.after-nounwind\");\n     }\n+    timeline.record(\"passes\");\n \n     Ok(vec![LtoModuleTranslation::Fat {\n         module: Some(module),\n         _serialized_bitcode: serialized_bitcode,\n     }])\n }\n \n+/// Prepare \"thin\" LTO to get run on these modules.\n+///\n+/// The general structure of ThinLTO is quite different from the structure of\n+/// \"fat\" LTO above. With \"fat\" LTO all LLVM modules in question are merged into\n+/// one giant LLVM module, and then we run more optimization passes over this\n+/// big module after internalizing most symbols. Thin LTO, on the other hand,\n+/// avoid this large bottleneck through more targeted optimization.\n+///\n+/// At a high level Thin LTO looks like:\n+///\n+///     1. Prepare a \"summary\" of each LLVM module in question which describes\n+///        the values inside, cost of the values, etc.\n+///     2. Merge the summaries of all modules in question into one \"index\"\n+///     3. Perform some global analysis on this index\n+///     4. For each module, use the index and analysis calculated previously to\n+///        perform local transformations on the module, for example inlining\n+///        small functions from other modules.\n+///     5. Run thin-specific optimization passes over each module, and then code\n+///        generate everything at the end.\n+///\n+/// The summary for each module is intended to be quite cheap, and the global\n+/// index is relatively quite cheap to create as well. As a result, the goal of\n+/// ThinLTO is to reduce the bottleneck on LTO and enable LTO to be used in more\n+/// situations. For example one cheap optimization is that we can parallelize\n+/// all codegen modules, easily making use of all the cores on a machine.\n+///\n+/// With all that in mind, the function here is designed at specifically just\n+/// calculating the *index* for ThinLTO. This index will then be shared amongst\n+/// all of the `LtoModuleTranslation` units returned below and destroyed once\n+/// they all go out of scope.\n+fn thin_lto(diag_handler: &Handler,\n+            modules: Vec<ModuleTranslation>,\n+            serialized_modules: Vec<(SerializedModule, CString)>,\n+            symbol_white_list: &[*const libc::c_char],\n+            timeline: &mut Timeline)\n+    -> Result<Vec<LtoModuleTranslation>, FatalError>\n+{\n+    unsafe {\n+        info!(\"going for that thin, thin LTO\");\n+\n+        let mut thin_buffers = Vec::new();\n+        let mut module_names = Vec::new();\n+        let mut thin_modules = Vec::new();\n+\n+        // FIXME: right now, like with fat LTO, we serialize all in-memory\n+        //        modules before working with them and ThinLTO. We really\n+        //        shouldn't do this, however, and instead figure out how to\n+        //        extract a summary from an in-memory module and then merge that\n+        //        into the global index. It turns out that this loop is by far\n+        //        the most expensive portion of this small bit of global\n+        //        analysis!\n+        for (i, module) in modules.iter().enumerate() {\n+            info!(\"local module: {} - {}\", i, module.llmod_id);\n+            let llvm = module.llvm().expect(\"can't lto pretranslated module\");\n+            let name = CString::new(module.llmod_id.clone()).unwrap();\n+            let buffer = ThinBuffer::new(llvm.llmod);\n+            thin_modules.push(llvm::ThinLTOModule {\n+                identifier: name.as_ptr(),\n+                data: buffer.data().as_ptr(),\n+                len: buffer.data().len(),\n+            });\n+            thin_buffers.push(buffer);\n+            module_names.push(name);\n+            timeline.record(&module.llmod_id);\n+        }\n+\n+        // FIXME: All upstream crates are deserialized internally in the\n+        //        function below to extract their summary and modules. Note that\n+        //        unlike the loop above we *must* decode and/or read something\n+        //        here as these are all just serialized files on disk. An\n+        //        improvement, however, to make here would be to store the\n+        //        module summary separately from the actual module itself. Right\n+        //        now this is store in one large bitcode file, and the entire\n+        //        file is deflate-compressed. We could try to bypass some of the\n+        //        decompression by storing the index uncompressed and only\n+        //        lazily decompressing the bytecode if necessary.\n+        //\n+        //        Note that truly taking advantage of this optimization will\n+        //        likely be further down the road. We'd have to implement\n+        //        incremental ThinLTO first where we could actually avoid\n+        //        looking at upstream modules entirely sometimes (the contents,\n+        //        we must always unconditionally look at the index).\n+        let mut serialized = Vec::new();\n+        for (module, name) in serialized_modules {\n+            info!(\"foreign module {:?}\", name);\n+            thin_modules.push(llvm::ThinLTOModule {\n+                identifier: name.as_ptr(),\n+                data: module.data().as_ptr(),\n+                len: module.data().len(),\n+            });\n+            serialized.push(module);\n+            module_names.push(name);\n+        }\n+\n+        // Delegate to the C++ bindings to create some data here. Once this is a\n+        // tried-and-true interface we may wish to try to upstream some of this\n+        // to LLVM itself, right now we reimplement a lot of what they do\n+        // upstream...\n+        let data = llvm::LLVMRustCreateThinLTOData(\n+            thin_modules.as_ptr(),\n+            thin_modules.len() as u32,\n+            symbol_white_list.as_ptr(),\n+            symbol_white_list.len() as u32,\n+        );\n+        if data.is_null() {\n+            let msg = format!(\"failed to prepare thin LTO context\");\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n+        let data = ThinData(data);\n+        info!(\"thin LTO data created\");\n+        timeline.record(\"data\");\n+\n+        // Throw our data in an `Arc` as we'll be sharing it across threads. We\n+        // also put all memory referenced by the C++ data (buffers, ids, etc)\n+        // into the arc as well. After this we'll create a thin module\n+        // translation per module in this data.\n+        let shared = Arc::new(ThinShared {\n+            data,\n+            thin_buffers,\n+            serialized_modules: serialized,\n+            module_names,\n+        });\n+        Ok((0..shared.module_names.len()).map(|i| {\n+            LtoModuleTranslation::Thin(ThinModule {\n+                shared: shared.clone(),\n+                idx: i,\n+            })\n+        }).collect())\n+    }\n+}\n+\n fn run_pass_manager(cgcx: &CodegenContext,\n                     tm: TargetMachineRef,\n                     llmod: ModuleRef,\n-                    config: &ModuleConfig) {\n-\n+                    config: &ModuleConfig,\n+                    thin: bool) {\n     // Now we have one massive module inside of llmod. Time to run the\n     // LTO-specific optimization passes that LLVM provides.\n     //\n@@ -273,10 +437,33 @@ fn run_pass_manager(cgcx: &CodegenContext,\n         assert!(!pass.is_null());\n         llvm::LLVMRustAddPass(pm, pass);\n \n-        with_llvm_pmb(llmod, config, &mut |b| {\n-            llvm::LLVMPassManagerBuilderPopulateLTOPassManager(b, pm,\n-                /* Internalize = */ False,\n-                /* RunInliner = */ True);\n+        // When optimizing for LTO we don't actually pass in `-O0`, but we force\n+        // it to always happen at least with `-O1`.\n+        //\n+        // With ThinLTO we mess around a lot with symbol visibility in a way\n+        // that will actually cause linking failures if we optimize at O0 which\n+        // notable is lacking in dead code elimination. To ensure we at least\n+        // get some optimizations and correctly link we forcibly switch to `-O1`\n+        // to get dead code elimination.\n+        //\n+        // Note that in general this shouldn't matter too much as you typically\n+        // only turn on ThinLTO when you're compiling with optimizations\n+        // otherwise.\n+        let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n+        let opt_level = match opt_level {\n+            llvm::CodeGenOptLevel::None => llvm::CodeGenOptLevel::Less,\n+            level => level,\n+        };\n+        with_llvm_pmb(llmod, config, opt_level, &mut |b| {\n+            if thin {\n+                if !llvm::LLVMRustPassManagerBuilderPopulateThinLTOPassManager(b, pm) {\n+                    panic!(\"this version of LLVM does not support ThinLTO\");\n+                }\n+            } else {\n+                llvm::LLVMPassManagerBuilderPopulateLTOPassManager(b, pm,\n+                    /* Internalize = */ False,\n+                    /* RunInliner = */ True);\n+            }\n         });\n \n         let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr() as *const _);\n@@ -311,13 +498,13 @@ unsafe impl Send for ModuleBuffer {}\n unsafe impl Sync for ModuleBuffer {}\n \n impl ModuleBuffer {\n-    fn new(m: ModuleRef) -> ModuleBuffer {\n+    pub fn new(m: ModuleRef) -> ModuleBuffer {\n         ModuleBuffer(unsafe {\n             llvm::LLVMRustModuleBufferCreate(m)\n         })\n     }\n \n-    fn data(&self) -> &[u8] {\n+    pub fn data(&self) -> &[u8] {\n         unsafe {\n             let ptr = llvm::LLVMRustModuleBufferPtr(self.0);\n             let len = llvm::LLVMRustModuleBufferLen(self.0);\n@@ -331,3 +518,165 @@ impl Drop for ModuleBuffer {\n         unsafe { llvm::LLVMRustModuleBufferFree(self.0); }\n     }\n }\n+\n+pub struct ThinModule {\n+    shared: Arc<ThinShared>,\n+    idx: usize,\n+}\n+\n+struct ThinShared {\n+    data: ThinData,\n+    thin_buffers: Vec<ThinBuffer>,\n+    serialized_modules: Vec<SerializedModule>,\n+    module_names: Vec<CString>,\n+}\n+\n+struct ThinData(*mut llvm::ThinLTOData);\n+\n+unsafe impl Send for ThinData {}\n+unsafe impl Sync for ThinData {}\n+\n+impl Drop for ThinData {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMRustFreeThinLTOData(self.0);\n+        }\n+    }\n+}\n+\n+pub struct ThinBuffer(*mut llvm::ThinLTOBuffer);\n+\n+unsafe impl Send for ThinBuffer {}\n+unsafe impl Sync for ThinBuffer {}\n+\n+impl ThinBuffer {\n+    pub fn new(m: ModuleRef) -> ThinBuffer {\n+        unsafe {\n+            let buffer = llvm::LLVMRustThinLTOBufferCreate(m);\n+            ThinBuffer(buffer)\n+        }\n+    }\n+\n+    pub fn data(&self) -> &[u8] {\n+        unsafe {\n+            let ptr = llvm::LLVMRustThinLTOBufferPtr(self.0) as *const _;\n+            let len = llvm::LLVMRustThinLTOBufferLen(self.0);\n+            slice::from_raw_parts(ptr, len)\n+        }\n+    }\n+}\n+\n+impl Drop for ThinBuffer {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMRustThinLTOBufferFree(self.0);\n+        }\n+    }\n+}\n+\n+impl ThinModule {\n+    fn name(&self) -> &str {\n+        self.shared.module_names[self.idx].to_str().unwrap()\n+    }\n+\n+    fn cost(&self) -> u64 {\n+        // Yes, that's correct, we're using the size of the bytecode as an\n+        // indicator for how costly this codegen unit is.\n+        self.data().len() as u64\n+    }\n+\n+    fn data(&self) -> &[u8] {\n+        let a = self.shared.thin_buffers.get(self.idx).map(|b| b.data());\n+        a.unwrap_or_else(|| {\n+            let len = self.shared.thin_buffers.len();\n+            self.shared.serialized_modules[self.idx - len].data()\n+        })\n+    }\n+\n+    unsafe fn optimize(&mut self, cgcx: &CodegenContext, timeline: &mut Timeline)\n+        -> Result<ModuleTranslation, FatalError>\n+    {\n+        let diag_handler = cgcx.create_diag_handler();\n+        let tm = (cgcx.tm_factory)().map_err(|e| {\n+            write::llvm_err(&diag_handler, e)\n+        })?;\n+\n+        // Right now the implementation we've got only works over serialized\n+        // modules, so we create a fresh new LLVM context and parse the module\n+        // into that context. One day, however, we may do this for upstream\n+        // crates but for locally translated modules we may be able to reuse\n+        // that LLVM Context and Module.\n+        let llcx = llvm::LLVMContextCreate();\n+        let llmod = llvm::LLVMRustParseBitcodeForThinLTO(\n+            llcx,\n+            self.data().as_ptr(),\n+            self.data().len(),\n+            self.shared.module_names[self.idx].as_ptr(),\n+        );\n+        assert!(!llmod.is_null());\n+        let mtrans = ModuleTranslation {\n+            source: ModuleSource::Translated(ModuleLlvm {\n+                llmod,\n+                llcx,\n+                tm,\n+            }),\n+            llmod_id: self.name().to_string(),\n+            name: self.name().to_string(),\n+            kind: ModuleKind::Regular,\n+        };\n+        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-input\");\n+\n+        // Like with \"fat\" LTO, get some better optimizations if landing pads\n+        // are disabled by removing all landing pads.\n+        if cgcx.no_landing_pads {\n+            llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n+            cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-nounwind\");\n+            timeline.record(\"nounwind\");\n+        }\n+\n+        // Up next comes the per-module local analyses that we do for Thin LTO.\n+        // Each of these functions is basically copied from the LLVM\n+        // implementation and then tailored to suit this implementation. Ideally\n+        // each of these would be supported by upstream LLVM but that's perhaps\n+        // a patch for another day!\n+        //\n+        // You can find some more comments about these functions in the LLVM\n+        // bindings we've got (currently `PassWrapper.cpp`)\n+        if !llvm::LLVMRustPrepareThinLTORename(self.shared.data.0, llmod) {\n+            let msg = format!(\"failed to prepare thin LTO module\");\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n+        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-rename\");\n+        timeline.record(\"rename\");\n+        if !llvm::LLVMRustPrepareThinLTOResolveWeak(self.shared.data.0, llmod) {\n+            let msg = format!(\"failed to prepare thin LTO module\");\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n+        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-resolve\");\n+        timeline.record(\"resolve\");\n+        if !llvm::LLVMRustPrepareThinLTOInternalize(self.shared.data.0, llmod) {\n+            let msg = format!(\"failed to prepare thin LTO module\");\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n+        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-internalize\");\n+        timeline.record(\"internalize\");\n+        if !llvm::LLVMRustPrepareThinLTOImport(self.shared.data.0, llmod) {\n+            let msg = format!(\"failed to prepare thin LTO module\");\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n+        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-import\");\n+        timeline.record(\"import\");\n+\n+        // Alright now that we've done everything related to the ThinLTO\n+        // analysis it's time to run some optimizations! Here we use the same\n+        // `run_pass_manager` as the \"fat\" LTO above except that we tell it to\n+        // populate a thin-specific pass manager, which presumably LLVM treats a\n+        // little differently.\n+        info!(\"running thin lto passes over {}\", mtrans.name);\n+        let config = cgcx.config(mtrans.kind);\n+        run_pass_manager(cgcx, tm, llmod, config, true);\n+        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-pm\");\n+        timeline.record(\"thin-done\");\n+        Ok(mtrans)\n+    }\n+}"}, {"sha": "0ebfe4daad18fcd9db9c1a7b69b327c01519e8e0", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -98,8 +98,10 @@\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n use monomorphize::Instance;\n+use trans_item::{BaseTransItemExt, InstantiationMode};\n \n use rustc::middle::weak_lang_items;\n+use rustc::middle::trans::TransItem;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -150,7 +152,10 @@ pub fn provide(providers: &mut Providers) {\n fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                              // the DefId of the item this name is for\n-                             def_id: Option<DefId>,\n+                             def_id: DefId,\n+\n+                             // instance this name will be for\n+                             instance: Instance<'tcx>,\n \n                              // type of the item, without any generic\n                              // parameters substituted; this is\n@@ -160,7 +165,7 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                              // values for generic type parameters,\n                              // if any.\n-                             substs: Option<&'tcx Substs<'tcx>>)\n+                             substs: &'tcx Substs<'tcx>)\n                              -> u64 {\n     debug!(\"get_symbol_hash(def_id={:?}, parameters={:?})\", def_id, substs);\n \n@@ -170,7 +175,7 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // the main symbol name is not necessarily unique; hash in the\n         // compiler's internal def-path, guaranteeing each symbol has a\n         // truly unique path\n-        hasher.hash(def_id.map(|def_id| tcx.def_path_hash(def_id)));\n+        hasher.hash(tcx.def_path_hash(def_id));\n \n         // Include the main item-type. Note that, in this case, the\n         // assertions about `needs_subst` may not hold, but this item-type\n@@ -186,19 +191,36 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // also include any type parameters (for generic items)\n-        if let Some(substs) = substs {\n-            assert!(!substs.has_erasable_regions());\n-            assert!(!substs.needs_subst());\n-            substs.visit_with(&mut hasher);\n-\n-            // If this is an instance of a generic function, we also hash in\n-            // the ID of the instantiating crate. This avoids symbol conflicts\n-            // in case the same instances is emitted in two crates of the same\n-            // project.\n-            if substs.types().next().is_some() {\n-                hasher.hash(tcx.crate_name.as_str());\n-                hasher.hash(tcx.sess.local_crate_disambiguator().as_str());\n+        assert!(!substs.has_erasable_regions());\n+        assert!(!substs.needs_subst());\n+        substs.visit_with(&mut hasher);\n+\n+        let mut avoid_cross_crate_conflicts = false;\n+\n+        // If this is an instance of a generic function, we also hash in\n+        // the ID of the instantiating crate. This avoids symbol conflicts\n+        // in case the same instances is emitted in two crates of the same\n+        // project.\n+        if substs.types().next().is_some() {\n+            avoid_cross_crate_conflicts = true;\n+        }\n+\n+        // If we're dealing with an instance of a function that's inlined from\n+        // another crate but we're marking it as globally shared to our\n+        // compliation (aka we're not making an internal copy in each of our\n+        // codegen units) then this symbol may become an exported (but hidden\n+        // visibility) symbol. This means that multiple crates may do the same\n+        // and we want to be sure to avoid any symbol conflicts here.\n+        match TransItem::Fn(instance).instantiation_mode(tcx) {\n+            InstantiationMode::GloballyShared { may_conflict: true } => {\n+                avoid_cross_crate_conflicts = true;\n             }\n+            _ => {}\n+        }\n+\n+        if avoid_cross_crate_conflicts {\n+            hasher.hash(tcx.crate_name.as_str());\n+            hasher.hash(tcx.sess.local_crate_disambiguator().as_str());\n         }\n     });\n \n@@ -309,7 +331,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     // and should not matter anyhow.\n     let instance_ty = tcx.erase_regions(&instance_ty);\n \n-    let hash = get_symbol_hash(tcx, Some(def_id), instance_ty, Some(substs));\n+    let hash = get_symbol_hash(tcx, def_id, instance, instance_ty, substs);\n \n     SymbolPathBuffer::from_interned(tcx.def_symbol_name(def_id)).finish(hash)\n }"}, {"sha": "5550ab9fa55e6752863dc192fd75f9d29ee8eec9", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 237, "deletions": 87, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -8,18 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::lto;\n+use back::bytecode::{self, RLIB_BYTECODE_EXTENSION};\n+use back::lto::{self, ModuleBuffer, ThinBuffer};\n use back::link::{self, get_linker, remove};\n use back::linker::LinkerInfo;\n use back::symbol_export::ExportedSymbols;\n+use base;\n+use consts;\n use rustc_incremental::{save_trans_partition, in_incr_comp_dir};\n-use rustc::dep_graph::DepGraph;\n+use rustc::dep_graph::{DepGraph, WorkProductFileKind};\n use rustc::middle::cstore::{LinkMeta, EncodedMetadata};\n use rustc::session::config::{self, OutputFilenames, OutputType, OutputTypes, Passes, SomePasses,\n                              AllPasses, Sanitizer};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n-use time_graph::{self, TimeGraph};\n+use time_graph::{self, TimeGraph, Timeline};\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n use llvm::{SMDiagnosticRef, ContextRef};\n@@ -35,13 +38,14 @@ use syntax::attr;\n use syntax::ext::hygiene::Mark;\n use syntax_pos::MultiSpan;\n use syntax_pos::symbol::Symbol;\n+use type_::Type;\n use context::{is_pie_binary, get_reloc_model};\n use jobserver::{Client, Acquired};\n use rustc_demangle;\n \n use std::any::Any;\n-use std::ffi::CString;\n-use std::fs;\n+use std::ffi::{CString, CStr};\n+use std::fs::{self, File};\n use std::io;\n use std::io::Write;\n use std::mem;\n@@ -217,14 +221,15 @@ pub struct ModuleConfig {\n     passes: Vec<String>,\n     /// Some(level) to optimize at a certain level, or None to run\n     /// absolutely no optimizations (used for the metadata module).\n-    opt_level: Option<llvm::CodeGenOptLevel>,\n+    pub opt_level: Option<llvm::CodeGenOptLevel>,\n \n     /// Some(level) to optimize binary size, or None to not affect program size.\n     opt_size: Option<llvm::CodeGenOptSize>,\n \n     // Flags indicating which outputs to produce.\n     emit_no_opt_bc: bool,\n     emit_bc: bool,\n+    emit_bc_compressed: bool,\n     emit_lto_bc: bool,\n     emit_ir: bool,\n     emit_asm: bool,\n@@ -254,6 +259,7 @@ impl ModuleConfig {\n \n             emit_no_opt_bc: false,\n             emit_bc: false,\n+            emit_bc_compressed: false,\n             emit_lto_bc: false,\n             emit_ir: false,\n             emit_asm: false,\n@@ -303,6 +309,7 @@ pub struct CodegenContext {\n     // Resouces needed when running LTO\n     pub time_passes: bool,\n     pub lto: bool,\n+    pub thinlto: bool,\n     pub no_landing_pads: bool,\n     pub save_temps: bool,\n     pub exported_symbols: Arc<ExportedSymbols>,\n@@ -314,7 +321,11 @@ pub struct CodegenContext {\n     metadata_module_config: Arc<ModuleConfig>,\n     allocator_module_config: Arc<ModuleConfig>,\n     pub tm_factory: Arc<Fn() -> Result<TargetMachineRef, String> + Send + Sync>,\n+    pub msvc_imps_needed: bool,\n+    pub target_pointer_width: String,\n \n+    // Number of cgus excluding the allocator/metadata modules\n+    pub total_cgus: usize,\n     // Handler to use for diagnostics produced during codegen.\n     pub diag_emitter: SharedEmitter,\n     // LLVM passes added by plugins.\n@@ -450,7 +461,8 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n unsafe fn optimize(cgcx: &CodegenContext,\n                    diag_handler: &Handler,\n                    mtrans: &ModuleTranslation,\n-                   config: &ModuleConfig)\n+                   config: &ModuleConfig,\n+                   timeline: &mut Timeline)\n     -> Result<(), FatalError>\n {\n     let (llmod, llcx, tm) = match mtrans.source {\n@@ -503,7 +515,8 @@ unsafe fn optimize(cgcx: &CodegenContext,\n         if !config.no_prepopulate_passes {\n             llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n             llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n-            with_llvm_pmb(llmod, &config, &mut |b| {\n+            let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n+            with_llvm_pmb(llmod, &config, opt_level, &mut |b| {\n                 llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n                 llvm::LLVMPassManagerBuilderPopulateModulePassManager(b, mpm);\n             })\n@@ -529,6 +542,7 @@ unsafe fn optimize(cgcx: &CodegenContext,\n         // Finally, run the actual optimization passes\n         time(config.time_passes, &format!(\"llvm function passes [{}]\", module_name.unwrap()), ||\n              llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n+        timeline.record(\"fpm\");\n         time(config.time_passes, &format!(\"llvm module passes [{}]\", module_name.unwrap()), ||\n              llvm::LLVMRunPassManager(mpm, llmod));\n \n@@ -543,7 +557,18 @@ fn generate_lto_work(cgcx: &CodegenContext,\n                      modules: Vec<ModuleTranslation>)\n     -> Vec<(WorkItem, u64)>\n {\n-    let lto_modules = lto::run(cgcx, modules).unwrap_or_else(|e| panic!(e));\n+    let mut timeline = cgcx.time_graph.as_ref().map(|tg| {\n+        tg.start(TRANS_WORKER_TIMELINE,\n+                 TRANS_WORK_PACKAGE_KIND,\n+                 \"generate lto\")\n+    }).unwrap_or(Timeline::noop());\n+    let mode = if cgcx.lto {\n+        lto::LTOMode::WholeCrateGraph\n+    } else {\n+        lto::LTOMode::JustThisCrate\n+    };\n+    let lto_modules = lto::run(cgcx, modules, mode, &mut timeline)\n+        .unwrap_or_else(|e| panic!(e));\n \n     lto_modules.into_iter().map(|module| {\n         let cost = module.cost();\n@@ -554,9 +579,11 @@ fn generate_lto_work(cgcx: &CodegenContext,\n unsafe fn codegen(cgcx: &CodegenContext,\n                   diag_handler: &Handler,\n                   mtrans: ModuleTranslation,\n-                  config: &ModuleConfig)\n+                  config: &ModuleConfig,\n+                  timeline: &mut Timeline)\n     -> Result<CompiledModule, FatalError>\n {\n+    timeline.record(\"codegen\");\n     let (llmod, llcx, tm) = match mtrans.source {\n         ModuleSource::Translated(ref llvm) => (llvm.llmod, llvm.llcx, llvm.tm),\n         ModuleSource::Preexisting(_) => {\n@@ -567,6 +594,10 @@ unsafe fn codegen(cgcx: &CodegenContext,\n     let module_name = Some(&module_name[..]);\n     let handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n \n+    if cgcx.msvc_imps_needed {\n+        create_msvc_imps(cgcx, llcx, llmod);\n+    }\n+\n     // A codegen-specific pass manager is used to generate object\n     // files for an LLVM module.\n     //\n@@ -599,9 +630,34 @@ unsafe fn codegen(cgcx: &CodegenContext,\n     let bc_out = cgcx.output_filenames.temp_path(OutputType::Bitcode, module_name);\n     let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n \n-    if write_bc {\n-        let bc_out_c = path2cstr(&bc_out);\n-        llvm::LLVMWriteBitcodeToFile(llmod, bc_out_c.as_ptr());\n+\n+    if write_bc || config.emit_bc_compressed {\n+        let thin;\n+        let old;\n+        let data = if llvm::LLVMRustThinLTOAvailable() {\n+            thin = ThinBuffer::new(llmod);\n+            thin.data()\n+        } else {\n+            old = ModuleBuffer::new(llmod);\n+            old.data()\n+        };\n+        timeline.record(\"make-bc\");\n+\n+        if write_bc {\n+            if let Err(e) = File::create(&bc_out).and_then(|mut f| f.write_all(data)) {\n+                diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n+            }\n+            timeline.record(\"write-bc\");\n+        }\n+\n+        if config.emit_bc_compressed {\n+            let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n+            let data = bytecode::encode(&mtrans.llmod_id, data);\n+            if let Err(e) = File::create(&dst).and_then(|mut f| f.write_all(&data)) {\n+                diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n+            }\n+            timeline.record(\"compress-bc\");\n+        }\n     }\n \n     time(config.time_passes, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n@@ -644,7 +700,8 @@ unsafe fn codegen(cgcx: &CodegenContext,\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr(), demangle_callback);\n                 llvm::LLVMDisposePassManager(cpm);\n-            })\n+            });\n+            timeline.record(\"ir\");\n         }\n \n         if config.emit_asm {\n@@ -665,13 +722,15 @@ unsafe fn codegen(cgcx: &CodegenContext,\n             if config.emit_obj {\n                 llvm::LLVMDisposeModule(llmod);\n             }\n+            timeline.record(\"asm\");\n         }\n \n         if write_obj {\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n                                   llvm::FileType::ObjectFile)\n             })?;\n+            timeline.record(\"obj\");\n         }\n \n         Ok(())\n@@ -694,6 +753,7 @@ unsafe fn codegen(cgcx: &CodegenContext,\n     drop(handlers);\n     Ok(mtrans.into_compiled_module(config.emit_obj,\n                                    config.emit_bc,\n+                                   config.emit_bc_compressed,\n                                    &cgcx.output_filenames))\n }\n \n@@ -712,7 +772,8 @@ pub fn start_async_translation(tcx: TyCtxt,\n                                time_graph: Option<TimeGraph>,\n                                link: LinkMeta,\n                                metadata: EncodedMetadata,\n-                               coordinator_receive: Receiver<Box<Any + Send>>)\n+                               coordinator_receive: Receiver<Box<Any + Send>>,\n+                               total_cgus: usize)\n                                -> OngoingCrateTranslation {\n     let sess = tcx.sess;\n     let crate_output = tcx.output_filenames(LOCAL_CRATE);\n@@ -779,11 +840,12 @@ pub fn start_async_translation(tcx: TyCtxt,\n         allocator_config.emit_bc = true;\n     }\n \n-    // Emit bitcode files for the crate if we're emitting an rlib.\n-    // Whenever an rlib is created, the bitcode is inserted into the\n-    // archive in order to allow LTO against it.\n+    // Emit compressed bitcode files for the crate if we're emitting an rlib.\n+    // Whenever an rlib is created, the bitcode is inserted into the archive in\n+    // order to allow LTO against it.\n     if need_crate_bitcode_for_rlib(sess) {\n-        modules_config.emit_bc = true;\n+        modules_config.emit_bc_compressed = true;\n+        allocator_config.emit_bc_compressed = true;\n     }\n \n     for output_type in output_types_override.keys() {\n@@ -836,6 +898,7 @@ pub fn start_async_translation(tcx: TyCtxt,\n                                                   shared_emitter,\n                                                   trans_worker_send,\n                                                   coordinator_receive,\n+                                                  total_cgus,\n                                                   client,\n                                                   time_graph.clone(),\n                                                   Arc::new(modules_config),\n@@ -862,29 +925,25 @@ pub fn start_async_translation(tcx: TyCtxt,\n \n fn copy_module_artifacts_into_incr_comp_cache(sess: &Session,\n                                               dep_graph: &DepGraph,\n-                                              compiled_modules: &CompiledModules,\n-                                              crate_output: &OutputFilenames) {\n+                                              compiled_modules: &CompiledModules) {\n     if sess.opts.incremental.is_none() {\n         return;\n     }\n \n     for module in compiled_modules.modules.iter() {\n         let mut files = vec![];\n \n-        if module.emit_obj {\n-            let path = crate_output.temp_path(OutputType::Object, Some(&module.name));\n-            files.push((OutputType::Object, path));\n+        if let Some(ref path) = module.object {\n+            files.push((WorkProductFileKind::Object, path.clone()));\n         }\n-\n-        if module.emit_bc {\n-            let path = crate_output.temp_path(OutputType::Bitcode, Some(&module.name));\n-            files.push((OutputType::Bitcode, path));\n+        if let Some(ref path) = module.bytecode {\n+            files.push((WorkProductFileKind::Bytecode, path.clone()));\n+        }\n+        if let Some(ref path) = module.bytecode_compressed {\n+            files.push((WorkProductFileKind::BytecodeCompressed, path.clone()));\n         }\n \n-        save_trans_partition(sess,\n-                             dep_graph,\n-                             &module.name,\n-                             &files);\n+        save_trans_partition(sess, dep_graph, &module.name, &files);\n     }\n }\n \n@@ -988,8 +1047,6 @@ fn produce_final_output_artifacts(sess: &Session,\n         // well.\n \n         // Specific rules for keeping .#module-name#.bc:\n-        //  - If we're building an rlib (`needs_crate_bitcode`), then keep\n-        //    it.\n         //  - If the user requested bitcode (`user_wants_bitcode`), and\n         //    codegen_units > 1, then keep it.\n         //  - If the user requested bitcode but codegen_units == 1, then we\n@@ -999,41 +1056,37 @@ fn produce_final_output_artifacts(sess: &Session,\n         // If you change how this works, also update back::link::link_rlib,\n         // where .#module-name#.bc files are (maybe) deleted after making an\n         // rlib.\n-        let needs_crate_bitcode = need_crate_bitcode_for_rlib(sess);\n         let needs_crate_object = crate_output.outputs.contains_key(&OutputType::Exe);\n \n-        let keep_numbered_bitcode = needs_crate_bitcode ||\n-                (user_wants_bitcode && sess.opts.codegen_units > 1);\n+        let keep_numbered_bitcode = user_wants_bitcode && sess.codegen_units() > 1;\n \n         let keep_numbered_objects = needs_crate_object ||\n-                (user_wants_objects && sess.opts.codegen_units > 1);\n+                (user_wants_objects && sess.codegen_units() > 1);\n \n         for module in compiled_modules.modules.iter() {\n-            let module_name = Some(&module.name[..]);\n-\n-            if module.emit_obj && !keep_numbered_objects {\n-                let path = crate_output.temp_path(OutputType::Object, module_name);\n-                remove(sess, &path);\n+            if let Some(ref path) = module.object {\n+                if !keep_numbered_objects {\n+                    remove(sess, path);\n+                }\n             }\n \n-            if module.emit_bc && !keep_numbered_bitcode {\n-                let path = crate_output.temp_path(OutputType::Bitcode, module_name);\n-                remove(sess, &path);\n+            if let Some(ref path) = module.bytecode {\n+                if !keep_numbered_bitcode {\n+                    remove(sess, path);\n+                }\n             }\n         }\n \n-        if compiled_modules.metadata_module.emit_bc && !user_wants_bitcode {\n-            let path = crate_output.temp_path(OutputType::Bitcode,\n-                                              Some(&compiled_modules.metadata_module.name));\n-            remove(sess, &path);\n-        }\n-\n-        if let Some(ref allocator_module) = compiled_modules.allocator_module {\n-            if allocator_module.emit_bc && !user_wants_bitcode {\n-                let path = crate_output.temp_path(OutputType::Bitcode,\n-                                                  Some(&allocator_module.name));\n+        if !user_wants_bitcode {\n+            if let Some(ref path) = compiled_modules.metadata_module.bytecode {\n                 remove(sess, &path);\n             }\n+\n+            if let Some(ref allocator_module) = compiled_modules.allocator_module {\n+                if let Some(ref path) = allocator_module.bytecode {\n+                    remove(sess, path);\n+                }\n+            }\n         }\n     }\n \n@@ -1045,13 +1098,9 @@ fn produce_final_output_artifacts(sess: &Session,\n }\n \n pub fn dump_incremental_data(trans: &CrateTranslation) {\n-    let mut reuse = 0;\n-    for mtrans in trans.modules.iter() {\n-        if mtrans.pre_existing {\n-            reuse += 1;\n-        }\n-    }\n-    eprintln!(\"incremental: re-using {} out of {} modules\", reuse, trans.modules.len());\n+    println!(\"[incremental] Re-using {} out of {} modules\",\n+              trans.modules.iter().filter(|m| m.pre_existing).count(),\n+              trans.modules.len());\n }\n \n enum WorkItem {\n@@ -1080,7 +1129,9 @@ enum WorkItemResult {\n     NeedsLTO(ModuleTranslation),\n }\n \n-fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n+fn execute_work_item(cgcx: &CodegenContext,\n+                     work_item: WorkItem,\n+                     timeline: &mut Timeline)\n     -> Result<WorkItemResult, FatalError>\n {\n     let diag_handler = cgcx.create_diag_handler();\n@@ -1089,8 +1140,8 @@ fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n         WorkItem::Optimize(mtrans) => mtrans,\n         WorkItem::LTO(mut lto) => {\n             unsafe {\n-                let module = lto.optimize(cgcx)?;\n-                let module = codegen(cgcx, &diag_handler, module, config)?;\n+                let module = lto.optimize(cgcx, timeline)?;\n+                let module = codegen(cgcx, &diag_handler, module, config, timeline)?;\n                 return Ok(WorkItemResult::Compiled(module))\n             }\n         }\n@@ -1107,8 +1158,28 @@ fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n                                         .as_ref()\n                                         .unwrap();\n         let name = &mtrans.name;\n+        let mut object = None;\n+        let mut bytecode = None;\n+        let mut bytecode_compressed = None;\n         for (kind, saved_file) in wp.saved_files {\n-            let obj_out = cgcx.output_filenames.temp_path(kind, Some(name));\n+            let obj_out = match kind {\n+                WorkProductFileKind::Object => {\n+                    let path = cgcx.output_filenames.temp_path(OutputType::Object, Some(name));\n+                    object = Some(path.clone());\n+                    path\n+                }\n+                WorkProductFileKind::Bytecode => {\n+                    let path = cgcx.output_filenames.temp_path(OutputType::Bitcode, Some(name));\n+                    bytecode = Some(path.clone());\n+                    path\n+                }\n+                WorkProductFileKind::BytecodeCompressed => {\n+                    let path = cgcx.output_filenames.temp_path(OutputType::Bitcode, Some(name))\n+                        .with_extension(RLIB_BYTECODE_EXTENSION);\n+                    bytecode_compressed = Some(path.clone());\n+                    path\n+                }\n+            };\n             let source_file = in_incr_comp_dir(&incr_comp_session_dir,\n                                                &saved_file);\n             debug!(\"copying pre-existing module `{}` from {:?} to {}\",\n@@ -1125,24 +1196,44 @@ fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n                 }\n             }\n         }\n-        let object = cgcx.output_filenames.temp_path(OutputType::Object, Some(name));\n+        assert_eq!(object.is_some(), config.emit_obj);\n+        assert_eq!(bytecode.is_some(), config.emit_bc);\n+        assert_eq!(bytecode_compressed.is_some(), config.emit_bc_compressed);\n \n         Ok(WorkItemResult::Compiled(CompiledModule {\n-            object,\n             llmod_id: mtrans.llmod_id.clone(),\n             name: module_name,\n             kind: ModuleKind::Regular,\n             pre_existing: true,\n-            emit_bc: config.emit_bc,\n-            emit_obj: config.emit_obj,\n+            object,\n+            bytecode,\n+            bytecode_compressed,\n         }))\n     } else {\n         debug!(\"llvm-optimizing {:?}\", module_name);\n \n         unsafe {\n-            optimize(cgcx, &diag_handler, &mtrans, config)?;\n-            if !cgcx.lto || mtrans.kind == ModuleKind::Metadata {\n-                let module = codegen(cgcx, &diag_handler, mtrans, config)?;\n+            optimize(cgcx, &diag_handler, &mtrans, config, timeline)?;\n+\n+            let lto = cgcx.lto;\n+\n+            let auto_thin_lto =\n+                cgcx.thinlto &&\n+                cgcx.total_cgus > 1 &&\n+                mtrans.kind != ModuleKind::Allocator;\n+\n+            // If we're a metadata module we never participate in LTO.\n+            //\n+            // If LTO was explicitly requested on the command line, we always\n+            // LTO everything else.\n+            //\n+            // If LTO *wasn't* explicitly requested and we're not a metdata\n+            // module, then we may automatically do ThinLTO if we've got\n+            // multiple codegen units. Note, however, that the allocator module\n+            // doesn't participate here automatically because of linker\n+            // shenanigans later on.\n+            if mtrans.kind == ModuleKind::Metadata || (!lto && !auto_thin_lto) {\n+                let module = codegen(cgcx, &diag_handler, mtrans, config, timeline)?;\n                 Ok(WorkItemResult::Compiled(module))\n             } else {\n                 Ok(WorkItemResult::NeedsLTO(mtrans))\n@@ -1187,12 +1278,13 @@ fn start_executing_work(tcx: TyCtxt,\n                         shared_emitter: SharedEmitter,\n                         trans_worker_send: Sender<Message>,\n                         coordinator_receive: Receiver<Box<Any + Send>>,\n+                        total_cgus: usize,\n                         jobserver: Client,\n                         time_graph: Option<TimeGraph>,\n                         modules_config: Arc<ModuleConfig>,\n                         metadata_config: Arc<ModuleConfig>,\n                         allocator_config: Arc<ModuleConfig>)\n-                        -> thread::JoinHandle<CompiledModules> {\n+                        -> thread::JoinHandle<Result<CompiledModules, ()>> {\n     let coordinator_send = tcx.tx_to_llvm_workers.clone();\n     let mut exported_symbols = FxHashMap();\n     exported_symbols.insert(LOCAL_CRATE, tcx.exported_symbols(LOCAL_CRATE));\n@@ -1229,6 +1321,7 @@ fn start_executing_work(tcx: TyCtxt,\n         crate_types: sess.crate_types.borrow().clone(),\n         each_linked_rlib_for_lto,\n         lto: sess.lto(),\n+        thinlto: sess.opts.debugging_opts.thinlto,\n         no_landing_pads: sess.no_landing_pads(),\n         save_temps: sess.opts.cg.save_temps,\n         opts: Arc::new(sess.opts.clone()),\n@@ -1246,6 +1339,9 @@ fn start_executing_work(tcx: TyCtxt,\n         metadata_module_config: metadata_config,\n         allocator_module_config: allocator_config,\n         tm_factory: target_machine_factory(tcx.sess),\n+        total_cgus,\n+        msvc_imps_needed: msvc_imps_needed(tcx),\n+        target_pointer_width: tcx.sess.target.target.target_pointer_width.clone(),\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen.\n@@ -1638,7 +1734,7 @@ fn start_executing_work(tcx: TyCtxt,\n                 Message::Done { result: Err(()), worker_id: _ } => {\n                     shared_emitter.fatal(\"aborting due to worker thread failure\");\n                     // Exit the coordinator thread\n-                    panic!(\"aborting due to worker thread failure\")\n+                    return Err(())\n                 }\n                 Message::TranslateItem => {\n                     bug!(\"the coordinator should not receive translation requests\")\n@@ -1664,11 +1760,11 @@ fn start_executing_work(tcx: TyCtxt,\n         let compiled_metadata_module = compiled_metadata_module\n             .expect(\"Metadata module not compiled?\");\n \n-        CompiledModules {\n+        Ok(CompiledModules {\n             modules: compiled_modules,\n             metadata_module: compiled_metadata_module,\n             allocator_module: compiled_allocator_module,\n-        }\n+        })\n     });\n \n     // A heuristic that determines if we have enough LLVM WorkItems in the\n@@ -1743,12 +1839,13 @@ fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n         // as a diagnostic was already sent off to the main thread - just\n         // surface that there was an error in this worker.\n         bomb.result = {\n-            let _timing_guard = cgcx.time_graph.as_ref().map(|tg| {\n+            let timeline = cgcx.time_graph.as_ref().map(|tg| {\n                 tg.start(time_graph::TimelineId(cgcx.worker),\n                          LLVM_WORK_PACKAGE_KIND,\n                          &work.name())\n             });\n-            execute_work_item(&cgcx, work).ok()\n+            let mut timeline = timeline.unwrap_or(Timeline::noop());\n+            execute_work_item(&cgcx, work, &mut timeline).ok()\n         };\n     });\n }\n@@ -1788,16 +1885,17 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n \n pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n                             config: &ModuleConfig,\n+                            opt_level: llvm::CodeGenOptLevel,\n                             f: &mut FnMut(llvm::PassManagerBuilderRef)) {\n     // Create the PassManagerBuilder for LLVM. We configure it with\n     // reasonable defaults and prepare it to actually populate the pass\n     // manager.\n     let builder = llvm::LLVMPassManagerBuilderCreate();\n-    let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n     let opt_size = config.opt_size.unwrap_or(llvm::CodeGenOptSizeNone);\n     let inline_threshold = config.inline_threshold;\n \n-    llvm::LLVMRustConfigurePassManagerBuilder(builder, opt_level,\n+    llvm::LLVMRustConfigurePassManagerBuilder(builder,\n+                                              opt_level,\n                                               config.merge_functions,\n                                               config.vectorize_slp,\n                                               config.vectorize_loop);\n@@ -1960,15 +2058,19 @@ pub struct OngoingCrateTranslation {\n     coordinator_send: Sender<Box<Any + Send>>,\n     trans_worker_receive: Receiver<Message>,\n     shared_emitter_main: SharedEmitterMain,\n-    future: thread::JoinHandle<CompiledModules>,\n+    future: thread::JoinHandle<Result<CompiledModules, ()>>,\n     output_filenames: Arc<OutputFilenames>,\n }\n \n impl OngoingCrateTranslation {\n     pub fn join(self, sess: &Session, dep_graph: &DepGraph) -> CrateTranslation {\n         self.shared_emitter_main.check(sess, true);\n         let compiled_modules = match self.future.join() {\n-            Ok(compiled_modules) => compiled_modules,\n+            Ok(Ok(compiled_modules)) => compiled_modules,\n+            Ok(Err(())) => {\n+                sess.abort_if_errors();\n+                panic!(\"expected abort due to worker thread errors\")\n+            },\n             Err(_) => {\n                 sess.fatal(\"Error during translation/LLVM phase.\");\n             }\n@@ -1982,15 +2084,14 @@ impl OngoingCrateTranslation {\n \n         copy_module_artifacts_into_incr_comp_cache(sess,\n                                                    dep_graph,\n-                                                   &compiled_modules,\n-                                                   &self.output_filenames);\n+                                                   &compiled_modules);\n         produce_final_output_artifacts(sess,\n                                        &compiled_modules,\n                                        &self.output_filenames);\n \n         // FIXME: time_llvm_passes support - does this use a global context or\n         // something?\n-        if sess.opts.codegen_units == 1 && sess.time_llvm_passes() {\n+        if sess.codegen_units() == 1 && sess.time_llvm_passes() {\n             unsafe { llvm::LLVMRustPrintPassTimings(); }\n         }\n \n@@ -2004,6 +2105,7 @@ impl OngoingCrateTranslation {\n \n             modules: compiled_modules.modules,\n             allocator_module: compiled_modules.allocator_module,\n+            metadata_module: compiled_modules.metadata_module,\n         };\n \n         if self.no_integrated_as {\n@@ -2073,3 +2175,51 @@ pub fn submit_translated_module_to_llvm(tcx: TyCtxt,\n         cost,\n     })));\n }\n+\n+fn msvc_imps_needed(tcx: TyCtxt) -> bool {\n+    tcx.sess.target.target.options.is_like_msvc &&\n+        tcx.sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib)\n+}\n+\n+// Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n+// This is required to satisfy `dllimport` references to static data in .rlibs\n+// when using MSVC linker.  We do this only for data, as linker can fix up\n+// code references on its own.\n+// See #26591, #27438\n+fn create_msvc_imps(cgcx: &CodegenContext, llcx: ContextRef, llmod: ModuleRef) {\n+    if !cgcx.msvc_imps_needed {\n+        return\n+    }\n+    // The x86 ABI seems to require that leading underscores are added to symbol\n+    // names, so we need an extra underscore on 32-bit. There's also a leading\n+    // '\\x01' here which disables LLVM's symbol mangling (e.g. no extra\n+    // underscores added in front).\n+    let prefix = if cgcx.target_pointer_width == \"32\" {\n+        \"\\x01__imp__\"\n+    } else {\n+        \"\\x01__imp_\"\n+    };\n+    unsafe {\n+        let i8p_ty = Type::i8p_llcx(llcx);\n+        let globals = base::iter_globals(llmod)\n+            .filter(|&val| {\n+                llvm::LLVMRustGetLinkage(val) == llvm::Linkage::ExternalLinkage &&\n+                    llvm::LLVMIsDeclaration(val) == 0\n+            })\n+            .map(move |val| {\n+                let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n+                let mut imp_name = prefix.as_bytes().to_vec();\n+                imp_name.extend(name.to_bytes());\n+                let imp_name = CString::new(imp_name).unwrap();\n+                (imp_name, val)\n+            })\n+            .collect::<Vec<_>>();\n+        for (imp_name, val) in globals {\n+            let imp = llvm::LLVMAddGlobal(llmod,\n+                                          i8p_ty.to_ref(),\n+                                          imp_name.as_ptr() as *const _);\n+            llvm::LLVMSetInitializer(imp, consts::ptrcast(val, i8p_ty));\n+            llvm::LLVMRustSetLinkage(imp, llvm::Linkage::ExternalLinkage);\n+        }\n+    }\n+}"}, {"sha": "547b1f7b2bf9610202c19501771dddb4d9e68e77", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 18, "deletions": 84, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -70,15 +70,15 @@ use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, CodegenUnit, CodegenUnitExt};\n use symbol_names_test;\n use time_graph;\n-use trans_item::{TransItem, TransItemExt, DefPathBasedNames};\n+use trans_item::{TransItem, BaseTransItemExt, TransItemExt, DefPathBasedNames};\n use type_::Type;\n use type_of;\n use value::Value;\n use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet, DefIdSet};\n use CrateInfo;\n \n use std::any::Any;\n-use std::ffi::{CStr, CString};\n+use std::ffi::CString;\n use std::str;\n use std::sync::Arc;\n use std::time::{Instant, Duration};\n@@ -93,6 +93,7 @@ use syntax::ast;\n use mir::lvalue::Alignment;\n \n pub use rustc_trans_utils::{find_exported_symbols, check_for_rustc_errors_attr};\n+pub use rustc_trans_utils::trans_item::linkage_by_name;\n \n pub struct StatRecorder<'a, 'tcx: 'a> {\n     ccx: &'a CrateContext<'a, 'tcx>,\n@@ -618,33 +619,6 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     mir::trans_mir(ccx, lldecl, &mir, instance, sig);\n }\n \n-pub fn linkage_by_name(name: &str) -> Option<Linkage> {\n-    use rustc::middle::trans::Linkage::*;\n-\n-    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n-    // applicable to variable declarations and may not really make sense for\n-    // Rust code in the first place but whitelist them anyway and trust that\n-    // the user knows what s/he's doing. Who knows, unanticipated use cases\n-    // may pop up in the future.\n-    //\n-    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n-    // and don't have to be, LLVM treats them as no-ops.\n-    match name {\n-        \"appending\" => Some(Appending),\n-        \"available_externally\" => Some(AvailableExternally),\n-        \"common\" => Some(Common),\n-        \"extern_weak\" => Some(ExternalWeak),\n-        \"external\" => Some(External),\n-        \"internal\" => Some(Internal),\n-        \"linkonce\" => Some(LinkOnceAny),\n-        \"linkonce_odr\" => Some(LinkOnceODR),\n-        \"private\" => Some(Private),\n-        \"weak\" => Some(WeakAny),\n-        \"weak_odr\" => Some(WeakODR),\n-        _ => None,\n-    }\n-}\n-\n pub fn set_link_section(ccx: &CrateContext,\n                         llval: ValueRef,\n                         attrs: &[ast::Attribute]) {\n@@ -812,47 +786,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     return (metadata_llcx, metadata_llmod, metadata, hashes);\n }\n \n-// Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n-// This is required to satisfy `dllimport` references to static data in .rlibs\n-// when using MSVC linker.  We do this only for data, as linker can fix up\n-// code references on its own.\n-// See #26591, #27438\n-fn create_imps(sess: &Session,\n-               llvm_module: &ModuleLlvm) {\n-    // The x86 ABI seems to require that leading underscores are added to symbol\n-    // names, so we need an extra underscore on 32-bit. There's also a leading\n-    // '\\x01' here which disables LLVM's symbol mangling (e.g. no extra\n-    // underscores added in front).\n-    let prefix = if sess.target.target.target_pointer_width == \"32\" {\n-        \"\\x01__imp__\"\n-    } else {\n-        \"\\x01__imp_\"\n-    };\n-    unsafe {\n-        let exported: Vec<_> = iter_globals(llvm_module.llmod)\n-                                   .filter(|&val| {\n-                                       llvm::LLVMRustGetLinkage(val) ==\n-                                       llvm::Linkage::ExternalLinkage &&\n-                                       llvm::LLVMIsDeclaration(val) == 0\n-                                   })\n-                                   .collect();\n-\n-        let i8p_ty = Type::i8p_llcx(llvm_module.llcx);\n-        for val in exported {\n-            let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-            let mut imp_name = prefix.as_bytes().to_vec();\n-            imp_name.extend(name.to_bytes());\n-            let imp_name = CString::new(imp_name).unwrap();\n-            let imp = llvm::LLVMAddGlobal(llvm_module.llmod,\n-                                          i8p_ty.to_ref(),\n-                                          imp_name.as_ptr() as *const _);\n-            llvm::LLVMSetInitializer(imp, consts::ptrcast(val, i8p_ty));\n-            llvm::LLVMRustSetLinkage(imp, llvm::Linkage::ExternalLinkage);\n-        }\n-    }\n-}\n-\n-struct ValueIter {\n+pub struct ValueIter {\n     cur: ValueRef,\n     step: unsafe extern \"C\" fn(ValueRef) -> ValueRef,\n }\n@@ -871,7 +805,7 @@ impl Iterator for ValueIter {\n     }\n }\n \n-fn iter_globals(llmod: llvm::ModuleRef) -> ValueIter {\n+pub fn iter_globals(llmod: llvm::ModuleRef) -> ValueIter {\n     unsafe {\n         ValueIter {\n             cur: llvm::LLVMGetFirstGlobal(llmod),\n@@ -886,6 +820,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     check_for_rustc_errors_attr(tcx);\n \n+    if tcx.sess.opts.debugging_opts.thinlto {\n+        if unsafe { !llvm::LLVMRustThinLTOAvailable() } {\n+            tcx.sess.fatal(\"this compiler's LLVM does not support ThinLTO\");\n+        }\n+    }\n \n     let crate_hash = tcx.dep_graph\n                         .fingerprint_of(&DepNode::new_no_params(DepKind::Krate));\n@@ -925,7 +864,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             time_graph.clone(),\n             link_meta,\n             metadata,\n-            rx);\n+            rx,\n+            1);\n \n         ongoing_translation.submit_pre_translated_module_to_llvm(tcx, metadata_module);\n         ongoing_translation.translation_finished(tcx);\n@@ -961,7 +901,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         time_graph.clone(),\n         link_meta,\n         metadata,\n-        rx);\n+        rx,\n+        codegen_units.len());\n \n     // Translate an allocator shim, if any\n     let allocator_module = if let Some(kind) = tcx.sess.allocator_kind.get() {\n@@ -1211,7 +1152,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n     let strategy = if tcx.sess.opts.debugging_opts.incremental.is_some() {\n         PartitioningStrategy::PerModule\n     } else {\n-        PartitioningStrategy::FixedUnitCount(tcx.sess.opts.codegen_units)\n+        PartitioningStrategy::FixedUnitCount(tcx.sess.codegen_units())\n     };\n \n     let codegen_units = time(time_passes, \"codegen unit partitioning\", || {\n@@ -1224,9 +1165,6 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n             .collect::<Vec<_>>()\n     });\n \n-    assert!(tcx.sess.opts.codegen_units == codegen_units.len() ||\n-            tcx.sess.opts.debugging_opts.incremental.is_some());\n-\n     let translation_items: DefIdSet = items.iter().filter_map(|trans_item| {\n         match *trans_item {\n             TransItem::Fn(ref instance) => Some(instance.def_id()),\n@@ -1372,7 +1310,9 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // crashes if the module identifier is same as other symbols\n         // such as a function name in the module.\n         // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-        let llmod_id = format!(\"{}.rs\", cgu.name());\n+        let llmod_id = format!(\"{}-{}.rs\",\n+                               cgu.name(),\n+                               tcx.crate_disambiguator(LOCAL_CRATE));\n \n         // Instantiate translation items without filling out definitions yet...\n         let scx = SharedCrateContext::new(tcx);\n@@ -1431,12 +1371,6 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 tm: create_target_machine(ccx.sess()),\n             };\n \n-            // Adjust exported symbols for MSVC dllimport\n-            if ccx.sess().target.target.options.is_like_msvc &&\n-               ccx.sess().crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n-                create_imps(ccx.sess(), &llvm_module);\n-            }\n-\n             ModuleTranslation {\n                 name: cgu_name,\n                 source: ModuleSource::Translated(llvm_module),"}, {"sha": "b515c9420bf36d18812dad1c4208b88bad65ecbb", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -24,6 +24,7 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TypeFoldable};\n use rustc::traits;\n use rustc::ty::subst::Substs;\n+use rustc_back::PanicStrategy;\n use type_of;\n \n /// Translates a reference to a fn/method item, monomorphizing and\n@@ -105,8 +106,10 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // *in Rust code* may unwind. Foreign items like `extern \"C\" {\n         // fn foo(); }` are assumed not to unwind **unless** they have\n         // a `#[unwind]` attribute.\n-        if !tcx.is_foreign_item(instance_def_id) {\n-            attributes::unwind(llfn, true);\n+        if tcx.sess.panic_strategy() == PanicStrategy::Unwind {\n+            if !tcx.is_foreign_item(instance_def_id) {\n+                attributes::unwind(llfn, true);\n+            }\n         }\n \n         // Apply an appropriate linkage/visibility value to our item that we"}, {"sha": "e3856cabcf910c77b3123462928f5040d34f150d", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -36,7 +36,6 @@ use libc::{c_uint, c_char};\n use std::iter;\n \n use syntax::abi::Abi;\n-use syntax::attr;\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -552,22 +551,6 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn requests_inline<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    instance: &ty::Instance<'tcx>\n-) -> bool {\n-    if is_inline_instance(tcx, instance) {\n-        return true\n-    }\n-    if let ty::InstanceDef::DropGlue(..) = instance.def {\n-        // Drop glue wants to be instantiated at every translation\n-        // unit, but without an #[inline] hint. We should make this\n-        // available to normal end-users.\n-        return true\n-    }\n-    attr::requests_inline(&instance.def.attrs(tcx)[..])\n-}\n-\n pub fn is_inline_instance<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: &ty::Instance<'tcx>"}, {"sha": "6fd24c1786c6971bbea09af0216ce3f4fddeb7ce", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -642,7 +642,7 @@ impl<'a, 'tcx> LayoutTyper<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n     }\n \n     fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.tcx().normalize_associated_type(&ty)\n+        self.tcx().fully_normalize_associated_types_in(&ty)\n     }\n }\n "}, {"sha": "3bde78e2c6a6075209aca3a3ea7b800c42d55b5d", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -30,7 +30,7 @@ use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n use rustc::ty::util::TypeIdHasher;\n use rustc::hir;\n-use rustc_data_structures::ToHex;\n+use rustc::ich::Fingerprint;\n use {type_of, machine, monomorphize};\n use common::{self, CrateContext};\n use type_::Type;\n@@ -146,11 +146,10 @@ impl<'tcx> TypeMap<'tcx> {\n \n         // The hasher we are using to generate the UniqueTypeId. We want\n         // something that provides more than the 64 bits of the DefaultHasher.\n-\n-        let mut type_id_hasher = TypeIdHasher::<[u8; 20]>::new(cx.tcx());\n+        let mut type_id_hasher = TypeIdHasher::<Fingerprint>::new(cx.tcx());\n         type_id_hasher.visit_ty(type_);\n-\n         let unique_type_id = type_id_hasher.finish().to_hex();\n+\n         let key = self.unique_id_interner.intern(&unique_type_id);\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n@@ -583,7 +582,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         ty::TyGenerator(def_id, substs, _) => {\n             let upvar_tys : Vec<_> = substs.field_tys(def_id, cx.tcx()).map(|t| {\n-                cx.tcx().normalize_associated_type(&t)\n+                cx.tcx().fully_normalize_associated_types_in(&t)\n             }).collect();\n             prepare_tuple_metadata(cx,\n                                    t,"}, {"sha": "1a2842920161888064f6ca04b241739ca9513836", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -376,7 +376,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 name_to_append_suffix_to.push_str(\",\");\n             }\n \n-            let actual_type = cx.tcx().normalize_associated_type(&actual_type);\n+            let actual_type = cx.tcx().fully_normalize_associated_types_in(&actual_type);\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n@@ -389,7 +389,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let template_params: Vec<_> = if cx.sess().opts.debuginfo == FullDebugInfo {\n             let names = get_type_parameter_names(cx, generics);\n             substs.types().zip(names).map(|(ty, name)| {\n-                let actual_type = cx.tcx().normalize_associated_type(&ty);\n+                let actual_type = cx.tcx().fully_normalize_associated_types_in(&ty);\n                 let actual_type_metadata = type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n                 let name = CString::new(name.as_str().as_bytes()).unwrap();\n                 unsafe {"}, {"sha": "f894bdf16e4de28c4c3233f622444aafda2882d2", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "patch": "@@ -24,6 +24,7 @@ use llvm::{self, ValueRef};\n use llvm::AttributePlace::Function;\n use rustc::ty::Ty;\n use rustc::session::config::Sanitizer;\n+use rustc_back::PanicStrategy;\n use abi::{Abi, FnType};\n use attributes;\n use context::CrateContext;\n@@ -98,6 +99,10 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n         _ => {},\n     }\n \n+    if ccx.tcx().sess.panic_strategy() != PanicStrategy::Unwind {\n+        attributes::unwind(llfn, false);\n+    }\n+\n     llfn\n }\n "}, {"sha": "93f2eef76d18d9c3d60fdcff97c5fca1420102b9", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "4fe726364f227bc2e5d1e3ccd02b2c1142476b5e", "filename": "src/librustc_trans/llvm_util.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "3253a0339a850ec209451c5ae0e2f4d9cdbd6356", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "d5d44bfa7ba43038169add3e7f9c33ba4d4aafbc", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "6980ba8a52505f9ccfa0f3366095c5b4c1f0e2c8", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 78, "deletions": 72, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "a8502682a806b718f93c6e5b7c9943d86cba759a", "filename": "src/librustc_trans/time_graph.rs", "status": "modified", "additions": 123, "deletions": 29, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Ftime_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Ftime_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftime_graph.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "db1af8cdefbe93596f439d808d1da31bc0853cf4", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 6, "deletions": 366, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "7d9d7cea9335da6b38a69edbe4f962f6a5535c41", "filename": "src/librustc_trans_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2FCargo.toml?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "c87d86262efdd7ece7721b91b3cced3b693d53ef", "filename": "src/librustc_trans_utils/collector.rs", "status": "renamed", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans_utils%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans_utils%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fcollector.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "previous_filename": "src/librustc_trans/collector.rs"}, {"sha": "634e37220e2f175d4fa89ac06c83accd6c575894", "filename": "src/librustc_trans_utils/common.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans_utils%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans_utils%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fcommon.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "bc8f8d5a6da2dc6a0642f70b4c2f0ff8e86c7a18", "filename": "src/librustc_trans_utils/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "ab61dacf010ae1f51637f15453ebbf0a5b023095", "filename": "src/librustc_trans_utils/monomorphize.rs", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans_utils%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans_utils%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fmonomorphize.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251", "previous_filename": "src/librustc_trans/monomorphize.rs"}, {"sha": "0ada39d7d27116114cd4b67acf2055cdd486066f", "filename": "src/librustc_trans_utils/trans_item.rs", "status": "added", "additions": 464, "deletions": 0, "changes": 464, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans_utils%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_trans_utils%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_item.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "7c9497badfbea9925b6f3f450457e8d8bcbada11", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "91ce4511a31cb3fe386a403ac4096db1ac56f9b5", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "554a858bcc17342f4d67f63383e702cd1f0dc87d", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "58d72e37d51cfb1c0b48b11cdb8a190ad01c932d", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "78941cb3a56868b2b1f96caabde6b6deac49ae12", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "23148406a111ecb62d6a3e953e71489a68d6c7e1", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "c82cafd3a62ed1838cf4abe2ae042b6e7210fbc3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "ad7978480a6b1b44ccb99b0fcb127aa4d554453b", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "ce2ac73a27e0cb8b6f25fd031483c26e12bb8b51", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "b867a655b4a6a30e36d256441e662be1b5c96d37", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "1355f711a4b14f5da51448743877b224d5c743e5", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "68ba1b4c44c81f61b35a6d6be0c3b0f478711d11", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 39, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "594cd0878cbfbc62144d3aabfed38bf24350174c", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "49ba0499f7868bcf7268a57b343ee8f9b964de26", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "6f0e46b3afee11ba60c5445fd7e19726f6939d6d", "filename": "src/librustc_typeck/namespace.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fnamespace.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "1127028cbc8c7c052867a20667b29d3791480cb9", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "196e66054946389f672dbffeb4d60b30d3ec82aa", "filename": "src/librustc_typeck/outlives/test.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "e168222058f9a32b290d1424ede8c3cb376051a3", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "e3ce403f3c17baa60ded8e1321678f41de939a30", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "4e8bf5f91092bef3142886b267d4bf0b2ab607d0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "2f7bd5e39a14927aad28c8988b82ae497e66680f", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "18d6b1cc1e0f06fd26c248b2a87b47ab59d3c55d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "79eaabe31e86b4698a10da1ee0fa1ecdd91fed9a", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "d538428a7e9a96be8ed54f0405894dab69c4dc6f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 77, "deletions": 40, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "04bf466a7804dee5fb53479542a07a2e477afe58", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 212, "deletions": 45, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "18270654aa93c5f7ee67e36031012ef1a01d90c6", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "4a4ca15170a4655d08acc4c7f205219a522fe3aa", "filename": "src/librustdoc/html/static/styles/main.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "20da99a6b137658acaec97ef85359666abe58db8", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "fe6bd985bb6181fc5c65f8eaf22a2746d7458fbe", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "8b2c8d2da395a1f87074507b17e8cb2118d04e49", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "5dd5f8953a00e143b7f130e1773327aa6fbd23ed", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "327deb9b419bee6c93ead3b6bf3554c152dfaace", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "0e6214ea04fc0a20a939fae3b739f44b2b6913a4", "filename": "src/libstd/build.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "d96a4f40d3f8ea0475582b7b9a6cca19afbc1926", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "7e623a0af17c3c1bab2db1c7948cb2b5f3974aad", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "b54603919427c33bb812fa4f56e55061cf05a001", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 186, "deletions": 65, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "a75596351e4cf3ec073fa809c29847b2e179969e", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "8c34660f821b71b45c20406adf5a4f7a47c1994d", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "fe1179a3b4a18ba56950ce8dab415970b9a801c5", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "83cc9ce582e34b15d3377518b153d6ae343f904d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "6318e2e40875faef5807eaacf1261fd62fb4341a", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "539ff1df1876f052bb00188edce8504c289e52e3", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 84, "deletions": 10, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "870d11298fe3bf6be136277a1b7ad6bbdd562340", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "122f15d1d4c4feed68c29b5af7d1c6bcf7c7079f", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "3e0fb44b01e30bd9719b61d9672ef9806deffcea", "filename": "src/libstd/os/nacl/fs.rs", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04/src%2Flibstd%2Fos%2Fnacl%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04/src%2Flibstd%2Fos%2Fnacl%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fnacl%2Ffs.rs?ref=69ba6738eb6bf9b6d11ebb81af2599648eb0bc04"}, {"sha": "3c3d4410a2a16bc89dc93499fb10eff32d5da164", "filename": "src/libstd/os/nacl/raw.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04/src%2Flibstd%2Fos%2Fnacl%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69ba6738eb6bf9b6d11ebb81af2599648eb0bc04/src%2Flibstd%2Fos%2Fnacl%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fnacl%2Fraw.rs?ref=69ba6738eb6bf9b6d11ebb81af2599648eb0bc04"}, {"sha": "9e1da318242bc550c9939102c59f4e7c548f09c7", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "7c107177c64cd67a83beb6a3b35274183a9be1b0", "filename": "src/libstd/process.rs", "status": "modified", "additions": 137, "deletions": 5, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "5af01262573f3b93133abadf5c5293f2d4ffa198", "filename": "src/libstd/sync/mpsc/cache_aligned.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Fmpsc%2Fcache_aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Fmpsc%2Fcache_aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fcache_aligned.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "45a26e594b0654740d8426d89f20a3364498b59c", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "a9f3cea243f366c61e0abf759c474c95a00581ae", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "cc4be92276a3b2c3ac4943c00904f77164222d2c", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 90, "deletions": 63, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "d1515eba68c3eea8ffbf88af03db9661614134e5", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 61, "deletions": 44, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "eb507858b92b23f5bd8dd76f88add49e76a4650d", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "30dbf02087d314cbda787d676e05fb8cab103e40", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 81, "deletions": 13, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "5c49d6b58459ccb76988a2680372ee7ae826602a", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "4f878d8ad1fa84beccfa75343d1bc5872a0d8fd6", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "00cf7eca75dc3eaf8148896027e938d621fd85a4", "filename": "src/libstd/sys/unix/env.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fenv.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}, {"sha": "a1ca839dc18722158e5f6276a7c1238a89264c5b", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca47e42b2c878eafb109c59cf0c8074043c1251/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=bca47e42b2c878eafb109c59cf0c8074043c1251"}]}