{"sha": "f33539e446d6f41d4a3296ed50a8f968e7950483", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMzUzOWU0NDZkNmY0MWQ0YTMyOTZlZDUwYThmOTY4ZTc5NTA0ODM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-03T19:21:48Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-03T21:05:51Z"}, "message": "Remove uses of + mode from libstd\n\nMore or less the same as my analogous commit for libcore. Had\nto remove the forbid(deprecated_modes) pragma from some files -- will\nrestore it after the snapshot.", "tree": {"sha": "d2063ef25015d1c906f4f15cd2d46ab89c6a1db2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2063ef25015d1c906f4f15cd2d46ab89c6a1db2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f33539e446d6f41d4a3296ed50a8f968e7950483", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f33539e446d6f41d4a3296ed50a8f968e7950483", "html_url": "https://github.com/rust-lang/rust/commit/f33539e446d6f41d4a3296ed50a8f968e7950483", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f33539e446d6f41d4a3296ed50a8f968e7950483/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "654b4d6987223752155b58804255a373d3410a96", "url": "https://api.github.com/repos/rust-lang/rust/commits/654b4d6987223752155b58804255a373d3410a96", "html_url": "https://github.com/rust-lang/rust/commit/654b4d6987223752155b58804255a373d3410a96"}], "stats": {"total": 228, "additions": 113, "deletions": 115}, "files": [{"sha": "60db62ce01ae2a59df60d019469a379bbdaa871f", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: forbid deprecated modes again after snap\n /**\n  * Concurrency-enabled mechanisms for sharing mutable and/or immutable state\n  * between tasks.\n@@ -66,7 +66,7 @@ impl &Condvar {\n struct ARC<T: Const Send> { x: SharedMutableState<T> }\n \n /// Create an atomically reference counted wrapper.\n-pub fn ARC<T: Const Send>(+data: T) -> ARC<T> {\n+pub fn ARC<T: Const Send>(data: T) -> ARC<T> {\n     ARC { x: unsafe { shared_mutable_state(move data) } }\n }\n \n@@ -98,7 +98,7 @@ pub fn clone<T: Const Send>(rc: &ARC<T>) -> ARC<T> {\n  * unwrap from a task that holds another reference to the same ARC; it is\n  * guaranteed to deadlock.\n  */\n-fn unwrap<T: Const Send>(+rc: ARC<T>) -> T {\n+fn unwrap<T: Const Send>(rc: ARC<T>) -> T {\n     let ARC { x: x } <- rc;\n     unsafe { unwrap_shared_mutable_state(move x) }\n }\n@@ -113,14 +113,14 @@ struct MutexARCInner<T: Send> { lock: Mutex, failed: bool, data: T }\n struct MutexARC<T: Send> { x: SharedMutableState<MutexARCInner<T>> }\n \n /// Create a mutex-protected ARC with the supplied data.\n-pub fn MutexARC<T: Send>(+user_data: T) -> MutexARC<T> {\n+pub fn MutexARC<T: Send>(user_data: T) -> MutexARC<T> {\n     mutex_arc_with_condvars(move user_data, 1)\n }\n /**\n  * Create a mutex-protected ARC with the supplied data and a specified number\n  * of condvars (as sync::mutex_with_condvars).\n  */\n-pub fn mutex_arc_with_condvars<T: Send>(+user_data: T,\n+pub fn mutex_arc_with_condvars<T: Send>(user_data: T,\n                                     num_condvars: uint) -> MutexARC<T> {\n     let data =\n         MutexARCInner { lock: mutex_with_condvars(num_condvars),\n@@ -191,7 +191,7 @@ impl<T: Send> &MutexARC<T> {\n  * Will additionally fail if another task has failed while accessing the arc.\n  */\n // FIXME(#2585) make this a by-move method on the arc\n-pub fn unwrap_mutex_arc<T: Send>(+arc: MutexARC<T>) -> T {\n+pub fn unwrap_mutex_arc<T: Send>(arc: MutexARC<T>) -> T {\n     let MutexARC { x: x } <- arc;\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n     let MutexARCInner { failed: failed, data: data, _ } <- inner;\n@@ -247,14 +247,14 @@ struct RWARC<T: Const Send> {\n }\n \n /// Create a reader/writer ARC with the supplied data.\n-pub fn RWARC<T: Const Send>(+user_data: T) -> RWARC<T> {\n+pub fn RWARC<T: Const Send>(user_data: T) -> RWARC<T> {\n     rw_arc_with_condvars(move user_data, 1)\n }\n /**\n  * Create a reader/writer ARC with the supplied data and a specified number\n  * of condvars (as sync::rwlock_with_condvars).\n  */\n-pub fn rw_arc_with_condvars<T: Const Send>(+user_data: T,\n+pub fn rw_arc_with_condvars<T: Const Send>(user_data: T,\n                                        num_condvars: uint) -> RWARC<T> {\n     let data =\n         RWARCInner { lock: rwlock_with_condvars(num_condvars),\n@@ -334,7 +334,7 @@ impl<T: Const Send> &RWARC<T> {\n      * }\n      * ~~~\n      */\n-    fn write_downgrade<U>(blk: fn(+v: RWWriteMode<T>) -> U) -> U {\n+    fn write_downgrade<U>(blk: fn(v: RWWriteMode<T>) -> U) -> U {\n         let state = unsafe { get_shared_mutable_state(&self.x) };\n         do borrow_rwlock(state).write_downgrade |write_mode| {\n             check_poison(false, state.failed);\n@@ -344,7 +344,7 @@ impl<T: Const Send> &RWARC<T> {\n     }\n \n     /// To be called inside of the write_downgrade block.\n-    fn downgrade(+token: RWWriteMode/&a<T>) -> RWReadMode/&a<T> {\n+    fn downgrade(token: RWWriteMode/&a<T>) -> RWReadMode/&a<T> {\n         // The rwlock should assert that the token belongs to us for us.\n         let state = unsafe { get_shared_immutable_state(&self.x) };\n         let RWWriteMode((data, t, _poison)) <- token;\n@@ -369,7 +369,7 @@ impl<T: Const Send> &RWARC<T> {\n  * in write mode.\n  */\n // FIXME(#2585) make this a by-move method on the arc\n-pub fn unwrap_rw_arc<T: Const Send>(+arc: RWARC<T>) -> T {\n+pub fn unwrap_rw_arc<T: Const Send>(arc: RWARC<T>) -> T {\n     let RWARC { x: x, _ } <- arc;\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n     let RWARCInner { failed: failed, data: data, _ } <- inner;"}, {"sha": "77f0d39c338e92ce969cde563cf1a51b21938a15", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -1,4 +1,4 @@\n-#[forbid(deprecated_mode)];\n+// tjc: forbid deprecated modes again after snap\n \n use vec::{to_mut, from_elem};\n \n@@ -95,7 +95,7 @@ struct BigBitv {\n     mut storage: ~[mut uint]\n }\n \n-fn BigBitv(+storage: ~[mut uint]) -> BigBitv {\n+fn BigBitv(storage: ~[mut uint]) -> BigBitv {\n     BigBitv {storage: storage}\n }\n "}, {"sha": "866dbce1c08591268b2178d3f6a747f26226e6d8", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -1,4 +1,4 @@\n-#[forbid(deprecated_mode)];\n+// tjc: forbid deprecated modes again after snap\n /// A dynamic, mutable location.\n ///\n /// Similar to a mutable option type, but friendlier.\n@@ -8,7 +8,7 @@ pub struct Cell<T> {\n }\n \n /// Creates a new full cell with the given value.\n-pub fn Cell<T>(+value: T) -> Cell<T> {\n+pub fn Cell<T>(value: T) -> Cell<T> {\n     Cell { value: Some(move value) }\n }\n \n@@ -29,7 +29,7 @@ impl<T> Cell<T> {\n     }\n \n     /// Returns the value, failing if the cell is full.\n-    fn put_back(+value: T) {\n+    fn put_back(value: T) {\n         if !self.is_empty() {\n             fail ~\"attempt to put a value back into a full cell\";\n         }"}, {"sha": "f85d4655ad14bdb3f802e0f90156c5941318710c", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -1,4 +1,4 @@\n-#[forbid(deprecated_mode)];\n+// tjc: forbid deprecated modes again after snap\n //! Unsafe debugging functions for inspecting values.\n \n use cast::reinterpret_cast;\n@@ -20,19 +20,19 @@ pub fn debug_tydesc<T>() {\n     rustrt::debug_tydesc(sys::get_type_desc::<T>());\n }\n \n-pub fn debug_opaque<T>(+x: T) {\n+pub fn debug_opaque<T>(x: T) {\n     rustrt::debug_opaque(sys::get_type_desc::<T>(), ptr::addr_of(&x) as *());\n }\n \n pub fn debug_box<T>(x: @T) {\n     rustrt::debug_box(sys::get_type_desc::<T>(), ptr::addr_of(&x) as *());\n }\n \n-pub fn debug_tag<T>(+x: T) {\n+pub fn debug_tag<T>(x: T) {\n     rustrt::debug_tag(sys::get_type_desc::<T>(), ptr::addr_of(&x) as *());\n }\n \n-pub fn debug_fn<T>(+x: T) {\n+pub fn debug_fn<T>(x: T) {\n     rustrt::debug_fn(sys::get_type_desc::<T>(), ptr::addr_of(&x) as *());\n }\n "}, {"sha": "f4fbc11c4f715dc75f4d56b288f4b4ba678b12ab", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -1,5 +1,5 @@\n //! A deque. Untested as of yet. Likely buggy\n-#[forbid(deprecated_mode)];\n+// tjc: forbid deprecated modes again after snap\n #[forbid(non_camel_case_types)];\n \n use option::{Some, None};\n@@ -8,8 +8,8 @@ use core::cmp::{Eq};\n \n pub trait Deque<T> {\n     fn size() -> uint;\n-    fn add_front(+v: T);\n-    fn add_back(+v: T);\n+    fn add_front(v: T);\n+    fn add_back(v: T);\n     fn pop_front() -> T;\n     fn pop_back() -> T;\n     fn peek_front() -> T;\n@@ -27,7 +27,7 @@ pub fn create<T: Copy>() -> Deque<T> {\n       * Grow is only called on full elts, so nelts is also len(elts), unlike\n       * elsewhere.\n       */\n-    fn grow<T: Copy>(nelts: uint, lo: uint, +elts: ~[Cell<T>])\n+    fn grow<T: Copy>(nelts: uint, lo: uint, elts: ~[Cell<T>])\n       -> ~[Cell<T>] {\n         let mut elts = move elts;\n         assert (nelts == vec::len(elts));\n@@ -55,7 +55,7 @@ pub fn create<T: Copy>() -> Deque<T> {\n \n     impl <T: Copy> Repr<T>: Deque<T> {\n         fn size() -> uint { return self.nelts; }\n-        fn add_front(+t: T) {\n+        fn add_front(t: T) {\n             let oldlo: uint = self.lo;\n             if self.lo == 0u {\n                 self.lo = self.elts.len() - 1u;\n@@ -68,7 +68,7 @@ pub fn create<T: Copy>() -> Deque<T> {\n             self.elts.set_elt(self.lo, Some(t));\n             self.nelts += 1u;\n         }\n-        fn add_back(+t: T) {\n+        fn add_back(t: T) {\n             if self.lo == self.hi && self.nelts != 0u {\n                 self.elts.swap(|v| grow(self.nelts, self.lo, move v));\n                 self.lo = 0u;\n@@ -200,7 +200,7 @@ mod tests {\n         assert (deq.get(3) == d);\n     }\n \n-    fn test_parameterized<T: Copy Eq Owned>(+a: T, +b: T, +c: T, +d: T) {\n+    fn test_parameterized<T: Copy Eq Owned>(a: T, +b: T, +c: T, +d: T) {\n         let deq: deque::Deque<T> = deque::create::<T>();\n         assert (deq.size() == 0u);\n         deq.add_front(a);"}, {"sha": "8fd775c4773ff65e17b042c08ce0f3d03485e27d", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -62,7 +62,7 @@\n  *     }\n  */\n \n-#[forbid(deprecated_mode)];\n+// tjc: forbid deprecated modes again after snap\n \n use core::cmp::Eq;\n use core::result::{Err, Ok};\n@@ -179,7 +179,7 @@ pub enum Fail_ {\n }\n \n /// Convert a `fail_` enum into an error string\n-pub fn fail_str(+f: Fail_) -> ~str {\n+pub fn fail_str(f: Fail_) -> ~str {\n     return match f {\n         ArgumentMissing(ref nm) => {\n             ~\"Argument to option '\" + *nm + ~\"' missing.\"\n@@ -335,7 +335,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n                free: free});\n }\n \n-fn opt_vals(+mm: Matches, nm: &str) -> ~[Optval] {\n+fn opt_vals(mm: Matches, nm: &str) -> ~[Optval] {\n     return match find_opt(mm.opts, mkname(nm)) {\n       Some(id) => mm.vals[id],\n       None => {\n@@ -345,15 +345,15 @@ fn opt_vals(+mm: Matches, nm: &str) -> ~[Optval] {\n     };\n }\n \n-fn opt_val(+mm: Matches, nm: &str) -> Optval { return opt_vals(mm, nm)[0]; }\n+fn opt_val(mm: Matches, nm: &str) -> Optval { return opt_vals(mm, nm)[0]; }\n \n /// Returns true if an option was matched\n-pub fn opt_present(+mm: Matches, nm: &str) -> bool {\n+pub fn opt_present(mm: Matches, nm: &str) -> bool {\n     return vec::len::<Optval>(opt_vals(mm, nm)) > 0u;\n }\n \n /// Returns true if any of several options were matched\n-pub fn opts_present(+mm: Matches, names: &[~str]) -> bool {\n+pub fn opts_present(mm: Matches, names: &[~str]) -> bool {\n     for vec::each(names) |nm| {\n         match find_opt(mm.opts, mkname(*nm)) {\n           Some(_) => return true,\n@@ -370,7 +370,7 @@ pub fn opts_present(+mm: Matches, names: &[~str]) -> bool {\n  * Fails if the option was not matched or if the match did not take an\n  * argument\n  */\n-pub fn opt_str(+mm: Matches, nm: &str) -> ~str {\n+pub fn opt_str(mm: Matches, nm: &str) -> ~str {\n     return match opt_val(mm, nm) { Val(copy s) => s, _ => fail };\n }\n \n@@ -380,7 +380,8 @@ pub fn opt_str(+mm: Matches, nm: &str) -> ~str {\n  * Fails if the no option was provided from the given list, or if the no such\n  * option took an argument\n  */\n-pub fn opts_str(+mm: Matches, names: &[~str]) -> ~str {\n+pub fn opts_str(mm: Matches, names: &[~str]) -> ~str {\n+>>>>>>> Remove uses of + mode from libstd\n     for vec::each(names) |nm| {\n         match opt_val(mm, *nm) {\n           Val(copy s) => return s,\n@@ -397,7 +398,7 @@ pub fn opts_str(+mm: Matches, names: &[~str]) -> ~str {\n  *\n  * Used when an option accepts multiple values.\n  */\n-pub fn opt_strs(+mm: Matches, nm: &str) -> ~[~str] {\n+pub fn opt_strs(mm: Matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n     for vec::each(opt_vals(mm, nm)) |v| {\n         match *v { Val(copy s) => acc.push(s), _ => () }\n@@ -406,7 +407,7 @@ pub fn opt_strs(+mm: Matches, nm: &str) -> ~[~str] {\n }\n \n /// Returns the string argument supplied to a matching option or none\n-pub fn opt_maybe_str(+mm: Matches, nm: &str) -> Option<~str> {\n+pub fn opt_maybe_str(mm: Matches, nm: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n     if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n     return match vals[0] {\n@@ -423,7 +424,7 @@ pub fn opt_maybe_str(+mm: Matches, nm: &str) -> Option<~str> {\n  * present but no argument was provided, and the argument if the option was\n  * present and an argument was provided.\n  */\n-pub fn opt_default(+mm: Matches, nm: &str, def: &str) -> Option<~str> {\n+pub fn opt_default(mm: Matches, nm: &str, def: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n     if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n     return match vals[0] { Val(copy s) => Some::<~str>(s),\n@@ -451,7 +452,7 @@ mod tests {\n     use opt = getopts;\n     use result::{Err, Ok};\n \n-    fn check_fail_type(+f: Fail_, ft: FailType) {\n+    fn check_fail_type(f: Fail_, ft: FailType) {\n         match f {\n           ArgumentMissing(_) => assert ft == ArgumentMissing_,\n           UnrecognizedOption(_) => assert ft == UnrecognizedOption_,"}, {"sha": "f244f2869a60e9421b68f62ed2dbd441ab5d9633", "filename": "src/libstd/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -1,6 +1,6 @@\n // Rust JSON serialization library\n // Copyright (c) 2011 Google Inc.\n-#[forbid(deprecated_mode)];\n+// tjc: forbid deprecated modes again after snap\n #[forbid(non_camel_case_types)];\n \n //! json serialization\n@@ -370,7 +370,7 @@ priv impl Parser {\n         self.ch\n     }\n \n-    fn error<T>(+msg: ~str) -> Result<T, Error> {\n+    fn error<T>(msg: ~str) -> Result<T, Error> {\n         Err(Error { line: self.line, col: self.col, msg: @msg })\n     }\n "}, {"sha": "4ff493f5ab9101763bc8ef1b903d7404684086c9", "filename": "src/libstd/list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -29,7 +29,7 @@ pub fn from_vec<T: Copy>(v: &[T]) -> @List<T> {\n  * * z - The initial value\n  * * f - The function to apply\n  */\n-pub fn foldl<T: Copy, U>(+z: T, ls: @List<U>, f: fn((&T), (&U)) -> T) -> T {\n+pub fn foldl<T: Copy, U>(z: T, ls: @List<U>, f: fn((&T), (&U)) -> T) -> T {\n     let mut accum: T = z;\n     do iter(ls) |elt| { accum = f(&accum, elt);}\n     accum"}, {"sha": "cc42c5623762911355c7c50674a3b231a8c21698", "filename": "src/libstd/map.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -1,6 +1,6 @@\n //! A map type\n \n-#[forbid(deprecated_mode)];\n+// tjc: forbid deprecated modes again after snap\n \n use io::WriterUtil;\n use to_str::ToStr;\n@@ -28,10 +28,10 @@ pub trait Map<K:Eq IterBytes Hash Copy, V: Copy> {\n      *\n      * Returns true if the key did not already exist in the map\n      */\n-    fn insert(+v: K, +v: V) -> bool;\n+    fn insert(v: K, +v: V) -> bool;\n \n     /// Returns true if the map contains a value for the specified key\n-    fn contains_key(+key: K) -> bool;\n+    fn contains_key(key: K) -> bool;\n \n     /// Returns true if the map contains a value for the specified\n     /// key, taking the key by reference.\n@@ -41,31 +41,31 @@ pub trait Map<K:Eq IterBytes Hash Copy, V: Copy> {\n      * Get the value for the specified key. Fails if the key does not exist in\n      * the map.\n      */\n-    fn get(+key: K) -> V;\n+    fn get(key: K) -> V;\n \n     /**\n      * Get the value for the specified key. If the key does not exist in\n      * the map then returns none.\n      */\n-    pure fn find(+key: K) -> Option<V>;\n+    pure fn find(key: K) -> Option<V>;\n \n     /**\n      * Remove and return a value from the map. Returns true if the\n      * key was present in the map, otherwise false.\n      */\n-    fn remove(+key: K) -> bool;\n+    fn remove(key: K) -> bool;\n \n     /// Clear the map, removing all key/value pairs.\n     fn clear();\n \n     /// Iterate over all the key/value pairs in the map by value\n-    pure fn each(fn(+key: K, +value: V) -> bool);\n+    pure fn each(fn(key: K, +value: V) -> bool);\n \n     /// Iterate over all the keys in the map by value\n-    pure fn each_key(fn(+key: K) -> bool);\n+    pure fn each_key(fn(key: K) -> bool);\n \n     /// Iterate over all the values in the map by value\n-    pure fn each_value(fn(+value: V) -> bool);\n+    pure fn each_value(fn(value: V) -> bool);\n \n     /// Iterate over all the key/value pairs in the map by reference\n     pure fn each_ref(fn(key: &K, value: &V) -> bool);\n@@ -201,7 +201,7 @@ pub mod chained {\n     impl<K:Eq IterBytes Hash Copy, V: Copy> T<K, V>: Map<K, V> {\n         pure fn size() -> uint { self.count }\n \n-        fn contains_key(+k: K) -> bool {\n+        fn contains_key(k: K) -> bool {\n             self.contains_key_ref(&k)\n         }\n \n@@ -213,7 +213,7 @@ pub mod chained {\n             }\n         }\n \n-        fn insert(+k: K, +v: V) -> bool {\n+        fn insert(k: K, +v: V) -> bool {\n             let hash = k.hash_keyed(0,0) as uint;\n             match self.search_tbl(&k, hash) {\n               NotFound => {\n@@ -255,7 +255,7 @@ pub mod chained {\n             }\n         }\n \n-        pure fn find(+k: K) -> Option<V> {\n+        pure fn find(k: K) -> Option<V> {\n             unsafe {\n                 match self.search_tbl(&k, k.hash_keyed(0,0) as uint) {\n                   NotFound => None,\n@@ -265,15 +265,15 @@ pub mod chained {\n             }\n         }\n \n-        fn get(+k: K) -> V {\n+        fn get(k: K) -> V {\n             let opt_v = self.find(k);\n             if opt_v.is_none() {\n                 fail fmt!(\"Key not found in table: %?\", k);\n             }\n             option::unwrap(move opt_v)\n         }\n \n-        fn remove(+k: K) -> bool {\n+        fn remove(k: K) -> bool {\n             match self.search_tbl(&k, k.hash_keyed(0,0) as uint) {\n               NotFound => false,\n               FoundFirst(idx, entry) => {\n@@ -294,15 +294,15 @@ pub mod chained {\n             self.chains = chains(initial_capacity);\n         }\n \n-        pure fn each(blk: fn(+key: K, +value: V) -> bool) {\n+        pure fn each(blk: fn(key: K, +value: V) -> bool) {\n             self.each_ref(|k, v| blk(*k, *v))\n         }\n \n-        pure fn each_key(blk: fn(+key: K) -> bool) {\n+        pure fn each_key(blk: fn(key: K) -> bool) {\n             self.each_key_ref(|p| blk(*p))\n         }\n \n-        pure fn each_value(blk: fn(+value: V) -> bool) {\n+        pure fn each_value(blk: fn(value: V) -> bool) {\n             self.each_value_ref(|p| blk(*p))\n         }\n \n@@ -377,7 +377,7 @@ pub fn HashMap<K:Eq IterBytes Hash Const, V: Copy>()\n }\n \n /// Convenience function for adding keys to a hashmap with nil type keys\n-pub fn set_add<K:Eq IterBytes Hash Const Copy>(set: Set<K>, +key: K) -> bool {\n+pub fn set_add<K:Eq IterBytes Hash Const Copy>(set: Set<K>, key: K) -> bool {\n     set.insert(key, ())\n }\n \n@@ -415,13 +415,13 @@ impl<K: Eq IterBytes Hash Copy, V: Copy> @Mut<LinearMap<K, V>>:\n         }\n     }\n \n-    fn insert(+key: K, +value: V) -> bool {\n+    fn insert(key: K, value: V) -> bool {\n         do self.borrow_mut |p| {\n             p.insert(key, value)\n         }\n     }\n \n-    fn contains_key(+key: K) -> bool {\n+    fn contains_key(key: K) -> bool {\n         do self.borrow_const |p| {\n             p.contains_key(&key)\n         }\n@@ -433,21 +433,21 @@ impl<K: Eq IterBytes Hash Copy, V: Copy> @Mut<LinearMap<K, V>>:\n         }\n     }\n \n-    fn get(+key: K) -> V {\n+    fn get(key: K) -> V {\n         do self.borrow_const |p| {\n             p.get(&key)\n         }\n     }\n \n-    pure fn find(+key: K) -> Option<V> {\n+    pure fn find(key: K) -> Option<V> {\n         unsafe {\n             do self.borrow_const |p| {\n                 p.find(&key)\n             }\n         }\n     }\n \n-    fn remove(+key: K) -> bool {\n+    fn remove(key: K) -> bool {\n         do self.borrow_mut |p| {\n             p.remove(&key)\n         }\n@@ -459,23 +459,23 @@ impl<K: Eq IterBytes Hash Copy, V: Copy> @Mut<LinearMap<K, V>>:\n         }\n     }\n \n-    pure fn each(op: fn(+key: K, +value: V) -> bool) {\n+    pure fn each(op: fn(key: K, +value: V) -> bool) {\n         unsafe {\n             do self.borrow_imm |p| {\n                 p.each(|k, v| op(*k, *v))\n             }\n         }\n     }\n \n-    pure fn each_key(op: fn(+key: K) -> bool) {\n+    pure fn each_key(op: fn(key: K) -> bool) {\n         unsafe {\n             do self.borrow_imm |p| {\n                 p.each_key(|k| op(*k))\n             }\n         }\n     }\n \n-    pure fn each_value(op: fn(+value: V) -> bool) {\n+    pure fn each_value(op: fn(value: V) -> bool) {\n         unsafe {\n             do self.borrow_imm |p| {\n                 p.each_value(|v| op(*v))"}, {"sha": "be38f16aff706e30be093e0d612d81f167b574bf", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -129,7 +129,7 @@ enum TcpConnectErrData {\n  * the remote host. In the event of failure, a\n  * `net::tcp::tcp_connect_err_data` instance will be returned\n  */\n-fn connect(+input_ip: ip::IpAddr, port: uint,\n+fn connect(input_ip: ip::IpAddr, port: uint,\n            iotask: IoTask)\n     -> result::Result<TcpSocket, TcpConnectErrData> unsafe {\n     let result_po = core::comm::Port::<ConnAttempt>();\n@@ -570,7 +570,7 @@ fn accept(new_conn: TcpNewConnection)\n  * successful/normal shutdown, and a `tcp_listen_err_data` enum in the event\n  * of listen exiting because of an error\n  */\n-fn listen(+host_ip: ip::IpAddr, port: uint, backlog: uint,\n+fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: IoTask,\n           +on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n           +new_connect_cb: fn~(TcpNewConnection,\n@@ -587,7 +587,7 @@ fn listen(+host_ip: ip::IpAddr, port: uint, backlog: uint,\n     }\n }\n \n-fn listen_common(+host_ip: ip::IpAddr, port: uint, backlog: uint,\n+fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: IoTask,\n           +on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n           +on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n@@ -728,7 +728,7 @@ fn listen_common(+host_ip: ip::IpAddr, port: uint, backlog: uint,\n  *\n  * A buffered wrapper that you can cast as an `io::reader` or `io::writer`\n  */\n-fn socket_buf(+sock: TcpSocket) -> TcpSocketBuf {\n+fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n     TcpSocketBuf(@{ sock: move sock, mut buf: ~[] })\n }\n \n@@ -738,7 +738,7 @@ impl TcpSocket {\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n         read_start(&self)\n     }\n-    fn read_stop(+read_port:\n+    fn read_stop(read_port:\n                  comm::Port<result::Result<~[u8], TcpErrData>>) ->\n         result::Result<(), TcpErrData> {\n         read_stop(&self, move read_port)\n@@ -1476,7 +1476,7 @@ mod test {\n         */\n     }\n \n-    fn buf_write<W:io::Writer>(+w: &W, val: &str) {\n+    fn buf_write<W:io::Writer>(w: &W, val: &str) {\n         log(debug, fmt!(\"BUF_WRITE: val len %?\", str::len(val)));\n         do str::byte_slice(val) |b_slice| {\n             log(debug, fmt!(\"BUF_WRITE: b_slice len %?\",\n@@ -1485,7 +1485,7 @@ mod test {\n         }\n     }\n \n-    fn buf_read<R:io::Reader>(+r: &R, len: uint) -> ~str {\n+    fn buf_read<R:io::Reader>(r: &R, len: uint) -> ~str {\n         let new_bytes = (*r).read_bytes(len);\n         log(debug, fmt!(\"in buf_read.. new_bytes len: %?\",\n                         vec::len(new_bytes)));"}, {"sha": "6dca075405bcccd4c56be09010fc125d52e22297", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -1,5 +1,5 @@\n //! Types/fns concerning URLs (see RFC 3986)\n-#[forbid(deprecated_mode)];\n+// tjc: forbid deprecated modes again after a snapshot\n \n use core::cmp::Eq;\n use map::HashMap;\n@@ -36,15 +36,15 @@ type UserInfo = {\n \n type Query = ~[(~str, ~str)];\n \n-fn Url(+scheme: ~str, +user: Option<UserInfo>, +host: ~str,\n+fn Url(scheme: ~str, +user: Option<UserInfo>, +host: ~str,\n        +port: Option<~str>, +path: ~str, +query: Query,\n        +fragment: Option<~str>) -> Url {\n     Url { scheme: move scheme, user: move user, host: move host,\n          port: move port, path: move path, query: move query,\n          fragment: move fragment }\n }\n \n-fn UserInfo(+user: ~str, +pass: Option<~str>) -> UserInfo {\n+fn UserInfo(user: ~str, +pass: Option<~str>) -> UserInfo {\n     {user: move user, pass: move pass}\n }\n \n@@ -306,7 +306,7 @@ fn userinfo_from_str(uinfo: &str) -> UserInfo {\n     return UserInfo(user, pass);\n }\n \n-fn userinfo_to_str(+userinfo: UserInfo) -> ~str {\n+fn userinfo_to_str(userinfo: UserInfo) -> ~str {\n     if option::is_some(&userinfo.pass) {\n         return str::concat(~[copy userinfo.user, ~\":\",\n                           option::unwrap(copy userinfo.pass),\n@@ -334,7 +334,7 @@ fn query_from_str(rawquery: &str) -> Query {\n     return query;\n }\n \n-fn query_to_str(+query: Query) -> ~str {\n+fn query_to_str(query: Query) -> ~str {\n     let mut strvec = ~[];\n     for query.each |kv| {\n         let (k, v) = copy *kv;\n@@ -681,7 +681,7 @@ impl Url : FromStr {\n  * result in just \"http://somehost.com\".\n  *\n  */\n-fn to_str(+url: Url) -> ~str {\n+fn to_str(url: Url) -> ~str {\n     let user = if url.user.is_some() {\n       userinfo_to_str(option::unwrap(copy url.user))\n     } else {"}, {"sha": "5df4fc10a036c1d3bc2f5f8d4afa165bfd6fc7d0", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -379,7 +379,7 @@ Section: Iterating\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-pub fn loop_chars(rope: Rope, it: fn(+c: char) -> bool) -> bool {\n+pub fn loop_chars(rope: Rope, it: fn(c: char) -> bool) -> bool {\n    match (rope) {\n       node::Empty => return true,\n       node::Content(x) => return node::loop_chars(x, it)\n@@ -1037,7 +1037,7 @@ mod node {\n         return result;\n     }\n \n-    pub fn loop_chars(node: @Node, it: fn(+c: char) -> bool) -> bool {\n+    pub fn loop_chars(node: @Node, it: fn(c: char) -> bool) -> bool {\n         return loop_leaves(node,|leaf| {\n             str::all_between(*leaf.content,\n                              leaf.byte_offset,"}, {"sha": "58ecbb0d6c3a5b31b1d2679b514ddaa85b99213e", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -2,7 +2,7 @@\n  * A simple map based on a vector for small integer keys. Space requirements\n  * are O(highest integer key).\n  */\n-#[forbid(deprecated_mode)];\n+// tjc: forbid deprecated modes again after snap\n \n use core::option;\n use core::option::{Some, None};\n@@ -28,7 +28,7 @@ pub fn mk<T: Copy>() -> SmallIntMap<T> {\n  * the specified key then the original value is replaced.\n  */\n #[inline(always)]\n-pub fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, +val: T) {\n+pub fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, val: T) {\n     //io::println(fmt!(\"%?\", key));\n     self.v.grow_set_elt(key, &None, Some(val));\n }\n@@ -77,12 +77,12 @@ impl<V: Copy> SmallIntMap<V>: map::Map<uint, V> {\n         sz\n     }\n     #[inline(always)]\n-    fn insert(+key: uint, +value: V) -> bool {\n+    fn insert(key: uint, value: V) -> bool {\n         let exists = contains_key(self, key);\n         insert(self, key, value);\n         return !exists;\n     }\n-    fn remove(+key: uint) -> bool {\n+    fn remove(key: uint) -> bool {\n         if key >= self.v.len() {\n             return false;\n         }\n@@ -93,23 +93,23 @@ impl<V: Copy> SmallIntMap<V>: map::Map<uint, V> {\n     fn clear() {\n         self.v.set(~[]);\n     }\n-    fn contains_key(+key: uint) -> bool {\n+    fn contains_key(key: uint) -> bool {\n         contains_key(self, key)\n     }\n     fn contains_key_ref(key: &uint) -> bool {\n         contains_key(self, *key)\n     }\n-    fn get(+key: uint) -> V { get(self, key) }\n-    pure fn find(+key: uint) -> Option<V> { find(self, key) }\n+    fn get(key: uint) -> V { get(self, key) }\n+    pure fn find(key: uint) -> Option<V> { find(self, key) }\n     fn rehash() { fail }\n \n-    pure fn each(it: fn(+key: uint, +value: V) -> bool) {\n+    pure fn each(it: fn(key: uint, +value: V) -> bool) {\n         self.each_ref(|k, v| it(*k, *v))\n     }\n-    pure fn each_key(it: fn(+key: uint) -> bool) {\n+    pure fn each_key(it: fn(key: uint) -> bool) {\n         self.each_ref(|k, _v| it(*k))\n     }\n-    pure fn each_value(it: fn(+value: V) -> bool) {\n+    pure fn each_value(it: fn(value: V) -> bool) {\n         self.each_ref(|_k, v| it(*v))\n     }\n     pure fn each_ref(it: fn(key: &uint, value: &V) -> bool) {"}, {"sha": "683ea589b914fcabda2efd185153a1dfa37c94e9", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -18,9 +18,6 @@ not required in or otherwise suitable for the core library.\n \n #[no_core];\n \n-// tjc: Added legacy_modes back in because it still uses + mode.\n-// Remove once + mode gets expunged from std.\n-#[legacy_modes];\n #[legacy_exports];\n \n #[allow(vecs_implicitly_copyable)];"}, {"sha": "f66134d38923408394a6a030f02cda6e48087364", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: forbid deprecated modes again after snap\n /**\n  * The concurrency primitives you know and love.\n  *\n@@ -69,7 +69,7 @@ struct SemInner<Q> {\n enum Sem<Q: Send> = Exclusive<SemInner<Q>>;\n \n #[doc(hidden)]\n-fn new_sem<Q: Send>(count: int, +q: Q) -> Sem<Q> {\n+fn new_sem<Q: Send>(count: int, q: Q) -> Sem<Q> {\n     Sem(exclusive(SemInner {\n         mut count: count, waiters: new_waitqueue(), blocked: q }))\n }\n@@ -535,7 +535,7 @@ impl &RWlock {\n      * }\n      * ~~~\n      */\n-    fn write_downgrade<U>(blk: fn(+v: RWlockWriteMode) -> U) -> U {\n+    fn write_downgrade<U>(blk: fn(v: RWlockWriteMode) -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above.\n         // The exit path is conditional on whether the caller downgrades.\n         let mut _release = None;\n@@ -551,7 +551,7 @@ impl &RWlock {\n     }\n \n     /// To be called inside of the write_downgrade block.\n-    fn downgrade(+token: RWlockWriteMode/&a) -> RWlockReadMode/&a {\n+    fn downgrade(token: RWlockWriteMode/&a) -> RWlockReadMode/&a {\n         if !ptr::ref_eq(self, token.lock) {\n             fail ~\"Can't downgrade() with a different rwlock's write_mode!\";\n         }\n@@ -957,7 +957,7 @@ mod tests {\n             drop { self.c.send(()); }\n         }\n \n-        fn SendOnFailure(+c: pipes::Chan<()>) -> SendOnFailure {\n+        fn SendOnFailure(c: pipes::Chan<()>) -> SendOnFailure {\n             SendOnFailure {\n                 c: c\n             }\n@@ -1038,7 +1038,7 @@ mod tests {\n         }\n     }\n     #[cfg(test)]\n-    fn test_rwlock_exclusion(+x: ~RWlock, mode1: RWlockMode,\n+    fn test_rwlock_exclusion(x: ~RWlock, mode1: RWlockMode,\n                              mode2: RWlockMode) {\n         // Test mutual exclusion between readers and writers. Just like the\n         // mutex mutual exclusion test, a ways above.\n@@ -1083,7 +1083,7 @@ mod tests {\n         test_rwlock_exclusion(~RWlock(), Downgrade, Downgrade);\n     }\n     #[cfg(test)]\n-    fn test_rwlock_handshake(+x: ~RWlock, mode1: RWlockMode,\n+    fn test_rwlock_handshake(x: ~RWlock, mode1: RWlockMode,\n                              mode2: RWlockMode, make_mode2_go_first: bool) {\n         // Much like sem_multi_resource.\n         let x2 = ~x.clone();"}, {"sha": "c5d9dd343fa0749fdd3ffc76c3a69b4734da703a", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -270,7 +270,7 @@ enum TestEvent {\n type MonitorMsg = (TestDesc, TestResult);\n \n fn run_tests(opts: &TestOpts, tests: &[TestDesc],\n-             callback: fn@(+e: TestEvent)) {\n+             callback: fn@(e: TestEvent)) {\n \n     let mut filtered_tests = filter_tests(opts, tests);\n     callback(TeFiltered(copy filtered_tests));\n@@ -379,7 +379,7 @@ fn filter_tests(opts: &TestOpts,\n \n type TestFuture = {test: TestDesc, wait: fn@() -> TestResult};\n \n-fn run_test(+test: TestDesc, monitor_ch: comm::Chan<MonitorMsg>) {\n+fn run_test(test: TestDesc, monitor_ch: comm::Chan<MonitorMsg>) {\n     if test.ignore {\n         core::comm::send(monitor_ch, (copy test, TrIgnored));\n         return;"}, {"sha": "aef3bb2ac0ad10e056ae6b3bdeb950f81ed966b0", "filename": "src/libstd/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -1,4 +1,4 @@\n-#[forbid(deprecated_mode)];\n+// tjc: forbid deprecated modes again after snap\n \n use core::cmp::Eq;\n use libc::{c_char, c_int, c_long, size_t, time_t};\n@@ -589,7 +589,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     }\n }\n \n-fn strftime(format: &str, +tm: Tm) -> ~str {\n+fn strftime(format: &str, tm: Tm) -> ~str {\n     fn parse_type(ch: char, tm: &Tm) -> ~str {\n         //FIXME (#2350): Implement missing types.\n       let die = || #fmt(\"strftime: can't understand this format %c \","}, {"sha": "2aca87b942ecbb3fbd274b3b52e37d0c2c829792", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -1,6 +1,6 @@\n //! Utilities that leverage libuv's `uv_timer_*` API\n \n-#[forbid(deprecated_mode)];\n+// tjc: forbid deprecated modes again after snap\n \n use uv = uv;\n use uv::iotask;\n@@ -24,7 +24,7 @@ use comm = core::comm;\n  * * val - a value of type T to send over the provided `ch`\n  */\n pub fn delayed_send<T: Copy Send>(iotask: IoTask,\n-                                  msecs: uint, ch: comm::Chan<T>, +val: T) {\n+                                  msecs: uint, ch: comm::Chan<T>, val: T) {\n         unsafe {\n             let timer_done_po = core::comm::Port::<()>();\n             let timer_done_ch = core::comm::Chan(timer_done_po);"}, {"sha": "4a4a34704be21437b10d3731d41cb4b42732ab93", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -5,7 +5,7 @@\n  * `interact` function you can execute code in a uv callback.\n  */\n \n-#[forbid(deprecated_mode)];\n+// tjc: forbid deprecated modes again after a snapshot\n \n use libc::c_void;\n use ptr::p2::addr_of;\n@@ -22,7 +22,7 @@ pub enum IoTask {\n     })\n }\n \n-pub fn spawn_iotask(+task: task::TaskBuilder) -> IoTask {\n+pub fn spawn_iotask(task: task::TaskBuilder) -> IoTask {\n \n     do listen |iotask_ch| {\n "}, {"sha": "5063605482182046e895bd2f670ad9b9e4c3b67f", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -642,7 +642,7 @@ extern mod rustrt {\n     fn rust_uv_addrinfo_as_sockaddr_in(input: *addrinfo) -> *sockaddr_in;\n     fn rust_uv_addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6;\n     fn rust_uv_malloc_buf_base_of(sug_size: libc::size_t) -> *u8;\n-    fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n+    fn rust_uv_free_base_of_buf(+buf: uv_buf_t);\n     fn rust_uv_get_stream_handle_from_connect_req(\n         connect_req: *uv_connect_t)\n         -> *uv_stream_t;\n@@ -661,8 +661,8 @@ extern mod rustrt {\n     fn rust_uv_get_data_for_req(req: *libc::c_void) -> *libc::c_void;\n     fn rust_uv_set_data_for_req(req: *libc::c_void,\n                                 data: *libc::c_void);\n-    fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n-    fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> libc::size_t;\n+    fn rust_uv_get_base_from_buf(+buf: uv_buf_t) -> *u8;\n+    fn rust_uv_get_len_from_buf(+buf: uv_buf_t) -> libc::size_t;\n \n     // sizeof testing helpers\n     fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;"}, {"sha": "a34fcc89c048ce497a3605db7d50c2f29b8f09e8", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f33539e446d6f41d4a3296ed50a8f968e7950483/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=f33539e446d6f41d4a3296ed50a8f968e7950483", "patch": "@@ -251,7 +251,7 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n         colors = do par::mapi_factory(*color_vec) {\n             let colors = arc::clone(&color);\n             let graph = arc::clone(&graph);\n-            fn~(i: uint, c: color) -> color {\n+            fn~(+i: uint, +c: color) -> color {\n                 let c : color = c;\n                 let colors = arc::get(&colors);\n                 let graph = arc::get(&graph);"}]}