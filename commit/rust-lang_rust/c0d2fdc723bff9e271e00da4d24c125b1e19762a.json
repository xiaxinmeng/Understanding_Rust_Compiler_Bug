{"sha": "c0d2fdc723bff9e271e00da4d24c125b1e19762a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwZDJmZGM3MjNiZmY5ZTI3MWUwMGRhNGQyNGMxMjViMWUxOTc2MmE=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-30T12:48:39Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-02T21:34:20Z"}, "message": "Partially apply rustfmt", "tree": {"sha": "29bb8fdc8e907afbc51e8ffbd3ce46ca0bf4d08e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29bb8fdc8e907afbc51e8ffbd3ce46ca0bf4d08e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0d2fdc723bff9e271e00da4d24c125b1e19762a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0d2fdc723bff9e271e00da4d24c125b1e19762a", "html_url": "https://github.com/rust-lang/rust/commit/c0d2fdc723bff9e271e00da4d24c125b1e19762a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0d2fdc723bff9e271e00da4d24c125b1e19762a/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c726e8077f9effe36dfa1358f87e71c941961f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c726e8077f9effe36dfa1358f87e71c941961f0", "html_url": "https://github.com/rust-lang/rust/commit/0c726e8077f9effe36dfa1358f87e71c941961f0"}], "stats": {"total": 177, "additions": 92, "deletions": 85}, "files": [{"sha": "012c4e502b4a7c82a8e70c31e9dd8de9504740aa", "filename": "src/attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=c0d2fdc723bff9e271e00da4d24c125b1e19762a", "patch": "@@ -60,10 +60,10 @@ impl LateLintPass for AttrPass {\n                         check_semver(cx, item.span, lit);\n                     }\n                 }\n-            } \n+            }\n         }\n     }\n-    \n+\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if is_relevant_item(item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n@@ -164,7 +164,7 @@ fn check_semver(cx: &LateContext, span: Span, lit: &Lit) {\n             return;\n         }\n     }\n-    span_lint(cx, \n+    span_lint(cx,\n               DEPRECATED_SEMVER,\n               span,\n               \"the since field must contain a semver-compliant version\");"}, {"sha": "0fce772010a9a1796978037425ff10c4a12e8304", "filename": "src/bit_mask.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=c0d2fdc723bff9e271e00da4d24c125b1e19762a", "patch": "@@ -151,7 +151,6 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                     } else if mask_value == 0 {\n                         span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                     }\n-\n                 }\n                 BiBitOr => {\n                     if mask_value | cmp_value != cmp_value {"}, {"sha": "d8f331ef5ff4f8af9846a9c126df33e1f44263e6", "filename": "src/derive.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fderive.rs?ref=c0d2fdc723bff9e271e00da4d24c125b1e19762a", "patch": "@@ -158,24 +158,21 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref:\n             _ => (),\n         }\n \n-        span_lint_and_then(\n-            cx, DERIVE_HASH_NOT_EQ, span,\n-            \"you are implementing `Clone` explicitly on a `Copy` type\",\n-            |db| {\n-                db.span_note(\n-                    span,\n-                    \"consider deriving `Clone` or removing `Copy`\"\n-                );\n-        });\n+        span_lint_and_then(cx,\n+                           DERIVE_HASH_NOT_EQ,\n+                           span,\n+                           \"you are implementing `Clone` explicitly on a `Copy` type\",\n+                           |db| {\n+                               db.span_note(span, \"consider deriving `Clone` or removing `Copy`\");\n+                           });\n     }\n }\n \n /// Checks for the `#[automatically_derived]` attribute all `#[derive]`d implementations have.\n fn is_automatically_derived(attr: &Attribute) -> bool {\n     if let MetaItem_::MetaWord(ref word) = attr.node.value.node {\n         word == &\"automatically_derived\"\n-    }\n-    else {\n+    } else {\n         false\n     }\n }"}, {"sha": "bd6687e3f0dfb9fd2c810ef0ede958f37c4903bd", "filename": "src/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fescape.rs?ref=c0d2fdc723bff9e271e00da4d24c125b1e19762a", "patch": "@@ -34,7 +34,7 @@ declare_lint!(pub BOXED_LOCAL, Warn, \"using Box<T> where unnecessary\");\n fn is_non_trait_box(ty: ty::Ty) -> bool {\n     match ty.sty {\n         ty::TyBox(ref inner) => !inner.is_trait(),\n-        _ => false\n+        _ => false,\n     }\n }\n "}, {"sha": "ad666a3bf3f6baead8a0dea1c2d528cf1214f406", "filename": "src/items_after_statements.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems_after_statements.rs?ref=c0d2fdc723bff9e271e00da4d24c125b1e19762a", "patch": "@@ -56,8 +56,10 @@ impl EarlyLintPass for ItemsAfterStatemets {\n                     if in_macro(cx, it.span) {\n                         return;\n                     }\n-                    cx.struct_span_lint(ITEMS_AFTER_STATEMENTS, it.span,\n-                                        \"adding items after statements is confusing, since items exist from the start of the scope\")\n+                    cx.struct_span_lint(ITEMS_AFTER_STATEMENTS,\n+                                        it.span,\n+                                        \"adding items after statements is confusing, since items exist from the \\\n+                                         start of the scope\")\n                       .emit();\n                 }\n             }"}, {"sha": "b6f8ebe5fd8992b4445605e852bc226a2c127cd5", "filename": "src/lifetimes.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=c0d2fdc723bff9e271e00da4d24c125b1e19762a", "patch": "@@ -68,9 +68,13 @@ enum RefLt {\n \n fn bound_lifetimes(bound: &TyParamBound) -> Option<HirVec<&Lifetime>> {\n     if let TraitTyParamBound(ref trait_ref, _) = *bound {\n-        let lt = trait_ref.trait_ref.path.segments\n-            .last().expect(\"a path must have at least one segment\")\n-            .parameters.lifetimes();\n+        let lt = trait_ref.trait_ref\n+                          .path\n+                          .segments\n+                          .last()\n+                          .expect(\"a path must have at least one segment\")\n+                          .parameters\n+                          .lifetimes();\n \n         Some(lt)\n     } else {\n@@ -83,10 +87,9 @@ fn check_fn_inner(cx: &LateContext, decl: &FnDecl, slf: Option<&ExplicitSelf>, g\n         return;\n     }\n \n-    let bounds_lts =\n-        generics.ty_params\n-            .iter()\n-            .flat_map(|ref typ| typ.bounds.iter().filter_map(bound_lifetimes).flat_map(|lts| lts));\n+    let bounds_lts = generics.ty_params\n+                             .iter()\n+                             .flat_map(|ref typ| typ.bounds.iter().filter_map(bound_lifetimes).flat_map(|lts| lts));\n \n     if could_use_elision(cx, decl, slf, &generics.lifetimes, bounds_lts) {\n         span_lint(cx,\n@@ -97,10 +100,9 @@ fn check_fn_inner(cx: &LateContext, decl: &FnDecl, slf: Option<&ExplicitSelf>, g\n     report_extra_lifetimes(cx, decl, &generics, slf);\n }\n \n-fn could_use_elision<'a, T: Iterator<Item=&'a Lifetime>>(\n-    cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>,\n-    named_lts: &[LifetimeDef], bounds_lts: T\n-) -> bool {\n+fn could_use_elision<'a, T: Iterator<Item = &'a Lifetime>>(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>,\n+                                                           named_lts: &[LifetimeDef], bounds_lts: T)\n+                                                           -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n     // * output references, exactly one input reference with same LT\n@@ -185,7 +187,7 @@ fn allowed_lts_from(named_lts: &[LifetimeDef]) -> HashSet<RefLt> {\n     allowed_lts\n }\n \n-fn lts_from_bounds<'a, T: Iterator<Item=&'a Lifetime>>(mut vec: Vec<RefLt>, bounds_lts: T) -> Vec<RefLt> {\n+fn lts_from_bounds<'a, T: Iterator<Item = &'a Lifetime>>(mut vec: Vec<RefLt>, bounds_lts: T) -> Vec<RefLt> {\n     for lt in bounds_lts {\n         if lt.name.as_str() != \"'static\" {\n             vec.push(RefLt::Named(lt.name));\n@@ -332,8 +334,7 @@ impl<'v> Visitor<'v> for LifetimeChecker {\n     }\n }\n \n-fn report_extra_lifetimes(cx: &LateContext, func: &FnDecl,\n-                          generics: &Generics, slf: Option<&ExplicitSelf>) {\n+fn report_extra_lifetimes(cx: &LateContext, func: &FnDecl, generics: &Generics, slf: Option<&ExplicitSelf>) {\n     let hs = generics.lifetimes\n                      .iter()\n                      .map(|lt| (lt.lifetime.name, lt.lifetime.span))"}, {"sha": "20c75e08d23d5473fa5a49089212015fbdd4e189", "filename": "src/loops.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=c0d2fdc723bff9e271e00da4d24c125b1e19762a", "patch": "@@ -296,16 +296,14 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n \n                 let skip: Cow<_> = if starts_at_zero {\n                     \"\".into()\n-                }\n-                else {\n+                } else {\n                     format!(\".skip({})\", snippet(cx, l.span, \"..\")).into()\n                 };\n \n                 let take: Cow<_> = if let Some(ref r) = *r {\n                     if !is_len_call(&r, &indexed) {\n                         format!(\".take({})\", snippet(cx, r.span, \"..\")).into()\n-                    }\n-                    else {\n+                    } else {\n                         \"\".into()\n                     }\n                 } else {\n@@ -327,8 +325,7 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n                 } else {\n                     let repl = if starts_at_zero && take.is_empty() {\n                         format!(\"&{}\", indexed)\n-                    }\n-                    else {\n+                    } else {\n                         format!(\"{}.iter(){}{}\", indexed, take, skip)\n                     };\n "}, {"sha": "e690f04bdb0c60518ebba7144e8deafd47205719", "filename": "src/matches.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=c0d2fdc723bff9e271e00da4d24c125b1e19762a", "patch": "@@ -192,7 +192,7 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n         },\n         PatEnum(ref path, None) => path.to_string(),\n         PatIdent(BindByValue(MutImmutable), ident, None) => ident.node.to_string(),\n-        _ => return\n+        _ => return,\n     };\n \n     for &(ty_path, pat_path) in candidates {\n@@ -206,15 +206,17 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n             span_lint_and_then(cx,\n                                lint,\n                                expr.span,\n-                               \"you seem to be trying to use match for destructuring a single pattern. \\\n-                               Consider using `if let`\", |db| {\n-                db.span_suggestion(expr.span, \"try this\",\n-                                   format!(\"if let {} = {} {}{}\",\n-                                           snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                           snippet(cx, ex.span, \"..\"),\n-                                           expr_block(cx, &arms[0].body, None, \"..\"),\n-                                           els_str));\n-            });\n+                               \"you seem to be trying to use match for destructuring a single pattern. Consider \\\n+                                using `if let`\",\n+                               |db| {\n+                                   db.span_suggestion(expr.span,\n+                                                      \"try this\",\n+                                                      format!(\"if let {} = {} {}{}\",\n+                                                              snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                                              snippet(cx, ex.span, \"..\"),\n+                                                              expr_block(cx, &arms[0].body, None, \"..\"),\n+                                                              els_str));\n+                               });\n         }\n     }\n }\n@@ -267,12 +269,12 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n         span_lint_and_then(cx,\n                            MATCH_BOOL,\n                            expr.span,\n-                           \"you seem to be trying to match on a boolean expression. Consider using \\\n-                           an if..else block:\", move |db| {\n-            if let Some(sugg) = sugg {\n-                db.span_suggestion(expr.span, \"try this\", sugg);\n-            }\n-        });\n+                           \"you seem to be trying to match on a boolean expression. Consider using an if..else block:\",\n+                           move |db| {\n+                               if let Some(sugg) = sugg {\n+                                   db.span_suggestion(expr.span, \"try this\", sugg);\n+                               }\n+                           });\n     }\n }\n "}, {"sha": "d40ab250a7f4a3337dee89f81f2ab5326cfdfc06", "filename": "src/methods.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=c0d2fdc723bff9e271e00da4d24c125b1e19762a", "patch": "@@ -349,16 +349,18 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n \n         if name == \"unwrap_or\" {\n             if let ExprPath(_, ref path) = fun.node {\n-                let path : &str = &path.segments.last()\n-                    .expect(\"A path must have at least one segment\")\n-                    .identifier.name.as_str();\n+                let path: &str = &path.segments\n+                                      .last()\n+                                      .expect(\"A path must have at least one segment\")\n+                                      .identifier\n+                                      .name\n+                                      .as_str();\n \n                 if [\"default\", \"new\"].contains(&path) {\n                     let arg_ty = cx.tcx.expr_ty(arg);\n                     let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &DEFAULT_TRAIT_PATH) {\n                         default_trait_id\n-                    }\n-                    else {\n+                    } else {\n                         return false;\n                     };\n \n@@ -408,7 +410,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n             };\n \n         if !poss.contains(&name) {\n-            return\n+            return;\n         }\n \n         let sugg = match (fn_has_arguments, !or_has_args) {\n@@ -444,30 +446,32 @@ fn lint_extend(cx: &LateContext, expr: &Expr, args: &MethodArgs) {\n     }\n     let arg_ty = cx.tcx.expr_ty(&args[1]);\n     if let Some((span, r)) = derefs_to_slice(cx, &args[1], &arg_ty) {\n-        span_lint(cx, EXTEND_FROM_SLICE, expr.span,\n+        span_lint(cx,\n+                  EXTEND_FROM_SLICE,\n+                  expr.span,\n                   &format!(\"use of `extend` to extend a Vec by a slice\"))\n-            .span_suggestion(expr.span, \"try this\",\n+            .span_suggestion(expr.span,\n+                             \"try this\",\n                              format!(\"{}.extend_from_slice({}{})\",\n                                      snippet(cx, args[0].span, \"_\"),\n-                                     r, snippet(cx, span, \"_\")));\n+                                     r,\n+                                     snippet(cx, span, \"_\")));\n     }\n }\n \n-fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty)\n-   -> Option<(Span, &'static str)> {\n+fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty) -> Option<(Span, &'static str)> {\n     fn may_slice(cx: &LateContext, ty: &ty::Ty) -> bool {\n         match ty.sty {\n             ty::TySlice(_) => true,\n             ty::TyStruct(..) => match_type(cx, ty, &VEC_PATH),\n             ty::TyArray(_, size) => size < 32,\n             ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) |\n             ty::TyBox(ref inner) => may_slice(cx, inner),\n-            _ => false\n+            _ => false,\n         }\n     }\n     if let ExprMethodCall(name, _, ref args) = expr.node {\n-        if &name.node.as_str() == &\"iter\" &&\n-               may_slice(cx, &cx.tcx.expr_ty(&args[0])) {\n+        if &name.node.as_str() == &\"iter\" && may_slice(cx, &cx.tcx.expr_ty(&args[0])) {\n             Some((args[0].span, \"&\"))\n         } else {\n             None\n@@ -476,10 +480,14 @@ fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty)\n         match ty.sty {\n             ty::TySlice(_) => Some((expr.span, \"\")),\n             ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) |\n-            ty::TyBox(ref inner) => if may_slice(cx, inner) {\n-                Some((expr.span, \"\"))\n-            } else { None },\n-            _ => None\n+            ty::TyBox(ref inner) => {\n+                if may_slice(cx, inner) {\n+                    Some((expr.span, \"\"))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n         }\n     }\n }"}, {"sha": "930952bdbaf89363dece0c4dc87dddc114d472a1", "filename": "src/print.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprint.rs?ref=c0d2fdc723bff9e271e00da4d24c125b1e19762a", "patch": "@@ -37,10 +37,7 @@ impl LateLintPass for PrintLint {\n                             None => (span, \"print\"),\n                         };\n \n-                        span_lint(cx,\n-                                  PRINT_STDOUT,\n-                                  span,\n-                                  &format!(\"use of `{}!`\", name));\n+                        span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n                     }\n                 }\n             }"}, {"sha": "1beb00e9056125fa47609500e2694ef5e55346e3", "filename": "src/shadow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=c0d2fdc723bff9e271e00da4d24c125b1e19762a", "patch": "@@ -211,8 +211,8 @@ fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, lspan: Span, init: &\n                                         &format!(\"{} is shadowed by {} which reuses the original value\",\n                                                  snippet(cx, lspan, \"_\"),\n                                                  snippet(cx, expr.span, \"..\")),\n-                                                 expr.span,\n-                                                 \"initialization happens here\");\n+                                        expr.span,\n+                                        \"initialization happens here\");\n             note_orig(cx, db, SHADOW_REUSE, prev_span);\n         } else {\n             let db = span_note_and_lint(cx,\n@@ -221,8 +221,8 @@ fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, lspan: Span, init: &\n                                         &format!(\"{} is shadowed by {}\",\n                                                  snippet(cx, lspan, \"_\"),\n                                                  snippet(cx, expr.span, \"..\")),\n-                                                 expr.span,\n-                                                 \"initialization happens here\");\n+                                        expr.span,\n+                                        \"initialization happens here\");\n             note_orig(cx, db, SHADOW_UNRELATED, prev_span);\n         }\n "}, {"sha": "78fb45cd6cfc04b60f05007d2f8d6161922f2b20", "filename": "src/utils.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d2fdc723bff9e271e00da4d24c125b1e19762a/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=c0d2fdc723bff9e271e00da4d24c125b1e19762a", "patch": "@@ -209,7 +209,7 @@ pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<cstore::DefLike> {\n         loop {\n             let segment = match path_it.next() {\n                 Some(segment) => segment,\n-                None => return None\n+                None => return None,\n             };\n \n             for item in &mem::replace(&mut items, vec![]) {\n@@ -229,8 +229,7 @@ pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<cstore::DefLike> {\n                 }\n             }\n         }\n-    }\n-    else {\n+    } else {\n         None\n     }\n }\n@@ -250,13 +249,17 @@ pub fn get_trait_def_id(cx: &LateContext, path: &[&str]) -> Option<DefId> {\n \n /// Check whether a type implements a trait.\n /// See also `get_trait_def_id`.\n-pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, trait_id: DefId, ty_params: Option<Vec<ty::Ty<'tcx>>>) -> bool {\n+pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, trait_id: DefId,\n+                                  ty_params: Option<Vec<ty::Ty<'tcx>>>)\n+                                  -> bool {\n     cx.tcx.populate_implementations_for_trait_if_necessary(trait_id);\n \n     let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, None);\n     let obligation = traits::predicate_for_trait_def(cx.tcx,\n                                                      traits::ObligationCause::dummy(),\n-                                                     trait_id, 0, ty,\n+                                                     trait_id,\n+                                                     0,\n+                                                     ty,\n                                                      ty_params.unwrap_or_default());\n \n     traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n@@ -658,6 +661,7 @@ pub fn is_expn_of(cx: &LateContext, mut span: Span, name: &str) -> Option<Span>\n                 (ei.callee.name(), ei.call_site)\n             })\n         });\n+\n         match span_name_span {\n             Some((mac_name, new_span)) if mac_name.as_str() == name => return Some(new_span),\n             None => return None,"}]}