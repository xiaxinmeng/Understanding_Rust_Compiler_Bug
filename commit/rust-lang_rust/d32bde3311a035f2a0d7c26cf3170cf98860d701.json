{"sha": "d32bde3311a035f2a0d7c26cf3170cf98860d701", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMmJkZTMzMTFhMDM1ZjJhMGQ3YzI2Y2YzMTcwY2Y5ODg2MGQ3MDE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-22T14:08:44Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-23T20:42:52Z"}, "message": "augment MIR pretty printer to print scopes", "tree": {"sha": "e6bada2a08585c31afb9628c1b93f3f4213d371e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6bada2a08585c31afb9628c1b93f3f4213d371e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d32bde3311a035f2a0d7c26cf3170cf98860d701", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d32bde3311a035f2a0d7c26cf3170cf98860d701", "html_url": "https://github.com/rust-lang/rust/commit/d32bde3311a035f2a0d7c26cf3170cf98860d701", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d32bde3311a035f2a0d7c26cf3170cf98860d701/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caac0b969fd888014c3ff80238d8a00c6eae4feb", "url": "https://api.github.com/repos/rust-lang/rust/commits/caac0b969fd888014c3ff80238d8a00c6eae4feb", "html_url": "https://github.com/rust-lang/rust/commit/caac0b969fd888014c3ff80238d8a00c6eae4feb"}], "stats": {"total": 103, "additions": 91, "deletions": 12}, "files": [{"sha": "a1688e1464c5a19be593a6c71882aa2c81655511", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d32bde3311a035f2a0d7c26cf3170cf98860d701/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32bde3311a035f2a0d7c26cf3170cf98860d701/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=d32bde3311a035f2a0d7c26cf3170cf98860d701", "patch": "@@ -197,7 +197,7 @@ pub struct ArgDecl<'tcx> {\n /// list of the `Mir`.\n ///\n /// (We use a `u32` internally just to save memory.)\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct BasicBlock(u32);\n \n impl BasicBlock {\n@@ -668,7 +668,7 @@ impl IndexMut<ScopeId> for ScopeDataVec {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub struct ScopeId(u32);\n \n impl ScopeId {"}, {"sha": "f2def53d4ead02db34ed77bc13b3a2c17de506e6", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d32bde3311a035f2a0d7c26cf3170cf98860d701/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32bde3311a035f2a0d7c26cf3170cf98860d701/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=d32bde3311a035f2a0d7c26cf3170cf98860d701", "patch": "@@ -73,6 +73,7 @@ pub struct ScopeAuxiliary {\n     pub postdoms: Vec<Location>,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Location {\n     /// the location is within this block\n     pub block: BasicBlock,"}, {"sha": "813766d60c6a117963d3d6c8ffedd64cb031dbe9", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 88, "deletions": 10, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d32bde3311a035f2a0d7c26cf3170cf98860d701/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32bde3311a035f2a0d7c26cf3170cf98860d701/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=d32bde3311a035f2a0d7c26cf3170cf98860d701", "patch": "@@ -8,60 +8,138 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use build::Location;\n use rustc::mir::repr::*;\n-use rustc::middle::ty;\n+use rustc::middle::ty::{self, TyCtxt};\n+use rustc_data_structures::fnv::FnvHashMap;\n use std::io::{self, Write};\n use syntax::ast::NodeId;\n+use syntax::codemap::Span;\n \n const INDENT: &'static str = \"    \";\n \n /// Write out a human-readable textual representation for the given MIR.\n-pub fn write_mir_pretty<'a, 'tcx, I>(tcx: &ty::TyCtxt<'tcx>,\n+pub fn write_mir_pretty<'a, 'tcx, I>(tcx: &TyCtxt<'tcx>,\n                                      iter: I,\n                                      w: &mut Write)\n                                      -> io::Result<()>\n     where I: Iterator<Item=(&'a NodeId, &'a Mir<'tcx>)>, 'tcx: 'a\n {\n+    let no_annotations = FnvHashMap();\n     for (&node_id, mir) in iter {\n-        write_mir_fn(tcx, node_id, mir, w)?;\n+        write_mir_fn(tcx, node_id, mir, w, &no_annotations)?;\n     }\n     Ok(())\n }\n \n-pub fn write_mir_fn<'tcx>(tcx: &ty::TyCtxt<'tcx>,\n+pub enum Annotation {\n+    EnterScope(ScopeId),\n+    ExitScope(ScopeId),\n+}\n+\n+pub fn write_mir_fn<'tcx>(tcx: &TyCtxt<'tcx>,\n                           node_id: NodeId,\n                           mir: &Mir<'tcx>,\n-                          w: &mut Write)\n+                          w: &mut Write,\n+                          annotations: &FnvHashMap<Location, Vec<Annotation>>)\n                           -> io::Result<()> {\n     write_mir_intro(tcx, node_id, mir, w)?;\n     for block in mir.all_basic_blocks() {\n-        write_basic_block(block, mir, w)?;\n+        write_basic_block(tcx, block, mir, w, annotations)?;\n+    }\n+\n+    // construct a scope tree\n+    let mut scope_tree: FnvHashMap<Option<ScopeId>, Vec<ScopeId>> = FnvHashMap();\n+    for (index, scope_data) in mir.scopes.vec.iter().enumerate() {\n+        scope_tree.entry(scope_data.parent_scope)\n+                  .or_insert(vec![])\n+                  .push(ScopeId::new(index));\n     }\n+    write_scope_tree(tcx, mir, &scope_tree, w, None, 1)?;\n+\n     writeln!(w, \"}}\")?;\n     Ok(())\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-fn write_basic_block(block: BasicBlock, mir: &Mir, w: &mut Write) -> io::Result<()> {\n+fn write_basic_block(tcx: &TyCtxt,\n+                     block: BasicBlock,\n+                     mir: &Mir,\n+                     w: &mut Write,\n+                     annotations: &FnvHashMap<Location, Vec<Annotation>>)\n+                     -> io::Result<()> {\n     let data = mir.basic_block_data(block);\n \n     // Basic block label at the top.\n     writeln!(w, \"\\n{}{:?}: {{\", INDENT, block)?;\n \n     // List of statements in the middle.\n+    let mut current_location = Location { block: block, statement_index: 0 };\n     for statement in &data.statements {\n-        writeln!(w, \"{0}{0}{1:?};\", INDENT, statement)?;\n+        if let Some(ref annotations) = annotations.get(&current_location) {\n+            for annotation in annotations.iter() {\n+                match *annotation {\n+                    Annotation::EnterScope(id) =>\n+                        writeln!(w, \"{0}{0}// Enter Scope({1})\",\n+                                 INDENT, id.index())?,\n+                    Annotation::ExitScope(id) =>\n+                        writeln!(w, \"{0}{0}// Exit Scope({1})\",\n+                                 INDENT, id.index())?,\n+                }\n+            }\n+        }\n+\n+        writeln!(w, \"{0}{0}{1:?}; // {2}\",\n+                 INDENT,\n+                 statement,\n+                 comment(tcx, statement.scope, statement.span))?;\n+\n+        current_location.statement_index += 1;\n     }\n \n     // Terminator at the bottom.\n-    writeln!(w, \"{0}{0}{1:?};\", INDENT, data.terminator())?;\n+    writeln!(w, \"{0}{0}{1:?}; // {2}\",\n+             INDENT,\n+             data.terminator(),\n+             comment(tcx, data.terminator().scope, data.terminator().span))?;\n \n     writeln!(w, \"{}}}\", INDENT)\n }\n \n+fn comment(tcx: &TyCtxt,\n+           scope: ScopeId,\n+           span: Span)\n+           -> String {\n+    format!(\"Scope({}) at {}\", scope.index(), tcx.sess.codemap().span_to_string(span))\n+}\n+\n+fn write_scope_tree(tcx: &TyCtxt,\n+                    mir: &Mir,\n+                    scope_tree: &FnvHashMap<Option<ScopeId>, Vec<ScopeId>>,\n+                    w: &mut Write,\n+                    parent: Option<ScopeId>,\n+                    depth: usize)\n+                    -> io::Result<()> {\n+    for &child in scope_tree.get(&parent).unwrap_or(&vec![]) {\n+        let indent = depth * INDENT.len();\n+        let data = &mir.scopes[child];\n+        assert_eq!(data.parent_scope, parent);\n+        writeln!(w, \"{0:1$}Scope({2}) {{\", \"\", indent, child.index())?;\n+        let indent = indent + INDENT.len();\n+        if let Some(parent) = parent {\n+            writeln!(w, \"{0:1$}Parent: Scope({2})\", \"\", indent, parent.index())?;\n+        }\n+        writeln!(w, \"{0:1$}Extent: {2:?}\",\n+                 \"\", indent,\n+                 tcx.region_maps.code_extent_data(data.extent))?;\n+        write_scope_tree(tcx, mir, scope_tree, w, Some(child), depth + 1)?;\n+    }\n+    Ok(())\n+}\n+\n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-fn write_mir_intro(tcx: &ty::TyCtxt, nid: NodeId, mir: &Mir, w: &mut Write)\n+fn write_mir_intro(tcx: &TyCtxt, nid: NodeId, mir: &Mir, w: &mut Write)\n                    -> io::Result<()> {\n     write!(w, \"fn {}(\", tcx.map.path_to_string(nid))?;\n "}]}