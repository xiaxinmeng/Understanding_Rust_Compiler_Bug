{"sha": "9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "node_id": "C_kwDOAAsO6NoAKDllN2I3ZDVlMWM5MTk5ZjM3MjEwN2UwYWNlMTczM2MxMWQwOWZlMzc", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-07-27T15:55:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-27T15:55:04Z"}, "message": "Rollup merge of #99651 - compiler-errors:fn-and-raw-ptr-in-const-generics, r=oli-obk\n\nDeeply deny fn and raw ptrs in const generics\n\nI think this is right -- just because we wrap a fn ptr in a wrapper type does not mean we should allow it in a const parameter.\n\nWe now reject both of these in the same way:\n\n```\n#![feature(adt_const_params)]\n\n#[derive(Eq, PartialEq)]\nstruct Wrapper();\n\nfn foo<const W: Wrapper>() {}\n\nfn foo2<const F: fn()>() {}\n```\n\nThis does regress one test (`src/test/ui/consts/refs_check_const_eq-issue-88384.stderr`), but I'm not sure it should've passed in the first place.\n\ncc: ``@b-naber`` who introduced that test^\nfixes #99641", "tree": {"sha": "5ad1af218214309db5ac55732215f3969db10482", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ad1af218214309db5ac55732215f3969db10482"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi4V/YCRBK7hj4Ov3rIwAA5y8IAIxcmZ6vM3xPz9n/FFIjVtm0\naYzH6CFi+SIt0eGG8TVY298DclXzFkO/9l68UDxKFDNX6tMT9xvR9fRX7L4R33nS\n376EOHHvSGofXM5KAls9SNsaeemUVg3fe3lhXd2I3boyKQ187cCA87QZijMlc4Y2\ns6Gz1UBj8cRJ+ZXt3aoRG882le6uJG3JD6SVfpAALLXrIaz4VKsi+P9F3HPXgYuB\noIlIoYvpI3zqnSLYxggwCbnjeiXK5ZUiodVs2NmGCtPam3gUDkbsKbDWEhKyx6eE\nyYPoVS4oaPW97aLVQli5Z9LHwl0pYhxQKuZpVoZWo/YHn89XhUhDhnDEYHxL/Pk=\n=3EwP\n-----END PGP SIGNATURE-----\n", "payload": "tree 5ad1af218214309db5ac55732215f3969db10482\nparent 4ce1b0f936a070bdfca1c1fe883d192774210d7e\nparent 10b69ab0d20bdbbcdfc5bfe443a50cf2b12b66de\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1658937304 +0200\ncommitter GitHub <noreply@github.com> 1658937304 +0200\n\nRollup merge of #99651 - compiler-errors:fn-and-raw-ptr-in-const-generics, r=oli-obk\n\nDeeply deny fn and raw ptrs in const generics\n\nI think this is right -- just because we wrap a fn ptr in a wrapper type does not mean we should allow it in a const parameter.\n\nWe now reject both of these in the same way:\n\n```\n#![feature(adt_const_params)]\n\n#[derive(Eq, PartialEq)]\nstruct Wrapper();\n\nfn foo<const W: Wrapper>() {}\n\nfn foo2<const F: fn()>() {}\n```\n\nThis does regress one test (`src/test/ui/consts/refs_check_const_eq-issue-88384.stderr`), but I'm not sure it should've passed in the first place.\n\ncc: ``@b-naber`` who introduced that test^\nfixes #99641\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "html_url": "https://github.com/rust-lang/rust/commit/9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ce1b0f936a070bdfca1c1fe883d192774210d7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ce1b0f936a070bdfca1c1fe883d192774210d7e", "html_url": "https://github.com/rust-lang/rust/commit/4ce1b0f936a070bdfca1c1fe883d192774210d7e"}, {"sha": "10b69ab0d20bdbbcdfc5bfe443a50cf2b12b66de", "url": "https://api.github.com/repos/rust-lang/rust/commits/10b69ab0d20bdbbcdfc5bfe443a50cf2b12b66de", "html_url": "https://github.com/rust-lang/rust/commit/10b69ab0d20bdbbcdfc5bfe443a50cf2b12b66de"}], "stats": {"total": 330, "additions": 192, "deletions": 138}, "files": [{"sha": "e099445117225e4a268718c01617e1612bcbeb63", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -226,7 +226,7 @@ impl Qualif for CustomEq {\n         // because that component may be part of an enum variant (e.g.,\n         // `Option::<NonStructuralMatchTy>::Some`), in which case some values of this type may be\n         // structural-match (`Option::None`).\n-        traits::search_for_structural_match_violation(cx.body.span, cx.tcx, ty, true).is_some()\n+        traits::search_for_structural_match_violation(cx.body.span, cx.tcx, ty).is_some()\n     }\n \n     fn in_adt_inherently<'tcx>("}, {"sha": "f8792edc017b2d8d3a5da6affae1e10302511dce", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -203,7 +203,7 @@ impl<'tcx> Const<'tcx> {\n     pub fn to_valtree(self) -> ty::ValTree<'tcx> {\n         match self.kind() {\n             ty::ConstKind::Value(valtree) => valtree,\n-            _ => bug!(\"expected ConstKind::Value\"),\n+            _ => bug!(\"expected ConstKind::Value, got {:?}\", self.kind()),\n         }\n     }\n "}, {"sha": "d6dd0f017941a74aa2a8f84ee5b9eff18412cdcb", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -120,37 +120,35 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     }\n \n     fn search_for_structural_match_violation(&self, ty: Ty<'tcx>) -> Option<String> {\n-        traits::search_for_structural_match_violation(self.span, self.tcx(), ty, true).map(\n-            |non_sm_ty| {\n-                with_no_trimmed_paths!(match non_sm_ty.kind {\n-                    traits::NonStructuralMatchTyKind::Adt(adt) => self.adt_derive_msg(adt),\n-                    traits::NonStructuralMatchTyKind::Dynamic => {\n-                        \"trait objects cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTyKind::Opaque => {\n-                        \"opaque types cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTyKind::Closure => {\n-                        \"closures cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTyKind::Generator => {\n-                        \"generators cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTyKind::Float => {\n-                        \"floating-point numbers cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTyKind::Param => {\n-                        bug!(\"use of a constant whose type is a parameter inside a pattern\")\n-                    }\n-                    traits::NonStructuralMatchTyKind::Projection => {\n-                        bug!(\"use of a constant whose type is a projection inside a pattern\")\n-                    }\n-                    traits::NonStructuralMatchTyKind::Foreign => {\n-                        bug!(\"use of a value of a foreign type inside a pattern\")\n-                    }\n-                })\n-            },\n-        )\n+        traits::search_for_structural_match_violation(self.span, self.tcx(), ty).map(|non_sm_ty| {\n+            with_no_trimmed_paths!(match non_sm_ty.kind() {\n+                ty::Adt(adt, _) => self.adt_derive_msg(*adt),\n+                ty::Dynamic(..) => {\n+                    \"trait objects cannot be used in patterns\".to_string()\n+                }\n+                ty::Opaque(..) => {\n+                    \"opaque types cannot be used in patterns\".to_string()\n+                }\n+                ty::Closure(..) => {\n+                    \"closures cannot be used in patterns\".to_string()\n+                }\n+                ty::Generator(..) | ty::GeneratorWitness(..) => {\n+                    \"generators cannot be used in patterns\".to_string()\n+                }\n+                ty::Float(..) => {\n+                    \"floating-point numbers cannot be used in patterns\".to_string()\n+                }\n+                ty::FnPtr(..) => {\n+                    \"function pointers cannot be used in patterns\".to_string()\n+                }\n+                ty::RawPtr(..) => {\n+                    \"raw pointers cannot be used in patterns\".to_string()\n+                }\n+                _ => {\n+                    bug!(\"use of a value of `{non_sm_ty}` inside a pattern\")\n+                }\n+            })\n+        })\n     }\n \n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {"}, {"sha": "d0a17f712d3dfc24e46c9d8b9c902f6a0dc97813", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -60,8 +60,9 @@ pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError\n pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n-pub use self::structural_match::search_for_structural_match_violation;\n-pub use self::structural_match::{NonStructuralMatchTy, NonStructuralMatchTyKind};\n+pub use self::structural_match::{\n+    search_for_adt_const_param_violation, search_for_structural_match_violation,\n+};\n pub use self::util::{\n     elaborate_obligations, elaborate_predicates, elaborate_predicates_with_span,\n     elaborate_trait_ref, elaborate_trait_refs,"}, {"sha": "c278752e3d9f46459a6027ebcd67307f0020624c", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 65, "deletions": 66, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -6,29 +6,10 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n use rustc_span::Span;\n use std::ops::ControlFlow;\n \n-#[derive(Debug)]\n-pub struct NonStructuralMatchTy<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub kind: NonStructuralMatchTyKind<'tcx>,\n-}\n-\n-#[derive(Debug)]\n-pub enum NonStructuralMatchTyKind<'tcx> {\n-    Adt(AdtDef<'tcx>),\n-    Param,\n-    Dynamic,\n-    Foreign,\n-    Opaque,\n-    Closure,\n-    Generator,\n-    Projection,\n-    Float,\n-}\n-\n /// This method traverses the structure of `ty`, trying to find an\n /// instance of an ADT (i.e. struct or enum) that doesn't implement\n /// the structural-match traits, or a generic type parameter\n@@ -54,15 +35,28 @@ pub enum NonStructuralMatchTyKind<'tcx> {\n /// For more background on why Rust has this requirement, and issues\n /// that arose when the requirement was not enforced completely, see\n /// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n-///\n-/// The floats_allowed flag is used to deny constants in floating point\n pub fn search_for_structural_match_violation<'tcx>(\n     span: Span,\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n-    floats_allowed: bool,\n-) -> Option<NonStructuralMatchTy<'tcx>> {\n-    ty.visit_with(&mut Search { tcx, span, seen: FxHashSet::default(), floats_allowed })\n+) -> Option<Ty<'tcx>> {\n+    ty.visit_with(&mut Search { tcx, span, seen: FxHashSet::default(), adt_const_param: false })\n+        .break_value()\n+}\n+\n+/// This method traverses the structure of `ty`, trying to find any\n+/// types that are not allowed to be used in a const generic.\n+///\n+/// This is either because the type does not implement `StructuralEq`\n+/// and `StructuralPartialEq`, or because the type is intentionally\n+/// not supported in const generics (such as floats and raw pointers,\n+/// which are allowed in match blocks).\n+pub fn search_for_adt_const_param_violation<'tcx>(\n+    span: Span,\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<Ty<'tcx>> {\n+    ty.visit_with(&mut Search { tcx, span, seen: FxHashSet::default(), adt_const_param: true })\n         .break_value()\n }\n \n@@ -125,7 +119,10 @@ struct Search<'tcx> {\n     /// we will not recur on them again.\n     seen: FxHashSet<hir::def_id::DefId>,\n \n-    floats_allowed: bool,\n+    // Additionally deny things that have been allowed in patterns,\n+    // but are not allowed in adt const params, such as floats and\n+    // fn ptrs.\n+    adt_const_param: bool,\n }\n \n impl<'tcx> Search<'tcx> {\n@@ -135,59 +132,35 @@ impl<'tcx> Search<'tcx> {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n-    type BreakTy = NonStructuralMatchTy<'tcx>;\n+    type BreakTy = Ty<'tcx>;\n \n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         debug!(\"Search visiting ty: {:?}\", ty);\n \n         let (adt_def, substs) = match *ty.kind() {\n             ty::Adt(adt_def, substs) => (adt_def, substs),\n             ty::Param(_) => {\n-                let kind = NonStructuralMatchTyKind::Param;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Dynamic(..) => {\n-                let kind = NonStructuralMatchTyKind::Dynamic;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Foreign(_) => {\n-                let kind = NonStructuralMatchTyKind::Foreign;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Opaque(..) => {\n-                let kind = NonStructuralMatchTyKind::Opaque;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Projection(..) => {\n-                let kind = NonStructuralMatchTyKind::Projection;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Closure(..) => {\n-                let kind = NonStructuralMatchTyKind::Closure;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Generator(..) | ty::GeneratorWitness(..) => {\n-                let kind = NonStructuralMatchTyKind::Generator;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n-            }\n-            ty::RawPtr(..) => {\n-                // structural-match ignores substructure of\n-                // `*const _`/`*mut _`, so skip `super_visit_with`.\n-                //\n-                // For example, if you have:\n-                // ```\n-                // struct NonStructural;\n-                // #[derive(PartialEq, Eq)]\n-                // struct T(*const NonStructural);\n-                // const C: T = T(std::ptr::null());\n-                // ```\n-                //\n-                // Even though `NonStructural` does not implement `PartialEq`,\n-                // structural equality on `T` does not recur into the raw\n-                // pointer. Therefore, one can still use `C` in a pattern.\n-                return ControlFlow::CONTINUE;\n+                return ControlFlow::Break(ty);\n             }\n-            ty::FnDef(..) | ty::FnPtr(..) => {\n+            ty::FnDef(..) => {\n                 // Types of formals and return in `fn(_) -> _` are also irrelevant;\n                 // so we do not recur into them via `super_visit_with`\n                 return ControlFlow::CONTINUE;\n@@ -206,14 +179,41 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n                 return ControlFlow::CONTINUE;\n             }\n \n+            ty::FnPtr(..) => {\n+                if !self.adt_const_param {\n+                    return ControlFlow::CONTINUE;\n+                } else {\n+                    return ControlFlow::Break(ty);\n+                }\n+            }\n+\n+            ty::RawPtr(..) => {\n+                if !self.adt_const_param {\n+                    // structural-match ignores substructure of\n+                    // `*const _`/`*mut _`, so skip `super_visit_with`.\n+                    //\n+                    // For example, if you have:\n+                    // ```\n+                    // struct NonStructural;\n+                    // #[derive(PartialEq, Eq)]\n+                    // struct T(*const NonStructural);\n+                    // const C: T = T(std::ptr::null());\n+                    // ```\n+                    //\n+                    // Even though `NonStructural` does not implement `PartialEq`,\n+                    // structural equality on `T` does not recur into the raw\n+                    // pointer. Therefore, one can still use `C` in a pattern.\n+                    return ControlFlow::CONTINUE;\n+                } else {\n+                    return ControlFlow::Break(ty);\n+                }\n+            }\n+\n             ty::Float(_) => {\n-                if self.floats_allowed {\n+                if !self.adt_const_param {\n                     return ControlFlow::CONTINUE;\n                 } else {\n-                    return ControlFlow::Break(NonStructuralMatchTy {\n-                        ty,\n-                        kind: NonStructuralMatchTyKind::Float,\n-                    });\n+                    return ControlFlow::Break(ty);\n                 }\n             }\n \n@@ -239,8 +239,7 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n \n         if !self.type_marked_structural(ty) {\n             debug!(\"Search found ty: {:?}\", ty);\n-            let kind = NonStructuralMatchTyKind::Adt(adt_def);\n-            return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+            return ControlFlow::Break(ty);\n         }\n \n         // structural-match does not care about the"}, {"sha": "bae986de9a23d64a48835a68b8c5b9c24fc7295b", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -848,29 +848,13 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n             let ty = tcx.type_of(tcx.hir().local_def_id(param.hir_id));\n \n             if tcx.features().adt_const_params {\n-                let err = match ty.peel_refs().kind() {\n-                    ty::FnPtr(_) => Some(\"function pointers\"),\n-                    ty::RawPtr(_) => Some(\"raw pointers\"),\n-                    _ => None,\n-                };\n-\n-                if let Some(unsupported_type) = err {\n-                    tcx.sess.span_err(\n-                        hir_ty.span,\n-                        &format!(\n-                            \"using {} as const generic parameters is forbidden\",\n-                            unsupported_type\n-                        ),\n-                    );\n-                }\n-\n                 if let Some(non_structural_match_ty) =\n-                    traits::search_for_structural_match_violation(param.span, tcx, ty, false)\n+                    traits::search_for_adt_const_param_violation(param.span, tcx, ty)\n                 {\n                     // We use the same error code in both branches, because this is really the same\n                     // issue: we just special-case the message for type parameters to make it\n                     // clearer.\n-                    match ty.peel_refs().kind() {\n+                    match non_structural_match_ty.kind() {\n                         ty::Param(_) => {\n                             // Const parameters may not have type parameters as their types,\n                             // because we cannot be sure that the type parameter derives `PartialEq`\n@@ -902,17 +886,35 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                             .note(\"floats do not derive `Eq` or `Ord`, which are required for const parameters\")\n                             .emit();\n                         }\n+                        ty::FnPtr(_) => {\n+                            struct_span_err!(\n+                                tcx.sess,\n+                                hir_ty.span,\n+                                E0741,\n+                                \"using function pointers as const generic parameters is forbidden\",\n+                            )\n+                            .emit();\n+                        }\n+                        ty::RawPtr(_) => {\n+                            struct_span_err!(\n+                                tcx.sess,\n+                                hir_ty.span,\n+                                E0741,\n+                                \"using raw pointers as const generic parameters is forbidden\",\n+                            )\n+                            .emit();\n+                        }\n                         _ => {\n                             let mut diag = struct_span_err!(\n                                 tcx.sess,\n                                 hir_ty.span,\n                                 E0741,\n                                 \"`{}` must be annotated with `#[derive(PartialEq, Eq)]` to be used as \\\n                                 the type of a const parameter\",\n-                                non_structural_match_ty.ty,\n+                                non_structural_match_ty,\n                             );\n \n-                            if ty == non_structural_match_ty.ty {\n+                            if ty == non_structural_match_ty {\n                                 diag.span_label(\n                                     hir_ty.span,\n                                     format!(\"`{ty}` doesn't derive both `PartialEq` and `Eq`\"),"}, {"sha": "b55c2449858c9fe0b9966d4428b795298b2c2afe", "filename": "src/test/ui/const-generics/fn-const-param-call.full.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.full.stderr?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -1,14 +1,15 @@\n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/fn-const-param-call.rs:11:25\n    |\n LL | struct Wrapper<const F: fn() -> u32>;\n    |                         ^^^^^^^^^^^\n \n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/fn-const-param-call.rs:13:15\n    |\n LL | impl<const F: fn() -> u32> Wrapper<F> {\n    |               ^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "2d66a19233269cb7fc93d31465a74a2b44f61efe", "filename": "src/test/ui/const-generics/fn-const-param-infer.full.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.full.stderr?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -1,8 +1,9 @@\n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/fn-const-param-infer.rs:6:25\n    |\n LL | struct Checked<const F: fn(usize) -> bool>;\n    |                         ^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "e17cf96aa3e3d0bdfea2d317753a8bdaf5094c3a", "filename": "src/test/ui/const-generics/issues/issue-71381.full.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71381.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71381.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71381.full.stderr?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -10,18 +10,19 @@ error[E0770]: the type of const parameters must not depend on other generic para\n LL |         const FN: unsafe extern \"C\" fn(Args),\n    |                                        ^^^^ the type must not depend on the parameter `Args`\n \n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/issue-71381.rs:14:61\n    |\n LL |     pub fn call_me<Args: Sized, const IDX: usize, const FN: unsafe extern \"C\" fn(Args)>(&self) {\n    |                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/issue-71381.rs:23:19\n    |\n LL |         const FN: unsafe extern \"C\" fn(Args),\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0770`.\n+Some errors have detailed explanations: E0741, E0770.\n+For more information about an error, try `rustc --explain E0741`."}, {"sha": "ab2a4e64a838978bade17de81988f5540df5062b", "filename": "src/test/ui/const-generics/issues/issue-71382.full.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71382.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71382.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71382.full.stderr?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -1,8 +1,9 @@\n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/issue-71382.rs:16:23\n    |\n LL |     fn test<const FN: fn()>(&self) {\n    |                       ^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "656aa29e19b2595579442e16cea4575ffb83638f", "filename": "src/test/ui/const-generics/issues/issue-71611.full.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71611.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71611.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71611.full.stderr?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -4,12 +4,13 @@ error[E0770]: the type of const parameters must not depend on other generic para\n LL | fn func<A, const F: fn(inner: A)>(outer: A) {\n    |                               ^ the type must not depend on the parameter `A`\n \n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/issue-71611.rs:5:21\n    |\n LL | fn func<A, const F: fn(inner: A)>(outer: A) {\n    |                     ^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0770`.\n+Some errors have detailed explanations: E0741, E0770.\n+For more information about an error, try `rustc --explain E0741`."}, {"sha": "92580b33685d190c45541ebb5b930dea8ee4b412", "filename": "src/test/ui/const-generics/issues/issue-72352.full.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72352.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72352.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72352.full.stderr?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -1,8 +1,9 @@\n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/issue-72352.rs:7:42\n    |\n LL | unsafe fn unsafely_do_the_thing<const F: fn(&CStr) -> usize>(ptr: *const i8) -> usize {\n    |                                          ^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "fae6d3fc41fb86ae77d179e7058bf79e26fecd7c", "filename": "src/test/ui/const-generics/issues/issue-99641.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-99641.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-99641.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-99641.rs?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -0,0 +1,18 @@\n+#![feature(adt_const_params)]\n+#![allow(incomplete_features)]\n+\n+fn main() {\n+    pub struct Color<const WHITE: (fn(),)>;\n+    //~^ ERROR using function pointers\n+\n+    impl<const WHITE: (fn(),)> Color<WHITE> {\n+        //~^ ERROR using function pointers\n+        pub fn new() -> Self {\n+            Color::<WHITE>\n+        }\n+    }\n+\n+    pub const D65: (fn(),) = (|| {},);\n+\n+    Color::<D65>::new();\n+}"}, {"sha": "349ebba08d53f5ba385b3ab9d667514457480560", "filename": "src/test/ui/const-generics/issues/issue-99641.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-99641.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-99641.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-99641.stderr?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -0,0 +1,15 @@\n+error[E0741]: using function pointers as const generic parameters is forbidden\n+  --> $DIR/issue-99641.rs:5:35\n+   |\n+LL |     pub struct Color<const WHITE: (fn(),)>;\n+   |                                   ^^^^^^^\n+\n+error[E0741]: using function pointers as const generic parameters is forbidden\n+  --> $DIR/issue-99641.rs:8:23\n+   |\n+LL |     impl<const WHITE: (fn(),)> Color<WHITE> {\n+   |                       ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "657eee2be24431697ed97a7a1e42a14a2ecc9cd4", "filename": "src/test/ui/const-generics/raw-ptr-const-param-deref.full.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.full.stderr?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -1,14 +1,15 @@\n-error: using raw pointers as const generic parameters is forbidden\n+error[E0741]: using raw pointers as const generic parameters is forbidden\n   --> $DIR/raw-ptr-const-param-deref.rs:9:23\n    |\n LL | struct Const<const P: *const u32>;\n    |                       ^^^^^^^^^^\n \n-error: using raw pointers as const generic parameters is forbidden\n+error[E0741]: using raw pointers as const generic parameters is forbidden\n   --> $DIR/raw-ptr-const-param-deref.rs:11:15\n    |\n LL | impl<const P: *const u32> Const<P> {\n    |               ^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "69f1aae5681a4371897857de6529bce118bec9a3", "filename": "src/test/ui/const-generics/raw-ptr-const-param.full.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.full.stderr?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -1,8 +1,9 @@\n-error: using raw pointers as const generic parameters is forbidden\n+error[E0741]: using raw pointers as const generic parameters is forbidden\n   --> $DIR/raw-ptr-const-param.rs:6:23\n    |\n LL | struct Const<const P: *const u32>;\n    |                       ^^^^^^^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "1496b28bd3ee6f4c2b3f466e9d19f8fbb2d5ed98", "filename": "src/test/ui/consts/refs_check_const_eq-issue-88384.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconsts%2Frefs_check_const_eq-issue-88384.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconsts%2Frefs_check_const_eq-issue-88384.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frefs_check_const_eq-issue-88384.rs?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -1,5 +1,3 @@\n-// check-pass\n-\n #![feature(fn_traits)]\n #![feature(adt_const_params)]\n //~^ WARNING the feature `adt_const_params` is incomplete\n@@ -10,8 +8,10 @@ struct CompileTimeSettings{\n }\n \n struct Foo<const T: CompileTimeSettings>;\n+//~^ ERROR using function pointers as const generic parameters is forbidden\n \n impl<const T: CompileTimeSettings> Foo<T> {\n+    //~^ ERROR using function pointers as const generic parameters is forbidden\n     fn call_hooks(){\n     }\n }"}, {"sha": "4f2f5e244b67e51e005e3cbe20c435da60571f7f", "filename": "src/test/ui/consts/refs_check_const_eq-issue-88384.stderr", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconsts%2Frefs_check_const_eq-issue-88384.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e7b7d5e1c9199f372107e0ace1733c11d09fe37/src%2Ftest%2Fui%2Fconsts%2Frefs_check_const_eq-issue-88384.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frefs_check_const_eq-issue-88384.stderr?ref=9e7b7d5e1c9199f372107e0ace1733c11d09fe37", "patch": "@@ -1,11 +1,24 @@\n warning: the feature `adt_const_params` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/refs_check_const_eq-issue-88384.rs:4:12\n+  --> $DIR/refs_check_const_eq-issue-88384.rs:2:12\n    |\n LL | #![feature(adt_const_params)]\n    |            ^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #95174 <https://github.com/rust-lang/rust/issues/95174> for more information\n \n-warning: 1 warning emitted\n+error[E0741]: using function pointers as const generic parameters is forbidden\n+  --> $DIR/refs_check_const_eq-issue-88384.rs:10:21\n+   |\n+LL | struct Foo<const T: CompileTimeSettings>;\n+   |                     ^^^^^^^^^^^^^^^^^^^\n+\n+error[E0741]: using function pointers as const generic parameters is forbidden\n+  --> $DIR/refs_check_const_eq-issue-88384.rs:13:15\n+   |\n+LL | impl<const T: CompileTimeSettings> Foo<T> {\n+   |               ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n \n+For more information about this error, try `rustc --explain E0741`."}]}