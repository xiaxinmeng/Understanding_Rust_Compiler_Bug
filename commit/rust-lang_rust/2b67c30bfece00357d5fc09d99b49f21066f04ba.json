{"sha": "2b67c30bfece00357d5fc09d99b49f21066f04ba", "node_id": "C_kwDOAAsO6NoAKDJiNjdjMzBiZmVjZTAwMzU3ZDVmYzA5ZDk5YjQ5ZjIxMDY2ZjA0YmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-29T12:07:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-29T12:07:33Z"}, "message": "Auto merge of #92397 - matthiaskrgr:rollup-xnfou17, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #92075 (rustdoc: Only special case struct fields for intra-doc links, not enum variants)\n - #92118 (Parse and suggest moving where clauses after equals for type aliases)\n - #92237 (Visit expressions in-order when resolving pattern bindings)\n - #92340 (rustdoc: Start cleaning up search index generation)\n - #92351 (Add long error explanation for E0227)\n - #92371 (Remove pretty printer space inside block with only outer attrs)\n - #92372 (Print space after formal generic params in fn type)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ad36e3e5492f2cd163e10b47db2b0bc3359ef337", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad36e3e5492f2cd163e10b47db2b0bc3359ef337"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b67c30bfece00357d5fc09d99b49f21066f04ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b67c30bfece00357d5fc09d99b49f21066f04ba", "html_url": "https://github.com/rust-lang/rust/commit/2b67c30bfece00357d5fc09d99b49f21066f04ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b67c30bfece00357d5fc09d99b49f21066f04ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6211dd7250e9b8e80733f74911ca88c661adb1a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6211dd7250e9b8e80733f74911ca88c661adb1a9", "html_url": "https://github.com/rust-lang/rust/commit/6211dd7250e9b8e80733f74911ca88c661adb1a9"}, {"sha": "949769cf3bb3f81293fbdaaac64d38bd97942158", "url": "https://api.github.com/repos/rust-lang/rust/commits/949769cf3bb3f81293fbdaaac64d38bd97942158", "html_url": "https://github.com/rust-lang/rust/commit/949769cf3bb3f81293fbdaaac64d38bd97942158"}], "stats": {"total": 512, "additions": 382, "deletions": 130}, "files": [{"sha": "f0c1d017326cddcf4964e61f43346783cab3b37a", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -387,23 +387,23 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         self.print_string(sym.as_str(), style);\n     }\n \n-    fn print_inner_attributes(&mut self, attrs: &[ast::Attribute]) {\n+    fn print_inner_attributes(&mut self, attrs: &[ast::Attribute]) -> bool {\n         self.print_either_attributes(attrs, ast::AttrStyle::Inner, false, true)\n     }\n \n-    fn print_inner_attributes_no_trailing_hardbreak(&mut self, attrs: &[ast::Attribute]) {\n+    fn print_inner_attributes_no_trailing_hardbreak(&mut self, attrs: &[ast::Attribute]) -> bool {\n         self.print_either_attributes(attrs, ast::AttrStyle::Inner, false, false)\n     }\n \n-    fn print_outer_attributes(&mut self, attrs: &[ast::Attribute]) {\n+    fn print_outer_attributes(&mut self, attrs: &[ast::Attribute]) -> bool {\n         self.print_either_attributes(attrs, ast::AttrStyle::Outer, false, true)\n     }\n \n-    fn print_inner_attributes_inline(&mut self, attrs: &[ast::Attribute]) {\n+    fn print_inner_attributes_inline(&mut self, attrs: &[ast::Attribute]) -> bool {\n         self.print_either_attributes(attrs, ast::AttrStyle::Inner, true, true)\n     }\n \n-    fn print_outer_attributes_inline(&mut self, attrs: &[ast::Attribute]) {\n+    fn print_outer_attributes_inline(&mut self, attrs: &[ast::Attribute]) -> bool {\n         self.print_either_attributes(attrs, ast::AttrStyle::Outer, true, true)\n     }\n \n@@ -413,20 +413,21 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         kind: ast::AttrStyle,\n         is_inline: bool,\n         trailing_hardbreak: bool,\n-    ) {\n-        let mut count = 0;\n+    ) -> bool {\n+        let mut printed = false;\n         for attr in attrs {\n             if attr.style == kind {\n                 self.print_attribute_inline(attr, is_inline);\n                 if is_inline {\n                     self.nbsp();\n                 }\n-                count += 1;\n+                printed = true;\n             }\n         }\n-        if count > 0 && trailing_hardbreak && !is_inline {\n+        if printed && trailing_hardbreak && !is_inline {\n             self.hardbreak_if_not_bol();\n         }\n+        printed\n     }\n \n     fn print_attribute(&mut self, attr: &ast::Attribute) {\n@@ -1646,7 +1647,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Block(blk));\n         self.bopen();\n \n-        self.print_inner_attributes(attrs);\n+        let has_attrs = self.print_inner_attributes(attrs);\n \n         for (i, st) in blk.stmts.iter().enumerate() {\n             match st.kind {\n@@ -1660,7 +1661,7 @@ impl<'a> State<'a> {\n             }\n         }\n \n-        let empty = attrs.is_empty() && blk.stmts.is_empty();\n+        let empty = !has_attrs && blk.stmts.is_empty();\n         self.bclose_maybe_open(blk.span, empty, close_box);\n         self.ann.post(self, AnnNode::Block(blk))\n     }\n@@ -2780,34 +2781,34 @@ impl<'a> State<'a> {\n                 self.word_space(\",\");\n             }\n \n-            match *predicate {\n-                ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n-                    ref bound_generic_params,\n-                    ref bounded_ty,\n-                    ref bounds,\n-                    ..\n-                }) => {\n-                    self.print_formal_generic_params(bound_generic_params);\n-                    self.print_type(bounded_ty);\n-                    self.print_type_bounds(\":\", bounds);\n-                }\n-                ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n-                    ref lifetime,\n-                    ref bounds,\n-                    ..\n-                }) => {\n-                    self.print_lifetime_bounds(*lifetime, bounds);\n-                }\n-                ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n-                    ref lhs_ty,\n-                    ref rhs_ty,\n-                    ..\n-                }) => {\n-                    self.print_type(lhs_ty);\n-                    self.space();\n-                    self.word_space(\"=\");\n-                    self.print_type(rhs_ty);\n-                }\n+            self.print_where_predicate(predicate);\n+        }\n+    }\n+\n+    pub fn print_where_predicate(&mut self, predicate: &ast::WherePredicate) {\n+        match predicate {\n+            ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                bound_generic_params,\n+                bounded_ty,\n+                bounds,\n+                ..\n+            }) => {\n+                self.print_formal_generic_params(bound_generic_params);\n+                self.print_type(bounded_ty);\n+                self.print_type_bounds(\":\", bounds);\n+            }\n+            ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n+                lifetime,\n+                bounds,\n+                ..\n+            }) => {\n+                self.print_lifetime_bounds(*lifetime, bounds);\n+            }\n+            ast::WherePredicate::EqPredicate(ast::WhereEqPredicate { lhs_ty, rhs_ty, .. }) => {\n+                self.print_type(lhs_ty);\n+                self.space();\n+                self.word_space(\"=\");\n+                self.print_type(rhs_ty);\n             }\n         }\n     }\n@@ -2908,10 +2909,7 @@ impl<'a> State<'a> {\n         generic_params: &[ast::GenericParam],\n     ) {\n         self.ibox(INDENT_UNIT);\n-        if !generic_params.is_empty() {\n-            self.word(\"for\");\n-            self.print_generic_params(generic_params);\n-        }\n+        self.print_formal_generic_params(generic_params);\n         let generics = ast::Generics {\n             params: Vec::new(),\n             where_clause: ast::WhereClause {"}, {"sha": "79d9c55b5470b731fb8415b6fae3442f5c09ac0c", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -120,6 +120,7 @@ E0223: include_str!(\"./error_codes/E0223.md\"),\n E0224: include_str!(\"./error_codes/E0224.md\"),\n E0225: include_str!(\"./error_codes/E0225.md\"),\n E0226: include_str!(\"./error_codes/E0226.md\"),\n+E0227: include_str!(\"./error_codes/E0227.md\"),\n E0228: include_str!(\"./error_codes/E0228.md\"),\n E0229: include_str!(\"./error_codes/E0229.md\"),\n E0230: include_str!(\"./error_codes/E0230.md\"),\n@@ -530,7 +531,6 @@ E0786: include_str!(\"./error_codes/E0786.md\"),\n //  E0217, // ambiguous associated type, defined in multiple supertraits\n //  E0218, // no associated type defined\n //  E0219, // associated type defined in higher-ranked supertrait\n-    E0227, // ambiguous lifetime bound, explicit lifetime bound required\n //  E0233,\n //  E0234,\n //  E0235, // structure constructor specifies a structure of type but"}, {"sha": "f68614723d4430ed7c265b684bb88d714230ed71", "filename": "compiler/rustc_error_codes/src/error_codes/E0227.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0227.md", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0227.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0227.md?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -0,0 +1,33 @@\n+This error indicates that the compiler is unable to determine whether there is\n+exactly one unique region in the set of derived region bounds.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0227\n+trait Foo<'foo>: 'foo {}\n+trait Bar<'bar>: 'bar {}\n+\n+trait FooBar<'foo, 'bar>: Foo<'foo> + Bar<'bar> {}\n+\n+struct Baz<'foo, 'bar> {\n+    baz: dyn FooBar<'foo, 'bar>,\n+}\n+```\n+\n+Here, `baz` can have either `'foo` or `'bar` lifetimes.\n+\n+To resolve this error, provide an explicit lifetime:\n+\n+```rust\n+trait Foo<'foo>: 'foo {}\n+trait Bar<'bar>: 'bar {}\n+\n+trait FooBar<'foo, 'bar>: Foo<'foo> + Bar<'bar> {}\n+\n+struct Baz<'foo, 'bar, 'baz>\n+where\n+    'baz: 'foo + 'bar,\n+{\n+    obj: dyn FooBar<'foo, 'bar> + 'baz,\n+}\n+```"}, {"sha": "334fa6f4e5ccf6d226e4d32bf0a6db32e6fc03fe", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -2327,10 +2327,7 @@ impl<'a> State<'a> {\n         arg_names: &[Ident],\n     ) {\n         self.ibox(INDENT_UNIT);\n-        if !generic_params.is_empty() {\n-            self.word(\"for\");\n-            self.print_generic_params(generic_params);\n-        }\n+        self.print_formal_generic_params(generic_params);\n         let generics = hir::Generics {\n             params: &[],\n             where_clause: hir::WhereClause { predicates: &[], span: rustc_span::DUMMY_SP },"}, {"sha": "d335ef8788b87f9910147da2475ee2d2d96a0b0c", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -794,6 +794,44 @@ impl<'a> Parser<'a> {\n         ))\n     }\n \n+    /// Emits an error that the where clause at the end of a type alias is not\n+    /// allowed and suggests moving it.\n+    fn error_ty_alias_where(\n+        &self,\n+        before_where_clause_present: bool,\n+        before_where_clause_span: Span,\n+        after_predicates: &[WherePredicate],\n+        after_where_clause_span: Span,\n+    ) {\n+        let mut err =\n+            self.struct_span_err(after_where_clause_span, \"where clause not allowed here\");\n+        if !after_predicates.is_empty() {\n+            let mut state = crate::pprust::State::new();\n+            if !before_where_clause_present {\n+                state.space();\n+                state.word_space(\"where\");\n+            } else {\n+                state.word_space(\",\");\n+            }\n+            let mut first = true;\n+            for p in after_predicates.iter() {\n+                if !first {\n+                    state.word_space(\",\");\n+                }\n+                first = false;\n+                state.print_where_predicate(p);\n+            }\n+            let suggestion = state.s.eof();\n+            err.span_suggestion(\n+                before_where_clause_span.shrink_to_hi(),\n+                \"move it here\",\n+                suggestion,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        err.emit()\n+    }\n+\n     /// Parses a `type` alias with the following grammar:\n     /// ```\n     /// TypeAlias = \"type\" Ident Generics {\":\" GenericBounds}? {\"=\" Ty}? \";\" ;\n@@ -806,9 +844,24 @@ impl<'a> Parser<'a> {\n         // Parse optional colon and param bounds.\n         let bounds =\n             if self.eat(&token::Colon) { self.parse_generic_bounds(None)? } else { Vec::new() };\n+\n         generics.where_clause = self.parse_where_clause()?;\n \n         let ty = if self.eat(&token::Eq) { Some(self.parse_ty()?) } else { None };\n+\n+        if self.token.is_keyword(kw::Where) {\n+            let after_where_clause = self.parse_where_clause()?;\n+\n+            self.error_ty_alias_where(\n+                generics.where_clause.has_where_token,\n+                generics.where_clause.span,\n+                &after_where_clause.predicates,\n+                after_where_clause.span,\n+            );\n+\n+            generics.where_clause.predicates.extend(after_where_clause.predicates.into_iter());\n+        }\n+\n         self.expect_semi()?;\n \n         Ok((ident, ItemKind::TyAlias(Box::new(TyAlias { defaultness, generics, bounds, ty }))))"}, {"sha": "5098cef11e83b4b793d90f8948370bff30fe367d", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -1603,10 +1603,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         pat_src: PatternSource,\n         bindings: &mut SmallVec<[(PatBoundCtx, FxHashSet<Ident>); 1]>,\n     ) {\n+        // We walk the pattern before declaring the pattern's inner bindings,\n+        // so that we avoid resolving a literal expression to a binding defined\n+        // by the pattern.\n+        visit::walk_pat(self, pat);\n         self.resolve_pattern_inner(pat, pat_src, bindings);\n         // This has to happen *after* we determine which pat_idents are variants:\n         self.check_consistent_bindings_top(pat);\n-        visit::walk_pat(self, pat);\n     }\n \n     /// Resolve bindings in a pattern. This is a helper to `resolve_pattern`."}, {"sha": "2b1a1d4a600d64f84ea9a9a03defb2a9140ceee9", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -39,7 +39,6 @@ use crate::clean::Clean;\n use crate::core::DocContext;\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n-use crate::html::render::cache::ExternalLocation;\n use crate::html::render::Context;\n use crate::passes::collect_intra_doc_links::UrlFragment;\n \n@@ -339,6 +338,16 @@ impl ExternalCrate {\n     }\n }\n \n+/// Indicates where an external crate can be found.\n+crate enum ExternalLocation {\n+    /// Remote URL root of the external crate\n+    Remote(String),\n+    /// This external crate can be found in the local doc/ folder\n+    Local,\n+    /// The external crate could not be found.\n+    Unknown,\n+}\n+\n /// Anything with a source location and set of attributes and, optionally, a\n /// name. That is, anything that can be documented. This doesn't correspond\n /// directly to the AST's concept of an item; it's a strict superset."}, {"sha": "6b9ccd37cfb371196476b7c65fb1738541202d33", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -6,13 +6,13 @@ use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n-use crate::clean::{self, ExternalCrate, ItemId, PrimitiveType};\n+use crate::clean::{self, types::ExternalLocation, ExternalCrate, ItemId, PrimitiveType};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::formats::item_type::ItemType;\n use crate::formats::Impl;\n use crate::html::markdown::short_markdown_summary;\n-use crate::html::render::cache::{get_index_search_type, ExternalLocation};\n+use crate::html::render::search_index::get_function_type_for_search;\n use crate::html::render::IndexItem;\n \n /// This cache is used to store information about the [`clean::Crate`] being\n@@ -303,7 +303,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                             desc,\n                             parent,\n                             parent_idx: None,\n-                            search_type: get_index_search_type(&item, self.tcx, self.cache),\n+                            search_type: get_function_type_for_search(&item, self.tcx),\n                             aliases: item.attrs.get_doc_aliases(),\n                         });\n                     }"}, {"sha": "3a7c7186877e232cec28e2651e5a5a2706642f51", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -21,10 +21,12 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::CRATE_DEF_INDEX;\n use rustc_target::spec::abi::Abi;\n \n-use crate::clean::{self, utils::find_nearest_parent_module, ExternalCrate, ItemId, PrimitiveType};\n+use crate::clean::{\n+    self, types::ExternalLocation, utils::find_nearest_parent_module, ExternalCrate, ItemId,\n+    PrimitiveType,\n+};\n use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n-use crate::html::render::cache::ExternalLocation;\n use crate::html::render::Context;\n \n use super::url_parts_builder::UrlPartsBuilder;"}, {"sha": "534a542d58ed0b596e5ffe754128715b5ea80fb9", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -13,16 +13,16 @@ use rustc_span::edition::Edition;\n use rustc_span::source_map::FileName;\n use rustc_span::symbol::sym;\n \n-use super::cache::{build_index, ExternalLocation};\n use super::print_item::{full_path, item_path, print_item};\n+use super::search_index::build_index;\n use super::templates;\n use super::write_shared::write_shared;\n use super::{\n     collect_spans_and_sources, print_sidebar, settings, AllTypes, LinkFromSrc, NameDoc, StylePath,\n     BASIC_KEYWORDS,\n };\n \n-use crate::clean::{self, ExternalCrate};\n+use crate::clean::{self, types::ExternalLocation, ExternalCrate};\n use crate::config::RenderOptions;\n use crate::docfs::{DocFS, PathError};\n use crate::error::Error;"}, {"sha": "3e7711181f730b7c5210639ddd48d2d449635b7a", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -23,7 +23,7 @@\n //! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n-crate mod cache;\n+crate mod search_index;\n \n #[cfg(test)]\n mod tests;"}, {"sha": "0fbe090f2190abf831d04d0e3c3b0a6968930ebb", "filename": "src/librustdoc/html/render/search_index.rs", "status": "renamed", "additions": 33, "deletions": 39, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -7,22 +7,12 @@ use rustc_span::symbol::Symbol;\n use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n-use crate::clean::types::{FnDecl, FnRetTy, GenericBound, Generics, Type, WherePredicate};\n+use crate::clean::types::{FnRetTy, Function, GenericBound, Generics, Type, WherePredicate};\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::markdown::short_markdown_summary;\n use crate::html::render::{IndexItem, IndexItemFunctionType, RenderType, TypeWithKind};\n \n-/// Indicates where an external crate can be found.\n-crate enum ExternalLocation {\n-    /// Remote URL root of the external crate\n-    Remote(String),\n-    /// This external crate can be found in the local doc/ folder\n-    Local,\n-    /// The external crate could not be found.\n-    Unknown,\n-}\n-\n /// Builds the search index from the collected metadata\n crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<'tcx>) -> String {\n     let mut defid_to_pathid = FxHashMap::default();\n@@ -42,7 +32,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n                 desc,\n                 parent: Some(did),\n                 parent_idx: None,\n-                search_type: get_index_search_type(item, tcx, cache),\n+                search_type: get_function_type_for_search(item, tcx),\n                 aliases: item.attrs.get_doc_aliases(),\n             });\n         }\n@@ -191,15 +181,14 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n     )\n }\n \n-crate fn get_index_search_type<'tcx>(\n+crate fn get_function_type_for_search<'tcx>(\n     item: &clean::Item,\n     tcx: TyCtxt<'tcx>,\n-    cache: &Cache,\n ) -> Option<IndexItemFunctionType> {\n     let (mut inputs, mut output) = match *item.kind {\n-        clean::FunctionItem(ref f) => get_all_types(&f.generics, &f.decl, tcx, cache),\n-        clean::MethodItem(ref m, _) => get_all_types(&m.generics, &m.decl, tcx, cache),\n-        clean::TyMethodItem(ref m) => get_all_types(&m.generics, &m.decl, tcx, cache),\n+        clean::FunctionItem(ref f) => get_fn_inputs_and_outputs(f, tcx),\n+        clean::MethodItem(ref m, _) => get_fn_inputs_and_outputs(m, tcx),\n+        clean::TyMethodItem(ref m) => get_fn_inputs_and_outputs(m, tcx),\n         _ => return None,\n     };\n \n@@ -211,12 +200,12 @@ crate fn get_index_search_type<'tcx>(\n \n fn get_index_type(clean_type: &clean::Type, generics: Vec<TypeWithKind>) -> RenderType {\n     RenderType {\n-        name: get_index_type_name(clean_type, true).map(|s| s.as_str().to_ascii_lowercase()),\n+        name: get_index_type_name(clean_type).map(|s| s.as_str().to_ascii_lowercase()),\n         generics: if generics.is_empty() { None } else { Some(generics) },\n     }\n }\n \n-fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option<Symbol> {\n+fn get_index_type_name(clean_type: &clean::Type) -> Option<Symbol> {\n     match *clean_type {\n         clean::Type::Path { ref path, .. } => {\n             let path_segment = path.segments.last().unwrap();\n@@ -226,11 +215,10 @@ fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option\n             let path = &bounds[0].trait_;\n             Some(path.segments.last().unwrap().name)\n         }\n-        clean::Generic(s) if accept_generic => Some(s),\n+        clean::Generic(s) => Some(s),\n         clean::Primitive(ref p) => Some(p.as_sym()),\n-        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_, accept_generic),\n-        clean::Generic(_)\n-        | clean::BareFunction(_)\n+        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_),\n+        clean::BareFunction(_)\n         | clean::Tuple(_)\n         | clean::Slice(_)\n         | clean::Array(_, _)\n@@ -248,20 +236,19 @@ fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option\n ///\n /// Important note: It goes through generics recursively. So if you have\n /// `T: Option<Result<(), ()>>`, it'll go into `Option` and then into `Result`.\n-crate fn get_real_types<'tcx>(\n+#[instrument(level = \"trace\", skip(tcx, res))]\n+fn add_generics_and_bounds_as_types<'tcx>(\n     generics: &Generics,\n     arg: &Type,\n     tcx: TyCtxt<'tcx>,\n     recurse: usize,\n     res: &mut Vec<TypeWithKind>,\n-    cache: &Cache,\n ) {\n     fn insert_ty(\n         res: &mut Vec<TypeWithKind>,\n         tcx: TyCtxt<'_>,\n         ty: Type,\n         mut generics: Vec<TypeWithKind>,\n-        _cache: &Cache,\n     ) {\n         let is_full_generic = ty.is_full_generic();\n \n@@ -330,6 +317,7 @@ crate fn get_real_types<'tcx>(\n \n     if recurse >= 10 {\n         // FIXME: remove this whole recurse thing when the recursion bug is fixed\n+        // See #59502 for the original issue.\n         return;\n     }\n \n@@ -350,32 +338,37 @@ crate fn get_real_types<'tcx>(\n                     for param_def in poly_trait.generic_params.iter() {\n                         match &param_def.kind {\n                             clean::GenericParamDefKind::Type { default: Some(ty), .. } => {\n-                                get_real_types(\n+                                add_generics_and_bounds_as_types(\n                                     generics,\n                                     ty,\n                                     tcx,\n                                     recurse + 1,\n                                     &mut ty_generics,\n-                                    cache,\n                                 )\n                             }\n                             _ => {}\n                         }\n                     }\n                 }\n             }\n-            insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n+            insert_ty(res, tcx, arg.clone(), ty_generics);\n         }\n         // Otherwise we check if the trait bounds are \"inlined\" like `T: Option<u32>`...\n         if let Some(bound) = generics.params.iter().find(|g| g.is_type() && g.name == arg_s) {\n             let mut ty_generics = Vec::new();\n             for bound in bound.get_bounds().unwrap_or(&[]) {\n                 if let Some(path) = bound.get_trait_path() {\n                     let ty = Type::Path { path };\n-                    get_real_types(generics, &ty, tcx, recurse + 1, &mut ty_generics, cache);\n+                    add_generics_and_bounds_as_types(\n+                        generics,\n+                        &ty,\n+                        tcx,\n+                        recurse + 1,\n+                        &mut ty_generics,\n+                    );\n                 }\n             }\n-            insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n+            insert_ty(res, tcx, arg.clone(), ty_generics);\n         }\n     } else {\n         // This is not a type parameter. So for example if we have `T, U: Option<T>`, and we're\n@@ -386,30 +379,31 @@ crate fn get_real_types<'tcx>(\n         let mut ty_generics = Vec::new();\n         if let Some(arg_generics) = arg.generics() {\n             for gen in arg_generics.iter() {\n-                get_real_types(generics, gen, tcx, recurse + 1, &mut ty_generics, cache);\n+                add_generics_and_bounds_as_types(generics, gen, tcx, recurse + 1, &mut ty_generics);\n             }\n         }\n-        insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n+        insert_ty(res, tcx, arg.clone(), ty_generics);\n     }\n }\n \n /// Return the full list of types when bounds have been resolved.\n ///\n /// i.e. `fn foo<A: Display, B: Option<A>>(x: u32, y: B)` will return\n /// `[u32, Display, Option]`.\n-crate fn get_all_types<'tcx>(\n-    generics: &Generics,\n-    decl: &FnDecl,\n+fn get_fn_inputs_and_outputs<'tcx>(\n+    func: &Function,\n     tcx: TyCtxt<'tcx>,\n-    cache: &Cache,\n ) -> (Vec<TypeWithKind>, Vec<TypeWithKind>) {\n+    let decl = &func.decl;\n+    let generics = &func.generics;\n+\n     let mut all_types = Vec::new();\n     for arg in decl.inputs.values.iter() {\n         if arg.type_.is_self_type() {\n             continue;\n         }\n         let mut args = Vec::new();\n-        get_real_types(generics, &arg.type_, tcx, 0, &mut args, cache);\n+        add_generics_and_bounds_as_types(generics, &arg.type_, tcx, 0, &mut args);\n         if !args.is_empty() {\n             all_types.extend(args);\n         } else {\n@@ -423,7 +417,7 @@ crate fn get_all_types<'tcx>(\n     let mut ret_types = Vec::new();\n     match decl.output {\n         FnRetTy::Return(ref return_type) => {\n-            get_real_types(generics, return_type, tcx, 0, &mut ret_types, cache);\n+            add_generics_and_bounds_as_types(generics, return_type, tcx, 0, &mut ret_types);\n             if ret_types.is_empty() {\n                 if let Some(kind) =\n                     return_type.def_id_no_primitives().map(|did| tcx.def_kind(did).into())", "previous_filename": "src/librustdoc/html/render/cache.rs"}, {"sha": "005da01b52b6c43813e1d109a45a8be51c99e2a2", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -19,12 +19,11 @@ use rustc_session::Session;\n use rustdoc_json_types as types;\n \n use crate::clean;\n-use crate::clean::ExternalCrate;\n+use crate::clean::types::{ExternalCrate, ExternalLocation};\n use crate::config::RenderOptions;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n use crate::formats::FormatRenderer;\n-use crate::html::render::cache::ExternalLocation;\n use crate::json::conversions::{from_item_id, IntoWithTcx};\n \n #[derive(Clone)]"}, {"sha": "10ef92e5f400f2817e576ee32b8606d824c2e9e0", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -684,27 +684,36 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 if ns != Namespace::ValueNS {\n                     return None;\n                 }\n-                debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n+                debug!(\"looking for fields named {} for {:?}\", item_name, did);\n                 // FIXME: this doesn't really belong in `associated_item` (maybe `variant_field` is better?)\n-                // NOTE: it's different from variant_field because it resolves fields and variants,\n+                // NOTE: it's different from variant_field because it only resolves struct fields,\n                 // not variant fields (2 path segments, not 3).\n+                //\n+                // We need to handle struct (and union) fields in this code because\n+                // syntactically their paths are identical to associated item paths:\n+                // `module::Type::field` and `module::Type::Assoc`.\n+                //\n+                // On the other hand, variant fields can't be mistaken for associated\n+                // items because they look like this: `module::Type::Variant::field`.\n+                //\n+                // Variants themselves don't need to be handled here, even though\n+                // they also look like associated items (`module::Type::Variant`),\n+                // because they are real Rust syntax (unlike the intra-doc links\n+                // field syntax) and are handled by the compiler's resolver.\n                 let def = match tcx.type_of(did).kind() {\n-                    ty::Adt(def, _) => def,\n+                    ty::Adt(def, _) if !def.is_enum() => def,\n                     _ => return None,\n                 };\n-                let field = if def.is_enum() {\n-                    def.all_fields().find(|item| item.ident.name == item_name)\n-                } else {\n-                    def.non_enum_variant().fields.iter().find(|item| item.ident.name == item_name)\n-                }?;\n-                let kind = if def.is_enum() { DefKind::Variant } else { DefKind::Field };\n-                let fragment = if def.is_enum() {\n-                    // FIXME: how can the field be a variant?\n-                    UrlFragment::Variant(field.ident.name)\n-                } else {\n-                    UrlFragment::StructField(field.ident.name)\n-                };\n-                Some((root_res, fragment, Some((kind, field.did))))\n+                let field = def\n+                    .non_enum_variant()\n+                    .fields\n+                    .iter()\n+                    .find(|item| item.ident.name == item_name)?;\n+                Some((\n+                    root_res,\n+                    UrlFragment::StructField(field.ident.name),\n+                    Some((DefKind::Field, field.did)),\n+                ))\n             }\n             Res::Def(DefKind::Trait, did) => tcx\n                 .associated_items(did)"}, {"sha": "6d9cb89f022987e6b6d63cfb97218b28bcc09ed1", "filename": "src/test/pretty/attr-fn-inner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fpretty%2Fattr-fn-inner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fpretty%2Fattr-fn-inner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fattr-fn-inner.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -9,8 +9,8 @@\n fn main() {\n     #![rustc_dummy]\n     #[rustc_dummy]\n-    fn f() { }\n+    fn f() {}\n \n     #[rustc_dummy]\n-    fn g() { }\n+    fn g() {}\n }"}, {"sha": "d132014420df9aee90581da15c224fdf1c06e2dd", "filename": "src/test/pretty/attr-literals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fpretty%2Fattr-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fpretty%2Fattr-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fattr-literals.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -7,8 +7,8 @@\n fn main() {\n     #![rustc_dummy(\"hi\", 1, 2, 1.012, pi = 3.14, bye, name(\"John\"))]\n     #[rustc_dummy = 8]\n-    fn f() { }\n+    fn f() {}\n \n     #[rustc_dummy(1, 2, 3)]\n-    fn g() { }\n+    fn g() {}\n }"}, {"sha": "8486342b0879f0c2f371cc6cfa15dc2639e195cb", "filename": "src/test/pretty/attr-tokens-raw-ident.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fpretty%2Fattr-tokens-raw-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fpretty%2Fattr-tokens-raw-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fattr-tokens-raw-ident.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -4,4 +4,4 @@\n // pp-exact\n \n #[rustfmt::r#final(final)]\n-fn main() { }\n+fn main() {}"}, {"sha": "1137d8045648920697911ee34dd97200170c9b91", "filename": "src/test/pretty/delimited-token-groups.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fpretty%2Fdelimited-token-groups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fpretty%2Fdelimited-token-groups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdelimited-token-groups.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -45,4 +45,4 @@ mac! {\n   }]\n #[rustc_dummy =\n   \"aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa\"]\n-fn main() { }\n+fn main() {}"}, {"sha": "a49860daa6ad6e0f7781384cedbf90d38908aa4e", "filename": "src/test/pretty/doc-comments.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fpretty%2Fdoc-comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fpretty%2Fdoc-comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdoc-comments.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -5,7 +5,7 @@\n // some single-line non-doc comment\n \n /// some single line outer-docs\n-fn a() { }\n+fn a() {}\n \n fn b() {\n     //! some single line inner-docs\n@@ -17,7 +17,7 @@ fn b() {\n //////////////////////////////////\n /// some single-line outer-docs preceded by a separator\n /// (and trailing whitespaces)\n-fn c() { }\n+fn c() {}\n \n /*\n  * some multi-line non-doc comment\n@@ -26,7 +26,7 @@ fn c() { }\n /**\n  * some multi-line outer-docs\n  */\n-fn d() { }\n+fn d() {}\n \n fn e() {\n     /*!\n@@ -43,10 +43,10 @@ fn e() {\n /**\n  * some multi-line outer-docs preceded by a separator\n  */\n-fn f() { }\n+fn f() {}\n \n #[doc = \"unsugared outer doc-comments work also\"]\n-fn g() { }\n+fn g() {}\n \n fn h() {\n     #![doc = \"as do inner ones\"]"}, {"sha": "ce51556dd418b4cac6a207a38cbb466aa55c04d9", "filename": "src/test/rustdoc-ui/search-index-generics-recursion-bug-issue-59502.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Frustdoc-ui%2Fsearch-index-generics-recursion-bug-issue-59502.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Frustdoc-ui%2Fsearch-index-generics-recursion-bug-issue-59502.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fsearch-index-generics-recursion-bug-issue-59502.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+// Minimization of issue #59502\n+\n+trait MyTrait<T> {\n+    type Output;\n+}\n+\n+pub fn pow<T: MyTrait<T, Output = T>>(arg: T) -> T {\n+    arg\n+}"}, {"sha": "0f0a781d2f9d30b46dc24369cb7b7e29aa6f9f45", "filename": "src/test/ui/error-codes/E0227.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Ferror-codes%2FE0227.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Ferror-codes%2FE0227.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0227.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -0,0 +1,12 @@\n+trait Foo<'foo>: 'foo {}\n+trait Bar<'bar>: 'bar {}\n+\n+trait FooBar<'foo, 'bar>: Foo<'foo> + Bar<'bar> {}\n+\n+struct Baz<'foo, 'bar> {\n+    baz: dyn FooBar<'foo, 'bar>,\n+    //~^ ERROR ambiguous lifetime bound, explicit lifetime bound required\n+}\n+\n+fn main() {\n+}"}, {"sha": "26de5b4c40015e794abc6feec91130b10d51d1c3", "filename": "src/test/ui/error-codes/E0227.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Ferror-codes%2FE0227.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Ferror-codes%2FE0227.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0227.stderr?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -0,0 +1,9 @@\n+error[E0227]: ambiguous lifetime bound, explicit lifetime bound required\n+  --> $DIR/E0227.rs:7:10\n+   |\n+LL |     baz: dyn FooBar<'foo, 'bar>,\n+   |          ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0227`."}, {"sha": "90bc7dc1da2398445779b8e49320727266ec0a3e", "filename": "src/test/ui/macros/stringify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -235,7 +235,7 @@ fn test_expr() {\n             #[attr]\n             {}\n         ),\n-        \"#[attr] { }\", // FIXME\n+        \"#[attr] {}\",\n     );\n     assert_eq!(\n         stringify_expr!(\n@@ -803,7 +803,7 @@ fn test_ty() {\n     assert_eq!(stringify_ty!(fn(x: u8)), \"fn(x: u8)\");\n     #[rustfmt::skip]\n     assert_eq!(stringify_ty!(for<> fn()), \"fn()\");\n-    assert_eq!(stringify_ty!(for<'a> fn()), \"for<'a>fn()\"); // FIXME\n+    assert_eq!(stringify_ty!(for<'a> fn()), \"for<'a> fn()\");\n \n     // TyKind::Never\n     assert_eq!(stringify_ty!(!), \"!\");"}, {"sha": "47db6c3f4880d2cc3c0e375e0ae67f29c772a113", "filename": "src/test/ui/match/expr_before_ident_pat.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Fmatch%2Fexpr_before_ident_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Fmatch%2Fexpr_before_ident_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fexpr_before_ident_pat.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -0,0 +1,15 @@\n+#![feature(half_open_range_patterns)]\n+\n+macro_rules! funny {\n+    ($a:expr, $b:ident) => {\n+        match [1, 2] {\n+            [$a, $b] => {}\n+        }\n+    };\n+}\n+\n+fn main() {\n+    funny!(a, a);\n+    //~^ ERROR cannot find value `a` in this scope\n+    //~| ERROR arbitrary expressions aren't allowed in patterns\n+}"}, {"sha": "1ac8274ffd5dbc41de7af64561cdb609ea799696", "filename": "src/test/ui/match/expr_before_ident_pat.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Fmatch%2Fexpr_before_ident_pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Fmatch%2Fexpr_before_ident_pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fexpr_before_ident_pat.stderr?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -0,0 +1,15 @@\n+error: arbitrary expressions aren't allowed in patterns\n+  --> $DIR/expr_before_ident_pat.rs:12:12\n+   |\n+LL |     funny!(a, a);\n+   |            ^\n+\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/expr_before_ident_pat.rs:12:12\n+   |\n+LL |     funny!(a, a);\n+   |            ^ not found in this scope\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "021166b2ba5609622578d79101873432a767b447", "filename": "src/test/ui/match/issue-92100.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Fmatch%2Fissue-92100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Fmatch%2Fissue-92100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fissue-92100.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -0,0 +1,7 @@\n+#![feature(half_open_range_patterns)]\n+\n+fn main() {\n+    match [1, 2] {\n+        [a.., a] => {} //~ ERROR cannot find value `a` in this scope\n+    }\n+}"}, {"sha": "0f694c587fcb413263291915d1eb3a12322057c9", "filename": "src/test/ui/match/issue-92100.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Fmatch%2Fissue-92100.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Fmatch%2Fissue-92100.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fissue-92100.stderr?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/issue-92100.rs:5:10\n+   |\n+LL |         [a.., a] => {}\n+   |          ^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "a9fa23dd95ef4eceda62e7de1c2d340ef88f09ad", "filename": "src/test/ui/parser/type-alias-where.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Fparser%2Ftype-alias-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Fparser%2Ftype-alias-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftype-alias-where.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -0,0 +1,37 @@\n+// check-fail\n+\n+#![feature(generic_associated_types)]\n+\n+// Fine, but lints as unused\n+type Foo where u32: Copy = ();\n+// Not fine.\n+type Bar = () where u32: Copy;\n+//~^ ERROR where clause not allowed here\n+type Baz = () where;\n+//~^ ERROR where clause not allowed here\n+\n+trait Trait {\n+    // Fine.\n+    type Assoc where u32: Copy;\n+    // Fine.\n+    type Assoc2 where u32: Copy, i32: Copy;\n+}\n+\n+impl Trait for u32 {\n+    // Fine.\n+    type Assoc where u32: Copy = ();\n+    // Not fine, suggests moving `i32: Copy`\n+    type Assoc2 where u32: Copy = () where i32: Copy;\n+    //~^ ERROR where clause not allowed here\n+}\n+\n+impl Trait for i32 {\n+    // Not fine, suggests moving `u32: Copy`\n+    type Assoc = () where u32: Copy;\n+    //~^ ERROR where clause not allowed here\n+    // Not fine, suggests moving both.\n+    type Assoc2 = () where u32: Copy, i32: Copy;\n+    //~^ ERROR where clause not allowed here\n+}\n+\n+fn main() {}"}, {"sha": "7ab0b28c8640a6539d3632ece12f32d6476cb22f", "filename": "src/test/ui/parser/type-alias-where.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Fparser%2Ftype-alias-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftest%2Fui%2Fparser%2Ftype-alias-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftype-alias-where.stderr?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -0,0 +1,40 @@\n+error: where clause not allowed here\n+  --> $DIR/type-alias-where.rs:8:15\n+   |\n+LL | type Bar = () where u32: Copy;\n+   |         -     ^^^^^^^^^^^^^^^\n+   |         |\n+   |         help: move it here: `where u32: Copy`\n+\n+error: where clause not allowed here\n+  --> $DIR/type-alias-where.rs:10:15\n+   |\n+LL | type Baz = () where;\n+   |               ^^^^^\n+\n+error: where clause not allowed here\n+  --> $DIR/type-alias-where.rs:24:38\n+   |\n+LL |     type Assoc2 where u32: Copy = () where i32: Copy;\n+   |                                -     ^^^^^^^^^^^^^^^\n+   |                                |\n+   |                                help: move it here: `, i32: Copy`\n+\n+error: where clause not allowed here\n+  --> $DIR/type-alias-where.rs:30:21\n+   |\n+LL |     type Assoc = () where u32: Copy;\n+   |               -     ^^^^^^^^^^^^^^^\n+   |               |\n+   |               help: move it here: `where u32: Copy`\n+\n+error: where clause not allowed here\n+  --> $DIR/type-alias-where.rs:33:22\n+   |\n+LL |     type Assoc2 = () where u32: Copy, i32: Copy;\n+   |                -     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                |\n+   |                help: move it here: `where u32: Copy, i32: Copy`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "8ea6bb308b7bac4a2bad4c12672b0fa9c9810af6", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67c30bfece00357d5fc09d99b49f21066f04ba/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=2b67c30bfece00357d5fc09d99b49f21066f04ba", "patch": "@@ -10,8 +10,8 @@ use regex::Regex;\n \n // A few of those error codes can't be tested but all the others can and *should* be tested!\n const EXEMPTED_FROM_TEST: &[&str] = &[\n-    \"E0227\", \"E0279\", \"E0280\", \"E0313\", \"E0377\", \"E0461\", \"E0462\", \"E0465\", \"E0476\", \"E0514\",\n-    \"E0519\", \"E0523\", \"E0554\", \"E0640\", \"E0717\", \"E0729\",\n+    \"E0279\", \"E0280\", \"E0313\", \"E0377\", \"E0461\", \"E0462\", \"E0465\", \"E0476\", \"E0514\", \"E0519\",\n+    \"E0523\", \"E0554\", \"E0640\", \"E0717\", \"E0729\",\n ];\n \n // Some error codes don't have any tests apparently..."}]}