{"sha": "ceaec9d8666614f6e84506b84f4b740538cb6d50", "node_id": "C_kwDOAAsO6NoAKGNlYWVjOWQ4NjY2NjE0ZjZlODQ1MDZiODRmNGI3NDA1MzhjYjZkNTA", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-20T15:17:16Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-20T15:17:30Z"}, "message": "internal: Replace Vec with Box in hir Pat", "tree": {"sha": "bde18860aaf5b70b5485dc1e6262ac3a6aabc533", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bde18860aaf5b70b5485dc1e6262ac3a6aabc533"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ceaec9d8666614f6e84506b84f4b740538cb6d50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ceaec9d8666614f6e84506b84f4b740538cb6d50", "html_url": "https://github.com/rust-lang/rust/commit/ceaec9d8666614f6e84506b84f4b740538cb6d50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ceaec9d8666614f6e84506b84f4b740538cb6d50/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc327774b7e188a15f96e1ab34fe7a1e972a5b0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a", "html_url": "https://github.com/rust-lang/rust/commit/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a"}], "stats": {"total": 80, "additions": 33, "deletions": 47}, "files": [{"sha": "e322a953844aeb709ad320b24e1d9a3096c57790", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ceaec9d8666614f6e84506b84f4b740538cb6d50/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaec9d8666614f6e84506b84f4b740538cb6d50/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=ceaec9d8666614f6e84506b84f4b740538cb6d50", "patch": "@@ -813,7 +813,7 @@ impl ExprCollector<'_> {\n             ast::Pat::RecordPat(p) => {\n                 let path =\n                     p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n-                let args: Vec<_> = p\n+                let args = p\n                     .record_pat_field_list()\n                     .expect(\"every struct should have a field list\")\n                     .fields()\n@@ -903,7 +903,7 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>) -> (Vec<PatId>, Option<usize>) {\n+    fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>) -> (Box<[PatId]>, Option<usize>) {\n         // Find the location of the `..`, if there is one. Note that we do not\n         // consider the possibility of there being multiple `..` here.\n         let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::RestPat(_)));\n@@ -962,7 +962,7 @@ impl From<ast::LiteralKind> for Literal {\n                 Literal::Float(Default::default(), ty)\n             }\n             LiteralKind::ByteString(bs) => {\n-                let text = bs.value().map(Vec::from).unwrap_or_else(Default::default);\n+                let text = bs.value().map(Box::from).unwrap_or_else(Default::default);\n                 Literal::ByteString(text)\n             }\n             LiteralKind::String(_) => Literal::String(Default::default()),"}, {"sha": "e6518c3e2d784021921ddac0510de9d15cfdd6bf", "filename": "crates/hir_def/src/expr.rs", "status": "modified", "additions": 26, "deletions": 40, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ceaec9d8666614f6e84506b84f4b740538cb6d50/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaec9d8666614f6e84506b84f4b740538cb6d50/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fexpr.rs?ref=ceaec9d8666614f6e84506b84f4b740538cb6d50", "patch": "@@ -41,7 +41,7 @@ pub type LabelId = Idx<Label>;\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Literal {\n     String(String),\n-    ByteString(Vec<u8>),\n+    ByteString(Box<[u8]>),\n     Char(char),\n     Bool(bool),\n     Int(i128, Option<BuiltinInt>),\n@@ -182,7 +182,7 @@ pub enum Expr {\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Array {\n-    ElementList(Vec<ExprId>),\n+    ElementList(Box<[ExprId]>),\n     Repeat { initializer: ExprId, repeat: ExprId },\n }\n \n@@ -228,23 +228,23 @@ impl Expr {\n             Expr::If { condition, then_branch, else_branch } => {\n                 f(*condition);\n                 f(*then_branch);\n-                if let Some(else_branch) = else_branch {\n-                    f(*else_branch);\n+                if let &Some(else_branch) = else_branch {\n+                    f(else_branch);\n                 }\n             }\n             Expr::Block { statements, tail, .. } => {\n                 for stmt in statements.iter() {\n                     match stmt {\n                         Statement::Let { initializer, .. } => {\n-                            if let Some(expr) = initializer {\n-                                f(*expr);\n+                            if let &Some(expr) = initializer {\n+                                f(expr);\n                             }\n                         }\n                         Statement::Expr { expr: expression, .. } => f(*expression),\n                     }\n                 }\n-                if let Some(expr) = tail {\n-                    f(*expr);\n+                if let &Some(expr) = tail {\n+                    f(expr);\n                 }\n             }\n             Expr::TryBlock { body }\n@@ -262,34 +262,28 @@ impl Expr {\n             }\n             Expr::Call { callee, args } => {\n                 f(*callee);\n-                for arg in args.iter() {\n-                    f(*arg);\n-                }\n+                args.iter().copied().for_each(f);\n             }\n             Expr::MethodCall { receiver, args, .. } => {\n                 f(*receiver);\n-                for arg in args.iter() {\n-                    f(*arg);\n-                }\n+                args.iter().copied().for_each(f);\n             }\n             Expr::Match { expr, arms } => {\n                 f(*expr);\n-                for arm in arms.iter() {\n-                    f(arm.expr);\n-                }\n+                arms.iter().map(|arm| arm.expr).for_each(f);\n             }\n             Expr::Continue { .. } => {}\n             Expr::Break { expr, .. } | Expr::Return { expr } | Expr::Yield { expr } => {\n-                if let Some(expr) = expr {\n-                    f(*expr);\n+                if let &Some(expr) = expr {\n+                    f(expr);\n                 }\n             }\n             Expr::RecordLit { fields, spread, .. } => {\n                 for field in fields.iter() {\n                     f(field.expr);\n                 }\n-                if let Some(expr) = spread {\n-                    f(*expr);\n+                if let &Some(expr) = spread {\n+                    f(expr);\n                 }\n             }\n             Expr::Lambda { body, .. } => {\n@@ -300,11 +294,11 @@ impl Expr {\n                 f(*rhs);\n             }\n             Expr::Range { lhs, rhs, .. } => {\n-                if let Some(lhs) = rhs {\n-                    f(*lhs);\n+                if let &Some(lhs) = rhs {\n+                    f(lhs);\n                 }\n-                if let Some(rhs) = lhs {\n-                    f(*rhs);\n+                if let &Some(rhs) = lhs {\n+                    f(rhs);\n                 }\n             }\n             Expr::Index { base, index } => {\n@@ -320,17 +314,9 @@ impl Expr {\n             | Expr::Box { expr } => {\n                 f(*expr);\n             }\n-            Expr::Tuple { exprs } => {\n-                for expr in exprs.iter() {\n-                    f(*expr);\n-                }\n-            }\n+            Expr::Tuple { exprs } => exprs.iter().copied().for_each(f),\n             Expr::Array(a) => match a {\n-                Array::ElementList(exprs) => {\n-                    for expr in exprs {\n-                        f(*expr);\n-                    }\n-                }\n+                Array::ElementList(exprs) => exprs.iter().copied().for_each(f),\n                 Array::Repeat { initializer, repeat } => {\n                     f(*initializer);\n                     f(*repeat)\n@@ -386,15 +372,15 @@ pub struct RecordFieldPat {\n pub enum Pat {\n     Missing,\n     Wild,\n-    Tuple { args: Vec<PatId>, ellipsis: Option<usize> },\n-    Or(Vec<PatId>),\n-    Record { path: Option<Box<Path>>, args: Vec<RecordFieldPat>, ellipsis: bool },\n+    Tuple { args: Box<[PatId]>, ellipsis: Option<usize> },\n+    Or(Box<[PatId]>),\n+    Record { path: Option<Box<Path>>, args: Box<[RecordFieldPat]>, ellipsis: bool },\n     Range { start: ExprId, end: ExprId },\n-    Slice { prefix: Vec<PatId>, slice: Option<PatId>, suffix: Vec<PatId> },\n+    Slice { prefix: Box<[PatId]>, slice: Option<PatId>, suffix: Box<[PatId]> },\n     Path(Box<Path>),\n     Lit(ExprId),\n     Bind { mode: BindingAnnotation, name: Name, subpat: Option<PatId> },\n-    TupleStruct { path: Option<Box<Path>>, args: Vec<PatId>, ellipsis: Option<usize> },\n+    TupleStruct { path: Option<Box<Path>>, args: Box<[PatId]>, ellipsis: Option<usize> },\n     Ref { pat: PatId, mutability: Mutability },\n     Box { inner: PatId },\n     ConstBlock(ExprId),"}, {"sha": "cc919327457aad2e46159f245a83458b57376075", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ceaec9d8666614f6e84506b84f4b740538cb6d50/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaec9d8666614f6e84506b84f4b740538cb6d50/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=ceaec9d8666614f6e84506b84f4b740538cb6d50", "patch": "@@ -226,17 +226,17 @@ impl<'a> InferenceContext<'a> {\n                     _ => self.err_ty(),\n                 };\n \n-                for pat_id in prefix.iter().chain(suffix) {\n-                    self.infer_pat(*pat_id, &elem_ty, default_bm);\n+                for &pat_id in prefix.iter().chain(suffix.iter()) {\n+                    self.infer_pat(pat_id, &elem_ty, default_bm);\n                 }\n \n                 let pat_ty = match expected.kind(&Interner) {\n                     TyKind::Array(_, const_) => TyKind::Array(elem_ty, const_.clone()),\n                     _ => TyKind::Slice(elem_ty),\n                 }\n                 .intern(&Interner);\n-                if let Some(slice_pat_id) = slice {\n-                    self.infer_pat(*slice_pat_id, &pat_ty, default_bm);\n+                if let &Some(slice_pat_id) = slice {\n+                    self.infer_pat(slice_pat_id, &pat_ty, default_bm);\n                 }\n \n                 pat_ty"}]}