{"sha": "7a641cb14525d1111d24e9060ebe07c3ce10ab83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNjQxY2IxNDUyNWQxMTExZDI0ZTkwNjBlYmUwN2MzY2UxMGFiODM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-07T09:29:25Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T14:31:49Z"}, "message": "make `TypeOp` implement debug instead of carrying a closure\n\nThis allows us to avoid some silly clones etc.", "tree": {"sha": "e838f169bd93e24cfc523dbc6b157b3e2c2eef18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e838f169bd93e24cfc523dbc6b157b3e2c2eef18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a641cb14525d1111d24e9060ebe07c3ce10ab83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a641cb14525d1111d24e9060ebe07c3ce10ab83", "html_url": "https://github.com/rust-lang/rust/commit/7a641cb14525d1111d24e9060ebe07c3ce10ab83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a641cb14525d1111d24e9060ebe07c3ce10ab83/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7a9e7aef2f90dd3e166be0c42570a70890d5dce", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a9e7aef2f90dd3e166be0c42570a70890d5dce", "html_url": "https://github.com/rust-lang/rust/commit/e7a9e7aef2f90dd3e166be0c42570a70890d5dce"}], "stats": {"total": 198, "additions": 98, "deletions": 100}, "files": [{"sha": "2523711f936e1bc80578105de2bb234062dc192c", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a641cb14525d1111d24e9060ebe07c3ce10ab83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a641cb14525d1111d24e9060ebe07c3ce10ab83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=7a641cb14525d1111d24e9060ebe07c3ce10ab83", "patch": "@@ -12,7 +12,7 @@ use borrow_check::location::{LocationIndex, LocationTable};\n use dataflow::indexes::BorrowIndex;\n use polonius_engine::AllFacts as PoloniusAllFacts;\n use polonius_engine::Atom;\n-use rustc::ty::RegionVid;\n+use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n use std::error::Error;\n use std::fmt::Debug;"}, {"sha": "afc21948e402581aa52d6c95e70aa57d16292aa3", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 62, "deletions": 57, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/7a641cb14525d1111d24e9060ebe07c3ce10ab83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a641cb14525d1111d24e9060ebe07c3ce10ab83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=7a641cb14525d1111d24e9060ebe07c3ce10ab83", "patch": "@@ -80,63 +80,66 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let anon_type_map =\n             self.fully_perform_op(\n                 Locations::All,\n-                || format!(\"input_output\"),\n-                CustomTypeOp::new(|cx| {\n-                    let mut obligations = ObligationAccumulator::default();\n-\n-                    let dummy_body_id = ObligationCause::dummy().body_id;\n-                    let (output_ty, anon_type_map) = obligations.add(infcx.instantiate_anon_types(\n-                        mir_def_id,\n-                        dummy_body_id,\n-                        cx.param_env,\n-                        &output_ty,\n-                    ));\n-                    debug!(\n-                        \"equate_inputs_and_outputs: instantiated output_ty={:?}\",\n-                        output_ty\n-                    );\n-                    debug!(\n-                        \"equate_inputs_and_outputs: anon_type_map={:#?}\",\n-                        anon_type_map\n-                    );\n-\n-                    debug!(\n-                        \"equate_inputs_and_outputs: mir_output_ty={:?}\",\n-                        mir_output_ty\n-                    );\n-                    obligations.add(\n-                        infcx\n-                            .at(&ObligationCause::dummy(), cx.param_env)\n-                            .eq(output_ty, mir_output_ty)?,\n-                    );\n-\n-                    for (&anon_def_id, anon_decl) in &anon_type_map {\n-                        let anon_defn_ty = tcx.type_of(anon_def_id);\n-                        let anon_defn_ty = anon_defn_ty.subst(tcx, anon_decl.substs);\n-                        let anon_defn_ty = renumber::renumber_regions(\n-                            cx.infcx,\n-                            TyContext::Location(Location::START),\n-                            &anon_defn_ty,\n+                CustomTypeOp::new(\n+                    |cx| {\n+                        let mut obligations = ObligationAccumulator::default();\n+\n+                        let dummy_body_id = ObligationCause::dummy().body_id;\n+                        let (output_ty, anon_type_map) =\n+                            obligations.add(infcx.instantiate_anon_types(\n+                                mir_def_id,\n+                                dummy_body_id,\n+                                cx.param_env,\n+                                &output_ty,\n+                            ));\n+                        debug!(\n+                            \"equate_inputs_and_outputs: instantiated output_ty={:?}\",\n+                            output_ty\n                         );\n                         debug!(\n-                            \"equate_inputs_and_outputs: concrete_ty={:?}\",\n-                            anon_decl.concrete_ty\n+                            \"equate_inputs_and_outputs: anon_type_map={:#?}\",\n+                            anon_type_map\n+                        );\n+\n+                        debug!(\n+                            \"equate_inputs_and_outputs: mir_output_ty={:?}\",\n+                            mir_output_ty\n                         );\n-                        debug!(\"equate_inputs_and_outputs: anon_defn_ty={:?}\", anon_defn_ty);\n                         obligations.add(\n                             infcx\n                                 .at(&ObligationCause::dummy(), cx.param_env)\n-                                .eq(anon_decl.concrete_ty, anon_defn_ty)?,\n+                                .eq(output_ty, mir_output_ty)?,\n                         );\n-                    }\n-\n-                    debug!(\"equate_inputs_and_outputs: equated\");\n \n-                    Ok(InferOk {\n-                        value: Some(anon_type_map),\n-                        obligations: obligations.into_vec(),\n-                    })\n-                }),\n+                        for (&anon_def_id, anon_decl) in &anon_type_map {\n+                            let anon_defn_ty = tcx.type_of(anon_def_id);\n+                            let anon_defn_ty = anon_defn_ty.subst(tcx, anon_decl.substs);\n+                            let anon_defn_ty = renumber::renumber_regions(\n+                                cx.infcx,\n+                                TyContext::Location(Location::START),\n+                                &anon_defn_ty,\n+                            );\n+                            debug!(\n+                                \"equate_inputs_and_outputs: concrete_ty={:?}\",\n+                                anon_decl.concrete_ty\n+                            );\n+                            debug!(\"equate_inputs_and_outputs: anon_defn_ty={:?}\", anon_defn_ty);\n+                            obligations.add(\n+                                infcx\n+                                    .at(&ObligationCause::dummy(), cx.param_env)\n+                                    .eq(anon_decl.concrete_ty, anon_defn_ty)?,\n+                            );\n+                        }\n+\n+                        debug!(\"equate_inputs_and_outputs: equated\");\n+\n+                        Ok(InferOk {\n+                            value: Some(anon_type_map),\n+                            obligations: obligations.into_vec(),\n+                        })\n+                    },\n+                    || format!(\"input_output\"),\n+                ),\n             ).unwrap_or_else(|terr| {\n                 span_mirbug!(\n                     self,\n@@ -156,14 +159,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         if let Some(anon_type_map) = anon_type_map {\n             self.fully_perform_op(\n                 Locations::All,\n-                || format!(\"anon_type_map\"),\n-                CustomTypeOp::new(|_cx| {\n-                    infcx.constrain_anon_types(&anon_type_map, universal_regions);\n-                    Ok(InferOk {\n-                        value: (),\n-                        obligations: vec![],\n-                    })\n-                }),\n+                CustomTypeOp::new(\n+                    |_cx| {\n+                        infcx.constrain_anon_types(&anon_type_map, universal_regions);\n+                        Ok(InferOk {\n+                            value: (),\n+                            obligations: vec![],\n+                        })\n+                    },\n+                    || format!(\"anon_type_map\"),\n+                ),\n             ).unwrap();\n         }\n     }"}, {"sha": "a032b2a9caabf95b23cf989093a53820ca867462", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7a641cb14525d1111d24e9060ebe07c3ce10ab83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a641cb14525d1111d24e9060ebe07c3ce10ab83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=7a641cb14525d1111d24e9060ebe07c3ce10ab83", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use borrow_check::nll::region_infer::Cause;\n-use borrow_check::nll::type_check::AtLocation;\n use borrow_check::nll::type_check::type_op::CustomTypeOp;\n+use borrow_check::nll::type_check::AtLocation;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use dataflow::MaybeInitializedPlaces;\n use dataflow::{FlowAtLocation, FlowsAtLocation};\n@@ -171,8 +171,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         );\n \n         cx.tcx().for_each_free_region(&value, |live_region| {\n-            cx\n-                .constraints\n+            cx.constraints\n                 .liveness_set\n                 .push((live_region, location, cause.clone()));\n         });\n@@ -219,15 +218,15 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         debug!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty,);\n \n         let (dropped_kinds, region_constraint_data) =\n-            cx.fully_perform_op_and_get_region_constraint_data(\n-                || format!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty),\n-                CustomTypeOp::new(|cx| {\n+            cx.fully_perform_op_and_get_region_constraint_data(CustomTypeOp::new(\n+                |cx| {\n                     Ok(cx\n                         .infcx\n                         .at(&ObligationCause::dummy(), cx.param_env)\n                         .dropck_outlives(dropped_ty))\n-                }),\n-            ).unwrap();\n+                },\n+                || format!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty),\n+            )).unwrap();\n \n         DropData {\n             dropped_kinds,"}, {"sha": "959532fff8da57051a4abf7476b790b9f485b08a", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7a641cb14525d1111d24e9060ebe07c3ce10ab83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a641cb14525d1111d24e9060ebe07c3ce10ab83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=7a641cb14525d1111d24e9060ebe07c3ce10ab83", "patch": "@@ -731,16 +731,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn fully_perform_op<R>(\n         &mut self,\n         locations: Locations,\n-        describe_op: impl Fn() -> String,\n         op: impl type_op::TypeOp<'gcx, 'tcx, Output = R>,\n     ) -> Result<R, TypeError<'tcx>> {\n         match op.trivial_noop() {\n             Ok(r) => Ok(r),\n             Err(op) => {\n-                let (r, opt_data) = self.fully_perform_op_and_get_region_constraint_data(\n-                    || format!(\"{} at {:?}\", describe_op(), locations),\n-                    op,\n-                )?;\n+                let (r, opt_data) = self.fully_perform_op_and_get_region_constraint_data(op)?;\n \n                 if let Some(data) = opt_data {\n                     self.push_region_constraints(locations, data);\n@@ -781,14 +777,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     /// be generated there, so this can be useful for caching.\n     fn fully_perform_op_and_get_region_constraint_data<R>(\n         &mut self,\n-        describe_op: impl Fn() -> String,\n         op: impl type_op::TypeOp<'gcx, 'tcx, Output = R>,\n     ) -> Result<(R, Option<Rc<RegionConstraintData<'tcx>>>), TypeError<'tcx>> {\n         if cfg!(debug_assertions) {\n-            info!(\n-                \"fully_perform_op_and_get_region_constraint_data({})\",\n-                describe_op(),\n-            );\n+            info!(\"fully_perform_op_and_get_region_constraint_data({:?})\", op,);\n         }\n \n         let mut fulfill_cx = TraitEngine::new(self.infcx.tcx);\n@@ -822,20 +814,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         locations: Locations,\n     ) -> UnitResult<'tcx> {\n         let param_env = self.param_env;\n-        self.fully_perform_op(\n-            locations,\n-            || format!(\"sub_types({:?} <: {:?})\", sub, sup),\n-            type_op::Subtype::new(param_env, sub, sup),\n-        )\n+        self.fully_perform_op(locations, type_op::Subtype::new(param_env, sub, sup))\n     }\n \n     fn eq_types(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, locations: Locations) -> UnitResult<'tcx> {\n         let param_env = self.param_env;\n-        self.fully_perform_op(\n-            locations,\n-            || format!(\"eq_types({:?} = {:?})\", a, b),\n-            type_op::Eq::new(param_env, b, a),\n-        )\n+        self.fully_perform_op(locations, type_op::Eq::new(param_env, b, a))\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -1614,7 +1598,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let param_env = self.param_env;\n         self.fully_perform_op(\n             location.at_self(),\n-            || format!(\"prove_predicates({:?})\", predicates_vec),\n             type_op::ProvePredicates::new(param_env, predicates),\n         ).unwrap()\n     }\n@@ -1651,10 +1634,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"normalize(value={:?}, location={:?})\", value, location);\n         let param_env = self.param_env;\n-        let value1 = value.clone(); // FIXME move describe into type_op\n         self.fully_perform_op(\n             location.to_locations(),\n-            || format!(\"normalize(value={:?})\", value1),\n             type_op::Normalize::new(param_env, value),\n         ).unwrap()\n     }"}, {"sha": "ff008d39d49b2b41324cb67146400dba5209c70c", "filename": "src/librustc_mir/borrow_check/nll/type_check/type_op.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7a641cb14525d1111d24e9060ebe07c3ce10ab83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a641cb14525d1111d24e9060ebe07c3ce10ab83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op.rs?ref=7a641cb14525d1111d24e9060ebe07c3ce10ab83", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{ParamEnv, Predicate, Ty};\n use std::fmt;\n \n-pub(super) trait TypeOp<'gcx, 'tcx>: Sized {\n+pub(super) trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n     type Output;\n \n     /// Micro-optimization: returns `Ok(x)` if we can trivially\n@@ -30,22 +30,25 @@ pub(super) trait TypeOp<'gcx, 'tcx>: Sized {\n     ) -> InferResult<'tcx, Self::Output>;\n }\n \n-pub(super) struct CustomTypeOp<F> {\n+pub(super) struct CustomTypeOp<F, G> {\n     closure: F,\n+    description: G,\n }\n \n-impl<F> CustomTypeOp<F> {\n-    pub(super) fn new<'gcx, 'tcx, R>(closure: F) -> Self\n+impl<F, G> CustomTypeOp<F, G> {\n+    pub(super) fn new<'gcx, 'tcx, R>(closure: F, description: G) -> Self\n     where\n         F: FnOnce(&mut TypeChecker<'_, 'gcx, 'tcx>) -> InferResult<'tcx, R>,\n+        G: Fn() -> String,\n     {\n-        CustomTypeOp { closure }\n+        CustomTypeOp { closure, description }\n     }\n }\n \n-impl<'gcx, 'tcx, F, R> TypeOp<'gcx, 'tcx> for CustomTypeOp<F>\n+impl<'gcx, 'tcx, F, R, G> TypeOp<'gcx, 'tcx> for CustomTypeOp<F, G>\n where\n     F: FnOnce(&mut TypeChecker<'_, 'gcx, 'tcx>) -> InferResult<'tcx, R>,\n+    G: Fn() -> String,\n {\n     type Output = R;\n \n@@ -58,7 +61,16 @@ where\n     }\n }\n \n-pub(super) trait InfcxTypeOp<'gcx, 'tcx>: Sized {\n+impl<F, G> fmt::Debug for CustomTypeOp<F, G>\n+where\n+    G: Fn() -> String,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", (self.description)())\n+    }\n+}\n+\n+pub(super) trait InfcxTypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n     type Output;\n \n     /// Micro-optimization: returns `Ok(x)` if we can trivially\n@@ -87,6 +99,7 @@ where\n     }\n }\n \n+#[derive(Debug)]\n pub(super) struct Subtype<'tcx> {\n     param_env: ParamEnv<'tcx>,\n     sub: Ty<'tcx>,\n@@ -121,6 +134,7 @@ impl<'gcx, 'tcx> InfcxTypeOp<'gcx, 'tcx> for Subtype<'tcx> {\n     }\n }\n \n+#[derive(Debug)]\n pub(super) struct Eq<'tcx> {\n     param_env: ParamEnv<'tcx>,\n     a: Ty<'tcx>,\n@@ -151,6 +165,7 @@ impl<'gcx, 'tcx> InfcxTypeOp<'gcx, 'tcx> for Eq<'tcx> {\n     }\n }\n \n+#[derive(Debug)]\n pub(super) struct ProvePredicates<'tcx> {\n     obligations: Vec<PredicateObligation<'tcx>>,\n }\n@@ -188,6 +203,7 @@ impl<'gcx, 'tcx> InfcxTypeOp<'gcx, 'tcx> for ProvePredicates<'tcx> {\n     }\n }\n \n+#[derive(Debug)]\n pub(super) struct Normalize<'tcx, T> {\n     param_env: ParamEnv<'tcx>,\n     value: T,\n@@ -221,10 +237,7 @@ where\n             .at(&ObligationCause::dummy(), self.param_env)\n             .normalize(&self.value)\n             .unwrap_or_else(|NoSolution| {\n-                bug!(\n-                    \"normalization of `{:?}` failed\",\n-                    self.value,\n-                );\n+                bug!(\"normalization of `{:?}` failed\", self.value,);\n             });\n         Ok(InferOk { value, obligations })\n     }"}]}