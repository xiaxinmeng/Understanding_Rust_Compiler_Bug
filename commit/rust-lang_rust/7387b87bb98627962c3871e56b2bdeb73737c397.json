{"sha": "7387b87bb98627962c3871e56b2bdeb73737c397", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczODdiODdiYjk4NjI3OTYyYzM4NzFlNTZiMmJkZWI3MzczN2MzOTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-30T21:58:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-30T21:58:09Z"}, "message": "Auto merge of #6197 - ThibsG:ImproveFilterNext, r=ebroto\n\nImprove suggestions for several lints\n\nThis PR is a follow-up of this [Zulip discussion](https://rust-lang.zulipchat.com/#narrow/stream/257328-clippy/topic/filter_next.20lint).\n\nIt unifies placeholders for `methods` module and improves several suggestions for `filter_next`, `filter_map_next` and `map_unwrap_or` lints.\n\nchangelog: none", "tree": {"sha": "153426cda227243435e8fd1654d144d4b945abcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/153426cda227243435e8fd1654d144d4b945abcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7387b87bb98627962c3871e56b2bdeb73737c397", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7387b87bb98627962c3871e56b2bdeb73737c397", "html_url": "https://github.com/rust-lang/rust/commit/7387b87bb98627962c3871e56b2bdeb73737c397", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7387b87bb98627962c3871e56b2bdeb73737c397/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0be654482cb33dc16d1d9aa5227aa73da46365fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0be654482cb33dc16d1d9aa5227aa73da46365fc", "html_url": "https://github.com/rust-lang/rust/commit/0be654482cb33dc16d1d9aa5227aa73da46365fc"}, {"sha": "c0dd1f9f7614d86c15fcccd4e0faabaa52c7c339", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0dd1f9f7614d86c15fcccd4e0faabaa52c7c339", "html_url": "https://github.com/rust-lang/rust/commit/c0dd1f9f7614d86c15fcccd4e0faabaa52c7c339"}], "stats": {"total": 521, "additions": 333, "deletions": 188}, "files": [{"sha": "3c3093e869c15a9e19d9a0866712edcb51d1f4c9", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -32,8 +32,7 @@ use crate::utils::{\n     is_copy, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath,\n     match_trait_method, match_type, match_var, method_calls, method_chain_args, paths, remove_blocks, return_ty,\n     single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then, sugg, walk_ptrs_ty_depth,\n-    SpanlessEq,\n+    span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, walk_ptrs_ty_depth, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -1735,7 +1734,7 @@ fn lint_or_fun_call<'tcx>(\n                     \"try this\",\n                     format!(\n                         \"{}.unwrap_or_default()\",\n-                        snippet_with_applicability(cx, self_expr.span, \"_\", &mut applicability)\n+                        snippet_with_applicability(cx, self_expr.span, \"..\", &mut applicability)\n                     ),\n                     applicability,\n                 );\n@@ -2142,7 +2141,7 @@ fn lint_clone_on_ref_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::\n             return;\n         };\n \n-        let snippet = snippet_with_macro_callsite(cx, arg.span, \"_\");\n+        let snippet = snippet_with_macro_callsite(cx, arg.span, \"..\");\n \n         span_lint_and_sugg(\n             cx,\n@@ -2178,9 +2177,9 @@ fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::E\n             \"try this\",\n             format!(\n                 \"{}.push_str({}{})\",\n-                snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability),\n+                snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability),\n                 ref_str,\n-                snippet_with_applicability(cx, target.span, \"_\", &mut applicability)\n+                snippet_with_applicability(cx, target.span, \"..\", &mut applicability)\n             ),\n             applicability,\n         );\n@@ -2427,7 +2426,7 @@ fn lint_get_unwrap<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args:\n     let mut applicability = Applicability::MachineApplicable;\n     let expr_ty = cx.typeck_results().expr_ty(&get_args[0]);\n     let get_args_str = if get_args.len() > 1 {\n-        snippet_with_applicability(cx, get_args[1].span, \"_\", &mut applicability)\n+        snippet_with_applicability(cx, get_args[1].span, \"..\", &mut applicability)\n     } else {\n         return; // not linting on a .get().unwrap() chain or variant\n     };\n@@ -2487,7 +2486,7 @@ fn lint_get_unwrap<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args:\n         format!(\n             \"{}{}[{}]\",\n             borrow_str,\n-            snippet_with_applicability(cx, get_args[0].span, \"_\", &mut applicability),\n+            snippet_with_applicability(cx, get_args[0].span, \"..\", &mut applicability),\n             get_args_str\n         ),\n         applicability,\n@@ -2503,7 +2502,7 @@ fn lint_iter_skip_next(cx: &LateContext<'_>, expr: &hir::Expr<'_>, skip_args: &[\n                 cx,\n                 ITER_SKIP_NEXT,\n                 expr.span.trim_start(caller.span).unwrap(),\n-                \"called `skip(x).next()` on an iterator\",\n+                \"called `skip(..).next()` on an iterator\",\n                 \"use `nth` instead\",\n                 hint,\n                 Applicability::MachineApplicable,\n@@ -2706,11 +2705,11 @@ fn lint_map_unwrap_or_else<'tcx>(\n \n         // lint message\n         let msg = if is_option {\n-            \"called `map(f).unwrap_or_else(g)` on an `Option` value. This can be done more directly by calling \\\n-            `map_or_else(g, f)` instead\"\n+            \"called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling \\\n+            `map_or_else(<g>, <f>)` instead\"\n         } else {\n-            \"called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling \\\n-            `.map_or_else(g, f)` instead\"\n+            \"called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling \\\n+            `.map_or_else(<g>, <f>)` instead\"\n         };\n         // get snippets for args to map() and unwrap_or_else()\n         let map_snippet = snippet(cx, map_args[1].span, \"..\");\n@@ -2720,16 +2719,15 @@ fn lint_map_unwrap_or_else<'tcx>(\n         let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n         let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n         if same_span && !multiline {\n-            span_lint_and_note(\n+            let var_snippet = snippet(cx, map_args[0].span, \"..\");\n+            span_lint_and_sugg(\n                 cx,\n                 MAP_UNWRAP_OR,\n                 expr.span,\n                 msg,\n-                None,\n-                &format!(\n-                    \"replace `map({0}).unwrap_or_else({1})` with `map_or_else({1}, {0})`\",\n-                    map_snippet, unwrap_snippet,\n-                ),\n+                \"try this\",\n+                format!(\"{}.map_or_else({}, {})\", var_snippet, unwrap_snippet, map_snippet),\n+                Applicability::MachineApplicable,\n             );\n             return true;\n         } else if same_span && multiline {\n@@ -2776,8 +2774,8 @@ fn lint_map_or_none<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n         if is_option {\n             let self_snippet = snippet(cx, map_or_args[0].span, \"..\");\n             let func_snippet = snippet(cx, map_or_args[2].span, \"..\");\n-            let msg = \"called `map_or(None, f)` on an `Option` value. This can be done more directly by calling \\\n-                       `and_then(f)` instead\";\n+            let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n+                       `and_then(..)` instead\";\n             (\n                 OPTION_MAP_OR_NONE,\n                 msg,\n@@ -2815,18 +2813,20 @@ fn lint_map_or_none<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n fn lint_filter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, filter_args: &'tcx [hir::Expr<'_>]) {\n     // lint if caller of `.filter().next()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n-                   `.find(p)` instead.\";\n+        let msg = \"called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n+                   `.find(..)` instead.\";\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n         if filter_snippet.lines().count() <= 1 {\n+            let iter_snippet = snippet(cx, filter_args[0].span, \"..\");\n             // add note if not multi-line\n-            span_lint_and_note(\n+            span_lint_and_sugg(\n                 cx,\n                 FILTER_NEXT,\n                 expr.span,\n                 msg,\n-                None,\n-                &format!(\"replace `filter({0}).next()` with `find({0})`\", filter_snippet),\n+                \"try this\",\n+                format!(\"{}.find({})\", iter_snippet, filter_snippet),\n+                Applicability::MachineApplicable,\n             );\n         } else {\n             span_lint(cx, FILTER_NEXT, expr.span, msg);\n@@ -2846,9 +2846,9 @@ fn lint_skip_while_next<'tcx>(\n             cx,\n             SKIP_WHILE_NEXT,\n             expr.span,\n-            \"called `skip_while(p).next()` on an `Iterator`\",\n+            \"called `skip_while(<p>).next()` on an `Iterator`\",\n             None,\n-            \"this is more succinctly expressed by calling `.find(!p)` instead\",\n+            \"this is more succinctly expressed by calling `.find(!<p>)` instead\",\n         );\n     }\n }\n@@ -2862,7 +2862,7 @@ fn lint_filter_map<'tcx>(\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter(p).map(q)` on an `Iterator`\";\n+        let msg = \"called `filter(..).map(..)` on an `Iterator`\";\n         let hint = \"this is more succinctly expressed by calling `.filter_map(..)` instead\";\n         span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n     }\n@@ -2871,17 +2871,19 @@ fn lint_filter_map<'tcx>(\n /// lint use of `filter_map().next()` for `Iterators`\n fn lint_filter_map_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, filter_args: &'tcx [hir::Expr<'_>]) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter_map(p).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n-                   `.find_map(p)` instead.\";\n+        let msg = \"called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n+                   `.find_map(..)` instead.\";\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n         if filter_snippet.lines().count() <= 1 {\n-            span_lint_and_note(\n+            let iter_snippet = snippet(cx, filter_args[0].span, \"..\");\n+            span_lint_and_sugg(\n                 cx,\n                 FILTER_MAP_NEXT,\n                 expr.span,\n                 msg,\n-                None,\n-                &format!(\"replace `filter_map({0}).next()` with `find_map({0})`\", filter_snippet),\n+                \"try this\",\n+                format!(\"{}.find_map({})\", iter_snippet, filter_snippet),\n+                Applicability::MachineApplicable,\n             );\n         } else {\n             span_lint(cx, FILTER_MAP_NEXT, expr.span, msg);\n@@ -2898,7 +2900,7 @@ fn lint_find_map<'tcx>(\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, &map_args[0], &paths::ITERATOR) {\n-        let msg = \"called `find(p).map(q)` on an `Iterator`\";\n+        let msg = \"called `find(..).map(..)` on an `Iterator`\";\n         let hint = \"this is more succinctly expressed by calling `.find_map(..)` instead\";\n         span_lint_and_help(cx, FIND_MAP, expr.span, msg, None, hint);\n     }\n@@ -2913,7 +2915,7 @@ fn lint_filter_map_map<'tcx>(\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter_map(p).map(q)` on an `Iterator`\";\n+        let msg = \"called `filter_map(..).map(..)` on an `Iterator`\";\n         let hint = \"this is more succinctly expressed by only calling `.filter_map(..)` instead\";\n         span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n     }\n@@ -2928,7 +2930,7 @@ fn lint_filter_flat_map<'tcx>(\n ) {\n     // lint if caller of `.filter().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter(p).flat_map(q)` on an `Iterator`\";\n+        let msg = \"called `filter(..).flat_map(..)` on an `Iterator`\";\n         let hint = \"this is more succinctly expressed by calling `.flat_map(..)` \\\n                     and filtering by returning `iter::empty()`\";\n         span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n@@ -2944,7 +2946,7 @@ fn lint_filter_map_flat_map<'tcx>(\n ) {\n     // lint if caller of `.filter_map().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter_map(p).flat_map(q)` on an `Iterator`\";\n+        let msg = \"called `filter_map(..).flat_map(..)` on an `Iterator`\";\n         let hint = \"this is more succinctly expressed by calling `.flat_map(..)` \\\n                     and filtering by returning `iter::empty()`\";\n         span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n@@ -3115,9 +3117,9 @@ fn lint_chars_cmp(\n                 \"like this\",\n                 format!(\"{}{}.{}({})\",\n                         if info.eq { \"\" } else { \"!\" },\n-                        snippet_with_applicability(cx, args[0][0].span, \"_\", &mut applicability),\n+                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n                         suggest,\n-                        snippet_with_applicability(cx, arg_char[0].span, \"_\", &mut applicability)),\n+                        snippet_with_applicability(cx, arg_char[0].span, \"..\", &mut applicability)),\n                 applicability,\n             );\n \n@@ -3164,7 +3166,7 @@ fn lint_chars_cmp_with_unwrap<'tcx>(\n                 \"like this\",\n                 format!(\"{}{}.{}('{}')\",\n                         if info.eq { \"\" } else { \"!\" },\n-                        snippet_with_applicability(cx, args[0][0].span, \"_\", &mut applicability),\n+                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n                         suggest,\n                         c),\n                 applicability,\n@@ -3239,7 +3241,7 @@ fn lint_single_char_pattern(cx: &LateContext<'_>, _expr: &hir::Expr<'_>, arg: &h\n fn lint_single_char_push_string(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let mut applicability = Applicability::MachineApplicable;\n     if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[1], &mut applicability) {\n-        let base_string_snippet = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n+        let base_string_snippet = snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability);\n         let sugg = format!(\"{}.push({})\", base_string_snippet, extension_string);\n         span_lint_and_sugg(\n             cx,\n@@ -3282,7 +3284,7 @@ fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_re\n                 expr.span,\n                 &format!(\"this call to `{}` does nothing\", call_name),\n                 \"try this\",\n-                snippet_with_applicability(cx, recvr.span, \"_\", &mut applicability).to_string(),\n+                snippet_with_applicability(cx, recvr.span, \"..\", &mut applicability).to_string(),\n                 applicability,\n             );\n         }"}, {"sha": "d30b85d6a78173677c1a4fd97f9b7e2acd889502", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -53,15 +53,15 @@ pub(super) fn lint<'tcx>(\n         // lint message\n         // comparing the snippet from source to raw text (\"None\") below is safe\n         // because we already have checked the type.\n-        let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"a\" };\n+        let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"<a>\" };\n         let unwrap_snippet_none = unwrap_snippet == \"None\";\n         let suggest = if unwrap_snippet_none {\n-            \"and_then(f)\"\n+            \"and_then(<f>)\"\n         } else {\n-            \"map_or(a, f)\"\n+            \"map_or(<a>, <f>)\"\n         };\n         let msg = &format!(\n-            \"called `map(f).unwrap_or({})` on an `Option` value. \\\n+            \"called `map(<f>).unwrap_or({})` on an `Option` value. \\\n             This can be done more directly by calling `{}` instead\",\n             arg, suggest\n         );"}, {"sha": "dbeb2354309c92bb4a66b2288ab2a7ec7ac905e5", "filename": "tests/ui/filter_map_next.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Ffilter_map_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Ffilter_map_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_map_next.rs?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -3,9 +3,6 @@\n fn main() {\n     let a = [\"1\", \"lol\", \"3\", \"NaN\", \"5\"];\n \n-    let element: Option<i32> = a.iter().filter_map(|s| s.parse().ok()).next();\n-    assert_eq!(element, Some(1));\n-\n     #[rustfmt::skip]\n     let _: Option<u32> = vec![1, 2, 3, 4, 5, 6]\n         .into_iter()"}, {"sha": "45427684d96e1c058ec0c0a25e31e64ed3af2852", "filename": "tests/ui/filter_map_next.stderr", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Ffilter_map_next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Ffilter_map_next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_map_next.stderr?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -1,14 +1,5 @@\n-error: called `filter_map(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find_map(p)` instead.\n-  --> $DIR/filter_map_next.rs:6:32\n-   |\n-LL |     let element: Option<i32> = a.iter().filter_map(|s| s.parse().ok()).next();\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::filter-map-next` implied by `-D warnings`\n-   = note: replace `filter_map(|s| s.parse().ok()).next()` with `find_map(|s| s.parse().ok())`\n-\n-error: called `filter_map(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find_map(p)` instead.\n-  --> $DIR/filter_map_next.rs:10:26\n+error: called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find_map(..)` instead.\n+  --> $DIR/filter_map_next.rs:7:26\n    |\n LL |       let _: Option<u32> = vec![1, 2, 3, 4, 5, 6]\n    |  __________________________^\n@@ -19,6 +10,8 @@ LL | |             if x == 2 {\n LL | |         })\n LL | |         .next();\n    | |_______________^\n+   |\n+   = note: `-D clippy::filter-map-next` implied by `-D warnings`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "c3992d7e92cf37c36d0c5568aa3a462bfcd2278b", "filename": "tests/ui/filter_map_next_fixable.fixed", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Ffilter_map_next_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Ffilter_map_next_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_map_next_fixable.fixed?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+\n+#![warn(clippy::all, clippy::pedantic)]\n+\n+fn main() {\n+    let a = [\"1\", \"lol\", \"3\", \"NaN\", \"5\"];\n+\n+    let element: Option<i32> = a.iter().find_map(|s| s.parse().ok());\n+    assert_eq!(element, Some(1));\n+}"}, {"sha": "447219a96839181630629af538bd834624f0bb51", "filename": "tests/ui/filter_map_next_fixable.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Ffilter_map_next_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Ffilter_map_next_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_map_next_fixable.rs?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+\n+#![warn(clippy::all, clippy::pedantic)]\n+\n+fn main() {\n+    let a = [\"1\", \"lol\", \"3\", \"NaN\", \"5\"];\n+\n+    let element: Option<i32> = a.iter().filter_map(|s| s.parse().ok()).next();\n+    assert_eq!(element, Some(1));\n+}"}, {"sha": "6c2530e0379e4fded306cb600956b395a3affb42", "filename": "tests/ui/filter_map_next_fixable.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Ffilter_map_next_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Ffilter_map_next_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_map_next_fixable.stderr?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -0,0 +1,10 @@\n+error: called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find_map(..)` instead.\n+  --> $DIR/filter_map_next_fixable.rs:8:32\n+   |\n+LL |     let element: Option<i32> = a.iter().filter_map(|s| s.parse().ok()).next();\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `a.iter().find_map(|s| s.parse().ok())`\n+   |\n+   = note: `-D clippy::filter-map-next` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "91718dd11755b75310056c4a60277da2b63e8329", "filename": "tests/ui/filter_methods.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Ffilter_methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Ffilter_methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_methods.stderr?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -1,4 +1,4 @@\n-error: called `filter(p).map(q)` on an `Iterator`\n+error: called `filter(..).map(..)` on an `Iterator`\n   --> $DIR/filter_methods.rs:5:21\n    |\n LL |     let _: Vec<_> = vec![5; 6].into_iter().filter(|&x| x == 0).map(|x| x * 2).collect();\n@@ -7,7 +7,7 @@ LL |     let _: Vec<_> = vec![5; 6].into_iter().filter(|&x| x == 0).map(|x| x *\n    = note: `-D clippy::filter-map` implied by `-D warnings`\n    = help: this is more succinctly expressed by calling `.filter_map(..)` instead\n \n-error: called `filter(p).flat_map(q)` on an `Iterator`\n+error: called `filter(..).flat_map(..)` on an `Iterator`\n   --> $DIR/filter_methods.rs:7:21\n    |\n LL |       let _: Vec<_> = vec![5_i8; 6]\n@@ -19,7 +19,7 @@ LL | |         .flat_map(|x| x.checked_mul(2))\n    |\n    = help: this is more succinctly expressed by calling `.flat_map(..)` and filtering by returning `iter::empty()`\n \n-error: called `filter_map(p).flat_map(q)` on an `Iterator`\n+error: called `filter_map(..).flat_map(..)` on an `Iterator`\n   --> $DIR/filter_methods.rs:13:21\n    |\n LL |       let _: Vec<_> = vec![5_i8; 6]\n@@ -31,7 +31,7 @@ LL | |         .flat_map(|x| x.checked_mul(2))\n    |\n    = help: this is more succinctly expressed by calling `.flat_map(..)` and filtering by returning `iter::empty()`\n \n-error: called `filter_map(p).map(q)` on an `Iterator`\n+error: called `filter_map(..).map(..)` on an `Iterator`\n   --> $DIR/filter_methods.rs:19:21\n    |\n LL |       let _: Vec<_> = vec![5_i8; 6]"}, {"sha": "aea3cc62afcc41631213bbafca089acc6f9b72b5", "filename": "tests/ui/find_map.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Ffind_map.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Ffind_map.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffind_map.stderr?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -1,4 +1,4 @@\n-error: called `find(p).map(q)` on an `Iterator`\n+error: called `find(..).map(..)` on an `Iterator`\n   --> $DIR/find_map.rs:20:26\n    |\n LL |     let _: Option<i32> = a.iter().find(|s| s.parse::<i32>().is_ok()).map(|s| s.parse().unwrap());\n@@ -7,7 +7,7 @@ LL |     let _: Option<i32> = a.iter().find(|s| s.parse::<i32>().is_ok()).map(|s\n    = note: `-D clippy::find-map` implied by `-D warnings`\n    = help: this is more succinctly expressed by calling `.find_map(..)` instead\n \n-error: called `find(p).map(q)` on an `Iterator`\n+error: called `find(..).map(..)` on an `Iterator`\n   --> $DIR/find_map.rs:23:29\n    |\n LL |       let _: Option<Flavor> = desserts_of_the_week"}, {"sha": "486de718bb563f9064338396bf07f16d1e7c7bfd", "filename": "tests/ui/iter_skip_next.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fiter_skip_next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fiter_skip_next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_skip_next.stderr?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -1,24 +1,24 @@\n-error: called `skip(x).next()` on an iterator\n+error: called `skip(..).next()` on an iterator\n   --> $DIR/iter_skip_next.rs:15:28\n    |\n LL |     let _ = some_vec.iter().skip(42).next();\n    |                            ^^^^^^^^^^^^^^^^ help: use `nth` instead: `.nth(42)`\n    |\n    = note: `-D clippy::iter-skip-next` implied by `-D warnings`\n \n-error: called `skip(x).next()` on an iterator\n+error: called `skip(..).next()` on an iterator\n   --> $DIR/iter_skip_next.rs:16:36\n    |\n LL |     let _ = some_vec.iter().cycle().skip(42).next();\n    |                                    ^^^^^^^^^^^^^^^^ help: use `nth` instead: `.nth(42)`\n \n-error: called `skip(x).next()` on an iterator\n+error: called `skip(..).next()` on an iterator\n   --> $DIR/iter_skip_next.rs:17:20\n    |\n LL |     let _ = (1..10).skip(10).next();\n    |                    ^^^^^^^^^^^^^^^^ help: use `nth` instead: `.nth(10)`\n \n-error: called `skip(x).next()` on an iterator\n+error: called `skip(..).next()` on an iterator\n   --> $DIR/iter_skip_next.rs:18:33\n    |\n LL |     let _ = &some_vec[..].iter().skip(3).next();"}, {"sha": "87e16f5d09bd75b03786b26e07b6a225510decd9", "filename": "tests/ui/map_unwrap_or.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmap_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmap_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_unwrap_or.rs?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -1,4 +1,3 @@\n-// FIXME: Add \"run-rustfix\" once it's supported for multipart suggestions\n // aux-build:option_helpers.rs\n \n #![warn(clippy::map_unwrap_or)]\n@@ -47,10 +46,6 @@ fn option_methods() {\n     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n \n     // Check for `option.map(_).unwrap_or_else(_)` use.\n-    // single line case\n-    let _ = opt.map(|x| x + 1)\n-        // Should lint even though this call is on a separate line.\n-        .unwrap_or_else(|| 0);\n     // Multi-line cases.\n     let _ = opt.map(|x| {\n         x + 1\n@@ -60,37 +55,24 @@ fn option_methods() {\n         .unwrap_or_else(||\n             0\n         );\n-    // Macro case.\n-    // Should not lint.\n-    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0);\n-\n-    // Issue #4144\n-    {\n-        let mut frequencies = HashMap::new();\n-        let word = \"foo\";\n-\n-        frequencies\n-            .get_mut(word)\n-            .map(|count| {\n-                *count += 1;\n-            })\n-            .unwrap_or_else(|| {\n-                frequencies.insert(word.to_owned(), 1);\n-            });\n-    }\n }\n \n+#[rustfmt::skip]\n fn result_methods() {\n     let res: Result<i32, ()> = Ok(1);\n \n     // Check for `result.map(_).unwrap_or_else(_)` use.\n-    // single line case\n-    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n-                                                      // multi line cases\n-    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n-    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n+    // multi line cases\n+    let _ = res.map(|x| {\n+        x + 1\n+    }\n+    ).unwrap_or_else(|_e| 0);\n+    let _ = res.map(|x| x + 1)\n+        .unwrap_or_else(|_e| {\n+            0\n+        });\n     // macro case\n-    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|e| 0); // should not lint\n+    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|_e| 0); // should not lint\n }\n \n fn main() {"}, {"sha": "96b9d6cc3c14519aed1cb04cdf5d9c941a797deb", "filename": "tests/ui/map_unwrap_or.stderr", "status": "modified", "additions": 42, "deletions": 57, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmap_unwrap_or.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmap_unwrap_or.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_unwrap_or.stderr?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -1,5 +1,5 @@\n-error: called `map(f).unwrap_or(a)` on an `Option` value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/map_unwrap_or.rs:17:13\n+error: called `map(<f>).unwrap_or(<a>)` on an `Option` value. This can be done more directly by calling `map_or(<a>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:16:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -8,13 +8,13 @@ LL | |         .unwrap_or(0);\n    | |_____________________^\n    |\n    = note: `-D clippy::map-unwrap-or` implied by `-D warnings`\n-help: use `map_or(a, f)` instead\n+help: use `map_or(<a>, <f>)` instead\n    |\n LL |     let _ = opt.map_or(0, |x| x + 1);\n    |                 ^^^^^^ ^^          --\n \n-error: called `map(f).unwrap_or(a)` on an `Option` value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/map_unwrap_or.rs:21:13\n+error: called `map(<f>).unwrap_or(<a>)` on an `Option` value. This can be done more directly by calling `map_or(<a>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:20:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -23,16 +23,16 @@ LL | |     }\n LL | |     ).unwrap_or(0);\n    | |__________________^\n    |\n-help: use `map_or(a, f)` instead\n+help: use `map_or(<a>, <f>)` instead\n    |\n LL |     let _ = opt.map_or(0, |x| {\n LL |         x + 1\n LL |     }\n LL |     );\n    |\n \n-error: called `map(f).unwrap_or(a)` on an `Option` value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/map_unwrap_or.rs:25:13\n+error: called `map(<f>).unwrap_or(<a>)` on an `Option` value. This can be done more directly by calling `map_or(<a>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:24:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -41,26 +41,26 @@ LL | |             0\n LL | |         });\n    | |__________^\n    |\n-help: use `map_or(a, f)` instead\n+help: use `map_or(<a>, <f>)` instead\n    |\n LL |     let _ = opt.map_or({\n LL |             0\n LL |         }, |x| x + 1);\n    |\n \n-error: called `map(f).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/map_unwrap_or.rs:30:13\n+error: called `map(<f>).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(<f>)` instead\n+  --> $DIR/map_unwrap_or.rs:29:13\n    |\n LL |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: use `and_then(f)` instead\n+help: use `and_then(<f>)` instead\n    |\n LL |     let _ = opt.and_then(|x| Some(x + 1));\n    |                 ^^^^^^^^                --\n \n-error: called `map(f).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/map_unwrap_or.rs:32:13\n+error: called `map(<f>).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(<f>)` instead\n+  --> $DIR/map_unwrap_or.rs:31:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -69,52 +69,41 @@ LL | |     }\n LL | |     ).unwrap_or(None);\n    | |_____________________^\n    |\n-help: use `and_then(f)` instead\n+help: use `and_then(<f>)` instead\n    |\n LL |     let _ = opt.and_then(|x| {\n LL |         Some(x + 1)\n LL |     }\n LL |     );\n    |\n \n-error: called `map(f).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/map_unwrap_or.rs:36:13\n+error: called `map(<f>).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(<f>)` instead\n+  --> $DIR/map_unwrap_or.rs:35:13\n    |\n LL |       let _ = opt\n    |  _____________^\n LL | |         .map(|x| Some(x + 1))\n LL | |         .unwrap_or(None);\n    | |________________________^\n    |\n-help: use `and_then(f)` instead\n+help: use `and_then(<f>)` instead\n    |\n LL |         .and_then(|x| Some(x + 1));\n    |          ^^^^^^^^                --\n \n-error: called `map(f).unwrap_or(a)` on an `Option` value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/map_unwrap_or.rs:47:13\n+error: called `map(<f>).unwrap_or(<a>)` on an `Option` value. This can be done more directly by calling `map_or(<a>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:46:13\n    |\n LL |     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: use `map_or(a, f)` instead\n+help: use `map_or(<a>, <f>)` instead\n    |\n LL |     let _ = Some(\"prefix\").map_or(id, |p| format!(\"{}.\", p));\n    |                            ^^^^^^ ^^^                      --\n \n-error: called `map(f).unwrap_or_else(g)` on an `Option` value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/map_unwrap_or.rs:51:13\n-   |\n-LL |       let _ = opt.map(|x| x + 1)\n-   |  _____________^\n-LL | |         // Should lint even though this call is on a separate line.\n-LL | |         .unwrap_or_else(|| 0);\n-   | |_____________________________^\n-   |\n-   = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n-\n-error: called `map(f).unwrap_or_else(g)` on an `Option` value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/map_unwrap_or.rs:55:13\n+error: called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling `map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:50:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -123,8 +112,8 @@ LL | |     }\n LL | |     ).unwrap_or_else(|| 0);\n    | |__________________________^\n \n-error: called `map(f).unwrap_or_else(g)` on an `Option` value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/map_unwrap_or.rs:59:13\n+error: called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling `map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:54:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -133,29 +122,25 @@ LL | |             0\n LL | |         );\n    | |_________^\n \n-error: called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling `.map_or_else(g, f)` instead\n-  --> $DIR/map_unwrap_or.rs:88:13\n+error: called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling `.map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:66:13\n    |\n-LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `map_or_else(|e| 0, |x| x + 1)`\n-\n-error: called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling `.map_or_else(g, f)` instead\n-  --> $DIR/map_unwrap_or.rs:90:13\n-   |\n-LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `map_or_else(|e| 0, |x| x + 1)`\n+LL |       let _ = res.map(|x| {\n+   |  _____________^\n+LL | |         x + 1\n+LL | |     }\n+LL | |     ).unwrap_or_else(|_e| 0);\n+   | |____________________________^\n \n-error: called `map(f).unwrap_or_else(g)` on a `Result` value. This can be done more directly by calling `.map_or_else(g, f)` instead\n-  --> $DIR/map_unwrap_or.rs:91:13\n-   |\n-LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+error: called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling `.map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or.rs:70:13\n    |\n-   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `map_or_else(|e| 0, |x| x + 1)`\n+LL |       let _ = res.map(|x| x + 1)\n+   |  _____________^\n+LL | |         .unwrap_or_else(|_e| {\n+LL | |             0\n+LL | |         });\n+   | |__________^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 11 previous errors\n "}, {"sha": "bd5b4f7165a4e65396224e927a5b10b3e99bb2ca", "filename": "tests/ui/map_unwrap_or_fixable.fixed", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmap_unwrap_or_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmap_unwrap_or_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_unwrap_or_fixable.fixed?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -0,0 +1,54 @@\n+// run-rustfix\n+// aux-build:option_helpers.rs\n+\n+#![warn(clippy::map_unwrap_or)]\n+\n+#[macro_use]\n+extern crate option_helpers;\n+\n+use std::collections::HashMap;\n+\n+#[rustfmt::skip]\n+fn option_methods() {\n+    let opt = Some(1);\n+\n+    // Check for `option.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = opt.map_or_else(|| 0, |x| x + 1);\n+\n+    // Macro case.\n+    // Should not lint.\n+    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0);\n+\n+    // Issue #4144\n+    {\n+        let mut frequencies = HashMap::new();\n+        let word = \"foo\";\n+\n+        frequencies\n+            .get_mut(word)\n+            .map(|count| {\n+                *count += 1;\n+            })\n+            .unwrap_or_else(|| {\n+                frequencies.insert(word.to_owned(), 1);\n+            });\n+    }\n+}\n+\n+#[rustfmt::skip]\n+fn result_methods() {\n+    let res: Result<i32, ()> = Ok(1);\n+\n+    // Check for `result.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = res.map_or_else(|_e| 0, |x| x + 1);\n+\n+    // macro case\n+    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|_e| 0); // should not lint\n+}\n+\n+fn main() {\n+    option_methods();\n+    result_methods();\n+}"}, {"sha": "0b892caf20e82a41d6c9c4f245af09ff647da0d2", "filename": "tests/ui/map_unwrap_or_fixable.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmap_unwrap_or_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmap_unwrap_or_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_unwrap_or_fixable.rs?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -0,0 +1,58 @@\n+// run-rustfix\n+// aux-build:option_helpers.rs\n+\n+#![warn(clippy::map_unwrap_or)]\n+\n+#[macro_use]\n+extern crate option_helpers;\n+\n+use std::collections::HashMap;\n+\n+#[rustfmt::skip]\n+fn option_methods() {\n+    let opt = Some(1);\n+\n+    // Check for `option.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = opt.map(|x| x + 1)\n+        // Should lint even though this call is on a separate line.\n+        .unwrap_or_else(|| 0);\n+\n+    // Macro case.\n+    // Should not lint.\n+    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0);\n+\n+    // Issue #4144\n+    {\n+        let mut frequencies = HashMap::new();\n+        let word = \"foo\";\n+\n+        frequencies\n+            .get_mut(word)\n+            .map(|count| {\n+                *count += 1;\n+            })\n+            .unwrap_or_else(|| {\n+                frequencies.insert(word.to_owned(), 1);\n+            });\n+    }\n+}\n+\n+#[rustfmt::skip]\n+fn result_methods() {\n+    let res: Result<i32, ()> = Ok(1);\n+\n+    // Check for `result.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = res.map(|x| x + 1)\n+        // should lint even though this call is on a separate line\n+        .unwrap_or_else(|_e| 0);\n+\n+    // macro case\n+    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|_e| 0); // should not lint\n+}\n+\n+fn main() {\n+    option_methods();\n+    result_methods();\n+}"}, {"sha": "1837bc2ca3b8b393526be48f827c18029dca064c", "filename": "tests/ui/map_unwrap_or_fixable.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmap_unwrap_or_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmap_unwrap_or_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_unwrap_or_fixable.stderr?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -0,0 +1,22 @@\n+error: called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling `map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or_fixable.rs:17:13\n+   |\n+LL |       let _ = opt.map(|x| x + 1)\n+   |  _____________^\n+LL | |         // Should lint even though this call is on a separate line.\n+LL | |         .unwrap_or_else(|| 0);\n+   | |_____________________________^ help: try this: `opt.map_or_else(|| 0, |x| x + 1)`\n+   |\n+   = note: `-D clippy::map-unwrap-or` implied by `-D warnings`\n+\n+error: called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling `.map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or_fixable.rs:47:13\n+   |\n+LL |       let _ = res.map(|x| x + 1)\n+   |  _____________^\n+LL | |         // should lint even though this call is on a separate line\n+LL | |         .unwrap_or_else(|_e| 0);\n+   | |_______________________________^ help: try this: `res.map_or_else(|_e| 0, |x| x + 1)`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "d93e5b114ecfa7a8933431848efc8a8543f442d8", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -122,16 +122,13 @@ impl Mul<T> for T {\n fn filter_next() {\n     let v = vec![3, 2, 1, 0, -1, -2, -3];\n \n-    // Single-line case.\n-    let _ = v.iter().filter(|&x| *x < 0).next();\n-\n     // Multi-line case.\n     let _ = v.iter().filter(|&x| {\n                                 *x < 0\n                             }\n                    ).next();\n \n-    // Check that hat we don't lint if the caller is not an `Iterator`.\n+    // Check that we don't lint if the caller is not an `Iterator`.\n     let foo = IteratorFalsePositives { foo: 0 };\n     let _ = foo.filter().next();\n }"}, {"sha": "8a281c2dbd25c2ec3feee082f9735bf89dff00f4", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -8,53 +8,46 @@ LL | |     }\n    |\n    = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n \n-error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n+error: called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(..)` instead.\n   --> $DIR/methods.rs:126:13\n    |\n-LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::filter-next` implied by `-D warnings`\n-   = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n-\n-error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:129:13\n-   |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n LL | |                                 *x < 0\n LL | |                             }\n LL | |                    ).next();\n    | |___________________________^\n+   |\n+   = note: `-D clippy::filter-next` implied by `-D warnings`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:146:22\n+  --> $DIR/methods.rs:143:22\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x < 0)`\n    |\n    = note: `-D clippy::search-is-some` implied by `-D warnings`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:147:20\n+  --> $DIR/methods.rs:144:20\n    |\n LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| **y == x)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:148:20\n+  --> $DIR/methods.rs:145:20\n    |\n LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:149:22\n+  --> $DIR/methods.rs:146:22\n    |\n LL |     let _ = v.iter().find(|x| **x == 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:152:13\n+  --> $DIR/methods.rs:149:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -64,13 +57,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:158:22\n+  --> $DIR/methods.rs:155:22\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:161:13\n+  --> $DIR/methods.rs:158:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -80,13 +73,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:167:22\n+  --> $DIR/methods.rs:164:22\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:170:13\n+  --> $DIR/methods.rs:167:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -95,5 +88,5 @@ LL | |                                }\n LL | |                    ).is_some();\n    | |______________________________^\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 11 previous errors\n "}, {"sha": "ee7c1b0da6d979cb7d0213574864d4d0833ab2b9", "filename": "tests/ui/methods_fixable.fixed", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmethods_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmethods_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods_fixable.fixed?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -0,0 +1,11 @@\n+// run-rustfix\n+\n+#![warn(clippy::filter_next)]\n+\n+/// Checks implementation of `FILTER_NEXT` lint.\n+fn main() {\n+    let v = vec![3, 2, 1, 0, -1, -2, -3];\n+\n+    // Single-line case.\n+    let _ = v.iter().find(|&x| *x < 0);\n+}"}, {"sha": "6d0f1b7bd5147beed87737827d520e45827c7638", "filename": "tests/ui/methods_fixable.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmethods_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmethods_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods_fixable.rs?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -0,0 +1,11 @@\n+// run-rustfix\n+\n+#![warn(clippy::filter_next)]\n+\n+/// Checks implementation of `FILTER_NEXT` lint.\n+fn main() {\n+    let v = vec![3, 2, 1, 0, -1, -2, -3];\n+\n+    // Single-line case.\n+    let _ = v.iter().filter(|&x| *x < 0).next();\n+}"}, {"sha": "70e7c3dea545bbeff7c3f78e4555fd0f2aee8822", "filename": "tests/ui/methods_fixable.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmethods_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fmethods_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods_fixable.stderr?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -0,0 +1,10 @@\n+error: called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(..)` instead.\n+  --> $DIR/methods_fixable.rs:10:13\n+   |\n+LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `v.iter().find(|&x| *x < 0)`\n+   |\n+   = note: `-D clippy::filter-next` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "1cba29412b872b927a359b74ab397d5b1b2798a9", "filename": "tests/ui/option_map_or_none.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Foption_map_or_none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Foption_map_or_none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_or_none.stderr?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -1,12 +1,12 @@\n-error: called `map_or(None, f)` on an `Option` value. This can be done more directly by calling `and_then(f)` instead\n+error: called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling `and_then(..)` instead\n   --> $DIR/option_map_or_none.rs:10:13\n    |\n LL |     let _ = opt.map_or(None, |x| Some(x + 1));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `opt.and_then(|x| Some(x + 1))`\n    |\n    = note: `-D clippy::option-map-or-none` implied by `-D warnings`\n \n-error: called `map_or(None, f)` on an `Option` value. This can be done more directly by calling `and_then(f)` instead\n+error: called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling `and_then(..)` instead\n   --> $DIR/option_map_or_none.rs:13:13\n    |\n LL |       let _ = opt.map_or(None, |x| {"}, {"sha": "269cc13468bc83a3ba58d280b5e1c62373f30c42", "filename": "tests/ui/skip_while_next.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fskip_while_next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7387b87bb98627962c3871e56b2bdeb73737c397/tests%2Fui%2Fskip_while_next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fskip_while_next.stderr?ref=7387b87bb98627962c3871e56b2bdeb73737c397", "patch": "@@ -1,13 +1,13 @@\n-error: called `skip_while(p).next()` on an `Iterator`\n+error: called `skip_while(<p>).next()` on an `Iterator`\n   --> $DIR/skip_while_next.rs:14:13\n    |\n LL |     let _ = v.iter().skip_while(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::skip-while-next` implied by `-D warnings`\n-   = help: this is more succinctly expressed by calling `.find(!p)` instead\n+   = help: this is more succinctly expressed by calling `.find(!<p>)` instead\n \n-error: called `skip_while(p).next()` on an `Iterator`\n+error: called `skip_while(<p>).next()` on an `Iterator`\n   --> $DIR/skip_while_next.rs:17:13\n    |\n LL |       let _ = v.iter().skip_while(|&x| {\n@@ -17,7 +17,7 @@ LL | |                             }\n LL | |                    ).next();\n    | |___________________________^\n    |\n-   = help: this is more succinctly expressed by calling `.find(!p)` instead\n+   = help: this is more succinctly expressed by calling `.find(!<p>)` instead\n \n error: aborting due to 2 previous errors\n "}]}