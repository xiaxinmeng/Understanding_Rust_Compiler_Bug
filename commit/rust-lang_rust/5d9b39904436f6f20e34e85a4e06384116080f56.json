{"sha": "5d9b39904436f6f20e34e85a4e06384116080f56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkOWIzOTkwNDQzNmY2ZjIwZTM0ZTg1YTRlMDYzODQxMTYwODBmNTY=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-12-11T19:50:03Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-01-10T08:08:25Z"}, "message": "Remove PlaceBase enum and make Place base field be local: Local", "tree": {"sha": "4b1a69935dc518c2d39919ea4e7360e2687313f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b1a69935dc518c2d39919ea4e7360e2687313f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d9b39904436f6f20e34e85a4e06384116080f56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9b39904436f6f20e34e85a4e06384116080f56", "html_url": "https://github.com/rust-lang/rust/commit/5d9b39904436f6f20e34e85a4e06384116080f56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d9b39904436f6f20e34e85a4e06384116080f56/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd5aa32c352d9aa7e652a64320f89b7f3859858b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd5aa32c352d9aa7e652a64320f89b7f3859858b", "html_url": "https://github.com/rust-lang/rust/commit/fd5aa32c352d9aa7e652a64320f89b7f3859858b"}], "stats": {"total": 1114, "additions": 457, "deletions": 657}, "files": [{"sha": "32d85314c7ab7694f003f98d88bac745a49dea16", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 51, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -1655,20 +1655,14 @@ impl Debug for Statement<'_> {\n /// changing or disturbing program state.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, HashStable)]\n pub struct Place<'tcx> {\n-    pub base: PlaceBase,\n+    pub local: Local,\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n     pub projection: &'tcx List<PlaceElem<'tcx>>,\n }\n \n impl<'tcx> rustc_serialize::UseSpecializedDecodable for Place<'tcx> {}\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum PlaceBase {\n-    /// local variable\n-    Local(Local),\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub enum ProjectionElem<V, T> {\n@@ -1756,14 +1750,14 @@ rustc_index::newtype_index! {\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct PlaceRef<'a, 'tcx> {\n-    pub base: &'a PlaceBase,\n+    pub local: &'a Local,\n     pub projection: &'a [PlaceElem<'tcx>],\n }\n \n impl<'tcx> Place<'tcx> {\n     // FIXME change this to a const fn by also making List::empty a const fn.\n     pub fn return_place() -> Place<'tcx> {\n-        Place { base: PlaceBase::Local(RETURN_PLACE), projection: List::empty() }\n+        Place { local: RETURN_PLACE, projection: List::empty() }\n     }\n \n     /// Returns `true` if this `Place` contains a `Deref` projection.\n@@ -1780,10 +1774,8 @@ impl<'tcx> Place<'tcx> {\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n         match self.as_ref() {\n-            PlaceRef { base: &PlaceBase::Local(local), projection: &[] }\n-            | PlaceRef { base: &PlaceBase::Local(local), projection: &[ProjectionElem::Deref] } => {\n-                Some(local)\n-            }\n+            PlaceRef { local, projection: &[] }\n+            | PlaceRef { local, projection: &[ProjectionElem::Deref] } => Some(*local),\n             _ => None,\n         }\n     }\n@@ -1795,19 +1787,13 @@ impl<'tcx> Place<'tcx> {\n     }\n \n     pub fn as_ref(&self) -> PlaceRef<'_, 'tcx> {\n-        PlaceRef { base: &self.base, projection: &self.projection }\n+        PlaceRef { local: &self.local, projection: &self.projection }\n     }\n }\n \n impl From<Local> for Place<'_> {\n     fn from(local: Local) -> Self {\n-        Place { base: local.into(), projection: List::empty() }\n-    }\n-}\n-\n-impl From<Local> for PlaceBase {\n-    fn from(local: Local) -> Self {\n-        PlaceBase::Local(local)\n+        Place { local: local.into(), projection: List::empty() }\n     }\n }\n \n@@ -1818,10 +1804,8 @@ impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n         match self {\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] }\n-            | PlaceRef { base: PlaceBase::Local(local), projection: [ProjectionElem::Deref] } => {\n-                Some(*local)\n-            }\n+            PlaceRef { local, projection: [] }\n+            | PlaceRef { local, projection: [ProjectionElem::Deref] } => Some(**local),\n             _ => None,\n         }\n     }\n@@ -1830,7 +1814,7 @@ impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n     /// projections, return `Some(_X)`.\n     pub fn as_local(&self) -> Option<Local> {\n         match self {\n-            PlaceRef { base: PlaceBase::Local(l), projection: [] } => Some(*l),\n+            PlaceRef { local, projection: [] } => Some(**local),\n             _ => None,\n         }\n     }\n@@ -1852,7 +1836,7 @@ impl Debug for Place<'_> {\n             }\n         }\n \n-        write!(fmt, \"{:?}\", self.base)?;\n+        write!(fmt, \"{:?}\", self.local)?;\n \n         for elem in self.projection.iter() {\n             match elem {\n@@ -1896,14 +1880,6 @@ impl Debug for Place<'_> {\n     }\n }\n \n-impl Debug for PlaceBase {\n-    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            PlaceBase::Local(id) => write!(fmt, \"{:?}\", id),\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Scopes\n \n@@ -2964,25 +2940,11 @@ impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n \n impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Place { base: self.base.fold_with(folder), projection: self.projection.fold_with(folder) }\n+        Place { local: self.local.fold_with(folder), projection: self.projection.fold_with(folder) }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.base.visit_with(visitor) || self.projection.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for PlaceBase {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        match self {\n-            PlaceBase::Local(local) => PlaceBase::Local(local.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match self {\n-            PlaceBase::Local(local) => local.visit_with(visitor),\n-        }\n+        self.local.visit_with(visitor) || self.projection.visit_with(visitor)\n     }\n }\n "}, {"sha": "e2aac562cc4ccf9ef81482b263e37f30ce8688e3", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -114,7 +114,7 @@ impl<'tcx> PlaceTy<'tcx> {\n \n impl<'tcx> Place<'tcx> {\n     pub fn ty_from<D>(\n-        base: &PlaceBase,\n+        local: &Local,\n         projection: &[PlaceElem<'tcx>],\n         local_decls: &D,\n         tcx: TyCtxt<'tcx>,\n@@ -124,25 +124,16 @@ impl<'tcx> Place<'tcx> {\n     {\n         projection\n             .iter()\n-            .fold(base.ty(local_decls), |place_ty, elem| place_ty.projection_ty(tcx, elem))\n+            .fold(PlaceTy::from_ty(local_decls.local_decls()[*local].ty), |place_ty, elem| {\n+                place_ty.projection_ty(tcx, elem)\n+            })\n     }\n \n     pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>\n     where\n         D: HasLocalDecls<'tcx>,\n     {\n-        Place::ty_from(&self.base, &self.projection, local_decls, tcx)\n-    }\n-}\n-\n-impl<'tcx> PlaceBase {\n-    pub fn ty<D>(&self, local_decls: &D) -> PlaceTy<'tcx>\n-    where\n-        D: HasLocalDecls<'tcx>,\n-    {\n-        match self {\n-            PlaceBase::Local(index) => PlaceTy::from_ty(local_decls.local_decls()[*index].ty),\n-        }\n+        Place::ty_from(&self.local, &self.projection, local_decls, tcx)\n     }\n }\n "}, {"sha": "4c5db1b07d225d783e49c97b765698bb5bf96f1f", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -164,10 +164,10 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_place_base(&mut self,\n-                                base: & $($mutability)? PlaceBase,\n+                                local: & $($mutability)? Local,\n                                 context: PlaceContext,\n                                 location: Location) {\n-                self.super_place_base(base, context, location);\n+                self.super_place_base(local, context, location);\n             }\n \n             visit_place_fns!($($mutability)?);\n@@ -705,14 +705,10 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_place_base(&mut self,\n-                                place_base: & $($mutability)? PlaceBase,\n+                                local: & $($mutability)? Local,\n                                 context: PlaceContext,\n                                 location: Location) {\n-                match place_base {\n-                    PlaceBase::Local(local) => {\n-                        self.visit_local(local, context, location);\n-                    }\n-                }\n+                self.visit_local(local, context, location);\n             }\n \n             fn super_local_decl(&mut self,\n@@ -845,7 +841,7 @@ macro_rules! visit_place_fns {\n             context: PlaceContext,\n             location: Location,\n         ) {\n-            self.visit_place_base(&mut place.base, context, location);\n+            self.visit_place_base(&mut place.local, context, location);\n \n             if let Some(new_projection) = self.process_projection(&place.projection) {\n                 place.projection = self.tcx().intern_place_elems(&new_projection);\n@@ -886,23 +882,23 @@ macro_rules! visit_place_fns {\n     () => (\n         fn visit_projection(\n             &mut self,\n-            base: &PlaceBase,\n+            local: &Local,\n             projection: &[PlaceElem<'tcx>],\n             context: PlaceContext,\n             location: Location,\n         ) {\n-            self.super_projection(base, projection, context, location);\n+            self.super_projection(local, projection, context, location);\n         }\n \n         fn visit_projection_elem(\n             &mut self,\n-            base: &PlaceBase,\n+            local: &Local,\n             proj_base: &[PlaceElem<'tcx>],\n             elem: &PlaceElem<'tcx>,\n             context: PlaceContext,\n             location: Location,\n         ) {\n-            self.super_projection_elem(base, proj_base, elem, context, location);\n+            self.super_projection_elem(local, proj_base, elem, context, location);\n         }\n \n         fn super_place(\n@@ -921,31 +917,31 @@ macro_rules! visit_place_fns {\n                 };\n             }\n \n-            self.visit_place_base(&place.base, context, location);\n+            self.visit_place_base(&place.local, context, location);\n \n-            self.visit_projection(&place.base,\n+            self.visit_projection(&place.local,\n                                   &place.projection,\n                                   context,\n                                   location);\n         }\n \n         fn super_projection(\n             &mut self,\n-            base: &PlaceBase,\n+            local: &Local,\n             projection: &[PlaceElem<'tcx>],\n             context: PlaceContext,\n             location: Location,\n         ) {\n             let mut cursor = projection;\n             while let [proj_base @ .., elem] = cursor {\n                 cursor = proj_base;\n-                self.visit_projection_elem(base, cursor, elem, context, location);\n+                self.visit_projection_elem(local, cursor, elem, context, location);\n             }\n         }\n \n         fn super_projection_elem(\n             &mut self,\n-            _base: &PlaceBase,\n+            _local: &Local,\n             _proj_base: &[PlaceElem<'tcx>],\n             elem: &PlaceElem<'tcx>,\n             _context: PlaceContext,"}, {"sha": "df1602b2ac46d83dd9265983a1eca524d252e490", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -226,11 +226,11 @@ pub fn decode_place<D>(decoder: &mut D) -> Result<mir::Place<'tcx>, D::Error>\n where\n     D: TyDecoder<'tcx>,\n {\n-    let base: mir::PlaceBase = Decodable::decode(decoder)?;\n+    let local: mir::Local = Decodable::decode(decoder)?;\n     let len = decoder.read_usize()?;\n     let projection: &'tcx List<mir::PlaceElem<'tcx>> =\n         decoder.tcx().mk_place_elems((0..len).map(|_| Decodable::decode(decoder)))?;\n-    Ok(mir::Place { base, projection })\n+    Ok(mir::Place { local, projection })\n }\n \n #[inline]"}, {"sha": "52a151439dcb74d09c23eb78dd4ec39ed203231d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -2434,7 +2434,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut projection = place.projection.to_vec();\n         projection.push(elem);\n \n-        Place { base: place.base, projection: self.intern_place_elems(&projection) }\n+        Place { local: place.local, projection: self.intern_place_elems(&projection) }\n     }\n \n     pub fn intern_existential_predicates("}, {"sha": "d1f70ad43bd2888622e7b9ff283f35d7a56917dd", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -1286,9 +1286,9 @@ fn generator_layout_and_saved_local_names(\n     let generator_layout = body.generator_layout.as_ref().unwrap();\n     let mut generator_saved_local_names = IndexVec::from_elem(None, &generator_layout.field_tys);\n \n-    let state_arg = mir::PlaceBase::Local(mir::Local::new(1));\n+    let state_arg = mir::Local::new(1);\n     for var in &body.var_debug_info {\n-        if var.place.base != state_arg {\n+        if var.place.local != state_arg {\n             continue;\n         }\n         match var.place.projection[..] {"}, {"sha": "c3affd233f8e3b00fc1b7693543505c0a7120aff", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -128,17 +128,13 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n             if is_consume {\n                 let base_ty =\n-                    mir::Place::ty_from(place_ref.base, proj_base, *self.fx.mir, cx.tcx());\n+                    mir::Place::ty_from(place_ref.local, proj_base, *self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n                 let elem_ty = base_ty.projection_ty(cx.tcx(), elem).ty;\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n-                let span = match place_ref.base {\n-                    mir::PlaceBase::Local(index) => {\n-                        self.fx.mir.local_decls[*index].source_info.span\n-                    }\n-                };\n+                let span = self.fx.mir.local_decls[*place_ref.local].source_info.span;\n                 if cx.spanned_layout_of(elem_ty, span).is_zst() {\n                     return;\n                 }\n@@ -178,9 +174,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                     // We use `NonUseContext::VarDebugInfo` for the base,\n                     // which might not force the base local to memory,\n                     // so we have to do it manually.\n-                    match place_ref.base {\n-                        mir::PlaceBase::Local(local) => self.visit_local(&local, context, location),\n-                    }\n+                    self.visit_local(place_ref.local, context, location);\n                 }\n             }\n \n@@ -191,7 +185,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             }\n \n             self.process_place(\n-                &mir::PlaceRef { base: place_ref.base, projection: proj_base },\n+                &mir::PlaceRef { local: place_ref.local, projection: proj_base },\n                 base_context,\n                 location,\n             );\n@@ -218,8 +212,8 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                 };\n             }\n \n-            self.visit_place_base(place_ref.base, context, location);\n-            self.visit_projection(place_ref.base, place_ref.projection, context, location);\n+            self.visit_place_base(place_ref.local, context, location);\n+            self.visit_projection(place_ref.local, place_ref.projection, context, location);\n         }\n     }\n }"}, {"sha": "fa79541701e416322871389d2b9ae49f085be960", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -1109,7 +1109,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         } else {\n             self.codegen_place(\n                 bx,\n-                &mir::PlaceRef { base: &dest.base, projection: &dest.projection },\n+                &mir::PlaceRef { local: &dest.local, projection: &dest.projection },\n             )\n         };\n         if fn_ret.is_indirect() {"}, {"sha": "e0aec5d6dd512038aca6502b570d1c1d0241522e", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -258,9 +258,7 @@ pub fn per_local_var_debug_info(\n     if tcx.sess.opts.debuginfo == DebugInfo::Full || !tcx.sess.fewer_names() {\n         let mut per_local = IndexVec::from_elem(vec![], &body.local_decls);\n         for var in &body.var_debug_info {\n-            match var.place.base {\n-                mir::PlaceBase::Local(local) => per_local[local].push(var),\n-            }\n+            per_local[var.place.local].push(var);\n         }\n         Some(per_local)\n     } else {"}, {"sha": "a155a6e78f7c3e3e6dd708501256b3460011b495", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -373,43 +373,39 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Option<OperandRef<'tcx, Bx::Value>> {\n         debug!(\"maybe_codegen_consume_direct(place_ref={:?})\", place_ref);\n \n-        match place_ref.base {\n-            mir::PlaceBase::Local(index) => {\n-                match self.locals[*index] {\n-                    LocalRef::Operand(Some(mut o)) => {\n-                        // Moves out of scalar and scalar pair fields are trivial.\n-                        for elem in place_ref.projection.iter() {\n-                            match elem {\n-                                mir::ProjectionElem::Field(ref f, _) => {\n-                                    o = o.extract_field(bx, f.index());\n-                                }\n-                                mir::ProjectionElem::Index(_)\n-                                | mir::ProjectionElem::ConstantIndex { .. } => {\n-                                    // ZSTs don't require any actual memory access.\n-                                    // FIXME(eddyb) deduplicate this with the identical\n-                                    // checks in `codegen_consume` and `extract_field`.\n-                                    let elem = o.layout.field(bx.cx(), 0);\n-                                    if elem.is_zst() {\n-                                        o = OperandRef::new_zst(bx, elem);\n-                                    } else {\n-                                        return None;\n-                                    }\n-                                }\n-                                _ => return None,\n+        match self.locals[*place_ref.local] {\n+            LocalRef::Operand(Some(mut o)) => {\n+                // Moves out of scalar and scalar pair fields are trivial.\n+                for elem in place_ref.projection.iter() {\n+                    match elem {\n+                        mir::ProjectionElem::Field(ref f, _) => {\n+                            o = o.extract_field(bx, f.index());\n+                        }\n+                        mir::ProjectionElem::Index(_)\n+                        | mir::ProjectionElem::ConstantIndex { .. } => {\n+                            // ZSTs don't require any actual memory access.\n+                            // FIXME(eddyb) deduplicate this with the identical\n+                            // checks in `codegen_consume` and `extract_field`.\n+                            let elem = o.layout.field(bx.cx(), 0);\n+                            if elem.is_zst() {\n+                                o = OperandRef::new_zst(bx, elem);\n+                            } else {\n+                                return None;\n                             }\n                         }\n-\n-                        Some(o)\n-                    }\n-                    LocalRef::Operand(None) => {\n-                        bug!(\"use of {:?} before def\", place_ref);\n-                    }\n-                    LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n-                        // watch out for locals that do not have an\n-                        // alloca; they are handled somewhat differently\n-                        None\n+                        _ => return None,\n                     }\n                 }\n+\n+                Some(o)\n+            }\n+            LocalRef::Operand(None) => {\n+                bug!(\"use of {:?} before def\", place_ref);\n+            }\n+            LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n+                // watch out for locals that do not have an\n+                // alloca; they are handled somewhat differently\n+                None\n             }\n         }\n     }"}, {"sha": "5e03a35b8a6fd662cde4077f3e4f54b91e79b7af", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -415,28 +415,26 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let tcx = self.cx.tcx();\n \n         let result = match place_ref {\n-            mir::PlaceRef { base: mir::PlaceBase::Local(index), projection: [] } => {\n-                match self.locals[*index] {\n-                    LocalRef::Place(place) => {\n-                        return place;\n-                    }\n-                    LocalRef::UnsizedPlace(place) => {\n-                        return bx.load_operand(place).deref(cx);\n-                    }\n-                    LocalRef::Operand(..) => {\n-                        bug!(\"using operand local {:?} as place\", place_ref);\n-                    }\n+            mir::PlaceRef { local, projection: [] } => match self.locals[**local] {\n+                LocalRef::Place(place) => {\n+                    return place;\n                 }\n-            }\n-            mir::PlaceRef { base, projection: [proj_base @ .., mir::ProjectionElem::Deref] } => {\n+                LocalRef::UnsizedPlace(place) => {\n+                    return bx.load_operand(place).deref(cx);\n+                }\n+                LocalRef::Operand(..) => {\n+                    bug!(\"using operand local {:?} as place\", place_ref);\n+                }\n+            },\n+            mir::PlaceRef { local, projection: [proj_base @ .., mir::ProjectionElem::Deref] } => {\n                 // Load the pointer from its location.\n-                self.codegen_consume(bx, &mir::PlaceRef { base, projection: proj_base })\n+                self.codegen_consume(bx, &mir::PlaceRef { local, projection: proj_base })\n                     .deref(bx.cx())\n             }\n-            mir::PlaceRef { base, projection: [proj_base @ .., elem] } => {\n+            mir::PlaceRef { local, projection: [proj_base @ .., elem] } => {\n                 // FIXME turn this recursion into iteration\n                 let cg_base =\n-                    self.codegen_place(bx, &mir::PlaceRef { base, projection: proj_base });\n+                    self.codegen_place(bx, &mir::PlaceRef { local, projection: proj_base });\n \n                 match elem {\n                     mir::ProjectionElem::Deref => bug!(),\n@@ -501,7 +499,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     pub fn monomorphized_place_ty(&self, place_ref: &mir::PlaceRef<'_, 'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n-        let place_ty = mir::Place::ty_from(place_ref.base, place_ref.projection, *self.mir, tcx);\n+        let place_ty = mir::Place::ty_from(place_ref.local, place_ref.projection, *self.mir, tcx);\n         self.monomorphize(&place_ty.ty)\n     }\n }"}, {"sha": "f2a44986cc4d4edccd167c26899abfb557130883", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -208,11 +208,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n \n             self.insert_as_pending_if_two_phase(location, &assigned_place, kind, idx);\n \n-            match borrowed_place.base {\n-                mir::PlaceBase::Local(local) => {\n-                    self.local_map.entry(local).or_default().insert(idx);\n-                }\n-            }\n+            self.local_map.entry(borrowed_place.local).or_default().insert(idx);\n         }\n \n         self.super_assign(assigned_place, rvalue, location)"}, {"sha": "0f6a360c7933b3f5d525272717d9ec5d54492bbb", "filename": "src/librustc_mir/borrow_check/constraint_generation.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -2,8 +2,8 @@ use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{\n-    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, PlaceRef, ProjectionElem,\n-    Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n+    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceRef, ProjectionElem, Rvalue,\n+    SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n };\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::SubstsRef;\n@@ -188,11 +188,8 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n             //   of the borrows are killed: the ones whose `borrowed_place`\n             //   conflicts with the `place`.\n             match place.as_ref() {\n-                PlaceRef { base: &PlaceBase::Local(local), projection: &[] }\n-                | PlaceRef {\n-                    base: &PlaceBase::Local(local),\n-                    projection: &[ProjectionElem::Deref],\n-                } => {\n+                PlaceRef { local, projection: &[] }\n+                | PlaceRef { local, projection: &[ProjectionElem::Deref] } => {\n                     debug!(\n                         \"Recording `killed` facts for borrows of local={:?} at location={:?}\",\n                         local, location\n@@ -202,20 +199,20 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                         all_facts,\n                         self.borrow_set,\n                         self.location_table,\n-                        &local,\n+                        local,\n                         location,\n                     );\n                 }\n \n-                PlaceRef { base: &PlaceBase::Local(local), projection: &[.., _] } => {\n+                PlaceRef { local, projection: &[.., _] } => {\n                     // Kill conflicting borrows of the innermost local.\n                     debug!(\n                         \"Recording `killed` facts for borrows of \\\n                             innermost projected local={:?} at location={:?}\",\n                         local, location\n                     );\n \n-                    if let Some(borrow_indices) = self.borrow_set.local_map.get(&local) {\n+                    if let Some(borrow_indices) = self.borrow_set.local_map.get(local) {\n                         for &borrow_index in borrow_indices {\n                             let places_conflict = places_conflict::places_conflict(\n                                 self.infcx.tcx,"}, {"sha": "08333ae423da727a3bbce26beec5abf39ed705ea", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -1,7 +1,7 @@\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n-    FakeReadCause, Local, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceBase,\n-    PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n+    FakeReadCause, Local, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n+    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::traits::error_reporting::suggest_constraining_type_param;\n use rustc::ty::{self, Ty};\n@@ -186,7 +186,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             let ty =\n-                Place::ty_from(used_place.base, used_place.projection, *self.body, self.infcx.tcx)\n+                Place::ty_from(used_place.local, used_place.projection, *self.body, self.infcx.tcx)\n                     .ty;\n             let needs_note = match ty.kind {\n                 ty::Closure(id, _) => {\n@@ -597,15 +597,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // field access to a union. If we find that, then we will keep the place of the\n                 // union being accessed and the field that was being accessed so we can check the\n                 // second borrowed place for the same union and a access to a different field.\n-                let Place { base, projection } = first_borrowed_place;\n+                let Place { local, projection } = first_borrowed_place;\n \n                 let mut cursor = projection.as_ref();\n                 while let [proj_base @ .., elem] = cursor {\n                     cursor = proj_base;\n \n                     match elem {\n-                        ProjectionElem::Field(field, _) if union_ty(base, proj_base).is_some() => {\n-                            return Some((PlaceRef { base: base, projection: proj_base }, field));\n+                        ProjectionElem::Field(field, _) if union_ty(local, proj_base).is_some() => {\n+                            return Some((PlaceRef { local, projection: proj_base }, field));\n                         }\n                         _ => {}\n                     }\n@@ -615,21 +615,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .and_then(|(target_base, target_field)| {\n                 // With the place of a union and a field access into it, we traverse the second\n                 // borrowed place and look for a access to a different field of the same union.\n-                let Place { base, projection } = second_borrowed_place;\n+                let Place { local, projection } = second_borrowed_place;\n \n                 let mut cursor = projection.as_ref();\n                 while let [proj_base @ .., elem] = cursor {\n                     cursor = proj_base;\n \n                     if let ProjectionElem::Field(field, _) = elem {\n-                        if let Some(union_ty) = union_ty(base, proj_base) {\n+                        if let Some(union_ty) = union_ty(local, proj_base) {\n                             if field != target_field\n-                                && base == target_base.base\n+                                && local == target_base.local\n                                 && proj_base == target_base.projection\n                             {\n                                 // FIXME when we avoid clone reuse describe_place closure\n                                 let describe_base_place = self\n-                                    .describe_place(PlaceRef { base: base, projection: proj_base })\n+                                    .describe_place(PlaceRef { local, projection: proj_base })\n                                     .unwrap_or_else(|| \"_\".to_owned());\n \n                                 return Some((\n@@ -686,14 +686,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let borrow_span = borrow_spans.var_or_use();\n \n         assert!(root_place.projection.is_empty());\n-        let proper_span = match root_place.base {\n-            PlaceBase::Local(local) => self.body.local_decls[*local].source_info.span,\n-        };\n+        let proper_span = self.body.local_decls[*root_place.local].source_info.span;\n \n         let root_place_projection = self.infcx.tcx.intern_place_elems(root_place.projection);\n \n         if self.access_place_error_reported.contains(&(\n-            Place { base: root_place.base.clone(), projection: root_place_projection },\n+            Place { local: root_place.local.clone(), projection: root_place_projection },\n             borrow_span,\n         )) {\n             debug!(\n@@ -704,22 +702,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         self.access_place_error_reported.insert((\n-            Place { base: root_place.base.clone(), projection: root_place_projection },\n+            Place { local: root_place.local.clone(), projection: root_place_projection },\n             borrow_span,\n         ));\n \n-        match borrow.borrowed_place.base {\n-            PlaceBase::Local(local) => {\n-                if self.body.local_decls[local].is_ref_to_thread_local() {\n-                    let err = self.report_thread_local_value_does_not_live_long_enough(\n-                        drop_span,\n-                        borrow_span,\n-                    );\n-                    err.buffer(&mut self.errors_buffer);\n-                    return;\n-                }\n-            }\n-        };\n+        let borrowed_local = borrow.borrowed_place.local;\n+        if self.body.local_decls[borrowed_local].is_ref_to_thread_local() {\n+            let err =\n+                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span);\n+            err.buffer(&mut self.errors_buffer);\n+            return;\n+        }\n \n         if let StorageDeadOrDrop::Destructor(dropped_ty) =\n             self.classify_drop_access_kind(borrow.borrowed_place.as_ref())\n@@ -1145,12 +1138,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         } else {\n             let root_place =\n                 self.prefixes(borrow.borrowed_place.as_ref(), PrefixSet::All).last().unwrap();\n-            let local =\n-                if let PlaceRef { base: PlaceBase::Local(local), projection: [] } = root_place {\n-                    local\n-                } else {\n-                    bug!(\"try_report_cannot_return_reference_to_local: not a local\")\n-                };\n+            let local = root_place.local;\n             match self.body.local_kind(*local) {\n                 LocalKind::ReturnPointer | LocalKind::Temp => {\n                     (\"temporary value\".to_string(), \"temporary value created here\".to_string())\n@@ -1517,23 +1505,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             [proj_base @ .., elem] => {\n                 // FIXME(spastorino) make this iterate\n                 let base_access = self.classify_drop_access_kind(PlaceRef {\n-                    base: place.base,\n+                    local: place.local,\n                     projection: proj_base,\n                 });\n                 match elem {\n                     ProjectionElem::Deref => match base_access {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                Place::ty_from(&place.base, proj_base, *self.body, tcx).ty.is_box(),\n+                                Place::ty_from(&place.local, proj_base, *self.body, tcx)\n+                                    .ty\n+                                    .is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = Place::ty_from(&place.base, proj_base, *self.body, tcx).ty;\n+                        let base_ty = Place::ty_from(&place.local, proj_base, *self.body, tcx).ty;\n                         match base_ty.kind {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor"}, {"sha": "3f3bdb9d36c76352d429503a78f7677a41f3f92b", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -2,8 +2,7 @@\n \n use rustc::mir::{\n     AggregateKind, Constant, Field, Local, LocalInfo, LocalKind, Location, Operand, Place,\n-    PlaceBase, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator,\n-    TerminatorKind,\n+    PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::print::Print;\n@@ -169,30 +168,30 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         including_downcast: &IncludingDowncast,\n     ) -> Result<(), ()> {\n         match place {\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] } => {\n+            PlaceRef { local, projection: [] } => {\n                 self.append_local_to_string(*local, buf)?;\n             }\n-            PlaceRef { base: &PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[local].is_ref_for_guard() =>\n+            PlaceRef { local, projection: [ProjectionElem::Deref] }\n+                if self.body.local_decls[*local].is_ref_for_guard() =>\n             {\n                 self.append_place_to_string(\n-                    PlaceRef { base: &PlaceBase::Local(local), projection: &[] },\n+                    PlaceRef { local: local, projection: &[] },\n                     buf,\n                     autoderef,\n                     &including_downcast,\n                 )?;\n             }\n-            PlaceRef { base: &PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[local].is_ref_to_static() =>\n+            PlaceRef { local, projection: [ProjectionElem::Deref] }\n+                if self.body.local_decls[*local].is_ref_to_static() =>\n             {\n-                let local_info = &self.body.local_decls[local].local_info;\n+                let local_info = &self.body.local_decls[*local].local_info;\n                 if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n                     buf.push_str(&self.infcx.tcx.item_name(def_id).as_str());\n                 } else {\n                     unreachable!();\n                 }\n             }\n-            PlaceRef { base, projection: [proj_base @ .., elem] } => {\n+            PlaceRef { local, projection: [proj_base @ .., elem] } => {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let upvar_field_projection = self.is_upvar_field_projection(place);\n@@ -208,29 +207,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             if autoderef {\n                                 // FIXME turn this recursion into iteration\n                                 self.append_place_to_string(\n-                                    PlaceRef { base, projection: proj_base },\n+                                    PlaceRef { local, projection: proj_base },\n                                     buf,\n                                     autoderef,\n                                     &including_downcast,\n                                 )?;\n                             } else {\n-                                match (proj_base, base) {\n-                                    _ => {\n-                                        buf.push_str(&\"*\");\n-                                        self.append_place_to_string(\n-                                            PlaceRef { base, projection: proj_base },\n-                                            buf,\n-                                            autoderef,\n-                                            &including_downcast,\n-                                        )?;\n-                                    }\n-                                }\n+                                buf.push_str(&\"*\");\n+                                self.append_place_to_string(\n+                                    PlaceRef { local, projection: proj_base },\n+                                    buf,\n+                                    autoderef,\n+                                    &including_downcast,\n+                                )?;\n                             }\n                         }\n                     }\n                     ProjectionElem::Downcast(..) => {\n                         self.append_place_to_string(\n-                            PlaceRef { base, projection: proj_base },\n+                            PlaceRef { local, projection: proj_base },\n                             buf,\n                             autoderef,\n                             &including_downcast,\n@@ -249,9 +244,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             buf.push_str(&name);\n                         } else {\n                             let field_name = self\n-                                .describe_field(PlaceRef { base, projection: proj_base }, *field);\n+                                .describe_field(PlaceRef { local, projection: proj_base }, *field);\n                             self.append_place_to_string(\n-                                PlaceRef { base, projection: proj_base },\n+                                PlaceRef { local, projection: proj_base },\n                                 buf,\n                                 autoderef,\n                                 &including_downcast,\n@@ -263,7 +258,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         autoderef = true;\n \n                         self.append_place_to_string(\n-                            PlaceRef { base, projection: proj_base },\n+                            PlaceRef { local, projection: proj_base },\n                             buf,\n                             autoderef,\n                             &including_downcast,\n@@ -280,7 +275,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // then use another while the borrow is held, don't output indices details\n                         // to avoid confusing the end-user\n                         self.append_place_to_string(\n-                            PlaceRef { base, projection: proj_base },\n+                            PlaceRef { local, projection: proj_base },\n                             buf,\n                             autoderef,\n                             &including_downcast,\n@@ -311,17 +306,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn describe_field(&self, place: PlaceRef<'cx, 'tcx>, field: Field) -> String {\n         // FIXME Place2 Make this work iteratively\n         match place {\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] } => {\n+            PlaceRef { local, projection: [] } => {\n                 let local = &self.body.local_decls[*local];\n                 self.describe_field_from_ty(&local.ty, field, None)\n             }\n-            PlaceRef { base, projection: [proj_base @ .., elem] } => match elem {\n+            PlaceRef { local, projection: [proj_base @ .., elem] } => match elem {\n                 ProjectionElem::Deref => {\n-                    self.describe_field(PlaceRef { base, projection: proj_base }, field)\n+                    self.describe_field(PlaceRef { local, projection: proj_base }, field)\n                 }\n                 ProjectionElem::Downcast(_, variant_index) => {\n                     let base_ty =\n-                        Place::ty_from(place.base, place.projection, *self.body, self.infcx.tcx).ty;\n+                        Place::ty_from(place.local, place.projection, *self.body, self.infcx.tcx)\n+                            .ty;\n                     self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n@@ -330,7 +326,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 ProjectionElem::Index(..)\n                 | ProjectionElem::ConstantIndex { .. }\n                 | ProjectionElem::Subslice { .. } => {\n-                    self.describe_field(PlaceRef { base, projection: proj_base }, field)\n+                    self.describe_field(PlaceRef { local, projection: proj_base }, field)\n                 }\n             },\n         }\n@@ -451,7 +447,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // If we didn't find an overloaded deref or index, then assume it's a\n         // built in deref and check the type of the base.\n-        let base_ty = Place::ty_from(deref_base.base, deref_base.projection, *self.body, tcx).ty;\n+        let base_ty = Place::ty_from(deref_base.local, deref_base.projection, *self.body, tcx).ty;\n         if base_ty.is_unsafe_ptr() {\n             BorrowedContentSource::DerefRawPointer\n         } else if base_ty.is_mutable_ptr() {"}, {"sha": "eb6db7c145c3cde6f10425a8a85a49da3602b884", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -273,7 +273,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let description = if place.projection.len() == 1 {\n             format!(\"static item `{}`\", self.describe_place(place.as_ref()).unwrap())\n         } else {\n-            let base_static = PlaceRef { base: &place.base, projection: &[ProjectionElem::Deref] };\n+            let base_static =\n+                PlaceRef { local: &place.local, projection: &[ProjectionElem::Deref] };\n \n             format!(\n                 \"`{:?}` as `{:?}` is a static item\",\n@@ -302,12 +303,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         let deref_base = match deref_target_place.projection.as_ref() {\n             &[ref proj_base @ .., ProjectionElem::Deref] => {\n-                PlaceRef { base: &deref_target_place.base, projection: &proj_base }\n+                PlaceRef { local: &deref_target_place.local, projection: &proj_base }\n             }\n             _ => bug!(\"deref_target_place is not a deref projection\"),\n         };\n \n-        if let PlaceRef { base: PlaceBase::Local(local), projection: [] } = deref_base {\n+        if let PlaceRef { local, projection: [] } = deref_base {\n             let decl = &self.body.local_decls[*local];\n             if decl.is_ref_for_guard() {\n                 let mut err = self.cannot_move_out_of("}, {"sha": "ae468e83ae253f790d97638f9217ca2f6dbcd0af", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir::{self, ClearCrossCrate, Local, LocalInfo, Location, ReadOnlyBodyAndCache};\n-use rustc::mir::{Mutability, Place, PlaceBase, PlaceRef, ProjectionElem};\n+use rustc::mir::{Mutability, Place, PlaceRef, ProjectionElem};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n use rustc_hir::Node;\n@@ -42,7 +42,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         debug!(\"report_mutability_error: access_place_desc={:?}\", access_place_desc);\n \n         match the_place_err {\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] } => {\n+            PlaceRef { local, projection: [] } => {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                 if access_place.as_local().is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n@@ -53,11 +53,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             PlaceRef {\n-                base: _,\n+                local,\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(&the_place_err.base, proj_base, *self.body, self.infcx.tcx).ty\n+                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n@@ -69,21 +69,21 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            PlaceRef { base: &PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[local].is_ref_for_guard() =>\n+            PlaceRef { local, projection: [ProjectionElem::Deref] }\n+                if self.body.local_decls[*local].is_ref_for_guard() =>\n             {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                 reason = \", as it is immutable for the pattern guard\".to_string();\n             }\n-            PlaceRef { base: &PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[local].is_ref_to_static() =>\n+            PlaceRef { local, projection: [ProjectionElem::Deref] }\n+                if self.body.local_decls[*local].is_ref_to_static() =>\n             {\n                 if access_place.projection.len() == 1 {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();\n                 } else {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    let local_info = &self.body.local_decls[local].local_info;\n+                    let local_info = &self.body.local_decls[*local].local_info;\n                     if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n                         let static_name = &self.infcx.tcx.item_name(def_id);\n                         reason = format!(\", as `{}` is an immutable static item\", static_name);\n@@ -92,16 +92,16 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n-            PlaceRef { base: _, projection: [proj_base @ .., ProjectionElem::Deref] } => {\n-                if the_place_err.base == &PlaceBase::Local(Local::new(1))\n+            PlaceRef { local: _, projection: [proj_base @ .., ProjectionElem::Deref] } => {\n+                if *the_place_err.local == Local::new(1)\n                     && proj_base.is_empty()\n                     && !self.upvars.is_empty()\n                 {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.body.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n                         Place::ty_from(\n-                            the_place_err.base,\n+                            the_place_err.local,\n                             the_place_err.projection,\n                             *self.body,\n                             self.infcx.tcx\n@@ -116,7 +116,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 } else {\n                     let source = self.borrowed_content_source(PlaceRef {\n-                        base: the_place_err.base,\n+                        local: the_place_err.local,\n                         projection: proj_base,\n                     });\n                     let pointer_type = source.describe_for_immutable_place();\n@@ -136,10 +136,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            PlaceRef { base: _, projection: [.., ProjectionElem::Index(_)] }\n-            | PlaceRef { base: _, projection: [.., ProjectionElem::ConstantIndex { .. }] }\n-            | PlaceRef { base: _, projection: [.., ProjectionElem::Subslice { .. }] }\n-            | PlaceRef { base: _, projection: [.., ProjectionElem::Downcast(..)] } => {\n+            PlaceRef { local: _, projection: [.., ProjectionElem::Index(_)] }\n+            | PlaceRef { local: _, projection: [.., ProjectionElem::ConstantIndex { .. }] }\n+            | PlaceRef { local: _, projection: [.., ProjectionElem::Subslice { .. }] }\n+            | PlaceRef { local: _, projection: [.., ProjectionElem::Downcast(..)] } => {\n                 bug!(\"Unexpected immutable place.\")\n             }\n         }\n@@ -187,15 +187,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // struct we've got a field access of (it must be a reference since there's a deref\n             // after the field access).\n             PlaceRef {\n-                base,\n+                local,\n                 projection:\n                     [proj_base @ .., ProjectionElem::Deref, ProjectionElem::Field(field, _), ProjectionElem::Deref],\n             } => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    Place::ty_from(base, proj_base, *self.body, self.infcx.tcx).ty,\n+                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -208,7 +208,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             // Suggest removing a `&mut` from the use of a mutable reference.\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] }\n+            PlaceRef { local, projection: [] }\n                 if {\n                     self.body\n                         .local_decls\n@@ -246,7 +246,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             // We want to suggest users use `let mut` for local (user\n             // variable) mutations...\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] }\n+            PlaceRef { local, projection: [] }\n                 if self.body.local_decls[*local].can_be_made_mutable() =>\n             {\n                 // ... but it doesn't make sense to suggest it on\n@@ -267,11 +267,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             // Also suggest adding mut for upvars\n             PlaceRef {\n-                base,\n+                local,\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(base, proj_base, *self.body, self.infcx.tcx).ty\n+                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // complete hack to approximate old AST-borrowck\n             // diagnostic: if the span starts with a mutable borrow of\n             // a local variable, then just suggest the user remove it.\n-            PlaceRef { base: PlaceBase::Local(_), projection: [] }\n+            PlaceRef { local: _, projection: [] }\n                 if {\n                     if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         snippet.starts_with(\"&mut \")\n@@ -311,7 +311,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 err.span_label(span, \"try removing `&mut` here\");\n             }\n \n-            PlaceRef { base: PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n+            PlaceRef { local, projection: [ProjectionElem::Deref] }\n                 if self.body.local_decls[*local].is_ref_for_guard() =>\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -325,7 +325,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             //\n             // FIXME: can this case be generalized to work for an\n             // arbitrary base for the projection?\n-            PlaceRef { base: PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n+            PlaceRef { local, projection: [ProjectionElem::Deref] }\n                 if self.body.local_decls[*local].is_user_variable() =>\n             {\n                 let local_decl = &self.body.local_decls[*local];\n@@ -408,18 +408,18 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             PlaceRef {\n-                base,\n+                local,\n                 projection: [ProjectionElem::Deref],\n                 // FIXME document what is this 1 magic number about\n-            } if *base == PlaceBase::Local(Local::new(1)) && !self.upvars.is_empty() => {\n+            } if *local == Local::new(1) && !self.upvars.is_empty() => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_help(\n                     self.body.span,\n                     \"consider changing this to accept closures that implement `FnMut`\",\n                 );\n             }\n \n-            PlaceRef { base: _, projection: [.., ProjectionElem::Deref] } => {\n+            PlaceRef { local: _, projection: [.., ProjectionElem::Deref] } => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 match opt_source {"}, {"sha": "7b0a103fd00383effcbd24cc91092986002362c7", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 45, "deletions": 66, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -5,7 +5,7 @@ use rustc::lint::builtin::MUTABLE_BORROW_RESERVATION_CONFLICT;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::mir::{\n     read_only, Body, BodyAndCache, ClearCrossCrate, Local, Location, Mutability, Operand, Place,\n-    PlaceBase, PlaceElem, PlaceRef, ReadOnlyBodyAndCache,\n+    PlaceElem, PlaceRef, ReadOnlyBodyAndCache,\n };\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n@@ -815,7 +815,7 @@ enum InitializationRequiringAction {\n }\n \n struct RootPlace<'d, 'tcx> {\n-    place_base: &'d PlaceBase,\n+    place_local: &'d Local,\n     place_projection: &'d [PlaceElem<'tcx>],\n     is_local_mutation_allowed: LocalMutationIsAllowed,\n }\n@@ -1252,11 +1252,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     this.used_mut_upvars.push(field);\n                 }\n             } else {\n-                match place.base {\n-                    PlaceBase::Local(local) => {\n-                        this.used_mut.insert(local);\n-                    }\n-                }\n+                this.used_mut.insert(place.local);\n             }\n         };\n \n@@ -1380,27 +1376,24 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = &borrow.borrowed_place;\n         let deref = [ProjectionElem::Deref];\n-        let mut root_place = PlaceRef { base: &place.base, projection: &[] };\n+        let mut root_place = PlaceRef { local: &place.local, projection: &[] };\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n         // we just know that all locals are dropped at function exit (otherwise\n         // we'll have a memory leak) and assume that all statics have a destructor.\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n \n-        let (might_be_alive, will_be_dropped) = match root_place.base {\n-            PlaceBase::Local(local) => {\n-                if self.body.local_decls[*local].is_ref_to_thread_local() {\n-                    // Thread-locals might be dropped after the function exits\n-                    // We have to dereference the outer reference because\n-                    // borrows don't conflict behind shared references.\n-                    root_place.projection = &deref;\n-                    (true, true)\n-                } else {\n-                    (false, self.locals_are_invalidated_at_exit)\n-                }\n-            }\n-        };\n+        let (might_be_alive, will_be_dropped) =\n+            if self.body.local_decls[*root_place.local].is_ref_to_thread_local() {\n+                // Thread-locals might be dropped after the function exits\n+                // We have to dereference the outer reference because\n+                // borrows don't conflict behind shared references.\n+                root_place.projection = &deref;\n+                (true, true)\n+            } else {\n+                (false, self.locals_are_invalidated_at_exit)\n+            };\n \n         if !will_be_dropped {\n             debug!(\"place_is_invalidated_at_exit({:?}) - won't be dropped\", place);\n@@ -1738,9 +1731,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             place_span.0.projection\n         {\n             let place_ty =\n-                Place::ty_from(place_span.0.base, base_proj, self.body(), self.infcx.tcx);\n+                Place::ty_from(place_span.0.local, base_proj, self.body(), self.infcx.tcx);\n             if let ty::Array(..) = place_ty.ty.kind {\n-                let array_place = PlaceRef { base: place_span.0.base, projection: base_proj };\n+                let array_place = PlaceRef { local: place_span.0.local, projection: base_proj };\n                 self.check_if_subslice_element_is_moved(\n                     location,\n                     desired_action,\n@@ -1837,7 +1830,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     self.check_if_full_path_is_moved(\n                         location, InitializationRequiringAction::Use,\n                         (PlaceRef {\n-                            base: &place.base,\n+                            local: &place.local,\n                             projection: proj_base,\n                         }, span), flow_state);\n                     // (base initialized; no need to\n@@ -1855,13 +1848,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // assigning to `P.f` requires `P` itself\n                     // be already initialized\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(&place.base, proj_base, self.body(), tcx).ty;\n+                    let base_ty = Place::ty_from(&place.local, proj_base, self.body(), tcx).ty;\n                     match base_ty.kind {\n                         ty::Adt(def, _) if def.has_dtor(tcx) => {\n                             self.check_if_path_or_subpath_is_moved(\n                                 location, InitializationRequiringAction::Assignment,\n                                 (PlaceRef {\n-                                    base: &place.base,\n+                                    local: &place.local,\n                                     projection: proj_base,\n                                 }, span), flow_state);\n \n@@ -1874,23 +1867,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // is allowed, remove this match arm.\n                         ty::Adt(..) | ty::Tuple(..) => {\n                             check_parent_of_field(self, location, PlaceRef {\n-                                base: &place.base,\n+                                local: &place.local,\n                                 projection: proj_base,\n                             }, span, flow_state);\n \n-                            match place.base {\n-                                // rust-lang/rust#21232,\n-                                // #54499, #54986: during\n-                                // period where we reject\n-                                // partial initialization, do\n-                                // not complain about\n-                                // unnecessary `mut` on an\n-                                // attempt to do a partial\n-                                // initialization.\n-                                PlaceBase::Local(local) => {\n-                                    self.used_mut.insert(local);\n-                                }\n-                            }\n+                            // rust-lang/rust#21232, #54499, #54986: during period where we reject\n+                            // partial initialization, do not complain about unnecessary `mut` on\n+                            // an attempt to do a partial initialization.\n+                            self.used_mut.insert(place.local);\n                         }\n \n                         _ => {}\n@@ -1968,7 +1952,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n                 if let ty::Adt(def, _) =\n-                    Place::ty_from(base.base, base.projection, this.body(), tcx).ty.kind\n+                    Place::ty_from(base.local, base.projection, this.body(), tcx).ty.kind\n                 {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n@@ -2087,9 +2071,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // partial initialization, do not complain about mutability\n         // errors except for actual mutation (as opposed to an attempt\n         // to do a partial initialization).\n-        let previously_initialized = match place.base {\n-            PlaceBase::Local(local) => self.is_local_ever_initialized(local, flow_state).is_some(),\n-        };\n+        let previously_initialized =\n+            self.is_local_ever_initialized(place.local, flow_state).is_some();\n \n         // at this point, we have set up the error reporting state.\n         if previously_initialized {\n@@ -2118,11 +2101,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Adds the place into the used mutable variables set\n     fn add_used_mut<'d>(&mut self, root_place: RootPlace<'d, 'tcx>, flow_state: &Flows<'cx, 'tcx>) {\n         match root_place {\n-            RootPlace {\n-                place_base: PlaceBase::Local(local),\n-                place_projection: [],\n-                is_local_mutation_allowed,\n-            } => {\n+            RootPlace { place_local: local, place_projection: [], is_local_mutation_allowed } => {\n                 // If the local may have been initialized, and it is now currently being\n                 // mutated, then it is justified to be annotated with the `mut`\n                 // keyword, since the mutation may be a possible reassignment.\n@@ -2133,18 +2112,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n             RootPlace {\n-                place_base: _,\n+                place_local: _,\n                 place_projection: _,\n                 is_local_mutation_allowed: LocalMutationIsAllowed::Yes,\n             } => {}\n             RootPlace {\n-                place_base,\n+                place_local,\n                 place_projection: place_projection @ [.., _],\n                 is_local_mutation_allowed: _,\n             } => {\n                 if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n-                    base: &place_base,\n-                    projection: &place_projection,\n+                    local: place_local,\n+                    projection: place_projection,\n                 }) {\n                     self.used_mut_upvars.push(field);\n                 }\n@@ -2160,34 +2139,34 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n     ) -> Result<RootPlace<'d, 'tcx>, PlaceRef<'d, 'tcx>> {\n         match place {\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] } => {\n+            PlaceRef { local, projection: [] } => {\n                 let local = &self.body.local_decls[*local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes => Ok(RootPlace {\n-                            place_base: place.base,\n+                            place_local: place.local,\n                             place_projection: place.projection,\n                             is_local_mutation_allowed: LocalMutationIsAllowed::Yes,\n                         }),\n                         LocalMutationIsAllowed::ExceptUpvars => Ok(RootPlace {\n-                            place_base: place.base,\n+                            place_local: place.local,\n                             place_projection: place.projection,\n                             is_local_mutation_allowed: LocalMutationIsAllowed::ExceptUpvars,\n                         }),\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n                     Mutability::Mut => Ok(RootPlace {\n-                        place_base: place.base,\n+                        place_local: place.local,\n                         place_projection: place.projection,\n                         is_local_mutation_allowed,\n                     }),\n                 }\n             }\n-            PlaceRef { base: _, projection: [proj_base @ .., elem] } => {\n+            PlaceRef { local: _, projection: [proj_base @ .., elem] } => {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let base_ty =\n-                            Place::ty_from(place.base, proj_base, self.body(), self.infcx.tcx).ty;\n+                            Place::ty_from(place.local, proj_base, self.body(), self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.kind {\n@@ -2206,7 +2185,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                         };\n \n                                         self.is_mutable(\n-                                            PlaceRef { base: place.base, projection: proj_base },\n+                                            PlaceRef { local: place.local, projection: proj_base },\n                                             mode,\n                                         )\n                                     }\n@@ -2219,15 +2198,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     // `*mut` raw pointers are always mutable, regardless of\n                                     // context. The users have to check by themselves.\n                                     hir::Mutability::Mut => Ok(RootPlace {\n-                                        place_base: place.base,\n+                                        place_local: place.local,\n                                         place_projection: place.projection,\n                                         is_local_mutation_allowed,\n                                     }),\n                                 }\n                             }\n                             // `Box<T>` owns its content, so mutable if its location is mutable\n                             _ if base_ty.is_box() => self.is_mutable(\n-                                PlaceRef { base: place.base, projection: proj_base },\n+                                PlaceRef { local: place.local, projection: proj_base },\n                                 is_local_mutation_allowed,\n                             ),\n                             // Deref should only be for reference, pointers or boxes\n@@ -2283,19 +2262,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     // }\n                                     // ```\n                                     let _ = self.is_mutable(\n-                                        PlaceRef { base: place.base, projection: proj_base },\n+                                        PlaceRef { local: place.local, projection: proj_base },\n                                         is_local_mutation_allowed,\n                                     )?;\n                                     Ok(RootPlace {\n-                                        place_base: place.base,\n+                                        place_local: place.local,\n                                         place_projection: place.projection,\n                                         is_local_mutation_allowed,\n                                     })\n                                 }\n                             }\n                         } else {\n                             self.is_mutable(\n-                                PlaceRef { base: place.base, projection: proj_base },\n+                                PlaceRef { local: place.local, projection: proj_base },\n                                 is_local_mutation_allowed,\n                             )\n                         }\n@@ -2321,7 +2300,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place_projection {\n             [base @ .., ProjectionElem::Field(field, _ty)] => {\n                 let tcx = self.infcx.tcx;\n-                let base_ty = Place::ty_from(place_ref.base, base, self.body(), tcx).ty;\n+                let base_ty = Place::ty_from(place_ref.local, base, self.body(), tcx).ty;\n \n                 if (base_ty.is_closure() || base_ty.is_generator())\n                     && (!by_ref || self.upvars[field.index()].by_ref)"}, {"sha": "deec6f386ffb3d9175795b83a3f37ec5c9265161", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -3,7 +3,7 @@ use crate::borrow_check::places_conflict;\n use crate::borrow_check::AccessDepth;\n use crate::dataflow::indexes::BorrowIndex;\n use rustc::mir::BorrowKind;\n-use rustc::mir::{BasicBlock, Body, Location, Place, PlaceBase};\n+use rustc::mir::{BasicBlock, Body, Location, Place};\n use rustc::ty::TyCtxt;\n use rustc_data_structures::graph::dominators::Dominators;\n \n@@ -131,9 +131,7 @@ pub(super) fn is_active<'tcx>(\n /// Determines if a given borrow is borrowing local data\n /// This is called for all Yield expressions on movable generators\n pub(super) fn borrow_of_local_data(place: &Place<'_>) -> bool {\n-    match place.base {\n-        // Reborrow of already borrowed data is ignored\n-        // Any errors will be caught on the initial borrow\n-        PlaceBase::Local(_) => !place.is_indirect(),\n-    }\n+    // Reborrow of already borrowed data is ignored\n+    // Any errors will be caught on the initial borrow\n+    !place.is_indirect()\n }"}, {"sha": "ac02da2661586d57c38ec867003b3956259a0ee3", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -1,6 +1,6 @@\n use crate::borrow_check::borrow_set::LocalsStateAtExit;\n use rustc::mir::ProjectionElem;\n-use rustc::mir::{Body, Mutability, Place, PlaceBase};\n+use rustc::mir::{Body, Mutability, Place};\n use rustc::ty::{self, TyCtxt};\n use rustc_hir as hir;\n \n@@ -25,40 +25,35 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n-        let local = match self.base {\n-            // If a local variable is immutable, then we only need to track borrows to guard\n-            // against two kinds of errors:\n-            // * The variable being dropped while still borrowed (e.g., because the fn returns\n-            //   a reference to a local variable)\n-            // * The variable being moved while still borrowed\n-            //\n-            // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n-            // so we don't have to worry about mutation while borrowed.\n-            PlaceBase::Local(local) => match locals_state_at_exit {\n-                LocalsStateAtExit::AllAreInvalidated => local,\n-                LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n-                    let ignore = !has_storage_dead_or_moved.contains(local)\n-                        && body.local_decls[local].mutability == Mutability::Not;\n-                    debug!(\"ignore_borrow: local {:?} => {:?}\", local, ignore);\n-                    if ignore {\n-                        return true;\n-                    } else {\n-                        local\n-                    }\n-                }\n-            },\n-        };\n+        // If a local variable is immutable, then we only need to track borrows to guard\n+        // against two kinds of errors:\n+        // * The variable being dropped while still borrowed (e.g., because the fn returns\n+        //   a reference to a local variable)\n+        // * The variable being moved while still borrowed\n+        //\n+        // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n+        // so we don't have to worry about mutation while borrowed.\n+        if let LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } =\n+            locals_state_at_exit\n+        {\n+            let ignore = !has_storage_dead_or_moved.contains(self.local)\n+                && body.local_decls[self.local].mutability == Mutability::Not;\n+            debug!(\"ignore_borrow: local {:?} => {:?}\", self.local, ignore);\n+            if ignore {\n+                return true;\n+            }\n+        }\n \n         for (i, elem) in self.projection.iter().enumerate() {\n             let proj_base = &self.projection[..i];\n \n             if *elem == ProjectionElem::Deref {\n-                let ty = Place::ty_from(&self.base, proj_base, body, tcx).ty;\n+                let ty = Place::ty_from(&self.local, proj_base, body, tcx).ty;\n                 match ty.kind {\n                     ty::Ref(_, _, hir::Mutability::Not) if i == 0 => {\n                         // For references to thread-local statics, we do need\n                         // to track the borrow.\n-                        if body.local_decls[local].is_ref_to_thread_local() {\n+                        if body.local_decls[self.local].is_ref_to_thread_local() {\n                             continue;\n                         }\n                         return true;"}, {"sha": "b95d1af11ad1d1c6fe64c250c83d3c773a79315b", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -1,7 +1,7 @@\n use crate::borrow_check::ArtificialField;\n use crate::borrow_check::Overlap;\n use crate::borrow_check::{AccessDepth, Deep, Shallow};\n-use rustc::mir::{Body, BorrowKind, Place, PlaceBase, PlaceElem, PlaceRef, ProjectionElem};\n+use rustc::mir::{Body, BorrowKind, Local, Place, PlaceElem, PlaceRef, ProjectionElem};\n use rustc::ty::{self, TyCtxt};\n use rustc_hir as hir;\n use std::cmp::max;\n@@ -119,10 +119,10 @@ fn place_components_conflict<'tcx>(\n     //    and either equal or disjoint.\n     //  - If we did run out of access, the borrow can access a part of it.\n \n-    let borrow_base = &borrow_place.base;\n-    let access_base = access_place.base;\n+    let borrow_local = &borrow_place.local;\n+    let access_local = access_place.local;\n \n-    match place_base_conflict(borrow_base, access_base) {\n+    match place_base_conflict(borrow_local, access_local) {\n         Overlap::Arbitrary => {\n             bug!(\"Two base can't return Arbitrary\");\n         }\n@@ -161,7 +161,7 @@ fn place_components_conflict<'tcx>(\n         match place_projection_conflict(\n             tcx,\n             body,\n-            borrow_base,\n+            borrow_local,\n             borrow_proj_base,\n             borrow_c,\n             access_c,\n@@ -208,7 +208,7 @@ fn place_components_conflict<'tcx>(\n             // access cares about.\n \n             let proj_base = &borrow_place.projection[..access_place.projection.len() + i];\n-            let base_ty = Place::ty_from(borrow_base, proj_base, body, tcx).ty;\n+            let base_ty = Place::ty_from(borrow_local, proj_base, body, tcx).ty;\n \n             match (elem, &base_ty.kind, access) {\n                 (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n@@ -293,19 +293,15 @@ fn place_components_conflict<'tcx>(\n // Given that the bases of `elem1` and `elem2` are always either equal\n // or disjoint (and have the same type!), return the overlap situation\n // between `elem1` and `elem2`.\n-fn place_base_conflict(elem1: &PlaceBase, elem2: &PlaceBase) -> Overlap {\n-    match (elem1, elem2) {\n-        (PlaceBase::Local(l1), PlaceBase::Local(l2)) => {\n-            if l1 == l2 {\n-                // the same local - base case, equal\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n-                Overlap::EqualOrDisjoint\n-            } else {\n-                // different locals - base case, disjoint\n-                debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n-                Overlap::Disjoint\n-            }\n-        }\n+fn place_base_conflict(l1: &Local, l2: &Local) -> Overlap {\n+    if l1 == l2 {\n+        // the same local - base case, equal\n+        debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n+        Overlap::EqualOrDisjoint\n+    } else {\n+        // different locals - base case, disjoint\n+        debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n+        Overlap::Disjoint\n     }\n }\n \n@@ -315,7 +311,7 @@ fn place_base_conflict(elem1: &PlaceBase, elem2: &PlaceBase) -> Overlap {\n fn place_projection_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    pi1_base: &PlaceBase,\n+    pi1_local: &Local,\n     pi1_proj_base: &[PlaceElem<'tcx>],\n     pi1_elem: &PlaceElem<'tcx>,\n     pi2_elem: &PlaceElem<'tcx>,\n@@ -333,7 +329,7 @@ fn place_projection_conflict<'tcx>(\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n                 Overlap::EqualOrDisjoint\n             } else {\n-                let ty = Place::ty_from(pi1_base, pi1_proj_base, body, tcx).ty;\n+                let ty = Place::ty_from(pi1_local, pi1_proj_base, body, tcx).ty;\n                 match ty.kind {\n                     ty::Adt(def, _) if def.is_union() => {\n                         // Different fields of a union, we are basically stuck."}, {"sha": "31bee460fa0113f4a9be55e61c87062f0f4c0aad", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -9,7 +9,7 @@\n \n use super::MirBorrowckCtxt;\n \n-use rustc::mir::{Place, PlaceBase, PlaceRef, ProjectionElem, ReadOnlyBodyAndCache};\n+use rustc::mir::{Place, PlaceRef, ProjectionElem, ReadOnlyBodyAndCache};\n use rustc::ty::{self, TyCtxt};\n use rustc_hir as hir;\n \n@@ -19,7 +19,7 @@ pub trait IsPrefixOf<'cx, 'tcx> {\n \n impl<'cx, 'tcx> IsPrefixOf<'cx, 'tcx> for PlaceRef<'cx, 'tcx> {\n     fn is_prefix_of(&self, other: PlaceRef<'cx, 'tcx>) -> bool {\n-        self.base == other.base\n+        self.local == other.local\n             && self.projection.len() <= other.projection.len()\n             && self.projection == &other.projection[..self.projection.len()]\n     }\n@@ -69,22 +69,23 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n \n         'cursor: loop {\n             match &cursor {\n-                PlaceRef { base: PlaceBase::Local(_), projection: [] } => {\n+                PlaceRef { local: _, projection: [] } => {\n                     self.next = None;\n                     return Some(cursor);\n                 }\n-                PlaceRef { base: _, projection: [proj_base @ .., elem] } => {\n+                PlaceRef { local: _, projection: [proj_base @ .., elem] } => {\n                     match elem {\n                         ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n                             // FIXME: add union handling\n-                            self.next = Some(PlaceRef { base: cursor.base, projection: proj_base });\n+                            self.next =\n+                                Some(PlaceRef { local: cursor.local, projection: proj_base });\n                             return Some(cursor);\n                         }\n                         ProjectionElem::Downcast(..)\n                         | ProjectionElem::Subslice { .. }\n                         | ProjectionElem::ConstantIndex { .. }\n                         | ProjectionElem::Index(_) => {\n-                            cursor = PlaceRef { base: cursor.base, projection: proj_base };\n+                            cursor = PlaceRef { local: cursor.local, projection: proj_base };\n                             continue 'cursor;\n                         }\n                         ProjectionElem::Deref => {\n@@ -105,7 +106,8 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         PrefixSet::All => {\n                             // All prefixes: just blindly enqueue the base\n                             // of the projection.\n-                            self.next = Some(PlaceRef { base: cursor.base, projection: proj_base });\n+                            self.next =\n+                                Some(PlaceRef { local: cursor.local, projection: proj_base });\n                             return Some(cursor);\n                         }\n                         PrefixSet::Supporting => {\n@@ -118,7 +120,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     // derefs, except we stop at the deref of a shared\n                     // reference.\n \n-                    let ty = Place::ty_from(cursor.base, proj_base, *self.body, self.tcx).ty;\n+                    let ty = Place::ty_from(cursor.local, proj_base, *self.body, self.tcx).ty;\n                     match ty.kind {\n                         ty::RawPtr(_) | ty::Ref(_ /*rgn*/, _ /*ty*/, hir::Mutability::Not) => {\n                             // don't continue traversing over derefs of raw pointers or shared\n@@ -128,12 +130,14 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         }\n \n                         ty::Ref(_ /*rgn*/, _ /*ty*/, hir::Mutability::Mut) => {\n-                            self.next = Some(PlaceRef { base: cursor.base, projection: proj_base });\n+                            self.next =\n+                                Some(PlaceRef { local: cursor.local, projection: proj_base });\n                             return Some(cursor);\n                         }\n \n                         ty::Adt(..) if ty.is_box() => {\n-                            self.next = Some(PlaceRef { base: cursor.base, projection: proj_base });\n+                            self.next =\n+                                Some(PlaceRef { local: cursor.local, projection: proj_base });\n                             return Some(cursor);\n                         }\n "}, {"sha": "947bbef4379f5ab780af9363246c4d620b623af6", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -465,9 +465,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n \n-        let mut place_ty = match &place.base {\n-            PlaceBase::Local(index) => PlaceTy::from_ty(self.body.local_decls[*index].ty),\n-        };\n+        let mut place_ty = PlaceTy::from_ty(self.body.local_decls[place.local].ty);\n \n         if place.projection.is_empty() {\n             if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n@@ -2389,7 +2387,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             match elem {\n                 ProjectionElem::Deref => {\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(&borrowed_place.base, proj_base, body, tcx).ty;\n+                    let base_ty = Place::ty_from(&borrowed_place.local, proj_base, body, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.kind {"}, {"sha": "5e4eebb771f21d8a6cf5e26fac8cbeed481f9e49", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{Local, Location, Place, PlaceBase, Statement, StatementKind, TerminatorKind};\n+use rustc::mir::{Local, Location, Place, Statement, StatementKind, TerminatorKind};\n \n use rustc_data_structures::fx::FxHashSet;\n \n@@ -57,11 +57,7 @@ impl GatherUsedMutsVisitor<'_, '_, '_> {\n         // be those that were never initialized - we will consider those as being used as\n         // they will either have been removed by unreachable code optimizations; or linted\n         // as unused variables.\n-        match into.base {\n-            PlaceBase::Local(local) => {\n-                self.never_initialized_mut_locals.remove(&local);\n-            }\n-        }\n+        self.never_initialized_mut_locals.remove(&into.local);\n     }\n }\n \n@@ -82,13 +78,11 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, _location: Location) {\n         match &statement.kind {\n             StatementKind::Assign(box (into, _)) => {\n-                match into.base {\n-                    PlaceBase::Local(local) => debug!(\n-                        \"visit_statement: statement={:?} local={:?} \\\n-                            never_initialized_mut_locals={:?}\",\n-                        statement, local, self.never_initialized_mut_locals\n-                    ),\n-                }\n+                debug!(\n+                    \"visit_statement: statement={:?} local={:?} \\\n+                    never_initialized_mut_locals={:?}\",\n+                    statement, into.local, self.never_initialized_mut_locals\n+                );\n                 self.remove_never_initialized_mut_locals(into);\n             }\n             _ => {}"}, {"sha": "eb2e87f4a2d419526f89154dfcb9de6e4707b567", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -20,13 +20,13 @@ use rustc_index::vec::Idx;\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n #[derive(Clone)]\n struct PlaceBuilder<'tcx> {\n-    base: PlaceBase,\n+    local: Local,\n     projection: Vec<PlaceElem<'tcx>>,\n }\n \n impl PlaceBuilder<'tcx> {\n     fn into_place(self, tcx: TyCtxt<'tcx>) -> Place<'tcx> {\n-        Place { base: self.base, projection: tcx.intern_place_elems(&self.projection) }\n+        Place { local: self.local, projection: tcx.intern_place_elems(&self.projection) }\n     }\n \n     fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n@@ -49,13 +49,7 @@ impl PlaceBuilder<'tcx> {\n \n impl From<Local> for PlaceBuilder<'tcx> {\n     fn from(local: Local) -> Self {\n-        Self { base: local.into(), projection: Vec::new() }\n-    }\n-}\n-\n-impl From<PlaceBase> for PlaceBuilder<'tcx> {\n-    fn from(base: PlaceBase) -> Self {\n-        Self { base, projection: Vec::new() }\n+        Self { local, projection: Vec::new() }\n     }\n }\n \n@@ -370,7 +364,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) {\n         let tcx = self.hir.tcx();\n         let place_ty =\n-            Place::ty_from(&base_place.base, &base_place.projection, &self.local_decls, tcx);\n+            Place::ty_from(&base_place.local, &base_place.projection, &self.local_decls, tcx);\n         if let ty::Slice(_) = place_ty.ty.kind {\n             // We need to create fake borrows to ensure that the bounds\n             // check that we just did stays valid. Since we can't assign to\n@@ -380,7 +374,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let fake_borrow_deref_ty = Place::ty_from(\n-                            &base_place.base,\n+                            &base_place.local,\n                             &base_place.projection[..idx],\n                             &self.local_decls,\n                             tcx,\n@@ -398,14 +392,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             Rvalue::Ref(\n                                 tcx.lifetimes.re_erased,\n                                 BorrowKind::Shallow,\n-                                Place { base: base_place.base.clone(), projection },\n+                                Place { local: base_place.local.clone(), projection },\n                             ),\n                         );\n                         fake_borrow_temps.push(fake_borrow_temp);\n                     }\n                     ProjectionElem::Index(_) => {\n                         let index_ty = Place::ty_from(\n-                            &base_place.base,\n+                            &base_place.local,\n                             &base_place.projection[..idx],\n                             &self.local_decls,\n                             tcx,"}, {"sha": "6f7b7258b5a1acb4e00acb1681b511ddf7c62727", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -393,26 +393,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let arg_place = unpack!(block = this.as_place(block, arg));\n \n         let mutability = match arg_place.as_ref() {\n-            PlaceRef { base: &PlaceBase::Local(local), projection: &[] } => {\n-                this.local_decls[local].mutability\n-            }\n-            PlaceRef { base: &PlaceBase::Local(local), projection: &[ProjectionElem::Deref] } => {\n+            PlaceRef { local, projection: &[] } => this.local_decls[*local].mutability,\n+            PlaceRef { local, projection: &[ProjectionElem::Deref] } => {\n                 debug_assert!(\n-                    this.local_decls[local].is_ref_for_guard(),\n+                    this.local_decls[*local].is_ref_for_guard(),\n                     \"Unexpected capture place\",\n                 );\n-                this.local_decls[local].mutability\n+                this.local_decls[*local].mutability\n             }\n             PlaceRef {\n-                ref base,\n+                ref local,\n                 projection: &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             }\n             | PlaceRef {\n-                ref base,\n+                ref local,\n                 projection:\n                     &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _), ProjectionElem::Deref],\n             } => {\n-                let place = PlaceRef { base, projection: proj_base };\n+                let place = PlaceRef { local, projection: proj_base };\n \n                 // Not projected from the implicit `self` in a closure.\n                 debug_assert!("}, {"sha": "1dcd29d923244b3a5045396380d2600d88e8354e", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -890,7 +890,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let proj_base = &source.projection[..i];\n \n                     fake_borrows.insert(Place {\n-                        base: source.base.clone(),\n+                        local: source.local.clone(),\n                         projection: self.hir.tcx().intern_place_elems(proj_base),\n                     });\n                 }\n@@ -1241,7 +1241,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // Insert a shallow borrow after a deref. For other\n                     // projections the borrow of prefix_cursor will\n                     // conflict with any mutation of base.\n-                    all_fake_borrows.push(PlaceRef { base: &place.base, projection: proj_base });\n+                    all_fake_borrows.push(PlaceRef { local: &place.local, projection: proj_base });\n                 }\n             }\n \n@@ -1258,7 +1258,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .into_iter()\n             .map(|matched_place_ref| {\n                 let matched_place = Place {\n-                    base: matched_place_ref.base.clone(),\n+                    local: matched_place_ref.local.clone(),\n                     projection: tcx.intern_place_elems(matched_place_ref.projection),\n                 };\n                 let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).ty;"}, {"sha": "d4813d8ab68ca3ba3fe0f1d0c47ea6803ffa49c7", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -834,7 +834,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             span: tcx_hir.span(var_id),\n                         },\n                         place: Place {\n-                            base: closure_env_arg.into(),\n+                            local: closure_env_arg.into(),\n                             projection: tcx.intern_place_elems(&projs),\n                         },\n                     });"}, {"sha": "63834d0ecda00215a26601e183d944a998541ae7", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -86,10 +86,7 @@ struct BorrowedLocalsVisitor<'gk> {\n }\n \n fn find_local(place: &Place<'_>) -> Option<Local> {\n-    match place.base {\n-        PlaceBase::Local(local) if !place.is_indirect() => Some(local),\n-        _ => None,\n-    }\n+    if !place.is_indirect() { Some(place.local) } else { None }\n }\n \n impl<'tcx> Visitor<'tcx> for BorrowedLocalsVisitor<'_> {"}, {"sha": "f94ee67f2bea7c72d2aab2138bd9d8ddea1b33a3", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -1,4 +1,4 @@\n-use rustc::mir::{self, Body, Location, Place, PlaceBase};\n+use rustc::mir::{self, Body, Location, Place};\n use rustc::ty::RegionVid;\n use rustc::ty::TyCtxt;\n \n@@ -195,38 +195,34 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     fn kill_borrows_on_place(&self, trans: &mut GenKillSet<BorrowIndex>, place: &Place<'tcx>) {\n         debug!(\"kill_borrows_on_place: place={:?}\", place);\n \n-        match place.base {\n-            PlaceBase::Local(local) => {\n-                let other_borrows_of_local =\n-                    self.borrow_set.local_map.get(&local).into_iter().flat_map(|bs| bs.into_iter());\n-\n-                // If the borrowed place is a local with no projections, all other borrows of this\n-                // local must conflict. This is purely an optimization so we don't have to call\n-                // `places_conflict` for every borrow.\n-                if place.projection.is_empty() {\n-                    if !self.body.local_decls[local].is_ref_to_static() {\n-                        trans.kill_all(other_borrows_of_local);\n-                    }\n-                    return;\n-                }\n-\n-                // By passing `PlaceConflictBias::NoOverlap`, we conservatively assume that any given\n-                // pair of array indices are unequal, so that when `places_conflict` returns true, we\n-                // will be assured that two places being compared definitely denotes the same sets of\n-                // locations.\n-                let definitely_conflicting_borrows = other_borrows_of_local.filter(|&&i| {\n-                    places_conflict(\n-                        self.tcx,\n-                        self.body,\n-                        &self.borrow_set.borrows[i].borrowed_place,\n-                        place,\n-                        PlaceConflictBias::NoOverlap,\n-                    )\n-                });\n+        let other_borrows_of_local =\n+            self.borrow_set.local_map.get(&place.local).into_iter().flat_map(|bs| bs.into_iter());\n \n-                trans.kill_all(definitely_conflicting_borrows);\n+        // If the borrowed place is a local with no projections, all other borrows of this\n+        // local must conflict. This is purely an optimization so we don't have to call\n+        // `places_conflict` for every borrow.\n+        if place.projection.is_empty() {\n+            if !self.body.local_decls[place.local].is_ref_to_static() {\n+                trans.kill_all(other_borrows_of_local);\n             }\n+            return;\n         }\n+\n+        // By passing `PlaceConflictBias::NoOverlap`, we conservatively assume that any given\n+        // pair of array indices are unequal, so that when `places_conflict` returns true, we\n+        // will be assured that two places being compared definitely denotes the same sets of\n+        // locations.\n+        let definitely_conflicting_borrows = other_borrows_of_local.filter(|&&i| {\n+            places_conflict(\n+                self.tcx,\n+                self.body,\n+                &self.borrow_set.borrows[i].borrowed_place,\n+                place,\n+                PlaceConflictBias::NoOverlap,\n+            )\n+        });\n+\n+        trans.kill_all(definitely_conflicting_borrows);\n     }\n }\n "}, {"sha": "85bf342c8a39a95da5efd20d1367a1656cd88247", "filename": "src/librustc_mir/dataflow/impls/indirect_mutation.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -111,12 +111,8 @@ impl<'tcx> Visitor<'tcx> for TransferFunction<'_, '_, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: Location) {\n         if let mir::Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n             if self.borrow_allows_mutation(kind, borrowed_place) {\n-                match borrowed_place.base {\n-                    mir::PlaceBase::Local(borrowed_local) if !borrowed_place.is_indirect() => {\n-                        self.trans.gen(borrowed_local)\n-                    }\n-\n-                    _ => (),\n+                if !borrowed_place.is_indirect() {\n+                    self.trans.gen(borrowed_place.local);\n                 }\n             }\n         }"}, {"sha": "6a48d1e98032c0d92426e1b7ae2d8e9b3e2c9144", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -115,14 +115,12 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         match stmt.kind {\n             StatementKind::StorageDead(l) => sets.kill(l),\n             StatementKind::Assign(box (ref place, _))\n-            | StatementKind::SetDiscriminant { box ref place, .. } => match place.base {\n-                PlaceBase::Local(local) => sets.gen(local),\n-            },\n+            | StatementKind::SetDiscriminant { box ref place, .. } => {\n+                sets.gen(place.local);\n+            }\n             StatementKind::InlineAsm(box InlineAsm { ref outputs, .. }) => {\n-                for p in &**outputs {\n-                    match p.base {\n-                        PlaceBase::Local(local) => sets.gen(local),\n-                    }\n+                for place in &**outputs {\n+                    sets.gen(place.local);\n                 }\n             }\n             _ => (),\n@@ -138,10 +136,8 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n     fn before_terminator_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n         self.check_for_borrow(sets, loc);\n \n-        if let TerminatorKind::Call {\n-            destination: Some((Place { base: PlaceBase::Local(local), .. }, _)),\n-            ..\n-        } = self.body[loc.block].terminator().kind\n+        if let TerminatorKind::Call { destination: Some((Place { local, .. }, _)), .. } =\n+            self.body[loc.block].terminator().kind\n         {\n             sets.gen(local);\n         }\n@@ -169,11 +165,7 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         _dest_bb: mir::BasicBlock,\n         dest_place: &mir::Place<'tcx>,\n     ) {\n-        match dest_place.base {\n-            PlaceBase::Local(local) => {\n-                in_out.insert(local);\n-            }\n-        }\n+        in_out.insert(dest_place.local);\n     }\n }\n "}, {"sha": "271bcce6ca53c3873c08dbb559b06854432032b3", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -96,9 +96,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n     fn move_path_for(&mut self, place: &Place<'tcx>) -> Result<MovePathIndex, MoveError<'tcx>> {\n         debug!(\"lookup({:?})\", place);\n-        let mut base = match place.base {\n-            PlaceBase::Local(local) => self.builder.data.rev_lookup.locals[local],\n-        };\n+        let mut base = self.builder.data.rev_lookup.locals[place.local];\n \n         // The move path index of the first union that we find. Once this is\n         // some we stop creating child move paths, since moves from unions\n@@ -111,15 +109,15 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             let proj_base = &place.projection[..i];\n             let body = self.builder.body;\n             let tcx = self.builder.tcx;\n-            let place_ty = Place::ty_from(&place.base, proj_base, body, tcx).ty;\n+            let place_ty = Place::ty_from(&place.local, proj_base, body, tcx).ty;\n             match place_ty.kind {\n                 ty::Ref(..) | ty::RawPtr(..) => {\n                     let proj = &place.projection[..i + 1];\n                     return Err(MoveError::cannot_move_out_of(\n                         self.loc,\n                         BorrowedContent {\n                             target_place: Place {\n-                                base: place.base.clone(),\n+                                local: place.local,\n                                 projection: tcx.intern_place_elems(proj),\n                             },\n                         },\n@@ -160,7 +158,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n \n             if union_path.is_none() {\n                 base = self.add_move_path(base, elem, |tcx| Place {\n-                    base: place.base.clone(),\n+                    local: place.local.clone(),\n                     projection: tcx.intern_place_elems(&place.projection[..i + 1]),\n                 });\n             }\n@@ -433,7 +431,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             // `ConstIndex` patterns. This is done to ensure that all move paths\n             // are disjoint, which is expected by drop elaboration.\n             let base_place = Place {\n-                base: place.base.clone(),\n+                local: place.local.clone(),\n                 projection: self.builder.tcx.intern_place_elems(base),\n             };\n             let base_path = match self.move_path_for(&base_place) {\n@@ -494,10 +492,10 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n         // of the union so it is marked as initialized again.\n         if let [proj_base @ .., ProjectionElem::Field(_, _)] = place.projection {\n             if let ty::Adt(def, _) =\n-                Place::ty_from(place.base, proj_base, self.builder.body, self.builder.tcx).ty.kind\n+                Place::ty_from(place.local, proj_base, self.builder.body, self.builder.tcx).ty.kind\n             {\n                 if def.is_union() {\n-                    place = PlaceRef { base: place.base, projection: proj_base }\n+                    place = PlaceRef { local: place.local, projection: proj_base }\n                 }\n             }\n         }"}, {"sha": "a46465ab4937646b5b744f1bc77f016275cc23fd", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -246,9 +246,7 @@ impl MovePathLookup {\n     // unknown place, but will rather return the nearest available\n     // parent.\n     pub fn find(&self, place: PlaceRef<'_, '_>) -> LookupResult {\n-        let mut result = match place.base {\n-            PlaceBase::Local(local) => self.locals[*local],\n-        };\n+        let mut result = self.locals[*place.local];\n \n         for elem in place.projection.iter() {\n             if let Some(&subpath) = self.projections.get(&(result, elem.lift())) {"}, {"sha": "6df3e6fc5962e50b8a4efe80b7f6f9558116484f", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -462,17 +462,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         place: &mir::Place<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        use rustc::mir::PlaceBase;\n-\n-        let base_op = match &place.base {\n-            PlaceBase::Local(mir::RETURN_PLACE) => throw_unsup!(ReadFromReturnPointer),\n-            PlaceBase::Local(local) => {\n+        let base_op = match place.local {\n+            mir::RETURN_PLACE => throw_unsup!(ReadFromReturnPointer),\n+            local => {\n                 // Do not use the layout passed in as argument if the base we are looking at\n                 // here is not the entire place.\n                 // FIXME use place_projection.is_empty() when is available\n                 let layout = if place.projection.is_empty() { layout } else { None };\n \n-                self.access_local(self.frame(), *local, layout)?\n+                self.access_local(self.frame(), local, layout)?\n             }\n         };\n "}, {"sha": "8888e3fd4632a2a3e1549dea0f646c29e537257f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -624,10 +624,8 @@ where\n         &mut self,\n         place: &mir::Place<'tcx>,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n-        use rustc::mir::PlaceBase;\n-\n-        let mut place_ty = match &place.base {\n-            PlaceBase::Local(mir::RETURN_PLACE) => {\n+        let mut place_ty = match place.local {\n+            mir::RETURN_PLACE => {\n                 // `return_place` has the *caller* layout, but we want to use our\n                 // `layout to verify our assumption. The caller will validate\n                 // their layout on return.\n@@ -648,10 +646,10 @@ where\n                     ))?,\n                 }\n             }\n-            PlaceBase::Local(local) => PlaceTy {\n+            local => PlaceTy {\n                 // This works even for dead/uninitialized locals; we check further when writing\n-                place: Place::Local { frame: self.cur_frame(), local: *local },\n-                layout: self.layout_of_local(self.frame(), *local, None)?,\n+                place: Place::Local { frame: self.cur_frame(), local: local },\n+                layout: self.layout_of_local(self.frame(), local, None)?,\n             },\n         };\n "}, {"sha": "5ccdb4be62461df2c4c99c86f955c622fb083d84", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -182,7 +182,7 @@ use rustc::mir::interpret::{AllocId, ConstValue};\n use rustc::mir::interpret::{ErrorHandled, GlobalAlloc, Scalar};\n use rustc::mir::mono::{InstantiationMode, MonoItem};\n use rustc::mir::visit::Visitor as MirVisitor;\n-use rustc::mir::{self, Location, PlaceBase};\n+use rustc::mir::{self, Local, Location};\n use rustc::session::config::EntryFnType;\n use rustc::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc::ty::print::obsolete::DefPathBasedNames;\n@@ -642,15 +642,10 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n     fn visit_place_base(\n         &mut self,\n-        place_base: &mir::PlaceBase,\n+        _place_local: &Local,\n         _context: mir::visit::PlaceContext,\n         _location: Location,\n     ) {\n-        match place_base {\n-            PlaceBase::Local(_) => {\n-                // Locals have no relevance for collector.\n-            }\n-        }\n     }\n }\n "}, {"sha": "577736f9bd11df64a011adb3f6745890e086d3fc", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -38,12 +38,15 @@ pub trait Qualif {\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         if let [proj_base @ .., elem] = place.projection {\n-            let base_qualif =\n-                Self::in_place(cx, per_local, PlaceRef { base: place.base, projection: proj_base });\n+            let base_qualif = Self::in_place(\n+                cx,\n+                per_local,\n+                PlaceRef { local: place.local, projection: proj_base },\n+            );\n             let qualif = base_qualif\n                 && Self::in_any_value_of_ty(\n                     cx,\n-                    Place::ty_from(place.base, proj_base, *cx.body, cx.tcx)\n+                    Place::ty_from(place.local, proj_base, *cx.body, cx.tcx)\n                         .projection_ty(cx.tcx, elem)\n                         .ty,\n                 );\n@@ -75,8 +78,8 @@ pub trait Qualif {\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         match place {\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] } => per_local(*local),\n-            PlaceRef { base: _, projection: [.., _] } => Self::in_projection(cx, per_local, place),\n+            PlaceRef { local, projection: [] } => per_local(*local),\n+            PlaceRef { local: _, projection: [.., _] } => Self::in_projection(cx, per_local, place),\n         }\n     }\n \n@@ -146,12 +149,12 @@ pub trait Qualif {\n             Rvalue::Ref(_, _, ref place) | Rvalue::AddressOf(_, ref place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n-                    let base_ty = Place::ty_from(&place.base, proj_base, *cx.body, cx.tcx).ty;\n+                    let base_ty = Place::ty_from(&place.local, proj_base, *cx.body, cx.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         return Self::in_place(\n                             cx,\n                             per_local,\n-                            PlaceRef { base: &place.base, projection: proj_base },\n+                            PlaceRef { local: &place.local, projection: proj_base },\n                         );\n                     }\n                 }"}, {"sha": "c445568dd2a9b4043b5677beebf1cbd19adcb6bf", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -47,15 +47,15 @@ where\n         debug_assert!(!place.is_indirect());\n \n         match (value, place.as_ref()) {\n-            (true, mir::PlaceRef { base: &mir::PlaceBase::Local(local), .. }) => {\n-                self.qualifs_per_local.insert(local);\n+            (true, mir::PlaceRef { local, .. }) => {\n+                self.qualifs_per_local.insert(*local);\n             }\n \n             // For now, we do not clear the qualif if a local is overwritten in full by\n             // an unqualified rvalue (e.g. `y = 5`). This is to be consistent\n             // with aggregates where we overwrite all fields with assignments, which would not\n             // get this feature.\n-            (false, mir::PlaceRef { base: &mir::PlaceBase::Local(_local), projection: &[] }) => {\n+            (false, mir::PlaceRef { local: _, projection: &[] }) => {\n                 // self.qualifs_per_local.remove(*local);\n             }\n "}, {"sha": "10a4b7d92b764a266610c206fcfe978bf6384457", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 18, "deletions": 31, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -304,8 +304,8 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                             PlaceContext::MutatingUse(MutatingUseContext::Borrow)\n                         }\n                     };\n-                    self.visit_place_base(&place.base, ctx, location);\n-                    self.visit_projection(&place.base, reborrowed_proj, ctx, location);\n+                    self.visit_place_base(&place.local, ctx, location);\n+                    self.visit_projection(&place.local, reborrowed_proj, ctx, location);\n                     return;\n                 }\n             }\n@@ -317,8 +317,8 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                         }\n                         Mutability::Mut => PlaceContext::MutatingUse(MutatingUseContext::AddressOf),\n                     };\n-                    self.visit_place_base(&place.base, ctx, location);\n-                    self.visit_projection(&place.base, reborrowed_proj, ctx, location);\n+                    self.visit_place_base(&place.local, ctx, location);\n+                    self.visit_projection(&place.local, reborrowed_proj, ctx, location);\n                     return;\n                 }\n             }\n@@ -412,23 +412,14 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         }\n     }\n \n-    fn visit_place_base(\n-        &mut self,\n-        place_base: &PlaceBase,\n-        context: PlaceContext,\n-        location: Location,\n-    ) {\n+    fn visit_place_base(&mut self, place_local: &Local, context: PlaceContext, location: Location) {\n         trace!(\n-            \"visit_place_base: place_base={:?} context={:?} location={:?}\",\n-            place_base,\n+            \"visit_place_base: place_local={:?} context={:?} location={:?}\",\n+            place_local,\n             context,\n             location,\n         );\n-        self.super_place_base(place_base, context, location);\n-\n-        match place_base {\n-            PlaceBase::Local(_) => {}\n-        }\n+        self.super_place_base(place_local, context, location);\n     }\n \n     fn visit_operand(&mut self, op: &Operand<'tcx>, location: Location) {\n@@ -441,30 +432,30 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n     }\n     fn visit_projection_elem(\n         &mut self,\n-        place_base: &PlaceBase,\n+        place_local: &Local,\n         proj_base: &[PlaceElem<'tcx>],\n         elem: &PlaceElem<'tcx>,\n         context: PlaceContext,\n         location: Location,\n     ) {\n         trace!(\n-            \"visit_projection_elem: place_base={:?} proj_base={:?} elem={:?} \\\n+            \"visit_projection_elem: place_local={:?} proj_base={:?} elem={:?} \\\n             context={:?} location={:?}\",\n-            place_base,\n+            place_local,\n             proj_base,\n             elem,\n             context,\n             location,\n         );\n \n-        self.super_projection_elem(place_base, proj_base, elem, context, location);\n+        self.super_projection_elem(place_local, proj_base, elem, context, location);\n \n         match elem {\n             ProjectionElem::Deref => {\n-                let base_ty = Place::ty_from(place_base, proj_base, *self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_local, proj_base, *self.body, self.tcx).ty;\n                 if let ty::RawPtr(_) = base_ty.kind {\n                     if proj_base.is_empty() {\n-                        if let (PlaceBase::Local(local), []) = (place_base, proj_base) {\n+                        if let (local, []) = (place_local, proj_base) {\n                             let decl = &self.body.local_decls[*local];\n                             if let LocalInfo::StaticRef { def_id, .. } = decl.local_info {\n                                 let span = decl.source_info.span;\n@@ -485,7 +476,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Field(..)\n             | ProjectionElem::Index(_) => {\n-                let base_ty = Place::ty_from(place_base, proj_base, *self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_local, proj_base, *self.body, self.tcx).ty;\n                 match base_ty.ty_adt_def() {\n                     Some(def) if def.is_union() => {\n                         self.check_op(ops::UnionAccess);\n@@ -669,19 +660,15 @@ fn place_as_reborrow(\n \n         // A borrow of a `static` also looks like `&(*_1)` in the MIR, but `_1` is a `const`\n         // that points to the allocation for the static. Don't treat these as reborrows.\n-        match place.base {\n-            PlaceBase::Local(local) => {\n-                if body.local_decls[local].is_ref_to_static() {\n-                    return None;\n-                }\n-            }\n+        if body.local_decls[place.local].is_ref_to_static() {\n+            return None;\n         }\n \n         // Ensure the type being derefed is a reference and not a raw pointer.\n         //\n         // This is sufficient to prevent an access to a `static mut` from being marked as a\n         // reborrow, even if the check above were to disappear.\n-        let inner_ty = Place::ty_from(&place.base, inner, body, tcx).ty;\n+        let inner_ty = Place::ty_from(&place.local, inner, body, tcx).ty;\n         match inner_ty.kind {\n             ty::Ref(..) => Some(inner),\n             _ => None,"}, {"sha": "934b262c2f9cb689d64458e28785e501b8770dcf", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -190,12 +190,6 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n     }\n \n     fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n-        match place.base {\n-            PlaceBase::Local(..) => {\n-                // Locals are safe.\n-            }\n-        }\n-\n         for (i, elem) in place.projection.iter().enumerate() {\n             let proj_base = &place.projection[..i];\n \n@@ -223,7 +217,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n             }\n             let is_borrow_of_interior_mut = context.is_borrow()\n-                && !Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty.is_freeze(\n+                && !Place::ty_from(&place.local, proj_base, self.body, self.tcx).ty.is_freeze(\n                     self.tcx,\n                     self.param_env,\n                     self.source_info.span,\n@@ -238,7 +232,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 self.check_mut_borrowing_layout_constrained_field(place, context.is_mutating_use());\n             }\n             let old_source_info = self.source_info;\n-            if let (PlaceBase::Local(local), []) = (&place.base, proj_base) {\n+            if let (local, []) = (&place.local, proj_base) {\n                 let decl = &self.body.local_decls[*local];\n                 if decl.internal {\n                     // Internal locals are used in the `move_val_init` desugaring.\n@@ -266,7 +260,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n-            let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n+            let base_ty = Place::ty_from(&place.local, proj_base, self.body, self.tcx).ty;\n             match base_ty.kind {\n                 ty::RawPtr(..) => self.require_unsafe(\n                     \"dereference of raw pointer\",\n@@ -420,7 +414,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n             match elem {\n                 ProjectionElem::Field(..) => {\n                     let ty =\n-                        Place::ty_from(&place.base, proj_base, &self.body.local_decls, self.tcx).ty;\n+                        Place::ty_from(&place.local, proj_base, &self.body.local_decls, self.tcx)\n+                            .ty;\n                     match ty.kind {\n                         ty::Adt(def, _) => match self.tcx.layout_scalar_valid_range(def.did) {\n                             (Bound::Unbounded, Bound::Unbounded) => {}"}, {"sha": "79506f3f22a67ccde5ce2428266d0e8b22f31268", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -10,7 +10,7 @@ use rustc::mir::visit::{\n };\n use rustc::mir::{\n     read_only, AggregateKind, BasicBlock, BinOp, Body, BodyAndCache, ClearCrossCrate, Constant,\n-    Local, LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, ReadOnlyBodyAndCache, Rvalue,\n+    Local, LocalDecl, LocalKind, Location, Operand, Place, ReadOnlyBodyAndCache, Rvalue,\n     SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator, TerminatorKind,\n     UnOp, RETURN_PLACE,\n };\n@@ -872,9 +872,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                         // doesn't use the invalid value\n                         match cond {\n                             Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                                match place.base {\n-                                    PlaceBase::Local(local) => self.remove_const(local),\n-                                }\n+                                self.remove_const(place.local);\n                             }\n                             Operand::Constant(_) => {}\n                         }"}, {"sha": "825ac4a28d86925a9e2f5266edd961121a7cd402", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -112,17 +112,17 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor<'tcx> {\n     }\n \n     fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n-        if place.base == PlaceBase::Local(self_arg()) {\n+        if place.local == self_arg() {\n             replace_base(\n                 place,\n                 Place {\n-                    base: PlaceBase::Local(self_arg()),\n+                    local: self_arg(),\n                     projection: self.tcx().intern_place_elems(&vec![ProjectionElem::Deref]),\n                 },\n                 self.tcx,\n             );\n         } else {\n-            self.visit_place_base(&mut place.base, context, location);\n+            self.visit_place_base(&mut place.local, context, location);\n \n             for elem in place.projection.iter() {\n                 if let PlaceElem::Index(local) = elem {\n@@ -148,11 +148,11 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n     }\n \n     fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n-        if place.base == PlaceBase::Local(self_arg()) {\n+        if place.local == self_arg() {\n             replace_base(\n                 place,\n                 Place {\n-                    base: PlaceBase::Local(self_arg()),\n+                    local: self_arg(),\n                     projection: self.tcx().intern_place_elems(&vec![ProjectionElem::Field(\n                         Field::new(0),\n                         self.ref_gen_ty,\n@@ -161,7 +161,7 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n                 self.tcx,\n             );\n         } else {\n-            self.visit_place_base(&mut place.base, context, location);\n+            self.visit_place_base(&mut place.local, context, location);\n \n             for elem in place.projection.iter() {\n                 if let PlaceElem::Index(local) = elem {\n@@ -173,7 +173,7 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n }\n \n fn replace_base<'tcx>(place: &mut Place<'tcx>, new_base: Place<'tcx>, tcx: TyCtxt<'tcx>) {\n-    place.base = new_base.base;\n+    place.local = new_base.local;\n \n     let mut new_projection = new_base.projection.to_vec();\n     new_projection.append(&mut place.projection.to_vec());\n@@ -236,7 +236,7 @@ impl TransformVisitor<'tcx> {\n         let mut projection = base.projection.to_vec();\n         projection.push(ProjectionElem::Field(Field::new(idx), ty));\n \n-        Place { base: base.base, projection: self.tcx.intern_place_elems(&projection) }\n+        Place { local: base.local, projection: self.tcx.intern_place_elems(&projection) }\n     }\n \n     // Create a statement which changes the discriminant\n@@ -281,14 +281,9 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n         _context: PlaceContext,\n         _location: Location,\n     ) {\n-        match place.base {\n-            PlaceBase::Local(l) =>\n-            // Replace an Local in the remap with a generator struct access\n-            {\n-                if let Some(&(ty, variant_index, idx)) = self.remap.get(&l) {\n-                    replace_base(place, self.make_field(variant_index, idx, ty), self.tcx);\n-                }\n-            }\n+        // Replace an Local in the remap with a generator struct access\n+        if let Some(&(ty, variant_index, idx)) = self.remap.get(&place.local) {\n+            replace_base(place, self.make_field(variant_index, idx, ty), self.tcx);\n         }\n     }\n "}, {"sha": "2dd00fe2fee195038aef34f998364cc2d06f262c", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -430,9 +430,7 @@ impl Inliner<'tcx> {\n                         }\n                     }\n \n-                    match place.base {\n-                        _ => false,\n-                    }\n+                    false\n                 }\n \n                 let dest = if dest_needs_borrow(&destination.0) {\n@@ -644,9 +642,7 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n \n     fn make_integrate_local(&self, local: &Local) -> Local {\n         if *local == RETURN_PLACE {\n-            match self.destination.base {\n-                PlaceBase::Local(l) => return l,\n-            }\n+            return self.destination.local;\n         }\n \n         let idx = local.index() - 1;\n@@ -668,18 +664,14 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n     }\n \n     fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n-        match &mut place.base {\n-            PlaceBase::Local(l) => {\n-                // If this is the `RETURN_PLACE`, we need to rebase any projections onto it.\n-                let dest_proj_len = self.destination.projection.len();\n-                if *l == RETURN_PLACE && dest_proj_len > 0 {\n-                    let mut projs = Vec::with_capacity(dest_proj_len + place.projection.len());\n-                    projs.extend(self.destination.projection);\n-                    projs.extend(place.projection);\n-\n-                    place.projection = self.tcx.intern_place_elems(&*projs);\n-                }\n-            }\n+        // If this is the `RETURN_PLACE`, we need to rebase any projections onto it.\n+        let dest_proj_len = self.destination.projection.len();\n+        if place.local == RETURN_PLACE && dest_proj_len > 0 {\n+            let mut projs = Vec::with_capacity(dest_proj_len + place.projection.len());\n+            projs.extend(self.destination.projection);\n+            projs.extend(place.projection);\n+\n+            place.projection = self.tcx.intern_place_elems(&*projs);\n         }\n         // Handles integrating any locals that occur in the base\n         // or projections"}, {"sha": "69eedb1ae1876971a62a8b1fc17afd7c8c0ea998", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -3,7 +3,7 @@\n use crate::transform::{MirPass, MirSource};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::mir::{\n-    read_only, Body, BodyAndCache, Constant, Local, Location, Operand, Place, PlaceBase, PlaceRef,\n+    read_only, Body, BodyAndCache, Constant, Local, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue,\n };\n use rustc::ty::{self, TyCtxt};\n@@ -55,7 +55,7 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n \n                         Place {\n                             // Replace with dummy\n-                            base: mem::replace(&mut place.base, PlaceBase::Local(Local::new(0))),\n+                            local: mem::replace(&mut place.local, Local::new(0)),\n                             projection: self.tcx().intern_place_elems(proj_l),\n                         }\n                     } else {\n@@ -92,10 +92,10 @@ impl OptimizationFinder<'b, 'tcx> {\n impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         if let Rvalue::Ref(_, _, place) = rvalue {\n-            if let PlaceRef { base, projection: &[ref proj_base @ .., ProjectionElem::Deref] } =\n+            if let PlaceRef { local, projection: &[ref proj_base @ .., ProjectionElem::Deref] } =\n                 place.as_ref()\n             {\n-                if Place::ty_from(base, proj_base, self.body, self.tcx).ty.is_region_ptr() {\n+                if Place::ty_from(local, proj_base, self.body, self.tcx).ty.is_region_ptr() {\n                     self.optimizations.and_stars.insert(location);\n                 }\n             }"}, {"sha": "90393ec6c8c8099f1f9cf34ff267aee1d623510f", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -308,17 +308,14 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n                         // We can only promote interior borrows of promotable temps (non-temps\n                         // don't get promoted anyway).\n-                        let base = match place.base {\n-                            PlaceBase::Local(local) => local,\n-                        };\n-                        self.validate_local(base)?;\n+                        self.validate_local(place.local)?;\n \n                         if place.projection.contains(&ProjectionElem::Deref) {\n                             return Err(Unpromotable);\n                         }\n \n                         let mut has_mut_interior =\n-                            self.qualif_local::<qualifs::HasMutInterior>(base);\n+                            self.qualif_local::<qualifs::HasMutInterior>(place.local);\n                         // HACK(eddyb) this should compute the same thing as\n                         // `<HasMutInterior as Qualif>::in_projection` from\n                         // `check_consts::qualifs` but without recursion.\n@@ -332,7 +329,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                 // FIXME(eddyb) this is probably excessive, with\n                                 // the exception of `union` member accesses.\n                                 let ty =\n-                                    Place::ty_from(&place.base, proj_base, *self.body, self.tcx)\n+                                    Place::ty_from(&place.local, proj_base, *self.body, self.tcx)\n                                         .projection_ty(self.tcx, elem)\n                                         .ty;\n                                 if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n@@ -348,7 +345,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         if has_mut_interior {\n                             return Err(Unpromotable);\n                         }\n-                        if self.qualif_local::<qualifs::NeedsDrop>(base) {\n+                        if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n                             return Err(Unpromotable);\n                         }\n \n@@ -478,10 +475,8 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n     fn validate_place(&self, place: PlaceRef<'_, 'tcx>) -> Result<(), Unpromotable> {\n         match place {\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] } => {\n-                self.validate_local(*local)\n-            }\n-            PlaceRef { base: _, projection: [proj_base @ .., elem] } => {\n+            PlaceRef { local, projection: [] } => self.validate_local(*local),\n+            PlaceRef { local: _, projection: [proj_base @ .., elem] } => {\n                 match *elem {\n                     ProjectionElem::Deref | ProjectionElem::Downcast(..) => {\n                         return Err(Unpromotable);\n@@ -496,7 +491,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     ProjectionElem::Field(..) => {\n                         if self.const_kind.is_none() {\n                             let base_ty =\n-                                Place::ty_from(place.base, proj_base, *self.body, self.tcx).ty;\n+                                Place::ty_from(place.local, proj_base, *self.body, self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n                                 // No promotion of union field accesses.\n                                 if def.is_union() {\n@@ -507,7 +502,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     }\n                 }\n \n-                self.validate_place(PlaceRef { base: place.base, projection: proj_base })\n+                self.validate_place(PlaceRef { local: place.local, projection: proj_base })\n             }\n         }\n     }\n@@ -594,10 +589,12 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // Raw reborrows can come from reference to pointer coercions,\n                 // so are allowed.\n                 if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n-                    let base_ty = Place::ty_from(&place.base, proj_base, *self.body, self.tcx).ty;\n+                    let base_ty = Place::ty_from(&place.local, proj_base, *self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n-                        return self\n-                            .validate_place(PlaceRef { base: &place.base, projection: proj_base });\n+                        return self.validate_place(PlaceRef {\n+                            local: &place.local,\n+                            projection: proj_base,\n+                        });\n                     }\n                 }\n                 Err(Unpromotable)\n@@ -631,9 +628,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 let mut place = place.as_ref();\n                 if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n-                    let base_ty = Place::ty_from(&place.base, proj_base, *self.body, self.tcx).ty;\n+                    let base_ty = Place::ty_from(&place.local, proj_base, *self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n-                        place = PlaceRef { base: &place.base, projection: proj_base };\n+                        place = PlaceRef { local: &place.local, projection: proj_base };\n                     }\n                 }\n \n@@ -642,16 +639,15 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // HACK(eddyb) this should compute the same thing as\n                 // `<HasMutInterior as Qualif>::in_projection` from\n                 // `check_consts::qualifs` but without recursion.\n-                let mut has_mut_interior = match place.base {\n-                    PlaceBase::Local(local) => self.qualif_local::<qualifs::HasMutInterior>(*local),\n-                };\n+                let mut has_mut_interior =\n+                    self.qualif_local::<qualifs::HasMutInterior>(*place.local);\n                 if has_mut_interior {\n                     let mut place_projection = place.projection;\n                     // FIXME(eddyb) use a forward loop instead of a reverse one.\n                     while let [proj_base @ .., elem] = place_projection {\n                         // FIXME(eddyb) this is probably excessive, with\n                         // the exception of `union` member accesses.\n-                        let ty = Place::ty_from(place.base, proj_base, *self.body, self.tcx)\n+                        let ty = Place::ty_from(place.local, proj_base, *self.body, self.tcx)\n                             .projection_ty(self.tcx, elem)\n                             .ty;\n                         if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n@@ -930,7 +926,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                             Rvalue::Ref(ref mut region, borrow_kind, ref mut place),\n                         )) => {\n                             // Use the underlying local for this (necessarily interior) borrow.\n-                            let ty = place.base.ty(local_decls).ty;\n+                            let ty = local_decls.local_decls()[place.local].ty;\n                             let span = statement.source_info.span;\n \n                             let ref_ty = tcx.mk_ref(\n@@ -965,10 +961,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                                 tcx.lifetimes.re_static,\n                                 borrow_kind,\n                                 Place {\n-                                    base: mem::replace(\n-                                        &mut place.base,\n-                                        PlaceBase::Local(promoted_ref),\n-                                    ),\n+                                    local: mem::replace(&mut place.local, promoted_ref),\n                                     projection: List::empty(),\n                                 },\n                             )"}, {"sha": "ab96ae3b6d6eec506e8f24d4f7a27f2aa8f5ecf5", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -261,7 +261,7 @@ fn check_place(\n             ProjectionElem::Downcast(_symbol, _variant_index) => {}\n \n             ProjectionElem::Field(..) => {\n-                let base_ty = Place::ty_from(&place.base, &proj_base, body, tcx).ty;\n+                let base_ty = Place::ty_from(&place.local, &proj_base, body, tcx).ty;\n                 if let Some(def) = base_ty.ty_adt_def() {\n                     // No union field accesses in `const fn`\n                     if def.is_union() {"}, {"sha": "ddf8d73e5481f82d1ecbccc8f8cb8defc2d2adf1", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -388,9 +388,7 @@ impl<'tcx> MutVisitor<'tcx> for LocalUpdater<'tcx> {\n         // Remove unnecessary StorageLive and StorageDead annotations.\n         data.statements.retain(|stmt| match &stmt.kind {\n             StatementKind::StorageLive(l) | StatementKind::StorageDead(l) => self.map[*l].is_some(),\n-            StatementKind::Assign(box (place, _)) => match place.base {\n-                PlaceBase::Local(local) => self.map[local].is_some(),\n-            },\n+            StatementKind::Assign(box (place, _)) => self.map[place.local].is_some(),\n             _ => true,\n         });\n         self.super_basic_block_data(block, data);"}, {"sha": "e733b0a5b5928dffdd04d888ceb5f591a56d9863", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -137,9 +137,9 @@ struct VarField<'tcx> {\n fn match_variant_field_place<'tcx>(place: &Place<'tcx>) -> Option<(Local, VarField<'tcx>)> {\n     match place.as_ref() {\n         PlaceRef {\n-            base: &PlaceBase::Local(local),\n+            local,\n             projection: &[ProjectionElem::Downcast(_, var_idx), ProjectionElem::Field(field, ty)],\n-        } => Some((local, VarField { field, field_ty: ty, var_idx })),\n+        } => Some((*local, VarField { field, field_ty: ty, var_idx })),\n         _ => None,\n     }\n }"}, {"sha": "e17c7a80f1a7617184e26ac3c6768a0dd1ae65bc", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9b39904436f6f20e34e85a4e06384116080f56/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=5d9b39904436f6f20e34e85a4e06384116080f56", "patch": "@@ -46,7 +46,7 @@ where\n             // encountered a Deref, which is ABI-aligned\n             ProjectionElem::Deref => break,\n             ProjectionElem::Field(..) => {\n-                let ty = Place::ty_from(&place.base, proj_base, local_decls, tcx).ty;\n+                let ty = Place::ty_from(&place.local, proj_base, local_decls, tcx).ty;\n                 match ty.kind {\n                     ty::Adt(def, _) if def.repr.packed() => return true,\n                     _ => {}"}]}