{"sha": "6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhOTdmYmFiNGI3YmRmYzBhZDRlMjNjNDZhNjViYTNiNjg1ZWI3MzA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-27T06:12:35Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-27T15:07:37Z"}, "message": "Rollup merge of #22818 - pnkfelix:fsk-issue-22536, r=nikomatsakis\n\n Ensure we do not zero when \\\"moving\\\" types that are Copy.\n\nUses more precise `type_needs_drop` for deciding about emitting cleanup code.  Added notes about the weaknesses regarding `ty::type_contents` here.\n\nFix #22536", "tree": {"sha": "43e30d2185b8e55589eebcef924fb95eb202cb9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43e30d2185b8e55589eebcef924fb95eb202cb9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "html_url": "https://github.com/rust-lang/rust/commit/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d4e01766bd0b3b171149d41effe5564caf0a38b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d4e01766bd0b3b171149d41effe5564caf0a38b", "html_url": "https://github.com/rust-lang/rust/commit/5d4e01766bd0b3b171149d41effe5564caf0a38b"}, {"sha": "9a6e3b900f458fd82c25e7679be2c8860aba4f22", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a6e3b900f458fd82c25e7679be2c8860aba4f22", "html_url": "https://github.com/rust-lang/rust/commit/9a6e3b900f458fd82c25e7679be2c8860aba4f22"}], "stats": {"total": 132, "additions": 114, "deletions": 18}, "files": [{"sha": "1ca243134cc6c6d985ca7f6b107c935c2d9ace58", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "patch": "@@ -241,7 +241,12 @@ extern \"rust-intrinsic\" {\n     /// will trigger a compiler error.\n     pub fn return_address() -> *const u8;\n \n-    /// Returns `true` if a type requires drop glue.\n+    /// Returns `true` if the actual type given as `T` requires drop\n+    /// glue; returns `false` if the actual type provided for `T`\n+    /// implements `Copy`.\n+    ///\n+    /// If the actual type neither requires drop glue nor implements\n+    /// `Copy`, then may return `true` or `false`.\n     pub fn needs_drop<T>() -> bool;\n \n     /// Returns `true` if a type is managed (will be allocated on the local heap)"}, {"sha": "48ff4c8332022aac0972c153eade715fbbe7be42", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "patch": "@@ -1499,6 +1499,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     fn create_dummy_locals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                        pat: &ast::Pat)\n                                        -> Block<'blk, 'tcx> {\n+        let _icx = push_ctxt(\"create_dummy_locals\");\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();"}, {"sha": "4f234fac9a4a0e65dba0040513c2e2d83a08c8fb", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "patch": "@@ -734,7 +734,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             };\n             if !is_rust_fn ||\n               type_of::return_uses_outptr(ccx, ret_ty) ||\n-              common::type_needs_drop(bcx.tcx(), ret_ty) {\n+              bcx.fcx.type_needs_drop(ret_ty) {\n                 // Push the out-pointer if we use an out-pointer for this\n                 // return type, otherwise push \"undef\".\n                 if common::type_is_zero_size(ccx, ret_ty) {"}, {"sha": "ad07f3953ccc5176b8d54a3376617e6016d7a95f", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "patch": "@@ -386,7 +386,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n                          ty: Ty<'tcx>) {\n-        if !common::type_needs_drop(self.ccx.tcx(), ty) { return; }\n+        if !self.type_needs_drop(ty) { return; }\n         let drop = box DropValue {\n             is_immediate: false,\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n@@ -408,7 +408,8 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n                                   ty: Ty<'tcx>) {\n-        if !common::type_needs_drop(self.ccx.tcx(), ty) { return; }\n+        if !self.type_needs_drop(ty) { return; }\n+\n         let drop = box DropValue {\n             is_immediate: false,\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n@@ -432,7 +433,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                                val: ValueRef,\n                                ty: Ty<'tcx>) {\n \n-        if !common::type_needs_drop(self.ccx.tcx(), ty) { return; }\n+        if !self.type_needs_drop(ty) { return; }\n         let drop = box DropValue {\n             is_immediate: true,\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n@@ -1007,6 +1008,7 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n                    bcx: Block<'blk, 'tcx>,\n                    debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n+        let _icx = base::push_ctxt(\"<DropValue as Cleanup>::trans\");\n         let bcx = if self.is_immediate {\n             glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc)\n         } else {"}, {"sha": "ec7ed2fe89017476a9ed7290c906128365b92a82", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "patch": "@@ -213,8 +213,43 @@ pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<\n     }\n }\n \n+/// If `type_needs_drop` returns true, then `ty` is definitely\n+/// non-copy and *might* have a destructor attached; if it returns\n+/// false, then `ty` definitely has no destructor (i.e. no drop glue).\n+///\n+/// (Note that this implies that if `ty` has a destructor attached,\n+/// then `type_needs_drop` will definitely return `true` for `ty`.)\n pub fn type_needs_drop<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty::type_contents(cx, ty).needs_drop(cx)\n+    type_needs_drop_given_env(cx, ty, &ty::empty_parameter_environment(cx))\n+}\n+\n+/// Core implementation of type_needs_drop, potentially making use of\n+/// and/or updating caches held in the `param_env`.\n+fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n+                                      ty: Ty<'tcx>,\n+                                      param_env: &ty::ParameterEnvironment<'a,'tcx>) -> bool {\n+    // Issue #22536: We first query type_moves_by_default.  It sees a\n+    // normalized version of the type, and therefore will definitely\n+    // know whether the type implements Copy (and thus needs no\n+    // cleanup/drop/zeroing) ...\n+    let implements_copy = !ty::type_moves_by_default(&param_env, DUMMY_SP, ty);\n+\n+    if implements_copy { return false; }\n+\n+    // ... (issue #22536 continued) but as an optimization, still use\n+    // prior logic of asking if the `needs_drop` bit is set; we need\n+    // not zero non-Copy types if they have no destructor.\n+\n+    // FIXME(#22815): Note that calling `ty::type_contents` is a\n+    // conservative heuristic; it may report that `needs_drop` is set\n+    // when actual type does not actually have a destructor associated\n+    // with it. But since `ty` absolutely did not have the `Copy`\n+    // bound attached (see above), it is sound to treat it as having a\n+    // destructor (e.g. zero its memory on move).\n+\n+    let contents = ty::type_contents(cx, ty);\n+    debug!(\"type_needs_drop ty={} contents={:?}\", ty.repr(cx), contents);\n+    contents.needs_drop(cx)\n }\n \n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -534,6 +569,12 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n                                          self.param_substs,\n                                          value)\n     }\n+\n+    /// This is the same as `common::type_needs_drop`, except that it\n+    /// may use or update caches within this `FunctionContext`.\n+    pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n+        type_needs_drop_given_env(self.ccx.tcx(), ty, &self.param_env)\n+    }\n }\n \n // Basic block context.  We create a block context for each basic block"}, {"sha": "85d0bc0319f308d93998463b3c2c410d5af30e53", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "patch": "@@ -77,7 +77,7 @@ pub fn trans_stmt_semi<'blk, 'tcx>(cx: Block<'blk, 'tcx>, e: &ast::Expr)\n                                    -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_stmt_semi\");\n     let ty = expr_ty(cx, e);\n-    if type_needs_drop(cx.tcx(), ty) {\n+    if cx.fcx.type_needs_drop(ty) {\n         expr::trans_to_lvalue(cx, e, \"stmt\").bcx\n     } else {\n         expr::trans_into(cx, e, expr::Ignore)"}, {"sha": "6ca71254868f3f62d339852a4276319acf9d7f45", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "patch": "@@ -311,7 +311,8 @@ impl KindOps for Lvalue {\n                               val: ValueRef,\n                               ty: Ty<'tcx>)\n                               -> Block<'blk, 'tcx> {\n-        if type_needs_drop(bcx.tcx(), ty) {\n+        let _icx = push_ctxt(\"<Lvalue as KindOps>::post_store\");\n+        if bcx.fcx.type_needs_drop(ty) {\n             // cancel cleanup of affine values by zeroing out\n             let () = zero_mem(bcx, val, ty);\n             bcx\n@@ -656,7 +657,7 @@ impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n     /// scalar-ish (like an int or a pointer) which (1) does not require drop glue and (2) is\n     /// naturally passed around by value, and not by reference.\n     pub fn to_llscalarish<'blk>(self, bcx: Block<'blk, 'tcx>) -> ValueRef {\n-        assert!(!type_needs_drop(bcx.tcx(), self.ty));\n+        assert!(!bcx.fcx.type_needs_drop(self.ty));\n         assert!(self.appropriate_rvalue_mode(bcx.ccx()) == ByValue);\n         if self.kind.is_by_ref() {\n             load_ty(bcx, self.val, self.ty)"}, {"sha": "27f9b9506a58a12e7848f441b98fbda733f22877", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "patch": "@@ -974,7 +974,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n             let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &**dst, \"assign\"));\n \n-            if type_needs_drop(bcx.tcx(), dst_datum.ty) {\n+            if bcx.fcx.type_needs_drop(dst_datum.ty) {\n                 // If there are destructors involved, make sure we\n                 // are copying from an rvalue, since that cannot possible\n                 // alias an lvalue. We are concerned about code like:\n@@ -1498,7 +1498,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         assert_eq!(discr, 0);\n \n         match ty::expr_kind(bcx.tcx(), &*base.expr) {\n-            ty::RvalueDpsExpr | ty::RvalueDatumExpr if !type_needs_drop(bcx.tcx(), ty) => {\n+            ty::RvalueDpsExpr | ty::RvalueDatumExpr if !bcx.fcx.type_needs_drop(ty) => {\n                 bcx = trans_into(bcx, &*base.expr, SaveIn(addr));\n             },\n             ty::RvalueStmtExpr => bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\"),\n@@ -2116,7 +2116,7 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Evaluate LHS (destination), which should be an lvalue\n     let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n-    assert!(!type_needs_drop(bcx.tcx(), dst_datum.ty));\n+    assert!(!bcx.fcx.type_needs_drop(dst_datum.ty));\n     let dst_ty = dst_datum.ty;\n     let dst = load_ty(bcx, dst_datum.val, dst_datum.ty);\n "}, {"sha": "9491c8377a655fdbe10eee9e63cc2200f29092f2", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "patch": "@@ -99,6 +99,16 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if !type_is_sized(tcx, t) {\n         return t\n     }\n+\n+    // FIXME (#22815): note that type_needs_drop conservatively\n+    // approximates in some cases and may say a type expression\n+    // requires drop glue when it actually does not.\n+    //\n+    // (In this case it is not clear whether any harm is done, i.e.\n+    // erroneously returning `t` in some cases where we could have\n+    // returned `tcx.types.i8` does not appear unsound. The impact on\n+    // code quality is unknown at this time.)\n+\n     if !type_needs_drop(tcx, t) {\n         return tcx.types.i8;\n     }\n@@ -125,7 +135,7 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"drop_ty(t={})\", t.repr(bcx.tcx()));\n     let _icx = push_ctxt(\"drop_ty\");\n-    if type_needs_drop(bcx.tcx(), t) {\n+    if bcx.fcx.type_needs_drop(t) {\n         let ccx = bcx.ccx();\n         let glue = get_drop_glue(ccx, t);\n         let glue_type = get_drop_glue_type(ccx, t);\n@@ -480,7 +490,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n         },\n         _ => {\n             assert!(type_is_sized(bcx.tcx(), t));\n-            if type_needs_drop(bcx.tcx(), t) && ty::type_is_structural(t) {\n+            if bcx.fcx.type_needs_drop(t) && ty::type_is_structural(t) {\n                 iter_structural_ty(bcx,\n                                    v0,\n                                    t,"}, {"sha": "54644c92869cfe0ea83c7c6d780545e1a2dd32d1", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "patch": "@@ -156,6 +156,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let ccx = fcx.ccx;\n     let tcx = bcx.tcx();\n \n+    let _icx = push_ctxt(\"trans_intrinsic_call\");\n+\n     let ret_ty = match callee_ty.sty {\n         ty::ty_bare_fn(_, ref f) => {\n             ty::erase_late_bound_regions(bcx.tcx(), &f.sig.output())\n@@ -376,7 +378,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"needs_drop\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            C_bool(ccx, type_needs_drop(ccx.tcx(), tp_ty))\n+\n+            C_bool(ccx, bcx.fcx.type_needs_drop(tp_ty))\n         }\n         (_, \"owns_managed\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);"}, {"sha": "4423cd2774446a8df5dea1bb2aa5ebabc706f485", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "patch": "@@ -454,7 +454,7 @@ fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let self_datum = unpack_datum!(\n         bcx, expr::trans(bcx, self_expr));\n \n-    let llval = if type_needs_drop(bcx.tcx(), self_datum.ty) {\n+    let llval = if bcx.fcx.type_needs_drop(self_datum.ty) {\n         let self_datum = unpack_datum!(\n             bcx, self_datum.to_rvalue_datum(bcx, \"trait_callee\"));\n "}, {"sha": "a5c3923336ae8a99b06f48b121962ea97e87478a", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "patch": "@@ -53,11 +53,10 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let not_null = IsNotNull(bcx, vptr);\n     with_cond(bcx, not_null, |bcx| {\n         let ccx = bcx.ccx();\n-        let tcx = bcx.tcx();\n         let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n \n         let dataptr = get_dataptr(bcx, vptr);\n-        let bcx = if type_needs_drop(tcx, unit_ty) {\n+        let bcx = if bcx.fcx.type_needs_drop(unit_ty) {\n             let len = get_len(bcx, vptr);\n             iter_vec_raw(bcx,\n                          dataptr,"}, {"sha": "b3492180a5829322f3fb49376eab4bf31fe8b761", "filename": "src/test/run-pass/issue-22536-copy-mustnt-zero.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Ftest%2Frun-pass%2Fissue-22536-copy-mustnt-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730/src%2Ftest%2Frun-pass%2Fissue-22536-copy-mustnt-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22536-copy-mustnt-zero.rs?ref=6a97fbab4b7bdfc0ad4e23c46a65ba3b685eb730", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for Issue #22536: If a type implements Copy, then\n+// moving it must not zero the original memory.\n+\n+trait Resources {\n+    type Buffer: Copy;\n+    fn foo(&self) {}\n+}\n+\n+struct BufferHandle<R: Resources> {\n+    raw: <R as Resources>::Buffer,\n+}\n+impl<R: Resources> Copy for BufferHandle<R> {}\n+\n+enum Res {}\n+impl Resources for Res {\n+    type Buffer = u32;\n+}\n+impl Copy for Res { }\n+\n+fn main() {\n+    let b: BufferHandle<Res> = BufferHandle { raw: 1 };\n+    let c = b;\n+    assert_eq!(c.raw, b.raw)\n+}"}]}