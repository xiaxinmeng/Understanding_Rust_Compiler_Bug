{"sha": "a3ff21f4d6a957e337e46d43da4e7f45d80e1504", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZmYyMWY0ZDZhOTU3ZTMzN2U0NmQ0M2RhNGU3ZjQ1ZDgwZTE1MDQ=", "commit": {"author": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2018-04-09T06:19:40Z"}, "committer": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2018-04-15T11:01:09Z"}, "message": "Rename lint to option_map_unit_fn\n\nRust does not have nil.", "tree": {"sha": "3ffbb5585cf5bf9b7689e06fe36283df0945cbd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ffbb5585cf5bf9b7689e06fe36283df0945cbd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3ff21f4d6a957e337e46d43da4e7f45d80e1504", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCAAGBQJa0zD1AAoJELb6Bqbg4mZb82EQAIOTxiv85SNHbFye3ZgV1srm\nNIoRTozTwiAT8xUy49TkEnZCpbNU9C3wtdt7NYW9OAdI9iv2AzWHDGytkc9SERTv\n0PeGcgUaJYQbnvThZsCrdv4dAgHwwIfKu51b7EewuNT0jHGuWzorTJ4MuaIlaV6I\n3rrXL83q9e0xMsnSzayckwB+vLg3V2wZ20bhMFHzleHeQaQ7TDsYgB1ViMEcqa2x\nT+IR/thAz7MmNf1BVzVI/2VEsbRes6erOXFCLjh+AAlZmIAAB/I4E9Tw/m2z+0k7\ngaM00GJ6IDIToYSv4ffmet6TXotSB4EHk/F1yTuburq/uAQ7ZgOAKxUKAGda6vdw\nbBIViG8TVpFArI2lAeqG+sf+tNMWHs87Z0WHuaMLDbA5MNg2KGxdot7eKXjEaxKh\nQpa4jXYf3ZR+NNoDVe/lhVg4jLca1bzc8FdznPlC9J4c0/U7voqEkAVBbNCBE77d\nyDXtpGWBt7oTD0bjCHhrNIk4TKbe342lsdpxiSeFuq4EKl797l+zbfHjEyFGu4MI\nRWU5J6rDSi1XgbrcnfOB8OScQ9A/tRsj6kwbhKPjY3WjAjCx2A1AjtZM2iIqdXO5\nZdNoAFX/0WYssZBry0ZthzI7Qx7Yb2ntP744Cu+PBpQyMTodrDWU5dQqDXDLBsCz\nEz6BI2AlHWegGWooBMZB\n=npyF\n-----END PGP SIGNATURE-----", "payload": "tree 3ffbb5585cf5bf9b7689e06fe36283df0945cbd8\nparent fbd71f901fc8ea324fdf3cf75f35e4ce587425ec\nauthor Philipp Hansch <dev@phansch.net> 1523254780 +0200\ncommitter Philipp Hansch <dev@phansch.net> 1523790069 +0200\n\nRename lint to option_map_unit_fn\n\nRust does not have nil.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3ff21f4d6a957e337e46d43da4e7f45d80e1504", "html_url": "https://github.com/rust-lang/rust/commit/a3ff21f4d6a957e337e46d43da4e7f45d80e1504", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3ff21f4d6a957e337e46d43da4e7f45d80e1504/comments", "author": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbd71f901fc8ea324fdf3cf75f35e4ce587425ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd71f901fc8ea324fdf3cf75f35e4ce587425ec", "html_url": "https://github.com/rust-lang/rust/commit/fbd71f901fc8ea324fdf3cf75f35e4ce587425ec"}], "stats": {"total": 75, "additions": 39, "deletions": 36}, "files": [{"sha": "0065ae1a0af20c3bef640f495d785d462b187203", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ff21f4d6a957e337e46d43da4e7f45d80e1504/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3ff21f4d6a957e337e46d43da4e7f45d80e1504/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=a3ff21f4d6a957e337e46d43da4e7f45d80e1504", "patch": "@@ -705,7 +705,7 @@ All notable changes to this project will be documented in this file.\n [`nonsensical_open_options`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#nonsensical_open_options\n [`not_unsafe_ptr_arg_deref`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#not_unsafe_ptr_arg_deref\n [`ok_expect`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#ok_expect\n-[`option_map_nil_fn`]: https://github.com/Manishearth/rust-clippy/wiki#option_map_nil_fn\n+[`option_map_unit_fn`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#option_map_unit_fn\n [`op_ref`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#op_ref\n [`option_map_or_none`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#option_map_or_none\n [`option_map_unwrap_or`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#option_map_unwrap_or"}, {"sha": "87781e4e5f7a6485a1beccc3e595c416eb34a9f7", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3ff21f4d6a957e337e46d43da4e7f45d80e1504/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ff21f4d6a957e337e46d43da4e7f45d80e1504/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a3ff21f4d6a957e337e46d43da4e7f45d80e1504", "patch": "@@ -145,7 +145,7 @@ pub mod lifetimes;\n pub mod literal_representation;\n pub mod loops;\n pub mod map_clone;\n-pub mod map_nil_fn;\n+pub mod option_map_unit_fn;\n pub mod matches;\n pub mod mem_forget;\n pub mod methods;\n@@ -406,7 +406,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box question_mark::QuestionMarkPass);\n     reg.register_late_lint_pass(box suspicious_trait_impl::SuspiciousImpl);\n     reg.register_late_lint_pass(box redundant_field_names::RedundantFieldNames);\n-    reg.register_late_lint_pass(box map_nil_fn::Pass);\n+    reg.register_late_lint_pass(box option_map_unit_fn::Pass);\n \n \n     reg.register_lint_group(\"clippy_restriction\", vec![\n@@ -443,7 +443,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         if_not_else::IF_NOT_ELSE,\n         infinite_iter::MAYBE_INFINITE_ITER,\n         items_after_statements::ITEMS_AFTER_STATEMENTS,\n-        map_nil_fn::OPTION_MAP_NIL_FN,\n+        option_map_unit_fn::OPTION_MAP_UNIT_FN,\n         matches::SINGLE_MATCH_ELSE,\n         methods::FILTER_MAP,\n         methods::OPTION_MAP_UNWRAP_OR,"}, {"sha": "df3c78a344b759f3c1a896d64dc96cc3f73cfed7", "filename": "clippy_lints/src/option_map_unit_fn.rs", "status": "renamed", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a3ff21f4d6a957e337e46d43da4e7f45d80e1504/clippy_lints%2Fsrc%2Foption_map_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ff21f4d6a957e337e46d43da4e7f45d80e1504/clippy_lints%2Fsrc%2Foption_map_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_map_unit_fn.rs?ref=a3ff21f4d6a957e337e46d43da4e7f45d80e1504", "patch": "@@ -8,21 +8,24 @@ use utils::paths;\n #[derive(Clone)]\n pub struct Pass;\n \n-/// **What it does:** Checks for usage of `Option.map(f)` where f is a nil\n-/// function or closure\n+/// **What it does:** Checks for usage of `Option.map(f)` where f is a function\n+/// or closure that returns the unit type.\n ///\n /// **Why is this bad?** Readability, this can be written more clearly with\n /// an if statement\n ///\n /// **Known problems:** None.\n ///\n /// **Example:**\n+///\n /// ```rust\n /// let x : Option<&str> = do_stuff();\n /// x.map(log_err_msg);\n /// x.map(|msg| log_err_msg(format_msg(msg)))\n /// ```\n+///\n /// The correct use would be:\n+///\n /// ```rust\n /// let x : Option<&str> = do_stuff();\n /// if let Some(msg) = x {\n@@ -33,47 +36,47 @@ pub struct Pass;\n /// }\n /// ```\n declare_clippy_lint! {\n-    pub OPTION_MAP_NIL_FN,\n+    pub OPTION_MAP_UNIT_FN,\n     complexity,\n-    \"using `Option.map(f)`, where f is a nil function or closure\"\n+    \"using `Option.map(f)`, where f is a function or closure that returns ()\"\n }\n \n \n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(OPTION_MAP_NIL_FN)\n+        lint_array!(OPTION_MAP_UNIT_FN)\n     }\n }\n \n-fn is_nil_type(ty: ty::Ty) -> bool {\n+fn is_unit_type(ty: ty::Ty) -> bool {\n     match ty.sty {\n         ty::TyTuple(slice) => slice.is_empty(),\n         ty::TyNever => true,\n         _ => false,\n     }\n }\n \n-fn is_nil_function(cx: &LateContext, expr: &hir::Expr) -> bool {\n+fn is_unit_function(cx: &LateContext, expr: &hir::Expr) -> bool {\n     let ty = cx.tables.expr_ty(expr);\n \n     if let ty::TyFnDef(id, _) = ty.sty {\n         if let Some(fn_type) = cx.tcx.fn_sig(id).no_late_bound_regions() {\n-            return is_nil_type(fn_type.output());\n+            return is_unit_type(fn_type.output());\n         }\n     }\n     false\n }\n \n-fn is_nil_expression(cx: &LateContext, expr: &hir::Expr) -> bool {\n-    is_nil_type(cx.tables.expr_ty(expr))\n+fn is_unit_expression(cx: &LateContext, expr: &hir::Expr) -> bool {\n+    is_unit_type(cx.tables.expr_ty(expr))\n }\n \n-// The expression inside a closure may or may not have surrounding braces and\n-// semicolons, which causes problems when generating a suggestion. Given an\n-// expression that evaluates to '()' or '!', recursively remove useless braces\n-// and semi-colons until is suitable for including in the suggestion template\n-fn reduce_nil_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<Span> {\n-    if !is_nil_expression(cx, expr) {\n+/// The expression inside a closure may or may not have surrounding braces and\n+/// semicolons, which causes problems when generating a suggestion. Given an\n+/// expression that evaluates to '()' or '!', recursively remove useless braces\n+/// and semi-colons until is suitable for including in the suggestion template\n+fn reduce_unit_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<Span> {\n+    if !is_unit_expression(cx, expr) {\n         return None;\n     }\n \n@@ -87,20 +90,20 @@ fn reduce_nil_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<Sp\n             match (&block.stmts[..], block.expr.as_ref()) {\n                 (&[], Some(inner_expr)) => {\n                     // Reduce `{ X }` to `X`\n-                    reduce_nil_expression(cx, inner_expr)\n+                    reduce_unit_expression(cx, inner_expr)\n                 },\n                 (&[ref inner_stmt], None) => {\n                     // Reduce `{ X; }` to `X` or `X;`\n                     match inner_stmt.node {\n                         hir::StmtDecl(ref d, _) => Some(d.span),\n                         hir::StmtExpr(ref e, _) => Some(e.span),\n                         hir::StmtSemi(ref e, _) => {\n-                            if is_nil_expression(cx, e) {\n-                                // `X` returns nil so we can strip the\n+                            if is_unit_expression(cx, e) {\n+                                // `X` returns unit so we can strip the\n                                 // semicolon and reduce further\n-                                reduce_nil_expression(cx, e)\n+                                reduce_unit_expression(cx, e)\n                             } else {\n-                                // `X` doesn't return nil so it needs a\n+                                // `X` doesn't return unit so it needs a\n                                 // trailing semicolon\n                                 Some(inner_stmt.span)\n                             }\n@@ -114,14 +117,14 @@ fn reduce_nil_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<Sp\n     }\n }\n \n-fn nil_closure<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'a hir::Expr) -> Option<(&'tcx hir::Arg, &'a hir::Expr)> {\n+fn unit_closure<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'a hir::Expr) -> Option<(&'tcx hir::Arg, &'a hir::Expr)> {\n     if let hir::ExprClosure(_, ref decl, inner_expr_id, _, _) = expr.node {\n         let body = cx.tcx.hir.body(inner_expr_id);\n         let body_expr = &body.value;\n \n         if_chain! {\n             if decl.inputs.len() == 1;\n-            if is_nil_expression(cx, body_expr);\n+            if is_unit_expression(cx, body_expr);\n             if let Some(binding) = iter_input_pats(&decl, body).next();\n             then {\n                 return Some((binding, body_expr));\n@@ -131,28 +134,28 @@ fn nil_closure<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'a hir::Expr) -> Opt\n     None\n }\n \n-fn lint_map_nil_fn(cx: &LateContext, stmt: &hir::Stmt, expr: &hir::Expr, map_args: &[hir::Expr]) {\n+fn lint_map_unit_fn(cx: &LateContext, stmt: &hir::Stmt, expr: &hir::Expr, map_args: &[hir::Expr]) {\n     let var_arg = &map_args[0];\n     let fn_arg = &map_args[1];\n \n     if !match_type(cx, cx.tables.expr_ty(var_arg), &paths::OPTION) {\n         return;\n     }\n \n-    if is_nil_function(cx, fn_arg) {\n-        let msg = \"called `map(f)` on an Option value where `f` is a nil function\";\n+    if is_unit_function(cx, fn_arg) {\n+        let msg = \"called `map(f)` on an Option value where `f` is a unit function\";\n         let suggestion = format!(\"if let Some(...) = {0} {{ {1}(...) }}\",\n                                  snippet(cx, var_arg.span, \"_\"),\n                                  snippet(cx, fn_arg.span, \"_\"));\n \n         span_lint_and_then(cx,\n-                           OPTION_MAP_NIL_FN,\n+                           OPTION_MAP_UNIT_FN,\n                            expr.span,\n                            msg,\n                            |db| { db.span_suggestion(stmt.span, \"try this\", suggestion); });\n-    } else if let Some((binding, closure_expr)) = nil_closure(cx, fn_arg) {\n-        let msg = \"called `map(f)` on an Option value where `f` is a nil closure\";\n-        let suggestion = if let Some(expr_span) = reduce_nil_expression(cx, closure_expr) {\n+    } else if let Some((binding, closure_expr)) = unit_closure(cx, fn_arg) {\n+        let msg = \"called `map(f)` on an Option value where `f` is a unit closure\";\n+        let suggestion = if let Some(expr_span) = reduce_unit_expression(cx, closure_expr) {\n             format!(\"if let Some({0}) = {1} {{ {2} }}\",\n                     snippet(cx, binding.pat.span, \"_\"),\n                     snippet(cx, var_arg.span, \"_\"),\n@@ -164,7 +167,7 @@ fn lint_map_nil_fn(cx: &LateContext, stmt: &hir::Stmt, expr: &hir::Expr, map_arg\n         };\n \n         span_lint_and_then(cx,\n-                           OPTION_MAP_NIL_FN,\n+                           OPTION_MAP_UNIT_FN,\n                            expr.span,\n                            msg,\n                            |db| { db.span_suggestion(stmt.span, \"try this\", suggestion); });\n@@ -180,7 +183,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if let hir::StmtSemi(ref expr, _) = stmt.node {\n             if let hir::ExprMethodCall(_, _, _) = expr.node {\n                 if let Some(arglists) = method_chain_args(expr, &[\"map\"]) {\n-                    lint_map_nil_fn(cx, stmt, expr, arglists[0]);\n+                    lint_map_unit_fn(cx, stmt, expr, arglists[0]);\n                 }\n             }\n         }", "previous_filename": "clippy_lints/src/map_nil_fn.rs"}]}