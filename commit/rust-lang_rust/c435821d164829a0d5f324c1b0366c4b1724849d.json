{"sha": "c435821d164829a0d5f324c1b0366c4b1724849d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MzU4MjFkMTY0ODI5YTBkNWYzMjRjMWIwMzY2YzRiMTcyNDg0OWQ=", "commit": {"author": {"name": "arthurprs", "email": "arthurprs@gmail.com", "date": "2016-09-24T09:28:00Z"}, "committer": {"name": "arthurprs", "email": "arthurprs@gmail.com", "date": "2016-10-12T15:07:09Z"}, "message": "Cache conscious hashmap table", "tree": {"sha": "d09ea4b237569718cb757cda03cf58eef15a0b53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d09ea4b237569718cb757cda03cf58eef15a0b53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c435821d164829a0d5f324c1b0366c4b1724849d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c435821d164829a0d5f324c1b0366c4b1724849d", "html_url": "https://github.com/rust-lang/rust/commit/c435821d164829a0d5f324c1b0366c4b1724849d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c435821d164829a0d5f324c1b0366c4b1724849d/comments", "author": {"login": "arthurprs", "id": 715958, "node_id": "MDQ6VXNlcjcxNTk1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/715958?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurprs", "html_url": "https://github.com/arthurprs", "followers_url": "https://api.github.com/users/arthurprs/followers", "following_url": "https://api.github.com/users/arthurprs/following{/other_user}", "gists_url": "https://api.github.com/users/arthurprs/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurprs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurprs/subscriptions", "organizations_url": "https://api.github.com/users/arthurprs/orgs", "repos_url": "https://api.github.com/users/arthurprs/repos", "events_url": "https://api.github.com/users/arthurprs/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurprs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arthurprs", "id": 715958, "node_id": "MDQ6VXNlcjcxNTk1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/715958?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurprs", "html_url": "https://github.com/arthurprs", "followers_url": "https://api.github.com/users/arthurprs/followers", "following_url": "https://api.github.com/users/arthurprs/following{/other_user}", "gists_url": "https://api.github.com/users/arthurprs/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurprs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurprs/subscriptions", "organizations_url": "https://api.github.com/users/arthurprs/orgs", "repos_url": "https://api.github.com/users/arthurprs/repos", "events_url": "https://api.github.com/users/arthurprs/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurprs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7bfb1aba9d089a0464c03b3841e889c6ee7c4f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7bfb1aba9d089a0464c03b3841e889c6ee7c4f1", "html_url": "https://github.com/rust-lang/rust/commit/a7bfb1aba9d089a0464c03b3841e889c6ee7c4f1"}], "stats": {"total": 156, "additions": 68, "deletions": 88}, "files": [{"sha": "b357bc3552a5e807b7e483e3665f7816019b420a", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 68, "deletions": 88, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/c435821d164829a0d5f324c1b0366c4b1724849d/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c435821d164829a0d5f324c1b0366c4b1724849d/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=c435821d164829a0d5f324c1b0366c4b1724849d", "patch": "@@ -24,10 +24,10 @@ use self::BucketState::*;\n const EMPTY_BUCKET: u64 = 0;\n \n /// The raw hashtable, providing safe-ish access to the unzipped and highly\n-/// optimized arrays of hashes, keys, and values.\n+/// optimized arrays of hashes, and key-value pairs.\n ///\n-/// This design uses less memory and is a lot faster than the naive\n-/// `Vec<Option<u64, K, V>>`, because we don't pay for the overhead of an\n+/// This design is a lot faster than the naive\n+/// `Vec<Option<(u64, K, V)>>`, because we don't pay for the overhead of an\n /// option on every element, and we get a generally more cache-aware design.\n ///\n /// Essential invariants of this structure:\n@@ -48,17 +48,19 @@ const EMPTY_BUCKET: u64 = 0;\n ///     which will likely map to the same bucket, while not being confused\n ///     with \"empty\".\n ///\n-///   - All three \"arrays represented by pointers\" are the same length:\n+///   - Both \"arrays represented by pointers\" are the same length:\n ///     `capacity`. This is set at creation and never changes. The arrays\n-///     are unzipped to save space (we don't have to pay for the padding\n-///     between odd sized elements, such as in a map from u64 to u8), and\n-///     be more cache aware (scanning through 8 hashes brings in at most\n-///     2 cache lines, since they're all right beside each other).\n+///     are unzipped and are more cache aware (scanning through 8 hashes\n+///     brings in at most 2 cache lines, since they're all right beside each\n+///     other). This layout may waste space in padding such as in a map from\n+///     u64 to u8, but is a more cache conscious layout as the key-value pairs\n+///     are only very shortly probed and the desired value will be in the same\n+///     or next cache line.\n ///\n /// You can kind of think of this module/data structure as a safe wrapper\n /// around just the \"table\" part of the hashtable. It enforces some\n /// invariants at the type level and employs some performance trickery,\n-/// but in general is just a tricked out `Vec<Option<u64, K, V>>`.\n+/// but in general is just a tricked out `Vec<Option<(u64, K, V)>>`.\n pub struct RawTable<K, V> {\n     capacity: usize,\n     size: usize,\n@@ -74,10 +76,8 @@ unsafe impl<K: Sync, V: Sync> Sync for RawTable<K, V> {}\n \n struct RawBucket<K, V> {\n     hash: *mut u64,\n-\n     // We use *const to ensure covariance with respect to K and V\n-    key: *const K,\n-    val: *const V,\n+    pair: *const (K, V),\n     _marker: marker::PhantomData<(K, V)>,\n }\n \n@@ -181,8 +181,7 @@ impl<K, V> RawBucket<K, V> {\n     unsafe fn offset(self, count: isize) -> RawBucket<K, V> {\n         RawBucket {\n             hash: self.hash.offset(count),\n-            key: self.key.offset(count),\n-            val: self.val.offset(count),\n+            pair: self.pair.offset(count),\n             _marker: marker::PhantomData,\n         }\n     }\n@@ -370,8 +369,7 @@ impl<K, V, M> EmptyBucket<K, V, M>\n     pub fn put(mut self, hash: SafeHash, key: K, value: V) -> FullBucket<K, V, M> {\n         unsafe {\n             *self.raw.hash = hash.inspect();\n-            ptr::write(self.raw.key as *mut K, key);\n-            ptr::write(self.raw.val as *mut V, value);\n+            ptr::write(self.raw.pair as *mut (K, V), (key, value));\n \n             self.table.borrow_table_mut().size += 1;\n         }\n@@ -430,7 +428,7 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n \n     /// Gets references to the key and value at a given index.\n     pub fn read(&self) -> (&K, &V) {\n-        unsafe { (&*self.raw.key, &*self.raw.val) }\n+        unsafe { (&(*self.raw.pair).0, &(*self.raw.pair).1) }\n     }\n }\n \n@@ -447,13 +445,14 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n \n         unsafe {\n             *self.raw.hash = EMPTY_BUCKET;\n+            let (k, v) = ptr::read(self.raw.pair);\n             (EmptyBucket {\n                  raw: self.raw,\n                  idx: self.idx,\n                  table: self.table,\n              },\n-             ptr::read(self.raw.key),\n-             ptr::read(self.raw.val))\n+            k,\n+            v)\n         }\n     }\n }\n@@ -466,8 +465,7 @@ impl<K, V, M> FullBucket<K, V, M>\n     pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) {\n         unsafe {\n             let old_hash = ptr::replace(self.raw.hash as *mut SafeHash, h);\n-            let old_key = ptr::replace(self.raw.key as *mut K, k);\n-            let old_val = ptr::replace(self.raw.val as *mut V, v);\n+            let (old_key, old_val) = ptr::replace(self.raw.pair as *mut (K, V), (k, v));\n \n             (old_hash, old_key, old_val)\n         }\n@@ -479,7 +477,8 @@ impl<K, V, M> FullBucket<K, V, M>\n {\n     /// Gets mutable references to the key and value at a given index.\n     pub fn read_mut(&mut self) -> (&mut K, &mut V) {\n-        unsafe { (&mut *(self.raw.key as *mut K), &mut *(self.raw.val as *mut V)) }\n+        let pair_mut = self.raw.pair as *mut (K, V);\n+        unsafe { (&mut (*pair_mut).0, &mut (*pair_mut).1) }\n     }\n }\n \n@@ -492,7 +491,7 @@ impl<'t, K, V, M> FullBucket<K, V, M>\n     /// in exchange for this, the returned references have a longer lifetime\n     /// than the references returned by `read()`.\n     pub fn into_refs(self) -> (&'t K, &'t V) {\n-        unsafe { (&*self.raw.key, &*self.raw.val) }\n+        unsafe { (&(*self.raw.pair).0, &(*self.raw.pair).1) }\n     }\n }\n \n@@ -502,7 +501,8 @@ impl<'t, K, V, M> FullBucket<K, V, M>\n     /// This works similarly to `into_refs`, exchanging a bucket state\n     /// for mutable references into the table.\n     pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) {\n-        unsafe { (&mut *(self.raw.key as *mut K), &mut *(self.raw.val as *mut V)) }\n+        let pair_mut = self.raw.pair as *mut (K, V);\n+        unsafe { (&mut (*pair_mut).0, &mut (*pair_mut).1) }\n     }\n }\n \n@@ -517,8 +517,7 @@ impl<K, V, M> GapThenFull<K, V, M>\n     pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> {\n         unsafe {\n             *self.gap.raw.hash = mem::replace(&mut *self.full.raw.hash, EMPTY_BUCKET);\n-            ptr::copy_nonoverlapping(self.full.raw.key, self.gap.raw.key as *mut K, 1);\n-            ptr::copy_nonoverlapping(self.full.raw.val, self.gap.raw.val as *mut V, 1);\n+            ptr::copy_nonoverlapping(self.full.raw.pair, self.gap.raw.pair as *mut (K, V), 1);\n         }\n \n         let FullBucket { raw: prev_raw, idx: prev_idx, .. } = self.full;\n@@ -560,49 +559,42 @@ fn test_rounding() {\n     assert_eq!(round_up_to_next(5, 4), 8);\n }\n \n-// Returns a tuple of (key_offset, val_offset),\n+// Returns a tuple of (pairs_offset, end_of_pairs_offset),\n // from the start of a mallocated array.\n #[inline]\n fn calculate_offsets(hashes_size: usize,\n-                     keys_size: usize,\n-                     keys_align: usize,\n-                     vals_align: usize)\n+                     pairs_size: usize,\n+                     pairs_align: usize)\n                      -> (usize, usize, bool) {\n-    let keys_offset = round_up_to_next(hashes_size, keys_align);\n-    let (end_of_keys, oflo) = keys_offset.overflowing_add(keys_size);\n-\n-    let vals_offset = round_up_to_next(end_of_keys, vals_align);\n+    let pairs_offset = round_up_to_next(hashes_size, pairs_align);\n+    let (end_of_pairs, oflo) = pairs_offset.overflowing_add(pairs_size);\n \n-    (keys_offset, vals_offset, oflo)\n+    (pairs_offset, end_of_pairs, oflo)\n }\n \n // Returns a tuple of (minimum required malloc alignment, hash_offset,\n // array_size), from the start of a mallocated array.\n fn calculate_allocation(hash_size: usize,\n                         hash_align: usize,\n-                        keys_size: usize,\n-                        keys_align: usize,\n-                        vals_size: usize,\n-                        vals_align: usize)\n+                        pairs_size: usize,\n+                        pairs_align: usize)\n                         -> (usize, usize, usize, bool) {\n     let hash_offset = 0;\n-    let (_, vals_offset, oflo) = calculate_offsets(hash_size, keys_size, keys_align, vals_align);\n-    let (end_of_vals, oflo2) = vals_offset.overflowing_add(vals_size);\n+    let (_, end_of_pairs, oflo) = calculate_offsets(hash_size, pairs_size, pairs_align);\n \n-    let align = cmp::max(hash_align, cmp::max(keys_align, vals_align));\n+    let align = cmp::max(hash_align, pairs_align);\n \n-    (align, hash_offset, end_of_vals, oflo || oflo2)\n+    (align, hash_offset, end_of_pairs, oflo)\n }\n \n #[test]\n fn test_offset_calculation() {\n-    assert_eq!(calculate_allocation(128, 8, 15, 1, 4, 4),\n-               (8, 0, 148, false));\n-    assert_eq!(calculate_allocation(3, 1, 2, 1, 1, 1), (1, 0, 6, false));\n-    assert_eq!(calculate_allocation(6, 2, 12, 4, 24, 8), (8, 0, 48, false));\n-    assert_eq!(calculate_offsets(128, 15, 1, 4), (128, 144, false));\n-    assert_eq!(calculate_offsets(3, 2, 1, 1), (3, 5, false));\n-    assert_eq!(calculate_offsets(6, 12, 4, 8), (8, 24, false));\n+    assert_eq!(calculate_allocation(128, 8, 16, 8), (8, 0, 144, false));\n+    assert_eq!(calculate_allocation(3, 1, 2, 1), (1, 0, 5, false));\n+    assert_eq!(calculate_allocation(6, 2, 12, 4), (4, 0, 20, false));\n+    assert_eq!(calculate_offsets(128, 15, 4), (128, 143, false));\n+    assert_eq!(calculate_offsets(3, 2, 4), (4, 6, false));\n+    assert_eq!(calculate_offsets(6, 12, 4), (8, 20, false));\n }\n \n impl<K, V> RawTable<K, V> {\n@@ -620,39 +612,31 @@ impl<K, V> RawTable<K, V> {\n \n         // No need for `checked_mul` before a more restrictive check performed\n         // later in this method.\n-        let hashes_size = capacity * size_of::<u64>();\n-        let keys_size = capacity * size_of::<K>();\n-        let vals_size = capacity * size_of::<V>();\n+        let hashes_size = capacity.wrapping_mul(size_of::<u64>());\n+        let pairs_size = capacity.wrapping_mul(size_of::<(K, V)>());\n \n-        // Allocating hashmaps is a little tricky. We need to allocate three\n+        // Allocating hashmaps is a little tricky. We need to allocate two\n         // arrays, but since we know their sizes and alignments up front,\n         // we just allocate a single array, and then have the subarrays\n         // point into it.\n         //\n         // This is great in theory, but in practice getting the alignment\n         // right is a little subtle. Therefore, calculating offsets has been\n         // factored out into a different function.\n-        let (malloc_alignment, hash_offset, size, oflo) = calculate_allocation(hashes_size,\n-                                                                               align_of::<u64>(),\n-                                                                               keys_size,\n-                                                                               align_of::<K>(),\n-                                                                               vals_size,\n-                                                                               align_of::<V>());\n-\n+        let (alignment, hash_offset, size, oflo) = calculate_allocation(hashes_size,\n+                                                                        align_of::<u64>(),\n+                                                                        pairs_size,\n+                                                                        align_of::<(K, V)>());\n         assert!(!oflo, \"capacity overflow\");\n \n         // One check for overflow that covers calculation and rounding of size.\n-        let size_of_bucket = size_of::<u64>()\n-            .checked_add(size_of::<K>())\n-            .unwrap()\n-            .checked_add(size_of::<V>())\n-            .unwrap();\n+        let size_of_bucket = size_of::<u64>().checked_add(size_of::<(K, V)>()).unwrap();\n         assert!(size >=\n                 capacity.checked_mul(size_of_bucket)\n                     .expect(\"capacity overflow\"),\n                 \"capacity overflow\");\n \n-        let buffer = allocate(size, malloc_alignment);\n+        let buffer = allocate(size, alignment);\n         if buffer.is_null() {\n             ::alloc::oom()\n         }\n@@ -669,17 +653,16 @@ impl<K, V> RawTable<K, V> {\n \n     fn first_bucket_raw(&self) -> RawBucket<K, V> {\n         let hashes_size = self.capacity * size_of::<u64>();\n-        let keys_size = self.capacity * size_of::<K>();\n+        let pairs_size = self.capacity * size_of::<(K, V)>();\n \n-        let buffer = *self.hashes as *const u8;\n-        let (keys_offset, vals_offset, oflo) =\n-            calculate_offsets(hashes_size, keys_size, align_of::<K>(), align_of::<V>());\n+        let buffer = *self.hashes as *mut u8;\n+        let (pairs_offset, _, oflo) =\n+            calculate_offsets(hashes_size, pairs_size, align_of::<(K, V)>());\n         debug_assert!(!oflo, \"capacity overflow\");\n         unsafe {\n             RawBucket {\n                 hash: *self.hashes,\n-                key: buffer.offset(keys_offset as isize) as *const K,\n-                val: buffer.offset(vals_offset as isize) as *const V,\n+                pair: buffer.offset(pairs_offset as isize) as *const _,\n                 _marker: marker::PhantomData,\n             }\n         }\n@@ -844,7 +827,7 @@ impl<'a, K, V> Iterator for RevMoveBuckets<'a, K, V> {\n \n                 if *self.raw.hash != EMPTY_BUCKET {\n                     self.elems_left -= 1;\n-                    return Some((ptr::read(self.raw.key), ptr::read(self.raw.val)));\n+                    return Some(ptr::read(self.raw.pair));\n                 }\n             }\n         }\n@@ -909,7 +892,7 @@ impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n         self.iter.next().map(|bucket| {\n             self.elems_left -= 1;\n-            unsafe { (&*bucket.key, &*bucket.val) }\n+            unsafe { (&(*bucket.pair).0, &(*bucket.pair).1) }\n         })\n     }\n \n@@ -929,7 +912,8 @@ impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n         self.iter.next().map(|bucket| {\n             self.elems_left -= 1;\n-            unsafe { (&*bucket.key, &mut *(bucket.val as *mut V)) }\n+            let pair_mut = bucket.pair as *mut (K, V);\n+            unsafe { (&(*pair_mut).0, &mut (*pair_mut).1) }\n         })\n     }\n \n@@ -950,7 +934,8 @@ impl<K, V> Iterator for IntoIter<K, V> {\n         self.iter.next().map(|bucket| {\n             self.table.size -= 1;\n             unsafe {\n-                (SafeHash { hash: *bucket.hash }, ptr::read(bucket.key), ptr::read(bucket.val))\n+                let (k, v) = ptr::read(bucket.pair);\n+                (SafeHash { hash: *bucket.hash }, k, v)\n             }\n         })\n     }\n@@ -974,9 +959,8 @@ impl<'a, K, V> Iterator for Drain<'a, K, V> {\n         self.iter.next().map(|bucket| {\n             unsafe {\n                 (**self.table).size -= 1;\n-                (SafeHash { hash: ptr::replace(bucket.hash, EMPTY_BUCKET) },\n-                 ptr::read(bucket.key),\n-                 ptr::read(bucket.val))\n+                let (k, v) = ptr::read(bucket.pair);\n+                (SafeHash { hash: ptr::replace(bucket.hash, EMPTY_BUCKET) }, k, v)\n             }\n         })\n     }\n@@ -1015,8 +999,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n                                 (full.hash(), k.clone(), v.clone())\n                             };\n                             *new_buckets.raw.hash = h.inspect();\n-                            ptr::write(new_buckets.raw.key as *mut K, k);\n-                            ptr::write(new_buckets.raw.val as *mut V, v);\n+                            ptr::write(new_buckets.raw.pair as *mut (K, V), (k, v));\n                         }\n                         Empty(..) => {\n                             *new_buckets.raw.hash = EMPTY_BUCKET;\n@@ -1054,14 +1037,11 @@ impl<K, V> Drop for RawTable<K, V> {\n         }\n \n         let hashes_size = self.capacity * size_of::<u64>();\n-        let keys_size = self.capacity * size_of::<K>();\n-        let vals_size = self.capacity * size_of::<V>();\n+        let pairs_size = self.capacity * size_of::<(K, V)>();\n         let (align, _, size, oflo) = calculate_allocation(hashes_size,\n                                                           align_of::<u64>(),\n-                                                          keys_size,\n-                                                          align_of::<K>(),\n-                                                          vals_size,\n-                                                          align_of::<V>());\n+                                                          pairs_size,\n+                                                          align_of::<(K, V)>());\n \n         debug_assert!(!oflo, \"should be impossible\");\n "}]}