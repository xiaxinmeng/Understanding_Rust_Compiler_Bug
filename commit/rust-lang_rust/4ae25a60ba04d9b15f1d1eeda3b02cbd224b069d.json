{"sha": "4ae25a60ba04d9b15f1d1eeda3b02cbd224b069d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZTI1YTYwYmEwNGQ5YjE1ZjFkMWVlZGEzYjAyY2JkMjI0YjA2OWQ=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-04-17T17:26:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-17T17:26:20Z"}, "message": "Rollup merge of #41280 - QuietMisdreavus:rustdoc-toc, r=GuillaumeGomez\n\nrustdoc: add a list of headings to the sidebar\n\nIt's another misdreavus rustdoc PR, which means it's time for Bikeshed City once again! `:3`\n\nIn an effort to aid navigation in long documentation pages, this PR adds a listing of headings to the sidebars of pages where such headings exist. For example, for structs, links to their fields, inherent methods, and trait implementations are available where applicable.\n\nExamples:\n\n* Modules/Crate roots\n  ![image](https://cloud.githubusercontent.com/assets/5217170/25019930/1000fa3a-2052-11e7-98ff-ddf5af18b3e6.png)\n* Enums\n  ![image](https://cloud.githubusercontent.com/assets/5217170/25019954/33497f9e-2052-11e7-88cf-df46f1b3b8a3.png)\n* Primitives\n  ![image](https://cloud.githubusercontent.com/assets/5217170/25019978/4820bbc6-2052-11e7-8b5a-96a864eb2a5b.png)\n* Traits\n  ![image](https://cloud.githubusercontent.com/assets/5217170/25020093/bd1bc9f2-2052-11e7-9cd1-00a0ad8007bc.png)\n* Structs\n  ![image](https://cloud.githubusercontent.com/assets/5217170/25020145/d75206b0-2052-11e7-88cc-9e9525084775.png)\n\nOpen questions:\n\n* Right now, these kinds of pages (and also unions) are the only pages that will receive the name header - pages for functions, constants, macros, etc, won't have the corresponding name in their sidebar. Should I print the name regardless and only add table-of-contents links for pages that have them? This would make them match, for example, a struct with no public fields, no methods, and no trait implementations. The latter would still have a \"Struct MyStruct\" line above the module contents, with no header links to speak of, whereas a function wouldn't even have \"Function my\\_function\".\n* This is only a header listing, but there has been requests to include a more-complete listing of fields/methods/traits/etc, for example in #41123.", "tree": {"sha": "bc7527958d8e27c9fc4c72aa2959e6777ba50450", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc7527958d8e27c9fc4c72aa2959e6777ba50450"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ae25a60ba04d9b15f1d1eeda3b02cbd224b069d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ae25a60ba04d9b15f1d1eeda3b02cbd224b069d", "html_url": "https://github.com/rust-lang/rust/commit/4ae25a60ba04d9b15f1d1eeda3b02cbd224b069d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ae25a60ba04d9b15f1d1eeda3b02cbd224b069d/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "url": "https://api.github.com/repos/rust-lang/rust/commits/914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "html_url": "https://github.com/rust-lang/rust/commit/914b6f1f14e62550c9b7ca7f59490aa0f10ef288"}, {"sha": "27bfbd56f08ab64122a79cb84446a27b99099590", "url": "https://api.github.com/repos/rust-lang/rust/commits/27bfbd56f08ab64122a79cb84446a27b99099590", "html_url": "https://github.com/rust-lang/rust/commit/27bfbd56f08ab64122a79cb84446a27b99099590"}], "stats": {"total": 229, "additions": 225, "deletions": 4}, "files": [{"sha": "998386353561ebc8b6b2ad8f4f436fe67ad08797", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ae25a60ba04d9b15f1d1eeda3b02cbd224b069d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae25a60ba04d9b15f1d1eeda3b02cbd224b069d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4ae25a60ba04d9b15f1d1eeda3b02cbd224b069d", "patch": "@@ -292,7 +292,7 @@ impl Item {\n         self.type_() == ItemType::Struct\n     }\n     pub fn is_enum(&self) -> bool {\n-        self.type_() == ItemType::Module\n+        self.type_() == ItemType::Enum\n     }\n     pub fn is_fn(&self) -> bool {\n         self.type_() == ItemType::Function\n@@ -312,6 +312,9 @@ impl Item {\n     pub fn is_primitive(&self) -> bool {\n         self.type_() == ItemType::Primitive\n     }\n+    pub fn is_union(&self) -> bool {\n+        self.type_() == ItemType::Union\n+    }\n     pub fn is_stripped(&self) -> bool {\n         match self.inner { StrippedItem(..) => true, _ => false }\n     }"}, {"sha": "d55a0640562aee2c336d089a2e72f7608d9aaf58", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 221, "deletions": 3, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/4ae25a60ba04d9b15f1d1eeda3b02cbd224b069d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae25a60ba04d9b15f1d1eeda3b02cbd224b069d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=4ae25a60ba04d9b15f1d1eeda3b02cbd224b069d", "patch": "@@ -2430,7 +2430,7 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     }).peekable();\n     if let doctree::Plain = s.struct_type {\n         if fields.peek().is_some() {\n-            write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n+            write!(w, \"<h2 id='fields' class='fields'>Fields</h2>\")?;\n             for (field, ty) in fields {\n                 let id = derive_id(format!(\"{}.{}\",\n                                            ItemType::StructField,\n@@ -2478,7 +2478,7 @@ fn item_union(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         }\n     }).peekable();\n     if fields.peek().is_some() {\n-        write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n+        write!(w, \"<h2 id='fields' class='fields'>Fields</h2>\")?;\n         for (field, ty) in fields {\n             write!(w, \"<span id='{shortty}.{name}' class=\\\"{shortty}\\\"><code>{name}: {ty}</code>\n                        </span>\",\n@@ -2550,7 +2550,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n     document(w, cx, it)?;\n     if !e.variants.is_empty() {\n-        write!(w, \"<h2 class='variants'>Variants</h2>\\n\")?;\n+        write!(w, \"<h2 id='variants' class='variants'>Variants</h2>\\n\")?;\n         for variant in &e.variants {\n             let id = derive_id(format!(\"{}.{}\",\n                                        ItemType::Variant,\n@@ -3074,6 +3074,37 @@ impl<'a> fmt::Display for Sidebar<'a> {\n         let it = self.item;\n         let parentlen = cx.current.len() - if it.is_mod() {1} else {0};\n \n+        if it.is_struct() || it.is_trait() || it.is_primitive() || it.is_union()\n+            || it.is_enum() || it.is_mod()\n+        {\n+            write!(fmt, \"<p class='location'>\")?;\n+            match it.inner {\n+                clean::StructItem(..) => write!(fmt, \"Struct \")?,\n+                clean::TraitItem(..) => write!(fmt, \"Trait \")?,\n+                clean::PrimitiveItem(..) => write!(fmt, \"Primitive Type \")?,\n+                clean::UnionItem(..) => write!(fmt, \"Union \")?,\n+                clean::EnumItem(..) => write!(fmt, \"Enum \")?,\n+                clean::ModuleItem(..) => if it.is_crate() {\n+                    write!(fmt, \"Crate \")?;\n+                } else {\n+                    write!(fmt, \"Module \")?;\n+                },\n+                _ => (),\n+            }\n+            write!(fmt, \"{}\", it.name.as_ref().unwrap())?;\n+            write!(fmt, \"</p>\")?;\n+\n+            match it.inner {\n+                clean::StructItem(ref s) => sidebar_struct(fmt, it, s)?,\n+                clean::TraitItem(ref t) => sidebar_trait(fmt, it, t)?,\n+                clean::PrimitiveItem(ref p) => sidebar_primitive(fmt, it, p)?,\n+                clean::UnionItem(ref u) => sidebar_union(fmt, it, u)?,\n+                clean::EnumItem(ref e) => sidebar_enum(fmt, it, e)?,\n+                clean::ModuleItem(ref m) => sidebar_module(fmt, it, &m.items)?,\n+                _ => (),\n+            }\n+        }\n+\n         // The sidebar is designed to display sibling functions, modules and\n         // other miscellaneous information. since there are lots of sibling\n         // items (and that causes quadratic growth in large modules),\n@@ -3116,6 +3147,193 @@ impl<'a> fmt::Display for Sidebar<'a> {\n     }\n }\n \n+fn sidebar_assoc_items(it: &clean::Item) -> String {\n+    let mut out = String::new();\n+    let c = cache();\n+    if let Some(v) = c.impls.get(&it.def_id) {\n+        if v.iter().any(|i| i.inner_impl().trait_.is_none()) {\n+            out.push_str(\"<li><a href=\\\"#methods\\\">Methods</a></li>\");\n+        }\n+\n+        if v.iter().any(|i| i.inner_impl().trait_.is_some()) {\n+            if let Some(impl_) = v.iter()\n+                                  .filter(|i| i.inner_impl().trait_.is_some())\n+                                  .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did) {\n+                if let Some(target) = impl_.inner_impl().items.iter().filter_map(|item| {\n+                    match item.inner {\n+                        clean::TypedefItem(ref t, true) => Some(&t.type_),\n+                        _ => None,\n+                    }\n+                }).next() {\n+                    let inner_impl = target.def_id().or(target.primitive_type().and_then(|prim| {\n+                        c.primitive_locations.get(&prim).cloned()\n+                    })).and_then(|did| c.impls.get(&did));\n+                    if inner_impl.is_some() {\n+                        out.push_str(\"<li><a href=\\\"#deref-methods\\\">\");\n+                        out.push_str(&format!(\"Methods from {:#}&lt;Target={:#}&gt;\",\n+                                                  impl_.inner_impl().trait_.as_ref().unwrap(),\n+                                                  target));\n+                        out.push_str(\"</a></li>\");\n+                    }\n+                }\n+            }\n+            out.push_str(\"<li><a href=\\\"#implementations\\\">Trait Implementations</a></li>\");\n+        }\n+    }\n+\n+    out\n+}\n+\n+fn sidebar_struct(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                  s: &clean::Struct) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    if s.fields.iter()\n+               .any(|f| if let clean::StructFieldItem(..) = f.inner { true } else { false }) {\n+        if let doctree::Plain = s.struct_type {\n+            sidebar.push_str(\"<li><a href=\\\"#fields\\\">Fields</a></li>\");\n+        }\n+    }\n+\n+    sidebar.push_str(&sidebar_assoc_items(it));\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n+fn sidebar_trait(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                 t: &clean::Trait) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    let has_types = t.items.iter().any(|m| m.is_associated_type());\n+    let has_consts = t.items.iter().any(|m| m.is_associated_const());\n+    let has_required = t.items.iter().any(|m| m.is_ty_method());\n+    let has_provided = t.items.iter().any(|m| m.is_method());\n+\n+    if has_types {\n+        sidebar.push_str(\"<li><a href=\\\"#associated-types\\\">Associated Types</a></li>\");\n+    }\n+    if has_consts {\n+        sidebar.push_str(\"<li><a href=\\\"#associated-const\\\">Associated Constants</a></li>\");\n+    }\n+    if has_required {\n+        sidebar.push_str(\"<li><a href=\\\"#required-methods\\\">Required Methods</a></li>\");\n+    }\n+    if has_provided {\n+        sidebar.push_str(\"<li><a href=\\\"#provided-methods\\\">Provided Methods</a></li>\");\n+    }\n+\n+    sidebar.push_str(&sidebar_assoc_items(it));\n+\n+    sidebar.push_str(\"<li><a href=\\\"#implementors\\\">Implementors</a></li>\");\n+\n+    write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)\n+}\n+\n+fn sidebar_primitive(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                     _p: &clean::PrimitiveType) -> fmt::Result {\n+    let sidebar = sidebar_assoc_items(it);\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n+fn sidebar_union(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                 u: &clean::Union) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    if u.fields.iter()\n+               .any(|f| if let clean::StructFieldItem(..) = f.inner { true } else { false }) {\n+        sidebar.push_str(\"<li><a href=\\\"#fields\\\">Fields</a></li>\");\n+    }\n+\n+    sidebar.push_str(&sidebar_assoc_items(it));\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n+fn sidebar_enum(fmt: &mut fmt::Formatter, it: &clean::Item,\n+                e: &clean::Enum) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    if !e.variants.is_empty() {\n+        sidebar.push_str(\"<li><a href=\\\"#variants\\\">Variants</a></li>\");\n+    }\n+\n+    sidebar.push_str(&sidebar_assoc_items(it));\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n+fn sidebar_module(fmt: &mut fmt::Formatter, _it: &clean::Item,\n+                  items: &[clean::Item]) -> fmt::Result {\n+    let mut sidebar = String::new();\n+\n+    if items.iter().any(|it| it.type_() == ItemType::ExternCrate ||\n+                             it.type_() == ItemType::Import) {\n+        sidebar.push_str(&format!(\"<li><a href=\\\"#{id}\\\">{name}</a></li>\",\n+                                  id = \"reexports\",\n+                                  name = \"Reexports\"));\n+    }\n+\n+    // ordering taken from item_module, reorder, where it prioritized elements in a certain order\n+    // to print its headings\n+    for &myty in &[ItemType::Primitive, ItemType::Module, ItemType::Macro, ItemType::Struct,\n+                   ItemType::Enum, ItemType::Constant, ItemType::Static, ItemType::Trait,\n+                   ItemType::Function, ItemType::Typedef, ItemType::Union, ItemType::Impl,\n+                   ItemType::TyMethod, ItemType::Method, ItemType::StructField, ItemType::Variant,\n+                   ItemType::AssociatedType, ItemType::AssociatedConst] {\n+        if items.iter().any(|it| {\n+            if let clean::DefaultImplItem(..) = it.inner {\n+                false\n+            } else {\n+                !maybe_ignore_item(it) && !it.is_stripped() && it.type_() == myty\n+            }\n+        }) {\n+            let (short, name) = match myty {\n+                ItemType::ExternCrate |\n+                ItemType::Import          => (\"reexports\", \"Reexports\"),\n+                ItemType::Module          => (\"modules\", \"Modules\"),\n+                ItemType::Struct          => (\"structs\", \"Structs\"),\n+                ItemType::Union           => (\"unions\", \"Unions\"),\n+                ItemType::Enum            => (\"enums\", \"Enums\"),\n+                ItemType::Function        => (\"functions\", \"Functions\"),\n+                ItemType::Typedef         => (\"types\", \"Type Definitions\"),\n+                ItemType::Static          => (\"statics\", \"Statics\"),\n+                ItemType::Constant        => (\"constants\", \"Constants\"),\n+                ItemType::Trait           => (\"traits\", \"Traits\"),\n+                ItemType::Impl            => (\"impls\", \"Implementations\"),\n+                ItemType::TyMethod        => (\"tymethods\", \"Type Methods\"),\n+                ItemType::Method          => (\"methods\", \"Methods\"),\n+                ItemType::StructField     => (\"fields\", \"Struct Fields\"),\n+                ItemType::Variant         => (\"variants\", \"Variants\"),\n+                ItemType::Macro           => (\"macros\", \"Macros\"),\n+                ItemType::Primitive       => (\"primitives\", \"Primitive Types\"),\n+                ItemType::AssociatedType  => (\"associated-types\", \"Associated Types\"),\n+                ItemType::AssociatedConst => (\"associated-consts\", \"Associated Constants\"),\n+            };\n+            sidebar.push_str(&format!(\"<li><a href=\\\"#{id}\\\">{name}</a></li>\",\n+                                      id = short,\n+                                      name = name));\n+        }\n+    }\n+\n+    if !sidebar.is_empty() {\n+        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+    }\n+    Ok(())\n+}\n+\n impl<'a> fmt::Display for Source<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Source(s) = *self;"}]}