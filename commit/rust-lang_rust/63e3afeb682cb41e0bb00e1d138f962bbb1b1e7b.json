{"sha": "63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZTNhZmViNjgyY2I0MWUwYmIwMGUxZDEzOGY5NjJiYmIxYjFlN2I=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-08T15:45:31Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-08T15:45:31Z"}, "message": "Merge #462\n\n462: Remove UI-ish FnSignatureInfo from hir r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "f275d467605f7e08907973a64472de7abd2c171e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f275d467605f7e08907973a64472de7abd2c171e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b", "html_url": "https://github.com/rust-lang/rust/commit/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "2f07976cb51f7be216678f410175ba4c09bc7e71", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f07976cb51f7be216678f410175ba4c09bc7e71", "html_url": "https://github.com/rust-lang/rust/commit/2f07976cb51f7be216678f410175ba4c09bc7e71"}, {"sha": "4fa972cffbf4e140e464fbb329f4c1f7a9841a10", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fa972cffbf4e140e464fbb329f4c1f7a9841a10", "html_url": "https://github.com/rust-lang/rust/commit/4fa972cffbf4e140e464fbb329f4c1f7a9841a10"}], "stats": {"total": 1004, "additions": 482, "deletions": 522}, "files": [{"sha": "1dac955843f6723885a0288493e706747e36ccff", "filename": "crates/ra_analysis/src/call_info.rs", "status": "added", "additions": 451, "deletions": 0, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs?ref=63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b", "patch": "@@ -0,0 +1,451 @@\n+use std::cmp::{max, min};\n+\n+use ra_db::{SyntaxDatabase, Cancelable};\n+use ra_syntax::{\n+    AstNode, SyntaxNode, TextUnit, TextRange,\n+    SyntaxKind::FN_DEF,\n+    ast::{self, ArgListOwner, DocCommentsOwner},\n+};\n+use ra_editor::find_node_at_offset;\n+\n+use crate::{FilePosition, CallInfo, db::RootDatabase};\n+\n+/// Computes parameter information for the given call expression.\n+pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Cancelable<Option<CallInfo>> {\n+    let file = db.source_file(position.file_id);\n+    let syntax = file.syntax();\n+\n+    // Find the calling expression and it's NameRef\n+    let calling_node = ctry!(FnCallNode::with_node(syntax, position.offset));\n+    let name_ref = ctry!(calling_node.name_ref());\n+\n+    // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n+    let file_symbols = db.index_resolve(name_ref)?;\n+    let symbol = ctry!(file_symbols.into_iter().find(|it| it.ptr.kind() == FN_DEF));\n+    let fn_file = db.source_file(symbol.file_id);\n+    let fn_def = symbol.ptr.resolve(&fn_file);\n+    let fn_def = ast::FnDef::cast(&fn_def).unwrap();\n+    let mut call_info = ctry!(CallInfo::new(fn_def));\n+    // If we have a calling expression let's find which argument we are on\n+    let num_params = call_info.parameters.len();\n+    let has_self = fn_def.param_list().and_then(|l| l.self_param()).is_some();\n+\n+    if num_params == 1 {\n+        if !has_self {\n+            call_info.active_parameter = Some(0);\n+        }\n+    } else if num_params > 1 {\n+        // Count how many parameters into the call we are.\n+        // TODO: This is best effort for now and should be fixed at some point.\n+        // It may be better to see where we are in the arg_list and then check\n+        // where offset is in that list (or beyond).\n+        // Revisit this after we get documentation comments in.\n+        if let Some(ref arg_list) = calling_node.arg_list() {\n+            let start = arg_list.syntax().range().start();\n+\n+            let range_search = TextRange::from_to(start, position.offset);\n+            let mut commas: usize = arg_list\n+                .syntax()\n+                .text()\n+                .slice(range_search)\n+                .to_string()\n+                .matches(',')\n+                .count();\n+\n+            // If we have a method call eat the first param since it's just self.\n+            if has_self {\n+                commas += 1;\n+            }\n+\n+            call_info.active_parameter = Some(commas);\n+        }\n+    }\n+\n+    Ok(Some(call_info))\n+}\n+\n+enum FnCallNode<'a> {\n+    CallExpr(&'a ast::CallExpr),\n+    MethodCallExpr(&'a ast::MethodCallExpr),\n+}\n+\n+impl<'a> FnCallNode<'a> {\n+    pub fn with_node(syntax: &'a SyntaxNode, offset: TextUnit) -> Option<FnCallNode<'a>> {\n+        if let Some(expr) = find_node_at_offset::<ast::CallExpr>(syntax, offset) {\n+            return Some(FnCallNode::CallExpr(expr));\n+        }\n+        if let Some(expr) = find_node_at_offset::<ast::MethodCallExpr>(syntax, offset) {\n+            return Some(FnCallNode::MethodCallExpr(expr));\n+        }\n+        None\n+    }\n+\n+    pub fn name_ref(&self) -> Option<&'a ast::NameRef> {\n+        match *self {\n+            FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()?.kind() {\n+                ast::ExprKind::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n+                _ => return None,\n+            }),\n+\n+            FnCallNode::MethodCallExpr(call_expr) => call_expr\n+                .syntax()\n+                .children()\n+                .filter_map(ast::NameRef::cast)\n+                .nth(0),\n+        }\n+    }\n+\n+    pub fn arg_list(&self) -> Option<&'a ast::ArgList> {\n+        match *self {\n+            FnCallNode::CallExpr(expr) => expr.arg_list(),\n+            FnCallNode::MethodCallExpr(expr) => expr.arg_list(),\n+        }\n+    }\n+}\n+\n+impl CallInfo {\n+    fn new(node: &ast::FnDef) -> Option<Self> {\n+        let mut doc = None;\n+\n+        // Strip the body out for the label.\n+        let mut label: String = if let Some(body) = node.body() {\n+            let body_range = body.syntax().range();\n+            let label: String = node\n+                .syntax()\n+                .children()\n+                .filter(|child| !child.range().is_subrange(&body_range))\n+                .map(|node| node.text().to_string())\n+                .collect();\n+            label\n+        } else {\n+            node.syntax().text().to_string()\n+        };\n+\n+        if let Some((comment_range, docs)) = extract_doc_comments(node) {\n+            let comment_range = comment_range\n+                .checked_sub(node.syntax().range().start())\n+                .unwrap();\n+            let start = comment_range.start().to_usize();\n+            let end = comment_range.end().to_usize();\n+\n+            // Remove the comment from the label\n+            label.replace_range(start..end, \"\");\n+\n+            // Massage markdown\n+            let mut processed_lines = Vec::new();\n+            let mut in_code_block = false;\n+            for line in docs.lines() {\n+                if line.starts_with(\"```\") {\n+                    in_code_block = !in_code_block;\n+                }\n+\n+                let line = if in_code_block && line.starts_with(\"```\") && !line.contains(\"rust\") {\n+                    \"```rust\".into()\n+                } else {\n+                    line.to_string()\n+                };\n+\n+                processed_lines.push(line);\n+            }\n+\n+            if !processed_lines.is_empty() {\n+                doc = Some(processed_lines.join(\"\\n\"));\n+            }\n+        }\n+\n+        Some(CallInfo {\n+            parameters: param_list(node),\n+            label: label.trim().to_owned(),\n+            doc,\n+            active_parameter: None,\n+        })\n+    }\n+}\n+\n+fn extract_doc_comments(node: &ast::FnDef) -> Option<(TextRange, String)> {\n+    if node.doc_comments().count() == 0 {\n+        return None;\n+    }\n+\n+    let comment_text = node.doc_comment_text();\n+\n+    let (begin, end) = node\n+        .doc_comments()\n+        .map(|comment| comment.syntax().range())\n+        .map(|range| (range.start().to_usize(), range.end().to_usize()))\n+        .fold((std::usize::MAX, std::usize::MIN), |acc, range| {\n+            (min(acc.0, range.0), max(acc.1, range.1))\n+        });\n+\n+    let range = TextRange::from_to(TextUnit::from_usize(begin), TextUnit::from_usize(end));\n+\n+    Some((range, comment_text))\n+}\n+\n+fn param_list(node: &ast::FnDef) -> Vec<String> {\n+    let mut res = vec![];\n+    if let Some(param_list) = node.param_list() {\n+        if let Some(self_param) = param_list.self_param() {\n+            res.push(self_param.syntax().text().to_string())\n+        }\n+\n+        // Maybe use param.pat here? See if we can just extract the name?\n+        //res.extend(param_list.params().map(|p| p.syntax().text().to_string()));\n+        res.extend(\n+            param_list\n+                .params()\n+                .filter_map(|p| p.pat())\n+                .map(|pat| pat.syntax().text().to_string()),\n+        );\n+    }\n+    res\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::mock_analysis::single_file_with_position;\n+\n+    fn call_info(text: &str) -> CallInfo {\n+        let (analysis, position) = single_file_with_position(text);\n+        analysis.call_info(position).unwrap().unwrap()\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_two_args_first() {\n+        let info = call_info(\n+            r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(<|>3, ); }\"#,\n+        );\n+\n+        assert_eq!(info.parameters, vec!(\"x\".to_string(), \"y\".to_string()));\n+        assert_eq!(info.active_parameter, Some(0));\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_two_args_second() {\n+        let info = call_info(\n+            r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3, <|>); }\"#,\n+        );\n+\n+        assert_eq!(info.parameters, vec!(\"x\".to_string(), \"y\".to_string()));\n+        assert_eq!(info.active_parameter, Some(1));\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_for_impl() {\n+        let info = call_info(\n+            r#\"struct F; impl F { pub fn new() { F{}} }\n+fn bar() {let _ : F = F::new(<|>);}\"#,\n+        );\n+\n+        assert_eq!(info.parameters, Vec::<String>::new());\n+        assert_eq!(info.active_parameter, None);\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_for_method_self() {\n+        let info = call_info(\n+            r#\"struct F;\n+impl F {\n+    pub fn new() -> F{\n+        F{}\n+    }\n+\n+    pub fn do_it(&self) {}\n+}\n+\n+fn bar() {\n+    let f : F = F::new();\n+    f.do_it(<|>);\n+}\"#,\n+        );\n+\n+        assert_eq!(info.parameters, vec![\"&self\".to_string()]);\n+        assert_eq!(info.active_parameter, None);\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_for_method_with_arg() {\n+        let info = call_info(\n+            r#\"struct F;\n+impl F {\n+    pub fn new() -> F{\n+        F{}\n+    }\n+\n+    pub fn do_it(&self, x: i32) {}\n+}\n+\n+fn bar() {\n+    let f : F = F::new();\n+    f.do_it(<|>);\n+}\"#,\n+        );\n+\n+        assert_eq!(info.parameters, vec![\"&self\".to_string(), \"x\".to_string()]);\n+        assert_eq!(info.active_parameter, Some(1));\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_with_docs_simple() {\n+        let info = call_info(\n+            r#\"\n+/// test\n+// non-doc-comment\n+fn foo(j: u32) -> u32 {\n+    j\n+}\n+\n+fn bar() {\n+    let _ = foo(<|>);\n+}\n+\"#,\n+        );\n+\n+        assert_eq!(info.parameters, vec![\"j\".to_string()]);\n+        assert_eq!(info.active_parameter, Some(0));\n+        assert_eq!(info.label, \"fn foo(j: u32) -> u32\".to_string());\n+        assert_eq!(info.doc, Some(\"test\".into()));\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_with_docs() {\n+        let info = call_info(\n+            r#\"\n+/// Adds one to the number given.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// let five = 5;\n+///\n+/// assert_eq!(6, my_crate::add_one(5));\n+/// ```\n+pub fn add_one(x: i32) -> i32 {\n+    x + 1\n+}\n+\n+pub fn do() {\n+    add_one(<|>\n+}\"#,\n+        );\n+\n+        assert_eq!(info.parameters, vec![\"x\".to_string()]);\n+        assert_eq!(info.active_parameter, Some(0));\n+        assert_eq!(info.label, \"pub fn add_one(x: i32) -> i32\".to_string());\n+        assert_eq!(\n+            info.doc,\n+            Some(\n+                r#\"Adds one to the number given.\n+\n+# Examples\n+\n+```rust\n+let five = 5;\n+\n+assert_eq!(6, my_crate::add_one(5));\n+```\"#\n+                    .into()\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_with_docs_impl() {\n+        let info = call_info(\n+            r#\"\n+struct addr;\n+impl addr {\n+    /// Adds one to the number given.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let five = 5;\n+    ///\n+    /// assert_eq!(6, my_crate::add_one(5));\n+    /// ```\n+    pub fn add_one(x: i32) -> i32 {\n+        x + 1\n+    }\n+}\n+\n+pub fn do_it() {\n+    addr {};\n+    addr::add_one(<|>);\n+}\"#,\n+        );\n+\n+        assert_eq!(info.parameters, vec![\"x\".to_string()]);\n+        assert_eq!(info.active_parameter, Some(0));\n+        assert_eq!(info.label, \"pub fn add_one(x: i32) -> i32\".to_string());\n+        assert_eq!(\n+            info.doc,\n+            Some(\n+                r#\"Adds one to the number given.\n+\n+# Examples\n+\n+```rust\n+let five = 5;\n+\n+assert_eq!(6, my_crate::add_one(5));\n+```\"#\n+                    .into()\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_with_docs_from_actix() {\n+        let info = call_info(\n+            r#\"\n+pub trait WriteHandler<E>\n+where\n+    Self: Actor,\n+    Self::Context: ActorContext,\n+{\n+    /// Method is called when writer emits error.\n+    ///\n+    /// If this method returns `ErrorAction::Continue` writer processing\n+    /// continues otherwise stream processing stops.\n+    fn error(&mut self, err: E, ctx: &mut Self::Context) -> Running {\n+        Running::Stop\n+    }\n+\n+    /// Method is called when writer finishes.\n+    ///\n+    /// By default this method stops actor's `Context`.\n+    fn finished(&mut self, ctx: &mut Self::Context) {\n+        ctx.stop()\n+    }\n+}\n+\n+pub fn foo() {\n+    WriteHandler r;\n+    r.finished(<|>);\n+}\n+\n+\"#,\n+        );\n+\n+        assert_eq!(\n+            info.parameters,\n+            vec![\"&mut self\".to_string(), \"ctx\".to_string()]\n+        );\n+        assert_eq!(info.active_parameter, Some(1));\n+        assert_eq!(\n+            info.doc,\n+            Some(\n+                r#\"Method is called when writer finishes.\n+\n+By default this method stops actor's `Context`.\"#\n+                    .into()\n+            )\n+        );\n+    }\n+\n+}"}, {"sha": "b3f75fdbebcccc0b6281a85c3207160e2989c698", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 3, "deletions": 111, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b", "patch": "@@ -3,13 +3,13 @@ use std::sync::Arc;\n use salsa::Database;\n \n use hir::{\n-    self, FnSignatureInfo, Problem, source_binder,\n+    self, Problem, source_binder,\n };\n use ra_db::{FilesDatabase, SourceRoot, SourceRootId, SyntaxDatabase};\n use ra_editor::{self, find_node_at_offset, assists, LocalEdit, Severity};\n use ra_syntax::{\n-    SyntaxNode, TextRange, TextUnit, AstNode, SourceFile,\n-    ast::{self, ArgListOwner, NameOwner},\n+    TextRange, AstNode, SourceFile,\n+    ast::{self, NameOwner},\n     SyntaxKind::*,\n };\n \n@@ -262,75 +262,6 @@ impl db::RootDatabase {\n             .collect()\n     }\n \n-    pub(crate) fn resolve_callable(\n-        &self,\n-        position: FilePosition,\n-    ) -> Cancelable<Option<(FnSignatureInfo, Option<usize>)>> {\n-        let file = self.source_file(position.file_id);\n-        let syntax = file.syntax();\n-\n-        // Find the calling expression and it's NameRef\n-        let calling_node = ctry!(FnCallNode::with_node(syntax, position.offset));\n-        let name_ref = ctry!(calling_node.name_ref());\n-\n-        // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n-        let file_symbols = self.index_resolve(name_ref)?;\n-        for symbol in file_symbols {\n-            if symbol.ptr.kind() == FN_DEF {\n-                let fn_file = self.source_file(symbol.file_id);\n-                let fn_def = symbol.ptr.resolve(&fn_file);\n-                let fn_def = ast::FnDef::cast(&fn_def).unwrap();\n-                let descr = ctry!(source_binder::function_from_source(\n-                    self,\n-                    symbol.file_id,\n-                    fn_def\n-                )?);\n-                if let Some(descriptor) = descr.signature_info(self) {\n-                    // If we have a calling expression let's find which argument we are on\n-                    let mut current_parameter = None;\n-\n-                    let num_params = descriptor.params.len();\n-                    let has_self = fn_def.param_list().and_then(|l| l.self_param()).is_some();\n-\n-                    if num_params == 1 {\n-                        if !has_self {\n-                            current_parameter = Some(0);\n-                        }\n-                    } else if num_params > 1 {\n-                        // Count how many parameters into the call we are.\n-                        // TODO: This is best effort for now and should be fixed at some point.\n-                        // It may be better to see where we are in the arg_list and then check\n-                        // where offset is in that list (or beyond).\n-                        // Revisit this after we get documentation comments in.\n-                        if let Some(ref arg_list) = calling_node.arg_list() {\n-                            let start = arg_list.syntax().range().start();\n-\n-                            let range_search = TextRange::from_to(start, position.offset);\n-                            let mut commas: usize = arg_list\n-                                .syntax()\n-                                .text()\n-                                .slice(range_search)\n-                                .to_string()\n-                                .matches(',')\n-                                .count();\n-\n-                            // If we have a method call eat the first param since it's just self.\n-                            if has_self {\n-                                commas += 1;\n-                            }\n-\n-                            current_parameter = Some(commas);\n-                        }\n-                    }\n-\n-                    return Ok(Some((descriptor, current_parameter)));\n-                }\n-            }\n-        }\n-\n-        Ok(None)\n-    }\n-\n     pub(crate) fn rename(\n         &self,\n         position: FilePosition,\n@@ -375,42 +306,3 @@ impl SourceChange {\n         }\n     }\n }\n-\n-enum FnCallNode<'a> {\n-    CallExpr(&'a ast::CallExpr),\n-    MethodCallExpr(&'a ast::MethodCallExpr),\n-}\n-\n-impl<'a> FnCallNode<'a> {\n-    pub fn with_node(syntax: &'a SyntaxNode, offset: TextUnit) -> Option<FnCallNode<'a>> {\n-        if let Some(expr) = find_node_at_offset::<ast::CallExpr>(syntax, offset) {\n-            return Some(FnCallNode::CallExpr(expr));\n-        }\n-        if let Some(expr) = find_node_at_offset::<ast::MethodCallExpr>(syntax, offset) {\n-            return Some(FnCallNode::MethodCallExpr(expr));\n-        }\n-        None\n-    }\n-\n-    pub fn name_ref(&self) -> Option<&'a ast::NameRef> {\n-        match *self {\n-            FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()?.kind() {\n-                ast::ExprKind::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n-                _ => return None,\n-            }),\n-\n-            FnCallNode::MethodCallExpr(call_expr) => call_expr\n-                .syntax()\n-                .children()\n-                .filter_map(ast::NameRef::cast)\n-                .nth(0),\n-        }\n-    }\n-\n-    pub fn arg_list(&self) -> Option<&'a ast::ArgList> {\n-        match *self {\n-            FnCallNode::CallExpr(expr) => expr.arg_list(),\n-            FnCallNode::MethodCallExpr(expr) => expr.arg_list(),\n-        }\n-    }\n-}"}, {"sha": "771a349c8c6e6cf390074c41bf2fedb46b2bc06e", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b", "patch": "@@ -22,6 +22,7 @@ mod symbol_index;\n \n mod extend_selection;\n mod hover;\n+mod call_info;\n mod syntax_highlighting;\n \n use std::{fmt, sync::Arc};\n@@ -39,7 +40,6 @@ pub use crate::{\n     completion::{CompletionItem, CompletionItemKind, InsertText},\n     runnables::{Runnable, RunnableKind},\n };\n-pub use hir::FnSignatureInfo;\n pub use ra_editor::{Fold, FoldKind, HighlightedRange, LineIndex, Severity, StructureNode};\n \n pub use ra_db::{\n@@ -272,6 +272,14 @@ impl<T> RangeInfo<T> {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct CallInfo {\n+    pub label: String,\n+    pub doc: Option<String>,\n+    pub parameters: Vec<String>,\n+    pub active_parameter: Option<usize>,\n+}\n+\n /// `AnalysisHost` stores the current state of the world.\n #[derive(Debug, Default)]\n pub struct AnalysisHost {\n@@ -391,6 +399,10 @@ impl Analysis {\n     pub fn hover(&self, position: FilePosition) -> Cancelable<Option<RangeInfo<String>>> {\n         hover::hover(&*self.db, position)\n     }\n+    /// Computes parameter information for the given call expression.\n+    pub fn call_info(&self, position: FilePosition) -> Cancelable<Option<CallInfo>> {\n+        call_info::call_info(&*self.db, position)\n+    }\n     /// Returns a `mod name;` declaration which created the current module.\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<NavigationTarget>> {\n         self.db.parent_module(position)\n@@ -425,13 +437,6 @@ impl Analysis {\n     pub fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n         self.db.diagnostics(file_id)\n     }\n-    /// Computes parameter information for the given call expression.\n-    pub fn resolve_callable(\n-        &self,\n-        position: FilePosition,\n-    ) -> Cancelable<Option<(FnSignatureInfo, Option<usize>)>> {\n-        self.db.resolve_callable(position)\n-    }\n     /// Computes the type of the expression at the given position.\n     pub fn type_of(&self, frange: FileRange) -> Cancelable<Option<String>> {\n         hover::type_of(&*self.db, frange)"}, {"sha": "2c0735cb50cf433d6f5c980f7fb9bc1725908172", "filename": "crates/ra_analysis/tests/test/main.rs", "status": "modified", "additions": 1, "deletions": 260, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs?ref=63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b", "patch": "@@ -5,14 +5,9 @@ use test_utils::{assert_eq_dbg, assert_eq_text};\n \n use ra_analysis::{\n     mock_analysis::{analysis_and_position, single_file, single_file_with_position, MockAnalysis},\n-    AnalysisChange, CrateGraph, FileId, FnSignatureInfo, Query\n+    AnalysisChange, CrateGraph, FileId, Query\n };\n \n-fn get_signature(text: &str) -> (FnSignatureInfo, Option<usize>) {\n-    let (analysis, position) = single_file_with_position(text);\n-    analysis.resolve_callable(position).unwrap().unwrap()\n-}\n-\n #[test]\n fn test_unresolved_module_diagnostic() {\n     let (analysis, file_id) = single_file(\"mod foo;\");\n@@ -99,260 +94,6 @@ fn test_resolve_crate_root() {\n     assert_eq!(host.analysis().crate_for(mod_file).unwrap(), vec![crate_id]);\n }\n \n-#[test]\n-fn test_fn_signature_two_args_first() {\n-    let (desc, param) = get_signature(\n-        r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(<|>3, ); }\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"foo\".to_string());\n-    assert_eq!(desc.params, vec!(\"x\".to_string(), \"y\".to_string()));\n-    assert_eq!(desc.ret_type, Some(\"-> u32\".into()));\n-    assert_eq!(param, Some(0));\n-}\n-\n-#[test]\n-fn test_fn_signature_two_args_second() {\n-    let (desc, param) = get_signature(\n-        r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3, <|>); }\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"foo\".to_string());\n-    assert_eq!(desc.params, vec!(\"x\".to_string(), \"y\".to_string()));\n-    assert_eq!(desc.ret_type, Some(\"-> u32\".into()));\n-    assert_eq!(param, Some(1));\n-}\n-\n-#[test]\n-fn test_fn_signature_for_impl() {\n-    let (desc, param) = get_signature(\n-        r#\"struct F; impl F { pub fn new() { F{}} }\n-fn bar() {let _ : F = F::new(<|>);}\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"new\".to_string());\n-    assert_eq!(desc.params, Vec::<String>::new());\n-    assert_eq!(desc.ret_type, None);\n-    assert_eq!(param, None);\n-}\n-\n-#[test]\n-fn test_fn_signature_for_method_self() {\n-    let (desc, param) = get_signature(\n-        r#\"struct F;\n-impl F {\n-    pub fn new() -> F{\n-        F{}\n-    }\n-\n-    pub fn do_it(&self) {}\n-}\n-\n-fn bar() {\n-    let f : F = F::new();\n-    f.do_it(<|>);\n-}\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"do_it\".to_string());\n-    assert_eq!(desc.params, vec![\"&self\".to_string()]);\n-    assert_eq!(desc.ret_type, None);\n-    assert_eq!(param, None);\n-}\n-\n-#[test]\n-fn test_fn_signature_for_method_with_arg() {\n-    let (desc, param) = get_signature(\n-        r#\"struct F;\n-impl F {\n-    pub fn new() -> F{\n-        F{}\n-    }\n-\n-    pub fn do_it(&self, x: i32) {}\n-}\n-\n-fn bar() {\n-    let f : F = F::new();\n-    f.do_it(<|>);\n-}\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"do_it\".to_string());\n-    assert_eq!(desc.params, vec![\"&self\".to_string(), \"x\".to_string()]);\n-    assert_eq!(desc.ret_type, None);\n-    assert_eq!(param, Some(1));\n-}\n-\n-#[test]\n-fn test_fn_signature_with_docs_simple() {\n-    let (desc, param) = get_signature(\n-        r#\"\n-/// test\n-// non-doc-comment\n-fn foo(j: u32) -> u32 {\n-    j\n-}\n-\n-fn bar() {\n-    let _ = foo(<|>);\n-}\n-\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"foo\".to_string());\n-    assert_eq!(desc.params, vec![\"j\".to_string()]);\n-    assert_eq!(desc.ret_type, Some(\"-> u32\".to_string()));\n-    assert_eq!(param, Some(0));\n-    assert_eq!(desc.label, \"fn foo(j: u32) -> u32\".to_string());\n-    assert_eq!(desc.doc, Some(\"test\".into()));\n-}\n-\n-#[test]\n-fn test_fn_signature_with_docs() {\n-    let (desc, param) = get_signature(\n-        r#\"\n-/// Adds one to the number given.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// let five = 5;\n-///\n-/// assert_eq!(6, my_crate::add_one(5));\n-/// ```\n-pub fn add_one(x: i32) -> i32 {\n-    x + 1\n-}\n-\n-pub fn do() {\n-    add_one(<|>\n-}\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"add_one\".to_string());\n-    assert_eq!(desc.params, vec![\"x\".to_string()]);\n-    assert_eq!(desc.ret_type, Some(\"-> i32\".to_string()));\n-    assert_eq!(param, Some(0));\n-    assert_eq!(desc.label, \"pub fn add_one(x: i32) -> i32\".to_string());\n-    assert_eq!(\n-        desc.doc,\n-        Some(\n-            r#\"Adds one to the number given.\n-\n-# Examples\n-\n-```rust\n-let five = 5;\n-\n-assert_eq!(6, my_crate::add_one(5));\n-```\"#\n-                .into()\n-        )\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_with_docs_impl() {\n-    let (desc, param) = get_signature(\n-        r#\"\n-struct addr;\n-impl addr {\n-    /// Adds one to the number given.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let five = 5;\n-    ///\n-    /// assert_eq!(6, my_crate::add_one(5));\n-    /// ```\n-    pub fn add_one(x: i32) -> i32 {\n-        x + 1\n-    }\n-}\n-\n-pub fn do_it() {\n-    addr {};\n-    addr::add_one(<|>);\n-}\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"add_one\".to_string());\n-    assert_eq!(desc.params, vec![\"x\".to_string()]);\n-    assert_eq!(desc.ret_type, Some(\"-> i32\".to_string()));\n-    assert_eq!(param, Some(0));\n-    assert_eq!(desc.label, \"pub fn add_one(x: i32) -> i32\".to_string());\n-    assert_eq!(\n-        desc.doc,\n-        Some(\n-            r#\"Adds one to the number given.\n-\n-# Examples\n-\n-```rust\n-let five = 5;\n-\n-assert_eq!(6, my_crate::add_one(5));\n-```\"#\n-                .into()\n-        )\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_with_docs_from_actix() {\n-    let (desc, param) = get_signature(\n-        r#\"\n-pub trait WriteHandler<E>\n-where\n-    Self: Actor,\n-    Self::Context: ActorContext,\n-{\n-    /// Method is called when writer emits error.\n-    ///\n-    /// If this method returns `ErrorAction::Continue` writer processing\n-    /// continues otherwise stream processing stops.\n-    fn error(&mut self, err: E, ctx: &mut Self::Context) -> Running {\n-        Running::Stop\n-    }\n-\n-    /// Method is called when writer finishes.\n-    ///\n-    /// By default this method stops actor's `Context`.\n-    fn finished(&mut self, ctx: &mut Self::Context) {\n-        ctx.stop()\n-    }\n-}\n-\n-pub fn foo() {\n-    WriteHandler r;\n-    r.finished(<|>);\n-}\n-\n-\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"finished\".to_string());\n-    assert_eq!(\n-        desc.params,\n-        vec![\"&mut self\".to_string(), \"ctx\".to_string()]\n-    );\n-    assert_eq!(desc.ret_type, None);\n-    assert_eq!(param, Some(1));\n-    assert_eq!(\n-        desc.doc,\n-        Some(\n-            r#\"Method is called when writer finishes.\n-\n-By default this method stops actor's `Context`.\"#\n-                .into()\n-        )\n-    );\n-}\n-\n fn get_all_refs(text: &str) -> Vec<(FileId, TextRange)> {\n     let (analysis, position) = single_file_with_position(text);\n     analysis.find_all_refs(position).unwrap()"}, {"sha": "2cfc4caa42f6e1011fc8c0c8d70dec19b3e70b3b", "filename": "crates/ra_hir/src/function.rs", "status": "modified", "additions": 3, "deletions": 124, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction.rs?ref=63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b", "patch": "@@ -1,14 +1,11 @@\n mod scope;\n \n-use std::{\n-    cmp::{max, min},\n-    sync::Arc,\n-};\n+use std::sync::Arc;\n \n use ra_db::Cancelable;\n use ra_syntax::{\n-    TextRange, TextUnit, TreePtr,\n-    ast::{self, AstNode, DocCommentsOwner, NameOwner},\n+    TreePtr,\n+    ast::{self, AstNode},\n };\n \n use crate::{DefId, DefKind, HirDatabase, ty::InferenceResult, Module, Crate, impl_block::ImplBlock, expr::{Body, BodySyntaxMapping}, type_ref::{TypeRef, Mutability}, Name};\n@@ -57,11 +54,6 @@ impl Function {\n         db.fn_signature(self.def_id)\n     }\n \n-    pub fn signature_info(&self, db: &impl HirDatabase) -> Option<FnSignatureInfo> {\n-        let syntax = self.syntax(db);\n-        FnSignatureInfo::new(&syntax)\n-    }\n-\n     pub fn infer(&self, db: &impl HirDatabase) -> Cancelable<Arc<InferenceResult>> {\n         db.infer(self.def_id)\n     }\n@@ -132,116 +124,3 @@ pub(crate) fn fn_signature(db: &impl HirDatabase, def_id: DefId) -> Arc<FnSignat\n     let sig = FnSignature { args, ret_type };\n     Arc::new(sig)\n }\n-\n-#[derive(Debug, Clone)]\n-pub struct FnSignatureInfo {\n-    pub name: String,\n-    pub label: String,\n-    pub ret_type: Option<String>,\n-    pub params: Vec<String>,\n-    pub doc: Option<String>,\n-}\n-\n-impl FnSignatureInfo {\n-    fn new(node: &ast::FnDef) -> Option<Self> {\n-        let name = node.name()?.text().to_string();\n-\n-        let mut doc = None;\n-\n-        // Strip the body out for the label.\n-        let mut label: String = if let Some(body) = node.body() {\n-            let body_range = body.syntax().range();\n-            let label: String = node\n-                .syntax()\n-                .children()\n-                .filter(|child| !child.range().is_subrange(&body_range))\n-                .map(|node| node.text().to_string())\n-                .collect();\n-            label\n-        } else {\n-            node.syntax().text().to_string()\n-        };\n-\n-        if let Some((comment_range, docs)) = FnSignatureInfo::extract_doc_comments(node) {\n-            let comment_range = comment_range\n-                .checked_sub(node.syntax().range().start())\n-                .unwrap();\n-            let start = comment_range.start().to_usize();\n-            let end = comment_range.end().to_usize();\n-\n-            // Remove the comment from the label\n-            label.replace_range(start..end, \"\");\n-\n-            // Massage markdown\n-            let mut processed_lines = Vec::new();\n-            let mut in_code_block = false;\n-            for line in docs.lines() {\n-                if line.starts_with(\"```\") {\n-                    in_code_block = !in_code_block;\n-                }\n-\n-                let line = if in_code_block && line.starts_with(\"```\") && !line.contains(\"rust\") {\n-                    \"```rust\".into()\n-                } else {\n-                    line.to_string()\n-                };\n-\n-                processed_lines.push(line);\n-            }\n-\n-            if !processed_lines.is_empty() {\n-                doc = Some(processed_lines.join(\"\\n\"));\n-            }\n-        }\n-\n-        let params = FnSignatureInfo::param_list(node);\n-        let ret_type = node.ret_type().map(|r| r.syntax().text().to_string());\n-\n-        Some(FnSignatureInfo {\n-            name,\n-            ret_type,\n-            params,\n-            label: label.trim().to_owned(),\n-            doc,\n-        })\n-    }\n-\n-    fn extract_doc_comments(node: &ast::FnDef) -> Option<(TextRange, String)> {\n-        if node.doc_comments().count() == 0 {\n-            return None;\n-        }\n-\n-        let comment_text = node.doc_comment_text();\n-\n-        let (begin, end) = node\n-            .doc_comments()\n-            .map(|comment| comment.syntax().range())\n-            .map(|range| (range.start().to_usize(), range.end().to_usize()))\n-            .fold((std::usize::MAX, std::usize::MIN), |acc, range| {\n-                (min(acc.0, range.0), max(acc.1, range.1))\n-            });\n-\n-        let range = TextRange::from_to(TextUnit::from_usize(begin), TextUnit::from_usize(end));\n-\n-        Some((range, comment_text))\n-    }\n-\n-    fn param_list(node: &ast::FnDef) -> Vec<String> {\n-        let mut res = vec![];\n-        if let Some(param_list) = node.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                res.push(self_param.syntax().text().to_string())\n-            }\n-\n-            // Maybe use param.pat here? See if we can just extract the name?\n-            //res.extend(param_list.params().map(|p| p.syntax().text().to_string()));\n-            res.extend(\n-                param_list\n-                    .params()\n-                    .filter_map(|p| p.pat())\n-                    .map(|pat| pat.syntax().text().to_string()),\n-            );\n-        }\n-        res\n-    }\n-}"}, {"sha": "197d8c4fd61760d8408b8dc69b5229bd03ce5d49", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b", "patch": "@@ -53,8 +53,6 @@ pub use self::{\n     impl_block::{ImplBlock, ImplItem},\n };\n \n-pub use self::function::FnSignatureInfo;\n-\n pub use self::code_model_api::{\n     Crate, CrateDependency,\n     Module, ModuleSource, Problem,"}, {"sha": "b9b42f1b3977ee4c9cace3c7852a469790628522", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=63e3afeb682cb41e0bb00e1d138f962bbb1b1e7b", "patch": "@@ -475,36 +475,30 @@ pub fn handle_signature_help(\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<req::SignatureHelp>> {\n     let position = params.try_conv_with(&world)?;\n-\n-    if let Some((descriptor, active_param)) = world.analysis().resolve_callable(position)? {\n-        let parameters: Vec<ParameterInformation> = descriptor\n-            .params\n-            .iter()\n+    if let Some(call_info) = world.analysis().call_info(position)? {\n+        let parameters: Vec<ParameterInformation> = call_info\n+            .parameters\n+            .into_iter()\n             .map(|param| ParameterInformation {\n                 label: ParameterLabel::Simple(param.clone()),\n                 documentation: None,\n             })\n             .collect();\n-\n-        let documentation = if let Some(doc) = descriptor.doc {\n-            Some(Documentation::MarkupContent(MarkupContent {\n+        let documentation = call_info.doc.map(|value| {\n+            Documentation::MarkupContent(MarkupContent {\n                 kind: MarkupKind::Markdown,\n-                value: doc,\n-            }))\n-        } else {\n-            None\n-        };\n-\n+                value,\n+            })\n+        });\n         let sig_info = SignatureInformation {\n-            label: descriptor.label,\n+            label: call_info.label,\n             documentation,\n             parameters: Some(parameters),\n         };\n-\n         Ok(Some(req::SignatureHelp {\n             signatures: vec![sig_info],\n             active_signature: Some(0),\n-            active_parameter: active_param.map(|a| a as u64),\n+            active_parameter: call_info.active_parameter.map(|it| it as u64),\n         }))\n     } else {\n         Ok(None)"}]}