{"sha": "a0edcb4b0384db91f159a9f8c77db3fbd098b2db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZWRjYjRiMDM4NGRiOTFmMTU5YTlmOGM3N2RiM2ZiZDA5OGIyZGI=", "commit": {"author": {"name": "Tim Neumann", "email": "mail@timnn.me", "date": "2017-09-17T11:18:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-09-17T11:18:59Z"}, "message": "Rollup merge of #44073 - murarth:rc-into-raw-unsized, r=alexcrichton\n\nImplement `Arc`/`Rc` raw pointer conversions for `?Sized`\n\n* Add `T: ?Sized` bound to {`Arc`,`Rc`}::{`from_raw`,`into_raw`}", "tree": {"sha": "783ef207d4404cba43dc540fbd3469fde79c12b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/783ef207d4404cba43dc540fbd3469fde79c12b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0edcb4b0384db91f159a9f8c77db3fbd098b2db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0edcb4b0384db91f159a9f8c77db3fbd098b2db", "html_url": "https://github.com/rust-lang/rust/commit/a0edcb4b0384db91f159a9f8c77db3fbd098b2db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0edcb4b0384db91f159a9f8c77db3fbd098b2db/comments", "author": {"login": "TimNN", "id": 1178249, "node_id": "MDQ6VXNlcjExNzgyNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1178249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimNN", "html_url": "https://github.com/TimNN", "followers_url": "https://api.github.com/users/TimNN/followers", "following_url": "https://api.github.com/users/TimNN/following{/other_user}", "gists_url": "https://api.github.com/users/TimNN/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimNN/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimNN/subscriptions", "organizations_url": "https://api.github.com/users/TimNN/orgs", "repos_url": "https://api.github.com/users/TimNN/repos", "events_url": "https://api.github.com/users/TimNN/events{/privacy}", "received_events_url": "https://api.github.com/users/TimNN/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef227f5ffe438783db0add58208d79dd84158c06", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef227f5ffe438783db0add58208d79dd84158c06", "html_url": "https://github.com/rust-lang/rust/commit/ef227f5ffe438783db0add58208d79dd84158c06"}, {"sha": "1cbb2b3a8827a2c7d37c022da1e706229b0e23af", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cbb2b3a8827a2c7d37c022da1e706229b0e23af", "html_url": "https://github.com/rust-lang/rust/commit/1cbb2b3a8827a2c7d37c022da1e706229b0e23af"}], "stats": {"total": 104, "additions": 71, "deletions": 33}, "files": [{"sha": "4b695ad7c7933ae11dcf066daf4c30955063c440", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a0edcb4b0384db91f159a9f8c77db3fbd098b2db/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0edcb4b0384db91f159a9f8c77db3fbd098b2db/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=a0edcb4b0384db91f159a9f8c77db3fbd098b2db", "patch": "@@ -22,7 +22,7 @@ use core::borrow;\n use core::fmt;\n use core::cmp::Ordering;\n use core::intrinsics::abort;\n-use core::mem::{self, size_of_val, uninitialized};\n+use core::mem::{self, align_of_val, size_of_val, uninitialized};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, Shared};\n@@ -324,7 +324,9 @@ impl<T> Arc<T> {\n             Ok(elem)\n         }\n     }\n+}\n \n+impl<T: ?Sized> Arc<T> {\n     /// Consumes the `Arc`, returning the wrapped pointer.\n     ///\n     /// To avoid a memory leak the pointer must be converted back to an `Arc` using\n@@ -378,16 +380,21 @@ impl<T> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // To find the corresponding pointer to the `ArcInner` we need to subtract the offset of the\n-        // `data` field from the pointer.\n-        let ptr = (ptr as *const u8).offset(-offset_of!(ArcInner<T>, data));\n+        // Align the unsized value to the end of the ArcInner.\n+        // Because it is ?Sized, it will always be the last field in memory.\n+        let align = align_of_val(&*ptr);\n+        let layout = Layout::new::<ArcInner<()>>();\n+        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n+\n+        // Reverse the offset to find the original ArcInner.\n+        let fake_ptr = ptr as *mut ArcInner<T>;\n+        let arc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+\n         Arc {\n-            ptr: Shared::new_unchecked(ptr as *mut u8 as *mut _),\n+            ptr: Shared::new_unchecked(arc_ptr),\n         }\n     }\n-}\n \n-impl<T: ?Sized> Arc<T> {\n     /// Creates a new [`Weak`][weak] pointer to this value.\n     ///\n     /// [weak]: struct.Weak.html\n@@ -1491,6 +1498,28 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_into_from_raw_unsized() {\n+        use std::fmt::Display;\n+        use std::string::ToString;\n+\n+        let arc: Arc<str> = Arc::from(\"foo\");\n+\n+        let ptr = Arc::into_raw(arc.clone());\n+        let arc2 = unsafe { Arc::from_raw(ptr) };\n+\n+        assert_eq!(unsafe { &*ptr }, \"foo\");\n+        assert_eq!(arc, arc2);\n+\n+        let arc: Arc<Display> = Arc::new(123);\n+\n+        let ptr = Arc::into_raw(arc.clone());\n+        let arc2 = unsafe { Arc::from_raw(ptr) };\n+\n+        assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n+        assert_eq!(arc2.to_string(), \"123\");\n+    }\n+\n     #[test]\n     fn test_cowarc_clone_make_mut() {\n         let mut cow0 = Arc::new(75);"}, {"sha": "c2a3019515f106cb9ce53d1eecaa83821024d16d", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a0edcb4b0384db91f159a9f8c77db3fbd098b2db/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0edcb4b0384db91f159a9f8c77db3fbd098b2db/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=a0edcb4b0384db91f159a9f8c77db3fbd098b2db", "patch": "@@ -105,22 +105,3 @@ macro_rules! vec {\n macro_rules! format {\n     ($($arg:tt)*) => ($crate::fmt::format(format_args!($($arg)*)))\n }\n-\n-// Private macro to get the offset of a struct field in bytes from the address of the struct.\n-macro_rules! offset_of {\n-    ($container:path, $field:ident) => {{\n-        // Make sure the field actually exists. This line ensures that a compile-time error is\n-        // generated if $field is accessed through a Deref impl.\n-        let $container { $field : _, .. };\n-\n-        // Create an (invalid) instance of the container and calculate the offset to its\n-        // field. Using a null pointer might be UB if `&(*(0 as *const T)).field` is interpreted to\n-        // be nullptr deref.\n-        let invalid: $container = ::core::mem::uninitialized();\n-        let offset = &invalid.$field as *const _ as usize - &invalid as *const _ as usize;\n-\n-        // Do not run destructors on the made up invalid instance.\n-        ::core::mem::forget(invalid);\n-        offset as isize\n-    }};\n-}"}, {"sha": "553980d463fc5e8799870fbc004d61fa52d35835", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a0edcb4b0384db91f159a9f8c77db3fbd098b2db/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0edcb4b0384db91f159a9f8c77db3fbd098b2db/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=a0edcb4b0384db91f159a9f8c77db3fbd098b2db", "patch": "@@ -253,7 +253,7 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::marker;\n use core::marker::Unsize;\n-use core::mem::{self, forget, size_of_val, uninitialized};\n+use core::mem::{self, align_of_val, forget, size_of_val, uninitialized};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, Shared};\n@@ -359,7 +359,9 @@ impl<T> Rc<T> {\n             Err(this)\n         }\n     }\n+}\n \n+impl<T: ?Sized> Rc<T> {\n     /// Consumes the `Rc`, returning the wrapped pointer.\n     ///\n     /// To avoid a memory leak the pointer must be converted back to an `Rc` using\n@@ -413,17 +415,21 @@ impl<T> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // To find the corresponding pointer to the `RcBox` we need to subtract the offset of the\n-        // `value` field from the pointer.\n+        // Align the unsized value to the end of the RcBox.\n+        // Because it is ?Sized, it will always be the last field in memory.\n+        let align = align_of_val(&*ptr);\n+        let layout = Layout::new::<RcBox<()>>();\n+        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n+\n+        // Reverse the offset to find the original RcBox.\n+        let fake_ptr = ptr as *mut RcBox<T>;\n+        let rc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n \n-        let ptr = (ptr as *const u8).offset(-offset_of!(RcBox<T>, value));\n         Rc {\n-            ptr: Shared::new_unchecked(ptr as *mut u8 as *mut _)\n+            ptr: Shared::new_unchecked(rc_ptr),\n         }\n     }\n-}\n \n-impl<T: ?Sized> Rc<T> {\n     /// Creates a new [`Weak`][weak] pointer to this value.\n     ///\n     /// [weak]: struct.Weak.html\n@@ -1522,6 +1528,28 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_into_from_raw_unsized() {\n+        use std::fmt::Display;\n+        use std::string::ToString;\n+\n+        let rc: Rc<str> = Rc::from(\"foo\");\n+\n+        let ptr = Rc::into_raw(rc.clone());\n+        let rc2 = unsafe { Rc::from_raw(ptr) };\n+\n+        assert_eq!(unsafe { &*ptr }, \"foo\");\n+        assert_eq!(rc, rc2);\n+\n+        let rc: Rc<Display> = Rc::new(123);\n+\n+        let ptr = Rc::into_raw(rc.clone());\n+        let rc2 = unsafe { Rc::from_raw(ptr) };\n+\n+        assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n+        assert_eq!(rc2.to_string(), \"123\");\n+    }\n+\n     #[test]\n     fn get_mut() {\n         let mut x = Rc::new(3);"}]}