{"sha": "c1d65eaa456d3986e38868e68e6ce25d802f06b4", "node_id": "C_kwDOAAsO6NoAKGMxZDY1ZWFhNDU2ZDM5ODZlMzg4NjhlNjhlNmNlMjVkODAyZjA2YjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-17T01:46:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-17T01:46:25Z"}, "message": "Auto merge of #96892 - oli-obk:\ud83d\udc0c_obligation_cause_code_\ud83d\udc0c, r=estebank\n\nClean up derived obligation creation\n\nr? `@estebank`\n\nworking on fixing the perf regression from https://github.com/rust-lang/rust/pull/91030#issuecomment-1083360210", "tree": {"sha": "01aa9fd87338a25a484b612c519982682f11ff15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01aa9fd87338a25a484b612c519982682f11ff15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1d65eaa456d3986e38868e68e6ce25d802f06b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1d65eaa456d3986e38868e68e6ce25d802f06b4", "html_url": "https://github.com/rust-lang/rust/commit/c1d65eaa456d3986e38868e68e6ce25d802f06b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1d65eaa456d3986e38868e68e6ce25d802f06b4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1cfdd1fb225d64e78b8d8cbab83564ac2dd5ec2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1cfdd1fb225d64e78b8d8cbab83564ac2dd5ec2", "html_url": "https://github.com/rust-lang/rust/commit/c1cfdd1fb225d64e78b8d8cbab83564ac2dd5ec2"}, {"sha": "0cefa5fa183fc2ff672d68a4c67009b79ded76e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cefa5fa183fc2ff672d68a4c67009b79ded76e4", "html_url": "https://github.com/rust-lang/rust/commit/0cefa5fa183fc2ff672d68a4c67009b79ded76e4"}], "stats": {"total": 395, "additions": 176, "deletions": 219}, "files": [{"sha": "4df4de21a0f0789666f663b879ddde3f12f5f32c", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=c1d65eaa456d3986e38868e68e6ce25d802f06b4", "patch": "@@ -69,14 +69,21 @@ impl<'tcx> PredicateObligation<'tcx> {\n     }\n }\n \n-impl TraitObligation<'_> {\n+impl<'tcx> TraitObligation<'tcx> {\n     /// Returns `true` if the trait predicate is considered `const` in its ParamEnv.\n     pub fn is_const(&self) -> bool {\n         match (self.predicate.skip_binder().constness, self.param_env.constness()) {\n             (ty::BoundConstness::ConstIfConst, hir::Constness::Const) => true,\n             _ => false,\n         }\n     }\n+\n+    pub fn derived_cause(\n+        &self,\n+        variant: impl FnOnce(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>,\n+    ) -> ObligationCause<'tcx> {\n+        self.cause.clone().derived_cause(self.predicate, variant)\n+    }\n }\n \n // `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger."}, {"sha": "263749390857ad69bbc4b795616d16c564fe6beb", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 75, "deletions": 35, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=c1d65eaa456d3986e38868e68e6ce25d802f06b4", "patch": "@@ -97,9 +97,7 @@ pub struct ObligationCause<'tcx> {\n     /// information.\n     pub body_id: hir::HirId,\n \n-    /// `None` for `MISC_OBLIGATION_CAUSE_CODE` (a common case, occurs ~60% of\n-    /// the time). `Some` otherwise.\n-    code: Option<Lrc<ObligationCauseCode<'tcx>>>,\n+    code: InternedObligationCauseCode<'tcx>,\n }\n \n // This custom hash function speeds up hashing for `Obligation` deduplication\n@@ -123,11 +121,7 @@ impl<'tcx> ObligationCause<'tcx> {\n         body_id: hir::HirId,\n         code: ObligationCauseCode<'tcx>,\n     ) -> ObligationCause<'tcx> {\n-        ObligationCause {\n-            span,\n-            body_id,\n-            code: if code == MISC_OBLIGATION_CAUSE_CODE { None } else { Some(Lrc::new(code)) },\n-        }\n+        ObligationCause { span, body_id, code: code.into() }\n     }\n \n     pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n@@ -136,15 +130,12 @@ impl<'tcx> ObligationCause<'tcx> {\n \n     #[inline(always)]\n     pub fn dummy() -> ObligationCause<'tcx> {\n-        ObligationCause { span: DUMMY_SP, body_id: hir::CRATE_HIR_ID, code: None }\n+        ObligationCause::dummy_with_span(DUMMY_SP)\n     }\n \n+    #[inline(always)]\n     pub fn dummy_with_span(span: Span) -> ObligationCause<'tcx> {\n-        ObligationCause { span, body_id: hir::CRATE_HIR_ID, code: None }\n-    }\n-\n-    pub fn make_mut_code(&mut self) -> &mut ObligationCauseCode<'tcx> {\n-        Lrc::make_mut(self.code.get_or_insert_with(|| Lrc::new(MISC_OBLIGATION_CAUSE_CODE)))\n+        ObligationCause { span, body_id: hir::CRATE_HIR_ID, code: Default::default() }\n     }\n \n     pub fn span(&self, tcx: TyCtxt<'tcx>) -> Span {\n@@ -164,14 +155,37 @@ impl<'tcx> ObligationCause<'tcx> {\n \n     #[inline]\n     pub fn code(&self) -> &ObligationCauseCode<'tcx> {\n-        self.code.as_deref().unwrap_or(&MISC_OBLIGATION_CAUSE_CODE)\n+        &self.code\n     }\n \n-    pub fn clone_code(&self) -> Lrc<ObligationCauseCode<'tcx>> {\n-        match &self.code {\n-            Some(code) => code.clone(),\n-            None => Lrc::new(MISC_OBLIGATION_CAUSE_CODE),\n-        }\n+    pub fn map_code(\n+        &mut self,\n+        f: impl FnOnce(InternedObligationCauseCode<'tcx>) -> ObligationCauseCode<'tcx>,\n+    ) {\n+        self.code = f(std::mem::take(&mut self.code)).into();\n+    }\n+\n+    pub fn derived_cause(\n+        mut self,\n+        parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        variant: impl FnOnce(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>,\n+    ) -> ObligationCause<'tcx> {\n+        /*!\n+         * Creates a cause for obligations that are derived from\n+         * `obligation` by a recursive search (e.g., for a builtin\n+         * bound, or eventually a `auto trait Foo`). If `obligation`\n+         * is itself a derived obligation, this is just a clone, but\n+         * otherwise we create a \"derived obligation\" cause so as to\n+         * keep track of the original root obligation for error\n+         * reporting.\n+         */\n+\n+        // NOTE(flaper87): As of now, it keeps track of the whole error\n+        // chain. Ideally, we should have a way to configure this either\n+        // by using -Z verbose or just a CLI argument.\n+        self.code =\n+            variant(DerivedObligationCause { parent_trait_pred, parent_code: self.code }).into();\n+        self\n     }\n }\n \n@@ -182,6 +196,30 @@ pub struct UnifyReceiverContext<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, Default)]\n+pub struct InternedObligationCauseCode<'tcx> {\n+    /// `None` for `MISC_OBLIGATION_CAUSE_CODE` (a common case, occurs ~60% of\n+    /// the time). `Some` otherwise.\n+    code: Option<Lrc<ObligationCauseCode<'tcx>>>,\n+}\n+\n+impl<'tcx> ObligationCauseCode<'tcx> {\n+    #[inline(always)]\n+    fn into(self) -> InternedObligationCauseCode<'tcx> {\n+        InternedObligationCauseCode {\n+            code: if let MISC_OBLIGATION_CAUSE_CODE = self { None } else { Some(Lrc::new(self)) },\n+        }\n+    }\n+}\n+\n+impl<'tcx> std::ops::Deref for InternedObligationCauseCode<'tcx> {\n+    type Target = ObligationCauseCode<'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        self.code.as_deref().unwrap_or(&MISC_OBLIGATION_CAUSE_CODE)\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from the span.\n@@ -269,7 +307,7 @@ pub enum ObligationCauseCode<'tcx> {\n         /// The node of the function call.\n         call_hir_id: hir::HirId,\n         /// The obligation introduced by this argument.\n-        parent_code: Lrc<ObligationCauseCode<'tcx>>,\n+        parent_code: InternedObligationCauseCode<'tcx>,\n     },\n \n     /// Error derived when matching traits/impls; see ObligationCause for more details\n@@ -404,25 +442,27 @@ pub struct ImplDerivedObligationCause<'tcx> {\n     pub span: Span,\n }\n \n-impl ObligationCauseCode<'_> {\n+impl<'tcx> ObligationCauseCode<'tcx> {\n     // Return the base obligation, ignoring derived obligations.\n     pub fn peel_derives(&self) -> &Self {\n         let mut base_cause = self;\n-        loop {\n-            match base_cause {\n-                BuiltinDerivedObligation(DerivedObligationCause { parent_code, .. })\n-                | DerivedObligation(DerivedObligationCause { parent_code, .. })\n-                | FunctionArgumentObligation { parent_code, .. } => {\n-                    base_cause = &parent_code;\n-                }\n-                ImplDerivedObligation(obligation_cause) => {\n-                    base_cause = &*obligation_cause.derived.parent_code;\n-                }\n-                _ => break,\n-            }\n+        while let Some((parent_code, _)) = base_cause.parent() {\n+            base_cause = parent_code;\n         }\n         base_cause\n     }\n+\n+    pub fn parent(&self) -> Option<(&Self, Option<ty::PolyTraitPredicate<'tcx>>)> {\n+        match self {\n+            FunctionArgumentObligation { parent_code, .. } => Some((parent_code, None)),\n+            BuiltinDerivedObligation(derived)\n+            | DerivedObligation(derived)\n+            | ImplDerivedObligation(box ImplDerivedObligationCause { derived, .. }) => {\n+                Some((&derived.parent_code, Some(derived.parent_trait_pred)))\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n // `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -472,7 +512,7 @@ pub struct DerivedObligationCause<'tcx> {\n     pub parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n \n     /// The parent trait had this cause.\n-    pub parent_code: Lrc<ObligationCauseCode<'tcx>>,\n+    pub parent_code: InternedObligationCauseCode<'tcx>,\n }\n \n #[derive(Clone, Debug, TypeFoldable, Lift)]"}, {"sha": "6082d7529c32e836c42d1a202fa0a869baf663f3", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 10, "deletions": 41, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=c1d65eaa456d3986e38868e68e6ce25d802f06b4", "patch": "@@ -2,11 +2,10 @@ pub mod on_unimplemented;\n pub mod suggestions;\n \n use super::{\n-    DerivedObligationCause, EvaluationResult, FulfillmentContext, FulfillmentError,\n-    FulfillmentErrorCode, ImplDerivedObligationCause, MismatchedProjectionTypes, Obligation,\n-    ObligationCause, ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote,\n-    OutputTypeParameterMismatch, Overflow, PredicateObligation, SelectionContext, SelectionError,\n-    TraitNotObjectSafe,\n+    EvaluationResult, FulfillmentContext, FulfillmentError, FulfillmentErrorCode,\n+    MismatchedProjectionTypes, Obligation, ObligationCause, ObligationCauseCode,\n+    OnUnimplementedDirective, OnUnimplementedNote, OutputTypeParameterMismatch, Overflow,\n+    PredicateObligation, SelectionContext, SelectionError, TraitNotObjectSafe,\n };\n \n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n@@ -684,42 +683,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 let mut code = obligation.cause.code();\n                                 let mut trait_pred = trait_predicate;\n                                 let mut peeled = false;\n-                                loop {\n-                                    match &*code {\n-                                        ObligationCauseCode::FunctionArgumentObligation {\n-                                            parent_code,\n-                                            ..\n-                                        } => {\n-                                            code = &parent_code;\n-                                        }\n-                                        ObligationCauseCode::ImplDerivedObligation(\n-                                            box ImplDerivedObligationCause {\n-                                                derived:\n-                                                    DerivedObligationCause {\n-                                                        parent_code,\n-                                                        parent_trait_pred,\n-                                                    },\n-                                                ..\n-                                            },\n-                                        )\n-                                        | ObligationCauseCode::BuiltinDerivedObligation(\n-                                            DerivedObligationCause {\n-                                                parent_code,\n-                                                parent_trait_pred,\n-                                            },\n-                                        )\n-                                        | ObligationCauseCode::DerivedObligation(\n-                                            DerivedObligationCause {\n-                                                parent_code,\n-                                                parent_trait_pred,\n-                                            },\n-                                        ) => {\n-                                            peeled = true;\n-                                            code = &parent_code;\n-                                            trait_pred = *parent_trait_pred;\n-                                        }\n-                                        _ => break,\n-                                    };\n+                                while let Some((parent_code, parent_trait_pred)) = code.parent() {\n+                                    code = parent_code;\n+                                    if let Some(parent_trait_pred) = parent_trait_pred {\n+                                        trait_pred = parent_trait_pred;\n+                                        peeled = true;\n+                                    }\n                                 }\n                                 let def_id = trait_pred.def_id();\n                                 // Mention *all* the `impl`s for the *top most* obligation, the"}, {"sha": "833e232e636655351822f49880bba81c9635901b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=c1d65eaa456d3986e38868e68e6ce25d802f06b4", "patch": "@@ -1,6 +1,6 @@\n use super::{\n-    DerivedObligationCause, EvaluationResult, ImplDerivedObligationCause, Obligation,\n-    ObligationCause, ObligationCauseCode, PredicateObligation, SelectionContext,\n+    EvaluationResult, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation,\n+    SelectionContext,\n };\n \n use crate::autoderef::Autoderef;\n@@ -623,28 +623,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let span = obligation.cause.span;\n         let mut real_trait_pred = trait_pred;\n         let mut code = obligation.cause.code();\n-        loop {\n-            match &code {\n-                ObligationCauseCode::FunctionArgumentObligation { parent_code, .. } => {\n-                    code = &parent_code;\n-                }\n-                ObligationCauseCode::ImplDerivedObligation(box ImplDerivedObligationCause {\n-                    derived: DerivedObligationCause { parent_code, parent_trait_pred },\n-                    ..\n-                })\n-                | ObligationCauseCode::BuiltinDerivedObligation(DerivedObligationCause {\n-                    parent_code,\n-                    parent_trait_pred,\n-                })\n-                | ObligationCauseCode::DerivedObligation(DerivedObligationCause {\n-                    parent_code,\n-                    parent_trait_pred,\n-                }) => {\n-                    code = &parent_code;\n-                    real_trait_pred = *parent_trait_pred;\n-                }\n-                _ => break,\n-            };\n+        while let Some((parent_code, parent_trait_pred)) = code.parent() {\n+            code = parent_code;\n+            if let Some(parent_trait_pred) = parent_trait_pred {\n+                real_trait_pred = parent_trait_pred;\n+            }\n             let Some(real_ty) = real_trait_pred.self_ty().no_bound_vars() else {\n                 continue;\n             };\n@@ -1669,7 +1652,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             debug!(\"maybe_note_obligation_cause_for_async_await: code={:?}\", code);\n             match code {\n                 ObligationCauseCode::FunctionArgumentObligation { parent_code, .. } => {\n-                    next_code = Some(parent_code.as_ref());\n+                    next_code = Some(parent_code);\n                 }\n                 ObligationCauseCode::ImplDerivedObligation(cause) => {\n                     let ty = cause.derived.parent_trait_pred.skip_binder().self_ty();\n@@ -1700,7 +1683,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         _ => {}\n                     }\n \n-                    next_code = Some(cause.derived.parent_code.as_ref());\n+                    next_code = Some(&cause.derived.parent_code);\n                 }\n                 ObligationCauseCode::DerivedObligation(derived_obligation)\n                 | ObligationCauseCode::BuiltinDerivedObligation(derived_obligation) => {\n@@ -1732,7 +1715,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         _ => {}\n                     }\n \n-                    next_code = Some(derived_obligation.parent_code.as_ref());\n+                    next_code = Some(&derived_obligation.parent_code);\n                 }\n                 _ => break,\n             }\n@@ -2382,8 +2365,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let is_upvar_tys_infer_tuple = if !matches!(ty.kind(), ty::Tuple(..)) {\n                     false\n                 } else {\n-                    if let ObligationCauseCode::BuiltinDerivedObligation(ref data) =\n-                        *data.parent_code\n+                    if let ObligationCauseCode::BuiltinDerivedObligation(data) = &*data.parent_code\n                     {\n                         let parent_trait_ref =\n                             self.resolve_vars_if_possible(data.parent_trait_pred);\n@@ -2428,7 +2410,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             err,\n                             &parent_predicate,\n                             param_env,\n-                            &cause_code.peel_derives(),\n+                            cause_code.peel_derives(),\n                             obligated_types,\n                             seen_requirements,\n                         )"}, {"sha": "d607f4e7642b6aa83470369377dced37dacabb08", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=c1d65eaa456d3986e38868e68e6ce25d802f06b4", "patch": "@@ -17,17 +17,15 @@ use rustc_middle::ty::{ToPolyTraitRef, ToPredicate};\n use rustc_span::def_id::DefId;\n \n use crate::traits::project::{normalize_with_depth, normalize_with_depth_to};\n-use crate::traits::select::TraitObligationExt;\n use crate::traits::util::{self, closure_trait_ref_and_return_type, predicate_for_trait_def};\n use crate::traits::{\n-    BuiltinDerivedObligation, DerivedObligationCause, ImplDerivedObligation,\n-    ImplDerivedObligationCause, ImplSource, ImplSourceAutoImplData, ImplSourceBuiltinData,\n-    ImplSourceClosureData, ImplSourceConstDestructData, ImplSourceDiscriminantKindData,\n-    ImplSourceFnPointerData, ImplSourceGeneratorData, ImplSourceObjectData, ImplSourcePointeeData,\n-    ImplSourceTraitAliasData, ImplSourceTraitUpcastingData, ImplSourceUserDefinedData, Normalized,\n-    ObjectCastObligation, Obligation, ObligationCause, OutputTypeParameterMismatch,\n-    PredicateObligation, Selection, SelectionError, TraitNotObjectSafe, TraitObligation,\n-    Unimplemented, VtblSegment,\n+    BuiltinDerivedObligation, ImplDerivedObligation, ImplDerivedObligationCause, ImplSource,\n+    ImplSourceAutoImplData, ImplSourceBuiltinData, ImplSourceClosureData,\n+    ImplSourceConstDestructData, ImplSourceDiscriminantKindData, ImplSourceFnPointerData,\n+    ImplSourceGeneratorData, ImplSourceObjectData, ImplSourcePointeeData, ImplSourceTraitAliasData,\n+    ImplSourceTraitUpcastingData, ImplSourceUserDefinedData, Normalized, ObjectCastObligation,\n+    Obligation, ObligationCause, OutputTypeParameterMismatch, PredicateObligation, Selection,\n+    SelectionError, TraitNotObjectSafe, TraitObligation, Unimplemented, VtblSegment,\n };\n \n use super::BuiltinImplConditions;\n@@ -1128,21 +1126,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let substs = self.rematch_impl(impl_def_id, &new_obligation);\n                 debug!(?substs, \"impl substs\");\n \n-                let derived = DerivedObligationCause {\n-                    parent_trait_pred: obligation.predicate,\n-                    parent_code: obligation.cause.clone_code(),\n-                };\n-                let derived_code = ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n-                    derived,\n-                    impl_def_id,\n-                    span: obligation.cause.span,\n-                }));\n-\n-                let cause = ObligationCause::new(\n-                    obligation.cause.span,\n-                    obligation.cause.body_id,\n-                    derived_code,\n-                );\n+                let cause = obligation.derived_cause(|derived| {\n+                    ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n+                        derived,\n+                        impl_def_id,\n+                        span: obligation.cause.span,\n+                    }))\n+                });\n                 ensure_sufficient_stack(|| {\n                     self.vtable_impl(\n                         impl_def_id,"}, {"sha": "a1577a30c9170d520ae6a200376b685f1295b489", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 10, "deletions": 48, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=c1d65eaa456d3986e38868e68e6ce25d802f06b4", "patch": "@@ -14,9 +14,9 @@ use super::util;\n use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n use super::wf;\n use super::{\n-    DerivedObligationCause, ErrorReporting, ImplDerivedObligation, ImplDerivedObligationCause,\n-    Normalized, Obligation, ObligationCause, ObligationCauseCode, Overflow, PredicateObligation,\n-    Selection, SelectionError, SelectionResult, TraitObligation, TraitQueryMode,\n+    ErrorReporting, ImplDerivedObligation, ImplDerivedObligationCause, Normalized, Obligation,\n+    ObligationCause, ObligationCauseCode, Overflow, PredicateObligation, Selection, SelectionError,\n+    SelectionResult, TraitObligation, TraitQueryMode,\n };\n \n use crate::infer::{InferCtxt, InferOk, TypeFreshener};\n@@ -2314,17 +2314,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?predicates);\n         assert_eq!(predicates.parent, None);\n         let mut obligations = Vec::with_capacity(predicates.predicates.len());\n-        let parent_code = cause.clone_code();\n         for (predicate, span) in predicates.predicates {\n             let span = *span;\n-            let derived =\n-                DerivedObligationCause { parent_trait_pred, parent_code: parent_code.clone() };\n-            let code = ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n-                derived,\n-                impl_def_id: def_id,\n-                span,\n-            }));\n-            let cause = ObligationCause::new(cause.span, cause.body_id, code);\n+            let cause = cause.clone().derived_cause(parent_trait_pred, |derived| {\n+                ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n+                    derived,\n+                    impl_def_id: def_id,\n+                    span,\n+                }))\n+            });\n             let predicate = normalize_with_depth_to(\n                 self,\n                 param_env,\n@@ -2340,42 +2338,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n }\n \n-trait TraitObligationExt<'tcx> {\n-    fn derived_cause(\n-        &self,\n-        variant: fn(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>,\n-    ) -> ObligationCause<'tcx>;\n-}\n-\n-impl<'tcx> TraitObligationExt<'tcx> for TraitObligation<'tcx> {\n-    fn derived_cause(\n-        &self,\n-        variant: fn(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>,\n-    ) -> ObligationCause<'tcx> {\n-        /*!\n-         * Creates a cause for obligations that are derived from\n-         * `obligation` by a recursive search (e.g., for a builtin\n-         * bound, or eventually a `auto trait Foo`). If `obligation`\n-         * is itself a derived obligation, this is just a clone, but\n-         * otherwise we create a \"derived obligation\" cause so as to\n-         * keep track of the original root obligation for error\n-         * reporting.\n-         */\n-\n-        let obligation = self;\n-\n-        // NOTE(flaper87): As of now, it keeps track of the whole error\n-        // chain. Ideally, we should have a way to configure this either\n-        // by using -Z verbose or just a CLI argument.\n-        let derived_cause = DerivedObligationCause {\n-            parent_trait_pred: obligation.predicate,\n-            parent_code: obligation.cause.clone_code(),\n-        };\n-        let derived_code = variant(derived_cause);\n-        ObligationCause::new(obligation.cause.span, obligation.cause.body_id, derived_code)\n-    }\n-}\n-\n impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n     fn list(&'o self) -> TraitObligationStackList<'o, 'tcx> {\n         TraitObligationStackList::with(self)"}, {"sha": "0379b16334cdc6f1ef64aa02d2889effa2ebe550", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=c1d65eaa456d3986e38868e68e6ce25d802f06b4", "patch": "@@ -294,30 +294,22 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         let obligations = self.nominal_obligations(trait_ref.def_id, trait_ref.substs);\n \n         debug!(\"compute_trait_ref obligations {:?}\", obligations);\n-        let cause = self.cause(traits::MiscObligation);\n         let param_env = self.param_env;\n         let depth = self.recursion_depth;\n \n         let item = self.item;\n \n-        let extend = |obligation: traits::PredicateObligation<'tcx>| {\n-            let mut cause = cause.clone();\n-            if let Some(parent_trait_pred) = obligation.predicate.to_opt_poly_trait_pred() {\n-                let derived_cause = traits::DerivedObligationCause {\n+        let extend = |traits::PredicateObligation { predicate, mut cause, .. }| {\n+            if let Some(parent_trait_pred) = predicate.to_opt_poly_trait_pred() {\n+                cause = cause.derived_cause(\n                     parent_trait_pred,\n-                    parent_code: obligation.cause.clone_code(),\n-                };\n-                *cause.make_mut_code() =\n-                    traits::ObligationCauseCode::DerivedObligation(derived_cause);\n+                    traits::ObligationCauseCode::DerivedObligation,\n+                );\n             }\n             extend_cause_with_original_assoc_item_obligation(\n-                tcx,\n-                trait_ref,\n-                item,\n-                &mut cause,\n-                obligation.predicate,\n+                tcx, trait_ref, item, &mut cause, predicate,\n             );\n-            traits::Obligation::with_depth(cause, depth, param_env, obligation.predicate)\n+            traits::Obligation::with_depth(cause, depth, param_env, predicate)\n         };\n \n         if let Elaborate::All = elaborate {\n@@ -339,17 +331,17 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 })\n                 .filter(|(_, arg)| !arg.has_escaping_bound_vars())\n                 .map(|(i, arg)| {\n-                    let mut new_cause = cause.clone();\n+                    let mut cause = traits::ObligationCause::misc(self.span, self.body_id);\n                     // The first subst is the self ty - use the correct span for it.\n                     if i == 0 {\n                         if let Some(hir::ItemKind::Impl(hir::Impl { self_ty, .. })) =\n                             item.map(|i| &i.kind)\n                         {\n-                            new_cause.span = self_ty.span;\n+                            cause.span = self_ty.span;\n                         }\n                     }\n                     traits::Obligation::with_depth(\n-                        new_cause,\n+                        cause,\n                         depth,\n                         param_env,\n                         ty::Binder::dummy(ty::PredicateKind::WellFormed(arg)).to_predicate(tcx),"}, {"sha": "54003654db010260560eaf7535ba958579333e79", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d65eaa456d3986e38868e68e6ce25d802f06b4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=c1d65eaa456d3986e38868e68e6ce25d802f06b4", "patch": "@@ -12,7 +12,6 @@ use crate::check::{\n use crate::structured_errors::StructuredDiagnostic;\n \n use rustc_ast as ast;\n-use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticId, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n@@ -1596,24 +1595,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Peel derived obligation, because it's the type that originally\n             // started this inference chain that matters, not the one we wound\n             // up with at the end.\n-            fn unpeel_to_top(\n-                mut code: Lrc<ObligationCauseCode<'_>>,\n-            ) -> Lrc<ObligationCauseCode<'_>> {\n-                let mut result_code = code.clone();\n+            fn unpeel_to_top<'a, 'tcx>(\n+                mut code: &'a ObligationCauseCode<'tcx>,\n+            ) -> &'a ObligationCauseCode<'tcx> {\n+                let mut result_code = code;\n                 loop {\n-                    let parent = match &*code {\n-                        ObligationCauseCode::ImplDerivedObligation(c) => {\n-                            c.derived.parent_code.clone()\n-                        }\n+                    let parent = match code {\n+                        ObligationCauseCode::ImplDerivedObligation(c) => &c.derived.parent_code,\n                         ObligationCauseCode::BuiltinDerivedObligation(c)\n-                        | ObligationCauseCode::DerivedObligation(c) => c.parent_code.clone(),\n-                        _ => break,\n+                        | ObligationCauseCode::DerivedObligation(c) => &c.parent_code,\n+                        _ => break result_code,\n                     };\n-                    result_code = std::mem::replace(&mut code, parent);\n+                    (result_code, code) = (code, parent);\n                 }\n-                result_code\n             }\n-            let self_: ty::subst::GenericArg<'_> = match &*unpeel_to_top(error.obligation.cause.clone_code()) {\n+            let self_: ty::subst::GenericArg<'_> = match unpeel_to_top(error.obligation.cause.code()) {\n                 ObligationCauseCode::BuiltinDerivedObligation(code) |\n                 ObligationCauseCode::DerivedObligation(code) => {\n                     code.parent_trait_pred.self_ty().skip_binder().into()\n@@ -1663,13 +1659,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // We make sure that only *one* argument matches the obligation failure\n                 // and we assign the obligation's span to its expression's.\n                 error.obligation.cause.span = args[ref_in].span;\n-                let parent_code = error.obligation.cause.clone_code();\n-                *error.obligation.cause.make_mut_code() =\n+                error.obligation.cause.map_code(|parent_code| {\n                     ObligationCauseCode::FunctionArgumentObligation {\n                         arg_hir_id: args[ref_in].hir_id,\n                         call_hir_id: expr.hir_id,\n                         parent_code,\n-                    };\n+                    }\n+                });\n             } else if error.obligation.cause.span == call_sp {\n                 // Make function calls point at the callee, not the whole thing.\n                 if let hir::ExprKind::Call(callee, _) = expr.kind {"}, {"sha": "a65f84ae58eadd479dffcd1d22aac7e643993330", "filename": "src/test/ui/associated-types/hr-associated-type-projection-1.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1d65eaa456d3986e38868e68e6ce25d802f06b4/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-projection-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1d65eaa456d3986e38868e68e6ce25d802f06b4/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-projection-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-projection-1.stderr?ref=c1d65eaa456d3986e38868e68e6ce25d802f06b4", "patch": "@@ -2,10 +2,18 @@ error[E0271]: type mismatch resolving `<T as Deref>::Target == T`\n   --> $DIR/hr-associated-type-projection-1.rs:13:33\n    |\n LL | impl<T: Copy + std::ops::Deref> UnsafeCopy<'_, T> for T {\n-   |      - this type parameter      ^^^^^^^^^^^^^^^^^ expected associated type, found type parameter `T`\n+   |      - this type parameter      ^^^^^^^^^^^^^^^^^ expected type parameter `T`, found associated type\n    |\n-   = note: expected associated type `<T as Deref>::Target`\n-               found type parameter `T`\n+   = note: expected type parameter `T`\n+             found associated type `<T as Deref>::Target`\n+note: required by a bound in `UnsafeCopy`\n+  --> $DIR/hr-associated-type-projection-1.rs:3:64\n+   |\n+LL | trait UnsafeCopy<'a, T: Copy>\n+   |       ---------- required by a bound in this\n+LL | where\n+LL |     for<'b> <Self as UnsafeCopy<'b, T>>::Item: std::ops::Deref<Target = T>,\n+   |                                                                ^^^^^^^^^^ required by this bound in `UnsafeCopy`\n help: consider further restricting this bound\n    |\n LL | impl<T: Copy + std::ops::Deref + Deref<Target = T>> UnsafeCopy<'_, T> for T {"}, {"sha": "e2b177b951cc9a2c2bda0f492468fc4e97faa295", "filename": "src/test/ui/builtin-superkinds/builtin-superkinds-self-type.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1d65eaa456d3986e38868e68e6ce25d802f06b4/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1d65eaa456d3986e38868e68e6ce25d802f06b4/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr?ref=c1d65eaa456d3986e38868e68e6ce25d802f06b4", "patch": "@@ -2,8 +2,13 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/builtin-superkinds-self-type.rs:10:16\n    |\n LL | impl <T: Sync> Foo for T { }\n-   |                ^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |                ^^^ ...so that the type `T` will meet its required lifetime bounds...\n    |\n+note: ...that is required by this bound\n+  --> $DIR/builtin-superkinds-self-type.rs:6:24\n+   |\n+LL | trait Foo : Sized+Sync+'static {\n+   |                        ^^^^^^^\n help: consider adding an explicit lifetime bound...\n    |\n LL | impl <T: Sync + 'static> Foo for T { }"}, {"sha": "f36947914179cc45e0f017f6dc32ef4ceb6e35c5", "filename": "src/test/ui/traits/assoc-type-in-superbad.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1d65eaa456d3986e38868e68e6ce25d802f06b4/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1d65eaa456d3986e38868e68e6ce25d802f06b4/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.stderr?ref=c1d65eaa456d3986e38868e68e6ce25d802f06b4", "patch": "@@ -2,7 +2,13 @@ error[E0271]: type mismatch resolving `<std::vec::IntoIter<i32> as Iterator>::It\n   --> $DIR/assoc-type-in-superbad.rs:12:16\n    |\n LL |     type Key = u32;\n-   |                ^^^ expected `i32`, found `u32`\n+   |                ^^^ expected `u32`, found `i32`\n+   |\n+note: required by a bound in `Foo`\n+  --> $DIR/assoc-type-in-superbad.rs:7:25\n+   |\n+LL | pub trait Foo: Iterator<Item=<Self as Foo>::Key> {\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Foo`\n \n error: aborting due to previous error\n "}]}