{"sha": "27167cbbaa862fc96017831f21f492c51eb8eed0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MTY3Y2JiYWE4NjJmYzk2MDE3ODMxZjIxZjQ5MmM1MWViOGVlZDA=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-24T14:40:53Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-24T14:56:51Z"}, "message": "Format code block in comment\n\nCloses #554.\nCloses #1695.", "tree": {"sha": "4eb1fcd282e22a3c13511f8595c88f76a6895e39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eb1fcd282e22a3c13511f8595c88f76a6895e39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27167cbbaa862fc96017831f21f492c51eb8eed0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27167cbbaa862fc96017831f21f492c51eb8eed0", "html_url": "https://github.com/rust-lang/rust/commit/27167cbbaa862fc96017831f21f492c51eb8eed0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27167cbbaa862fc96017831f21f492c51eb8eed0/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "939a6c58202f775a63e46fbde4e0d6b3b04cf8aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/939a6c58202f775a63e46fbde4e0d6b3b04cf8aa", "html_url": "https://github.com/rust-lang/rust/commit/939a6c58202f775a63e46fbde4e0d6b3b04cf8aa"}], "stats": {"total": 217, "additions": 190, "deletions": 27}, "files": [{"sha": "eb9e96f2509f1bf3f40204fb85bceef38ce18ecd", "filename": "src/comment.rs", "status": "modified", "additions": 49, "deletions": 25, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/27167cbbaa862fc96017831f21f492c51eb8eed0/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27167cbbaa862fc96017831f21f492c51eb8eed0/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=27167cbbaa862fc96017831f21f492c51eb8eed0", "patch": "@@ -318,41 +318,65 @@ fn rewrite_comment_inner(\n \n     let mut result = String::with_capacity(orig.len() * 2);\n     result.push_str(opener);\n+    let mut code_block_buffer = String::with_capacity(128);\n     let mut is_prev_line_multi_line = false;\n     let mut inside_code_block = false;\n     let comment_line_separator = format!(\"\\n{}{}\", indent_str, line_start);\n+    let join_code_block_with_comment_line_separator = |s: &str| {\n+        let mut result = String::with_capacity(s.len() + 128);\n+        let mut iter = s.lines().peekable();\n+        while let Some(line) = iter.next() {\n+            result.push_str(line);\n+            result.push_str(match iter.peek() {\n+                Some(ref next_line) if next_line.is_empty() => comment_line_separator.trim_right(),\n+                Some(..) => &comment_line_separator,\n+                None => \"\",\n+            });\n+        }\n+        result\n+    };\n+\n     for (i, (line, has_leading_whitespace)) in lines.enumerate() {\n         let is_last = i == count_newlines(orig);\n-        if result == opener {\n-            let force_leading_whitespace = opener == \"/* \" && count_newlines(orig) == 0;\n-            if !has_leading_whitespace && !force_leading_whitespace && result.ends_with(' ') {\n-                result.pop();\n-            }\n-            if line.is_empty() {\n-                continue;\n-            }\n-        } else if is_prev_line_multi_line && !line.is_empty() {\n-            result.push(' ')\n-        } else if is_last && !closer.is_empty() && line.is_empty() {\n-            result.push('\\n');\n-            result.push_str(&indent_str);\n-        } else {\n-            result.push_str(&comment_line_separator);\n-            if !has_leading_whitespace && result.ends_with(' ') {\n-                result.pop();\n-            }\n-        }\n \n-        if line.starts_with(\"```\") {\n-            inside_code_block = !inside_code_block;\n-        }\n         if inside_code_block {\n-            if line.is_empty() && result.ends_with(' ') {\n-                result.pop();\n-            } else {\n+            if line.starts_with(\"```\") {\n+                inside_code_block = false;\n+                result.push_str(&comment_line_separator);\n+                let code_block = ::format_code_block(&code_block_buffer, config)\n+                    .unwrap_or_else(|| code_block_buffer.to_owned());\n+                result.push_str(&join_code_block_with_comment_line_separator(&code_block));\n+                code_block_buffer.clear();\n+                result.push_str(&comment_line_separator);\n                 result.push_str(line);\n+            } else {\n+                code_block_buffer.push_str(line);\n+                code_block_buffer.push('\\n');\n             }\n+\n             continue;\n+        } else {\n+            inside_code_block = line.starts_with(\"```\");\n+\n+            if result == opener {\n+                let force_leading_whitespace = opener == \"/* \" && count_newlines(orig) == 0;\n+                if !has_leading_whitespace && !force_leading_whitespace && result.ends_with(' ') {\n+                    result.pop();\n+                }\n+                if line.is_empty() {\n+                    continue;\n+                }\n+            } else if is_prev_line_multi_line && !line.is_empty() {\n+                result.push(' ')\n+            } else if is_last && !closer.is_empty() && line.is_empty() {\n+                result.push('\\n');\n+                result.push_str(&indent_str);\n+            } else {\n+                result.push_str(&comment_line_separator);\n+                if !has_leading_whitespace && result.ends_with(' ') {\n+                    result.pop();\n+                }\n+            }\n         }\n \n         if config.wrap_comments() && line.len() > fmt.shape.width && !has_url(line) {"}, {"sha": "d221f6a7d6049675449a6894a577ab8d5260b4e6", "filename": "src/lib.rs", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/27167cbbaa862fc96017831f21f492c51eb8eed0/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27167cbbaa862fc96017831f21f492c51eb8eed0/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=27167cbbaa862fc96017831f21f492c51eb8eed0", "patch": "@@ -44,6 +44,7 @@ use comment::{CharClasses, FullCodeCharKind};\n use config::Config;\n use filemap::FileMap;\n use issues::{BadIssueSeeker, Issue};\n+use shape::Indent;\n use utils::use_colored_tty;\n use visitor::{FmtVisitor, SnippetProvider};\n \n@@ -529,6 +530,55 @@ fn parse_input(\n     }\n }\n \n+/// Format the given snippet. The snippet is expected to be *complete* code.\n+/// When we cannot parse the given snippet, this function returns `None`.\n+pub fn format_snippet(snippet: &str, config: &Config) -> Option<String> {\n+    let mut out: Vec<u8> = Vec::with_capacity(snippet.len() * 2);\n+    let input = Input::Text(snippet.into());\n+    let mut config = config.clone();\n+    config.set().write_mode(config::WriteMode::Plain);\n+    match format_input(input, &config, Some(&mut out)) {\n+        // `format_input()` returns an empty string on parsing error.\n+        Ok(..) if out.is_empty() && !snippet.is_empty() => None,\n+        Ok(..) => String::from_utf8(out).ok(),\n+        Err(..) => None,\n+    }\n+}\n+\n+/// Format the given code block. Mainly targeted for code block in comment.\n+/// The code block may be incomplete (i.e. parser may be unable to parse it).\n+/// To avoid panic in parser, we wrap the code block with a dummy function.\n+/// The returned code block does *not* end with newline.\n+pub fn format_code_block(code_snippet: &str, config: &Config) -> Option<String> {\n+    // Wrap the given code block with `fn main()` if it does not have one.\n+    let fn_main_prefix = \"fn main() {\\n\";\n+    let snippet = fn_main_prefix.to_owned() + code_snippet + \"\\n}\";\n+\n+    // Trim \"fn main() {\" on the first line and \"}\" on the last line,\n+    // then unindent the whole code block.\n+    format_snippet(&snippet, config).map(|s| {\n+        // 2 = \"}\\n\"\n+        s[fn_main_prefix.len()..s.len().checked_sub(2).unwrap_or(0)]\n+            .lines()\n+            .map(|line| {\n+                if line.len() > config.tab_spaces() {\n+                    // Make sure that the line has leading whitespaces.\n+                    let indent_str =\n+                        Indent::from_width(config, config.tab_spaces()).to_string(config);\n+                    if line.starts_with(indent_str.as_ref()) {\n+                        &line[config.tab_spaces()..]\n+                    } else {\n+                        line\n+                    }\n+                } else {\n+                    line\n+                }\n+            })\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\")\n+    })\n+}\n+\n pub fn format_input<T: Write>(\n     input: Input,\n     config: &Config,\n@@ -650,3 +700,86 @@ pub fn run(input: Input, config: &Config) -> Summary {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use super::{format_code_block, format_snippet, Config};\n+\n+    #[test]\n+    fn test_no_panic_on_format_snippet_and_format_code_block() {\n+        // `format_snippet()` and `format_code_block()` should not panic\n+        // even when we cannot parse the given snippet.\n+        let snippet = \"let\";\n+        assert!(format_snippet(snippet, &Config::default()).is_none());\n+        assert!(format_code_block(snippet, &Config::default()).is_none());\n+    }\n+\n+    fn test_format_inner<F>(formatter: F, input: &str, expected: &str) -> bool\n+    where\n+        F: Fn(&str, &Config) -> Option<String>,\n+    {\n+        let output = formatter(input, &Config::default());\n+        output.is_some() && output.unwrap() == expected\n+    }\n+\n+    #[test]\n+    fn test_format_snippet() {\n+        let snippet = \"fn main() { println!(\\\"hello, world\\\"); }\";\n+        let expected = \"fn main() {\\n    \\\n+                        println!(\\\"hello, world\\\");\\n\\\n+                        }\\n\";\n+        assert!(test_format_inner(format_snippet, snippet, expected));\n+    }\n+\n+    #[test]\n+    fn test_format_code_block() {\n+        // simple code block\n+        let code_block = \"let x=3;\";\n+        let expected = \"let x = 3;\";\n+        assert!(test_format_inner(format_code_block, code_block, expected));\n+\n+        // more complex code block, taken from chains.rs.\n+        let code_block =\n+\"let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n+(\n+chain_indent(context, shape.add_offset(parent_rewrite.len())),\n+context.config.indent_style() == IndentStyle::Visual || is_small_parent,\n+)\n+} else if is_block_expr(context, &parent, &parent_rewrite) {\n+match context.config.indent_style() {\n+// Try to put the first child on the same line with parent's last line\n+IndentStyle::Block => (parent_shape.block_indent(context.config.tab_spaces()), true),\n+// The parent is a block, so align the rest of the chain with the closing\n+// brace.\n+IndentStyle::Visual => (parent_shape, false),\n+}\n+} else {\n+(\n+chain_indent(context, shape.add_offset(parent_rewrite.len())),\n+false,\n+)\n+};\n+\";\n+        let expected =\n+\"let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n+    (\n+        chain_indent(context, shape.add_offset(parent_rewrite.len())),\n+        context.config.indent_style() == IndentStyle::Visual || is_small_parent,\n+    )\n+} else if is_block_expr(context, &parent, &parent_rewrite) {\n+    match context.config.indent_style() {\n+        // Try to put the first child on the same line with parent's last line\n+        IndentStyle::Block => (parent_shape.block_indent(context.config.tab_spaces()), true),\n+        // The parent is a block, so align the rest of the chain with the closing\n+        // brace.\n+        IndentStyle::Visual => (parent_shape, false),\n+    }\n+} else {\n+    (\n+        chain_indent(context, shape.add_offset(parent_rewrite.len())),\n+        false,\n+    )\n+};\";\n+        assert!(test_format_inner(format_code_block, code_block, expected));\n+    }\n+}"}, {"sha": "76dbbefc3a7a87de82e7982cb149e7df0dcbdb2e", "filename": "tests/target/issue-2197.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/27167cbbaa862fc96017831f21f492c51eb8eed0/tests%2Ftarget%2Fissue-2197.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27167cbbaa862fc96017831f21f492c51eb8eed0/tests%2Ftarget%2Fissue-2197.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-2197.rs?ref=27167cbbaa862fc96017831f21f492c51eb8eed0", "patch": "@@ -4,8 +4,14 @@\n \n /// ```rust\n /// unsafe fn sum_sse2(x: i32x4) -> i32 {\n-///     let x = vendor::_mm_add_epi32(x, vendor::_mm_srli_si128(x.into(), 8).into());\n-///     let x = vendor::_mm_add_epi32(x, vendor::_mm_srli_si128(x.into(), 4).into());\n+///     let x = vendor::_mm_add_epi32(\n+///         x,\n+///         vendor::_mm_srli_si128(x.into(), 8).into(),\n+///     );\n+///     let x = vendor::_mm_add_epi32(\n+///         x,\n+///         vendor::_mm_srli_si128(x.into(), 4).into(),\n+///     );\n ///     vendor::_mm_cvtsi128_si32(x)\n /// }\n /// ```"}]}