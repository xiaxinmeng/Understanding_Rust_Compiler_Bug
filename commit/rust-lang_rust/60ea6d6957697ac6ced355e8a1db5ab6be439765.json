{"sha": "60ea6d6957697ac6ced355e8a1db5ab6be439765", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwZWE2ZDY5NTc2OTdhYzZjZWQzNTVlOGExZGI1YWI2YmU0Mzk3NjU=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-05-18T06:50:23Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-05-18T07:29:14Z"}, "message": "Convert various inner doc-comments to outer doc-comments", "tree": {"sha": "231fe223bc379d7243acd22be186a9df105dd1b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/231fe223bc379d7243acd22be186a9df105dd1b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60ea6d6957697ac6ced355e8a1db5ab6be439765", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60ea6d6957697ac6ced355e8a1db5ab6be439765", "html_url": "https://github.com/rust-lang/rust/commit/60ea6d6957697ac6ced355e8a1db5ab6be439765", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60ea6d6957697ac6ced355e8a1db5ab6be439765/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "728fe775a28b780d2bb26982992d5aab7623ba13", "url": "https://api.github.com/repos/rust-lang/rust/commits/728fe775a28b780d2bb26982992d5aab7623ba13", "html_url": "https://github.com/rust-lang/rust/commit/728fe775a28b780d2bb26982992d5aab7623ba13"}], "stats": {"total": 85, "additions": 30, "deletions": 55}, "files": [{"sha": "ca9c49b2c0682a90c3baa3ca28b9d33e44a0b619", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60ea6d6957697ac6ced355e8a1db5ab6be439765/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ea6d6957697ac6ced355e8a1db5ab6be439765/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=60ea6d6957697ac6ced355e8a1db5ab6be439765", "patch": "@@ -127,12 +127,11 @@ totalord_impl!(uint)\n \n totalord_impl!(char)\n \n+/// Compares (a1, b1) against (a2, b2), where the a values are more significant.\n pub fn cmp2<A:TotalOrd,B:TotalOrd>(\n     a1: &A, b1: &B,\n     a2: &A, b2: &B) -> Ordering\n {\n-    //! Compares (a1, b1) against (a2, b2), where the a values are more significant.\n-\n     match a1.cmp(a2) {\n         Less => Less,\n         Greater => Greater,"}, {"sha": "ab52822849cfb55377dc199e05d1ef6cb894be32", "filename": "src/libcore/either.rs", "status": "modified", "additions": 22, "deletions": 40, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/60ea6d6957697ac6ced355e8a1db5ab6be439765/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ea6d6957697ac6ced355e8a1db5ab6be439765/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=60ea6d6957697ac6ced355e8a1db5ab6be439765", "patch": "@@ -26,26 +26,22 @@ pub enum Either<T, U> {\n     Right(U)\n }\n \n+/// Applies a function based on the given either value\n+///\n+/// If `value` is left(T) then `f_left` is applied to its contents, if\n+/// `value` is right(U) then `f_right` is applied to its contents, and the\n+/// result is returned.\n #[inline(always)]\n pub fn either<T, U, V>(f_left: &fn(&T) -> V,\n                        f_right: &fn(&U) -> V, value: &Either<T, U>) -> V {\n-    /*!\n-     * Applies a function based on the given either value\n-     *\n-     * If `value` is left(T) then `f_left` is applied to its contents, if\n-     * `value` is right(U) then `f_right` is applied to its contents, and the\n-     * result is returned.\n-     */\n-\n     match *value {\n       Left(ref l) => f_left(l),\n       Right(ref r) => f_right(r)\n     }\n }\n \n+/// Extracts from a vector of either all the left values\n pub fn lefts<T:Copy,U>(eithers: &[Either<T, U>]) -> ~[T] {\n-    //! Extracts from a vector of either all the left values\n-\n     do vec::build_sized(eithers.len()) |push| {\n         for eithers.each |elt| {\n             match *elt {\n@@ -56,9 +52,8 @@ pub fn lefts<T:Copy,U>(eithers: &[Either<T, U>]) -> ~[T] {\n     }\n }\n \n+/// Extracts from a vector of either all the right values\n pub fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n-    //! Extracts from a vector of either all the right values\n-\n     do vec::build_sized(eithers.len()) |push| {\n         for eithers.each |elt| {\n             match *elt {\n@@ -69,15 +64,11 @@ pub fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n     }\n }\n \n-pub fn partition<T, U>(eithers: ~[Either<T, U>])\n-    -> (~[T], ~[U]) {\n-    /*!\n-     * Extracts from a vector of either all the left values and right values\n-     *\n-     * Returns a structure containing a vector of left values and a vector of\n-     * right values.\n-     */\n-\n+/// Extracts from a vector of either all the left values and right values\n+///\n+/// Returns a structure containing a vector of left values and a vector of\n+/// right values.\n+pub fn partition<T, U>(eithers: ~[Either<T, U>]) -> (~[T], ~[U]) {\n     let mut lefts: ~[T] = ~[];\n     let mut rights: ~[U] = ~[];\n     do vec::consume(eithers) |_i, elt| {\n@@ -89,60 +80,51 @@ pub fn partition<T, U>(eithers: ~[Either<T, U>])\n     return (lefts, rights);\n }\n \n+/// Flips between left and right of a given either\n #[inline(always)]\n pub fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n-    //! Flips between left and right of a given either\n-\n     match eith {\n       Right(r) => Left(r),\n       Left(l) => Right(l)\n     }\n }\n \n+/// Converts either::t to a result::t\n+///\n+/// Converts an `either` type to a `result` type, making the \"right\" choice\n+/// an ok result, and the \"left\" choice a fail\n #[inline(always)]\n-pub fn to_result<T, U>(eith: Either<T, U>)\n-    -> Result<U, T> {\n-    /*!\n-     * Converts either::t to a result::t\n-     *\n-     * Converts an `either` type to a `result` type, making the \"right\" choice\n-     * an ok result, and the \"left\" choice a fail\n-     */\n-\n+pub fn to_result<T, U>(eith: Either<T, U>) -> Result<U, T> {\n     match eith {\n       Right(r) => result::Ok(r),\n       Left(l) => result::Err(l)\n     }\n }\n \n+/// Checks whether the given value is a left\n #[inline(always)]\n pub fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n-    //! Checks whether the given value is a left\n-\n     match *eith { Left(_) => true, _ => false }\n }\n \n+/// Checks whether the given value is a right\n #[inline(always)]\n pub fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n-    //! Checks whether the given value is a right\n-\n     match *eith { Right(_) => true, _ => false }\n }\n \n+/// Retrieves the value in the left branch. Fails if the either is Right.\n #[inline(always)]\n pub fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n-    //! Retrieves the value in the left branch. Fails if the either is Right.\n-\n     match eith {\n         Left(x) => x,\n         Right(_) => fail!(\"either::unwrap_left Right\")\n     }\n }\n \n+/// Retrieves the value in the right branch. Fails if the either is Left.\n #[inline(always)]\n pub fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n-    //! Retrieves the value in the right branch. Fails if the either is Left.\n-\n     match eith {\n         Right(x) => x,\n         Left(_) => fail!(\"either::unwrap_right Left\")"}, {"sha": "ecde1eb19179d3f0a03652a2786837f6ba282698", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60ea6d6957697ac6ced355e8a1db5ab6be439765/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ea6d6957697ac6ced355e8a1db5ab6be439765/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=60ea6d6957697ac6ced355e8a1db5ab6be439765", "patch": "@@ -35,16 +35,16 @@ pub mod raw {\n \n }\n \n+/// Determine if two shared boxes point to the same object\n #[inline(always)]\n pub fn ptr_eq<T>(a: @T, b: @T) -> bool {\n-    //! Determine if two shared boxes point to the same object\n     let a_ptr: *T = to_unsafe_ptr(&*a), b_ptr: *T = to_unsafe_ptr(&*b);\n     a_ptr == b_ptr\n }\n \n+/// Determine if two mutable shared boxes point to the same object\n #[inline(always)]\n pub fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n-    //! Determine if two mutable shared boxes point to the same object\n     let a_ptr: *T = to_unsafe_ptr(&*a), b_ptr: *T = to_unsafe_ptr(&*b);\n     a_ptr == b_ptr\n }"}, {"sha": "e1bd72f67f16f68707ab8d742bdbce7cafd67b72", "filename": "src/libcore/option.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/60ea6d6957697ac6ced355e8a1db5ab6be439765/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ea6d6957697ac6ced355e8a1db5ab6be439765/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=60ea6d6957697ac6ced355e8a1db5ab6be439765", "patch": "@@ -182,34 +182,28 @@ pub impl<T> Option<T> {\n     #[inline(always)]\n     fn is_some(&const self) -> bool { !self.is_none() }\n \n+    /// Update an optional value by optionally running its content through a\n+    /// function that returns an option.\n     #[inline(always)]\n     fn chain<U>(self, f: &fn(t: T) -> Option<U>) -> Option<U> {\n-        /*!\n-         * Update an optional value by optionally running its content through a\n-         * function that returns an option.\n-         */\n \n         match self {\n             Some(t) => f(t),\n             None => None\n         }\n     }\n \n+    /// Returns the leftmost Some() value, or None if both are None.\n     #[inline(always)]\n     fn or(self, optb: Option<T>) -> Option<T> {\n-        /*!\n-         * Returns the leftmost Some() value, or None if both are None.\n-         */\n         match self {\n             Some(opta) => Some(opta),\n             _ => optb\n         }\n     }\n \n-    /**\n-     * Update an optional value by optionally running its content by reference\n-     * through a function that returns an option.\n-     */\n+    /// Update an optional value by optionally running its content by reference\n+    /// through a function that returns an option.\n     #[inline(always)]\n     fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>) -> Option<U> {\n         match *self { Some(ref x) => f(x), None => None }"}]}