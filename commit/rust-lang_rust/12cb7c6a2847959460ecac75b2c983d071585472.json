{"sha": "12cb7c6a2847959460ecac75b2c983d071585472", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyY2I3YzZhMjg0Nzk1OTQ2MGVjYWM3NWIyYzk4M2QwNzE1ODU0NzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-19T00:17:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-19T00:17:00Z"}, "message": "Auto merge of #23482 - alexcrichton:snapshots, r=aturon", "tree": {"sha": "481e99dcf4197b0b25cd765877c1b132f768d772", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/481e99dcf4197b0b25cd765877c1b132f768d772"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12cb7c6a2847959460ecac75b2c983d071585472", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12cb7c6a2847959460ecac75b2c983d071585472", "html_url": "https://github.com/rust-lang/rust/commit/12cb7c6a2847959460ecac75b2c983d071585472", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12cb7c6a2847959460ecac75b2c983d071585472/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94a95067e017252d4928a4292a6aeef66902e694", "url": "https://api.github.com/repos/rust-lang/rust/commits/94a95067e017252d4928a4292a6aeef66902e694", "html_url": "https://github.com/rust-lang/rust/commit/94a95067e017252d4928a4292a6aeef66902e694"}, {"sha": "fccf5a00056b1d72065951a4428070326df1cfb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/fccf5a00056b1d72065951a4428070326df1cfb5", "html_url": "https://github.com/rust-lang/rust/commit/fccf5a00056b1d72065951a4428070326df1cfb5"}], "stats": {"total": 4957, "additions": 993, "deletions": 3964}, "files": [{"sha": "6bdfe2b15516751a6ab860bc74962db9949f943d", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -264,7 +264,6 @@ impl BoxAny for Box<Any> {\n     }\n }\n \n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl BoxAny for Box<Any+Send> {\n     #[inline]"}, {"sha": "aaf6e76237ca5669b7d6266f4b4ff853ed7dfec0", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[cfg(stage0)]\n-#[cfg(not(test))]\n-use core::ptr::PtrExt;\n-\n // FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias`\n \n /// Return a pointer to `size` bytes of memory aligned to `align`."}, {"sha": "855235e89c880041b1510fbf1243191d0074408d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -159,9 +159,6 @@ use core::nonzero::NonZero;\n use core::ops::{Deref, Drop};\n use core::option::Option;\n use core::option::Option::{Some, None};\n-#[cfg(stage0)]\n-use core::ptr::{self, PtrExt};\n-#[cfg(not(stage0))]\n use core::ptr;\n use core::result::Result;\n use core::result::Result::{Ok, Err};"}, {"sha": "1b0356b88b08dcdb9e3bf1a386f67052170b22f1", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -43,12 +43,8 @@ extern crate alloc;\n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::intrinsics;\n-#[cfg(stage0)] // SNAP 270a677\n-use std::intrinsics::{get_tydesc, TyDesc};\n use std::marker;\n use std::mem;\n-#[cfg(stage0)]\n-use std::num::{Int, UnsignedInt};\n use std::ptr;\n use std::rc::Rc;\n use std::rt::heap::{allocate, deallocate};\n@@ -190,14 +186,12 @@ fn un_bitpack_tydesc_ptr(p: usize) -> (*const TyDesc, bool) {\n // HACK(eddyb) TyDesc replacement using a trait object vtable.\n // This could be replaced in the future with a custom DST layout,\n // or `&'static (drop_glue, size, align)` created by a `const fn`.\n-#[cfg(not(stage0))] // SNAP 270a677\n struct TyDesc {\n     drop_glue: fn(*const i8),\n     size: usize,\n     align: usize\n }\n \n-#[cfg(not(stage0))] // SNAP 270a677\n unsafe fn get_tydesc<T>() -> *const TyDesc {\n     use std::raw::TraitObject;\n "}, {"sha": "bfac3b2df5a5cba8cc1a200ed9be1053bea87f53", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -105,9 +105,6 @@ struct MutNodeSlice<'a, K: 'a, V: 'a> {\n /// Fails if `target_alignment` is not a power of two.\n #[inline]\n fn round_up_to_next(unrounded: usize, target_alignment: usize) -> usize {\n-    #[cfg(stage0)]\n-    use core::num::UnsignedInt;\n-\n     assert!(target_alignment.is_power_of_two());\n     (unrounded + target_alignment - 1) & !(target_alignment - 1)\n }"}, {"sha": "5f614f3649ca9fd93f08765b44c46df3002a49ec", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 3, "deletions": 43, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -8,45 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[cfg(stage0)]\n-/// Creates a `Vec` containing the arguments.\n-///\n-/// `vec!` allows `Vec`s to be defined with the same syntax as array expressions.\n-/// There are two forms of this macro:\n-///\n-/// - Create a `Vec` containing a given list of elements:\n-///\n-/// ```\n-/// let v = vec![1, 2, 3];\n-/// assert_eq!(v[0], 1);\n-/// assert_eq!(v[1], 2);\n-/// assert_eq!(v[2], 3);\n-/// ```\n-///\n-/// - Create a `Vec` from a given element and size:\n-///\n-/// ```\n-/// let v = vec![1; 3];\n-/// assert_eq!(v, [1, 1, 1]);\n-/// ```\n-///\n-/// Note that unlike array expressions this syntax supports all elements\n-/// which implement `Clone` and the number of elements doesn't have to be\n-/// a constant.\n-#[macro_export]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-macro_rules! vec {\n-    ($elem:expr; $n:expr) => (\n-        $crate::vec::from_elem($elem, $n)\n-    );\n-    ($($x:expr),*) => (\n-        <[_] as $crate::slice::SliceExt>::into_vec(\n-            $crate::boxed::Box::new([$($x),*]))\n-    );\n-    ($($x:expr,)*) => (vec![$($x),*])\n-}\n-\n-#[cfg(not(stage0))]\n /// Creates a `Vec` containing the arguments.\n ///\n /// `vec!` allows `Vec`s to be defined with the same syntax as array expressions.\n@@ -84,11 +45,10 @@ macro_rules! vec {\n     ($($x:expr,)*) => (vec![$($x),*])\n }\n \n-// HACK(japaric): with cfg(test) the inherent `[T]::into_vec` method, which is required for this\n-// macro definition, is not available. Instead use the `slice::into_vec`  function which is only\n-// available with cfg(test)\n+// HACK(japaric): with cfg(test) the inherent `[T]::into_vec` method, which is\n+// required for this macro definition, is not available. Instead use the\n+// `slice::into_vec`  function which is only available with cfg(test)\n // NB see the slice::hack module in slice.rs for more information\n-#[cfg(not(stage0))]\n #[cfg(test)]\n macro_rules! vec {\n     ($elem:expr; $n:expr) => ("}, {"sha": "45864153dd799598783557075b2e5115be246e79", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 7, "deletions": 973, "changes": 980, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -99,8 +99,6 @@ use core::mem;\n use core::num::wrapping::WrappingOps;\n use core::ops::FnMut;\n use core::option::Option::{self, Some, None};\n-#[cfg(stage0)]\n-use core::ptr::PtrExt;\n use core::ptr;\n use core::result::Result;\n use core::slice as core_slice;\n@@ -121,984 +119,20 @@ pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n // Basic slice extension methods\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[cfg(stage0)]\n-/// Allocating extension methods for slices.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait SliceExt {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Item;\n-\n-    /// Sorts the slice, in place, using `compare` to compare\n-    /// elements.\n-    ///\n-    /// This sort is `O(n log n)` worst-case and stable, but allocates\n-    /// approximately `2 * n`, where `n` is the length of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [5, 4, 1, 3, 2];\n-    /// v.sort_by(|a, b| a.cmp(b));\n-    /// assert!(v == [1, 2, 3, 4, 5]);\n-    ///\n-    /// // reverse sorting\n-    /// v.sort_by(|a, b| b.cmp(a));\n-    /// assert!(v == [5, 4, 3, 2, 1]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n-\n-    /// Consumes `src` and moves as many elements as it can into `self`\n-    /// from the range [start,end).\n-    ///\n-    /// Returns the number of elements copied (the shorter of `self.len()`\n-    /// and `end - start`).\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A mutable vector of `T`\n-    /// * start - The index into `src` to start copying from\n-    /// * end - The index into `src` to stop copying from\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut a = [1, 2, 3, 4, 5];\n-    /// let b = vec![6, 7, 8];\n-    /// let num_moved = a.move_from(b, 0, 3);\n-    /// assert_eq!(num_moved, 3);\n-    /// assert!(a == [6, 7, 8, 4, 5]);\n-    /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"uncertain about this API approach\")]\n-    fn move_from(&mut self, src: Vec<Self::Item>, start: usize, end: usize) -> usize;\n-\n-    /// Deprecated: use `&s[start .. end]` notation instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &s[start .. end] instead\")]\n-    fn slice(&self, start: usize, end: usize) -> &[Self::Item];\n-\n-    /// Deprecated: use `&s[start..]` notation instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &s[start..] instead\")]\n-    fn slice_from(&self, start: usize) -> &[Self::Item];\n-\n-    /// Deprecated: use `&s[..end]` notation instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &s[..end] instead\")]\n-    fn slice_to(&self, end: usize) -> &[Self::Item];\n-\n-    /// Divides one slice into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// Panics if `mid > len`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30, 20, 50];\n-    /// let (v1, v2) = v.split_at(2);\n-    /// assert_eq!([10, 40], v1);\n-    /// assert_eq!([30, 20, 50], v2);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn split_at(&self, mid: usize) -> (&[Self::Item], &[Self::Item]);\n-\n-    /// Returns an iterator over the slice.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn iter(&self) -> Iter<Self::Item>;\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`.  The matched element is not contained in the subslices.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Print the slice split by numbers divisible by 3 (i.e. `[10, 40]`,\n-    /// `[20]`, `[50]`):\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30, 20, 60, 50];\n-    /// for group in v.split(|num| *num % 3 == 0) {\n-    ///     println!(\"{:?}\", group);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn split<F>(&self, pred: F) -> Split<Self::Item, F>\n-                where F: FnMut(&Self::Item) -> bool;\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to splitting at most `n` times.  The matched element is\n-    /// not contained in the subslices.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n-    /// `[20, 60, 50]`):\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30, 20, 60, 50];\n-    /// for group in v.splitn(1, |num| *num % 3 == 0) {\n-    ///     println!(\"{:?}\", group);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn splitn<F>(&self, n: usize, pred: F) -> SplitN<Self::Item, F>\n-                 where F: FnMut(&Self::Item) -> bool;\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to splitting at most `n` times. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n-    /// the subslices.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Print the slice split once, starting from the end, by numbers divisible\n-    /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30, 20, 60, 50];\n-    /// for group in v.rsplitn(1, |num| *num % 3 == 0) {\n-    ///     println!(\"{:?}\", group);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<Self::Item, F>\n-                  where F: FnMut(&Self::Item) -> bool;\n-\n-    /// Returns an iterator over all contiguous windows of length\n-    /// `size`. The windows overlap. If the slice is shorter than\n-    /// `size`, the iterator returns no values.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `size` is 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n-    /// `[3,4]`):\n-    ///\n-    /// ```\n-    /// let v = &[1, 2, 3, 4];\n-    /// for win in v.windows(2) {\n-    ///     println!(\"{:?}\", win);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn windows(&self, size: usize) -> Windows<Self::Item>;\n-\n-    /// Returns an iterator over `size` elements of the slice at a\n-    /// time. The chunks do not overlap. If `size` does not divide the\n-    /// length of the slice, then the last chunk will not have length\n-    /// `size`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `size` is 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Print the slice two elements at a time (i.e. `[1,2]`,\n-    /// `[3,4]`, `[5]`):\n-    ///\n-    /// ```\n-    /// let v = &[1, 2, 3, 4, 5];\n-    /// for win in v.chunks(2) {\n-    ///     println!(\"{:?}\", win);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn chunks(&self, size: usize) -> Chunks<Self::Item>;\n-\n-    /// Returns the element of a slice at the given index, or `None` if the\n-    /// index is out of bounds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(Some(&40), v.get(1));\n-    /// assert_eq!(None, v.get(3));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn get(&self, index: usize) -> Option<&Self::Item>;\n-\n-    /// Returns the first element of a slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(Some(&10), v.first());\n-    ///\n-    /// let w: &[i32] = &[];\n-    /// assert_eq!(None, w.first());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn first(&self) -> Option<&Self::Item>;\n-\n-    /// Returns all but the first element of a slice.\n-    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n-    fn tail(&self) -> &[Self::Item];\n-\n-    /// Returns all but the last element of a slice.\n-    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n-    fn init(&self) -> &[Self::Item];\n-\n-    /// Returns the last element of a slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(Some(&30), v.last());\n-    ///\n-    /// let w: &[i32] = &[];\n-    /// assert_eq!(None, w.last());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn last(&self) -> Option<&Self::Item>;\n-\n-    /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn get_unchecked(&self, index: usize) -> &Self::Item;\n-\n-    /// Returns an unsafe pointer to the slice's buffer\n-    ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the slice may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn as_ptr(&self) -> *const Self::Item;\n-\n-    /// Binary search a sorted slice with a comparator function.\n-    ///\n-    /// The comparator function should implement an order consistent\n-    /// with the sort order of the underlying slice, returning an\n-    /// order code that indicates whether its argument is `Less`,\n-    /// `Equal` or `Greater` the desired target.\n-    ///\n-    /// If a matching value is found then returns `Ok`, containing\n-    /// the index for the matched element; if no match is found then\n-    /// `Err` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n-    ///\n-    /// ```\n-    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n-    ///\n-    /// let seek = 13;\n-    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n-    /// let seek = 4;\n-    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n-    /// let seek = 100;\n-    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n-    /// let seek = 1;\n-    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n-    /// assert!(match r { Ok(1...4) => true, _ => false, });\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn binary_search_by<F>(&self, f: F) -> Result<usize, usize> where\n-        F: FnMut(&Self::Item) -> Ordering;\n-\n-    /// Return the number of elements in the slice\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let a = [1, 2, 3];\n-    /// assert_eq!(a.len(), 3);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len(&self) -> usize;\n-\n-    /// Returns true if the slice has a length of 0\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let a = [1, 2, 3];\n-    /// assert!(!a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_empty(&self) -> bool { self.len() == 0 }\n-    /// Returns a mutable reference to the element at the given index,\n-    /// or `None` if the index is out of bounds\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn get_mut(&mut self, index: usize) -> Option<&mut Self::Item>;\n-\n-    /// Work with `self` as a mut slice.\n-    /// Primarily intended for getting a &mut [T] from a [T; N].\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn as_mut_slice(&mut self) -> &mut [Self::Item];\n-\n-    /// Deprecated: use `&mut s[start .. end]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start .. end] instead\")]\n-    fn slice_mut(&mut self, start: usize, end: usize) -> &mut [Self::Item];\n-\n-    /// Deprecated: use `&mut s[start ..]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start ..] instead\")]\n-    fn slice_from_mut(&mut self, start: usize) -> &mut [Self::Item];\n-\n-    /// Deprecated: use `&mut s[.. end]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[.. end] instead\")]\n-    fn slice_to_mut(&mut self, end: usize) -> &mut [Self::Item];\n-\n-    /// Returns an iterator that allows modifying each value\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn iter_mut(&mut self) -> IterMut<Self::Item>;\n-\n-    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn first_mut(&mut self) -> Option<&mut Self::Item>;\n-\n-    /// Returns all but the first element of a mutable slice\n-    #[unstable(feature = \"collections\",\n-               reason = \"likely to be renamed or removed\")]\n-    fn tail_mut(&mut self) -> &mut [Self::Item];\n-\n-    /// Returns all but the last element of a mutable slice\n-    #[unstable(feature = \"collections\",\n-               reason = \"likely to be renamed or removed\")]\n-    fn init_mut(&mut self) -> &mut [Self::Item];\n-\n-    /// Returns a mutable pointer to the last item in the slice.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn last_mut(&mut self) -> Option<&mut Self::Item>;\n-\n-    /// Returns an iterator over mutable subslices separated by elements that\n-    /// match `pred`.  The matched element is not contained in the subslices.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn split_mut<F>(&mut self, pred: F) -> SplitMut<Self::Item, F>\n-                    where F: FnMut(&Self::Item) -> bool;\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to splitting at most `n` times.  The matched element is\n-    /// not contained in the subslices.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<Self::Item, F>\n-                     where F: FnMut(&Self::Item) -> bool;\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to splitting at most `n` times. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n-    /// the subslices.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rsplitn_mut<F>(&mut self,  n: usize, pred: F) -> RSplitNMut<Self::Item, F>\n-                      where F: FnMut(&Self::Item) -> bool;\n-\n-    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n-    /// The chunks are mutable and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last chunk will not\n-    /// have length `chunk_size`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `chunk_size` is 0.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<Self::Item>;\n-\n-    /// Swaps two elements in a slice.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * a - The index of the first element\n-    /// * b - The index of the second element\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `a` or `b` are out of bounds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n-    /// v.swap(1, 3);\n-    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn swap(&mut self, a: usize, b: usize);\n-\n-    /// Divides one `&mut` into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `mid > len`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [1, 2, 3, 4, 5, 6];\n-    ///\n-    /// // scoped to restrict the lifetime of the borrows\n-    /// {\n-    ///    let (left, right) = v.split_at_mut(0);\n-    ///    assert!(left == []);\n-    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(2);\n-    ///     assert!(left == [1, 2]);\n-    ///     assert!(right == [3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(6);\n-    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == []);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn split_at_mut(&mut self, mid: usize) -> (&mut [Self::Item], &mut [Self::Item]);\n-\n-    /// Reverse the order of elements in a slice, in place.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [1, 2, 3];\n-    /// v.reverse();\n-    /// assert!(v == [3, 2, 1]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn reverse(&mut self);\n-\n-    /// Returns an unsafe mutable pointer to the element in index\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut Self::Item;\n-\n-    /// Return an unsafe mutable pointer to the slice's buffer.\n-    ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the slice may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn as_mut_ptr(&mut self) -> *mut Self::Item;\n-\n-    /// Copies `self` into a new `Vec`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn to_vec(&self) -> Vec<Self::Item> where Self::Item: Clone;\n-\n-    /// Creates an iterator that yields every possible permutation of the\n-    /// vector in succession.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [1, 2, 3];\n-    /// let mut perms = v.permutations();\n-    ///\n-    /// for p in perms {\n-    ///   println!(\"{:?}\", p);\n-    /// }\n-    /// ```\n-    ///\n-    /// Iterating through permutations one by one.\n-    ///\n-    /// ```\n-    /// let v = [1, 2, 3];\n-    /// let mut perms = v.permutations();\n-    ///\n-    /// assert_eq!(Some(vec![1, 2, 3]), perms.next());\n-    /// assert_eq!(Some(vec![1, 3, 2]), perms.next());\n-    /// assert_eq!(Some(vec![3, 1, 2]), perms.next());\n-    /// ```\n-    #[unstable(feature = \"collections\")]\n-    fn permutations(&self) -> Permutations<Self::Item> where Self::Item: Clone;\n-\n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut dst = [0, 0, 0];\n-    /// let src = [1, 2];\n-    ///\n-    /// assert!(dst.clone_from_slice(&src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n-    ///\n-    /// let src2 = [3, 4, 5, 6];\n-    /// assert!(dst.clone_from_slice(&src2) == 3);\n-    /// assert!(dst == [3, 4, 5]);\n-    /// ```\n-    #[unstable(feature = \"collections\")]\n-    fn clone_from_slice(&mut self, &[Self::Item]) -> usize where Self::Item: Clone;\n-\n-    /// Sorts the slice, in place.\n-    ///\n-    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [-5, 4, 1, -3, 2];\n-    ///\n-    /// v.sort();\n-    /// assert!(v == [-5, -3, 1, 2, 4]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sort(&mut self) where Self::Item: Ord;\n-\n-    /// Binary search a sorted slice for a given element.\n-    ///\n-    /// If the value is found then `Ok` is returned, containing the\n-    /// index of the matching element; if the value is not found then\n-    /// `Err` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n-    ///\n-    /// ```\n-    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n-    ///\n-    /// assert_eq!(s.binary_search(&13),  Ok(9));\n-    /// assert_eq!(s.binary_search(&4),   Err(7));\n-    /// assert_eq!(s.binary_search(&100), Err(13));\n-    /// let r = s.binary_search(&1);\n-    /// assert!(match r { Ok(1...4) => true, _ => false, });\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn binary_search(&self, x: &Self::Item) -> Result<usize, usize> where Self::Item: Ord;\n-\n-    /// Deprecated: use `binary_search` instead.\n-    #[unstable(feature = \"collections\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use binary_search instead\")]\n-    fn binary_search_elem(&self, x: &Self::Item) -> Result<usize, usize> where Self::Item: Ord {\n-        self.binary_search(x)\n-    }\n-\n-    /// Mutates the slice to the next lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// last-ordered permutation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v: &mut [_] = &mut [0, 1, 2];\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [0, 2, 1];\n-    /// assert!(v == b);\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [1, 0, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"uncertain if this merits inclusion in std\")]\n-    fn next_permutation(&mut self) -> bool where Self::Item: Ord;\n-\n-    /// Mutates the slice to the previous lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// first-ordered permutation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v: &mut [_] = &mut [1, 0, 2];\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0, 2, 1];\n-    /// assert!(v == b);\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0, 1, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"uncertain if this merits inclusion in std\")]\n-    fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n-\n-    /// Find the first index containing a matching value.\n-    #[unstable(feature = \"collections\")]\n-    fn position_elem(&self, t: &Self::Item) -> Option<usize> where Self::Item: PartialEq;\n-\n-    /// Find the last index containing a matching value.\n-    #[unstable(feature = \"collections\")]\n-    fn rposition_elem(&self, t: &Self::Item) -> Option<usize> where Self::Item: PartialEq;\n-\n-    /// Returns true if the slice contains an element with the given value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert!(v.contains(&30));\n-    /// assert!(!v.contains(&50));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n-\n-    /// Returns true if `needle` is a prefix of the slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert!(v.starts_with(&[10]));\n-    /// assert!(v.starts_with(&[10, 40]));\n-    /// assert!(!v.starts_with(&[50]));\n-    /// assert!(!v.starts_with(&[10, 50]));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n-\n-    /// Returns true if `needle` is a suffix of the slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert!(v.ends_with(&[30]));\n-    /// assert!(v.ends_with(&[40, 30]));\n-    /// assert!(!v.ends_with(&[50]));\n-    /// assert!(!v.ends_with(&[50, 30]));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n-\n-    /// Convert `self` into a vector without clones or allocation.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn into_vec(self: Box<Self>) -> Vec<Self::Item>;\n-}\n-\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> SliceExt for [T] {\n-    type Item = T;\n-\n-    #[inline]\n-    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n-        merge_sort(self, compare)\n-    }\n-\n-    #[inline]\n-    fn move_from(&mut self, mut src: Vec<T>, start: usize, end: usize) -> usize {\n-        for (a, b) in self.iter_mut().zip(src[start .. end].iter_mut()) {\n-            mem::swap(a, b);\n-        }\n-        cmp::min(self.len(), end-start)\n-    }\n-\n-    #[inline]\n-    fn slice(&self, start: usize, end: usize) -> &[T] {\n-        &self[start .. end]\n-    }\n-\n-    #[inline]\n-    fn slice_from(&self, start: usize) -> &[T] {\n-        &self[start ..]\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: usize) -> &[T] {\n-        &self[.. end]\n-    }\n-\n-    #[inline]\n-    fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n-        core_slice::SliceExt::split_at(self, mid)\n-    }\n-\n-    #[inline]\n-    fn iter(&self) -> Iter<T> {\n-        core_slice::SliceExt::iter(self)\n-    }\n-\n-    #[inline]\n-    fn split<F>(&self, pred: F) -> Split<T, F>\n-                where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::split(self, pred)\n-    }\n-\n-    #[inline]\n-    fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F>\n-                 where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::splitn(self, n, pred)\n-    }\n-\n-    #[inline]\n-    fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F>\n-                  where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::rsplitn(self, n, pred)\n-    }\n-\n-    #[inline]\n-    fn windows(&self, size: usize) -> Windows<T> {\n-        core_slice::SliceExt::windows(self, size)\n-    }\n-\n-    #[inline]\n-    fn chunks(&self, size: usize) -> Chunks<T> {\n-        core_slice::SliceExt::chunks(self, size)\n-    }\n-\n-    #[inline]\n-    fn get(&self, index: usize) -> Option<&T> {\n-        core_slice::SliceExt::get(self, index)\n-    }\n-\n-    #[inline]\n-    fn first(&self) -> Option<&T> {\n-        core_slice::SliceExt::first(self)\n-    }\n-\n-    #[inline]\n-    fn tail(&self) -> &[T] {\n-        core_slice::SliceExt::tail(self)\n-    }\n-\n-    #[inline]\n-    fn init(&self) -> &[T] {\n-        core_slice::SliceExt::init(self)\n-    }\n-\n-    #[inline]\n-    fn last(&self) -> Option<&T> {\n-        core_slice::SliceExt::last(self)\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked(&self, index: usize) -> &T {\n-        core_slice::SliceExt::get_unchecked(self, index)\n-    }\n-\n-    #[inline]\n-    fn as_ptr(&self) -> *const T {\n-        core_slice::SliceExt::as_ptr(self)\n-    }\n-\n-    #[inline]\n-    fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>\n-                        where F: FnMut(&T) -> Ordering {\n-        core_slice::SliceExt::binary_search_by(self, f)\n-    }\n-\n-    #[inline]\n-    fn len(&self) -> usize {\n-        core_slice::SliceExt::len(self)\n-    }\n-\n-    #[inline]\n-    fn is_empty(&self) -> bool {\n-        core_slice::SliceExt::is_empty(self)\n-    }\n-\n-    #[inline]\n-    fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n-        core_slice::SliceExt::get_mut(self, index)\n-    }\n-\n-    #[inline]\n-    fn as_mut_slice(&mut self) -> &mut [T] {\n-        core_slice::SliceExt::as_mut_slice(self)\n-    }\n-\n-    #[inline]\n-    fn slice_mut(&mut self, start: usize, end: usize) -> &mut [T] {\n-        &mut self[start .. end]\n-    }\n-\n-    #[inline]\n-    fn slice_from_mut(&mut self, start: usize) -> &mut [T] {\n-        &mut self[start ..]\n-    }\n-\n-    #[inline]\n-    fn slice_to_mut(&mut self, end: usize) -> &mut [T] {\n-        &mut self[.. end]\n-    }\n-\n-    #[inline]\n-    fn iter_mut(&mut self) -> IterMut<T> {\n-        core_slice::SliceExt::iter_mut(self)\n-    }\n-\n-    #[inline]\n-    fn first_mut(&mut self) -> Option<&mut T> {\n-        core_slice::SliceExt::first_mut(self)\n-    }\n-\n-    #[inline]\n-    fn tail_mut(&mut self) -> &mut [T] {\n-        core_slice::SliceExt::tail_mut(self)\n-    }\n-\n-    #[inline]\n-    fn init_mut(&mut self) -> &mut [T] {\n-        core_slice::SliceExt::init_mut(self)\n-    }\n-\n-    #[inline]\n-    fn last_mut(&mut self) -> Option<&mut T> {\n-        core_slice::SliceExt::last_mut(self)\n-    }\n-\n-    #[inline]\n-    fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n-                    where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::split_mut(self, pred)\n-    }\n-\n-    #[inline]\n-    fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n-                     where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::splitn_mut(self, n, pred)\n-    }\n-\n-    #[inline]\n-    fn rsplitn_mut<F>(&mut self,  n: usize, pred: F) -> RSplitNMut<T, F>\n-                      where F: FnMut(&T) -> bool {\n-        core_slice::SliceExt::rsplitn_mut(self, n, pred)\n-    }\n-\n-    #[inline]\n-    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n-        core_slice::SliceExt::chunks_mut(self, chunk_size)\n-    }\n-\n-    #[inline]\n-    fn swap(&mut self, a: usize, b: usize) {\n-        core_slice::SliceExt::swap(self, a, b)\n-    }\n-\n-    #[inline]\n-    fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n-        core_slice::SliceExt::split_at_mut(self, mid)\n-    }\n-\n-    #[inline]\n-    fn reverse(&mut self) {\n-        core_slice::SliceExt::reverse(self)\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T {\n-        core_slice::SliceExt::get_unchecked_mut(self, index)\n-    }\n-\n-    #[inline]\n-    fn as_mut_ptr(&mut self) -> *mut T {\n-        core_slice::SliceExt::as_mut_ptr(self)\n-    }\n-\n-    /// Returns a copy of `v`.\n-    #[inline]\n-    fn to_vec(&self) -> Vec<T> where T: Clone {\n-        let mut vector = Vec::with_capacity(self.len());\n-        vector.push_all(self);\n-        vector\n-    }\n-\n-    /// Returns an iterator over all permutations of a vector.\n-    fn permutations(&self) -> Permutations<T> where T: Clone {\n-        Permutations{\n-            swaps: ElementSwaps::new(self.len()),\n-            v: self.to_vec(),\n-        }\n-    }\n-\n-    fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone {\n-        core_slice::SliceExt::clone_from_slice(self, src)\n-    }\n-\n-    #[inline]\n-    fn sort(&mut self) where T: Ord {\n-        self.sort_by(|a, b| a.cmp(b))\n-    }\n-\n-    fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {\n-        core_slice::SliceExt::binary_search(self, x)\n-    }\n-\n-    fn next_permutation(&mut self) -> bool where T: Ord {\n-        core_slice::SliceExt::next_permutation(self)\n-    }\n-\n-    fn prev_permutation(&mut self) -> bool where T: Ord {\n-        core_slice::SliceExt::prev_permutation(self)\n-    }\n-\n-    fn position_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n-        core_slice::SliceExt::position_elem(self, t)\n-    }\n-\n-    fn rposition_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n-        core_slice::SliceExt::rposition_elem(self, t)\n-    }\n-\n-    fn contains(&self, x: &T) -> bool where T: PartialEq {\n-        core_slice::SliceExt::contains(self, x)\n-    }\n-\n-    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n-        core_slice::SliceExt::starts_with(self, needle)\n-    }\n-\n-    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n-        core_slice::SliceExt::ends_with(self, needle)\n-    }\n-\n-    fn into_vec(mut self: Box<Self>) -> Vec<T> {\n-        unsafe {\n-            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n-            mem::forget(self);\n-            xs\n-        }\n-    }\n-}\n-\n // HACK(japaric) needed for the implementation of `vec!` macro during testing\n // NB see the hack module in this file for more details\n-#[cfg(not(stage0))]\n #[cfg(test)]\n pub use self::hack::into_vec;\n \n // HACK(japaric) needed for the implementation of `Vec::clone` during testing\n // NB see the hack module in this file for more details\n-#[cfg(not(stage0))]\n #[cfg(test)]\n pub use self::hack::to_vec;\n \n-// HACK(japaric): With cfg(test) `impl [T]` is not available, these three functions are actually\n-// methods that are in `impl [T]` but not in `core::slice::SliceExt` - we need to supply these\n-// functions for the `test_permutations` test\n-#[cfg(not(stage0))]\n+// HACK(japaric): With cfg(test) `impl [T]` is not available, these three\n+// functions are actually methods that are in `impl [T]` but not in\n+// `core::slice::SliceExt` - we need to supply these functions for the\n+// `test_permutations` test\n mod hack {\n     use alloc::boxed::Box;\n     use core::clone::Clone;\n@@ -1136,8 +170,9 @@ mod hack {\n         vector\n     }\n \n-    // NB we can remove this hack if we move this test to libcollectionstest - but that can't be\n-    // done right now because the test needs access to the private fields of Permutations\n+    // NB we can remove this hack if we move this test to libcollectionstest -\n+    // but that can't be done right now because the test needs access to the\n+    // private fields of Permutations\n     #[test]\n     fn test_permutations() {\n         {\n@@ -1192,7 +227,6 @@ mod hack {\n     }\n }\n \n-#[cfg(not(stage0))]\n /// Allocating extension methods for slices.\n #[lang = \"slice\"]\n #[cfg(not(test))]"}, {"sha": "3a289e4ef37389b6838671f60aa0109bff6c6fda", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 0, "deletions": 1172, "changes": 1172, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -59,22 +59,14 @@ use self::DecompositionType::*;\n use core::clone::Clone;\n use core::iter::AdditiveIterator;\n use core::iter::{Iterator, IteratorExt, Extend};\n-#[cfg(stage0)]\n-use core::ops::Index;\n-#[cfg(stage0)]\n-use core::ops::RangeFull;\n use core::option::Option::{self, Some, None};\n use core::result::Result;\n use core::slice::AsSlice;\n use core::str as core_str;\n-#[cfg(stage0)]\n-use unicode::char::CharExt;\n use unicode::str::{UnicodeStr, Utf16Encoder};\n \n use vec_deque::VecDeque;\n use borrow::{Borrow, ToOwned};\n-#[cfg(stage0)]\n-use slice::SliceExt;\n use string::String;\n use unicode;\n use vec::Vec;\n@@ -423,1171 +415,7 @@ Section: CowString\n Section: Trait implementations\n */\n \n-#[cfg(stage0)]\n-/// Any string that can be represented as a slice.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait StrExt: Index<RangeFull, Output = str> {\n-    /// Escapes each char in `s` with `char::escape_default`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"return type may change to be an iterator\")]\n-    fn escape_default(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_default()).collect()\n-    }\n-\n-    /// Escapes each char in `s` with `char::escape_unicode`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"return type may change to be an iterator\")]\n-    fn escape_unicode(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_unicode()).collect()\n-    }\n-\n-    /// Replaces all occurrences of one string with another.\n-    ///\n-    /// `replace` takes two arguments, a sub-`&str` to find in `self`, and a second `&str` to\n-    /// replace it with. If the original `&str` isn't found, no change occurs.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"this is old\";\n-    ///\n-    /// assert_eq!(s.replace(\"old\", \"new\"), \"this is new\");\n-    /// ```\n-    ///\n-    /// When a `&str` isn't found:\n-    ///\n-    /// ```\n-    /// let s = \"this is old\";\n-    /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn replace(&self, from: &str, to: &str) -> String {\n-        let mut result = String::new();\n-        let mut last_end = 0;\n-        for (start, end) in self.match_indices(from) {\n-            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n-            result.push_str(to);\n-            last_end = end;\n-        }\n-        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n-        result\n-    }\n-\n-    /// Returns an iterator over the string in Unicode Normalization Form D\n-    /// (canonical decomposition).\n-    #[inline]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    fn nfd_chars(&self) -> Decompositions {\n-        Decompositions {\n-            iter: self[..].chars(),\n-            buffer: Vec::new(),\n-            sorted: false,\n-            kind: Canonical\n-        }\n-    }\n-\n-    /// Returns an iterator over the string in Unicode Normalization Form KD\n-    /// (compatibility decomposition).\n-    #[inline]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    fn nfkd_chars(&self) -> Decompositions {\n-        Decompositions {\n-            iter: self[..].chars(),\n-            buffer: Vec::new(),\n-            sorted: false,\n-            kind: Compatible\n-        }\n-    }\n-\n-    /// An Iterator over the string in Unicode Normalization Form C\n-    /// (canonical decomposition followed by canonical composition).\n-    #[inline]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    fn nfc_chars(&self) -> Recompositions {\n-        Recompositions {\n-            iter: self.nfd_chars(),\n-            state: Composing,\n-            buffer: VecDeque::new(),\n-            composee: None,\n-            last_ccc: None\n-        }\n-    }\n-\n-    /// An Iterator over the string in Unicode Normalization Form KC\n-    /// (compatibility decomposition followed by canonical composition).\n-    #[inline]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    fn nfkc_chars(&self) -> Recompositions {\n-        Recompositions {\n-            iter: self.nfkd_chars(),\n-            state: Composing,\n-            buffer: VecDeque::new(),\n-            composee: None,\n-            last_ccc: None\n-        }\n-    }\n-\n-    /// Returns `true` if `self` contains another `&str`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert!(\"bananas\".contains(\"nana\"));\n-    ///\n-    /// assert!(!\"bananas\".contains(\"foobar\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        core_str::StrExt::contains(&self[..], pat)\n-    }\n-\n-    /// Returns `true` if `self` contains a `char`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert!(\"hello\".contains_char('e'));\n-    ///\n-    /// assert!(!\"hello\".contains_char('z'));\n-    /// ```\n-    #[unstable(feature = \"collections\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use `contains()` with a char\")]\n-    fn contains_char<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        core_str::StrExt::contains_char(&self[..], pat)\n-    }\n-\n-    /// An iterator over the codepoints of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n-    ///\n-    /// assert_eq!(v, ['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn chars(&self) -> Chars {\n-        core_str::StrExt::chars(&self[..])\n-    }\n-\n-    /// An iterator over the bytes of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v: Vec<u8> = \"bors\".bytes().collect();\n-    ///\n-    /// assert_eq!(v, b\"bors\".to_vec());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn bytes(&self) -> Bytes {\n-        core_str::StrExt::bytes(&self[..])\n-    }\n-\n-    /// An iterator over the characters of `self` and their byte offsets.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v: Vec<(usize, char)> = \"abc\".char_indices().collect();\n-    /// let b = vec![(0, 'a'), (1, 'b'), (2, 'c')];\n-    ///\n-    /// assert_eq!(v, b);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn char_indices(&self) -> CharIndices {\n-        core_str::StrExt::char_indices(&self[..])\n-    }\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by a pattern.\n-    ///\n-    /// The pattern can be a simple `&str`, or a closure that determines\n-    /// the split.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple `&str` patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".split('X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    /// ```\n-    ///\n-    /// More complex patterns with a lambda:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n-        core_str::StrExt::split(&self[..], pat)\n-    }\n-\n-    /// An iterator over substrings of `self`, separated by characters matched by a pattern,\n-    /// restricted to splitting at most `count` times.\n-    ///\n-    /// The pattern can be a simple `&str`, or a closure that determines\n-    /// the split.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple `&str` patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abcXdef\".splitn(0, 'X').collect();\n-    /// assert_eq!(v, [\"abcXdef\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    /// ```\n-    ///\n-    /// More complex patterns with a lambda:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, [\"abc\", \"def2ghi\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n-        core_str::StrExt::splitn(&self[..], count, pat)\n-    }\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by a pattern.\n-    ///\n-    /// Equivalent to `split`, except that the trailing substring is skipped if empty.\n-    ///\n-    /// The pattern can be a simple `&str`, or a closure that determines\n-    /// the split.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple `&str` patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n-    /// assert_eq!(v, [\"A\", \"B\"]);\n-    ///\n-    /// let v: Vec<&str> = \"A..B..\".split_terminator('.').collect();\n-    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n-    /// ```\n-    ///\n-    /// More complex patterns with a lambda:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1def2ghi3\".split_terminator(|c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n-        core_str::StrExt::split_terminator(&self[..], pat)\n-    }\n-\n-    /// An iterator over substrings of `self`, separated by characters matched by a pattern,\n-    /// starting from the end of the string.\n-    ///\n-    /// Restricted to splitting at most `count` times.\n-    ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple `&str` patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n-    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n-    /// ```\n-    ///\n-    /// More complex patterns with a lambda:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n-        core_str::StrExt::rsplitn(&self[..], count, pat)\n-    }\n-\n-    /// An iterator over the start and end indices of the disjoint matches of a `&str` within\n-    /// `self`.\n-    ///\n-    /// That is, each returned value `(start, end)` satisfies `self.slice(start, end) == sep`. For\n-    /// matches of `sep` within `self` that overlap, only the indices corresponding to the first\n-    /// match are returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(0,3), (6,9), (12,15)]);\n-    ///\n-    /// let v: Vec<(usize, usize)> = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(1,4), (4,7)]);\n-    ///\n-    /// let v: Vec<(usize, usize)> = \"ababa\".match_indices(\"aba\").collect();\n-    /// assert_eq!(v, [(0, 3)]); // only the first `aba`\n-    /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"might have its iterator type changed\")]\n-    // NB: Right now MatchIndices yields `(usize, usize)`,\n-    // but it would be more consistent and useful to return `(usize, &str)`\n-    fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n-        core_str::StrExt::match_indices(&self[..], pat)\n-    }\n-\n-    /// An iterator over the substrings of `self` separated by a `&str`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, [\"1\", \"\", \"2\"]);\n-    /// ```\n-    #[unstable(feature = \"collections\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use `split()` with a `&str`\")]\n-    #[allow(deprecated) /* for SplitStr */]\n-    fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P> {\n-        core_str::StrExt::split_str(&self[..], pat)\n-    }\n-\n-    /// An iterator over the lines of a string, separated by `\\n`.\n-    ///\n-    /// This does not include the empty string after a trailing `\\n`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let four_lines = \"foo\\nbar\\n\\nbaz\";\n-    /// let v: Vec<&str> = four_lines.lines().collect();\n-    ///\n-    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    ///\n-    /// Leaving off the trailing character:\n-    ///\n-    /// ```\n-    /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n-    /// let v: Vec<&str> = four_lines.lines().collect();\n-    ///\n-    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn lines(&self) -> Lines {\n-        core_str::StrExt::lines(&self[..])\n-    }\n-\n-    /// An iterator over the lines of a string, separated by either `\\n` or `\\r\\n`.\n-    ///\n-    /// As with `.lines()`, this does not include an empty trailing line.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\";\n-    /// let v: Vec<&str> = four_lines.lines_any().collect();\n-    ///\n-    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    ///\n-    /// Leaving off the trailing character:\n-    ///\n-    /// ```\n-    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n-    /// let v: Vec<&str> = four_lines.lines_any().collect();\n-    ///\n-    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn lines_any(&self) -> LinesAny {\n-        core_str::StrExt::lines_any(&self[..])\n-    }\n-\n-    /// Deprecated: use `s[a .. b]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"use slice notation [a..b] instead\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..b] instead\")]\n-    fn slice(&self, begin: usize, end: usize) -> &str;\n-\n-    /// Deprecated: use `s[a..]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"use slice notation [a..b] instead\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..] instead\")]\n-    fn slice_from(&self, begin: usize) -> &str;\n-\n-    /// Deprecated: use `s[..a]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"use slice notation [a..b] instead\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [..a] instead\")]\n-    fn slice_to(&self, end: usize) -> &str;\n-\n-    /// Returns a slice of the string from the character range [`begin`..`end`).\n-    ///\n-    /// That is, start at the `begin`-th code point of the string and continue\n-    /// to the `end`-th code point. This does not detect or handle edge cases\n-    /// such as leaving a combining character as the first code point of the\n-    /// string.\n-    ///\n-    /// Due to the design of UTF-8, this operation is `O(end)`. See `slice`,\n-    /// `slice_to` and `slice_from` for `O(1)` variants that use byte indices\n-    /// rather than code point indices.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `begin` > `end` or the either `begin` or `end` are beyond the\n-    /// last character of the string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n-    /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n-    /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"may have yet to prove its worth\")]\n-    fn slice_chars(&self, begin: usize, end: usize) -> &str {\n-        core_str::StrExt::slice_chars(&self[..], begin, end)\n-    }\n-\n-    /// Takes a bytewise slice from a string.\n-    ///\n-    /// Returns the substring from [`begin`..`end`).\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// Caller must check both UTF-8 character boundaries and the boundaries of\n-    /// the entire slice as well.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(s.slice_unchecked(0, 21), \"L\u00f6we \u8001\u864e L\u00e9opard\");\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        core_str::StrExt::slice_unchecked(&self[..], begin, end)\n-    }\n-\n-    /// Returns `true` if the given `&str` is a prefix of the string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert!(\"banana\".starts_with(\"ba\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        core_str::StrExt::starts_with(&self[..], pat)\n-    }\n-\n-    /// Returns true if the given `&str` is a suffix of the string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert!(\"banana\".ends_with(\"nana\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::ends_with(&self[..], pat)\n-    }\n-\n-    /// Returns a string with all pre- and suffixes that match a pattern repeatedly removed.\n-    ///\n-    /// The pattern can be any `DoubleEndedSearcher`, including a closure that determines the split.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple `char` patterns:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n-    ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n-    /// ```\n-    ///\n-    /// More complex patterns with a lambda:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"123foo1bar123\".trim_matches(|c: char| c.is_numeric()), \"foo1bar\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: DoubleEndedSearcher<'a>\n-    {\n-        core_str::StrExt::trim_matches(&self[..], pat)\n-    }\n-\n-    /// Returns a string with all prefixes that match a pattern repeatedly removed.\n-    ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple `&str` patterns:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n-    ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n-    /// ```\n-    ///\n-    /// More complex patterns with a lambda:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"123foo1bar123\".trim_left_matches(|c: char| c.is_numeric()), \"foo1bar123\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n-        core_str::StrExt::trim_left_matches(&self[..], pat)\n-    }\n-\n-    /// Returns a string with all suffixes that match a pattern repeatedly removed.\n-    ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple `&str` patterns:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n-    /// ```\n-    ///\n-    /// More complex patterns with a lambda:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"123foo1bar123\".trim_right_matches(|c: char| c.is_numeric()), \"123foo1bar\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::trim_right_matches(&self[..], pat)\n-    }\n-\n-    /// Check that `index`-th byte lies at the start and/or end of a UTF-8 code point sequence.\n-    ///\n-    /// The start and end of the string (when `index == self.len()`) are considered to be\n-    /// boundaries.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `index` is greater than `self.len()`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert!(s.is_char_boundary(0));\n-    /// // start of `\u8001`\n-    /// assert!(s.is_char_boundary(6));\n-    /// assert!(s.is_char_boundary(s.len()));\n-    ///\n-    /// // second byte of `\u00f6`\n-    /// assert!(!s.is_char_boundary(2));\n-    ///\n-    /// // third byte of `\u8001`\n-    /// assert!(!s.is_char_boundary(8));\n-    /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"it is unclear whether this method pulls its weight \\\n-                         with the existence of the char_indices iterator or \\\n-                         this method may want to be replaced with checked \\\n-                         slicing\")]\n-    fn is_char_boundary(&self, index: usize) -> bool {\n-        core_str::StrExt::is_char_boundary(&self[..], index)\n-    }\n-\n-    /// Given a byte position, return the next char and its index.\n-    ///\n-    /// This can be used to iterate over the Unicode characters of a string.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n-    ///\n-    /// # Examples\n-    ///\n-    /// This example manually iterates through the characters of a string; this should normally be\n-    /// done by `.chars()` or `.char_indices()`.\n-    ///\n-    /// ```\n-    /// use std::str::CharRange;\n-    ///\n-    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-    /// let mut i = 0;\n-    /// while i < s.len() {\n-    ///     let CharRange {ch, next} = s.char_range_at(i);\n-    ///     println!(\"{}: {}\", i, ch);\n-    ///     i = next;\n-    /// }\n-    /// ```\n-    ///\n-    /// This outputs:\n-    ///\n-    /// ```text\n-    /// 0: \u4e2d\n-    /// 3: \u534e\n-    /// 6: V\n-    /// 7: i\n-    /// 8: \u1ec7\n-    /// 11: t\n-    /// 12:\n-    /// 13: N\n-    /// 14: a\n-    /// 15: m\n-    /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"often replaced by char_indices, this method may \\\n-                         be removed in favor of just char_at() or eventually \\\n-                         removed altogether\")]\n-    fn char_range_at(&self, start: usize) -> CharRange {\n-        core_str::StrExt::char_range_at(&self[..], start)\n-    }\n-\n-    /// Given a byte position, return the previous `char` and its position.\n-    ///\n-    /// This function can be used to iterate over a Unicode string in reverse.\n-    ///\n-    /// Returns 0 for next index if called on start index 0.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than the length of the string.\n-    /// If `i` is not an index following a valid UTF-8 character.\n-    ///\n-    /// # Examples\n-    ///\n-    /// This example manually iterates through the characters of a string; this should normally be\n-    /// done by `.chars().rev()` or `.char_indices()`.\n-    ///\n-    /// ```\n-    /// use std::str::CharRange;\n-    ///\n-    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-    /// let mut i = s.len();\n-    /// while i > 0 {\n-    ///     let CharRange {ch, next} = s.char_range_at_reverse(i);\n-    ///     println!(\"{}: {}\", i, ch);\n-    ///     i = next;\n-    /// }\n-    /// ```\n-    ///\n-    /// This outputs:\n-    ///\n-    /// ```text\n-    /// 16: m\n-    /// 15: a\n-    /// 14: N\n-    /// 13:\n-    /// 12: t\n-    /// 11: \u1ec7\n-    /// 8: i\n-    /// 7: V\n-    /// 6: \u534e\n-    /// 3: \u4e2d\n-    /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"often replaced by char_indices, this method may \\\n-                         be removed in favor of just char_at() or eventually \\\n-                         removed altogether\")]\n-    fn char_range_at_reverse(&self, start: usize) -> CharRange {\n-        core_str::StrExt::char_range_at_reverse(&self[..], start)\n-    }\n-\n-    /// Given a byte position, return the `char` at that position.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"ab\u03c0c\";\n-    /// assert_eq!(s.char_at(1), 'b');\n-    /// assert_eq!(s.char_at(2), '\u03c0');\n-    /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"frequently replaced by the chars() iterator, this \\\n-                         method may be removed or possibly renamed in the \\\n-                         future; it is normally replaced by chars/char_indices \\\n-                         iterators or by getting the first char from a \\\n-                         subslice\")]\n-    fn char_at(&self, i: usize) -> char {\n-        core_str::StrExt::char_at(&self[..], i)\n-    }\n-\n-    /// Given a byte position, return the `char` at that position, counting from the end.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than the length of the string.\n-    /// If `i` is not an index following a valid UTF-8 character.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"ab\u03c0c\";\n-    /// assert_eq!(s.char_at_reverse(1), 'a');\n-    /// assert_eq!(s.char_at_reverse(2), 'b');\n-    /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"see char_at for more details, but reverse semantics \\\n-                         are also somewhat unclear, especially with which \\\n-                         cases generate panics\")]\n-    fn char_at_reverse(&self, i: usize) -> char {\n-        core_str::StrExt::char_at_reverse(&self[..], i)\n-    }\n-\n-    /// Convert `self` to a byte slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn as_bytes(&self) -> &[u8] {\n-        core_str::StrExt::as_bytes(&self[..])\n-    }\n-\n-    /// Returns the byte index of the first character of `self` that matches the pattern, if it\n-    /// exists.\n-    ///\n-    /// Returns `None` if it doesn't exist.\n-    ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple `&str` patterns:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find('L'), Some(0));\n-    /// assert_eq!(s.find('\u00e9'), Some(14));\n-    ///\n-    /// ```\n-    ///\n-    /// More complex patterns with a lambda:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n-    /// ```\n-    ///\n-    /// Not finding the pattern:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let x: &[_] = &['1', '2'];\n-    ///\n-    /// assert_eq!(s.find(x), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n-        core_str::StrExt::find(&self[..], pat)\n-    }\n-\n-    /// Returns the byte index of the last character of `self` that matches the pattern, if it\n-    /// exists.\n-    ///\n-    /// Returns `None` if it doesn't exist.\n-    ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple `&str` patterns:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.rfind('L'), Some(13));\n-    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n-    /// ```\n-    ///\n-    /// More complex patterns with a lambda:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n-    /// ```\n-    ///\n-    /// Not finding the pattern:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let x: &[_] = &['1', '2'];\n-    ///\n-    /// assert_eq!(s.rfind(x), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rfind(&self[..], pat)\n-    }\n-\n-    /// Returns the byte index of the first matching substring if it exists.\n-    ///\n-    /// Returns `None` if it doesn't exist.\n-    ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n-    /// assert_eq!(s.find_str(\"muffin man\"), None);\n-    /// ```\n-    #[unstable(feature = \"collections\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use `find()` with a `&str`\")]\n-    fn find_str<'a, P: Pattern<'a>>(&'a self, needle: P) -> Option<usize> {\n-        core_str::StrExt::find_str(&self[..], needle)\n-    }\n-\n-    /// Retrieves the first character from a `&str` and returns it.\n-    ///\n-    /// This does not allocate a new string; instead, it returns a slice that points one character\n-    /// beyond the character that was shifted.\n-    ///\n-    /// If the slice does not contain any characters, None is returned instead.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let (c, s1) = s.slice_shift_char().unwrap();\n-    ///\n-    /// assert_eq!(c, 'L');\n-    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n-    ///\n-    /// let (c, s2) = s1.slice_shift_char().unwrap();\n-    ///\n-    /// assert_eq!(c, '\u00f6');\n-    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n-    /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"awaiting conventions about shifting and slices and \\\n-                         may not be warranted with the existence of the chars \\\n-                         and/or char_indices iterators\")]\n-    fn slice_shift_char(&self) -> Option<(char, &str)> {\n-        core_str::StrExt::slice_shift_char(&self[..])\n-    }\n-\n-    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `inner` is not a direct slice contained within self.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let string = \"a\\nb\\nc\";\n-    /// let lines: Vec<&str> = string.lines().collect();\n-    ///\n-    /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n-    /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n-    /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n-    /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"awaiting convention about comparability of arbitrary slices\")]\n-    fn subslice_offset(&self, inner: &str) -> usize {\n-        core_str::StrExt::subslice_offset(&self[..], inner)\n-    }\n-\n-    /// Return an unsafe pointer to the `&str`'s buffer.\n-    ///\n-    /// The caller must ensure that the string outlives this pointer, and that it is not\n-    /// reallocated (e.g. by pushing to the string).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"Hello\";\n-    /// let p = s.as_ptr();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn as_ptr(&self) -> *const u8 {\n-        core_str::StrExt::as_ptr(&self[..])\n-    }\n-\n-    /// Return an iterator of `u16` over the string encoded as UTF-16.\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n-    fn utf16_units(&self) -> Utf16Units {\n-        Utf16Units { encoder: Utf16Encoder::new(self[..].chars()) }\n-    }\n-\n-    /// Returns the length of `self` in bytes.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert_eq!(\"foo\".len(), 3);\n-    /// assert_eq!(\"\u0192oo\".len(), 4); // fancy f!\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn len(&self) -> usize {\n-        core_str::StrExt::len(&self[..])\n-    }\n-\n-    /// Returns true if this slice has a length of zero bytes.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert!(\"\".is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_empty(&self) -> bool {\n-        core_str::StrExt::is_empty(&self[..])\n-    }\n-\n-    /// Parses `self` into the specified type.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Will return `Err` if it's not possible to parse `self` into the type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert_eq!(\"4\".parse::<u32>(), Ok(4));\n-    /// ```\n-    ///\n-    /// Failing:\n-    ///\n-    /// ```\n-    /// assert!(\"j\".parse::<u32>().is_err());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n-        core_str::StrExt::parse(&self[..])\n-    }\n-\n-    /// Returns an iterator over the [grapheme clusters][graphemes] of `self`.\n-    ///\n-    /// [graphemes]: http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\n-    ///\n-    /// If `is_extended` is true, the iterator is over the *extended grapheme clusters*;\n-    /// otherwise, the iterator is over the *legacy grapheme clusters*.\n-    /// [UAX#29](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n-    /// recommends extended grapheme cluster boundaries for general processing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let gr1 = \"a\\u{310}e\\u{301}o\\u{308}\\u{332}\".graphemes(true).collect::<Vec<&str>>();\n-    /// let b: &[_] = &[\"a\\u{310}\", \"e\\u{301}\", \"o\\u{308}\\u{332}\"];\n-    ///\n-    /// assert_eq!(gr1.as_slice(), b);\n-    ///\n-    /// let gr2 = \"a\\r\\nb\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\".graphemes(true).collect::<Vec<&str>>();\n-    /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n-    ///\n-    /// assert_eq!(gr2.as_slice(), b);\n-    /// ```\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    fn graphemes(&self, is_extended: bool) -> Graphemes {\n-        UnicodeStr::graphemes(&self[..], is_extended)\n-    }\n-\n-    /// Returns an iterator over the grapheme clusters of `self` and their byte offsets. See\n-    /// `graphemes()` for more information.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n-    /// let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n-    ///\n-    /// assert_eq!(gr_inds.as_slice(), b);\n-    /// ```\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n-        UnicodeStr::grapheme_indices(&self[..], is_extended)\n-    }\n-\n-    /// An iterator over the non-empty words of `self`.\n-    ///\n-    /// A 'word' is a subsequence separated by any sequence of whitespace. Sequences of whitespace\n-    /// are collapsed, so empty \"words\" are not included.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n-    /// let v: Vec<&str> = some_words.words().collect();\n-    ///\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    /// ```\n-    #[unstable(feature = \"str_words\",\n-               reason = \"the precise algorithm to use is unclear\")]\n-    fn words(&self) -> Words {\n-        UnicodeStr::words(&self[..])\n-    }\n-\n-    /// Returns a string's displayed width in columns.\n-    ///\n-    /// Control characters have zero width.\n-    ///\n-    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n-    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n-    /// In CJK locales, `is_cjk` should be `true`, else it should be `false`.\n-    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n-    /// recommends that these characters be treated as 1 column (i.e., `is_cjk =\n-    /// false`) if the locale is unknown.\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    fn width(&self, is_cjk: bool) -> usize {\n-        UnicodeStr::width(&self[..], is_cjk)\n-    }\n-\n-    /// Returns a `&str` with leading and trailing whitespace removed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    /// assert_eq!(s.trim(), \"Hello\\tworld\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trim(&self) -> &str {\n-        UnicodeStr::trim(&self[..])\n-    }\n-\n-    /// Returns a `&str` with leading whitespace removed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    /// assert_eq!(s.trim_left(), \"Hello\\tworld\\t\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trim_left(&self) -> &str {\n-        UnicodeStr::trim_left(&self[..])\n-    }\n-\n-    /// Returns a `&str` with trailing whitespace removed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    /// assert_eq!(s.trim_right(), \" Hello\\tworld\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trim_right(&self) -> &str {\n-        UnicodeStr::trim_right(&self[..])\n-    }\n-\n-    /// Returns the lowercase equivalent of this string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// let s = \"HELLO\";\n-    /// assert_eq!(s.to_lowercase(), \"hello\");\n-    #[unstable(feature = \"collections\")]\n-    fn to_lowercase(&self) -> String {\n-        let mut s = String::with_capacity(self.len());\n-        s.extend(self[..].chars().flat_map(|c| c.to_lowercase()));\n-        return s;\n-    }\n-\n-    /// Returns the uppercase equivalent of this string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// let s = \"hello\";\n-    /// assert_eq!(s.to_uppercase(), \"HELLO\");\n-    #[unstable(feature = \"collections\")]\n-    fn to_uppercase(&self) -> String {\n-        let mut s = String::with_capacity(self.len());\n-        s.extend(self[..].chars().flat_map(|c| c.to_uppercase()));\n-        return s;\n-    }\n-}\n-\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl StrExt for str {\n-    fn slice(&self, begin: usize, end: usize) -> &str {\n-        &self[begin..end]\n-    }\n-\n-    fn slice_from(&self, begin: usize) -> &str {\n-        &self[begin..]\n-    }\n-\n-    fn slice_to(&self, end: usize) -> &str {\n-        &self[..end]\n-    }\n-}\n \n-#[cfg(not(stage0))]\n /// Any string that can be represented as a slice.\n #[lang = \"str\"]\n #[cfg(not(test))]"}, {"sha": "cd6f27bf65f6e5ab2e96fae662080cce247f503e", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -85,23 +85,6 @@ impl String {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    /// Creates a new string buffer from the given string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = String::from_str(\"hello\");\n-    /// assert_eq!(s.as_slice(), \"hello\");\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"needs investigation to see if to_string() can match perf\")]\n-    pub fn from_str(string: &str) -> String {\n-        String { vec: ::slice::SliceExt::to_vec(string.as_bytes()) }\n-    }\n-\n-    #[cfg(not(stage0))]\n     /// Creates a new string buffer from the given string.\n     ///\n     /// # Examples\n@@ -118,9 +101,9 @@ impl String {\n         String { vec: <[_]>::to_vec(string.as_bytes()) }\n     }\n \n-    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is required for this\n-    // method definition, is not available. Since we don't require this method for testing\n-    // purposes, I'll just stub it\n+    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n+    // required for this method definition, is not available. Since we don't\n+    // require this method for testing purposes, I'll just stub it\n     // NB see the slice::hack module in slice.rs for more information\n     #[inline]\n     #[cfg(test)]"}, {"sha": "b0e8dc7d0b6226d004480ffd3d7f85a2b6ff88c8", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -59,8 +59,6 @@ use core::intrinsics::assume;\n use core::iter::{repeat, FromIterator, IntoIterator};\n use core::marker::PhantomData;\n use core::mem;\n-#[cfg(stage0)]\n-use core::num::{Int, UnsignedInt};\n use core::ops::{Index, IndexMut, Deref, Add};\n use core::ops;\n use core::ptr;\n@@ -1283,18 +1281,13 @@ pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n \n #[unstable(feature = \"collections\")]\n impl<T:Clone> Clone for Vec<T> {\n-    #[cfg(stage0)]\n-    fn clone(&self) -> Vec<T> { ::slice::SliceExt::to_vec(&**self) }\n-\n-    #[cfg(not(stage0))]\n     #[cfg(not(test))]\n     fn clone(&self) -> Vec<T> { <[T]>::to_vec(&**self) }\n \n-    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is required for this\n-    // method definition, is not available. Instead use the `slice::to_vec`  function which is only\n-    // available with cfg(test)\n+    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n+    // required for this method definition, is not available. Instead use the\n+    // `slice::to_vec`  function which is only available with cfg(test)\n     // NB see the slice::hack module in slice.rs for more information\n-    #[cfg(not(stage0))]\n     #[cfg(test)]\n     fn clone(&self) -> Vec<T> {\n         ::slice::to_vec(&**self)"}, {"sha": "56ca74dab1f0fd6d040e3b6bb6ed92cb68b4676e", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -25,8 +25,6 @@ use core::default::Default;\n use core::fmt;\n use core::iter::{self, repeat, FromIterator, IntoIterator, RandomAccessIterator};\n use core::mem;\n-#[cfg(stage0)]\n-use core::num::{Int, UnsignedInt};\n use core::num::wrapping::WrappingOps;\n use core::ops::{Index, IndexMut};\n use core::ptr::{self, Unique};"}, {"sha": "3938a610668b7c979046fbf5d763a27a9375be68", "filename": "src/libcore/any.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -155,7 +155,6 @@ impl Any {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl Any+Send {\n     /// Forwards to the method defined on the type `Any`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "1462d07652d08d6f52c1719237b74a4fc23a152b", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -44,26 +44,6 @@\n \n use marker::Sized;\n \n-#[cfg(stage0)] // SNAP 270a677\n-pub type GlueFn = extern \"Rust\" fn(*const i8);\n-\n-#[lang=\"ty_desc\"]\n-#[derive(Copy)]\n-#[cfg(stage0)] // SNAP 270a677\n-pub struct TyDesc {\n-    // sizeof(T)\n-    pub size: usize,\n-\n-    // alignof(T)\n-    pub align: usize,\n-\n-    // Called when a value of type `T` is no longer needed\n-    pub drop_glue: GlueFn,\n-\n-    // Name corresponding to the type\n-    pub name: &'static str,\n-}\n-\n extern \"rust-intrinsic\" {\n \n     // NB: These intrinsics take unsafe pointers because they mutate aliased\n@@ -198,12 +178,8 @@ extern \"rust-intrinsic\" {\n     pub fn min_align_of<T>() -> usize;\n     pub fn pref_align_of<T>() -> usize;\n \n-    /// Get a static pointer to a type descriptor.\n-    #[cfg(stage0)] // SNAP 270a677\n-    pub fn get_tydesc<T: ?Sized>() -> *const TyDesc;\n-\n     /// Gets a static string slice containing the name of a type.\n-    #[cfg(not(stage0))] // SNAP 270a677\n+    #[cfg(not(stage0))]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This"}, {"sha": "156bc2708fb5f338e46a29e2feca4e9c23dcece7", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 954, "deletions": 974, "changes": 1928, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -437,13 +437,19 @@ macro_rules! uint_impl {\n             fn max_value() -> $T { -1 }\n \n             #[inline]\n-            fn count_ones(self) -> u32 { unsafe { $ctpop(self as $ActualT) as u32 } }\n+            fn count_ones(self) -> u32 {\n+                unsafe { $ctpop(self as $ActualT) as u32 }\n+            }\n \n             #[inline]\n-            fn leading_zeros(self) -> u32 { unsafe { $ctlz(self as $ActualT) as u32 } }\n+            fn leading_zeros(self) -> u32 {\n+                unsafe { $ctlz(self as $ActualT) as u32 }\n+            }\n \n             #[inline]\n-            fn trailing_zeros(self) -> u32 { unsafe { $cttz(self as $ActualT) as u32 } }\n+            fn trailing_zeros(self) -> u32 {\n+                unsafe { $cttz(self as $ActualT) as u32 }\n+            }\n \n             #[inline]\n             fn rotate_left(self, n: u32) -> $T {\n@@ -460,7 +466,9 @@ macro_rules! uint_impl {\n             }\n \n             #[inline]\n-            fn swap_bytes(self) -> $T { unsafe { $bswap(self as $ActualT) as $T } }\n+            fn swap_bytes(self) -> $T {\n+                unsafe { $bswap(self as $ActualT) as $T }\n+            }\n \n             #[inline]\n             fn checked_add(self, other: $T) -> Option<$T> {\n@@ -571,19 +579,29 @@ macro_rules! int_impl {\n             fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n \n             #[inline]\n-            fn leading_zeros(self) -> u32 { (self as $UnsignedT).leading_zeros() }\n+            fn leading_zeros(self) -> u32 {\n+                (self as $UnsignedT).leading_zeros()\n+            }\n \n             #[inline]\n-            fn trailing_zeros(self) -> u32 { (self as $UnsignedT).trailing_zeros() }\n+            fn trailing_zeros(self) -> u32 {\n+                (self as $UnsignedT).trailing_zeros()\n+            }\n \n             #[inline]\n-            fn rotate_left(self, n: u32) -> $T { (self as $UnsignedT).rotate_left(n) as $T }\n+            fn rotate_left(self, n: u32) -> $T {\n+                (self as $UnsignedT).rotate_left(n) as $T\n+            }\n \n             #[inline]\n-            fn rotate_right(self, n: u32) -> $T { (self as $UnsignedT).rotate_right(n) as $T }\n+            fn rotate_right(self, n: u32) -> $T {\n+                (self as $UnsignedT).rotate_right(n) as $T\n+            }\n \n             #[inline]\n-            fn swap_bytes(self) -> $T { (self as $UnsignedT).swap_bytes() as $T }\n+            fn swap_bytes(self) -> $T {\n+                (self as $UnsignedT).swap_bytes() as $T\n+            }\n \n             #[inline]\n             fn checked_add(self, other: $T) -> Option<$T> {\n@@ -708,1043 +726,1005 @@ signed_int_impl! { i32 }\n signed_int_impl! { i64 }\n signed_int_impl! { int }\n \n-#[cfg(stage0)]\n-/// A built-in unsigned integer.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait UnsignedInt: Int + WrappingOps {\n-    /// Returns `true` iff `self == 2^k` for some `k`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn is_power_of_two(self) -> bool {\n-        (self.wrapping_sub(Int::one())) & self == Int::zero() && !(self == Int::zero())\n-    }\n-\n-    /// Returns the smallest power of two greater than or equal to `self`.\n-    /// Unspecified behavior on overflow.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn next_power_of_two(self) -> Self {\n-        let bits = size_of::<Self>() * 8;\n-        let one: Self = Int::one();\n-        one << ((bits - self.wrapping_sub(one).leading_zeros() as usize) % bits)\n-    }\n-\n-    /// Returns the smallest power of two greater than or equal to `n`. If the\n-    /// next power of two is greater than the type's maximum value, `None` is\n-    /// returned, otherwise the power of two is wrapped in `Some`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn checked_next_power_of_two(self) -> Option<Self> {\n-        let npot = self.next_power_of_two();\n-        if npot >= self {\n-            Some(npot)\n-        } else {\n-            None\n+// `Int` + `SignedInt` implemented for signed integers\n+macro_rules! int_impl {\n+    ($T:ty = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n+     $add_with_overflow:path,\n+     $sub_with_overflow:path,\n+     $mul_with_overflow:path) => {\n+        /// Returns the `0` value of this integer type.\n+        // FIXME (#5527): Should be an associated constant\n+        #[unstable(feature = \"core\",\n+                   reason = \"unsure about its place in the world\")]\n+        #[inline]\n+        pub fn zero() -> $T { 0 }\n+\n+        /// Returns the `1` value of this integer type.\n+        // FIXME (#5527): Should be an associated constant\n+        #[unstable(feature = \"core\",\n+                   reason = \"unsure about its place in the world\")]\n+        #[inline]\n+        pub fn one() -> $T { 1 }\n+\n+        /// Returns the smallest value that can be represented by this integer\n+        /// type.\n+        // FIXME (#5527): Should be and associated constant\n+        #[unstable(feature = \"core\",\n+                   reason = \"unsure about its place in the world\")]\n+        #[inline]\n+        pub fn min_value() -> $T { (-1 as $T) << ($BITS - 1) }\n+\n+        /// Returns the largest value that can be represented by this integer\n+        /// type.\n+        // FIXME (#5527): Should be and associated constant\n+        #[unstable(feature = \"core\",\n+                   reason = \"unsure about its place in the world\")]\n+        #[inline]\n+        pub fn max_value() -> $T { let min: $T = <$T>::min_value(); !min }\n+\n+        /// Returns the number of ones in the binary representation of `self`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0b01001100u8;\n+        ///\n+        /// assert_eq!(n.count_ones(), 3);\n+        /// ```\n+        #[unstable(feature = \"core\",\n+                   reason = \"pending integer conventions\")]\n+        #[inline]\n+        pub fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n+\n+        /// Returns the number of zeros in the binary representation of `self`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0b01001100u8;\n+        ///\n+        /// assert_eq!(n.count_zeros(), 5);\n+        /// ```\n+        #[unstable(feature = \"core\",\n+                   reason = \"pending integer conventions\")]\n+        #[inline]\n+        pub fn count_zeros(self) -> u32 {\n+            (!self).count_ones()\n         }\n-    }\n-}\n-\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl UnsignedInt for uint {}\n-\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl UnsignedInt for u8 {}\n-\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl UnsignedInt for u16 {}\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl UnsignedInt for u32 {}\n-\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl UnsignedInt for u64 {}\n-\n-// NB(japaric) I added this module to avoid adding several `cfg(not(stage0))`, and avoid name\n-// clashes between macros. We should move all the items inside this module into the outer scope\n-// once the `Int` trait is removed\n-#[cfg(not(stage0))]\n-mod inherent {\n-    use intrinsics;\n-    use mem::size_of;\n-    use option::Option::{self, Some, None};\n-\n-    use super::wrapping::{OverflowingOps, WrappingOps};\n-\n-    // `Int` + `SignedInt` implemented for signed integers\n-    macro_rules! int_impl {\n-        ($T:ty = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n-         $add_with_overflow:path,\n-         $sub_with_overflow:path,\n-         $mul_with_overflow:path) => {\n-            /// Returns the `0` value of this integer type.\n-            // FIXME (#5527): Should be an associated constant\n-            #[unstable(feature = \"core\",\n-                       reason = \"unsure about its place in the world\")]\n-            #[inline]\n-            pub fn zero() -> $T { 0 }\n-\n-            /// Returns the `1` value of this integer type.\n-            // FIXME (#5527): Should be an associated constant\n-            #[unstable(feature = \"core\",\n-                       reason = \"unsure about its place in the world\")]\n-            #[inline]\n-            pub fn one() -> $T { 1 }\n-\n-            /// Returns the smallest value that can be represented by this integer type.\n-            // FIXME (#5527): Should be and associated constant\n-            #[unstable(feature = \"core\",\n-                       reason = \"unsure about its place in the world\")]\n-            #[inline]\n-            pub fn min_value() -> $T { (-1 as $T) << ($BITS - 1) }\n-\n-            /// Returns the largest value that can be represented by this integer type.\n-            // FIXME (#5527): Should be and associated constant\n-            #[unstable(feature = \"core\",\n-                       reason = \"unsure about its place in the world\")]\n-            #[inline]\n-            pub fn max_value() -> $T { let min: $T = <$T>::min_value(); !min }\n-\n-            /// Returns the number of ones in the binary representation of `self`.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0b01001100u8;\n-            ///\n-            /// assert_eq!(n.count_ones(), 3);\n-            /// ```\n-            #[unstable(feature = \"core\",\n-                       reason = \"pending integer conventions\")]\n-            #[inline]\n-            pub fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n-\n-            /// Returns the number of zeros in the binary representation of `self`.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0b01001100u8;\n-            ///\n-            /// assert_eq!(n.count_zeros(), 5);\n-            /// ```\n-            #[unstable(feature = \"core\",\n-                       reason = \"pending integer conventions\")]\n-            #[inline]\n-            pub fn count_zeros(self) -> u32 {\n-                (!self).count_ones()\n-            }\n-\n-            /// Returns the number of leading zeros in the binary representation\n-            /// of `self`.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0b0101000u16;\n-            ///\n-            /// assert_eq!(n.leading_zeros(), 10);\n-            /// ```\n-            #[unstable(feature = \"core\",\n-                       reason = \"pending integer conventions\")]\n-            #[inline]\n-            pub fn leading_zeros(self) -> u32 { (self as $UnsignedT).leading_zeros() }\n+        /// Returns the number of leading zeros in the binary representation\n+        /// of `self`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0b0101000u16;\n+        ///\n+        /// assert_eq!(n.leading_zeros(), 10);\n+        /// ```\n+        #[unstable(feature = \"core\",\n+                   reason = \"pending integer conventions\")]\n+        #[inline]\n+        pub fn leading_zeros(self) -> u32 {\n+            (self as $UnsignedT).leading_zeros()\n+        }\n \n-            /// Returns the number of trailing zeros in the binary representation\n-            /// of `self`.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0b0101000u16;\n-            ///\n-            /// assert_eq!(n.trailing_zeros(), 3);\n-            /// ```\n-            #[unstable(feature = \"core\",\n-                       reason = \"pending integer conventions\")]\n-            #[inline]\n-            pub fn trailing_zeros(self) -> u32 { (self as $UnsignedT).trailing_zeros() }\n+        /// Returns the number of trailing zeros in the binary representation\n+        /// of `self`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0b0101000u16;\n+        ///\n+        /// assert_eq!(n.trailing_zeros(), 3);\n+        /// ```\n+        #[unstable(feature = \"core\",\n+                   reason = \"pending integer conventions\")]\n+        #[inline]\n+        pub fn trailing_zeros(self) -> u32 {\n+            (self as $UnsignedT).trailing_zeros()\n+        }\n \n-            /// Shifts the bits to the left by a specified amount amount, `n`, wrapping\n-            /// the truncated bits to the end of the resulting integer.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0x0123456789ABCDEFu64;\n-            /// let m = 0x3456789ABCDEF012u64;\n-            ///\n-            /// assert_eq!(n.rotate_left(12), m);\n-            /// ```\n-            #[unstable(feature = \"core\",\n-                       reason = \"pending integer conventions\")]\n-            #[inline]\n-            pub fn rotate_left(self, n: u32) -> $T { (self as $UnsignedT).rotate_left(n) as $T }\n+        /// Shifts the bits to the left by a specified amount amount, `n`,\n+        /// wrapping the truncated bits to the end of the resulting integer.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0x0123456789ABCDEFu64;\n+        /// let m = 0x3456789ABCDEF012u64;\n+        ///\n+        /// assert_eq!(n.rotate_left(12), m);\n+        /// ```\n+        #[unstable(feature = \"core\",\n+                   reason = \"pending integer conventions\")]\n+        #[inline]\n+        pub fn rotate_left(self, n: u32) -> $T {\n+            (self as $UnsignedT).rotate_left(n) as $T\n+        }\n \n-            /// Shifts the bits to the right by a specified amount amount, `n`, wrapping\n-            /// the truncated bits to the beginning of the resulting integer.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0x0123456789ABCDEFu64;\n-            /// let m = 0xDEF0123456789ABCu64;\n-            ///\n-            /// assert_eq!(n.rotate_right(12), m);\n-            /// ```\n-            #[unstable(feature = \"core\",\n-                       reason = \"pending integer conventions\")]\n-            #[inline]\n-            pub fn rotate_right(self, n: u32) -> $T { (self as $UnsignedT).rotate_right(n) as $T }\n+        /// Shifts the bits to the right by a specified amount amount, `n`,\n+        /// wrapping the truncated bits to the beginning of the resulting\n+        /// integer.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0x0123456789ABCDEFu64;\n+        /// let m = 0xDEF0123456789ABCu64;\n+        ///\n+        /// assert_eq!(n.rotate_right(12), m);\n+        /// ```\n+        #[unstable(feature = \"core\",\n+                   reason = \"pending integer conventions\")]\n+        #[inline]\n+        pub fn rotate_right(self, n: u32) -> $T {\n+            (self as $UnsignedT).rotate_right(n) as $T\n+        }\n \n-            /// Reverses the byte order of the integer.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0x0123456789ABCDEFu64;\n-            /// let m = 0xEFCDAB8967452301u64;\n-            ///\n-            /// assert_eq!(n.swap_bytes(), m);\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn swap_bytes(self) -> $T { (self as $UnsignedT).swap_bytes() as $T }\n+        /// Reverses the byte order of the integer.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0x0123456789ABCDEFu64;\n+        /// let m = 0xEFCDAB8967452301u64;\n+        ///\n+        /// assert_eq!(n.swap_bytes(), m);\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn swap_bytes(self) -> $T {\n+            (self as $UnsignedT).swap_bytes() as $T\n+        }\n \n-            /// Convert an integer from big endian to the target's endianness.\n-            ///\n-            /// On big endian this is a no-op. On little endian the bytes are swapped.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0x0123456789ABCDEFu64;\n-            ///\n-            /// if cfg!(target_endian = \"big\") {\n-            ///     assert_eq!(Int::from_be(n), n)\n-            /// } else {\n-            ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n-            /// }\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn from_be(x: $T) -> $T {\n-                if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n-            }\n+        /// Convert an integer from big endian to the target's endianness.\n+        ///\n+        /// On big endian this is a no-op. On little endian the bytes are\n+        /// swapped.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0x0123456789ABCDEFu64;\n+        ///\n+        /// if cfg!(target_endian = \"big\") {\n+        ///     assert_eq!(Int::from_be(n), n)\n+        /// } else {\n+        ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n+        /// }\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn from_be(x: $T) -> $T {\n+            if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n+        }\n \n-            /// Convert an integer from little endian to the target's endianness.\n-            ///\n-            /// On little endian this is a no-op. On big endian the bytes are swapped.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0x0123456789ABCDEFu64;\n-            ///\n-            /// if cfg!(target_endian = \"little\") {\n-            ///     assert_eq!(Int::from_le(n), n)\n-            /// } else {\n-            ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n-            /// }\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn from_le(x: $T) -> $T {\n-                if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n-            }\n+        /// Convert an integer from little endian to the target's endianness.\n+        ///\n+        /// On little endian this is a no-op. On big endian the bytes are\n+        /// swapped.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0x0123456789ABCDEFu64;\n+        ///\n+        /// if cfg!(target_endian = \"little\") {\n+        ///     assert_eq!(Int::from_le(n), n)\n+        /// } else {\n+        ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n+        /// }\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn from_le(x: $T) -> $T {\n+            if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n+        }\n \n-            /// Convert `self` to big endian from the target's endianness.\n-            ///\n-            /// On big endian this is a no-op. On little endian the bytes are swapped.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0x0123456789ABCDEFu64;\n-            ///\n-            /// if cfg!(target_endian = \"big\") {\n-            ///     assert_eq!(n.to_be(), n)\n-            /// } else {\n-            ///     assert_eq!(n.to_be(), n.swap_bytes())\n-            /// }\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn to_be(self) -> $T { // or not to be?\n-                if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n-            }\n+        /// Convert `self` to big endian from the target's endianness.\n+        ///\n+        /// On big endian this is a no-op. On little endian the bytes are\n+        /// swapped.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0x0123456789ABCDEFu64;\n+        ///\n+        /// if cfg!(target_endian = \"big\") {\n+        ///     assert_eq!(n.to_be(), n)\n+        /// } else {\n+        ///     assert_eq!(n.to_be(), n.swap_bytes())\n+        /// }\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn to_be(self) -> $T { // or not to be?\n+            if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n+        }\n \n-            /// Convert `self` to little endian from the target's endianness.\n-            ///\n-            /// On little endian this is a no-op. On big endian the bytes are swapped.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0x0123456789ABCDEFu64;\n-            ///\n-            /// if cfg!(target_endian = \"little\") {\n-            ///     assert_eq!(n.to_le(), n)\n-            /// } else {\n-            ///     assert_eq!(n.to_le(), n.swap_bytes())\n-            /// }\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn to_le(self) -> $T {\n-                if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n-            }\n+        /// Convert `self` to little endian from the target's endianness.\n+        ///\n+        /// On little endian this is a no-op. On big endian the bytes are\n+        /// swapped.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0x0123456789ABCDEFu64;\n+        ///\n+        /// if cfg!(target_endian = \"little\") {\n+        ///     assert_eq!(n.to_le(), n)\n+        /// } else {\n+        ///     assert_eq!(n.to_le(), n.swap_bytes())\n+        /// }\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn to_le(self) -> $T {\n+            if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n+        }\n \n-            /// Checked integer addition. Computes `self + other`, returning `None` if\n-            /// overflow occurred.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// assert_eq!(5u16.checked_add(65530), Some(65535));\n-            /// assert_eq!(6u16.checked_add(65530), None);\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn checked_add(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $add_with_overflow, self, other)\n-            }\n+        /// Checked integer addition. Computes `self + other`, returning `None`\n+        /// if overflow occurred.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// assert_eq!(5u16.checked_add(65530), Some(65535));\n+        /// assert_eq!(6u16.checked_add(65530), None);\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn checked_add(self, other: $T) -> Option<$T> {\n+            checked_op!($T, $ActualT, $add_with_overflow, self, other)\n+        }\n \n-            /// Checked integer subtraction. Computes `self - other`, returning `None`\n-            /// if underflow occurred.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n-            /// assert_eq!((-128i8).checked_sub(1), None);\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn checked_sub(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n-            }\n+        /// Checked integer subtraction. Computes `self - other`, returning\n+        /// `None` if underflow occurred.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n+        /// assert_eq!((-128i8).checked_sub(1), None);\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn checked_sub(self, other: $T) -> Option<$T> {\n+            checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n+        }\n \n-            /// Checked integer multiplication. Computes `self * other`, returning\n-            /// `None` if underflow or overflow occurred.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// assert_eq!(5u8.checked_mul(51), Some(255));\n-            /// assert_eq!(5u8.checked_mul(52), None);\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn checked_mul(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n-            }\n+        /// Checked integer multiplication. Computes `self * other`, returning\n+        /// `None` if underflow or overflow occurred.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// assert_eq!(5u8.checked_mul(51), Some(255));\n+        /// assert_eq!(5u8.checked_mul(52), None);\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn checked_mul(self, other: $T) -> Option<$T> {\n+            checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n+        }\n \n-            /// Checked integer division. Computes `self / other`, returning `None` if\n-            /// `other == 0` or the operation results in underflow or overflow.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// assert_eq!((-127i8).checked_div(-1), Some(127));\n-            /// assert_eq!((-128i8).checked_div(-1), None);\n-            /// assert_eq!((1i8).checked_div(0), None);\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn checked_div(self, v: $T) -> Option<$T> {\n-                match v {\n-                    0   => None,\n-                   -1 if self == <$T>::min_value()\n-                        => None,\n-                    v   => Some(self / v),\n-                }\n+        /// Checked integer division. Computes `self / other`, returning `None`\n+        /// if `other == 0` or the operation results in underflow or overflow.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// assert_eq!((-127i8).checked_div(-1), Some(127));\n+        /// assert_eq!((-128i8).checked_div(-1), None);\n+        /// assert_eq!((1i8).checked_div(0), None);\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn checked_div(self, v: $T) -> Option<$T> {\n+            match v {\n+                0   => None,\n+               -1 if self == <$T>::min_value()\n+                    => None,\n+                v   => Some(self / v),\n             }\n+        }\n \n-            /// Saturating integer addition. Computes `self + other`, saturating at\n-            /// the numeric bounds instead of overflowing.\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn saturating_add(self, other: $T) -> $T {\n-                match self.checked_add(other) {\n-                    Some(x)                       => x,\n-                    None if other >= <$T>::zero() => <$T>::max_value(),\n-                    None                          => <$T>::min_value(),\n-                }\n+        /// Saturating integer addition. Computes `self + other`, saturating at\n+        /// the numeric bounds instead of overflowing.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn saturating_add(self, other: $T) -> $T {\n+            match self.checked_add(other) {\n+                Some(x)                       => x,\n+                None if other >= <$T>::zero() => <$T>::max_value(),\n+                None                          => <$T>::min_value(),\n             }\n+        }\n \n-            /// Saturating integer subtraction. Computes `self - other`, saturating at\n-            /// the numeric bounds instead of overflowing.\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn saturating_sub(self, other: $T) -> $T {\n-                match self.checked_sub(other) {\n-                    Some(x)                      => x,\n-                    None if other >= <$T>::zero() => <$T>::min_value(),\n-                    None                          => <$T>::max_value(),\n-                }\n+        /// Saturating integer subtraction. Computes `self - other`, saturating\n+        /// at the numeric bounds instead of overflowing.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn saturating_sub(self, other: $T) -> $T {\n+            match self.checked_sub(other) {\n+                Some(x)                      => x,\n+                None if other >= <$T>::zero() => <$T>::min_value(),\n+                None                          => <$T>::max_value(),\n             }\n+        }\n \n-            /// Raises self to the power of `exp`, using exponentiation by squaring.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// assert_eq!(2.pow(4), 16);\n-            /// ```\n-            #[unstable(feature = \"core\",\n-                       reason = \"pending integer conventions\")]\n-            #[inline]\n-            pub fn pow(self, mut exp: u32) -> $T {\n-                let mut base = self;\n-                let mut acc = <$T>::one();\n-\n-                let mut prev_base = self;\n-                let mut base_oflo = false;\n-                while exp > 0 {\n-                    if (exp & 1) == 1 {\n-                        if base_oflo {\n-                            // ensure overflow occurs in the same manner it\n-                            // would have otherwise (i.e. signal any exception\n-                            // it would have otherwise).\n-                            acc = acc * (prev_base * prev_base);\n-                        } else {\n-                            acc = acc * base;\n-                        }\n+        /// Raises self to the power of `exp`, using exponentiation by squaring.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// assert_eq!(2.pow(4), 16);\n+        /// ```\n+        #[unstable(feature = \"core\",\n+                   reason = \"pending integer conventions\")]\n+        #[inline]\n+        pub fn pow(self, mut exp: u32) -> $T {\n+            let mut base = self;\n+            let mut acc = <$T>::one();\n+\n+            let mut prev_base = self;\n+            let mut base_oflo = false;\n+            while exp > 0 {\n+                if (exp & 1) == 1 {\n+                    if base_oflo {\n+                        // ensure overflow occurs in the same manner it\n+                        // would have otherwise (i.e. signal any exception\n+                        // it would have otherwise).\n+                        acc = acc * (prev_base * prev_base);\n+                    } else {\n+                        acc = acc * base;\n                     }\n-                    prev_base = base;\n-                    let (new_base, new_base_oflo) = base.overflowing_mul(base);\n-                    base = new_base;\n-                    base_oflo = new_base_oflo;\n-                    exp /= 2;\n                 }\n-                acc\n+                prev_base = base;\n+                let (new_base, new_base_oflo) = base.overflowing_mul(base);\n+                base = new_base;\n+                base_oflo = new_base_oflo;\n+                exp /= 2;\n             }\n+            acc\n+        }\n \n-            /// Computes the absolute value of `self`. `Int::min_value()` will be\n-            /// returned if the number is `Int::min_value()`.\n-            #[unstable(feature = \"core\", reason = \"overflow in debug builds?\")]\n-            #[inline]\n-            pub fn abs(self) -> $T {\n-                if self.is_negative() { -self } else { self }\n-            }\n+        /// Computes the absolute value of `self`. `Int::min_value()` will be\n+        /// returned if the number is `Int::min_value()`.\n+        #[unstable(feature = \"core\", reason = \"overflow in debug builds?\")]\n+        #[inline]\n+        pub fn abs(self) -> $T {\n+            if self.is_negative() { -self } else { self }\n+        }\n \n-            /// Returns a number representing sign of `self`.\n-            ///\n-            /// - `0` if the number is zero\n-            /// - `1` if the number is positive\n-            /// - `-1` if the number is negative\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn signum(self) -> $T {\n-                match self {\n-                    n if n > 0 =>  1,\n-                    0          =>  0,\n-                    _          => -1,\n-                }\n+        /// Returns a number representing sign of `self`.\n+        ///\n+        /// - `0` if the number is zero\n+        /// - `1` if the number is positive\n+        /// - `-1` if the number is negative\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn signum(self) -> $T {\n+            match self {\n+                n if n > 0 =>  1,\n+                0          =>  0,\n+                _          => -1,\n             }\n+        }\n \n-            /// Returns `true` if `self` is positive and `false` if the number\n-            /// is zero or negative.\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn is_positive(self) -> bool { self > 0 }\n+        /// Returns `true` if `self` is positive and `false` if the number\n+        /// is zero or negative.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn is_positive(self) -> bool { self > 0 }\n \n-            /// Returns `true` if `self` is negative and `false` if the number\n-            /// is zero or positive.\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn is_negative(self) -> bool { self < 0 }\n-        }\n+        /// Returns `true` if `self` is negative and `false` if the number\n+        /// is zero or positive.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn is_negative(self) -> bool { self < 0 }\n     }\n+}\n \n-    #[lang = \"i8\"]\n-    impl i8 {\n-        int_impl! { i8 = i8, u8, 8,\n-            intrinsics::i8_add_with_overflow,\n-            intrinsics::i8_sub_with_overflow,\n-            intrinsics::i8_mul_with_overflow }\n-    }\n+#[lang = \"i8\"]\n+impl i8 {\n+    int_impl! { i8 = i8, u8, 8,\n+        intrinsics::i8_add_with_overflow,\n+        intrinsics::i8_sub_with_overflow,\n+        intrinsics::i8_mul_with_overflow }\n+}\n \n-    #[lang = \"i16\"]\n-    impl i16 {\n-        int_impl! { i16 = i16, u16, 16,\n-            intrinsics::i16_add_with_overflow,\n-            intrinsics::i16_sub_with_overflow,\n-            intrinsics::i16_mul_with_overflow }\n-    }\n+#[lang = \"i16\"]\n+impl i16 {\n+    int_impl! { i16 = i16, u16, 16,\n+        intrinsics::i16_add_with_overflow,\n+        intrinsics::i16_sub_with_overflow,\n+        intrinsics::i16_mul_with_overflow }\n+}\n \n-    #[lang = \"i32\"]\n-    impl i32 {\n-        int_impl! { i32 = i32, u32, 32,\n-            intrinsics::i32_add_with_overflow,\n-            intrinsics::i32_sub_with_overflow,\n-            intrinsics::i32_mul_with_overflow }\n-    }\n+#[lang = \"i32\"]\n+impl i32 {\n+    int_impl! { i32 = i32, u32, 32,\n+        intrinsics::i32_add_with_overflow,\n+        intrinsics::i32_sub_with_overflow,\n+        intrinsics::i32_mul_with_overflow }\n+}\n \n-    #[lang = \"i64\"]\n-    impl i64 {\n-        int_impl! { i64 = i64, u64, 64,\n-            intrinsics::i64_add_with_overflow,\n-            intrinsics::i64_sub_with_overflow,\n-            intrinsics::i64_mul_with_overflow }\n-    }\n+#[lang = \"i64\"]\n+impl i64 {\n+    int_impl! { i64 = i64, u64, 64,\n+        intrinsics::i64_add_with_overflow,\n+        intrinsics::i64_sub_with_overflow,\n+        intrinsics::i64_mul_with_overflow }\n+}\n \n-    #[cfg(target_pointer_width = \"32\")]\n-    #[lang = \"isize\"]\n-    impl isize {\n-        int_impl! { int = i32, u32, 32,\n-            intrinsics::i32_add_with_overflow,\n-            intrinsics::i32_sub_with_overflow,\n-            intrinsics::i32_mul_with_overflow }\n-    }\n+#[cfg(target_pointer_width = \"32\")]\n+#[lang = \"isize\"]\n+impl isize {\n+    int_impl! { int = i32, u32, 32,\n+        intrinsics::i32_add_with_overflow,\n+        intrinsics::i32_sub_with_overflow,\n+        intrinsics::i32_mul_with_overflow }\n+}\n \n-    #[cfg(target_pointer_width = \"64\")]\n-    #[lang = \"isize\"]\n-    impl isize {\n-        int_impl! { int = i64, u64, 64,\n-            intrinsics::i64_add_with_overflow,\n-            intrinsics::i64_sub_with_overflow,\n-            intrinsics::i64_mul_with_overflow }\n-    }\n+#[cfg(target_pointer_width = \"64\")]\n+#[lang = \"isize\"]\n+impl isize {\n+    int_impl! { int = i64, u64, 64,\n+        intrinsics::i64_add_with_overflow,\n+        intrinsics::i64_sub_with_overflow,\n+        intrinsics::i64_mul_with_overflow }\n+}\n \n-    // `Int` + `UnsignedInt` implemented for signed integers\n-    macro_rules! uint_impl {\n-        ($T:ty = $ActualT:ty, $BITS:expr,\n-         $ctpop:path,\n-         $ctlz:path,\n-         $cttz:path,\n-         $bswap:path,\n-         $add_with_overflow:path,\n-         $sub_with_overflow:path,\n-         $mul_with_overflow:path) => {\n-            /// Returns the `0` value of this integer type.\n-            // FIXME (#5527): Should be an associated constant\n-            #[unstable(feature = \"core\",\n-                       reason = \"unsure about its place in the world\")]\n-            #[inline]\n-            pub fn zero() -> $T { 0 }\n-\n-            /// Returns the `1` value of this integer type.\n-            // FIXME (#5527): Should be an associated constant\n-            #[unstable(feature = \"core\",\n-                       reason = \"unsure about its place in the world\")]\n-            #[inline]\n-            pub fn one() -> $T { 1 }\n-\n-            /// Returns the smallest value that can be represented by this integer type.\n-            // FIXME (#5527): Should be and associated constant\n-            #[unstable(feature = \"core\",\n-                       reason = \"unsure about its place in the world\")]\n-            #[inline]\n-            pub fn min_value() -> $T { 0 }\n-\n-            /// Returns the largest value that can be represented by this integer type.\n-            // FIXME (#5527): Should be and associated constant\n-            #[unstable(feature = \"core\",\n-                       reason = \"unsure about its place in the world\")]\n-            #[inline]\n-            pub fn max_value() -> $T { -1 }\n-\n-            /// Returns the number of ones in the binary representation of `self`.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0b01001100u8;\n-            ///\n-            /// assert_eq!(n.count_ones(), 3);\n-            /// ```\n-            #[unstable(feature = \"core\",\n-                       reason = \"pending integer conventions\")]\n-            #[inline]\n-            pub fn count_ones(self) -> u32 { unsafe { $ctpop(self as $ActualT) as u32 } }\n+// `Int` + `UnsignedInt` implemented for signed integers\n+macro_rules! uint_impl {\n+    ($T:ty = $ActualT:ty, $BITS:expr,\n+     $ctpop:path,\n+     $ctlz:path,\n+     $cttz:path,\n+     $bswap:path,\n+     $add_with_overflow:path,\n+     $sub_with_overflow:path,\n+     $mul_with_overflow:path) => {\n+        /// Returns the `0` value of this integer type.\n+        // FIXME (#5527): Should be an associated constant\n+        #[unstable(feature = \"core\",\n+                   reason = \"unsure about its place in the world\")]\n+        #[inline]\n+        pub fn zero() -> $T { 0 }\n+\n+        /// Returns the `1` value of this integer type.\n+        // FIXME (#5527): Should be an associated constant\n+        #[unstable(feature = \"core\",\n+                   reason = \"unsure about its place in the world\")]\n+        #[inline]\n+        pub fn one() -> $T { 1 }\n+\n+        /// Returns the smallest value that can be represented by this integer\n+        /// type.\n+        // FIXME (#5527): Should be and associated constant\n+        #[unstable(feature = \"core\",\n+                   reason = \"unsure about its place in the world\")]\n+        #[inline]\n+        pub fn min_value() -> $T { 0 }\n+\n+        /// Returns the largest value that can be represented by this integer\n+        /// type.\n+        // FIXME (#5527): Should be and associated constant\n+        #[unstable(feature = \"core\",\n+                   reason = \"unsure about its place in the world\")]\n+        #[inline]\n+        pub fn max_value() -> $T { -1 }\n+\n+        /// Returns the number of ones in the binary representation of `self`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0b01001100u8;\n+        ///\n+        /// assert_eq!(n.count_ones(), 3);\n+        /// ```\n+        #[unstable(feature = \"core\",\n+                   reason = \"pending integer conventions\")]\n+        #[inline]\n+        pub fn count_ones(self) -> u32 {\n+            unsafe { $ctpop(self as $ActualT) as u32 }\n+        }\n \n-            /// Returns the number of zeros in the binary representation of `self`.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0b01001100u8;\n-            ///\n-            /// assert_eq!(n.count_zeros(), 5);\n-            /// ```\n-            #[unstable(feature = \"core\",\n-                       reason = \"pending integer conventions\")]\n-            #[inline]\n-            pub fn count_zeros(self) -> u32 {\n-                (!self).count_ones()\n-            }\n+        /// Returns the number of zeros in the binary representation of `self`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0b01001100u8;\n+        ///\n+        /// assert_eq!(n.count_zeros(), 5);\n+        /// ```\n+        #[unstable(feature = \"core\",\n+                   reason = \"pending integer conventions\")]\n+        #[inline]\n+        pub fn count_zeros(self) -> u32 {\n+            (!self).count_ones()\n+        }\n \n-            /// Returns the number of leading zeros in the binary representation\n-            /// of `self`.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0b0101000u16;\n-            ///\n-            /// assert_eq!(n.leading_zeros(), 10);\n-            /// ```\n-            #[unstable(feature = \"core\",\n-                       reason = \"pending integer conventions\")]\n-            #[inline]\n-            pub fn leading_zeros(self) -> u32 { unsafe { $ctlz(self as $ActualT) as u32 } }\n+        /// Returns the number of leading zeros in the binary representation\n+        /// of `self`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0b0101000u16;\n+        ///\n+        /// assert_eq!(n.leading_zeros(), 10);\n+        /// ```\n+        #[unstable(feature = \"core\",\n+                   reason = \"pending integer conventions\")]\n+        #[inline]\n+        pub fn leading_zeros(self) -> u32 {\n+            unsafe { $ctlz(self as $ActualT) as u32 }\n+        }\n \n-            /// Returns the number of trailing zeros in the binary representation\n-            /// of `self`.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0b0101000u16;\n-            ///\n-            /// assert_eq!(n.trailing_zeros(), 3);\n-            /// ```\n-            #[unstable(feature = \"core\",\n-                       reason = \"pending integer conventions\")]\n-            #[inline]\n-            pub fn trailing_zeros(self) -> u32 { unsafe { $cttz(self as $ActualT) as u32 } }\n+        /// Returns the number of trailing zeros in the binary representation\n+        /// of `self`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0b0101000u16;\n+        ///\n+        /// assert_eq!(n.trailing_zeros(), 3);\n+        /// ```\n+        #[unstable(feature = \"core\",\n+                   reason = \"pending integer conventions\")]\n+        #[inline]\n+        pub fn trailing_zeros(self) -> u32 {\n+            unsafe { $cttz(self as $ActualT) as u32 }\n+        }\n \n-            /// Shifts the bits to the left by a specified amount amount, `n`, wrapping\n-            /// the truncated bits to the end of the resulting integer.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0x0123456789ABCDEFu64;\n-            /// let m = 0x3456789ABCDEF012u64;\n-            ///\n-            /// assert_eq!(n.rotate_left(12), m);\n-            /// ```\n-            #[unstable(feature = \"core\",\n-                       reason = \"pending integer conventions\")]\n-            #[inline]\n-            pub fn rotate_left(self, n: u32) -> $T {\n-                // Protect against undefined behaviour for over-long bit shifts\n-                let n = n % $BITS;\n-                (self << n) | (self >> (($BITS - n) % $BITS))\n-            }\n+        /// Shifts the bits to the left by a specified amount amount, `n`,\n+        /// wrapping the truncated bits to the end of the resulting integer.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0x0123456789ABCDEFu64;\n+        /// let m = 0x3456789ABCDEF012u64;\n+        ///\n+        /// assert_eq!(n.rotate_left(12), m);\n+        /// ```\n+        #[unstable(feature = \"core\",\n+                   reason = \"pending integer conventions\")]\n+        #[inline]\n+        pub fn rotate_left(self, n: u32) -> $T {\n+            // Protect against undefined behaviour for over-long bit shifts\n+            let n = n % $BITS;\n+            (self << n) | (self >> (($BITS - n) % $BITS))\n+        }\n \n-            /// Shifts the bits to the right by a specified amount amount, `n`, wrapping\n-            /// the truncated bits to the beginning of the resulting integer.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0x0123456789ABCDEFu64;\n-            /// let m = 0xDEF0123456789ABCu64;\n-            ///\n-            /// assert_eq!(n.rotate_right(12), m);\n-            /// ```\n-            #[unstable(feature = \"core\",\n-                       reason = \"pending integer conventions\")]\n-            #[inline]\n-            pub fn rotate_right(self, n: u32) -> $T {\n-                // Protect against undefined behaviour for over-long bit shifts\n-                let n = n % $BITS;\n-                (self >> n) | (self << (($BITS - n) % $BITS))\n-            }\n+        /// Shifts the bits to the right by a specified amount amount, `n`,\n+        /// wrapping the truncated bits to the beginning of the resulting\n+        /// integer.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0x0123456789ABCDEFu64;\n+        /// let m = 0xDEF0123456789ABCu64;\n+        ///\n+        /// assert_eq!(n.rotate_right(12), m);\n+        /// ```\n+        #[unstable(feature = \"core\",\n+                   reason = \"pending integer conventions\")]\n+        #[inline]\n+        pub fn rotate_right(self, n: u32) -> $T {\n+            // Protect against undefined behaviour for over-long bit shifts\n+            let n = n % $BITS;\n+            (self >> n) | (self << (($BITS - n) % $BITS))\n+        }\n \n-            /// Reverses the byte order of the integer.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0x0123456789ABCDEFu64;\n-            /// let m = 0xEFCDAB8967452301u64;\n-            ///\n-            /// assert_eq!(n.swap_bytes(), m);\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn swap_bytes(self) -> $T { unsafe { $bswap(self as $ActualT) as $T } }\n+        /// Reverses the byte order of the integer.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0x0123456789ABCDEFu64;\n+        /// let m = 0xEFCDAB8967452301u64;\n+        ///\n+        /// assert_eq!(n.swap_bytes(), m);\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn swap_bytes(self) -> $T {\n+            unsafe { $bswap(self as $ActualT) as $T }\n+        }\n \n-            /// Convert an integer from big endian to the target's endianness.\n-            ///\n-            /// On big endian this is a no-op. On little endian the bytes are swapped.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0x0123456789ABCDEFu64;\n-            ///\n-            /// if cfg!(target_endian = \"big\") {\n-            ///     assert_eq!(Int::from_be(n), n)\n-            /// } else {\n-            ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n-            /// }\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn from_be(x: $T) -> $T {\n-                if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n-            }\n+        /// Convert an integer from big endian to the target's endianness.\n+        ///\n+        /// On big endian this is a no-op. On little endian the bytes are\n+        /// swapped.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0x0123456789ABCDEFu64;\n+        ///\n+        /// if cfg!(target_endian = \"big\") {\n+        ///     assert_eq!(Int::from_be(n), n)\n+        /// } else {\n+        ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n+        /// }\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn from_be(x: $T) -> $T {\n+            if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n+        }\n \n-            /// Convert an integer from little endian to the target's endianness.\n-            ///\n-            /// On little endian this is a no-op. On big endian the bytes are swapped.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0x0123456789ABCDEFu64;\n-            ///\n-            /// if cfg!(target_endian = \"little\") {\n-            ///     assert_eq!(Int::from_le(n), n)\n-            /// } else {\n-            ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n-            /// }\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn from_le(x: $T) -> $T {\n-                if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n-            }\n+        /// Convert an integer from little endian to the target's endianness.\n+        ///\n+        /// On little endian this is a no-op. On big endian the bytes are\n+        /// swapped.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0x0123456789ABCDEFu64;\n+        ///\n+        /// if cfg!(target_endian = \"little\") {\n+        ///     assert_eq!(Int::from_le(n), n)\n+        /// } else {\n+        ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n+        /// }\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn from_le(x: $T) -> $T {\n+            if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n+        }\n \n-            /// Convert `self` to big endian from the target's endianness.\n-            ///\n-            /// On big endian this is a no-op. On little endian the bytes are swapped.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0x0123456789ABCDEFu64;\n-            ///\n-            /// if cfg!(target_endian = \"big\") {\n-            ///     assert_eq!(n.to_be(), n)\n-            /// } else {\n-            ///     assert_eq!(n.to_be(), n.swap_bytes())\n-            /// }\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn to_be(self) -> $T { // or not to be?\n-                if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n-            }\n+        /// Convert `self` to big endian from the target's endianness.\n+        ///\n+        /// On big endian this is a no-op. On little endian the bytes are\n+        /// swapped.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0x0123456789ABCDEFu64;\n+        ///\n+        /// if cfg!(target_endian = \"big\") {\n+        ///     assert_eq!(n.to_be(), n)\n+        /// } else {\n+        ///     assert_eq!(n.to_be(), n.swap_bytes())\n+        /// }\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn to_be(self) -> $T { // or not to be?\n+            if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n+        }\n \n-            /// Convert `self` to little endian from the target's endianness.\n-            ///\n-            /// On little endian this is a no-op. On big endian the bytes are swapped.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// let n = 0x0123456789ABCDEFu64;\n-            ///\n-            /// if cfg!(target_endian = \"little\") {\n-            ///     assert_eq!(n.to_le(), n)\n-            /// } else {\n-            ///     assert_eq!(n.to_le(), n.swap_bytes())\n-            /// }\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn to_le(self) -> $T {\n-                if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n-            }\n+        /// Convert `self` to little endian from the target's endianness.\n+        ///\n+        /// On little endian this is a no-op. On big endian the bytes are\n+        /// swapped.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// let n = 0x0123456789ABCDEFu64;\n+        ///\n+        /// if cfg!(target_endian = \"little\") {\n+        ///     assert_eq!(n.to_le(), n)\n+        /// } else {\n+        ///     assert_eq!(n.to_le(), n.swap_bytes())\n+        /// }\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn to_le(self) -> $T {\n+            if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n+        }\n \n-            /// Checked integer addition. Computes `self + other`, returning `None` if\n-            /// overflow occurred.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// assert_eq!(5u16.checked_add(65530), Some(65535));\n-            /// assert_eq!(6u16.checked_add(65530), None);\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn checked_add(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $add_with_overflow, self, other)\n-            }\n+        /// Checked integer addition. Computes `self + other`, returning `None`\n+        /// if overflow occurred.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// assert_eq!(5u16.checked_add(65530), Some(65535));\n+        /// assert_eq!(6u16.checked_add(65530), None);\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn checked_add(self, other: $T) -> Option<$T> {\n+            checked_op!($T, $ActualT, $add_with_overflow, self, other)\n+        }\n \n-            /// Checked integer subtraction. Computes `self - other`, returning `None`\n-            /// if underflow occurred.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n-            /// assert_eq!((-128i8).checked_sub(1), None);\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn checked_sub(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n-            }\n+        /// Checked integer subtraction. Computes `self - other`, returning\n+        /// `None` if underflow occurred.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n+        /// assert_eq!((-128i8).checked_sub(1), None);\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn checked_sub(self, other: $T) -> Option<$T> {\n+            checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n+        }\n \n-            /// Checked integer multiplication. Computes `self * other`, returning\n-            /// `None` if underflow or overflow occurred.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// assert_eq!(5u8.checked_mul(51), Some(255));\n-            /// assert_eq!(5u8.checked_mul(52), None);\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn checked_mul(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n-            }\n+        /// Checked integer multiplication. Computes `self * other`, returning\n+        /// `None` if underflow or overflow occurred.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// assert_eq!(5u8.checked_mul(51), Some(255));\n+        /// assert_eq!(5u8.checked_mul(52), None);\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn checked_mul(self, other: $T) -> Option<$T> {\n+            checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n+        }\n \n-            /// Checked integer division. Computes `self / other`, returning `None` if\n-            /// `other == 0` or the operation results in underflow or overflow.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// assert_eq!((-127i8).checked_div(-1), Some(127));\n-            /// assert_eq!((-128i8).checked_div(-1), None);\n-            /// assert_eq!((1i8).checked_div(0), None);\n-            /// ```\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn checked_div(self, v: $T) -> Option<$T> {\n-                match v {\n-                    0 => None,\n-                    v => Some(self / v),\n-                }\n+        /// Checked integer division. Computes `self / other`, returning `None`\n+        /// if `other == 0` or the operation results in underflow or overflow.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// assert_eq!((-127i8).checked_div(-1), Some(127));\n+        /// assert_eq!((-128i8).checked_div(-1), None);\n+        /// assert_eq!((1i8).checked_div(0), None);\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn checked_div(self, v: $T) -> Option<$T> {\n+            match v {\n+                0 => None,\n+                v => Some(self / v),\n             }\n+        }\n \n-            /// Saturating integer addition. Computes `self + other`, saturating at\n-            /// the numeric bounds instead of overflowing.\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn saturating_add(self, other: $T) -> $T {\n-                match self.checked_add(other) {\n-                    Some(x)                       => x,\n-                    None if other >= <$T>::zero() => <$T>::max_value(),\n-                    None                          => <$T>::min_value(),\n-                }\n+        /// Saturating integer addition. Computes `self + other`, saturating at\n+        /// the numeric bounds instead of overflowing.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn saturating_add(self, other: $T) -> $T {\n+            match self.checked_add(other) {\n+                Some(x)                       => x,\n+                None if other >= <$T>::zero() => <$T>::max_value(),\n+                None                          => <$T>::min_value(),\n             }\n+        }\n \n-            /// Saturating integer subtraction. Computes `self - other`, saturating at\n-            /// the numeric bounds instead of overflowing.\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn saturating_sub(self, other: $T) -> $T {\n-                match self.checked_sub(other) {\n-                    Some(x)                       => x,\n-                    None if other >= <$T>::zero() => <$T>::min_value(),\n-                    None                          => <$T>::max_value(),\n-                }\n+        /// Saturating integer subtraction. Computes `self - other`, saturating\n+        /// at the numeric bounds instead of overflowing.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn saturating_sub(self, other: $T) -> $T {\n+            match self.checked_sub(other) {\n+                Some(x)                       => x,\n+                None if other >= <$T>::zero() => <$T>::min_value(),\n+                None                          => <$T>::max_value(),\n             }\n+        }\n \n-            /// Raises self to the power of `exp`, using exponentiation by squaring.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```rust\n-            /// use std::num::Int;\n-            ///\n-            /// assert_eq!(2.pow(4), 16);\n-            /// ```\n-            #[unstable(feature = \"core\",\n-                       reason = \"pending integer conventions\")]\n-            #[inline]\n-            pub fn pow(self, mut exp: u32) -> $T {\n-                let mut base = self;\n-                let mut acc = <$T>::one();\n-\n-                let mut prev_base = self;\n-                let mut base_oflo = false;\n-                while exp > 0 {\n-                    if (exp & 1) == 1 {\n-                        if base_oflo {\n-                            // ensure overflow occurs in the same manner it\n-                            // would have otherwise (i.e. signal any exception\n-                            // it would have otherwise).\n-                            acc = acc * (prev_base * prev_base);\n-                        } else {\n-                            acc = acc * base;\n-                        }\n+        /// Raises self to the power of `exp`, using exponentiation by squaring.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// use std::num::Int;\n+        ///\n+        /// assert_eq!(2.pow(4), 16);\n+        /// ```\n+        #[unstable(feature = \"core\",\n+                   reason = \"pending integer conventions\")]\n+        #[inline]\n+        pub fn pow(self, mut exp: u32) -> $T {\n+            let mut base = self;\n+            let mut acc = <$T>::one();\n+\n+            let mut prev_base = self;\n+            let mut base_oflo = false;\n+            while exp > 0 {\n+                if (exp & 1) == 1 {\n+                    if base_oflo {\n+                        // ensure overflow occurs in the same manner it\n+                        // would have otherwise (i.e. signal any exception\n+                        // it would have otherwise).\n+                        acc = acc * (prev_base * prev_base);\n+                    } else {\n+                        acc = acc * base;\n                     }\n-                    prev_base = base;\n-                    let (new_base, new_base_oflo) = base.overflowing_mul(base);\n-                    base = new_base;\n-                    base_oflo = new_base_oflo;\n-                    exp /= 2;\n                 }\n-                acc\n+                prev_base = base;\n+                let (new_base, new_base_oflo) = base.overflowing_mul(base);\n+                base = new_base;\n+                base_oflo = new_base_oflo;\n+                exp /= 2;\n             }\n+            acc\n+        }\n \n-            /// Returns `true` iff `self == 2^k` for some `k`.\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn is_power_of_two(self) -> bool {\n-                (self.wrapping_sub(<$T>::one())) & self == <$T>::zero() && !(self == <$T>::zero())\n-            }\n+        /// Returns `true` iff `self == 2^k` for some `k`.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn is_power_of_two(self) -> bool {\n+            (self.wrapping_sub(<$T>::one())) & self == <$T>::zero() &&\n+                !(self == <$T>::zero())\n+        }\n \n-            /// Returns the smallest power of two greater than or equal to `self`.\n-            /// Unspecified behavior on overflow.\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n-            pub fn next_power_of_two(self) -> $T {\n-                let bits = size_of::<$T>() * 8;\n-                let one: $T = <$T>::one();\n-                one << ((bits - self.wrapping_sub(one).leading_zeros() as usize) % bits)\n-            }\n+        /// Returns the smallest power of two greater than or equal to `self`.\n+        /// Unspecified behavior on overflow.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn next_power_of_two(self) -> $T {\n+            let bits = size_of::<$T>() * 8;\n+            let one: $T = <$T>::one();\n+            one << ((bits - self.wrapping_sub(one).leading_zeros() as usize) % bits)\n+        }\n \n-            /// Returns the smallest power of two greater than or equal to `n`. If the\n-            /// next power of two is greater than the type's maximum value, `None` is\n-            /// returned, otherwise the power of two is wrapped in `Some`.\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            pub fn checked_next_power_of_two(self) -> Option<$T> {\n-                let npot = self.next_power_of_two();\n-                if npot >= self {\n-                    Some(npot)\n-                } else {\n-                    None\n-                }\n+        /// Returns the smallest power of two greater than or equal to `n`. If\n+        /// the next power of two is greater than the type's maximum value,\n+        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        pub fn checked_next_power_of_two(self) -> Option<$T> {\n+            let npot = self.next_power_of_two();\n+            if npot >= self {\n+                Some(npot)\n+            } else {\n+                None\n             }\n         }\n     }\n+}\n \n-    /// Swapping a single byte is a no-op. This is marked as `unsafe` for\n-    /// consistency with the other `bswap` intrinsics.\n-    unsafe fn bswap8(x: u8) -> u8 { x }\n-\n-    #[lang = \"u8\"]\n-    impl u8 {\n-        uint_impl! { u8 = u8, 8,\n-            intrinsics::ctpop8,\n-            intrinsics::ctlz8,\n-            intrinsics::cttz8,\n-            bswap8,\n-            intrinsics::u8_add_with_overflow,\n-            intrinsics::u8_sub_with_overflow,\n-            intrinsics::u8_mul_with_overflow }\n-    }\n+#[lang = \"u8\"]\n+impl u8 {\n+    uint_impl! { u8 = u8, 8,\n+        intrinsics::ctpop8,\n+        intrinsics::ctlz8,\n+        intrinsics::cttz8,\n+        bswap8,\n+        intrinsics::u8_add_with_overflow,\n+        intrinsics::u8_sub_with_overflow,\n+        intrinsics::u8_mul_with_overflow }\n+}\n \n-    #[lang = \"u16\"]\n-    impl u16 {\n-        uint_impl! { u16 = u16, 16,\n-            intrinsics::ctpop16,\n-            intrinsics::ctlz16,\n-            intrinsics::cttz16,\n-            intrinsics::bswap16,\n-            intrinsics::u16_add_with_overflow,\n-            intrinsics::u16_sub_with_overflow,\n-            intrinsics::u16_mul_with_overflow }\n-    }\n+#[lang = \"u16\"]\n+impl u16 {\n+    uint_impl! { u16 = u16, 16,\n+        intrinsics::ctpop16,\n+        intrinsics::ctlz16,\n+        intrinsics::cttz16,\n+        intrinsics::bswap16,\n+        intrinsics::u16_add_with_overflow,\n+        intrinsics::u16_sub_with_overflow,\n+        intrinsics::u16_mul_with_overflow }\n+}\n \n-    #[lang = \"u32\"]\n-    impl u32 {\n-        uint_impl! { u32 = u32, 32,\n-            intrinsics::ctpop32,\n-            intrinsics::ctlz32,\n-            intrinsics::cttz32,\n-            intrinsics::bswap32,\n-            intrinsics::u32_add_with_overflow,\n-            intrinsics::u32_sub_with_overflow,\n-            intrinsics::u32_mul_with_overflow }\n-    }\n+#[lang = \"u32\"]\n+impl u32 {\n+    uint_impl! { u32 = u32, 32,\n+        intrinsics::ctpop32,\n+        intrinsics::ctlz32,\n+        intrinsics::cttz32,\n+        intrinsics::bswap32,\n+        intrinsics::u32_add_with_overflow,\n+        intrinsics::u32_sub_with_overflow,\n+        intrinsics::u32_mul_with_overflow }\n+}\n \n \n-    #[lang = \"u64\"]\n-    impl u64 {\n-        uint_impl! { u64 = u64, 64,\n-            intrinsics::ctpop64,\n-            intrinsics::ctlz64,\n-            intrinsics::cttz64,\n-            intrinsics::bswap64,\n-            intrinsics::u64_add_with_overflow,\n-            intrinsics::u64_sub_with_overflow,\n-            intrinsics::u64_mul_with_overflow }\n-    }\n+#[lang = \"u64\"]\n+impl u64 {\n+    uint_impl! { u64 = u64, 64,\n+        intrinsics::ctpop64,\n+        intrinsics::ctlz64,\n+        intrinsics::cttz64,\n+        intrinsics::bswap64,\n+        intrinsics::u64_add_with_overflow,\n+        intrinsics::u64_sub_with_overflow,\n+        intrinsics::u64_mul_with_overflow }\n+}\n \n-    #[cfg(target_pointer_width = \"32\")]\n-    #[lang = \"usize\"]\n-    impl usize {\n-        uint_impl! { uint = u32, 32,\n-            intrinsics::ctpop32,\n-            intrinsics::ctlz32,\n-            intrinsics::cttz32,\n-            intrinsics::bswap32,\n-            intrinsics::u32_add_with_overflow,\n-            intrinsics::u32_sub_with_overflow,\n-            intrinsics::u32_mul_with_overflow }\n-    }\n+#[cfg(target_pointer_width = \"32\")]\n+#[lang = \"usize\"]\n+impl usize {\n+    uint_impl! { uint = u32, 32,\n+        intrinsics::ctpop32,\n+        intrinsics::ctlz32,\n+        intrinsics::cttz32,\n+        intrinsics::bswap32,\n+        intrinsics::u32_add_with_overflow,\n+        intrinsics::u32_sub_with_overflow,\n+        intrinsics::u32_mul_with_overflow }\n+}\n \n-    #[cfg(target_pointer_width = \"64\")]\n-    #[lang = \"usize\"]\n-    impl usize {\n-        uint_impl! { uint = u64, 64,\n-            intrinsics::ctpop64,\n-            intrinsics::ctlz64,\n-            intrinsics::cttz64,\n-            intrinsics::bswap64,\n-            intrinsics::u64_add_with_overflow,\n-            intrinsics::u64_sub_with_overflow,\n-            intrinsics::u64_mul_with_overflow }\n-    }\n+#[cfg(target_pointer_width = \"64\")]\n+#[lang = \"usize\"]\n+impl usize {\n+    uint_impl! { uint = u64, 64,\n+        intrinsics::ctpop64,\n+        intrinsics::ctlz64,\n+        intrinsics::cttz64,\n+        intrinsics::bswap64,\n+        intrinsics::u64_add_with_overflow,\n+        intrinsics::u64_sub_with_overflow,\n+        intrinsics::u64_mul_with_overflow }\n }\n \n /// A generic trait for converting a value to a number."}, {"sha": "c668fe80d14520420c6ebb4e1921ad96a98e559a", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -42,8 +42,6 @@ pub use iter::{Extend, IteratorExt};\n pub use iter::{Iterator, DoubleEndedIterator};\n pub use iter::{ExactSizeIterator};\n pub use option::Option::{self, Some, None};\n-#[cfg(stage0)]\n-pub use ptr::{PtrExt, MutPtrExt};\n pub use result::Result::{self, Ok, Err};\n pub use slice::{AsSlice, SliceExt};\n pub use str::{Str, StrExt};"}, {"sha": "1cbea057e88420c5cfdc8329616dd72fb389b274", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 5, "deletions": 138, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -262,145 +262,13 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n-#[cfg(stage0)]\n-/// Methods on raw pointers\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait PtrExt {\n-    /// The type which is being pointed at\n-    type Target: ?Sized;\n-\n-    /// Returns true if the pointer is null.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_null(self) -> bool;\n-\n-    /// Returns `None` if the pointer is null, or else returns a reference to\n-    /// the value wrapped in `Some`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// While this method and its mutable counterpart are useful for\n-    /// null-safety, it is important to note that this is still an unsafe\n-    /// operation because the returned value could be pointing to invalid\n-    /// memory.\n-    #[unstable(feature = \"core\",\n-               reason = \"Option is not clearly the right return type, and we may want \\\n-                         to tie the return lifetime to a borrow of the raw pointer\")]\n-    unsafe fn as_ref<'a>(&self) -> Option<&'a Self::Target>;\n-\n-    /// Calculates the offset from a pointer. `count` is in units of T; e.g. a\n-    /// `count` of 3 represents a pointer offset of `3 * sizeof::<T>()` bytes.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The offset must be in-bounds of the object, or one-byte-past-the-end.\n-    /// Otherwise `offset` invokes Undefined Behaviour, regardless of whether\n-    /// the pointer is used.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: isize) -> Self where Self::Target: Sized;\n-}\n-\n-#[cfg(stage0)]\n-/// Methods on mutable raw pointers\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait MutPtrExt {\n-    /// The type which is being pointed at\n-    type Target: ?Sized;\n-\n-    /// Returns `None` if the pointer is null, or else returns a mutable\n-    /// reference to the value wrapped in `Some`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// As with `as_ref`, this is unsafe because it cannot verify the validity\n-    /// of the returned pointer.\n-    #[unstable(feature = \"core\",\n-               reason = \"Option is not clearly the right return type, and we may want \\\n-                         to tie the return lifetime to a borrow of the raw pointer\")]\n-    unsafe fn as_mut<'a>(&self) -> Option<&'a mut Self::Target>;\n-}\n-\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> PtrExt for *const T {\n-    type Target = T;\n-\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_null(self) -> bool { self == 0 as *const T }\n-\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: isize) -> *const T where T: Sized {\n-        intrinsics::offset(self, count)\n-    }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\",\n-               reason = \"return value does not necessarily convey all possible \\\n-                         information\")]\n-    unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n-        if self.is_null() {\n-            None\n-        } else {\n-            Some(&**self)\n-        }\n-    }\n-}\n-\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> PtrExt for *mut T {\n-    type Target = T;\n-\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_null(self) -> bool { self == 0 as *mut T }\n-\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: isize) -> *mut T where T: Sized {\n-        intrinsics::offset(self, count) as *mut T\n-    }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\",\n-               reason = \"return value does not necessarily convey all possible \\\n-                         information\")]\n-    unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n-        if self.is_null() {\n-            None\n-        } else {\n-            Some(&**self)\n-        }\n-    }\n-}\n-\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> MutPtrExt for *mut T {\n-    type Target = T;\n-\n-    #[inline]\n-    #[unstable(feature = \"core\",\n-               reason = \"return value does not necessarily convey all possible \\\n-                         information\")]\n-    unsafe fn as_mut<'a>(&self) -> Option<&'a mut T> {\n-        if self.is_null() {\n-            None\n-        } else {\n-            Some(&mut **self)\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"const_ptr\"]\n impl<T: ?Sized> *const T {\n     /// Returns true if the pointer is null.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_null(self) -> bool {\n+    pub fn is_null(self) -> bool where T: Sized {\n         self == 0 as *const T\n     }\n \n@@ -417,7 +285,7 @@ impl<T: ?Sized> *const T {\n                reason = \"Option is not clearly the right return type, and we may want \\\n                          to tie the return lifetime to a borrow of the raw pointer\")]\n     #[inline]\n-    pub unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n+    pub unsafe fn as_ref<'a>(&self) -> Option<&'a T> where T: Sized {\n         if self.is_null() {\n             None\n         } else {\n@@ -440,14 +308,13 @@ impl<T: ?Sized> *const T {\n     }\n }\n \n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"mut_ptr\"]\n impl<T: ?Sized> *mut T {\n     /// Returns true if the pointer is null.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_null(self) -> bool {\n+    pub fn is_null(self) -> bool where T: Sized {\n         self == 0 as *mut T\n     }\n \n@@ -464,7 +331,7 @@ impl<T: ?Sized> *mut T {\n                reason = \"Option is not clearly the right return type, and we may want \\\n                          to tie the return lifetime to a borrow of the raw pointer\")]\n     #[inline]\n-    pub unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n+    pub unsafe fn as_ref<'a>(&self) -> Option<&'a T> where T: Sized {\n         if self.is_null() {\n             None\n         } else {\n@@ -497,7 +364,7 @@ impl<T: ?Sized> *mut T {\n                reason = \"return value does not necessarily convey all possible \\\n                          information\")]\n     #[inline]\n-    pub unsafe fn as_mut<'a>(&self) -> Option<&'a mut T> {\n+    pub unsafe fn as_mut<'a>(&self) -> Option<&'a mut T> where T: Sized {\n         if self.is_null() {\n             None\n         } else {"}, {"sha": "907b2eba80c5b872a1f5fc1fb9964901c73c1251", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -49,8 +49,6 @@ use option::Option::{None, Some};\n use result::Result;\n use result::Result::{Ok, Err};\n use ptr;\n-#[cfg(stage0)]\n-use ptr::PtrExt;\n use mem;\n use mem::size_of;\n use marker::{Send, Sized, Sync, self};"}, {"sha": "e8181395b5c1e5a19538eb3eef1942014577daa4", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -31,8 +31,6 @@ use mem;\n use num::Int;\n use ops::{Fn, FnMut};\n use option::Option::{self, None, Some};\n-#[cfg(stage0)]\n-use ptr::PtrExt;\n use raw::{Repr, Slice};\n use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};"}, {"sha": "496c96c7c8adc1dd5bebd412b258c7a352db670d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -27,8 +27,6 @@ use middle::ty;\n use std::cmp::Ordering;\n use std::fmt;\n use std::iter::{range_inclusive, AdditiveIterator, FromIterator, IntoIterator, repeat};\n-#[cfg(stage0)]\n-use std::num::Float;\n use std::slice;\n use syntax::ast::{self, DUMMY_NODE_ID, NodeId, Pat};\n use syntax::ast_util;"}, {"sha": "529ed8598b1ac13e9ccb2daa4ad0dcac6c62b5cd", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -204,8 +204,6 @@ use std::io::prelude::*;\n use std::io;\n use std::mem::{swap};\n use std::num::FpCategory as Fp;\n-#[cfg(stage0)]\n-use std::num::{Float, Int};\n use std::ops::Index;\n use std::str::FromStr;\n use std::string;"}, {"sha": "60b1738d2c98918351082c0da31efbfc78b08aed", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -23,8 +23,6 @@ use hash::{Hash, SipHasher};\n use iter::{self, Iterator, ExactSizeIterator, IntoIterator, IteratorExt, FromIterator, Extend, Map};\n use marker::Sized;\n use mem::{self, replace};\n-#[cfg(stage0)]\n-use num::{Int, UnsignedInt};\n use ops::{Deref, FnMut, Index, IndexMut};\n use option::Option::{self, Some, None};\n use rand::{self, Rng};"}, {"sha": "052bcfd7e164951ac15fd7d576e8643b386225d1", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -19,15 +19,10 @@ use iter::{Iterator, IteratorExt, ExactSizeIterator, count};\n use marker::{Copy, Send, Sync, Sized, self};\n use mem::{min_align_of, size_of};\n use mem;\n-#[cfg(stage0)]\n-use num::{Int, UnsignedInt};\n use num::wrapping::{OverflowingOps, WrappingOps};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{Some, None};\n-#[cfg(stage0)]\n-use ptr::{self, PtrExt, Unique};\n-#[cfg(not(stage0))]\n use ptr::{self, Unique};\n use rt::heap::{allocate, deallocate, EMPTY};\n use collections::hash_state::HashState;"}, {"sha": "a42809127bf5c8912c0568a281607db410f23047", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -272,10 +272,6 @@ mod dl {\n     use ptr;\n     use result::Result;\n     use result::Result::{Ok, Err};\n-    #[cfg(stage0)]\n-    use slice::SliceExt;\n-    #[cfg(stage0)]\n-    use str::StrExt;\n     use str;\n     use string::String;\n     use vec::Vec;\n@@ -294,10 +290,11 @@ mod dl {\n                 let err = os::errno();\n                 if err as libc::c_int == ERROR_CALL_NOT_IMPLEMENTED {\n                     use_thread_mode = false;\n-                    // SetThreadErrorMode not found. use fallback solution: SetErrorMode()\n-                    // Note that SetErrorMode is process-wide so this can cause race condition!\n-                    // However, since even Windows APIs do not care of such problem (#20650),\n-                    // we just assume SetErrorMode race is not a great deal.\n+                    // SetThreadErrorMode not found. use fallback solution:\n+                    // SetErrorMode() Note that SetErrorMode is process-wide so\n+                    // this can cause race condition!  However, since even\n+                    // Windows APIs do not care of such problem (#20650), we\n+                    // just assume SetErrorMode race is not a great deal.\n                     prev_error_mode = SetErrorMode(new_error_mode);\n                 }\n             }"}, {"sha": "fc4f03ff3a54a808d3a28a27a6074a57caa29ddd", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -22,12 +22,7 @@ use old_io;\n use ops::Deref;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n-#[cfg(stage0)]\n-use slice::{self, SliceExt};\n-#[cfg(not(stage0))]\n use slice;\n-#[cfg(stage0)]\n-use str::StrExt;\n use string::String;\n use vec::Vec;\n "}, {"sha": "8691c84a4622f348b675545aa060740f23d40f06", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -20,18 +20,10 @@ use iter::Iterator;\n use marker::Sized;\n use ops::{Drop, FnOnce};\n use option::Option::{self, Some, None};\n-#[cfg(stage0)]\n-use ptr::PtrExt;\n use result::Result::{Ok, Err};\n use result;\n-#[cfg(stage0)]\n-use slice::{self, SliceExt};\n-#[cfg(not(stage0))]\n use slice;\n use string::String;\n-#[cfg(stage0)]\n-use str::{self, StrExt};\n-#[cfg(not(stage0))]\n use str;\n use vec::Vec;\n "}, {"sha": "11e2b8dca1b8082d73c6835326497b4d96185acb", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -357,7 +357,6 @@ impl Float for f32 {\n     }\n }\n \n-#[cfg(not(stage0))]\n #[cfg(not(test))]\n #[lang = \"f32\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "650f642220fc0c270257226d1912068c9d80738b", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -366,7 +366,6 @@ impl Float for f64 {\n     }\n }\n \n-#[cfg(not(stage0))]\n #[cfg(not(test))]\n #[lang = \"f64\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "60a548b596b1c60f719659e828fa58ca646620c6", "filename": "src/libstd/num/float_macros.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat_macros.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -11,17 +11,6 @@\n #![unstable(feature = \"std_misc\")]\n #![doc(hidden)]\n \n-#[cfg(stage0)]\n-macro_rules! assert_approx_eq {\n-    ($a:expr, $b:expr) => ({\n-        use num::Float;\n-        let (a, b) = (&$a, &$b);\n-        assert!((*a - *b).abs() < 1.0e-6,\n-                \"{} is not approximately equal to {}\", *a, *b);\n-    })\n-}\n-\n-#[cfg(not(stage0))]\n macro_rules! assert_approx_eq {\n     ($a:expr, $b:expr) => ({\n         let (a, b) = (&$a, &$b);"}, {"sha": "37f1f69177621781729c03e49f0c6d2bcb7fdf6d", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -23,9 +23,6 @@ use marker::Copy;\n use clone::Clone;\n use cmp::{PartialOrd, PartialEq};\n \n-#[cfg(stage0)]\n-pub use core::num::{Int, SignedInt, UnsignedInt};\n-#[cfg(not(stage0))]\n pub use core::num::{Int, SignedInt};\n pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};\n pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};"}, {"sha": "66826b359e63054f9fa06fdc1afc18ff4a4a5ba7", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -16,17 +16,10 @@ use self::ExponentFormat::*;\n use self::SignificantDigits::*;\n use self::SignFormat::*;\n \n-#[cfg(stage0)]\n-use char::{self, CharExt};\n-#[cfg(not(stage0))]\n use char;\n use num::{self, Int, Float, ToPrimitive};\n use num::FpCategory as Fp;\n use ops::FnMut;\n-#[cfg(stage0)]\n-use slice::SliceExt;\n-#[cfg(stage0)]\n-use str::StrExt;\n use string::String;\n use vec::Vec;\n "}, {"sha": "56bc21303bbcac039278545be16de691caf08894", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -20,8 +20,6 @@ use ops::Drop;\n use option::Option;\n use option::Option::{Some, None};\n use result::Result::Ok;\n-#[cfg(stage0)]\n-use slice::{SliceExt};\n use slice;\n use vec::Vec;\n "}, {"sha": "2dc61f409e2a4524cf6e8fa4f7e9698376b926a7", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -14,9 +14,6 @@ use sync::mpsc::{Sender, Receiver};\n use old_io;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n-#[cfg(stage0)]\n-use slice::{bytes, SliceExt};\n-#[cfg(not(stage0))]\n use slice::bytes;\n use super::{Buffer, Reader, Writer, IoResult};\n use vec::Vec;"}, {"sha": "12c9970aa84393f8ca2b8746e8b22fdec81e25a3", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -26,11 +26,7 @@ use num::Int;\n use ops::FnOnce;\n use option::Option;\n use option::Option::{Some, None};\n-#[cfg(stage0)]\n-use ptr::PtrExt;\n use result::Result::{Ok, Err};\n-#[cfg(stage0)]\n-use slice::SliceExt;\n \n /// An iterator that reads a single byte on each iteration,\n /// until `.read_byte()` returns `EndOfFile`.\n@@ -164,8 +160,6 @@ pub fn u64_to_be_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n ///           32-bit value is parsed.\n pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n     use ptr::{copy_nonoverlapping_memory};\n-    #[cfg(stage0)]\n-    use slice::SliceExt;\n \n     assert!(size <= 8);\n "}, {"sha": "2df925beb3667e9afe882821f1ae0eacf3733216", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -64,8 +64,6 @@ use option::Option::{Some, None};\n use old_path::{Path, GenericPath};\n use old_path;\n use result::Result::{Err, Ok};\n-#[cfg(stage0)]\n-use slice::SliceExt;\n use string::String;\n use vec::Vec;\n "}, {"sha": "eb7691361d45c502661c84566411cccde681323a", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -17,9 +17,6 @@ use option::Option::None;\n use result::Result::{Err, Ok};\n use old_io;\n use old_io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n-#[cfg(stage0)]\n-use slice::{self, SliceExt};\n-#[cfg(not(stage0))]\n use slice;\n use vec::Vec;\n "}, {"sha": "6b6c36a31ec5bd32592db5ada18125febf97cc72", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -251,8 +251,6 @@ pub use self::FileMode::*;\n pub use self::FileAccess::*;\n pub use self::IoErrorKind::*;\n \n-#[cfg(stage0)]\n-use char::CharExt;\n use default::Default;\n use error::Error;\n use fmt;\n@@ -268,10 +266,6 @@ use boxed::Box;\n use result::Result;\n use result::Result::{Ok, Err};\n use sys;\n-#[cfg(stage0)]\n-use slice::SliceExt;\n-#[cfg(stage0)]\n-use str::StrExt;\n use str;\n use string::String;\n use usize;\n@@ -935,8 +929,6 @@ impl<'a> Reader for &'a mut (Reader+'a) {\n // API yet. If so, it should be a method on Vec.\n unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -> &'a mut [T] {\n     use slice;\n-    #[cfg(stage0)]\n-    use ptr::PtrExt;\n \n     assert!(start <= end);\n     assert!(end <= v.capacity());"}, {"sha": "077a50725705286ade3fdc4d8d31990265b92c5f", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -26,11 +26,6 @@ use ops::{FnOnce, FnMut};\n use option::Option;\n use option::Option::{None, Some};\n use result::Result::{self, Ok, Err};\n-#[cfg(stage0)]\n-use slice::SliceExt;\n-#[cfg(stage0)]\n-use str::{FromStr, StrExt};\n-#[cfg(not(stage0))]\n use str::FromStr;\n use vec::Vec;\n "}, {"sha": "4ca403823753d625a7220f407c0f2a796d89a022", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -43,10 +43,6 @@ use ops::{Deref, DerefMut, FnOnce};\n use ptr;\n use result::Result::{Ok, Err};\n use rt;\n-#[cfg(stage0)]\n-use slice::SliceExt;\n-#[cfg(stage0)]\n-use str::StrExt;\n use string::String;\n use sys::{fs, tty};\n use sync::{Arc, Mutex, MutexGuard, Once, ONCE_INIT};"}, {"sha": "04bfd4409cf20b68412f39a3a59ba790891b579e", "filename": "src/libstd/old_io/tempfile.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -21,8 +21,6 @@ use option::Option;\n use old_path::{Path, GenericPath};\n use rand::{Rng, thread_rng};\n use result::Result::{Ok, Err};\n-#[cfg(stage0)]\n-use str::StrExt;\n use string::String;\n \n /// A wrapper for a path to temporary directory implementing automatic"}, {"sha": "fd117838f2f5b9d4b5e201a0ac99b90db8190c19", "filename": "src/libstd/old_path/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -72,11 +72,7 @@ use iter::IteratorExt;\n use option::Option;\n use option::Option::{None, Some};\n use str;\n-#[cfg(stage0)]\n-use str::StrExt;\n use string::{String, CowString};\n-#[cfg(stage0)]\n-use slice::SliceExt;\n use vec::Vec;\n \n /// Typedef for POSIX file paths."}, {"sha": "4f28e9e44f12ef0fd173652ee1d1c1120c1ea2b6", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -20,13 +20,7 @@ use iter::{Iterator, IteratorExt, Map};\n use marker::Sized;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n-#[cfg(stage0)]\n-use slice::{AsSlice, Split, SliceExt, SliceConcatExt};\n-#[cfg(not(stage0))]\n use slice::{AsSlice, Split, SliceConcatExt};\n-#[cfg(stage0)]\n-use str::{self, FromStr, StrExt};\n-#[cfg(not(stage0))]\n use str::{self, FromStr};\n use vec::Vec;\n "}, {"sha": "ef873265b7bcdbe21d0a93a9b9eea4e0d9ad9037", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -15,8 +15,6 @@\n use self::PathPrefix::*;\n \n use ascii::AsciiExt;\n-#[cfg(stage0)]\n-use char::CharExt;\n use clone::Clone;\n use cmp::{Ordering, Eq, Ord, PartialEq, PartialOrd};\n use fmt;\n@@ -27,13 +25,7 @@ use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n-#[cfg(stage0)]\n-use slice::{SliceExt, SliceConcatExt};\n-#[cfg(not(stage0))]\n use slice::SliceConcatExt;\n-#[cfg(stage0)]\n-use str::{SplitTerminator, FromStr, StrExt};\n-#[cfg(not(stage0))]\n use str::{SplitTerminator, FromStr};\n use string::{String, ToString};\n use vec::Vec;"}, {"sha": "a1a3afca7a9a50196be3730d0709aeecace962e5", "filename": "src/libstd/os.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -52,18 +52,10 @@ use option::Option::{Some, None};\n use option::Option;\n use old_path::{Path, GenericPath, BytesContainer};\n use path::{self, PathBuf};\n-#[cfg(stage0)]\n-use ptr::PtrExt;\n use ptr;\n use result::Result::{Err, Ok};\n use result::Result;\n-#[cfg(stage0)]\n-use slice::{AsSlice, SliceExt};\n-#[cfg(not(stage0))]\n use slice::AsSlice;\n-#[cfg(stage0)]\n-use str::{Str, StrExt};\n-#[cfg(not(stage0))]\n use str::Str;\n use str;\n use string::{String, ToString};"}, {"sha": "ddceed14cc6ce51a49ea3bbb680be1a71d56fd97", "filename": "src/libstd/path.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -159,8 +159,6 @@ mod platform {\n     use core::prelude::*;\n     use ascii::*;\n \n-    #[cfg(stage0)]\n-    use char::CharExt as UnicodeCharExt;\n     use super::{os_str_as_u8_slice, u8_slice_as_os_str, Prefix};\n     use ffi::OsStr;\n "}, {"sha": "2aaf6e8280086b54bc8e84f3ce9a3988e43e70cb", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -25,9 +25,6 @@\n // Reexported types and traits\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use boxed::Box;\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)] pub use char::CharExt;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use clone::Clone;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -40,21 +37,10 @@\n #[doc(no_inline)] pub use iter::{Iterator, IteratorExt, Extend};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use option::Option::{self, Some, None};\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)] pub use ptr::{PtrExt, MutPtrExt};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)] pub use slice::{SliceExt, SliceConcatExt, AsSlice};\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use slice::{SliceConcatExt, AsSlice};\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)] pub use str::{Str, StrExt};\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use str::Str;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "51b6045cf16f8b0302008694ef4d558cc5fda08d", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -24,8 +24,6 @@ mod imp {\n     use rand::Rng;\n     use rand::reader::ReaderRng;\n     use result::Result::Ok;\n-    #[cfg(stage0)]\n-    use slice::SliceExt;\n     use mem;\n     use os::errno;\n \n@@ -194,8 +192,6 @@ mod imp {\n     use rand::Rng;\n     use result::Result::{Ok};\n     use self::libc::{c_int, size_t};\n-    #[cfg(stage0)]\n-    use slice::SliceExt;\n \n     /// A random number generator that retrieves randomness straight from\n     /// the operating system. Platform sources:\n@@ -265,8 +261,6 @@ mod imp {\n     use result::Result::{Ok, Err};\n     use self::libc::{DWORD, BYTE, LPCSTR, BOOL};\n     use self::libc::types::os::arch::extra::{LONG_PTR};\n-    #[cfg(stage0)]\n-    use slice::SliceExt;\n \n     type HCRYPTPROV = LONG_PTR;\n "}, {"sha": "5231b122b9e538f61799dbffb62320ff2eef9b18", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -13,8 +13,6 @@\n use old_io::Reader;\n use rand::Rng;\n use result::Result::{Ok, Err};\n-#[cfg(stage0)]\n-use slice::SliceExt;\n \n /// An RNG that reads random bytes straight from a `Reader`. This will\n /// work best with an infinite reader, but this is not required."}, {"sha": "9fa12b1ef30239472e35a3dc2b948ebc4950b782", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -12,9 +12,6 @@\n //!\n //! Documentation can be found on the `rt::at_exit` function.\n \n-#[cfg(stage0)]\n-use core::prelude::*;\n-\n use boxed;\n use boxed::Box;\n use vec::Vec;"}, {"sha": "3cc91bf54b4d92dec95082b79f2f223acba8b81e", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -172,18 +172,6 @@ impl Wtf8Buf {\n         Wtf8Buf { bytes: string.into_bytes() }\n     }\n \n-    #[cfg(stage0)]\n-    /// Create a WTF-8 string from an UTF-8 `&str` slice.\n-    ///\n-    /// This copies the content of the slice.\n-    ///\n-    /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n-    #[inline]\n-    pub fn from_str(str: &str) -> Wtf8Buf {\n-        Wtf8Buf { bytes: slice::SliceExt::to_vec(str.as_bytes()) }\n-    }\n-\n-    #[cfg(not(stage0))]\n     /// Create a WTF-8 string from an UTF-8 `&str` slice.\n     ///\n     /// This copies the content of the slice."}, {"sha": "3b8d18d87a0cafbe3f8d7c44237a4bf5fa17d27b", "filename": "src/libstd/sys/unix/os_str.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -16,8 +16,6 @@ use core::prelude::*;\n use borrow::Cow;\n use fmt::{self, Debug};\n use vec::Vec;\n-#[cfg(stage0)]\n-use slice::SliceExt as StdSliceExt;\n use str;\n use string::String;\n use mem;"}, {"sha": "4c2777459dd5d1810c789b46e556e336b975504f", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -128,8 +128,6 @@ impl Process {\n         use env::split_paths;\n         use mem;\n         use iter::IteratorExt;\n-        #[cfg(stage0)]\n-        use str::StrExt;\n \n         // To have the spawning semantics of unix/windows stay the same, we need to\n         // read the *child's* PATH if one is provided. See #15149 for more details."}, {"sha": "ad2fa3d25a879e39bd7de60b135c3181372f1ace", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -78,8 +78,6 @@ use owned_slice::OwnedSlice;\n use std::collections::HashSet;\n use std::io::prelude::*;\n use std::mem;\n-#[cfg(stage0)]\n-use std::num::Float;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use std::slice;\n@@ -5809,12 +5807,6 @@ impl<'a> Parser<'a> {\n         None\n     }\n \n-    // HACK(eddyb) staging required for `quote_item!`.\n-    #[cfg(stage0)] // SNAP 270a677\n-    pub fn parse_item_with_outer_attributes(&mut self) -> Option<P<Item>> {\n-        self.parse_item()\n-    }\n-\n     pub fn parse_item(&mut self) -> Option<P<Item>> {\n         let attrs = self.parse_outer_attributes();\n         self.parse_item_(attrs, true)"}, {"sha": "5850fed980a9f7590ce9780a02be78f13573a1e0", "filename": "src/libunicode/char.rs", "status": "modified", "additions": 0, "deletions": 408, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibunicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibunicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fchar.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -41,413 +41,6 @@ pub use normalize::{decompose_canonical, decompose_compatible, compose};\n pub use tables::normalization::canonical_combining_class;\n pub use tables::UNICODE_VERSION;\n \n-#[cfg(stage0)]\n-/// Functionality for manipulating `char`.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait CharExt {\n-    /// Checks if a `char` parses as a numeric digit in the given radix.\n-    ///\n-    /// Compared to `is_numeric()`, this function only recognizes the characters\n-    /// `0-9`, `a-z` and `A-Z`.\n-    ///\n-    /// # Return value\n-    ///\n-    /// Returns `true` if `c` is a valid digit under `radix`, and `false`\n-    /// otherwise.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if given a radix > 36.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let c = '1';\n-    ///\n-    /// assert!(c.is_digit(10));\n-    ///\n-    /// assert!('f'.is_digit(16));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_digit(self, radix: u32) -> bool;\n-\n-    /// Converts a character to the corresponding digit.\n-    ///\n-    /// # Return value\n-    ///\n-    /// If `c` is between '0' and '9', the corresponding value between 0 and\n-    /// 9. If `c` is 'a' or 'A', 10. If `c` is 'b' or 'B', 11, etc. Returns\n-    /// none if the character does not refer to a digit in the given radix.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if given a radix outside the range [0..36].\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let c = '1';\n-    ///\n-    /// assert_eq!(c.to_digit(10), Some(1));\n-    ///\n-    /// assert_eq!('f'.to_digit(16), Some(15));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn to_digit(self, radix: u32) -> Option<u32>;\n-\n-    /// Returns an iterator that yields the hexadecimal Unicode escape of a\n-    /// character, as `char`s.\n-    ///\n-    /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n-    /// where `NNNN` is the shortest hexadecimal representation of the code\n-    /// point.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// for i in '\u2764'.escape_unicode() {\n-    ///     println!(\"{}\", i);\n-    /// }\n-    /// ```\n-    ///\n-    /// This prints:\n-    ///\n-    /// ```text\n-    /// \\\n-    /// u\n-    /// {\n-    /// 2\n-    /// 7\n-    /// 6\n-    /// 4\n-    /// }\n-    /// ```\n-    ///\n-    /// Collecting into a `String`:\n-    ///\n-    /// ```\n-    /// let heart: String = '\u2764'.escape_unicode().collect();\n-    ///\n-    /// assert_eq!(heart, r\"\\u{2764}\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn escape_unicode(self) -> EscapeUnicode;\n-\n-    /// Returns an iterator that yields the 'default' ASCII and\n-    /// C++11-like literal escape of a character, as `char`s.\n-    ///\n-    /// The default is chosen with a bias toward producing literals that are\n-    /// legal in a variety of languages, including C++11 and similar C-family\n-    /// languages. The exact rules are:\n-    ///\n-    /// * Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n-    /// * Single-quote, double-quote and backslash chars are backslash-\n-    ///   escaped.\n-    /// * Any other chars in the range [0x20,0x7e] are not escaped.\n-    /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// for i in '\"'.escape_default() {\n-    ///     println!(\"{}\", i);\n-    /// }\n-    /// ```\n-    ///\n-    /// This prints:\n-    ///\n-    /// ```text\n-    /// \\\n-    /// \"\n-    /// ```\n-    ///\n-    /// Collecting into a `String`:\n-    ///\n-    /// ```\n-    /// let quote: String = '\"'.escape_default().collect();\n-    ///\n-    /// assert_eq!(quote, \"\\\\\\\"\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn escape_default(self) -> EscapeDefault;\n-\n-    /// Returns the number of bytes this character would need if encoded in\n-    /// UTF-8.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let n = '\u00df'.len_utf8();\n-    ///\n-    /// assert_eq!(n, 2);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf8(self) -> usize;\n-\n-    /// Returns the number of 16-bit code units this character would need if\n-    /// encoded in UTF-16.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let n = '\u00df'.len_utf16();\n-    ///\n-    /// assert_eq!(n, 1);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf16(self) -> usize;\n-\n-    /// Encodes this character as UTF-8 into the provided byte buffer, and then\n-    /// returns the number of bytes written.\n-    ///\n-    /// If the buffer is not large enough, nothing will be written into it and a\n-    /// `None` will be returned. A buffer of length four is large enough to\n-    /// encode any `char`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// In both of these examples, '\u00df' takes two bytes to encode.\n-    ///\n-    /// ```\n-    /// let mut b = [0; 2];\n-    ///\n-    /// let result = '\u00df'.encode_utf8(&mut b);\n-    ///\n-    /// assert_eq!(result, Some(2));\n-    /// ```\n-    ///\n-    /// A buffer that's too small:\n-    ///\n-    /// ```\n-    /// let mut b = [0; 1];\n-    ///\n-    /// let result = '\u00df'.encode_utf8(&mut b);\n-    ///\n-    /// assert_eq!(result, None);\n-    /// ```\n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;\n-\n-    /// Encodes this character as UTF-16 into the provided `u16` buffer, and\n-    /// then returns the number of `u16`s written.\n-    ///\n-    /// If the buffer is not large enough, nothing will be written into it and a\n-    /// `None` will be returned. A buffer of length 2 is large enough to encode\n-    /// any `char`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// In both of these examples, '\u00df' takes one `u16` to encode.\n-    ///\n-    /// ```\n-    /// let mut b = [0; 1];\n-    ///\n-    /// let result = '\u00df'.encode_utf16(&mut b);\n-    ///\n-    /// assert_eq!(result, Some(1));\n-    /// ```\n-    ///\n-    /// A buffer that's too small:\n-    ///\n-    /// ```\n-    /// let mut b = [0; 0];\n-    ///\n-    /// let result = '\u00df'.encode_utf8(&mut b);\n-    ///\n-    /// assert_eq!(result, None);\n-    /// ```\n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;\n-\n-    /// Returns whether the specified character is considered a Unicode\n-    /// alphabetic code point.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_alphabetic(self) -> bool;\n-\n-    /// Returns whether the specified character satisfies the 'XID_Start'\n-    /// Unicode property.\n-    ///\n-    /// 'XID_Start' is a Unicode Derived Property specified in\n-    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-    /// mostly similar to ID_Start but modified for closure under NFKx.\n-    #[unstable(feature = \"unicode\",\n-               reason = \"mainly needed for compiler internals\")]\n-    fn is_xid_start(self) -> bool;\n-\n-    /// Returns whether the specified `char` satisfies the 'XID_Continue'\n-    /// Unicode property.\n-    ///\n-    /// 'XID_Continue' is a Unicode Derived Property specified in\n-    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-    /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n-    #[unstable(feature = \"unicode\",\n-               reason = \"mainly needed for compiler internals\")]\n-    fn is_xid_continue(self) -> bool;\n-\n-    /// Indicates whether a character is in lowercase.\n-    ///\n-    /// This is defined according to the terms of the Unicode Derived Core\n-    /// Property `Lowercase`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_lowercase(self) -> bool;\n-\n-    /// Indicates whether a character is in uppercase.\n-    ///\n-    /// This is defined according to the terms of the Unicode Derived Core\n-    /// Property `Uppercase`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_uppercase(self) -> bool;\n-\n-    /// Indicates whether a character is whitespace.\n-    ///\n-    /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_whitespace(self) -> bool;\n-\n-    /// Indicates whether a character is alphanumeric.\n-    ///\n-    /// Alphanumericness is defined in terms of the Unicode General Categories\n-    /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_alphanumeric(self) -> bool;\n-\n-    /// Indicates whether a character is a control code point.\n-    ///\n-    /// Control code points are defined in terms of the Unicode General\n-    /// Category `Cc`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_control(self) -> bool;\n-\n-    /// Indicates whether the character is numeric (Nd, Nl, or No).\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_numeric(self) -> bool;\n-\n-    /// Converts a character to its lowercase equivalent.\n-    ///\n-    /// The case-folding performed is the common or simple mapping. See\n-    /// `to_uppercase()` for references and more information.\n-    ///\n-    /// # Return value\n-    ///\n-    /// Returns an iterator which yields the characters corresponding to the\n-    /// lowercase equivalent of the character. If no conversion is possible then\n-    /// the input character is returned.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn to_lowercase(self) -> ToLowercase;\n-\n-    /// Converts a character to its uppercase equivalent.\n-    ///\n-    /// The case-folding performed is the common or simple mapping: it maps\n-    /// one Unicode codepoint to its uppercase equivalent according to the\n-    /// Unicode database [1]. The additional [`SpecialCasing.txt`] is not yet\n-    /// considered here, but the iterator returned will soon support this form\n-    /// of case folding.\n-    ///\n-    /// A full reference can be found here [2].\n-    ///\n-    /// # Return value\n-    ///\n-    /// Returns an iterator which yields the characters corresponding to the\n-    /// uppercase equivalent of the character. If no conversion is possible then\n-    /// the input character is returned.\n-    ///\n-    /// [1]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n-    ///\n-    /// [`SpecialCasing`.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n-    ///\n-    /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn to_uppercase(self) -> ToUppercase;\n-\n-    /// Returns this character's displayed width in columns, or `None` if it is a\n-    /// control character other than `'\\x00'`.\n-    ///\n-    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n-    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n-    /// In CJK contexts, `is_cjk` should be `true`, else it should be `false`.\n-    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n-    /// recommends that these characters be treated as 1 column (i.e.,\n-    /// `is_cjk` = `false`) if the context cannot be reliably determined.\n-    #[unstable(feature = \"unicode\",\n-               reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n-    fn width(self, is_cjk: bool) -> Option<usize>;\n-}\n-\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl CharExt for char {\n-    fn is_digit(self, radix: u32) -> bool { C::is_digit(self, radix) }\n-    fn to_digit(self, radix: u32) -> Option<u32> { C::to_digit(self, radix) }\n-    fn escape_unicode(self) -> EscapeUnicode { C::escape_unicode(self) }\n-    fn escape_default(self) -> EscapeDefault { C::escape_default(self) }\n-    fn len_utf8(self) -> usize { C::len_utf8(self) }\n-    fn len_utf16(self) -> usize { C::len_utf16(self) }\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> { C::encode_utf8(self, dst) }\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> { C::encode_utf16(self, dst) }\n-\n-    fn is_alphabetic(self) -> bool {\n-        match self {\n-            'a' ... 'z' | 'A' ... 'Z' => true,\n-            c if c > '\\x7f' => derived_property::Alphabetic(c),\n-            _ => false\n-        }\n-    }\n-\n-    fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n-\n-    fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n-\n-    fn is_lowercase(self) -> bool {\n-        match self {\n-            'a' ... 'z' => true,\n-            c if c > '\\x7f' => derived_property::Lowercase(c),\n-            _ => false\n-        }\n-    }\n-\n-    fn is_uppercase(self) -> bool {\n-        match self {\n-            'A' ... 'Z' => true,\n-            c if c > '\\x7f' => derived_property::Uppercase(c),\n-            _ => false\n-        }\n-    }\n-\n-    fn is_whitespace(self) -> bool {\n-        match self {\n-            ' ' | '\\x09' ... '\\x0d' => true,\n-            c if c > '\\x7f' => property::White_Space(c),\n-            _ => false\n-        }\n-    }\n-\n-    fn is_alphanumeric(self) -> bool {\n-        self.is_alphabetic() || self.is_numeric()\n-    }\n-\n-    fn is_control(self) -> bool { general_category::Cc(self) }\n-\n-    fn is_numeric(self) -> bool {\n-        match self {\n-            '0' ... '9' => true,\n-            c if c > '\\x7f' => general_category::N(c),\n-            _ => false\n-        }\n-    }\n-\n-    fn to_lowercase(self) -> ToLowercase {\n-        ToLowercase(Some(conversions::to_lower(self)))\n-    }\n-\n-    fn to_uppercase(self) -> ToUppercase {\n-        ToUppercase(Some(conversions::to_upper(self)))\n-    }\n-\n-    fn width(self, is_cjk: bool) -> Option<usize> { charwidth::width(self, is_cjk) }\n-}\n-\n /// An iterator over the lowercase mapping of a given character, returned from\n /// the `lowercase` method on characters.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -470,7 +63,6 @@ impl Iterator for ToUppercase {\n     fn next(&mut self) -> Option<char> { self.0.take() }\n }\n \n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"char\"]\n impl char {"}, {"sha": "485065685f1dfdfa6a934be2eb44a22350d3b811", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -26,8 +26,6 @@ use core::num::Int;\n use core::slice;\n use core::str::Split;\n \n-#[cfg(stage0)]\n-use char::CharExt as UCharExt; // conflicts with core::prelude::CharExt\n use tables::grapheme::GraphemeCat;\n \n /// An iterator over the words of a string, separated by a sequence of whitespace\n@@ -244,7 +242,7 @@ impl<'a> Iterator for Graphemes<'a> {\n         }\n \n         self.cat = if take_curr {\n-            idx = idx + len_utf8(self.string.char_at(idx));\n+            idx = idx + self.string.char_at(idx).len_utf8();\n             None\n         } else {\n             Some(cat)\n@@ -256,11 +254,6 @@ impl<'a> Iterator for Graphemes<'a> {\n     }\n }\n \n-#[cfg(stage0)]\n-fn len_utf8(c: char) -> usize { UCharExt::len_utf8(c) }\n-#[cfg(not(stage0))]\n-fn len_utf8(c: char) -> usize { c.len_utf8() }\n-\n impl<'a> DoubleEndedIterator for Graphemes<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {"}, {"sha": "09fcd518c1e7e3998f32851738559f36840d845d", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -14,6 +14,7 @@\n #![feature(exit_status)]\n #![feature(rustdoc)]\n #![feature(rustc_private)]\n+#![feature(path_relative_from)]\n \n extern crate rustdoc;\n extern crate rustc_back;"}, {"sha": "3bdf32b53fa8731a65c5a7a7b4b034842538edd6", "filename": "src/snapshots.txt", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12cb7c6a2847959460ecac75b2c983d071585472/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/12cb7c6a2847959460ecac75b2c983d071585472/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=12cb7c6a2847959460ecac75b2c983d071585472", "patch": "@@ -1,3 +1,13 @@\n+S 2015-03-17 c64d671\n+  bitrig-x86_64 4b2f11a96b1b5b3782d74bda707aca33bc179880\n+  freebsd-x86_64 14ced24e1339a4dd8baa9db69995daa52a948d54\n+  linux-i386 200450ad3cc56bc715ca105b9acae35204bf7351\n+  linux-x86_64 a54f50fee722ba6bc7281dec3e4d5121af7c15e3\n+  macos-i386 e33fd692f3808a0265e7b02fbc40e403080cdd4f\n+  macos-x86_64 9a89ed364ae71aeb9d659ad223eae5f5986fc03f\n+  winnt-i386 8911a28581e490d413b56467a6184545633ca04a\n+  winnt-x86_64 38ce4556b19472c23ccce28685e3a2ebefb9bfbc\n+\n S 2015-03-07 270a677\n   bitrig-x86_64 4b2f11a96b1b5b3782d74bda707aca33bc179880\n   freebsd-x86_64 3c147d8e4cfdcb02c2569f5aca689a1d8920d17b"}]}