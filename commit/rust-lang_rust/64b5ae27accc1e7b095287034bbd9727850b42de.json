{"sha": "64b5ae27accc1e7b095287034bbd9727850b42de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YjVhZTI3YWNjYzFlN2IwOTUyODcwMzRiYmQ5NzI3ODUwYjQyZGU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-07T23:01:45Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-07T23:01:45Z"}, "message": "Start annotating FIXMEs in typestate; also some minor refactoring", "tree": {"sha": "9f582d19e6b8df37d11fa71634a1235e4129ad5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f582d19e6b8df37d11fa71634a1235e4129ad5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64b5ae27accc1e7b095287034bbd9727850b42de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64b5ae27accc1e7b095287034bbd9727850b42de", "html_url": "https://github.com/rust-lang/rust/commit/64b5ae27accc1e7b095287034bbd9727850b42de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64b5ae27accc1e7b095287034bbd9727850b42de/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b2cfe793b26a15abfc10641b1f301eee4763339", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b2cfe793b26a15abfc10641b1f301eee4763339", "html_url": "https://github.com/rust-lang/rust/commit/6b2cfe793b26a15abfc10641b1f301eee4763339"}], "stats": {"total": 70, "additions": 19, "deletions": 51}, "files": [{"sha": "a6a46d1e222e94c6710f053c44c004d0edbd6f7b", "filename": "src/rustc/middle/tstate/ann.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64b5ae27accc1e7b095287034bbd9727850b42de/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b5ae27accc1e7b095287034bbd9727850b42de/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs?ref=64b5ae27accc1e7b095287034bbd9727850b42de", "patch": "@@ -34,7 +34,7 @@ type poststate = t;\n type pre_and_post = {precondition: precond, postcondition: postcond};\n \n \n-/* FIXME: once it's implemented: */\n+/* FIXME: once it's implemented: (Issue #34) */\n \n //  : ((*.precondition).nbits == (*.postcondition).nbits);\n type pre_and_post_state = {prestate: prestate, poststate: poststate};\n@@ -196,7 +196,6 @@ fn extend_poststate(p: poststate, newv: poststate) -> bool {\n }\n \n // Sets the given bit in p to \"don't care\"\n-// FIXME: is this correct?\n fn relax_prestate(i: uint, p: prestate) -> bool {\n     let was_set = tritv_get(p, i);\n     tritv_set(i, p, dont_care);\n@@ -234,7 +233,6 @@ fn clone(p: prestate) -> prestate { ret tritv_clone(p); }\n // returns true if a implies b\n // that is, returns true except if for some bits c and d,\n // c = 1 and d = either 0 or \"don't know\"\n-// FIXME: is this correct?\n fn implies(a: t, b: t) -> bool {\n     let tmp = tritv_clone(b);\n     tritv_difference(tmp, a);\n@@ -244,6 +242,10 @@ fn implies(a: t, b: t) -> bool {\n fn trit_str(t: trit) -> str {\n     alt t { dont_care { \"?\" } ttrue { \"1\" } tfalse { \"0\" } }\n }\n+\n+// FIXME: Would be nice to have unit tests for some of these operations, as\n+// a step towards formalizing them more rigorously. #2538\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "b97e6b21c3988a6cfe02d7199cbedcea3c52185f", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 14, "deletions": 48, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/64b5ae27accc1e7b095287034bbd9727850b42de/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b5ae27accc1e7b095287034bbd9727850b42de/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=64b5ae27accc1e7b095287034bbd9727850b42de", "patch": "@@ -196,7 +196,7 @@ may be the operator in a \"check\" expression in the source.  */\n type constraint = {\n     path: @path,\n     // FIXME: really only want it to be mut during collect_locals.\n-    // freeze it after that.\n+    // freeze it after that. (#2539)\n     descs: @dvec<pred_args>\n };\n \n@@ -496,7 +496,7 @@ fn constraints(fcx: fn_ctxt) -> [norm_constraint] {\n \n // FIXME\n // Would rather take an immutable vec as an argument,\n-// should freeze it at some earlier point.\n+// should freeze it at some earlier point. (#2539)\n fn match_args(fcx: fn_ctxt, occs: @dvec<pred_args>,\n               occ: [@constr_arg_use]) -> uint {\n     #debug(\"match_args: looking at %s\",\n@@ -715,28 +715,23 @@ fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>] {\n             }\n           }\n           _ {\n-            //  #error(\"##\");\n             rslt += [c.node];\n           }\n         }\n     }\n \n-    /*\n-    for (constr_arg_general_<tup(ident, def_id)> p in rslt) {\n-        alt (p) {\n-            case (carg_ident(?p)) {\n-                log(error, p._0);\n-            }\n-            case (_) {}\n-        }\n-    }\n-    */\n-\n     ret rslt;\n }\n \n enum if_ty { if_check, plain_if, }\n \n+fn for_constraints_mentioning(fcx: fn_ctxt, id: node_id,\n+                              f: fn(norm_constraint)) {\n+    for constraints(fcx).each {|c|\n+        if constraint_mentions(fcx, c, id) { f(c); }\n+    };\n+}\n+\n fn local_node_id_to_def_id_strict(fcx: fn_ctxt, sp: span, i: node_id) ->\n    def_id {\n     alt local_node_id_to_def(fcx, i) {\n@@ -787,7 +782,6 @@ fn copy_in_postcond(fcx: fn_ctxt, parent_exp: node_id, dest: inst, src: inst,\n     copy_in_poststate_two(fcx, post, post, dest, src, ty);\n }\n \n-// FIXME refactor\n fn copy_in_poststate(fcx: fn_ctxt, post: poststate, dest: inst, src: inst,\n                      ty: oper_type) {\n     copy_in_poststate_two(fcx, post, post, dest, src, ty);\n@@ -823,42 +817,31 @@ fn copy_in_poststate_two(fcx: fn_ctxt, src_post: poststate,\n     };\n }\n \n-/* FIXME should refactor this better */\n fn forget_in_postcond(fcx: fn_ctxt, parent_exp: node_id, dead_v: node_id) {\n     // In the postcondition given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n-    alt d {\n-      some(d_id) {\n-        for constraints(fcx).each {|c|\n-            if constraint_mentions(fcx, c, d_id) {\n+    option::iter(d) {|d_id|\n+        for_constraints_mentioning(fcx, d_id) {|c|\n                 #debug(\"clearing constraint %u %s\",\n                        c.bit_num,\n                        constraint_to_str(fcx.ccx.tcx, c.c));\n                 clear_in_postcond(c.bit_num,\n                                   node_id_to_ts_ann(fcx.ccx,\n                                                     parent_exp).conditions);\n-            }\n         }\n-      }\n-      _ { }\n-    }\n+    };\n }\n \n fn forget_in_poststate(fcx: fn_ctxt, p: poststate, dead_v: node_id) -> bool {\n     // In the poststate given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n     let mut changed = false;\n-    alt d {\n-      some(d_id) {\n-        for constraints(fcx).each {|c|\n-            if constraint_mentions(fcx, c, d_id) {\n+    option::iter(d) {|d_id|\n+        for_constraints_mentioning(fcx, d_id) {|c|\n                 changed |= clear_in_poststate_(c.bit_num, p);\n-            }\n         }\n-      }\n-      _ { }\n     }\n     ret changed;\n }\n@@ -876,23 +859,6 @@ fn constraint_mentions(_fcx: fn_ctxt, c: norm_constraint, v: node_id) ->\n fn args_mention<T>(args: [@constr_arg_use],\n                    q: fn([T], node_id) -> bool,\n                    s: [T]) -> bool {\n-    /*\n-      FIXME\n-      The following version causes an assertion in trans to fail\n-      (something about type_is_tup_like)\n-    fn mentions<T>(&[T] s, &fn(&[T], def_id) -> bool q,\n-                            &@constr_arg_use a) -> bool {\n-        alt (a.node) {\n-            case (carg_ident(?p1)) {\n-                auto res = q(s, p1._1);\n-                log(error, (res));\n-                res\n-                    }\n-            case (_)               { false }\n-        }\n-    }\n-    ret vec::any(bind mentions(s,q,_), args);\n-    */\n \n     for args.each {|a|\n         alt a.node { carg_ident(p1) { if q(s, p1.node) { ret true; } } _ { } }"}]}