{"sha": "f042d749b0fc212bff6bdc44b84e134b878bff64", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNDJkNzQ5YjBmYzIxMmJmZjZiZGM0NGI4NGUxMzRiODc4YmZmNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-02T19:48:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-02T19:48:44Z"}, "message": "Auto merge of #74826 - matklad:mbe-fragment, r=petrochenkov\n\nIntroduce NonterminalKind for more type-safe mbe parsing\n\nIt encapsulate the (part of) the interface between the parser and\nmacro by example (macro_rules) parser.\n\nThe second bit is somewhat more general `parse_ast_fragment`, which is\nthe reason why we keep some `parse_xxx` functions as public.", "tree": {"sha": "72b5578e9fe767f8825245ad343b0d269173df40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72b5578e9fe767f8825245ad343b0d269173df40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f042d749b0fc212bff6bdc44b84e134b878bff64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f042d749b0fc212bff6bdc44b84e134b878bff64", "html_url": "https://github.com/rust-lang/rust/commit/f042d749b0fc212bff6bdc44b84e134b878bff64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f042d749b0fc212bff6bdc44b84e134b878bff64/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19cefa68640843956eedd86227ddc1d35dbc6754", "url": "https://api.github.com/repos/rust-lang/rust/commits/19cefa68640843956eedd86227ddc1d35dbc6754", "html_url": "https://github.com/rust-lang/rust/commit/19cefa68640843956eedd86227ddc1d35dbc6754"}, {"sha": "1a2d07e084cf2f3bacbdfd6530ce802a046c75c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a2d07e084cf2f3bacbdfd6530ce802a046c75c0", "html_url": "https://github.com/rust-lang/rust/commit/1a2d07e084cf2f3bacbdfd6530ce802a046c75c0"}], "stats": {"total": 658, "additions": 319, "deletions": 339}, "files": [{"sha": "e1c94ddf782881d16571fa154727471f1f2159c3", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=f042d749b0fc212bff6bdc44b84e134b878bff64", "patch": "@@ -704,6 +704,67 @@ pub enum Nonterminal {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(Nonterminal, 40);\n \n+#[derive(Debug, Copy, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+pub enum NonterminalKind {\n+    Item,\n+    Block,\n+    Stmt,\n+    Pat,\n+    Expr,\n+    Ty,\n+    Ident,\n+    Lifetime,\n+    Literal,\n+    Meta,\n+    Path,\n+    Vis,\n+    TT,\n+}\n+\n+impl NonterminalKind {\n+    pub fn from_symbol(symbol: Symbol) -> Option<NonterminalKind> {\n+        Some(match symbol {\n+            sym::item => NonterminalKind::Item,\n+            sym::block => NonterminalKind::Block,\n+            sym::stmt => NonterminalKind::Stmt,\n+            sym::pat => NonterminalKind::Pat,\n+            sym::expr => NonterminalKind::Expr,\n+            sym::ty => NonterminalKind::Ty,\n+            sym::ident => NonterminalKind::Ident,\n+            sym::lifetime => NonterminalKind::Lifetime,\n+            sym::literal => NonterminalKind::Literal,\n+            sym::meta => NonterminalKind::Meta,\n+            sym::path => NonterminalKind::Path,\n+            sym::vis => NonterminalKind::Vis,\n+            sym::tt => NonterminalKind::TT,\n+            _ => return None,\n+        })\n+    }\n+    fn symbol(self) -> Symbol {\n+        match self {\n+            NonterminalKind::Item => sym::item,\n+            NonterminalKind::Block => sym::block,\n+            NonterminalKind::Stmt => sym::stmt,\n+            NonterminalKind::Pat => sym::pat,\n+            NonterminalKind::Expr => sym::expr,\n+            NonterminalKind::Ty => sym::ty,\n+            NonterminalKind::Ident => sym::ident,\n+            NonterminalKind::Lifetime => sym::lifetime,\n+            NonterminalKind::Literal => sym::literal,\n+            NonterminalKind::Meta => sym::meta,\n+            NonterminalKind::Path => sym::path,\n+            NonterminalKind::Vis => sym::vis,\n+            NonterminalKind::TT => sym::tt,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for NonterminalKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.symbol())\n+    }\n+}\n+\n impl Nonterminal {\n     fn span(&self) -> Span {\n         match self {"}, {"sha": "6f2daaa81c02f5a6b1bd9669539afbce2d7edb83", "filename": "src/librustc_expand/mbe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_expand%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_expand%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe.rs?ref=f042d749b0fc212bff6bdc44b84e134b878bff64", "patch": "@@ -9,7 +9,7 @@ crate mod macro_rules;\n crate mod quoted;\n crate mod transcribe;\n \n-use rustc_ast::token::{self, Token, TokenKind};\n+use rustc_ast::token::{self, NonterminalKind, Token, TokenKind};\n use rustc_ast::tokenstream::DelimSpan;\n \n use rustc_span::symbol::Ident;\n@@ -84,7 +84,7 @@ enum TokenTree {\n     /// e.g., `$var`\n     MetaVar(Span, Ident),\n     /// e.g., `$var:expr`. This is only used in the left hand side of MBE macros.\n-    MetaVarDecl(Span, Ident /* name to bind */, Ident /* kind of nonterminal */),\n+    MetaVarDecl(Span, Ident /* name to bind */, Option<NonterminalKind>),\n }\n \n impl TokenTree {"}, {"sha": "d2fe7fe10a8301b1cd24cdbe4d23a78b2690f04b", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 17, "deletions": 189, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=f042d749b0fc212bff6bdc44b84e134b878bff64", "patch": "@@ -76,15 +76,11 @@ use TokenTreeOrTokenTreeSlice::*;\n \n use crate::mbe::{self, TokenTree};\n \n-use rustc_ast::ptr::P;\n use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n-use rustc_ast_pretty::pprust;\n-use rustc_parse::parser::{FollowedByType, Parser, PathStyle};\n+use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n-use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent, Symbol};\n+use rustc_span::symbol::MacroRulesNormalizedIdent;\n \n-use rustc_errors::PResult;\n-use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -382,7 +378,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n                     n_rec(sess, next_m, res.by_ref(), ret_val)?;\n                 }\n             }\n-            TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n+            TokenTree::MetaVarDecl(span, _, None) => {\n                 if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                     return Err((span, \"missing fragment specifier\".to_string()));\n                 }\n@@ -565,18 +561,18 @@ fn inner_parse_loop<'root, 'tt>(\n                 }\n \n                 // We need to match a metavar (but the identifier is invalid)... this is an error\n-                TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n+                TokenTree::MetaVarDecl(span, _, None) => {\n                     if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                         return Error(span, \"missing fragment specifier\".to_string());\n                     }\n                 }\n \n                 // We need to match a metavar with a valid ident... call out to the black-box\n                 // parser by adding an item to `bb_items`.\n-                TokenTree::MetaVarDecl(_, _, id) => {\n+                TokenTree::MetaVarDecl(_, _, Some(kind)) => {\n                     // Built-in nonterminals never start with these tokens,\n                     // so we can eliminate them from consideration.\n-                    if may_begin_with(token, id.name) {\n+                    if Parser::nonterminal_may_begin_with(kind, token) {\n                         bb_items.push(item);\n                     }\n                 }\n@@ -706,7 +702,7 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             let nts = bb_items\n                 .iter()\n                 .map(|item| match item.top_elts.get_tt(item.idx) {\n-                    TokenTree::MetaVarDecl(_, bind, name) => format!(\"{} ('{}')\", name, bind),\n+                    TokenTree::MetaVarDecl(_, bind, Some(kind)) => format!(\"{} ('{}')\", kind, bind),\n                     _ => panic!(),\n                 })\n                 .collect::<Vec<String>>()\n@@ -736,10 +732,17 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             assert_eq!(bb_items.len(), 1);\n \n             let mut item = bb_items.pop().unwrap();\n-            if let TokenTree::MetaVarDecl(span, _, ident) = item.top_elts.get_tt(item.idx) {\n+            if let TokenTree::MetaVarDecl(span, _, Some(kind)) = item.top_elts.get_tt(item.idx) {\n                 let match_cur = item.match_cur;\n-                let nt = match parse_nt(parser.to_mut(), span, ident.name) {\n-                    Err(()) => return ErrorReported,\n+                let nt = match parser.to_mut().parse_nonterminal(kind) {\n+                    Err(mut err) => {\n+                        err.span_label(\n+                            span,\n+                            format!(\"while parsing argument for this `{}` macro fragment\", kind),\n+                        )\n+                        .emit();\n+                        return ErrorReported;\n+                    }\n                     Ok(nt) => nt,\n                 };\n                 item.push_match(match_cur, MatchedNonterminal(Lrc::new(nt)));\n@@ -754,178 +757,3 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n         assert!(!cur_items.is_empty());\n     }\n }\n-\n-/// The token is an identifier, but not `_`.\n-/// We prohibit passing `_` to macros expecting `ident` for now.\n-fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n-    token.ident().filter(|(ident, _)| ident.name != kw::Underscore)\n-}\n-\n-/// Checks whether a non-terminal may begin with a particular token.\n-///\n-/// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n-/// token. Be conservative (return true) if not sure.\n-fn may_begin_with(token: &Token, name: Symbol) -> bool {\n-    /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n-    fn may_be_ident(nt: &token::Nonterminal) -> bool {\n-        match *nt {\n-            token::NtItem(_) | token::NtBlock(_) | token::NtVis(_) | token::NtLifetime(_) => false,\n-            _ => true,\n-        }\n-    }\n-\n-    match name {\n-        sym::expr => {\n-            token.can_begin_expr()\n-            // This exception is here for backwards compatibility.\n-            && !token.is_keyword(kw::Let)\n-        }\n-        sym::ty => token.can_begin_type(),\n-        sym::ident => get_macro_ident(token).is_some(),\n-        sym::literal => token.can_begin_literal_maybe_minus(),\n-        sym::vis => match token.kind {\n-            // The follow-set of :vis + \"priv\" keyword + interpolated\n-            token::Comma | token::Ident(..) | token::Interpolated(..) => true,\n-            _ => token.can_begin_type(),\n-        },\n-        sym::block => match token.kind {\n-            token::OpenDelim(token::Brace) => true,\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtItem(_)\n-                | token::NtPat(_)\n-                | token::NtTy(_)\n-                | token::NtIdent(..)\n-                | token::NtMeta(_)\n-                | token::NtPath(_)\n-                | token::NtVis(_) => false, // none of these may start with '{'.\n-                _ => true,\n-            },\n-            _ => false,\n-        },\n-        sym::path | sym::meta => match token.kind {\n-            token::ModSep | token::Ident(..) => true,\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtPath(_) | token::NtMeta(_) => true,\n-                _ => may_be_ident(&nt),\n-            },\n-            _ => false,\n-        },\n-        sym::pat => match token.kind {\n-            token::Ident(..) |               // box, ref, mut, and other identifiers (can stricten)\n-            token::OpenDelim(token::Paren) |    // tuple pattern\n-            token::OpenDelim(token::Bracket) |  // slice pattern\n-            token::BinOp(token::And) |          // reference\n-            token::BinOp(token::Minus) |        // negative literal\n-            token::AndAnd |                     // double reference\n-            token::Literal(..) |                // literal\n-            token::DotDot |                     // range pattern (future compat)\n-            token::DotDotDot |                  // range pattern (future compat)\n-            token::ModSep |                     // path\n-            token::Lt |                         // path (UFCS constant)\n-            token::BinOp(token::Shl) => true,   // path (double UFCS)\n-            token::Interpolated(ref nt) => may_be_ident(nt),\n-            _ => false,\n-        },\n-        sym::lifetime => match token.kind {\n-            token::Lifetime(_) => true,\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtLifetime(_) | token::NtTT(_) => true,\n-                _ => false,\n-            },\n-            _ => false,\n-        },\n-        _ => match token.kind {\n-            token::CloseDelim(_) => false,\n-            _ => true,\n-        },\n-    }\n-}\n-\n-/// A call to the \"black-box\" parser to parse some Rust non-terminal.\n-///\n-/// # Parameters\n-///\n-/// - `p`: the \"black-box\" parser to use\n-/// - `sp`: the `Span` we want to parse\n-/// - `name`: the name of the metavar _matcher_ we want to match (e.g., `tt`, `ident`, `block`,\n-///   etc...)\n-///\n-/// # Returns\n-///\n-/// The parsed non-terminal.\n-fn parse_nt(p: &mut Parser<'_>, sp: Span, name: Symbol) -> Result<Nonterminal, ()> {\n-    // FIXME(Centril): Consider moving this to `parser.rs` to make\n-    // the visibilities of the methods used below `pub(super)` at most.\n-    if name == sym::tt {\n-        return Ok(token::NtTT(p.parse_token_tree()));\n-    }\n-    parse_nt_inner(p, sp, name).map_err(|mut err| {\n-        err.span_label(sp, format!(\"while parsing argument for this `{}` macro fragment\", name))\n-            .emit()\n-    })\n-}\n-\n-fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a, Nonterminal> {\n-    // Any `Nonterminal` which stores its tokens (currently `NtItem` and `NtExpr`)\n-    // needs to have them force-captured here.\n-    // A `macro_rules!` invocation may pass a captured item/expr to a proc-macro,\n-    // which requires having captured tokens available. Since we cannot determine\n-    // in advance whether or not a proc-macro will be (transitively) invoked,\n-    // we always capture tokens for any `Nonterminal` which needs them.\n-    Ok(match name {\n-        sym::item => match p.collect_tokens(|this| this.parse_item())? {\n-            (Some(mut item), tokens) => {\n-                // If we captured tokens during parsing (due to outer attributes),\n-                // use those.\n-                if item.tokens.is_none() {\n-                    item.tokens = Some(tokens);\n-                }\n-                token::NtItem(item)\n-            }\n-            (None, _) => return Err(p.struct_span_err(p.token.span, \"expected an item keyword\")),\n-        },\n-        sym::block => token::NtBlock(p.parse_block()?),\n-        sym::stmt => match p.parse_stmt()? {\n-            Some(s) => token::NtStmt(s),\n-            None => return Err(p.struct_span_err(p.token.span, \"expected a statement\")),\n-        },\n-        sym::pat => token::NtPat(p.parse_pat(None)?),\n-        sym::expr => {\n-            let (mut expr, tokens) = p.collect_tokens(|this| this.parse_expr())?;\n-            // If we captured tokens during parsing (due to outer attributes),\n-            // use those.\n-            if expr.tokens.is_none() {\n-                expr.tokens = Some(tokens);\n-            }\n-            token::NtExpr(expr)\n-        }\n-        sym::literal => token::NtLiteral(p.parse_literal_maybe_minus()?),\n-        sym::ty => token::NtTy(p.parse_ty()?),\n-        // this could be handled like a token, since it is one\n-        sym::ident => {\n-            if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n-                p.bump();\n-                token::NtIdent(ident, is_raw)\n-            } else {\n-                let token_str = pprust::token_to_string(&p.token);\n-                let msg = &format!(\"expected ident, found {}\", &token_str);\n-                return Err(p.struct_span_err(p.token.span, msg));\n-            }\n-        }\n-        sym::path => token::NtPath(p.parse_path(PathStyle::Type)?),\n-        sym::meta => token::NtMeta(P(p.parse_attr_item()?)),\n-        sym::vis => token::NtVis(p.parse_visibility(FollowedByType::Yes)?),\n-        sym::lifetime => {\n-            if p.check_lifetime() {\n-                token::NtLifetime(p.expect_lifetime().ident)\n-            } else {\n-                let token_str = pprust::token_to_string(&p.token);\n-                let msg = &format!(\"expected a lifetime, found `{}`\", &token_str);\n-                return Err(p.struct_span_err(p.token.span, msg));\n-            }\n-        }\n-        // this is not supposed to happen, since it has been checked\n-        // when compiling the macro.\n-        _ => p.span_bug(sp, \"invalid fragment specifier\"),\n-    })\n-}"}, {"sha": "74d4023b41075b52e4872b2518ac4f5be8c6c8ec", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 43, "deletions": 132, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=f042d749b0fc212bff6bdc44b84e134b878bff64", "patch": "@@ -9,7 +9,7 @@ use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq};\n use crate::mbe::transcribe::transcribe;\n \n use rustc_ast::ast;\n-use rustc_ast::token::{self, NtTT, Token, TokenKind::*};\n+use rustc_ast::token::{self, NonterminalKind, NtTT, Token, TokenKind::*};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n@@ -21,18 +21,14 @@ use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent};\n use rustc_span::Span;\n \n use log::debug;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::{mem, slice};\n \n-const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n-                                        `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `lifetime`, \\\n-                                        `literal`, `path`, `meta`, `tt`, `item` and `vis`\";\n-\n crate struct ParserAnyMacro<'a> {\n     parser: Parser<'a>,\n \n@@ -403,7 +399,7 @@ pub fn compile_declarative_macro(\n     let diag = &sess.span_diagnostic;\n     let lhs_nm = Ident::new(sym::lhs, def.span);\n     let rhs_nm = Ident::new(sym::rhs, def.span);\n-    let tt_spec = Ident::new(sym::tt, def.span);\n+    let tt_spec = Some(NonterminalKind::TT);\n \n     // Parse the macro_rules! invocation\n     let (macro_rules, body) = match &def.kind {\n@@ -571,7 +567,7 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n             TokenTree::Sequence(span, ref seq) => {\n                 if seq.separator.is_none()\n                     && seq.tts.iter().all(|seq_tt| match *seq_tt {\n-                        TokenTree::MetaVarDecl(_, _, id) => id.name == sym::vis,\n+                        TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Vis)) => true,\n                         TokenTree::Sequence(_, ref sub_seq) => {\n                             sub_seq.kleene.op == mbe::KleeneOp::ZeroOrMore\n                                 || sub_seq.kleene.op == mbe::KleeneOp::ZeroOrOne\n@@ -890,21 +886,7 @@ fn check_matcher_core(\n         // of NT tokens that might end the sequence `... token`.\n         match *token {\n             TokenTree::Token(..) | TokenTree::MetaVar(..) | TokenTree::MetaVarDecl(..) => {\n-                let can_be_followed_by_any;\n-                if let Err(bad_frag) = has_legal_fragment_specifier(sess, features, attrs, token) {\n-                    let msg = format!(\"invalid fragment specifier `{}`\", bad_frag);\n-                    sess.span_diagnostic\n-                        .struct_span_err(token.span(), &msg)\n-                        .help(VALID_FRAGMENT_NAMES_MSG)\n-                        .emit();\n-                    // (This eliminates false positives and duplicates\n-                    // from error messages.)\n-                    can_be_followed_by_any = true;\n-                } else {\n-                    can_be_followed_by_any = token_can_be_followed_by_any(token);\n-                }\n-\n-                if can_be_followed_by_any {\n+                if token_can_be_followed_by_any(token) {\n                     // don't need to track tokens that work with any,\n                     last.replace_with_irrelevant();\n                     // ... and don't need to check tokens that can be\n@@ -967,19 +949,10 @@ fn check_matcher_core(\n \n         // Now `last` holds the complete set of NT tokens that could\n         // end the sequence before SUFFIX. Check that every one works with `suffix`.\n-        'each_last: for token in &last.tokens {\n-            if let TokenTree::MetaVarDecl(_, name, frag_spec) = *token {\n+        for token in &last.tokens {\n+            if let TokenTree::MetaVarDecl(_, name, Some(kind)) = *token {\n                 for next_token in &suffix_first.tokens {\n-                    match is_in_follow(next_token, frag_spec.name) {\n-                        IsInFollow::Invalid(msg, help) => {\n-                            sess.span_diagnostic\n-                                .struct_span_err(next_token.span(), &msg)\n-                                .help(help)\n-                                .emit();\n-                            // don't bother reporting every source of\n-                            // conflict for a particular element of `last`.\n-                            continue 'each_last;\n-                        }\n+                    match is_in_follow(next_token, kind) {\n                         IsInFollow::Yes => {}\n                         IsInFollow::No(possible) => {\n                             let may_be = if last.tokens.len() == 1 && suffix_first.tokens.len() == 1\n@@ -996,22 +969,19 @@ fn check_matcher_core(\n                                     \"`${name}:{frag}` {may_be} followed by `{next}`, which \\\n                                      is not allowed for `{frag}` fragments\",\n                                     name = name,\n-                                    frag = frag_spec,\n+                                    frag = kind,\n                                     next = quoted_tt_to_string(next_token),\n                                     may_be = may_be\n                                 ),\n                             );\n-                            err.span_label(\n-                                sp,\n-                                format!(\"not allowed after `{}` fragments\", frag_spec),\n-                            );\n+                            err.span_label(sp, format!(\"not allowed after `{}` fragments\", kind));\n                             let msg = \"allowed there are: \";\n                             match possible {\n                                 &[] => {}\n                                 &[t] => {\n                                     err.note(&format!(\n                                         \"only {} is allowed after `{}` fragments\",\n-                                        t, frag_spec,\n+                                        t, kind,\n                                     ));\n                                 }\n                                 ts => {\n@@ -1038,8 +1008,8 @@ fn check_matcher_core(\n }\n \n fn token_can_be_followed_by_any(tok: &mbe::TokenTree) -> bool {\n-    if let mbe::TokenTree::MetaVarDecl(_, _, frag_spec) = *tok {\n-        frag_can_be_followed_by_any(frag_spec.name)\n+    if let mbe::TokenTree::MetaVarDecl(_, _, Some(kind)) = *tok {\n+        frag_can_be_followed_by_any(kind)\n     } else {\n         // (Non NT's can always be followed by anything in matchers.)\n         true\n@@ -1054,26 +1024,23 @@ fn token_can_be_followed_by_any(tok: &mbe::TokenTree) -> bool {\n /// specifier which consumes at most one token tree can be followed by\n /// a fragment specifier (indeed, these fragments can be followed by\n /// ANYTHING without fear of future compatibility hazards).\n-fn frag_can_be_followed_by_any(frag: Symbol) -> bool {\n-    match frag {\n-        sym::item     | // always terminated by `}` or `;`\n-        sym::block    | // exactly one token tree\n-        sym::ident    | // exactly one token tree\n-        sym::literal  | // exactly one token tree\n-        sym::meta     | // exactly one token tree\n-        sym::lifetime | // exactly one token tree\n-        sym::tt =>   // exactly one token tree\n-            true,\n-\n-        _ =>\n-            false,\n+fn frag_can_be_followed_by_any(kind: NonterminalKind) -> bool {\n+    match kind {\n+        NonterminalKind::Item           // always terminated by `}` or `;`\n+        | NonterminalKind::Block        // exactly one token tree\n+        | NonterminalKind::Ident        // exactly one token tree\n+        | NonterminalKind::Literal      // exactly one token tree\n+        | NonterminalKind::Meta         // exactly one token tree\n+        | NonterminalKind::Lifetime     // exactly one token tree\n+        | NonterminalKind::TT => true,  // exactly one token tree\n+\n+        _ => false,\n     }\n }\n \n enum IsInFollow {\n     Yes,\n     No(&'static [&'static str]),\n-    Invalid(String, &'static str),\n }\n \n /// Returns `true` if `frag` can legally be followed by the token `tok`. For\n@@ -1084,26 +1051,26 @@ enum IsInFollow {\n /// break macros that were relying on that binary operator as a\n /// separator.\n // when changing this do not forget to update doc/book/macros.md!\n-fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n+fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n     use mbe::TokenTree;\n \n     if let TokenTree::Token(Token { kind: token::CloseDelim(_), .. }) = *tok {\n         // closing a token tree can never be matched by any fragment;\n         // iow, we always require that `(` and `)` match, etc.\n         IsInFollow::Yes\n     } else {\n-        match frag {\n-            sym::item => {\n+        match kind {\n+            NonterminalKind::Item => {\n                 // since items *must* be followed by either a `;` or a `}`, we can\n                 // accept anything after them\n                 IsInFollow::Yes\n             }\n-            sym::block => {\n+            NonterminalKind::Block => {\n                 // anything can follow block, the braces provide an easy boundary to\n                 // maintain\n                 IsInFollow::Yes\n             }\n-            sym::stmt | sym::expr => {\n+            NonterminalKind::Stmt | NonterminalKind::Expr => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`;`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1113,7 +1080,7 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            sym::pat => {\n+            NonterminalKind::Pat => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`=`\", \"`|`\", \"`if`\", \"`in`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1124,7 +1091,7 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            sym::path | sym::ty => {\n+            NonterminalKind::Path | NonterminalKind::Ty => {\n                 const TOKENS: &[&str] = &[\n                     \"`{`\", \"`[`\", \"`=>`\", \"`,`\", \"`>`\", \"`=`\", \"`:`\", \"`;`\", \"`|`\", \"`as`\",\n                     \"`where`\",\n@@ -1146,26 +1113,24 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                         }\n                         _ => IsInFollow::No(TOKENS),\n                     },\n-                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == sym::block => {\n-                        IsInFollow::Yes\n-                    }\n+                    TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Block)) => IsInFollow::Yes,\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            sym::ident | sym::lifetime => {\n+            NonterminalKind::Ident | NonterminalKind::Lifetime => {\n                 // being a single token, idents and lifetimes are harmless\n                 IsInFollow::Yes\n             }\n-            sym::literal => {\n+            NonterminalKind::Literal => {\n                 // literals may be of a single token, or two tokens (negative numbers)\n                 IsInFollow::Yes\n             }\n-            sym::meta | sym::tt => {\n+            NonterminalKind::Meta | NonterminalKind::TT => {\n                 // being either a single token or a delimited sequence, tt is\n                 // harmless\n                 IsInFollow::Yes\n             }\n-            sym::vis => {\n+            NonterminalKind::Vis => {\n                 // Explicitly disallow `priv`, on the off chance it comes back.\n                 const TOKENS: &[&str] = &[\"`,`\", \"an ident\", \"a type\"];\n                 match tok {\n@@ -1180,78 +1145,24 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                             }\n                         }\n                     },\n-                    TokenTree::MetaVarDecl(_, _, frag)\n-                        if frag.name == sym::ident\n-                            || frag.name == sym::ty\n-                            || frag.name == sym::path =>\n-                    {\n-                        IsInFollow::Yes\n-                    }\n+                    TokenTree::MetaVarDecl(\n+                        _,\n+                        _,\n+                        Some(NonterminalKind::Ident | NonterminalKind::Ty | NonterminalKind::Path),\n+                    ) => IsInFollow::Yes,\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            kw::Invalid => IsInFollow::Yes,\n-            _ => IsInFollow::Invalid(\n-                format!(\"invalid fragment specifier `{}`\", frag),\n-                VALID_FRAGMENT_NAMES_MSG,\n-            ),\n         }\n     }\n }\n \n-fn has_legal_fragment_specifier(\n-    sess: &ParseSess,\n-    features: &Features,\n-    attrs: &[ast::Attribute],\n-    tok: &mbe::TokenTree,\n-) -> Result<(), String> {\n-    debug!(\"has_legal_fragment_specifier({:?})\", tok);\n-    if let mbe::TokenTree::MetaVarDecl(_, _, ref frag_spec) = *tok {\n-        let frag_span = tok.span();\n-        if !is_legal_fragment_specifier(sess, features, attrs, frag_spec.name, frag_span) {\n-            return Err(frag_spec.to_string());\n-        }\n-    }\n-    Ok(())\n-}\n-\n-fn is_legal_fragment_specifier(\n-    _sess: &ParseSess,\n-    _features: &Features,\n-    _attrs: &[ast::Attribute],\n-    frag_name: Symbol,\n-    _frag_span: Span,\n-) -> bool {\n-    /*\n-     * If new fragment specifiers are invented in nightly, `_sess`,\n-     * `_features`, `_attrs`, and `_frag_span` will be useful here\n-     * for checking against feature gates. See past versions of\n-     * this function.\n-     */\n-    match frag_name {\n-        sym::item\n-        | sym::block\n-        | sym::stmt\n-        | sym::expr\n-        | sym::pat\n-        | sym::lifetime\n-        | sym::path\n-        | sym::ty\n-        | sym::ident\n-        | sym::meta\n-        | sym::tt\n-        | sym::vis\n-        | sym::literal\n-        | kw::Invalid => true,\n-        _ => false,\n-    }\n-}\n-\n fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     match *tt {\n         mbe::TokenTree::Token(ref token) => pprust::token_to_string(&token),\n         mbe::TokenTree::MetaVar(_, name) => format!(\"${}\", name),\n-        mbe::TokenTree::MetaVarDecl(_, name, kind) => format!(\"${}:{}\", name, kind),\n+        mbe::TokenTree::MetaVarDecl(_, name, Some(kind)) => format!(\"${}:{}\", name, kind),\n+        mbe::TokenTree::MetaVarDecl(_, name, None) => format!(\"${}:\", name),\n         _ => panic!(\n             \"unexpected mbe::TokenTree::{{Sequence or Delimited}} \\\n              in follow set checker\""}, {"sha": "774cc84afdeb11df0f8fb7c7c1b3d73d9dcaa057", "filename": "src/librustc_expand/mbe/quoted.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs?ref=f042d749b0fc212bff6bdc44b84e134b878bff64", "patch": "@@ -12,6 +12,10 @@ use rustc_span::Span;\n \n use rustc_data_structures::sync::Lrc;\n \n+const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n+                                        `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `lifetime`, \\\n+                                        `literal`, `path`, `meta`, `tt`, `item` and `vis`\";\n+\n /// Takes a `tokenstream::TokenStream` and returns a `Vec<self::TokenTree>`. Specifically, this\n /// takes a generic `TokenStream`, such as is used in the rest of the compiler, and returns a\n /// collection of `TokenTree` for use in parsing a macro.\n@@ -55,9 +59,21 @@ pub(super) fn parse(\n                     Some(tokenstream::TokenTree::Token(Token { kind: token::Colon, span })) => {\n                         match trees.next() {\n                             Some(tokenstream::TokenTree::Token(token)) => match token.ident() {\n-                                Some((kind, _)) => {\n+                                Some((frag, _)) => {\n                                     let span = token.span.with_lo(start_sp.lo());\n-                                    result.push(TokenTree::MetaVarDecl(span, ident, kind));\n+                                    let kind = token::NonterminalKind::from_symbol(frag.name)\n+                                        .unwrap_or_else(|| {\n+                                            let msg = format!(\n+                                                \"invalid fragment specifier `{}`\",\n+                                                frag.name\n+                                            );\n+                                            sess.span_diagnostic\n+                                                .struct_span_err(span, &msg)\n+                                                .help(VALID_FRAGMENT_NAMES_MSG)\n+                                                .emit();\n+                                            token::NonterminalKind::Ident\n+                                        });\n+                                    result.push(TokenTree::MetaVarDecl(span, ident, Some(kind)));\n                                     continue;\n                                 }\n                                 _ => token.span,\n@@ -71,7 +87,7 @@ pub(super) fn parse(\n                     // Macros loaded from other crates have dummy node ids.\n                     sess.missing_fragment_specifiers.borrow_mut().insert(span, node_id);\n                 }\n-                result.push(TokenTree::MetaVarDecl(span, ident, Ident::invalid()));\n+                result.push(TokenTree::MetaVarDecl(span, ident, None));\n             }\n \n             // Not a metavar or no matchers allowed, so just return the tree"}, {"sha": "3aec300d86d4f5dcb6bb6cf386fb3b8c9d1d64e4", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=f042d749b0fc212bff6bdc44b84e134b878bff64", "patch": "@@ -1450,7 +1450,7 @@ impl<'a> Parser<'a> {\n \n     /// Matches `'-' lit | lit` (cf. `ast_validation::AstValidator::check_expr_within_pat`).\n     /// Keep this in sync with `Token::can_begin_literal_maybe_minus`.\n-    pub fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n+    pub(super) fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_whole_expr!(self);\n \n         let lo = self.token.span;"}, {"sha": "2509a9792215d553379da4acdf0ce201045c94e1", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=f042d749b0fc212bff6bdc44b84e134b878bff64", "patch": "@@ -1,16 +1,17 @@\n pub mod attr;\n+mod diagnostics;\n mod expr;\n+mod generics;\n mod item;\n+mod nonterminal;\n mod pat;\n mod path;\n-mod ty;\n-pub use path::PathStyle;\n-mod diagnostics;\n-mod generics;\n mod stmt;\n-use diagnostics::Error;\n+mod ty;\n \n use crate::lexer::UnmatchedBrace;\n+use diagnostics::Error;\n+pub use path::PathStyle;\n \n use log::debug;\n use rustc_ast::ast::DUMMY_NODE_ID;\n@@ -958,7 +959,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a single token tree from the input.\n-    pub fn parse_token_tree(&mut self) -> TokenTree {\n+    pub(crate) fn parse_token_tree(&mut self) -> TokenTree {\n         match self.token.kind {\n             token::OpenDelim(..) => {\n                 let frame = mem::replace(\n@@ -1017,7 +1018,7 @@ impl<'a> Parser<'a> {\n     /// If the following element can't be a tuple (i.e., it's a function definition), then\n     /// it's not a tuple struct field), and the contents within the parentheses isn't valid,\n     /// so emit a proper diagnostic.\n-    pub fn parse_visibility(&mut self, fbt: FollowedByType) -> PResult<'a, Visibility> {\n+    pub(crate) fn parse_visibility(&mut self, fbt: FollowedByType) -> PResult<'a, Visibility> {\n         maybe_whole!(self, NtVis, |x| x);\n \n         self.expected_tokens.push(TokenType::Keyword(kw::Crate));"}, {"sha": "12139771bbfdaa172c9d4cc9f0d7026fd59ab8a1", "filename": "src/librustc_parse/parser/nonterminal.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_parse%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_parse%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fnonterminal.rs?ref=f042d749b0fc212bff6bdc44b84e134b878bff64", "patch": "@@ -0,0 +1,163 @@\n+use rustc_ast::ptr::P;\n+use rustc_ast::token::{self, Nonterminal, NonterminalKind, Token};\n+use rustc_ast_pretty::pprust;\n+use rustc_errors::PResult;\n+use rustc_span::symbol::{kw, Ident};\n+\n+use crate::parser::{FollowedByType, Parser, PathStyle};\n+\n+impl<'a> Parser<'a> {\n+    /// Checks whether a non-terminal may begin with a particular token.\n+    ///\n+    /// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n+    /// token. Be conservative (return true) if not sure.\n+    pub fn nonterminal_may_begin_with(kind: NonterminalKind, token: &Token) -> bool {\n+        /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n+        fn may_be_ident(nt: &token::Nonterminal) -> bool {\n+            match *nt {\n+                token::NtItem(_) | token::NtBlock(_) | token::NtVis(_) | token::NtLifetime(_) => {\n+                    false\n+                }\n+                _ => true,\n+            }\n+        }\n+\n+        match kind {\n+            NonterminalKind::Expr => {\n+                token.can_begin_expr()\n+                // This exception is here for backwards compatibility.\n+                && !token.is_keyword(kw::Let)\n+            }\n+            NonterminalKind::Ty => token.can_begin_type(),\n+            NonterminalKind::Ident => get_macro_ident(token).is_some(),\n+            NonterminalKind::Literal => token.can_begin_literal_maybe_minus(),\n+            NonterminalKind::Vis => match token.kind {\n+                // The follow-set of :vis + \"priv\" keyword + interpolated\n+                token::Comma | token::Ident(..) | token::Interpolated(..) => true,\n+                _ => token.can_begin_type(),\n+            },\n+            NonterminalKind::Block => match token.kind {\n+                token::OpenDelim(token::Brace) => true,\n+                token::Interpolated(ref nt) => match **nt {\n+                    token::NtItem(_)\n+                    | token::NtPat(_)\n+                    | token::NtTy(_)\n+                    | token::NtIdent(..)\n+                    | token::NtMeta(_)\n+                    | token::NtPath(_)\n+                    | token::NtVis(_) => false, // none of these may start with '{'.\n+                    _ => true,\n+                },\n+                _ => false,\n+            },\n+            NonterminalKind::Path | NonterminalKind::Meta => match token.kind {\n+                token::ModSep | token::Ident(..) => true,\n+                token::Interpolated(ref nt) => match **nt {\n+                    token::NtPath(_) | token::NtMeta(_) => true,\n+                    _ => may_be_ident(&nt),\n+                },\n+                _ => false,\n+            },\n+            NonterminalKind::Pat => match token.kind {\n+                token::Ident(..) |                  // box, ref, mut, and other identifiers (can stricten)\n+                token::OpenDelim(token::Paren) |    // tuple pattern\n+                token::OpenDelim(token::Bracket) |  // slice pattern\n+                token::BinOp(token::And) |          // reference\n+                token::BinOp(token::Minus) |        // negative literal\n+                token::AndAnd |                     // double reference\n+                token::Literal(..) |                // literal\n+                token::DotDot |                     // range pattern (future compat)\n+                token::DotDotDot |                  // range pattern (future compat)\n+                token::ModSep |                     // path\n+                token::Lt |                         // path (UFCS constant)\n+                token::BinOp(token::Shl) => true,   // path (double UFCS)\n+                token::Interpolated(ref nt) => may_be_ident(nt),\n+                _ => false,\n+            },\n+            NonterminalKind::Lifetime => match token.kind {\n+                token::Lifetime(_) => true,\n+                token::Interpolated(ref nt) => match **nt {\n+                    token::NtLifetime(_) | token::NtTT(_) => true,\n+                    _ => false,\n+                },\n+                _ => false,\n+            },\n+            NonterminalKind::TT | NonterminalKind::Item | NonterminalKind::Stmt => match token.kind\n+            {\n+                token::CloseDelim(_) => false,\n+                _ => true,\n+            },\n+        }\n+    }\n+\n+    pub fn parse_nonterminal(&mut self, kind: NonterminalKind) -> PResult<'a, Nonterminal> {\n+        // Any `Nonterminal` which stores its tokens (currently `NtItem` and `NtExpr`)\n+        // needs to have them force-captured here.\n+        // A `macro_rules!` invocation may pass a captured item/expr to a proc-macro,\n+        // which requires having captured tokens available. Since we cannot determine\n+        // in advance whether or not a proc-macro will be (transitively) invoked,\n+        // we always capture tokens for any `Nonterminal` which needs them.\n+        Ok(match kind {\n+            NonterminalKind::Item => match self.collect_tokens(|this| this.parse_item())? {\n+                (Some(mut item), tokens) => {\n+                    // If we captured tokens during parsing (due to outer attributes),\n+                    // use those.\n+                    if item.tokens.is_none() {\n+                        item.tokens = Some(tokens);\n+                    }\n+                    token::NtItem(item)\n+                }\n+                (None, _) => {\n+                    return Err(self.struct_span_err(self.token.span, \"expected an item keyword\"));\n+                }\n+            },\n+            NonterminalKind::Block => token::NtBlock(self.parse_block()?),\n+            NonterminalKind::Stmt => match self.parse_stmt()? {\n+                Some(s) => token::NtStmt(s),\n+                None => return Err(self.struct_span_err(self.token.span, \"expected a statement\")),\n+            },\n+            NonterminalKind::Pat => token::NtPat(self.parse_pat(None)?),\n+            NonterminalKind::Expr => {\n+                let (mut expr, tokens) = self.collect_tokens(|this| this.parse_expr())?;\n+                // If we captured tokens during parsing (due to outer attributes),\n+                // use those.\n+                if expr.tokens.is_none() {\n+                    expr.tokens = Some(tokens);\n+                }\n+                token::NtExpr(expr)\n+            }\n+            NonterminalKind::Literal => token::NtLiteral(self.parse_literal_maybe_minus()?),\n+            NonterminalKind::Ty => token::NtTy(self.parse_ty()?),\n+            // this could be handled like a token, since it is one\n+            NonterminalKind::Ident => {\n+                if let Some((ident, is_raw)) = get_macro_ident(&self.token) {\n+                    self.bump();\n+                    token::NtIdent(ident, is_raw)\n+                } else {\n+                    let token_str = pprust::token_to_string(&self.token);\n+                    let msg = &format!(\"expected ident, found {}\", &token_str);\n+                    return Err(self.struct_span_err(self.token.span, msg));\n+                }\n+            }\n+            NonterminalKind::Path => token::NtPath(self.parse_path(PathStyle::Type)?),\n+            NonterminalKind::Meta => token::NtMeta(P(self.parse_attr_item()?)),\n+            NonterminalKind::TT => token::NtTT(self.parse_token_tree()),\n+            NonterminalKind::Vis => token::NtVis(self.parse_visibility(FollowedByType::Yes)?),\n+            NonterminalKind::Lifetime => {\n+                if self.check_lifetime() {\n+                    token::NtLifetime(self.expect_lifetime().ident)\n+                } else {\n+                    let token_str = pprust::token_to_string(&self.token);\n+                    let msg = &format!(\"expected a lifetime, found `{}`\", &token_str);\n+                    return Err(self.struct_span_err(self.token.span, msg));\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+/// The token is an identifier, but not `_`.\n+/// We prohibit passing `_` to macros expecting `ident` for now.\n+fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n+    token.ident().filter(|(ident, _)| ident.name != kw::Underscore)\n+}"}, {"sha": "d4e44c54b127405fdcdc4c11fe474dda129938f5", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=f042d749b0fc212bff6bdc44b84e134b878bff64", "patch": "@@ -125,7 +125,7 @@ impl<'a> Parser<'a> {\n     /// `a::b::C::<D>` (with disambiguator)\n     /// `Fn(Args)` (without disambiguator)\n     /// `Fn::(Args)` (with disambiguator)\n-    pub fn parse_path(&mut self, style: PathStyle) -> PResult<'a, Path> {\n+    pub(super) fn parse_path(&mut self, style: PathStyle) -> PResult<'a, Path> {\n         maybe_whole!(self, NtPath, |path| {\n             if style == PathStyle::Mod && path.segments.iter().any(|segment| segment.args.is_some())\n             {"}, {"sha": "5c3a5e9987324c93f4c56aab60dbd88bc4797d86", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=f042d749b0fc212bff6bdc44b84e134b878bff64", "patch": "@@ -21,7 +21,7 @@ use std::mem;\n impl<'a> Parser<'a> {\n     /// Parses a statement. This stops just before trailing semicolons on everything but items.\n     /// e.g., a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n-    pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n+    pub(super) fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n         Ok(self.parse_stmt_without_recovery().unwrap_or_else(|mut e| {\n             e.emit();\n             self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n@@ -247,7 +247,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a block. No inner attributes are allowed.\n-    pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n+    pub(super) fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n         let (attrs, block) = self.parse_inner_attrs_and_block()?;\n         if let [.., last] = &*attrs {\n             self.error_on_forbidden_inner_attr(last.span, DEFAULT_INNER_ATTR_FORBIDDEN);"}, {"sha": "cd66b917f232a016e9912d81c1e329dd3d784828", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f042d749b0fc212bff6bdc44b84e134b878bff64/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=f042d749b0fc212bff6bdc44b84e134b878bff64", "patch": "@@ -610,13 +610,13 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn check_lifetime(&mut self) -> bool {\n+    pub(super) fn check_lifetime(&mut self) -> bool {\n         self.expected_tokens.push(TokenType::Lifetime);\n         self.token.is_lifetime()\n     }\n \n     /// Parses a single lifetime `'a` or panics.\n-    pub fn expect_lifetime(&mut self) -> Lifetime {\n+    pub(super) fn expect_lifetime(&mut self) -> Lifetime {\n         if let Some(ident) = self.token.lifetime() {\n             self.bump();\n             Lifetime { ident, id: ast::DUMMY_NODE_ID }"}]}