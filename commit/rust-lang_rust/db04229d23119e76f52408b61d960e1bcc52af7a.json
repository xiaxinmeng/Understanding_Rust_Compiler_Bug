{"sha": "db04229d23119e76f52408b61d960e1bcc52af7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMDQyMjlkMjMxMTllNzZmNTI0MDhiNjFkOTYwZTFiY2M1MmFmN2E=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-23T09:18:54Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-23T17:58:49Z"}, "message": "Rollup merge of #22696 - stepancheg:use-box, r=alexcrichton\n\n e. g.\n\n```\nlet b: Box<Foo> = Box::from_raw(p);\n```\n\ninstead of\n\n```\nlet b: Box<Foo> = mem::transmute(p);\n```\n\nPatch also changes closure release code in `src/libstd/sys/unix/thread.rs`\nwhen `pthread_create` failed. Raw pointer was transmuted to box of\n`FnOnce()` instead of `Thunk`. This code was probably never executed,\nbecause `pthread_create` rarely fails.\n\n(And there are two more patches in PR: fix typo in doc and mark `from_raw` and `into_raw` functions inline.)", "tree": {"sha": "0ea536aed48e5e6f97b607725575309102f60eca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ea536aed48e5e6f97b607725575309102f60eca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db04229d23119e76f52408b61d960e1bcc52af7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db04229d23119e76f52408b61d960e1bcc52af7a", "html_url": "https://github.com/rust-lang/rust/commit/db04229d23119e76f52408b61d960e1bcc52af7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db04229d23119e76f52408b61d960e1bcc52af7a/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2302a50ed534ed671d87835f435af4034705cbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2302a50ed534ed671d87835f435af4034705cbe", "html_url": "https://github.com/rust-lang/rust/commit/b2302a50ed534ed671d87835f435af4034705cbe"}, {"sha": "26d9f0ab1aeb3d7b440911104cf17741f83aa0f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/26d9f0ab1aeb3d7b440911104cf17741f83aa0f5", "html_url": "https://github.com/rust-lang/rust/commit/26d9f0ab1aeb3d7b440911104cf17741f83aa0f5"}], "stats": {"total": 113, "additions": 65, "deletions": 48}, "files": [{"sha": "a93872dfe36bd8d522bd9fa3e56e10715f386605", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -105,15 +105,16 @@ impl<T : ?Sized> Box<T> {\n     /// After this function call, pointer is owned by resulting box.\n     /// In particular, it means that `Box` destructor calls destructor\n     /// of `T` and releases memory. Since the way `Box` allocates and\n-    /// releases memory is unspecified, so the only valid pointer to\n-    /// pass to this function is the one taken from another `Box` with\n-    /// `box::into_raw` function.\n+    /// releases memory is unspecified, the only valid pointer to pass\n+    /// to this function is the one taken from another `Box` with\n+    /// `boxed::into_raw` function.\n     ///\n     /// Function is unsafe, because improper use of this function may\n     /// lead to memory problems like double-free, for example if the\n     /// function is called twice on the same raw pointer.\n     #[unstable(feature = \"alloc\",\n                reason = \"may be renamed or moved out of Box scope\")]\n+    #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n         mem::transmute(raw)\n     }\n@@ -141,6 +142,7 @@ impl<T : ?Sized> Box<T> {\n /// ```\n #[unstable(feature = \"alloc\",\n            reason = \"may be renamed\")]\n+#[inline]\n pub unsafe fn into_raw<T : ?Sized>(b: Box<T>) -> *mut T {\n     mem::transmute(b)\n }\n@@ -248,11 +250,12 @@ impl BoxAny for Box<Any> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n+                let raw = into_raw(self);\n                 let to: TraitObject =\n-                    mem::transmute::<Box<Any>, TraitObject>(self);\n+                    mem::transmute::<*mut Any, TraitObject>(raw);\n \n                 // Extract the data pointer\n-                Ok(mem::transmute(to.data))\n+                Ok(Box::from_raw(to.data as *mut T))\n             }\n         } else {\n             Err(self)"}, {"sha": "5b3d7c9ea902b1f2223eeef86534ae7d7c5f467d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -144,14 +144,15 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use boxed;\n use core::cell::Cell;\n use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n use core::marker;\n-use core::mem::{transmute, min_align_of, size_of, forget};\n+use core::mem::{min_align_of, size_of, forget};\n use core::nonzero::NonZero;\n use core::ops::{Deref, Drop};\n use core::option::Option;\n@@ -201,7 +202,7 @@ impl<T> Rc<T> {\n                 // there is an implicit weak pointer owned by all the strong pointers, which\n                 // ensures that the weak destructor never frees the allocation while the strong\n                 // destructor is running, even if the weak pointer is stored inside the strong one.\n-                _ptr: NonZero::new(transmute(box RcBox {\n+                _ptr: NonZero::new(boxed::into_raw(box RcBox {\n                     value: value,\n                     strong: Cell::new(1),\n                     weak: Cell::new(1)"}, {"sha": "0726704056eb85f92abfa080ca530e9cc960e79b", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -388,7 +388,7 @@ impl<T> Vec<T> {\n     pub fn into_boxed_slice(mut self) -> Box<[T]> {\n         self.shrink_to_fit();\n         unsafe {\n-            let xs: Box<[T]> = mem::transmute(&mut *self);\n+            let xs: Box<[T]> = Box::from_raw(&mut *self);\n             mem::forget(self);\n             xs\n         }"}, {"sha": "5e80bc5db2e41967512edd22373b6cf53f74ba81", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -167,6 +167,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![deny(missing_docs)]\n \n+#![feature(alloc)]\n #![feature(staged_api)]\n #![feature(box_syntax)]\n #![feature(int_uint)]\n@@ -175,6 +176,7 @@\n #![feature(std_misc)]\n #![feature(env)]\n \n+use std::boxed;\n use std::cell::RefCell;\n use std::fmt;\n use std::old_io::LineBufferedWriter;\n@@ -205,11 +207,11 @@ const DEFAULT_LOG_LEVEL: u32 = 1;\n /// logging statement should be run.\n static mut LOG_LEVEL: u32 = MAX_LOG_LEVEL;\n \n-static mut DIRECTIVES: *const Vec<directive::LogDirective> =\n-    0 as *const Vec<directive::LogDirective>;\n+static mut DIRECTIVES: *mut Vec<directive::LogDirective> =\n+    0 as *mut Vec<directive::LogDirective>;\n \n /// Optional filter.\n-static mut FILTER: *const String = 0 as *const _;\n+static mut FILTER: *mut String = 0 as *mut _;\n \n /// Debug log level\n pub const DEBUG: u32 = 4;\n@@ -419,23 +421,23 @@ fn init() {\n \n         assert!(FILTER.is_null());\n         match filter {\n-            Some(f) => FILTER = mem::transmute(box f),\n+            Some(f) => FILTER = boxed::into_raw(box f),\n             None => {}\n         }\n \n         assert!(DIRECTIVES.is_null());\n-        DIRECTIVES = mem::transmute(box directives);\n+        DIRECTIVES = boxed::into_raw(box directives);\n \n         // Schedule the cleanup for the globals for when the runtime exits.\n         rt::at_exit(move || {\n             assert!(!DIRECTIVES.is_null());\n             let _directives: Box<Vec<directive::LogDirective>> =\n-                mem::transmute(DIRECTIVES);\n-            DIRECTIVES = ptr::null();\n+                Box::from_raw(DIRECTIVES);\n+            DIRECTIVES = ptr::null_mut();\n \n             if !FILTER.is_null() {\n-                let _filter: Box<String> = mem::transmute(FILTER);\n-                FILTER = 0 as *const _;\n+                let _filter: Box<String> = Box::from_raw(FILTER);\n+                FILTER = 0 as *mut _;\n             }\n         });\n     }"}, {"sha": "56a707c24a6c9789c5c8b751e31759d91c7fef5f", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -27,6 +27,7 @@\n \n use self::StdSource::*;\n \n+use boxed;\n use boxed::Box;\n use cell::RefCell;\n use clone::Clone;\n@@ -218,7 +219,7 @@ impl Reader for StdinReader {\n /// See `stdout()` for more notes about this function.\n pub fn stdin() -> StdinReader {\n     // We're following the same strategy as kimundi's lazy_static library\n-    static mut STDIN: *const StdinReader = 0 as *const StdinReader;\n+    static mut STDIN: *mut StdinReader = 0 as *mut StdinReader;\n     static ONCE: Once = ONCE_INIT;\n \n     unsafe {\n@@ -235,12 +236,12 @@ pub fn stdin() -> StdinReader {\n             let stdin = StdinReader {\n                 inner: Arc::new(Mutex::new(RaceBox(stdin)))\n             };\n-            STDIN = mem::transmute(box stdin);\n+            STDIN = boxed::into_raw(box stdin);\n \n             // Make sure to free it at exit\n             rt::at_exit(|| {\n-                mem::transmute::<_, Box<StdinReader>>(STDIN);\n-                STDIN = ptr::null();\n+                Box::from_raw(STDIN);\n+                STDIN = ptr::null_mut();\n             });\n         });\n "}, {"sha": "08755ba829f8f9af3958b4a18ff1fb2d31bfda23", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -14,9 +14,9 @@\n \n use core::prelude::*;\n \n+use boxed;\n use boxed::Box;\n use vec::Vec;\n-use mem;\n use thunk::Thunk;\n use sys_common::mutex::{Mutex, MUTEX_INIT};\n \n@@ -32,7 +32,7 @@ static mut QUEUE: *mut Queue = 0 as *mut Queue;\n unsafe fn init() {\n     if QUEUE.is_null() {\n         let state: Box<Queue> = box Vec::new();\n-        QUEUE = mem::transmute(state);\n+        QUEUE = boxed::into_raw(state);\n     } else {\n         // can't re-init after a cleanup\n         rtassert!(QUEUE as uint != 1);\n@@ -57,7 +57,7 @@ pub fn cleanup() {\n \n         // If we never called init, not need to cleanup!\n         if queue as uint != 0 {\n-            let queue: Box<Queue> = mem::transmute(queue);\n+            let queue: Box<Queue> = Box::from_raw(queue);\n             for to_run in *queue {\n                 to_run.invoke(());\n             }"}, {"sha": "4dda3ea8c998800e94cde11c237296ab2ee502da", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -60,6 +60,7 @@\n use prelude::v1::*;\n \n use any::Any;\n+use boxed;\n use cell::Cell;\n use cmp;\n use panicking;\n@@ -173,15 +174,16 @@ fn rust_panic(cause: Box<Any + Send + 'static>) -> ! {\n             },\n             cause: Some(cause),\n         };\n-        let error = uw::_Unwind_RaiseException(mem::transmute(exception));\n+        let exception_param = boxed::into_raw(exception) as *mut uw::_Unwind_Exception;\n+        let error = uw::_Unwind_RaiseException(exception_param);\n         rtabort!(\"Could not unwind stack, error = {}\", error as int)\n     }\n \n     extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n                                 exception: *mut uw::_Unwind_Exception) {\n         rtdebug!(\"exception_cleanup()\");\n         unsafe {\n-            let _: Box<Exception> = mem::transmute(exception);\n+            let _: Box<Exception> = Box::from_raw(exception as *mut Exception);\n         }\n     }\n }"}, {"sha": "59fa2e6bc9a91c31dc28cc60f8e3ad8b0dfd9861", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -44,8 +44,8 @@ pub use self::PopResult::*;\n \n use core::prelude::*;\n \n+use alloc::boxed;\n use alloc::boxed::Box;\n-use core::mem;\n use core::ptr;\n use core::cell::UnsafeCell;\n \n@@ -82,7 +82,7 @@ unsafe impl<T: Send> Sync for Queue<T> { }\n \n impl<T> Node<T> {\n     unsafe fn new(v: Option<T>) -> *mut Node<T> {\n-        mem::transmute(box Node {\n+        boxed::into_raw(box Node {\n             next: AtomicPtr::new(ptr::null_mut()),\n             value: v,\n         })\n@@ -129,7 +129,7 @@ impl<T: Send> Queue<T> {\n                 assert!((*tail).value.is_none());\n                 assert!((*next).value.is_some());\n                 let ret = (*next).value.take().unwrap();\n-                let _: Box<Node<T>> = mem::transmute(tail);\n+                let _: Box<Node<T>> = Box::from_raw(tail);\n                 return Data(ret);\n             }\n \n@@ -146,7 +146,7 @@ impl<T: Send> Drop for Queue<T> {\n             let mut cur = *self.tail.get();\n             while !cur.is_null() {\n                 let next = (*cur).next.load(Ordering::Relaxed);\n-                let _: Box<Node<T>> = mem::transmute(cur);\n+                let _: Box<Node<T>> = Box::from_raw(cur);\n                 cur = next;\n             }\n         }"}, {"sha": "7b5c614536df98617c32c33af432ad9b7c75e7c7", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -37,8 +37,8 @@\n \n use core::prelude::*;\n \n+use alloc::boxed;\n use alloc::boxed::Box;\n-use core::mem;\n use core::ptr;\n use core::cell::UnsafeCell;\n \n@@ -81,7 +81,7 @@ unsafe impl<T: Send> Sync for Queue<T> { }\n impl<T: Send> Node<T> {\n     fn new() -> *mut Node<T> {\n         unsafe {\n-            mem::transmute(box Node {\n+            boxed::into_raw(box Node {\n                 value: None,\n                 next: AtomicPtr::new(ptr::null_mut::<Node<T>>()),\n             })\n@@ -200,7 +200,7 @@ impl<T: Send> Queue<T> {\n                           .next.store(next, Ordering::Relaxed);\n                     // We have successfully erased all references to 'tail', so\n                     // now we can safely drop it.\n-                    let _: Box<Node<T>> = mem::transmute(tail);\n+                    let _: Box<Node<T>> = Box::from_raw(tail);\n                 }\n             }\n             return ret;\n@@ -233,7 +233,7 @@ impl<T: Send> Drop for Queue<T> {\n             let mut cur = *self.first.get();\n             while !cur.is_null() {\n                 let next = (*cur).next.load(Ordering::Relaxed);\n-                let _n: Box<Node<T>> = mem::transmute(cur);\n+                let _n: Box<Node<T>> = Box::from_raw(cur);\n                 cur = next;\n             }\n         }"}, {"sha": "5faaa928ee973893d345e29aab91b8446f1947a1", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -22,8 +22,8 @@\n \n use prelude::v1::*;\n \n+use boxed;\n use cell::UnsafeCell;\n-use mem;\n use ptr;\n use rt;\n use sync::{StaticMutex, StaticCondvar};\n@@ -88,7 +88,7 @@ impl<M: Send> Helper<M> {\n             let _guard = self.lock.lock().unwrap();\n             if !*self.initialized.get() {\n                 let (tx, rx) = channel();\n-                *self.chan.get() = mem::transmute(box tx);\n+                *self.chan.get() = boxed::into_raw(box tx);\n                 let (receive, send) = helper_signal::new();\n                 *self.signal.get() = send as uint;\n \n@@ -132,7 +132,7 @@ impl<M: Send> Helper<M> {\n             let mut guard = self.lock.lock().unwrap();\n \n             // Close the channel by destroying it\n-            let chan: Box<Sender<M>> = mem::transmute(*self.chan.get());\n+            let chan: Box<Sender<M>> = Box::from_raw(*self.chan.get());\n             *self.chan.get() = ptr::null_mut();\n             drop(chan);\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);"}, {"sha": "731617858e95fe3f9185048414d59e6c60189e77", "filename": "src/libstd/sys/common/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -27,7 +27,7 @@ pub fn start_thread(main: *mut libc::c_void) -> thread::rust_thread_return {\n     unsafe {\n         stack::record_os_managed_stack_bounds(0, usize::MAX);\n         let handler = stack_overflow::Handler::new();\n-        let f: Box<Thunk> = mem::transmute(main);\n+        let f: Box<Thunk> = Box::from_raw(main as *mut Thunk);\n         f.invoke(());\n         drop(handler);\n         mem::transmute(0 as thread::rust_thread_return)"}, {"sha": "f4791d39da19055e6925db6d923ed98527eb4097", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -11,6 +11,7 @@\n use core::prelude::*;\n \n use io;\n+use boxed;\n use boxed::Box;\n use cmp;\n use mem;\n@@ -241,13 +242,15 @@ pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n         },\n     };\n \n-    let arg: *mut libc::c_void = mem::transmute(box p); // must box since sizeof(p)=2*uint\n+    // must box since sizeof(p)=2*uint\n+    let raw_p = boxed::into_raw(box p);\n+    let arg = raw_p as *mut libc::c_void;\n     let ret = pthread_create(&mut native, &attr, thread_start, arg);\n     assert_eq!(pthread_attr_destroy(&mut attr), 0);\n \n     if ret != 0 {\n         // be sure to not leak the closure\n-        let _p: Box<Box<FnOnce()+Send>> = mem::transmute(arg);\n+        let _p: Box<Thunk> = Box::from_raw(raw_p);\n         Err(io::Error::from_os_error(ret))\n     } else {\n         Ok(native)"}, {"sha": "7fe8dce1a3ea153a27ebbc612f751a4fc9194603", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -10,6 +10,8 @@\n \n use prelude::v1::*;\n \n+use boxed;\n+use boxed::Box;\n use cmp;\n use io;\n use mem;\n@@ -45,7 +47,8 @@ pub mod guard {\n }\n \n pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n-    let arg: *mut libc::c_void = mem::transmute(box p);\n+    let raw_p = boxed::into_raw(box p);\n+    let arg = raw_p as *mut libc::c_void;\n     // FIXME On UNIX, we guard against stack sizes that are too small but\n     // that's because pthreads enforces that stacks are at least\n     // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n@@ -61,7 +64,7 @@ pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n \n     if ret as uint == 0 {\n         // be sure to not leak the closure\n-        let _p: Box<Thunk> = mem::transmute(arg);\n+        let _p: Box<Thunk> = Box::from_raw(raw_p);\n         Err(io::Error::last_os_error())\n     } else {\n         Ok(ret)"}, {"sha": "cf942b5d025330cc80c083663521e4cd5001dd39", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -133,13 +133,13 @@ unsafe fn init_dtors() {\n     if !DTORS.is_null() { return }\n \n     let dtors = box Vec::<(Key, Dtor)>::new();\n-    DTORS = mem::transmute(dtors);\n+    DTORS = boxed::into_raw(dtors);\n \n     rt::at_exit(move|| {\n         DTOR_LOCK.lock();\n         let dtors = DTORS;\n         DTORS = ptr::null_mut();\n-        mem::transmute::<_, Box<Vec<(Key, Dtor)>>>(dtors);\n+        Boxed::from_raw(dtors);\n         assert!(DTORS.is_null()); // can't re-init after destructing\n         DTOR_LOCK.unlock();\n     });"}, {"sha": "9549ae14b885584007bc863102aca555ce59a355", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db04229d23119e76f52408b61d960e1bcc52af7a/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=db04229d23119e76f52408b61d960e1bcc52af7a", "patch": "@@ -330,6 +330,7 @@ impl<T: 'static> Key<T> {\n mod imp {\n     use prelude::v1::*;\n \n+    use alloc::boxed;\n     use cell::UnsafeCell;\n     use intrinsics;\n     use ptr;\n@@ -422,14 +423,14 @@ mod imp {\n         type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n         if DTORS.get().is_null() {\n             let v: Box<List> = box Vec::new();\n-            DTORS.set(mem::transmute(v));\n+            DTORS.set(boxed::into_raw(v) as *mut u8);\n         }\n         let list: &mut List = &mut *(DTORS.get() as *mut List);\n         list.push((t, dtor));\n \n         unsafe extern fn run_dtors(mut ptr: *mut u8) {\n             while !ptr.is_null() {\n-                let list: Box<List> = mem::transmute(ptr);\n+                let list: Box<List> = Box::from_raw(ptr as *mut List);\n                 for &(ptr, dtor) in &*list {\n                     dtor(ptr);\n                 }\n@@ -467,6 +468,7 @@ mod imp {\n mod imp {\n     use prelude::v1::*;\n \n+    use alloc::boxed;\n     use cell::UnsafeCell;\n     use mem;\n     use ptr;\n@@ -517,7 +519,7 @@ mod imp {\n                 key: self,\n                 value: mem::transmute_copy(&self.inner),\n             };\n-            let ptr: *mut Value<T> = mem::transmute(ptr);\n+            let ptr: *mut Value<T> = boxed::into_raw(ptr);\n             self.os.set(ptr as *mut u8);\n             Some(&mut (*ptr).value as *mut T)\n         }\n@@ -533,7 +535,7 @@ mod imp {\n         //\n         // Note that to prevent an infinite loop we reset it back to null right\n         // before we return from the destructor ourselves.\n-        let ptr: Box<Value<T>> = mem::transmute(ptr);\n+        let ptr: Box<Value<T>> = Box::from_raw(ptr as *mut Value<T>);\n         let key = ptr.key;\n         key.os.set(1 as *mut u8);\n         drop(ptr);"}]}