{"sha": "7ffbd62445b9706325d01ec8be8e70c41404fe0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmZmJkNjI0NDViOTcwNjMyNWQwMWVjOGJlOGU3MGM0MTQwNGZlMGQ=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-10-14T17:55:32Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-10-23T21:10:58Z"}, "message": "ignore uninhabited non-exhaustive variant fields\n\nThis commit modifies the uninhabitedness checking so that the fields of\na non-exhaustive variant (which is not local) are ignored if they are\nuninhabited. This is an improvement over the previous behaviour which\nconsidered all non-local non-exhaustive variants useful because\nunreachable patterns are now detected.\n\nSigned-off-by: David Wood <david@davidtw.co>", "tree": {"sha": "d968523abcb2a40c5dc6cc34f694d3bd999316c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d968523abcb2a40c5dc6cc34f694d3bd999316c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ffbd62445b9706325d01ec8be8e70c41404fe0d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEfgm2/wUjk9OnjxlyJZLnbIc4H9kFAl2wweMACgkQJZLnbIc4\nH9kbpQ//RzUQMY0EEX3Vqx11K0jE1ltDtUk5gkbJqJiDnPZMV9zr3r8GI6tgAyb4\nj/DKojSJMqnzcKcreRe3C6y0NSNBJhyzSf8dcwHe5Ncjm8589aIHy3W+RrgJjlDN\ncd9RXSNDZiDNM50VLjnmcGUAP8n7GsLGgTCVwL/ZpeqpFr4CTiepQS9vSQwlax1d\nyYcHt5jOlISEVMXxFUxeOAjEIetisXOiMrRWPOtdEJsp5QX2Yea+7LLA/x0WgK9c\nlGaxqQAKyWOC92LXzW5kA8xw4pRAmHcVDUxO+b5Cr5VyNxN9aBJgpbpN2ZzgETNl\nW2JZ1I73RK+L45hxI5/imxAckpMlMwdNVBNnVKoc+wJavxI/H2ZRQ/yFTnVMzeSW\nvJfACKVnbDELGTy+ep1eTVcaCBqw49z9colzj/jLeMKbK4XFhv2yqG38arRgZ2dz\nD/iGnQmX3g+F0puoWL2d+xplCzHQvk1/FIHTlAUEb8BSDIOuJ9quN2aqgvQ6CZAR\nVVpFJ06xaBpT+oKoQqgTLyxB9j6OrEDkHYazwEaWBKjoH2QFH2ZZLHU9Gypiz+OX\nHu9DNBe/lKSXG6eTAwQMftrZt6hwUMGQSs+D/2Q9egRgSoqQ+FodDC/kL9A4Mk4f\n4UWESEKpa7ctx3m32XDAI75ywtQ1+E1SjdGAagbUTzbh6zHdybQ=\n=kkqe\n-----END PGP SIGNATURE-----", "payload": "tree d968523abcb2a40c5dc6cc34f694d3bd999316c7\nparent 4a8c5b20c7772bc5342b83d4b0696ea216ef75a7\nauthor David Wood <david@davidtw.co> 1571075732 +0100\ncommitter David Wood <david@davidtw.co> 1571865058 +0100\n\nignore uninhabited non-exhaustive variant fields\n\nThis commit modifies the uninhabitedness checking so that the fields of\na non-exhaustive variant (which is not local) are ignored if they are\nuninhabited. This is an improvement over the previous behaviour which\nconsidered all non-local non-exhaustive variants useful because\nunreachable patterns are now detected.\n\nSigned-off-by: David Wood <david@davidtw.co>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ffbd62445b9706325d01ec8be8e70c41404fe0d", "html_url": "https://github.com/rust-lang/rust/commit/7ffbd62445b9706325d01ec8be8e70c41404fe0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ffbd62445b9706325d01ec8be8e70c41404fe0d/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a8c5b20c7772bc5342b83d4b0696ea216ef75a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8c5b20c7772bc5342b83d4b0696ea216ef75a7", "html_url": "https://github.com/rust-lang/rust/commit/4a8c5b20c7772bc5342b83d4b0696ea216ef75a7"}], "stats": {"total": 124, "additions": 75, "deletions": 49}, "files": [{"sha": "907c84b6f8cf02ac23a4d4a33f1dade25a452a52", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 39, "deletions": 49, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7ffbd62445b9706325d01ec8be8e70c41404fe0d/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ffbd62445b9706325d01ec8be8e70c41404fe0d/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=7ffbd62445b9706325d01ec8be8e70c41404fe0d", "patch": "@@ -394,16 +394,6 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn is_non_exhaustive_variant<'p>(&self, pattern: &'p Pat<'tcx>) -> bool {\n-        match *pattern.kind {\n-            PatKind::Variant { adt_def, variant_index, .. } => {\n-                let ref variant = adt_def.variants[variant_index];\n-                variant.is_field_list_non_exhaustive()\n-            }\n-            _ => false,\n-        }\n-    }\n-\n     fn is_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.kind {\n             ty::Adt(adt_def, ..) => adt_def.is_variant_list_non_exhaustive(),\n@@ -1252,19 +1242,12 @@ pub fn is_useful<'p, 'a, 'tcx>(\n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v[0]);\n \n     if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n-        let is_declared_nonexhaustive = cx.is_non_exhaustive_variant(v[0]) && !cx.is_local(pcx.ty);\n-        debug!(\"is_useful - expanding constructors: {:#?}, is_declared_nonexhaustive: {:?}\",\n-               constructors, is_declared_nonexhaustive);\n-\n-        if is_declared_nonexhaustive {\n-            Useful\n-        } else {\n-            split_grouped_constructors(\n-                cx.tcx, cx.param_env, constructors, matrix, pcx.ty, pcx.span, Some(hir_id),\n-            ).into_iter().map(|c|\n-                is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id)\n-            ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n-        }\n+        debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n+        split_grouped_constructors(\n+            cx.tcx, cx.param_env, constructors, matrix, pcx.ty, pcx.span, Some(hir_id),\n+        ).into_iter().map(|c|\n+            is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id)\n+        ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n \n@@ -1548,27 +1531,30 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n                 // Use T as the sub pattern type of Box<T>.\n                 vec![substs.type_at(0)]\n             } else {\n-                adt.variants[ctor.variant_index_for_adt(cx, adt)].fields.iter().map(|field| {\n+                let variant = &adt.variants[ctor.variant_index_for_adt(cx, adt)];\n+                let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n+                variant.fields.iter().map(|field| {\n                     let is_visible = adt.is_enum()\n                         || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                    if is_visible {\n-                        let ty = field.ty(cx.tcx, substs);\n-                        match ty.kind {\n-                            // If the field type returned is an array of an unknown\n-                            // size return an TyErr.\n-                            ty::Array(_, len)\n-                                if len.try_eval_usize(cx.tcx, cx.param_env).is_none() =>\n-                                cx.tcx.types.err,\n-                            _ => ty,\n-                        }\n-                    } else {\n-                        // Treat all non-visible fields as TyErr. They\n-                        // can't appear in any other pattern from\n-                        // this match (because they are private),\n-                        // so their type does not matter - but\n-                        // we don't want to know they are\n-                        // uninhabited.\n-                        cx.tcx.types.err\n+                    let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n+                    match (is_visible, is_non_exhaustive, is_uninhabited) {\n+                        // Treat all uninhabited types in non-exhaustive variants as `TyErr`.\n+                        (_, true, true) => cx.tcx.types.err,\n+                        // Treat all non-visible fields as `TyErr`. They can't appear in any\n+                        // other pattern from this match (because they are private), so their\n+                        // type does not matter - but we don't want to know they are uninhabited.\n+                        (false, ..) => cx.tcx.types.err,\n+                        (true, ..) => {\n+                            let ty = field.ty(cx.tcx, substs);\n+                            match ty.kind {\n+                                // If the field type returned is an array of an unknown\n+                                // size return an TyErr.\n+                                ty::Array(_, len)\n+                                    if len.try_eval_usize(cx.tcx, cx.param_env).is_none() =>\n+                                    cx.tcx.types.err,\n+                                _ => ty,\n+                            }\n+                        },\n                     }\n                 }).collect()\n             }\n@@ -1874,15 +1860,18 @@ fn constructor_covered_by_range<'tcx>(\n     }\n }\n \n-fn patterns_for_variant<'p, 'tcx>(\n+fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     subpatterns: &'p [FieldPat<'tcx>],\n-    wild_patterns: &[&'p Pat<'tcx>])\n-    -> SmallVec<[&'p Pat<'tcx>; 2]>\n-{\n+    wild_patterns: &[&'p Pat<'tcx>],\n+    is_non_exhaustive: bool,\n+) -> SmallVec<[&'p Pat<'tcx>; 2]> {\n     let mut result = SmallVec::from_slice(wild_patterns);\n \n     for subpat in subpatterns {\n-        result[subpat.field.index()] = &subpat.pattern;\n+        if !is_non_exhaustive || !cx.is_uninhabited(subpat.pattern.ty) {\n+            result[subpat.field.index()] = &subpat.pattern;\n+        }\n     }\n \n     debug!(\"patterns_for_variant({:#?}, {:#?}) = {:#?}\", subpatterns, wild_patterns, result);\n@@ -1916,13 +1905,14 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n \n         PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n+            let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !cx.is_local(pat.ty);\n             Some(Variant(variant.def_id))\n                 .filter(|variant_constructor| variant_constructor == constructor)\n-                .map(|_| patterns_for_variant(subpatterns, wild_patterns))\n+                .map(|_| patterns_for_variant(cx, subpatterns, wild_patterns, is_non_exhaustive))\n         }\n \n         PatKind::Leaf { ref subpatterns } => {\n-            Some(patterns_for_variant(subpatterns, wild_patterns))\n+            Some(patterns_for_variant(cx, subpatterns, wild_patterns, false))\n         }\n \n         PatKind::Deref { ref subpattern } => {"}, {"sha": "0096e2963007a442f05c70aea27779619cccba9e", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/issue-65157-repeated-match-arm.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7ffbd62445b9706325d01ec8be8e70c41404fe0d/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ffbd62445b9706325d01ec8be8e70c41404fe0d/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.rs?ref=7ffbd62445b9706325d01ec8be8e70c41404fe0d", "patch": "@@ -0,0 +1,22 @@\n+// aux-build:uninhabited.rs\n+#![deny(unreachable_patterns)]\n+#![feature(never_type)]\n+#![feature(non_exhaustive)]\n+\n+extern crate uninhabited;\n+\n+use uninhabited::PartiallyInhabitedVariants;\n+\n+// This test checks a redundant/useless pattern of a non-exhaustive enum/variant is still\n+// warned against.\n+\n+pub fn foo(x: PartiallyInhabitedVariants) {\n+    match x {\n+        PartiallyInhabitedVariants::Struct { .. } => {},\n+        PartiallyInhabitedVariants::Struct { .. } => {},\n+        //~^ ERROR unreachable pattern\n+        _ => {},\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "d46b1fd4c420252f6d34b8f7bb2505889582833a", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/issue-65157-repeated-match-arm.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ffbd62445b9706325d01ec8be8e70c41404fe0d/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ffbd62445b9706325d01ec8be8e70c41404fe0d/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.stderr?ref=7ffbd62445b9706325d01ec8be8e70c41404fe0d", "patch": "@@ -0,0 +1,14 @@\n+error: unreachable pattern\n+  --> $DIR/issue-65157-repeated-match-arm.rs:16:9\n+   |\n+LL |         PartiallyInhabitedVariants::Struct { .. } => {},\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-65157-repeated-match-arm.rs:2:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}