{"sha": "098106870e0ebdebb40964624185f304ee7b3d63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ODEwNjg3MGUwZWJkZWJiNDA5NjQ2MjQxODVmMzA0ZWU3YjNkNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-27T21:49:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-27T21:49:28Z"}, "message": "auto merge of #8077 : graydon/rust/reorganize-driver, r=pcwalton\n\nThe purpose here is to get rid of compile_upto, which pretty much always requires the user to read the source to figure out what it does. It's replaced by a sequence of obviously-named functions:\r\n\r\n  - phase_1_parse_input(sess, cfg, input);\r\n  - phase_2_configure_and_expand(sess, cfg, crate);\r\n  - phase_3_run_analysis_passes(sess, expanded_crate);\r\n  - phase_4_translate_to_llvm(sess, expanded_crate, &analysis, outputs);\r\n  - phase_5_run_llvm_passes(sess, &trans, outputs);\r\n  - phase_6_link_output(sess, &trans, outputs); \r\n\r\nEach of which takes what it takes and returns what it returns, with as little variation as possible in behaviour: no \"pairs of options\" and \"pairs of control flags\". You can tell if you missed a phase because you will be missing a `phase_N` call to some `N` between 1 and 6.\r\n\r\nIt does mean that people invoking librustc from outside need to write more function calls. The benefit is that they can _figure out what they're doing_ much more easily, and stop at any point, rather than further overloading the tangled logic of `compile_upto`.", "tree": {"sha": "0ac0cc7fbcd8c9307ee08c94ef16b1ccdee6088b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ac0cc7fbcd8c9307ee08c94ef16b1ccdee6088b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/098106870e0ebdebb40964624185f304ee7b3d63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/098106870e0ebdebb40964624185f304ee7b3d63", "html_url": "https://github.com/rust-lang/rust/commit/098106870e0ebdebb40964624185f304ee7b3d63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/098106870e0ebdebb40964624185f304ee7b3d63/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32622cef992fea2ba23bafe39ed08730a2b78fb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/32622cef992fea2ba23bafe39ed08730a2b78fb4", "html_url": "https://github.com/rust-lang/rust/commit/32622cef992fea2ba23bafe39ed08730a2b78fb4"}, {"sha": "413446c85b44a7d9269a0723ed043e16d09e2324", "url": "https://api.github.com/repos/rust-lang/rust/commits/413446c85b44a7d9269a0723ed043e16d09e2324", "html_url": "https://github.com/rust-lang/rust/commit/413446c85b44a7d9269a0723ed043e16d09e2324"}], "stats": {"total": 571, "additions": 292, "deletions": 279}, "files": [{"sha": "65b78baba406905eb6a4c8ca130539243e6c11f8", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 243, "deletions": 224, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/098106870e0ebdebb40964624185f304ee7b3d63/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/098106870e0ebdebb40964624185f304ee7b3d63/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=098106870e0ebdebb40964624185f304ee7b3d63", "patch": "@@ -16,14 +16,16 @@ use driver::session::{Session, Session_, No, Less, Default};\n use driver::session;\n use front;\n use lib::llvm::llvm;\n+use lib::llvm::{ContextRef, ModuleRef};\n+use metadata::common::LinkMeta;\n use metadata::{creader, cstore, filesearch};\n use metadata;\n use middle::{trans, freevars, kind, ty, typeck, lint, astencode, reachable};\n use middle;\n use util::common::time;\n use util::ppaux;\n \n-use std::hashmap::HashMap;\n+use std::hashmap::{HashMap,HashSet};\n use std::int;\n use std::io;\n use std::os;\n@@ -132,280 +134,295 @@ pub enum input {\n     str_input(@str)\n }\n \n-pub fn parse_input(sess: Session, cfg: ast::CrateConfig, input: &input)\n+pub fn phase_1_parse_input(sess: Session, cfg: ast::CrateConfig, input: &input)\n     -> @ast::Crate {\n-    match *input {\n-      file_input(ref file) => {\n-        parse::parse_crate_from_file(&(*file), cfg, sess.parse_sess)\n-      }\n-      str_input(src) => {\n-        parse::parse_crate_from_source_str(\n-            anon_src(), src, cfg, sess.parse_sess)\n-      }\n-    }\n-}\n-\n-/// First phase to do, last phase to do\n-#[deriving(Eq)]\n-pub struct compile_upto {\n-    from: compile_phase,\n-    to: compile_phase\n-}\n-\n-#[deriving(Eq)]\n-pub enum compile_phase {\n-    cu_parse,\n-    cu_expand, // means \"it's already expanded\"\n-    cu_typeck,\n-    cu_no_trans,\n-    cu_everything,\n+    time(sess.time_passes(), ~\"parsing\", || {\n+        match *input {\n+            file_input(ref file) => {\n+                parse::parse_crate_from_file(&(*file), cfg.clone(), sess.parse_sess)\n+            }\n+            str_input(src) => {\n+                parse::parse_crate_from_source_str(\n+                    anon_src(), src, cfg.clone(), sess.parse_sess)\n+            }\n+        }\n+    })\n }\n \n // For continuing compilation after a parsed crate has been\n // modified\n \n-\n-#[fixed_stack_segment]\n-pub fn compile_rest(sess: Session,\n-                    cfg: ast::CrateConfig,\n-                    phases: compile_upto,\n-                    outputs: Option<@OutputFilenames>,\n-                    curr: Option<@ast::Crate>)\n-    -> (Option<@ast::Crate>, Option<ty::ctxt>) {\n-\n+/// Run the \"early phases\" of the compiler: initial `cfg` processing,\n+/// syntax expansion, secondary `cfg` expansion, synthesis of a test\n+/// harness if one is to be provided and injection of a dependency on the\n+/// standard library and prelude.\n+pub fn phase_2_configure_and_expand(sess: Session,\n+                                    cfg: ast::CrateConfig,\n+                                    mut crate: @ast::Crate) -> @ast::Crate {\n     let time_passes = sess.time_passes();\n \n-    let mut crate = curr.unwrap();\n-\n-    if phases.from == cu_parse || phases.from == cu_everything {\n+    *sess.building_library = session::building_library(sess.opts.crate_type,\n+                                                       crate, sess.opts.test);\n \n-        *sess.building_library = session::building_library(\n-            sess.opts.crate_type, crate, sess.opts.test);\n \n-        // strip before expansion to allow macros to depend on\n-        // configuration variables e.g/ in\n-        //\n-        //   #[macro_escape] #[cfg(foo)]\n-        //   mod bar { macro_rules! baz!(() => {{}}) }\n-        //\n-        // baz! should not use this definition unless foo is enabled.\n-        crate = time(time_passes, ~\"std macros injection\", ||\n-                     syntax::ext::expand::inject_std_macros(sess.parse_sess,\n-                                                            cfg.clone(),\n-                                                            crate));\n+    // strip before expansion to allow macros to depend on\n+    // configuration variables e.g/ in\n+    //\n+    //   #[macro_escape] #[cfg(foo)]\n+    //   mod bar { macro_rules! baz!(() => {{}}) }\n+    //\n+    // baz! should not use this definition unless foo is enabled.\n+    crate = time(time_passes, ~\"std macros injection\", ||\n+                 syntax::ext::expand::inject_std_macros(sess.parse_sess,\n+                                                        cfg.clone(),\n+                                                        crate));\n \n-        crate = time(time_passes, ~\"configuration 1\", ||\n-                     front::config::strip_unconfigured_items(crate));\n+    crate = time(time_passes, ~\"configuration 1\", ||\n+                 front::config::strip_unconfigured_items(crate));\n \n-        crate = time(time_passes, ~\"expansion\", ||\n-                     syntax::ext::expand::expand_crate(sess.parse_sess,\n-                                                       cfg.clone(),\n-                                                       crate));\n+    crate = time(time_passes, ~\"expansion\", ||\n+                 syntax::ext::expand::expand_crate(sess.parse_sess, cfg.clone(),\n+                                                   crate));\n \n-        // strip again, in case expansion added anything with a #[cfg].\n-        crate = time(time_passes, ~\"configuration 2\", ||\n-                     front::config::strip_unconfigured_items(crate));\n+    // strip again, in case expansion added anything with a #[cfg].\n+    crate = time(time_passes, ~\"configuration 2\", ||\n+                 front::config::strip_unconfigured_items(crate));\n \n+    crate = time(time_passes, ~\"maybe building test harness\", ||\n+                 front::test::modify_for_testing(sess, crate));\n \n-        crate = time(time_passes, ~\"maybe building test harness\", ||\n-                     front::test::modify_for_testing(sess, crate));\n-    }\n+    crate = time(time_passes, ~\"std injection\", ||\n+                 front::std_inject::maybe_inject_libstd_ref(sess, crate));\n \n-    if phases.to == cu_expand {\n-        return (Some(crate), None);\n-    }\n+    return crate;\n+}\n \n-    assert!(phases.from != cu_no_trans);\n+pub struct CrateAnalysis {\n+    exp_map2: middle::resolve::ExportMap2,\n+    ty_cx: ty::ctxt,\n+    maps: astencode::Maps,\n+    reachable: @mut HashSet<ast::node_id>\n+}\n \n-    let (llcx, llmod, link_meta) = {\n-        crate = time(time_passes, ~\"std injection\", ||\n-                     front::std_inject::maybe_inject_libstd_ref(sess, crate));\n+/// Run the resolution, typechecking, region checking and other\n+/// miscellaneous analysis passes on the crate. Return various\n+/// structures carrying the results of the analysis.\n+pub fn phase_3_run_analysis_passes(sess: Session,\n+                                   crate: @ast::Crate) -> CrateAnalysis {\n \n-        let ast_map = time(time_passes, ~\"ast indexing\", ||\n-                           syntax::ast_map::map_crate(sess.diagnostic(), crate));\n+    let time_passes = sess.time_passes();\n+    let ast_map = time(time_passes, ~\"ast indexing\", ||\n+                       syntax::ast_map::map_crate(sess.diagnostic(), crate));\n \n-        time(time_passes, ~\"external crate/lib resolution\", ||\n-             creader::read_crates(sess.diagnostic(), crate, sess.cstore,\n-                                  sess.filesearch,\n-                                  session::sess_os_to_meta_os(sess.targ_cfg.os),\n-                                  sess.opts.is_static,\n-                                  token::get_ident_interner()));\n+    time(time_passes, ~\"external crate/lib resolution\", ||\n+         creader::read_crates(sess.diagnostic(), crate, sess.cstore,\n+                              sess.filesearch,\n+                              session::sess_os_to_meta_os(sess.targ_cfg.os),\n+                              sess.opts.is_static,\n+                              token::get_ident_interner()));\n \n-        let lang_items = time(time_passes, ~\"language item collection\", ||\n-                              middle::lang_items::collect_language_items(crate, sess));\n+    let lang_items = time(time_passes, ~\"language item collection\", ||\n+                          middle::lang_items::collect_language_items(crate, sess));\n \n-        let middle::resolve::CrateMap {\n-            def_map: def_map,\n-            exp_map2: exp_map2,\n-            trait_map: trait_map\n-        } =\n-            time(time_passes, ~\"resolution\", ||\n-                 middle::resolve::resolve_crate(sess, lang_items, crate));\n+    let middle::resolve::CrateMap {\n+        def_map: def_map,\n+        exp_map2: exp_map2,\n+        trait_map: trait_map\n+    } =\n+        time(time_passes, ~\"resolution\", ||\n+             middle::resolve::resolve_crate(sess, lang_items, crate));\n \n-        time(time_passes, ~\"looking for entry point\",\n-             || middle::entry::find_entry_point(sess, crate, ast_map));\n+    time(time_passes, ~\"looking for entry point\",\n+         || middle::entry::find_entry_point(sess, crate, ast_map));\n \n-        let freevars = time(time_passes, ~\"freevar finding\", ||\n-                            freevars::annotate_freevars(def_map, crate));\n+    let freevars = time(time_passes, ~\"freevar finding\", ||\n+                        freevars::annotate_freevars(def_map, crate));\n \n-        let region_map = time(time_passes, ~\"region resolution\", ||\n-                              middle::region::resolve_crate(sess, def_map, crate));\n+    let region_map = time(time_passes, ~\"region resolution\", ||\n+                          middle::region::resolve_crate(sess, def_map, crate));\n \n-        let rp_set = time(time_passes, ~\"region parameterization inference\", ||\n-                          middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n+    let rp_set = time(time_passes, ~\"region parameterization inference\", ||\n+                      middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n \n-        let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n-                                region_map, rp_set, lang_items);\n+    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n+                            region_map, rp_set, lang_items);\n \n-        // passes are timed inside typeck\n-        let (method_map, vtable_map) = typeck::check_crate(\n-            ty_cx, trait_map, crate);\n+    // passes are timed inside typeck\n+    let (method_map, vtable_map) = typeck::check_crate(\n+        ty_cx, trait_map, crate);\n \n-        // These next two const passes can probably be merged\n-        time(time_passes, ~\"const marking\", ||\n-             middle::const_eval::process_crate(crate, ty_cx));\n+    // These next two const passes can probably be merged\n+    time(time_passes, ~\"const marking\", ||\n+         middle::const_eval::process_crate(crate, ty_cx));\n \n-        time(time_passes, ~\"const checking\", ||\n-             middle::check_const::check_crate(sess, crate, ast_map, def_map,\n-                                              method_map, ty_cx));\n+    time(time_passes, ~\"const checking\", ||\n+         middle::check_const::check_crate(sess, crate, ast_map, def_map,\n+                                          method_map, ty_cx));\n \n-        if phases.to == cu_typeck { return (Some(crate), Some(ty_cx)); }\n+    time(time_passes, ~\"privacy checking\", ||\n+         middle::privacy::check_crate(ty_cx, &method_map, crate));\n \n-        time(time_passes, ~\"privacy checking\", ||\n-             middle::privacy::check_crate(ty_cx, &method_map, crate));\n+    time(time_passes, ~\"effect checking\", ||\n+         middle::effect::check_crate(ty_cx, method_map, crate));\n \n-        time(time_passes, ~\"effect checking\", ||\n-             middle::effect::check_crate(ty_cx, method_map, crate));\n+    time(time_passes, ~\"loop checking\", ||\n+         middle::check_loop::check_crate(ty_cx, crate));\n \n-        time(time_passes, ~\"loop checking\", ||\n-             middle::check_loop::check_crate(ty_cx, crate));\n+    let middle::moves::MoveMaps {moves_map, moved_variables_set,\n+                                 capture_map} =\n+        time(time_passes, ~\"compute moves\", ||\n+             middle::moves::compute_moves(ty_cx, method_map, crate));\n \n-        let middle::moves::MoveMaps {moves_map, moved_variables_set,\n-                                     capture_map} =\n-            time(time_passes, ~\"compute moves\", ||\n-                 middle::moves::compute_moves(ty_cx, method_map, crate));\n+    time(time_passes, ~\"match checking\", ||\n+         middle::check_match::check_crate(ty_cx, method_map,\n+                                          moves_map, crate));\n \n-        time(time_passes, ~\"match checking\", ||\n-             middle::check_match::check_crate(ty_cx, method_map,\n-                                              moves_map, crate));\n+    time(time_passes, ~\"liveness checking\", ||\n+         middle::liveness::check_crate(ty_cx, method_map,\n+                                       capture_map, crate));\n \n-        time(time_passes, ~\"liveness checking\", ||\n-             middle::liveness::check_crate(ty_cx, method_map,\n+    let (root_map, write_guard_map) =\n+        time(time_passes, ~\"borrow checking\", ||\n+             middle::borrowck::check_crate(ty_cx, method_map,\n+                                           moves_map, moved_variables_set,\n                                            capture_map, crate));\n \n-        let (root_map, write_guard_map) =\n-            time(time_passes, ~\"borrow checking\", ||\n-                 middle::borrowck::check_crate(ty_cx, method_map,\n-                                               moves_map, moved_variables_set,\n-                                               capture_map, crate));\n+    time(time_passes, ~\"kind checking\", ||\n+         kind::check_crate(ty_cx, method_map, crate));\n \n-        time(time_passes, ~\"kind checking\", ||\n-             kind::check_crate(ty_cx, method_map, crate));\n+    let reachable_map =\n+        time(time_passes, ~\"reachability checking\", ||\n+             reachable::find_reachable(ty_cx, method_map, crate));\n \n-        let reachable_map =\n-            time(time_passes, ~\"reachability checking\", ||\n-                reachable::find_reachable(ty_cx, method_map, crate));\n+    time(time_passes, ~\"lint checking\", ||\n+         lint::check_crate(ty_cx, crate));\n \n-        time(time_passes, ~\"lint checking\", ||\n-             lint::check_crate(ty_cx, crate));\n-\n-        if phases.to == cu_no_trans {\n-            return (Some(crate), Some(ty_cx));\n-        }\n-\n-        let maps = astencode::Maps {\n+    CrateAnalysis {\n+        exp_map2: exp_map2,\n+        ty_cx: ty_cx,\n+        maps: astencode::Maps {\n             root_map: root_map,\n             method_map: method_map,\n             vtable_map: vtable_map,\n             write_guard_map: write_guard_map,\n             capture_map: capture_map\n-        };\n+        },\n+        reachable: reachable_map\n+    }\n+}\n \n-        let outputs = outputs.get_ref();\n-        time(time_passes, ~\"translation\", ||\n-             trans::base::trans_crate(sess,\n-                                      crate,\n-                                      ty_cx,\n-                                      &outputs.obj_filename,\n-                                      exp_map2,\n-                                      reachable_map,\n-                                      maps))\n-    };\n+pub struct CrateTranslation {\n+    context: ContextRef,\n+    module: ModuleRef,\n+    link: LinkMeta\n+}\n \n-    let outputs = outputs.get_ref();\n-    if (sess.opts.debugging_opts & session::print_link_args) != 0 {\n-        io::println(link::link_args(sess, &outputs.obj_filename,\n-                                    &outputs.out_filename, link_meta).connect(\" \"));\n-    }\n+/// Run the translation phase to LLVM, after which the AST and analysis can\n+/// be discarded.\n+pub fn phase_4_translate_to_llvm(sess: Session,\n+                                 crate: @ast::Crate,\n+                                 analysis: &CrateAnalysis,\n+                                 outputs: &OutputFilenames) -> CrateTranslation {\n+    time(sess.time_passes(), ~\"translation\", ||\n+         trans::base::trans_crate(sess, crate, analysis,\n+                                  &outputs.obj_filename))\n+}\n+\n+/// Run LLVM itself, producing a bitcode file, assembly file or object file\n+/// as a side effect.\n+pub fn phase_5_run_llvm_passes(sess: Session,\n+                               trans: &CrateTranslation,\n+                               outputs: &OutputFilenames) {\n \n     // NB: Android hack\n     if sess.targ_cfg.arch == abi::Arm &&\n-            (sess.opts.output_type == link::output_type_object ||\n-             sess.opts.output_type == link::output_type_exe) {\n+        (sess.opts.output_type == link::output_type_object ||\n+         sess.opts.output_type == link::output_type_exe) {\n         let output_type = link::output_type_assembly;\n         let obj_filename = outputs.obj_filename.with_filetype(\"s\");\n \n-        time(time_passes, ~\"LLVM passes\", ||\n-            link::write::run_passes(sess, llcx, llmod, output_type,\n+        time(sess.time_passes(), ~\"LLVM passes\", ||\n+            link::write::run_passes(sess,\n+                                    trans.context,\n+                                    trans.module,\n+                                    output_type,\n                                     &obj_filename));\n \n         link::write::run_ndk(sess, &obj_filename, &outputs.obj_filename);\n     } else {\n-        time(time_passes, ~\"LLVM passes\", ||\n-            link::write::run_passes(sess, llcx, llmod, sess.opts.output_type,\n+        time(sess.time_passes(), ~\"LLVM passes\", ||\n+            link::write::run_passes(sess,\n+                                    trans.context,\n+                                    trans.module,\n+                                    sess.opts.output_type,\n                                     &outputs.obj_filename));\n     }\n+}\n \n-    let stop_after_codegen =\n-        sess.opts.output_type != link::output_type_exe ||\n-        (sess.opts.is_static && *sess.building_library)   ||\n-        sess.opts.jit;\n-\n-    if stop_after_codegen { return (None, None); }\n-\n-    time(time_passes, ~\"linking\", ||\n+/// Run the linker on any artifacts that resulted from the LLVM run.\n+/// This should produce either a finished executable or library.\n+pub fn phase_6_link_output(sess: Session,\n+                           trans: &CrateTranslation,\n+                           outputs: &OutputFilenames) {\n+    time(sess.time_passes(), ~\"linking\", ||\n          link::link_binary(sess,\n                            &outputs.obj_filename,\n-                           &outputs.out_filename, link_meta));\n+                           &outputs.out_filename,\n+                           trans.link));\n+}\n \n-    return (None, None);\n+pub fn stop_after_phase_3(sess: Session) -> bool {\n+   if sess.opts.no_trans {\n+        debug!(\"invoked with --no-trans, returning early from compile_input\");\n+        return true;\n+    }\n+    return false;\n }\n \n-pub fn compile_upto(sess: Session,\n-                    cfg: ast::CrateConfig,\n-                    input: &input,\n-                    upto: compile_phase,\n-                    outputs: Option<@OutputFilenames>)\n-                    -> (Option<@ast::Crate>, Option<ty::ctxt>) {\n-    let time_passes = sess.time_passes();\n-    let crate = time(time_passes,\n-                     ~\"parsing\",\n-                     || parse_input(sess, cfg.clone(), input) );\n-    if upto == cu_parse {\n-        return (Some(crate), None);\n+pub fn stop_after_phase_1(sess: Session) -> bool {\n+    if sess.opts.parse_only {\n+        debug!(\"invoked with --parse-only, returning early from compile_input\");\n+        return true;\n     }\n+    return false;\n+}\n \n-    compile_rest(sess,\n-                 cfg,\n-                 compile_upto {\n-                    from: cu_parse,\n-                    to: upto\n-                 },\n-                 outputs,\n-                 Some(crate))\n+pub fn stop_after_phase_5(sess: Session) -> bool {\n+    if sess.opts.output_type != link::output_type_exe {\n+        debug!(\"not building executable, returning early from compile_input\");\n+        return true;\n+    }\n+\n+    if sess.opts.is_static && *sess.building_library {\n+        debug!(\"building static library, returning early from compile_input\");\n+        return true;\n+    }\n+\n+    if sess.opts.jit {\n+        debug!(\"running JIT, returning early from compile_input\");\n+        return true;\n+    }\n+    return false;\n }\n \n+#[fixed_stack_segment]\n pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n                      outdir: &Option<Path>, output: &Option<Path>) {\n-    let upto = if sess.opts.parse_only { cu_parse }\n-               else if sess.opts.no_trans { cu_no_trans }\n-               else { cu_everything };\n-    let outputs = build_output_filenames(input, outdir, output, [], sess); // ???\n-    compile_upto(sess, cfg, input, upto, Some(outputs));\n+    let outputs = build_output_filenames(input, outdir, output, [], sess);\n+    let crate = phase_1_parse_input(sess, cfg.clone(), input);\n+    if stop_after_phase_1(sess) { return; }\n+    let expanded_crate = phase_2_configure_and_expand(sess, cfg, crate);\n+    let analysis = phase_3_run_analysis_passes(sess, expanded_crate);\n+    if stop_after_phase_3(sess) { return; }\n+    let trans = phase_4_translate_to_llvm(sess, expanded_crate, &analysis, outputs);\n+    phase_5_run_llvm_passes(sess, &trans, outputs);\n+    if stop_after_phase_5(sess) { return; }\n+    phase_6_link_output(sess, &trans, outputs);\n }\n \n pub fn pretty_print_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n                           ppm: pp_mode) {\n+\n     fn ann_paren_for_expr(node: pprust::ann_node) {\n         match node {\n           pprust::node_expr(s, _) => pprust::popen(s),\n@@ -447,37 +464,39 @@ pub fn pretty_print_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n         }\n     }\n \n-    // Because the pretty printer needs to make a pass over the source\n-    // to collect comments and literals, and we need to support reading\n-    // from stdin, we're going to just suck the source into a string\n-    // so both the parser and pretty-printer can use it.\n-    let upto = match ppm {\n-      ppm_expanded | ppm_expanded_identified => cu_expand,\n-      ppm_typed => cu_typeck,\n-      _ => cu_parse\n+    let crate = phase_1_parse_input(sess, cfg.clone(), input);\n+\n+    let (crate, is_expanded) = match ppm {\n+        ppm_expanded | ppm_expanded_identified | ppm_typed => {\n+            (phase_2_configure_and_expand(sess, cfg, crate), true)\n+        }\n+        _ => (crate, false)\n     };\n-    let (crate, tcx) = compile_upto(sess, cfg, input, upto, None);\n \n-    let ann = match ppm {\n-      ppm_typed => {\n-          pprust::pp_ann {pre: ann_paren_for_expr,\n-                          post: |a| ann_typed_post(tcx.get(), a) }\n-      }\n-      ppm_identified | ppm_expanded_identified => {\n-          pprust::pp_ann {pre: ann_paren_for_expr,\n-                          post: ann_identified_post}\n-      }\n-      ppm_expanded | ppm_normal => {\n-          pprust::no_ann()\n-      }\n+    let annotation = match ppm {\n+        ppm_identified | ppm_expanded_identified => {\n+            pprust::pp_ann {\n+                pre: ann_paren_for_expr,\n+                post: ann_identified_post\n+            }\n+        }\n+        ppm_typed => {\n+            let analysis = phase_3_run_analysis_passes(sess, crate);\n+            pprust::pp_ann {\n+                pre: ann_paren_for_expr,\n+                post: |a| ann_typed_post(analysis.ty_cx, a)\n+            }\n+        }\n+        _ => pprust::no_ann()\n     };\n-    let is_expanded = upto != cu_parse;\n+\n     let src = sess.codemap.get_filemap(source_name(input)).src;\n     do io::with_str_reader(src) |rdr| {\n         pprust::print_crate(sess.codemap, token::get_ident_interner(),\n-                            sess.span_diagnostic, crate.unwrap(),\n+                            sess.span_diagnostic, crate,\n                             source_name(input),\n-                            rdr, io::stdout(), ann, is_expanded);\n+                            rdr, io::stdout(),\n+                            annotation, is_expanded);\n     }\n }\n \n@@ -864,7 +883,7 @@ pub fn build_output_filenames(input: &input,\n                               ofile: &Option<Path>,\n                               attrs: &[ast::Attribute],\n                               sess: Session)\n-                           -> @OutputFilenames {\n+                           -> ~OutputFilenames {\n     let obj_path;\n     let out_path;\n     let sopts = sess.opts;\n@@ -943,7 +962,7 @@ pub fn build_output_filenames(input: &input,\n       }\n     }\n \n-    @OutputFilenames {\n+    ~OutputFilenames {\n         out_filename: out_path,\n         obj_filename: obj_path\n     }"}, {"sha": "b9318b62a27549de03ab77539f533357ed3282f0", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/098106870e0ebdebb40964624185f304ee7b3d63/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/098106870e0ebdebb40964624185f304ee7b3d63/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=098106870e0ebdebb40964624185f304ee7b3d63", "patch": "@@ -28,15 +28,15 @@ use back::link::{mangle_exported_name};\n use back::{link, abi};\n use driver::session;\n use driver::session::Session;\n-use lib::llvm::{ContextRef, ModuleRef, ValueRef, BasicBlockRef};\n+use driver::driver::{CrateAnalysis, CrateTranslation};\n+use lib::llvm::{ModuleRef, ValueRef, BasicBlockRef};\n use lib::llvm::{llvm, True};\n use lib;\n use metadata::common::LinkMeta;\n use metadata::{csearch, cstore, encoder};\n use middle::astencode;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::lang_items::{MallocFnLangItem, ClosureExchangeMallocFnLangItem};\n-use middle::resolve;\n use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::base;\n@@ -66,7 +66,7 @@ use util::ppaux::{Repr, ty_to_str};\n use middle::trans::type_::Type;\n \n use std::hash;\n-use std::hashmap::{HashMap, HashSet};\n+use std::hashmap::HashMap;\n use std::io;\n use std::libc::c_uint;\n use std::uint;\n@@ -2970,12 +2970,8 @@ pub fn write_abi_version(ccx: &mut CrateContext) {\n \n pub fn trans_crate(sess: session::Session,\n                    crate: &ast::Crate,\n-                   tcx: ty::ctxt,\n-                   output: &Path,\n-                   emap2: resolve::ExportMap2,\n-                   reachable_map: @mut HashSet<ast::node_id>,\n-                   maps: astencode::Maps)\n-                   -> (ContextRef, ModuleRef, LinkMeta) {\n+                   analysis: &CrateAnalysis,\n+                   output: &Path) -> CrateTranslation {\n     // Before we touch LLVM, make sure that multithreading is enabled.\n     if unsafe { !llvm::LLVMRustStartMultithreading() } {\n         //sess.bug(\"couldn't enable multi-threaded LLVM\");\n@@ -2996,12 +2992,12 @@ pub fn trans_crate(sess: session::Session,\n \n     let ccx = @mut CrateContext::new(sess,\n                                      llmod_id,\n-                                     tcx,\n-                                     emap2,\n-                                     maps,\n+                                     analysis.ty_cx,\n+                                     analysis.exp_map2,\n+                                     analysis.maps,\n                                      symbol_hasher,\n                                      link_meta,\n-                                     reachable_map);\n+                                     analysis.reachable);\n \n     {\n         let _icx = push_ctxt(\"data\");\n@@ -3056,5 +3052,9 @@ pub fn trans_crate(sess: session::Session,\n     let link_meta = ccx.link_meta;\n     let llmod = ccx.llmod;\n \n-    return (llcx, llmod, link_meta);\n+    return CrateTranslation {\n+        context: llcx,\n+        module: llmod,\n+        link: link_meta\n+    };\n }"}, {"sha": "0c1f4e203aa452d47501103d4f705a32b0ed3244", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/098106870e0ebdebb40964624185f304ee7b3d63/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/098106870e0ebdebb40964624185f304ee7b3d63/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=098106870e0ebdebb40964624185f304ee7b3d63", "patch": "@@ -223,13 +223,15 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     debug!(\"testing with ^^^^^^ %?\", (||{ println(test) })());\n     let dinput = driver::str_input(test.to_managed());\n     let cfg = driver::build_configuration(sess, binary, &dinput);\n-    let outputs = driver::build_output_filenames(&dinput, &None, &None, [], sess);\n-    let (crate, tcx) = driver::compile_upto(sess, cfg.clone(), &dinput,\n-                                            driver::cu_typeck, Some(outputs));\n+\n+    let crate = driver::phase_1_parse_input(sess, cfg.clone(), &dinput);\n+    let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n+    let analysis = driver::phase_3_run_analysis_passes(sess, expanded_crate);\n+\n     // Once we're typechecked, record the types of all local variables defined\n     // in this input\n-    do find_main(crate.expect(\"crate after cu_typeck\"), sess) |blk| {\n-        program.register_new_vars(blk, tcx.expect(\"tcx after cu_typeck\"));\n+    do find_main(crate, sess) |blk| {\n+        program.register_new_vars(blk, analysis.ty_cx);\n     }\n \n     //\n@@ -242,8 +244,12 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     let cfg = driver::build_configuration(sess, binary, &input);\n     let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n     let sess = driver::build_session(options, diagnostic::emit);\n-    driver::compile_upto(sess, cfg, &input, driver::cu_everything,\n-                         Some(outputs));\n+\n+    let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n+    let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n+    let analysis = driver::phase_3_run_analysis_passes(sess, expanded_crate);\n+    let trans = driver::phase_4_translate_to_llvm(sess, expanded_crate, &analysis, outputs);\n+    driver::phase_5_run_llvm_passes(sess, &trans, outputs);\n \n     //\n     // Stage 4: Inform the program that computation is done so it can update all\n@@ -265,10 +271,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n         let code = fmt!(\"fn main() {\\n %s \\n}\", input);\n         let input = driver::str_input(code.to_managed());\n         let cfg = driver::build_configuration(sess, binary, &input);\n-        let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n-        let (crate, _) = driver::compile_upto(sess, cfg, &input,\n-                                              driver::cu_parse, Some(outputs));\n-        crate.expect(\"parsing should return a crate\")\n+        driver::phase_1_parse_input(sess, cfg.clone(), &input)\n     }\n \n     fn find_main(crate: @ast::Crate, sess: session::Session,\n@@ -334,9 +337,12 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n             None => { },\n         }\n         if (should_compile) {\n-            printfln!(\"compiling %s...\", src_filename);\n-            driver::compile_upto(sess, cfg, &input, driver::cu_everything,\n-                                 Some(outputs));\n+            println(fmt!(\"compiling %s...\", src_filename));\n+            let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n+            let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n+            let analysis = driver::phase_3_run_analysis_passes(sess, expanded_crate);\n+            let trans = driver::phase_4_translate_to_llvm(sess, expanded_crate, &analysis, outputs);\n+            driver::phase_5_run_llvm_passes(sess, &trans, outputs);\n             true\n         } else { false }\n     } {"}, {"sha": "b2aa53f3ab15fec26871f9d0d79768f72e91941c", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/098106870e0ebdebb40964624185f304ee7b3d63/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/098106870e0ebdebb40964624185f304ee7b3d63/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=098106870e0ebdebb40964624185f304ee7b3d63", "patch": "@@ -109,7 +109,8 @@ impl<'self> PkgScript<'self> {\n         let input = driver::file_input(script);\n         let sess = driver::build_session(options, diagnostic::emit);\n         let cfg = driver::build_configuration(sess, binary, &input);\n-        let (crate, _) = driver::compile_upto(sess, cfg.clone(), &input, driver::cu_parse, None);\n+        let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n+        let crate = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n         let work_dir = build_pkg_id_in_workspace(id, workspace);\n \n         debug!(\"Returning package script with id %?\", id);\n@@ -119,7 +120,7 @@ impl<'self> PkgScript<'self> {\n             input: input,\n             sess: sess,\n             cfg: cfg,\n-            crate: crate.unwrap(),\n+            crate: crate,\n             build_dir: work_dir\n         }\n     }\n@@ -142,14 +143,10 @@ impl<'self> PkgScript<'self> {\n                 let root = r.pop().pop().pop().pop(); // :-\\\n                 debug!(\"Root is %s, calling compile_rest\", root.to_str());\n                 let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n-                let binary = os::args()[0].to_managed();\n                 util::compile_crate_from_input(&self.input,\n                                                &self.build_dir,\n                                                sess,\n-                                               crate,\n-                                               driver::build_configuration(sess,\n-                                                                           binary, &self.input),\n-                                               driver::cu_parse);\n+                                               crate);\n                 debug!(\"Running program: %s %s %s %s\", exe.to_str(),\n                        sysroot.to_str(), root.to_str(), \"install\");\n                 // FIXME #7401 should support commands besides `install`"}, {"sha": "12d3f4fcfcec67615f80e46a8e8ff4b8c79535a2", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/098106870e0ebdebb40964624185f304ee7b3d63/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/098106870e0ebdebb40964624185f304ee7b3d63/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=098106870e0ebdebb40964624185f304ee7b3d63", "patch": "@@ -18,7 +18,6 @@ use syntax::ext::base::ExtCtxt;\n use syntax::{ast, attr, codemap, diagnostic, fold};\n use syntax::attr::AttrMetaMethods;\n use rustc::back::link::output_type_exe;\n-use rustc::driver::driver::compile_upto;\n use rustc::driver::session::{lib_crate, bin_crate};\n use context::Ctx;\n use package_id::PkgId;\n@@ -220,12 +219,8 @@ pub fn compile_input(ctxt: &Ctx,\n     // Infer dependencies that rustpkg needs to build, by scanning for\n     // `extern mod` directives.\n     let cfg = driver::build_configuration(sess, binary, &input);\n-    let (crate_opt, _) = driver::compile_upto(sess, cfg.clone(), &input, driver::cu_expand, None);\n-\n-    let mut crate = match crate_opt {\n-        Some(c) => c,\n-        None => fail!(\"compile_input expected...\")\n-    };\n+    let mut crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n+    crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n \n     // Not really right. Should search other workspaces too, and the installed\n     // database (which doesn't exist yet)\n@@ -257,7 +252,7 @@ pub fn compile_input(ctxt: &Ctx,\n \n     debug!(\"calling compile_crate_from_input, out_dir = %s,\n            building_library = %?\", out_dir.to_str(), sess.building_library);\n-    compile_crate_from_input(&input, out_dir, sess, crate, cfg.clone(), driver::cu_expand);\n+    compile_crate_from_input(&input, out_dir, sess, crate);\n     true\n }\n \n@@ -269,9 +264,7 @@ pub fn compile_input(ctxt: &Ctx,\n pub fn compile_crate_from_input(input: &driver::input,\n                                 build_dir: &Path,\n                                 sess: session::Session,\n-                                crate: @ast::Crate,\n-                                cfg: ast::CrateConfig,\n-                                compile_from: driver::compile_phase) {\n+                                crate: @ast::Crate) {\n     debug!(\"Calling build_output_filenames with %s, building library? %?\",\n            build_dir.to_str(), sess.building_library);\n \n@@ -284,15 +277,13 @@ pub fn compile_crate_from_input(input: &driver::input,\n     for sess.opts.addl_lib_search_paths.iter().advance |lib| {\n         debug!(\"an additional library: %s\", lib.to_str());\n     }\n-\n-    driver::compile_rest(sess,\n-                         cfg,\n-                         compile_upto {\n-                             from: compile_from,\n-                             to: driver::cu_everything\n-                         },\n-                         Some(outputs),\n-                         Some(crate));\n+    let analysis = driver::phase_3_run_analysis_passes(sess, crate);\n+    let translation = driver::phase_4_translate_to_llvm(sess, crate,\n+                                                        &analysis,\n+                                                        outputs);\n+    driver::phase_5_run_llvm_passes(sess, &translation, outputs);\n+    if driver::stop_after_phase_5(sess) { return; }\n+    driver::phase_6_link_output(sess, &translation, outputs);\n }\n \n #[cfg(windows)]"}]}