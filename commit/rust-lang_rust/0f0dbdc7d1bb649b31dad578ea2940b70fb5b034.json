{"sha": "0f0dbdc7d1bb649b31dad578ea2940b70fb5b034", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMGRiZGM3ZDFiYjY0OWIzMWRhZDU3OGVhMjk0MGI3MGZiNWIwMzQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-24T19:05:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-24T19:05:41Z"}, "message": "Merge #9396\n\n9396: feat: Highlight loop break points r=Veykril a=Veykril\n\n![Code_HmWQMlioKr](https://user-images.githubusercontent.com/3757771/123318732-d47be280-d52f-11eb-8a9a-cb3f591d4195.png)\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "16ea81793d6ab67e9ad809b9db2cb0334b716d0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16ea81793d6ab67e9ad809b9db2cb0334b716d0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f0dbdc7d1bb649b31dad578ea2940b70fb5b034", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg1NeFCRBK7hj4Ov3rIwAAHroIAD43F+aq6qFCkxRrLwePWeRc\ndBweHkXGUuzgy2mJiSymlZrciFcos+ws6TlJc0PcDaf9XlQlxaJCRyvHxvWxmJWs\nqiOtJP49PVJbGrjauFBe+G7aeIzTeyM0+GopzwLDJQKGoCnt/qg0Ycs2n7xFpG6z\nAVcq+GzrxqGbwIArJDCDFlnqBWEk+pURkwbEGJ82Z7NIJNtMDPR4AmI8fRdPYiAZ\nAEFMUVlzazlDGLDsjDwHrHca2vsUVlK5FklXuS0aKXec2jHXlNn63O6ffbfhZCsa\neOeL2N66uigh2q9KTQ2Tnt2nzQFttLrcf7iYnez5ILdj1FSVk3syYYgNaxBrBNY=\n=/4yJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 16ea81793d6ab67e9ad809b9db2cb0334b716d0f\nparent 264716e827f9b316c2a346efcf6dd740dbd0fb84\nparent 42efd211bcee72bfbcff340cc45db51a5b8906be\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1624561541 +0000\ncommitter GitHub <noreply@github.com> 1624561541 +0000\n\nMerge #9396\n\n9396: feat: Highlight loop break points r=Veykril a=Veykril\n\n![Code_HmWQMlioKr](https://user-images.githubusercontent.com/3757771/123318732-d47be280-d52f-11eb-8a9a-cb3f591d4195.png)\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f0dbdc7d1bb649b31dad578ea2940b70fb5b034", "html_url": "https://github.com/rust-lang/rust/commit/0f0dbdc7d1bb649b31dad578ea2940b70fb5b034", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f0dbdc7d1bb649b31dad578ea2940b70fb5b034/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "264716e827f9b316c2a346efcf6dd740dbd0fb84", "url": "https://api.github.com/repos/rust-lang/rust/commits/264716e827f9b316c2a346efcf6dd740dbd0fb84", "html_url": "https://github.com/rust-lang/rust/commit/264716e827f9b316c2a346efcf6dd740dbd0fb84"}, {"sha": "42efd211bcee72bfbcff340cc45db51a5b8906be", "url": "https://api.github.com/repos/rust-lang/rust/commits/42efd211bcee72bfbcff340cc45db51a5b8906be", "html_url": "https://github.com/rust-lang/rust/commit/42efd211bcee72bfbcff340cc45db51a5b8906be"}], "stats": {"total": 283, "additions": 271, "deletions": 12}, "files": [{"sha": "8ec123cf8a7a18e4d0a9095936d7a9d4b1923b10", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 271, "deletions": 12, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/0f0dbdc7d1bb649b31dad578ea2940b70fb5b034/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0dbdc7d1bb649b31dad578ea2940b70fb5b034/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=0f0dbdc7d1bb649b31dad578ea2940b70fb5b034", "patch": "@@ -24,6 +24,7 @@ pub struct HighlightedRange {\n // - if on an identifier, highlights all references to that identifier in the current file\n // - if on an `async` or `await token, highlights all yield points for that async context\n // - if on a `return` token, `?` character or `->` return type arrow, highlights all exit points for that context\n+// - if on a `break`, `loop`, `while` or `for` token, highlights all break points for that loop or block context\n pub(crate) fn highlight_related(\n     sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n@@ -33,13 +34,21 @@ pub(crate) fn highlight_related(\n \n     let token = pick_best_token(syntax.token_at_offset(position.offset), |kind| match kind {\n         T![?] => 2, // prefer `?` when the cursor is sandwiched like `await$0?`\n-        T![await] | T![async] | T![return] | T![->] => 1,\n+        T![await]\n+        | T![async]\n+        | T![return]\n+        | T![break]\n+        | T![loop]\n+        | T![for]\n+        | T![while]\n+        | T![->] => 1,\n         _ => 0,\n     })?;\n \n     match token.kind() {\n         T![return] | T![?] | T![->] => highlight_exit_points(sema, token),\n         T![await] | T![async] => highlight_yield_points(token),\n+        T![break] | T![loop] | T![for] | T![while] => highlight_break_points(token),\n         _ => highlight_references(sema, &syntax, position),\n     }\n }\n@@ -112,8 +121,13 @@ fn highlight_exit_points(\n \n         if let Some(tail) = tail {\n             for_each_inner_tail(&tail, &mut |tail| {\n-                highlights\n-                    .push(HighlightedRange { access: None, range: tail.syntax().text_range() })\n+                let range = match tail {\n+                    ast::Expr::BreakExpr(b) => b\n+                        .break_token()\n+                        .map_or_else(|| tail.syntax().text_range(), |tok| tok.text_range()),\n+                    _ => tail.syntax().text_range(),\n+                };\n+                highlights.push(HighlightedRange { access: None, range })\n             });\n         }\n         Some(highlights)\n@@ -135,6 +149,65 @@ fn highlight_exit_points(\n     None\n }\n \n+fn highlight_break_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n+    fn hl(\n+        token: Option<SyntaxToken>,\n+        label: Option<ast::Label>,\n+        body: Option<ast::BlockExpr>,\n+    ) -> Option<Vec<HighlightedRange>> {\n+        let mut highlights = Vec::new();\n+        let range = cover_range(\n+            token.map(|tok| tok.text_range()),\n+            label.as_ref().map(|it| it.syntax().text_range()),\n+        );\n+        highlights.extend(range.map(|range| HighlightedRange { access: None, range }));\n+        for_each_break(label, body, &mut |break_| {\n+            let range = cover_range(\n+                break_.break_token().map(|it| it.text_range()),\n+                break_.lifetime().map(|it| it.syntax().text_range()),\n+            );\n+            highlights.extend(range.map(|range| HighlightedRange { access: None, range }));\n+        });\n+        Some(highlights)\n+    }\n+    let parent = token.parent()?;\n+    let lbl = match_ast! {\n+        match parent {\n+            ast::BreakExpr(b) => b.lifetime(),\n+            ast::LoopExpr(l) => l.label().and_then(|it| it.lifetime()),\n+            ast::ForExpr(f) => f.label().and_then(|it| it.lifetime()),\n+            ast::WhileExpr(w) => w.label().and_then(|it| it.lifetime()),\n+            ast::EffectExpr(b) => Some(b.label().and_then(|it| it.lifetime())?),\n+            _ => return None,\n+        }\n+    };\n+    let lbl = lbl.as_ref();\n+    let label_matches = |def_lbl: Option<ast::Label>| match lbl {\n+        Some(lbl) => {\n+            Some(lbl.text()) == def_lbl.and_then(|it| it.lifetime()).as_ref().map(|it| it.text())\n+        }\n+        None => true,\n+    };\n+    for anc in token.ancestors().flat_map(ast::Expr::cast) {\n+        return match anc {\n+            ast::Expr::LoopExpr(l) if label_matches(l.label()) => {\n+                hl(l.loop_token(), l.label(), l.loop_body())\n+            }\n+            ast::Expr::ForExpr(f) if label_matches(f.label()) => {\n+                hl(f.for_token(), f.label(), f.loop_body())\n+            }\n+            ast::Expr::WhileExpr(w) if label_matches(w.label()) => {\n+                hl(w.while_token(), w.label(), w.loop_body())\n+            }\n+            ast::Expr::EffectExpr(e) if e.label().is_some() && label_matches(e.label()) => {\n+                hl(None, e.label(), e.block_expr())\n+            }\n+            _ => continue,\n+        };\n+    }\n+    None\n+}\n+\n fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n     fn hl(\n         async_token: Option<SyntaxToken>,\n@@ -221,7 +294,13 @@ fn for_each_inner_tail(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n             }\n         }\n         ast::Expr::EffectExpr(e) => match e.effect() {\n-            ast::Effect::Label(_) | ast::Effect::Unsafe(_) => {\n+            ast::Effect::Label(label) => {\n+                for_each_break(Some(label), e.block_expr(), &mut |b| cb(&ast::Expr::BreakExpr(b)));\n+                if let Some(b) = e.block_expr() {\n+                    for_each_inner_tail(&ast::Expr::BlockExpr(b), cb);\n+                }\n+            }\n+            ast::Effect::Unsafe(_) => {\n                 if let Some(e) = e.block_expr().and_then(|b| b.tail_expr()) {\n                     for_each_inner_tail(&e, cb);\n                 }\n@@ -231,7 +310,9 @@ fn for_each_inner_tail(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n         ast::Expr::IfExpr(if_) => {\n             if_.blocks().for_each(|block| for_each_inner_tail(&ast::Expr::BlockExpr(block), cb))\n         }\n-        ast::Expr::LoopExpr(l) => for_each_break(l, cb),\n+        ast::Expr::LoopExpr(l) => {\n+            for_each_break(l.label(), l.loop_body(), &mut |b| cb(&ast::Expr::BreakExpr(b)))\n+        }\n         ast::Expr::MatchExpr(m) => {\n             if let Some(arms) = m.match_arm_list() {\n                 arms.arms().filter_map(|arm| arm.expr()).for_each(|e| for_each_inner_tail(&e, cb));\n@@ -267,10 +348,14 @@ fn for_each_inner_tail(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n     }\n }\n \n-fn for_each_break(l: &ast::LoopExpr, cb: &mut dyn FnMut(&ast::Expr)) {\n-    let label = l.label().and_then(|lbl| lbl.lifetime());\n+fn for_each_break(\n+    label: Option<ast::Label>,\n+    body: Option<ast::BlockExpr>,\n+    cb: &mut dyn FnMut(ast::BreakExpr),\n+) {\n+    let label = label.and_then(|lbl| lbl.lifetime());\n     let mut depth = 0;\n-    if let Some(b) = l.loop_body() {\n+    if let Some(b) = body {\n         let preorder = &mut b.syntax().preorder();\n         let ev_as_expr = |ev| match ev {\n             WalkEvent::Enter(it) => Some(WalkEvent::Enter(ast::Expr::cast(it)?)),\n@@ -281,13 +366,13 @@ fn for_each_break(l: &ast::LoopExpr, cb: &mut dyn FnMut(&ast::Expr)) {\n         };\n         while let Some(node) = preorder.find_map(ev_as_expr) {\n             match node {\n-                WalkEvent::Enter(expr) => match &expr {\n+                WalkEvent::Enter(expr) => match expr {\n                     ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_) => {\n                         depth += 1\n                     }\n                     ast::Expr::EffectExpr(e) if e.label().is_some() => depth += 1,\n                     ast::Expr::BreakExpr(b) if depth == 0 || eq_label(b.lifetime()) => {\n-                        cb(&expr);\n+                        cb(b);\n                     }\n                     _ => (),\n                 },\n@@ -303,6 +388,15 @@ fn for_each_break(l: &ast::LoopExpr, cb: &mut dyn FnMut(&ast::Expr)) {\n     }\n }\n \n+fn cover_range(r0: Option<TextRange>, r1: Option<TextRange>) -> Option<TextRange> {\n+    match (r0, r1) {\n+        (Some(r0), Some(r1)) => Some(r0.cover(r1)),\n+        (Some(range), None) => Some(range),\n+        (None, Some(range)) => Some(range),\n+        (None, None) => None,\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::fixture;\n@@ -564,12 +658,12 @@ fn foo() ->$0 u32 {\n               // ^^^\n             7 => loop {\n                 break 5;\n-             // ^^^^^^^\n+             // ^^^^^\n             }\n             8 => 'a: loop {\n                 'b: loop {\n                     break 'a 5;\n-                 // ^^^^^^^^^^\n+                 // ^^^^^\n                     break 'b 5;\n                     break 5;\n                 };\n@@ -580,6 +674,171 @@ fn foo() ->$0 u32 {\n         }\n     }\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_inner_tail_exit_points_labeled_block() {\n+        check(\n+            r#\"\n+fn foo() ->$0 u32 {\n+    'foo: {\n+        break 'foo 0;\n+     // ^^^^^\n+        loop {\n+            break;\n+            break 'foo 0;\n+         // ^^^^^\n+        }\n+        0\n+     // ^\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_break_loop() {\n+        check(\n+            r#\"\n+fn foo() {\n+    'outer: loop {\n+ // ^^^^^^^^^^^^\n+         break;\n+      // ^^^^^\n+         'inner: loop {\n+            break;\n+            'innermost: loop {\n+                break 'outer;\n+             // ^^^^^^^^^^^^\n+                break 'inner;\n+            }\n+            break$0 'outer;\n+         // ^^^^^^^^^^^^\n+            break;\n+        }\n+        break;\n+     // ^^^^^\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_break_for() {\n+        check(\n+            r#\"\n+fn foo() {\n+    'outer: for _ in () {\n+ // ^^^^^^^^^^^\n+         break;\n+      // ^^^^^\n+         'inner: for _ in () {\n+            break;\n+            'innermost: for _ in () {\n+                break 'outer;\n+             // ^^^^^^^^^^^^\n+                break 'inner;\n+            }\n+            break$0 'outer;\n+         // ^^^^^^^^^^^^\n+            break;\n+        }\n+        break;\n+     // ^^^^^\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_break_while() {\n+        check(\n+            r#\"\n+fn foo() {\n+    'outer: while true {\n+ // ^^^^^^^^^^^^^\n+         break;\n+      // ^^^^^\n+         'inner: while true {\n+            break;\n+            'innermost: while true {\n+                break 'outer;\n+             // ^^^^^^^^^^^^\n+                break 'inner;\n+            }\n+            break$0 'outer;\n+         // ^^^^^^^^^^^^\n+            break;\n+        }\n+        break;\n+     // ^^^^^\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_break_labeled_block() {\n+        check(\n+            r#\"\n+fn foo() {\n+    'outer: {\n+ // ^^^^^^^\n+         break;\n+      // ^^^^^\n+         'inner: {\n+            break;\n+            'innermost: {\n+                break 'outer;\n+             // ^^^^^^^^^^^^\n+                break 'inner;\n+            }\n+            break$0 'outer;\n+         // ^^^^^^^^^^^^\n+            break;\n+        }\n+        break;\n+     // ^^^^^\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_break_unlabeled_loop() {\n+        check(\n+            r#\"\n+fn foo() {\n+    loop {\n+ // ^^^^\n+        break$0;\n+     // ^^^^^\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_break_unlabeled_block_in_loop() {\n+        check(\n+            r#\"\n+fn foo() {\n+    loop {\n+ // ^^^^\n+        {\n+            break$0;\n+         // ^^^^^\n+        }\n+    }\n+}\n \"#,\n         );\n     }"}]}