{"sha": "ccb721a58d2973ea65e382d8af28932aa649b579", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjYjcyMWE1OGQyOTczZWE2NWUzODJkOGFmMjg5MzJhYTY0OWI1Nzk=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-09-13T14:26:35Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-09-15T10:28:25Z"}, "message": "debuginfo: Added description of algorithm for handling recursive types.\n\nAlso fixed nasty bug caused by calling LLVMDIBuilderCreateStructType() with a null pointer where an empty array was expected (which would trigger an unintelligable assertion somewhere down the line).", "tree": {"sha": "4fb423b9a0f71871b715cd01d26a17efb65deefe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fb423b9a0f71871b715cd01d26a17efb65deefe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccb721a58d2973ea65e382d8af28932aa649b579", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccb721a58d2973ea65e382d8af28932aa649b579", "html_url": "https://github.com/rust-lang/rust/commit/ccb721a58d2973ea65e382d8af28932aa649b579", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccb721a58d2973ea65e382d8af28932aa649b579/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ce02e71448548d779413860632e07646cbc96b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ce02e71448548d779413860632e07646cbc96b3", "html_url": "https://github.com/rust-lang/rust/commit/1ce02e71448548d779413860632e07646cbc96b3"}], "stats": {"total": 184, "additions": 72, "deletions": 112}, "files": [{"sha": "b10f03729e44c996584d0e6cd81c1fc1d04b778a", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 66, "deletions": 83, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/ccb721a58d2973ea65e382d8af28932aa649b579/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb721a58d2973ea65e382d8af28932aa649b579/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ccb721a58d2973ea65e382d8af28932aa649b579", "patch": "@@ -45,6 +45,46 @@ This file consists of three conceptual sections:\n 2. Module-internal metadata creation functions\n 3. Minor utility functions\n \n+\n+## Recursive Types\n+Some kinds of types, such as structs and enums can be recursive. That means that the type definition\n+of some type X refers to some other type which in turn (transitively) refers to X. This introduces\n+cycles into the type referral graph. A naive algorithm doing an on-demand, depth-first traversal of\n+this graph when describing types, can get trapped in an endless loop when it reaches such a cycle.\n+\n+For example, the following simple type for a singly-linked list...\n+\n+```\n+struct List {\n+    value: int,\n+    tail: Option<@List>,\n+}\n+```\n+\n+will generate the following callstack with a naive DFS algorithm:\n+\n+```\n+describe(t = List)\n+  describe(t = int)\n+  describe(t = Option<@List>)\n+    describe(t = @List)\n+      describe(t = List) // at the beginning again...\n+      ...\n+```\n+\n+To break cycles like these, we use \"forward declarations\". That is, when the algorithm encounters a\n+possibly recursive type (any struct or enum), it immediately creates a type description node and\n+inserts it into the cache *before* describing the members of the type. This type description is just\n+a stub (as type members are not described and added to it yet) but it allows the algorithm to\n+already refer to the type. After the stub is inserted into the cache, the algorithm continues as\n+before. If it now encounters a recursive reference, it will hit the cache and does not try to\n+describe the type anew.\n+\n+This behaviour is encapsulated in the 'RecursiveTypeDescription' enum, which represents a kind of\n+continuation, storing all state needed to continue traversal at the type members after the type has\n+been registered with the cache. (This implementation approach might be a tad over-engineered and\n+may change in the future)\n+\n */\n \n \n@@ -561,16 +601,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n             _) => {\n             (ident, fn_decl, generics, Some(top_level_block), span)\n         }\n-        ast_map::node_foreign_item(@ast::foreign_item {\n-                ident: ident,\n-                node: ast::foreign_item_fn(ref fn_decl, ref generics),\n-                span: span,\n-                _\n-            },\n-            _,\n-            _,\n-            _) => {\n-            //(ident, fn_decl, generics, None, span)\n+        ast_map::node_foreign_item(@ast::foreign_item { _ }, _, _, _) => {\n             return FunctionWithoutDebugInfo;\n         }\n         ast_map::node_variant(*)     |\n@@ -1062,18 +1093,13 @@ fn prepare_struct_metadata(cx: &mut CrateContext,\n                            span: Span)\n                         -> RecursiveTypeDescription {\n     let struct_name = ppaux::ty_to_str(cx.tcx, struct_type);\n-    println(fmt!(\"struct_metadata: %s\", struct_name));\n-\n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n+\n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id, span);\n \n     let file_name = span_start(cx, definition_span).file.name;\n     let file_metadata = file_metadata(cx, file_name);\n \n-    let loc = span_start(cx, definition_span);\n-\n-    let (composite_size, composite_align) = size_and_align_of(cx, struct_llvm_type);\n-\n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n                                                   struct_name,\n@@ -1142,43 +1168,14 @@ impl RecursiveTypeDescription {\n \n                 // ... then create the member descriptions\n                 let member_descriptions = member_description_factory(cx);\n-                let member_metadata: ~[DIDescriptor] = member_descriptions\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, member_description)| {\n-                        let (member_size,\n-                             member_align) = size_and_align_of(cx, member_description.llvm_type);\n-                        let member_offset = match member_description.offset {\n-                            FixedMemberOffset { bytes } => bytes,\n-                            ComputedMemberOffset => {\n-                                machine::llelement_offset(cx, llvm_type, i)\n-                            }\n-                        };\n-\n-                        do member_description.name.with_c_str |member_name| {\n-                            unsafe {\n-                                llvm::LLVMDIBuilderCreateMemberType(\n-                                    DIB(cx),\n-                                    metadata_stub,\n-                                    member_name,\n-                                    file_metadata,\n-                                    0 as c_uint,\n-                                    bytes_to_bits(member_size),\n-                                    bytes_to_bits(member_align),\n-                                    bytes_to_bits(member_offset),\n-                                    0,\n-                                    member_description.type_metadata)\n-                            }\n-                        }\n-                    })\n-                    .collect();\n-\n-                unsafe {\n-                    let type_array = create_DIArray(DIB(cx), member_metadata);\n-                    llvm::LLVMDICompositeTypeSetTypeArray(metadata_stub, type_array);\n-                }\n \n-                metadata_stub\n+                set_members_of_composite_type(cx,\n+                                              metadata_stub,\n+                                              llvm_type,\n+                                              member_descriptions,\n+                                              file_metadata,\n+                                              codemap::dummy_sp());\n+                return metadata_stub;\n             }\n         }\n     }\n@@ -1469,6 +1466,7 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n \n enum MemberOffset {\n     FixedMemberOffset{ bytes: uint },\n+    // For ComputedMemberOffset, the offset is read from the llvm type definition\n     ComputedMemberOffset\n }\n \n@@ -1490,26 +1488,15 @@ fn composite_type_metadata(cx: &mut CrateContext,\n                            file_metadata: DIFile,\n                            definition_span: Span)\n                         -> DICompositeType {\n-    let loc = span_start(cx, definition_span);\n-    let (composite_size, composite_align) = size_and_align_of(cx, composite_llvm_type);\n-\n-    let composite_type_metadata = do composite_type_name.with_c_str |name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateStructType(\n-                DIB(cx),\n-                containing_scope,\n-                name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                bytes_to_bits(composite_size),\n-                bytes_to_bits(composite_align),\n-                0,\n-                ptr::null(),\n-                ptr::null(),\n-                0,\n-                ptr::null())\n-    }};\n-\n+    // Create the (empty) struct metadata node ...\n+    let composite_type_metadata = create_struct_stub(cx,\n+                                                     composite_llvm_type,\n+                                                     composite_type_name,\n+                                                     containing_scope,\n+                                                     file_metadata,\n+                                                     definition_span);\n+\n+    // ... and immediately create and add the member descriptions.\n     set_members_of_composite_type(cx,\n                                   composite_type_metadata,\n                                   composite_llvm_type,\n@@ -1563,7 +1550,7 @@ fn set_members_of_composite_type(cx: &mut CrateContext,\n }\n \n // A convenience wrapper around LLVMDIBuilderCreateStructType(). Does not do any caching, does not\n-// add any fields to the struct. This can be done later with LLVMDICompositeTypeSetTypeArray().\n+// add any fields to the struct. This can be done later with set_members_of_composite_type().\n fn create_struct_stub(cx: &mut CrateContext,\n                       struct_llvm_type: Type,\n                       struct_type_name: &str,\n@@ -1576,6 +1563,10 @@ fn create_struct_stub(cx: &mut CrateContext,\n \n     return do struct_type_name.with_c_str |name| {\n         unsafe {\n+            // LLVMDIBuilderCreateStructType() wants an empty array. A null pointer will lead to\n+            // hard to trace and debug LLVM assertions later on in llvm/lib/IR/Value.cpp\n+            let empty_array = create_DIArray(DIB(cx), []);\n+\n             llvm::LLVMDIBuilderCreateStructType(\n                 DIB(cx),\n                 containing_scope,\n@@ -1586,7 +1577,7 @@ fn create_struct_stub(cx: &mut CrateContext,\n                 bytes_to_bits(struct_align),\n                 0,\n                 ptr::null(),\n-                ptr::null(),\n+                empty_array,\n                 0,\n                 ptr::null())\n     }};\n@@ -1864,7 +1855,7 @@ fn trait_metadata(cx: &mut CrateContext,\n                   substs: &ty::substs,\n                   trait_store: ty::TraitStore,\n                   mutability: ast::Mutability,\n-                  builtinBounds: &ty::BuiltinBounds,\n+                  _: &ty::BuiltinBounds,\n                   usage_site_span: Span)\n                -> DIType {\n     // The implementation provided here is a stub. It makes sure that the trait type is\n@@ -2120,14 +2111,6 @@ fn DIB(cx: &CrateContext) -> DIBuilderRef {\n     cx.dbg_cx.get_ref().builder\n }\n \n-fn assert_fcx_has_span(fcx: &FunctionContext) {\n-    if fcx.span.is_none() {\n-        fcx.ccx.sess.bug(fmt!(\"debuginfo: Encountered function %s with invalid source span. \\\n-            This function should have been ignored by debuginfo generation.\",\n-            ast_map::path_to_str(fcx.path, fcx.ccx.sess.intr())));\n-    }\n-}\n-\n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n     match fcx.debug_context {\n         FunctionDebugContext(_) => false,"}, {"sha": "63d42816207cd79dae5cd0713cd6233e2d0d4882", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ccb721a58d2973ea65e382d8af28932aa649b579/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ccb721a58d2973ea65e382d8af28932aa649b579/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=ccb721a58d2973ea65e382d8af28932aa649b579", "patch": "@@ -790,29 +790,6 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateNameSpace(\n         LineNo));\n }\n \n-// extern \"C\" LLVMValueRef LLVMDIBuilderCreateForwardDecl(\n-//     DIBuilderRef Builder,\n-//     unsigned Tag,\n-//     const char* Name,\n-//     LLVMValueRef Scope,\n-//     LLVMValueRef File,\n-//     unsigned Line,\n-//     unsigned RuntimeLang,\n-//     uint64_t SizeInBits,\n-//     uint64_t AlignInBits)\n-// {\n-//     return wrap(Builder->createForwardDecl(\n-//         Tag,\n-//         Name,\n-//         unwrapDI<DIDescriptor>(Scope),\n-//         unwrapDI<DIFile>(File),\n-//         Line,\n-//         RuntimeLang,\n-//         SizeInBits,\n-//         AlignInBits\n-//     ));\n-// }\n-\n extern \"C\" void LLVMDICompositeTypeSetTypeArray(\n     LLVMValueRef CompositeType,\n     LLVMValueRef TypeArray)"}, {"sha": "b8a43d6d16a40a82493afb40fbfc001b0e60e3ff", "filename": "src/test/debug-info/recursive-struct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ccb721a58d2973ea65e382d8af28932aa649b579/src%2Ftest%2Fdebug-info%2Frecursive-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb721a58d2973ea65e382d8af28932aa649b579/src%2Ftest%2Fdebug-info%2Frecursive-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Frecursive-struct.rs?ref=ccb721a58d2973ea65e382d8af28932aa649b579", "patch": "@@ -142,14 +142,14 @@ struct LongCycleWithAnonymousTypes {\n \n // This test case makes sure that recursive structs are properly described. The Node structs are\n // generic so that we can have a new type (that newly needs to be described) for the different\n-// cases. The potential problem with recursive types is that the DI generation algorithm get trapped\n-// in an endless loop. To make sure, we actually test this in the different cases, we have to\n-// operate on a new type each time, otherwise we would just hit the DI cache for all but the first\n-// case.\n+// cases. The potential problem with recursive types is that the DI generation algorithm gets\n+// trapped in an endless loop. To make sure, we actually test this in the different cases, we have\n+// to operate on a new type each time, otherwise we would just hit the DI cache for all but the\n+// first case.\n \n // The different cases below (stack_*, unique_*, box_*, etc) are set up so that the type description\n // algorithm will enter the type reference cycle that is created by a recursive definition from a\n-// different context.\n+// different context each time.\n \n // The \"long cycle\" cases are constructed to span a longer, indirect recursion cycle between types.\n // The different locals will cause the DI algorithm to enter the type reference cycle at different"}, {"sha": "4ec9fae1e2f126eb3d2a329ec7b7596b0134268a", "filename": "src/test/debug-info/trait-pointers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccb721a58d2973ea65e382d8af28932aa649b579/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb721a58d2973ea65e382d8af28932aa649b579/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs?ref=ccb721a58d2973ea65e382d8af28932aa649b579", "patch": "@@ -24,7 +24,7 @@ struct Struct {\n \n impl Trait for Struct {}\n \n-// There is no real test here yet. Just make that it compiles without crashing.\n+// There is no real test here yet. Just make sure that it compiles without crashing.\n fn main() {\n     let stack_struct = Struct { a:0, b: 1.0 };\n     let reference: &Trait = &stack_struct as &Trait;"}]}