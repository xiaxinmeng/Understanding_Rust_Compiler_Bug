{"sha": "2d2f1a5e88d6749edc3a51b4d68101e972d2ec25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMmYxYTVlODhkNjc0OWVkYzNhNTFiNGQ2ODEwMWU5NzJkMmVjMjU=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-06-15T08:39:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-15T08:39:58Z"}, "message": "Rollup merge of #80269 - pickfire:patch-4, r=joshtriplett\n\nExplain non-dropped sender recv in docs\n\nOriginal senders that are still hanging around could cause\nReceiver::recv to not block since this is a potential footgun\nfor beginners, clarify more on this in the docs for readers to\nbe aware about it.\n\nMaybe it would be better to show an example of the pattern where `drop(tx)` is used when it is being cloned multiple times? Although I have seen it in quite a few articles but I am surprised that this part is not very clear with the current words without careful reading.\n\n> If the corresponding Sender has disconnected, or it disconnects while this call is blocking, this call will wake up and return Err to indicate that no more messages can ever be received on this channel. However, since channels are buffered, messages sent before the disconnect will still be properly received.\n\nSome words there may seemed similar if I carefully read and relate it but if I am new, I probably does not know \"drop\" makes it \"disconnected\". So I mention the words \"drop\" and \"alive\" to make it more relatable to lifetime.", "tree": {"sha": "4ce62f9f562a1f6e9edbc729f039d88b19e82ee7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ce62f9f562a1f6e9edbc729f039d88b19e82ee7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d2f1a5e88d6749edc3a51b4d68101e972d2ec25", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgyGdhCRBK7hj4Ov3rIwAAtnMIAJ9v3xQCG1sTJ132zMJUU6Xp\ndtgDWTM4PNKn5tOLocC4DqNq1nl4U3MEVkTLfDrD0uSTd65tASISWZhtSpVKjnHn\n6gxj1fIxRJk0uR9P1xpGXZEhfVG64w+vlvpD5DTcB2ycRY/4KTWIsfU+mhzyQ/TN\n6DPmFE65zcSp1eBQsqQx9JqntFqUd0euYq/uL99NBUlb1/ODgUbNFpzr04JxpOEq\nvZZxEZ7eWwXKg49vxtT9yaAAfhEHpwSJsi5iIswJKR/pe1Iopqhs1ZY09ZGvGVsM\nx9cTUkGvPdrFHK8vFLtpVqxAEgyjE+9slwa0+MiFmCgp+5j3YJ/NYB3SlO8b0E8=\n=0Sm5\n-----END PGP SIGNATURE-----\n", "payload": "tree 4ce62f9f562a1f6e9edbc729f039d88b19e82ee7\nparent 9089771daf6b1f1824446cca3306d7c18084eae0\nparent 0f3c7d18fb1213ad285173210820924b76b534a1\nauthor Yuki Okushi <jtitor@2k36.org> 1623746398 +0900\ncommitter GitHub <noreply@github.com> 1623746398 +0900\n\nRollup merge of #80269 - pickfire:patch-4, r=joshtriplett\n\nExplain non-dropped sender recv in docs\n\nOriginal senders that are still hanging around could cause\nReceiver::recv to not block since this is a potential footgun\nfor beginners, clarify more on this in the docs for readers to\nbe aware about it.\n\nMaybe it would be better to show an example of the pattern where `drop(tx)` is used when it is being cloned multiple times? Although I have seen it in quite a few articles but I am surprised that this part is not very clear with the current words without careful reading.\n\n> If the corresponding Sender has disconnected, or it disconnects while this call is blocking, this call will wake up and return Err to indicate that no more messages can ever be received on this channel. However, since channels are buffered, messages sent before the disconnect will still be properly received.\n\nSome words there may seemed similar if I carefully read and relate it but if I am new, I probably does not know \"drop\" makes it \"disconnected\". So I mention the words \"drop\" and \"alive\" to make it more relatable to lifetime.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d2f1a5e88d6749edc3a51b4d68101e972d2ec25", "html_url": "https://github.com/rust-lang/rust/commit/2d2f1a5e88d6749edc3a51b4d68101e972d2ec25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d2f1a5e88d6749edc3a51b4d68101e972d2ec25/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9089771daf6b1f1824446cca3306d7c18084eae0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9089771daf6b1f1824446cca3306d7c18084eae0", "html_url": "https://github.com/rust-lang/rust/commit/9089771daf6b1f1824446cca3306d7c18084eae0"}, {"sha": "0f3c7d18fb1213ad285173210820924b76b534a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f3c7d18fb1213ad285173210820924b76b534a1", "html_url": "https://github.com/rust-lang/rust/commit/0f3c7d18fb1213ad285173210820924b76b534a1"}], "stats": {"total": 53, "additions": 46, "deletions": 7}, "files": [{"sha": "b4f4456537b9693f41b56df9208e5588ce4f88ab", "filename": "library/std/src/sync/mpsc/mod.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2d2f1a5e88d6749edc3a51b4d68101e972d2ec25/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2f1a5e88d6749edc3a51b4d68101e972d2ec25/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs?ref=2d2f1a5e88d6749edc3a51b4d68101e972d2ec25", "patch": "@@ -105,6 +105,35 @@\n //! });\n //! rx.recv().unwrap();\n //! ```\n+//!\n+//! Unbounded receive loop:\n+//!\n+//! ```\n+//! use std::sync::mpsc::sync_channel;\n+//! use std::thread;\n+//!\n+//! let (tx, rx) = sync_channel(3);\n+//!\n+//! for _ in 0..3 {\n+//!     // It would be the same without thread and clone here\n+//!     // since there will still be one `tx` left.\n+//!     let tx = tx.clone();\n+//!     // cloned tx dropped within thread\n+//!     thread::spawn(move || tx.send(\"ok\").unwrap());\n+//! }\n+//!\n+//! // Drop the last sender to stop `rx` waiting for message.\n+//! // The program will not complete if we comment this out.\n+//! // **All** `tx` needs to be dropped for `rx` to have `Err`.\n+//! drop(tx);\n+//!\n+//! // Unbounded receiver waiting for all senders to complete.\n+//! while let Ok(msg) = rx.recv() {\n+//!     println!(\"{}\", msg);\n+//! }\n+//!\n+//! println!(\"completed\");\n+//! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -437,6 +466,9 @@ pub struct IntoIter<T> {\n ///\n /// Messages can be sent through this channel with [`send`].\n ///\n+/// Note: all senders (the original and the clones) need to be dropped for the receiver\n+/// to stop blocking to receive messages with [`Receiver::recv`].\n+///\n /// [`send`]: Sender::send\n ///\n /// # Examples\n@@ -643,7 +675,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// the same order as it was sent, and no [`send`] will block the calling thread\n /// (this channel has an \"infinite buffer\", unlike [`sync_channel`], which will\n /// block after its buffer limit is reached). [`recv`] will block until a message\n-/// is available.\n+/// is available while there is at least one [`Sender`] alive (including clones).\n ///\n /// The [`Sender`] can be cloned to [`send`] to the same channel multiple times, but\n /// only one [`Receiver`] is supported.\n@@ -806,6 +838,11 @@ impl<T> Sender<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Sender<T> {\n+    /// Clone a sender to send to other threads.\n+    ///\n+    /// Note, be aware of the lifetime of the sender because all senders\n+    /// (including the original) need to be dropped in order for\n+    /// [`Receiver::recv`] to stop blocking.\n     fn clone(&self) -> Sender<T> {\n         let packet = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n@@ -1064,9 +1101,10 @@ impl<T> Receiver<T> {\n     /// corresponding channel has hung up.\n     ///\n     /// This function will always block the current thread if there is no data\n-    /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding [`Sender`] (or [`SyncSender`]), then this\n-    /// receiver will wake up and return that message.\n+    /// available and it's possible for more data to be sent (at least one sender\n+    /// still exists). Once a message is sent to the corresponding [`Sender`]\n+    /// (or [`SyncSender`]), this receiver will wake up and return that\n+    /// message.\n     ///\n     /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n     /// this call is blocking, this call will wake up and return [`Err`] to\n@@ -1146,9 +1184,10 @@ impl<T> Receiver<T> {\n     /// corresponding channel has hung up, or if it waits more than `timeout`.\n     ///\n     /// This function will always block the current thread if there is no data\n-    /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding [`Sender`] (or [`SyncSender`]), then this\n-    /// receiver will wake up and return that message.\n+    /// available and it's possible for more data to be sent (at least one sender\n+    /// still exists). Once a message is sent to the corresponding [`Sender`]\n+    /// (or [`SyncSender`]), this receiver will wake up and return that\n+    /// message.\n     ///\n     /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n     /// this call is blocking, this call will wake up and return [`Err`] to"}]}