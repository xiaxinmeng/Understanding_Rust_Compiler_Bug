{"sha": "c54af457d05722321ca88c2ae0e5706ef803c5fb", "node_id": "C_kwDOAAsO6NoAKGM1NGFmNDU3ZDA1NzIyMzIxY2E4OGMyYWUwZTU3MDZlZjgwM2M1ZmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-14T00:30:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-14T00:30:46Z"}, "message": "Auto merge of #109097 - matthiaskrgr:rollup-6ydc4ri, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #108419 (Stabilize `atomic_as_ptr`)\n - #108507 (use `as_ptr` to determine the address of atomics)\n - #108607 (Don't use fd-lock on Solaris in bootstrap)\n - #108830 (Treat projections with infer as placeholder during fast reject in new solver)\n - #109055 (create `config::tests::detect_src_and_out` test for bootstrap)\n - #109058 (Document BinOp::is_checkable)\n - #109081 (simd-wide-sum test: adapt for LLVM 17 codegen change)\n - #109083 (Update books)\n - #109088 (Gracefully handle `#[target_feature]` on statics)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "04c6c57d4f325d76ae7de556262bf908fbaf70df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04c6c57d4f325d76ae7de556262bf908fbaf70df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c54af457d05722321ca88c2ae0e5706ef803c5fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c54af457d05722321ca88c2ae0e5706ef803c5fb", "html_url": "https://github.com/rust-lang/rust/commit/c54af457d05722321ca88c2ae0e5706ef803c5fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c54af457d05722321ca88c2ae0e5706ef803c5fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22f247c6f3ed388cb702d01c2ff27da658a8b353", "url": "https://api.github.com/repos/rust-lang/rust/commits/22f247c6f3ed388cb702d01c2ff27da658a8b353", "html_url": "https://github.com/rust-lang/rust/commit/22f247c6f3ed388cb702d01c2ff27da658a8b353"}, {"sha": "30cd4b3a161d38574a599f2aa58db8334b470f8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/30cd4b3a161d38574a599f2aa58db8334b470f8b", "html_url": "https://github.com/rust-lang/rust/commit/30cd4b3a161d38574a599f2aa58db8334b470f8b"}], "stats": {"total": 598, "additions": 454, "deletions": 144}, "files": [{"sha": "f9bb8359208e326c2517f4b107b0deb644b15172", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -61,25 +61,29 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n \n     let supported_target_features = tcx.supported_target_features(LOCAL_CRATE);\n \n-    // In some cases, attribute are only valid on functions, but it's the `check_attr`\n-    // pass that check that they aren't used anywhere else, rather this module.\n-    // In these cases, we bail from performing further checks that are only meaningful for\n-    // functions (such as calling `fn_sig`, which ICEs if given a non-function). We also\n-    // report a delayed bug, just in case `check_attr` isn't doing its job.\n-    let validate_fn_only_attr = |attr_sp| -> bool {\n-        let def_kind = tcx.def_kind(did);\n-        if let DefKind::Fn | DefKind::AssocFn | DefKind::Variant | DefKind::Ctor(..) = def_kind {\n-            true\n-        } else {\n-            tcx.sess.delay_span_bug(attr_sp, \"this attribute can only be applied to functions\");\n-            false\n-        }\n-    };\n-\n     let mut inline_span = None;\n     let mut link_ordinal_span = None;\n     let mut no_sanitize_span = None;\n+\n     for attr in attrs.iter() {\n+        // In some cases, attribute are only valid on functions, but it's the `check_attr`\n+        // pass that check that they aren't used anywhere else, rather this module.\n+        // In these cases, we bail from performing further checks that are only meaningful for\n+        // functions (such as calling `fn_sig`, which ICEs if given a non-function). We also\n+        // report a delayed bug, just in case `check_attr` isn't doing its job.\n+        let fn_sig = || {\n+            use DefKind::*;\n+\n+            let def_kind = tcx.def_kind(did);\n+            if let Fn | AssocFn | Variant | Ctor(..) = def_kind {\n+                Some(tcx.fn_sig(did))\n+            } else {\n+                tcx.sess\n+                    .delay_span_bug(attr.span, \"this attribute can only be applied to functions\");\n+                None\n+            }\n+        };\n+\n         if attr.has_name(sym::cold) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n         } else if attr.has_name(sym::rustc_allocator) {\n@@ -169,8 +173,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n                 }\n             }\n         } else if attr.has_name(sym::cmse_nonsecure_entry) {\n-            if validate_fn_only_attr(attr.span)\n-                && !matches!(tcx.fn_sig(did).skip_binder().abi(), abi::Abi::C { .. })\n+            if let Some(fn_sig) = fn_sig()\n+                && !matches!(fn_sig.skip_binder().abi(), abi::Abi::C { .. })\n             {\n                 struct_span_err!(\n                     tcx.sess,\n@@ -189,8 +193,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n         } else if attr.has_name(sym::track_caller) {\n             if !tcx.is_closure(did.to_def_id())\n-                && validate_fn_only_attr(attr.span)\n-                && tcx.fn_sig(did).skip_binder().abi() != abi::Abi::Rust\n+                && let Some(fn_sig) = fn_sig()\n+                && fn_sig.skip_binder().abi() != abi::Abi::Rust\n             {\n                 struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n                     .emit();\n@@ -222,7 +226,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n             }\n         } else if attr.has_name(sym::target_feature) {\n             if !tcx.is_closure(did.to_def_id())\n-                && tcx.fn_sig(did).skip_binder().unsafety() == hir::Unsafety::Normal\n+                && let Some(fn_sig) = fn_sig()\n+                && fn_sig.skip_binder().unsafety() == hir::Unsafety::Normal\n             {\n                 if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n                     // The `#[target_feature]` attribute is allowed on"}, {"sha": "07a33bcbb509bf847ed6789911ff55581ad59985", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -11,7 +11,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n-use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams};\n+use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams, TreatProjections};\n use rustc_middle::ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n \n@@ -99,7 +99,12 @@ impl<'tcx> InherentCollect<'tcx> {\n                 }\n             }\n \n-            if let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsInfer) {\n+            if let Some(simp) = simplify_type(\n+                self.tcx,\n+                self_ty,\n+                TreatParams::AsCandidateKey,\n+                TreatProjections::AsCandidateKey,\n+            ) {\n                 self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n             } else {\n                 bug!(\"unexpected self type: {:?}\", self_ty);\n@@ -159,7 +164,12 @@ impl<'tcx> InherentCollect<'tcx> {\n             }\n         }\n \n-        if let Some(simp) = simplify_type(self.tcx, ty, TreatParams::AsInfer) {\n+        if let Some(simp) = simplify_type(\n+            self.tcx,\n+            ty,\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n         } else {\n             bug!(\"unexpected primitive type: {:?}\", ty);"}, {"sha": "562dd2caae3410f900ffae36a6ed39fbf10c92c2", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -15,6 +15,7 @@ use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n use rustc_middle::middle::stability;\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::AssocItem;\n use rustc_middle::ty::GenericParamDefKind;\n@@ -699,7 +700,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn assemble_inherent_candidates_for_incoherent_ty(&mut self, self_ty: Ty<'tcx>) {\n-        let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsInfer) else {\n+        let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsCandidateKey, TreatProjections::AsCandidateKey) else {\n             bug!(\"unexpected incoherent type: {:?}\", self_ty)\n         };\n         for &impl_def_id in self.tcx.incoherent_impls(simp) {"}, {"sha": "7055d9257ec90902c55124077e48874d5dfa4c7a", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -25,6 +25,7 @@ use rustc_infer::infer::{\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::DeepRejectCtxt;\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::{with_crate_prefix, with_forced_trimmed_paths};\n use rustc_middle::ty::{self, GenericArgKind, Ty, TyCtxt, TypeVisitableExt};\n@@ -1257,7 +1258,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let target_ty = self\n                 .autoderef(sugg_span, rcvr_ty)\n                 .find(|(rcvr_ty, _)| {\n-                    DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer }\n+                    DeepRejectCtxt { treat_obligation_params: TreatParams::AsCandidateKey }\n                         .types_may_unify(*rcvr_ty, impl_ty)\n                 })\n                 .map_or(impl_ty, |(ty, _)| ty)\n@@ -1516,7 +1517,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .into_iter()\n             .any(|info| self.associated_value(info.def_id, item_name).is_some());\n         let found_assoc = |ty: Ty<'tcx>| {\n-            simplify_type(tcx, ty, TreatParams::AsInfer)\n+            simplify_type(tcx, ty, TreatParams::AsCandidateKey, TreatProjections::AsCandidateKey)\n                 .and_then(|simp| {\n                     tcx.incoherent_impls(simp)\n                         .iter()\n@@ -2645,9 +2646,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // FIXME: Even though negative bounds are not implemented, we could maybe handle\n                 // cases where a positive bound implies a negative impl.\n                 (candidates, Vec::new())\n-            } else if let Some(simp_rcvr_ty) =\n-                simplify_type(self.tcx, rcvr_ty, TreatParams::AsPlaceholder)\n-            {\n+            } else if let Some(simp_rcvr_ty) = simplify_type(\n+                self.tcx,\n+                rcvr_ty,\n+                TreatParams::ForLookup,\n+                TreatProjections::ForLookup,\n+            ) {\n                 let mut potential_candidates = Vec::new();\n                 let mut explicitly_negative = Vec::new();\n                 for candidate in candidates {\n@@ -2660,8 +2664,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         })\n                         .any(|imp_did| {\n                             let imp = self.tcx.impl_trait_ref(imp_did).unwrap().subst_identity();\n-                            let imp_simp =\n-                                simplify_type(self.tcx, imp.self_ty(), TreatParams::AsPlaceholder);\n+                            let imp_simp = simplify_type(\n+                                self.tcx,\n+                                imp.self_ty(),\n+                                TreatParams::ForLookup,\n+                                TreatProjections::ForLookup,\n+                            );\n                             imp_simp.map_or(false, |s| s == simp_rcvr_ty)\n                         })\n                     {"}, {"sha": "bbab8a62a2bce98fa4a9cc083c49a64e4e935daa", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -26,7 +26,7 @@ use rustc_middle::middle::exported_symbols::{\n use rustc_middle::mir::interpret;\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams, TreatProjections};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_middle::util::common::to_readable_str;\n@@ -1858,7 +1858,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     let simplified_self_ty = fast_reject::simplify_type(\n                         self.tcx,\n                         trait_ref.self_ty(),\n-                        TreatParams::AsInfer,\n+                        TreatParams::AsCandidateKey,\n+                        TreatProjections::AsCandidateKey,\n                     );\n \n                     fx_hash_map"}, {"sha": "b34651c3ea7972c77db1da4c8c395c57363c40d2", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -1999,6 +1999,9 @@ impl BorrowKind {\n }\n \n impl BinOp {\n+    /// The checkable operators are those whose overflow checking behavior is controlled by\n+    /// -Coverflow-checks option. The remaining operators have either no overflow conditions (e.g.,\n+    /// BitAnd, BitOr, BitXor) or are always checked for overflow (e.g., Div, Rem).\n     pub fn is_checkable(self) -> bool {\n         use self::BinOp::*;\n         matches!(self, Add | Sub | Mul | Shl | Shr)"}, {"sha": "ee505742be9a039e4a7c125cc30542337e66120e", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -51,15 +51,35 @@ pub enum SimplifiedType {\n /// generic parameters as if they were inference variables in that case.\n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n pub enum TreatParams {\n-    /// Treat parameters as placeholders in the given environment.\n+    /// Treat parameters as infer vars. This is the correct mode for caching\n+    /// an impl's type for lookup.\n+    AsCandidateKey,\n+    /// Treat parameters as placeholders in the given environment. This is the\n+    /// correct mode for *lookup*, as during candidate selection.\n+    ForLookup,\n+}\n+\n+/// During fast-rejection, we have the choice of treating projection types\n+/// as either simplifyable or not, depending on whether we expect the projection\n+/// to be normalized/rigid.\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n+pub enum TreatProjections {\n+    /// In candidates, we may be able to normalize the projection\n+    /// after instantiating the candidate and equating it with a goal.\n     ///\n-    /// Note that this also causes us to treat projections as if they were\n-    /// placeholders. This is only correct if the given projection cannot\n-    /// be normalized in the current context. Even if normalization fails,\n-    /// it may still succeed later if the projection contains any inference\n-    /// variables.\n-    AsPlaceholder,\n-    AsInfer,\n+    /// We must assume that the `impl<T> Trait<T> for <T as Id>::This`\n+    /// can apply to all self types so we don't return a simplified type\n+    /// for `<T as Id>::This`.\n+    AsCandidateKey,\n+    /// In the old solver we don't try to normalize projections\n+    /// when looking up impls and only access them by using the\n+    /// current self type. This means that if the self type is\n+    /// a projection which could later be normalized, we must not\n+    /// treat it as rigid.\n+    ForLookup,\n+    /// We can treat projections in the self type as opaque as\n+    /// we separately look up impls for the normalized self type.\n+    NextSolverLookup,\n }\n \n /// Tries to simplify a type by only returning the outermost injective\u00b9 layer, if one exists.\n@@ -87,6 +107,7 @@ pub fn simplify_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     treat_params: TreatParams,\n+    treat_projections: TreatProjections,\n ) -> Option<SimplifiedType> {\n     match *ty.kind() {\n         ty::Bool => Some(BoolSimplifiedType),\n@@ -115,19 +136,13 @@ pub fn simplify_type<'tcx>(\n         ty::FnPtr(f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n         ty::Placeholder(..) => Some(PlaceholderSimplifiedType),\n         ty::Param(_) => match treat_params {\n-            TreatParams::AsPlaceholder => Some(PlaceholderSimplifiedType),\n-            TreatParams::AsInfer => None,\n+            TreatParams::ForLookup => Some(PlaceholderSimplifiedType),\n+            TreatParams::AsCandidateKey => None,\n         },\n-        ty::Alias(..) => match treat_params {\n-            // When treating `ty::Param` as a placeholder, projections also\n-            // don't unify with anything else as long as they are fully normalized.\n-            //\n-            // We will have to be careful with lazy normalization here.\n-            TreatParams::AsPlaceholder if !ty.has_non_region_infer() => {\n-                debug!(\"treating `{}` as a placeholder\", ty);\n-                Some(PlaceholderSimplifiedType)\n-            }\n-            TreatParams::AsPlaceholder | TreatParams::AsInfer => None,\n+        ty::Alias(..) => match treat_projections {\n+            TreatProjections::ForLookup if !ty.needs_infer() => Some(PlaceholderSimplifiedType),\n+            TreatProjections::NextSolverLookup => Some(PlaceholderSimplifiedType),\n+            TreatProjections::AsCandidateKey | TreatProjections::ForLookup => None,\n         },\n         ty::Foreign(def_id) => Some(ForeignSimplifiedType(def_id)),\n         ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,\n@@ -295,8 +310,8 @@ impl DeepRejectCtxt {\n             // Depending on the value of `treat_obligation_params`, we either\n             // treat generic parameters like placeholders or like inference variables.\n             ty::Param(_) => match self.treat_obligation_params {\n-                TreatParams::AsPlaceholder => false,\n-                TreatParams::AsInfer => true,\n+                TreatParams::ForLookup => false,\n+                TreatParams::AsCandidateKey => true,\n             },\n \n             ty::Infer(_) => true,\n@@ -333,8 +348,8 @@ impl DeepRejectCtxt {\n         let k = impl_ct.kind();\n         match obligation_ct.kind() {\n             ty::ConstKind::Param(_) => match self.treat_obligation_params {\n-                TreatParams::AsPlaceholder => false,\n-                TreatParams::AsInfer => true,\n+                TreatParams::ForLookup => false,\n+                TreatParams::AsCandidateKey => true,\n             },\n \n             // As we don't necessarily eagerly evaluate constants,"}, {"sha": "bf2b121f704afcbcb55dd44ca800ab424ea9f84d", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -1,5 +1,5 @@\n use crate::traits::specialization_graph;\n-use crate::ty::fast_reject::{self, SimplifiedType, TreatParams};\n+use crate::ty::fast_reject::{self, SimplifiedType, TreatParams, TreatProjections};\n use crate::ty::visit::TypeVisitableExt;\n use crate::ty::{Ident, Ty, TyCtxt};\n use hir::def_id::LOCAL_CRATE;\n@@ -118,16 +118,32 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Iterate over every impl that could possibly match the self type `self_ty`.\n     ///\n     /// `trait_def_id` MUST BE the `DefId` of a trait.\n-    pub fn for_each_relevant_impl<F: FnMut(DefId)>(\n+    pub fn for_each_relevant_impl(\n         self,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        mut f: F,\n+        f: impl FnMut(DefId),\n     ) {\n-        let _: Option<()> = self.find_map_relevant_impl(trait_def_id, self_ty, |did| {\n-            f(did);\n-            None\n-        });\n+        self.for_each_relevant_impl_treating_projections(\n+            trait_def_id,\n+            self_ty,\n+            TreatProjections::ForLookup,\n+            f,\n+        )\n+    }\n+\n+    pub fn for_each_relevant_impl_treating_projections(\n+        self,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        treat_projections: TreatProjections,\n+        mut f: impl FnMut(DefId),\n+    ) {\n+        let _: Option<()> =\n+            self.find_map_relevant_impl(trait_def_id, self_ty, treat_projections, |did| {\n+                f(did);\n+                None\n+            });\n     }\n \n     /// `trait_def_id` MUST BE the `DefId` of a trait.\n@@ -137,7 +153,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         self_ty: Ty<'tcx>,\n     ) -> impl Iterator<Item = DefId> + 'tcx {\n         let impls = self.trait_impls_of(trait_def_id);\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsInfer) {\n+        if let Some(simp) = fast_reject::simplify_type(\n+            self,\n+            self_ty,\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 return impls.iter().copied();\n             }\n@@ -150,11 +171,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// the first non-none value.\n     ///\n     /// `trait_def_id` MUST BE the `DefId` of a trait.\n-    pub fn find_map_relevant_impl<T, F: FnMut(DefId) -> Option<T>>(\n+    pub fn find_map_relevant_impl<T>(\n         self,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        mut f: F,\n+        treat_projections: TreatProjections,\n+        mut f: impl FnMut(DefId) -> Option<T>,\n     ) -> Option<T> {\n         // FIXME: This depends on the set of all impls for the trait. That is\n         // unfortunate wrt. incremental compilation.\n@@ -169,14 +191,13 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n-        // Note that we're using `TreatParams::AsPlaceholder` to query `non_blanket_impls` while using\n-        // `TreatParams::AsInfer` while actually adding them.\n-        //\n         // This way, when searching for some impl for `T: Trait`, we do not look at any impls\n         // whose outer level is not a parameter or projection. Especially for things like\n         // `T: Clone` this is incredibly useful as we would otherwise look at all the impls\n         // of `Clone` for `Option<T>`, `Vec<T>`, `ConcreteType` and so on.\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsPlaceholder) {\n+        if let Some(simp) =\n+            fast_reject::simplify_type(self, self_ty, TreatParams::ForLookup, treat_projections)\n+        {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 for &impl_def_id in impls {\n                     if let result @ Some(_) = f(impl_def_id) {\n@@ -237,9 +258,12 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n             continue;\n         }\n \n-        if let Some(simplified_self_ty) =\n-            fast_reject::simplify_type(tcx, impl_self_ty, TreatParams::AsInfer)\n-        {\n+        if let Some(simplified_self_ty) = fast_reject::simplify_type(\n+            tcx,\n+            impl_self_ty,\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             impls.non_blanket_impls.entry(simplified_self_ty).or_default().push(impl_def_id);\n         } else {\n             impls.blanket_impls.push(impl_def_id);"}, {"sha": "b0f6127baa5d42073b3d6b6ed49243bc23eabaed", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -2,6 +2,7 @@\n \n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir;\n+use crate::ty::fast_reject::TreatProjections;\n use crate::ty::layout::IntegerExt;\n use crate::ty::{\n     self, FallibleTypeFolder, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n@@ -363,14 +364,20 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.ensure().coherent_trait(drop_trait);\n \n         let ty = self.type_of(adt_did).subst_identity();\n-        let (did, constness) = self.find_map_relevant_impl(drop_trait, ty, |impl_did| {\n-            if let Some(item_id) = self.associated_item_def_ids(impl_did).first() {\n-                if validate(self, impl_did).is_ok() {\n-                    return Some((*item_id, self.constness(impl_did)));\n+        let (did, constness) = self.find_map_relevant_impl(\n+            drop_trait,\n+            ty,\n+            // FIXME: This could also be some other mode, like \"unexpected\"\n+            TreatProjections::ForLookup,\n+            |impl_did| {\n+                if let Some(item_id) = self.associated_item_def_ids(impl_did).first() {\n+                    if validate(self, impl_did).is_ok() {\n+                        return Some((*item_id, self.constness(impl_did)));\n+                    }\n                 }\n-            }\n-            None\n-        })?;\n+                None\n+            },\n+        )?;\n \n         Some(ty::Destructor { did, constness })\n     }"}, {"sha": "c8d371dd0846b8c2c0dcc27146a5e22ec8d14165", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -2215,7 +2215,7 @@ impl CheckAttrVisitor<'_> {\n             // `fn(TokenStream) -> TokenStream` after some substitution of generic arguments.\n             //\n             // Properly checking this means pulling in additional `rustc` crates, so we don't.\n-            let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer };\n+            let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsCandidateKey };\n \n             if sig.abi != Abi::Rust {\n                 tcx.sess.emit_err(errors::ProcMacroInvalidAbi {"}, {"sha": "891ea0cdebe5031be8908d1a92551530a3267713", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate_predicates;\n use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, MaybeCause, QueryResult};\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::fmt::Debug;\n@@ -299,9 +300,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         candidates: &mut Vec<Candidate<'tcx>>,\n     ) {\n         let tcx = self.tcx();\n-        tcx.for_each_relevant_impl(\n+        tcx.for_each_relevant_impl_treating_projections(\n             goal.predicate.trait_def_id(tcx),\n             goal.predicate.self_ty(),\n+            TreatProjections::NextSolverLookup,\n             |impl_def_id| match G::consider_impl_candidate(self, goal, impl_def_id) {\n                 Ok(result) => candidates\n                     .push(Candidate { source: CandidateSource::Impl(impl_def_id), result }),"}, {"sha": "dbb8e722c8f6ff29aa7c5a5d6d8658e5e75237ba", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -184,7 +184,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n \n         let goal_trait_ref = goal.predicate.projection_ty.trait_ref(tcx);\n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::ForLookup };\n         if iter::zip(goal_trait_ref.substs, impl_trait_ref.skip_binder().substs)\n             .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n         {"}, {"sha": "7878539817cfb928fc8a6a0d4237cb7fa3b8113f", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::LangItem;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::supertraits;\n use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, QueryResult};\n-use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams, TreatProjections};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use rustc_middle::ty::{TraitPredicate, TypeVisitableExt};\n use rustc_span::DUMMY_SP;\n@@ -36,7 +36,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         let tcx = ecx.tcx();\n \n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::ForLookup };\n         if iter::zip(goal.predicate.trait_ref.substs, impl_trait_ref.skip_binder().substs)\n             .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n         {\n@@ -135,9 +135,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         // currently instead lint patterns which can be used to\n         // exploit this unsoundness on stable, see #93367 for\n         // more details.\n+        //\n+        // Using `TreatProjections::NextSolverLookup` is fine here because\n+        // `instantiate_constituent_tys_for_auto_trait` returns nothing for\n+        // projection types anyways. So it doesn't really matter what we do\n+        // here, and this is faster.\n         if let Some(def_id) = ecx.tcx().find_map_relevant_impl(\n             goal.predicate.def_id(),\n             goal.predicate.self_ty(),\n+            TreatProjections::NextSolverLookup,\n             Some,\n         ) {\n             debug!(?def_id, ?goal, \"disqualified auto-trait implementation\");"}, {"sha": "96a4b76af550fd5c9eb26d0782114f4514dee93c", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -75,7 +75,7 @@ pub fn overlapping_impls(\n     // Before doing expensive operations like entering an inference context, do\n     // a quick check via fast_reject to tell if the impl headers could possibly\n     // unify.\n-    let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer };\n+    let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsCandidateKey };\n     let impl1_ref = tcx.impl_trait_ref(impl1_def_id);\n     let impl2_ref = tcx.impl_trait_ref(impl2_def_id);\n     let may_overlap = match (impl1_ref, impl2_ref) {"}, {"sha": "41ffaeeac1c11ffa67b4f7c97c1d3d594191abb9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -32,6 +32,7 @@ use rustc_infer::infer::{InferOk, TypeTrace};\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::print::{with_forced_trimmed_paths, FmtPrinter, Print};\n use rustc_middle::ty::{\n@@ -1799,12 +1800,17 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     })\n                     .and_then(|(trait_assoc_item, id)| {\n                         let trait_assoc_ident = trait_assoc_item.ident(self.tcx);\n-                        self.tcx.find_map_relevant_impl(id, proj.projection_ty.self_ty(), |did| {\n-                            self.tcx\n-                                .associated_items(did)\n-                                .in_definition_order()\n-                                .find(|assoc| assoc.ident(self.tcx) == trait_assoc_ident)\n-                        })\n+                        self.tcx.find_map_relevant_impl(\n+                            id,\n+                            proj.projection_ty.self_ty(),\n+                            TreatProjections::ForLookup,\n+                            |did| {\n+                                self.tcx\n+                                    .associated_items(did)\n+                                    .in_definition_order()\n+                                    .find(|assoc| assoc.ident(self.tcx) == trait_assoc_ident)\n+                            },\n+                        )\n                     })\n                     .and_then(|item| match self.tcx.hir().get_if_local(item.def_id) {\n                         Some(\n@@ -2176,7 +2182,12 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         trait_ref: &ty::PolyTraitRef<'tcx>,\n     ) -> bool {\n         let get_trait_impl = |trait_def_id| {\n-            self.tcx.find_map_relevant_impl(trait_def_id, trait_ref.skip_binder().self_ty(), Some)\n+            self.tcx.find_map_relevant_impl(\n+                trait_def_id,\n+                trait_ref.skip_binder().self_ty(),\n+                TreatProjections::ForLookup,\n+                Some,\n+            )\n         };\n         let required_trait_path = self.tcx.def_path_str(trait_ref.def_id());\n         let traits_with_same_path: std::collections::BTreeSet<_> = self"}, {"sha": "3182af989f05a565592755863faa044c939e11db", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -9,6 +9,7 @@ use hir::LangItem;\n use rustc_hir as hir;\n use rustc_infer::traits::ObligationCause;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n use rustc_target::spec::abi::Abi;\n \n@@ -783,6 +784,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let relevant_impl = self.tcx().find_map_relevant_impl(\n                     self.tcx().require_lang_item(LangItem::Drop, None),\n                     obligation.predicate.skip_binder().trait_ref.self_ty(),\n+                    TreatProjections::ForLookup,\n                     Some,\n                 );\n "}, {"sha": "38cdaddc1e707c286693e3cd5c6e6d947fde9114", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -2558,7 +2558,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n         // We can avoid creating type variables and doing the full\n         // substitution if we find that any of the input types, when\n         // simplified, do not match.\n-        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::ForLookup };\n         iter::zip(obligation.predicate.skip_binder().trait_ref.substs, impl_trait_ref.substs)\n             .any(|(obl, imp)| !drcx.generic_args_may_unify(obl, imp))\n     }"}, {"sha": "cd665d9471db23a393370c81e5b9193758f85f86", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -3,7 +3,7 @@ use super::OverlapError;\n use crate::traits;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams, TreatProjections};\n use rustc_middle::ty::{self, TyCtxt, TypeVisitableExt};\n \n pub use rustc_middle::traits::specialization_graph::*;\n@@ -49,8 +49,12 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().skip_binder();\n-        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer)\n-        {\n+        if let Some(st) = fast_reject::simplify_type(\n+            tcx,\n+            trait_ref.self_ty(),\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             debug!(\"insert_blindly: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             self.non_blanket_impls.entry(st).or_default().push(impl_def_id)\n         } else {\n@@ -65,8 +69,12 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n     fn remove_existing(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().skip_binder();\n         let vec: &mut Vec<DefId>;\n-        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer)\n-        {\n+        if let Some(st) = fast_reject::simplify_type(\n+            tcx,\n+            trait_ref.self_ty(),\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             debug!(\"remove_existing: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             vec = self.non_blanket_impls.get_mut(&st).unwrap();\n         } else {\n@@ -302,7 +310,12 @@ impl<'tcx> GraphExt<'tcx> for Graph {\n \n         let mut parent = trait_def_id;\n         let mut last_lint = None;\n-        let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer);\n+        let simplified = fast_reject::simplify_type(\n+            tcx,\n+            trait_ref.self_ty(),\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        );\n \n         // Descend the specialization tree, where `parent` is the current parent node.\n         loop {"}, {"sha": "123561873a668160c953697c2963e20b9c89767a", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -960,6 +960,7 @@ impl AtomicBool {\n     /// ```ignore (extern-declaration)\n     /// # fn main() {\n     /// use std::sync::atomic::AtomicBool;\n+    ///\n     /// extern \"C\" {\n     ///     fn my_atomic_op(arg: *mut bool);\n     /// }\n@@ -971,7 +972,8 @@ impl AtomicBool {\n     /// # }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"atomic_mut_ptr\", reason = \"recently added\", issue = \"66893\")]\n+    #[stable(feature = \"atomic_as_ptr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"atomic_as_ptr\", since = \"CURRENT_RUSTC_VERSION\")]\n     pub const fn as_ptr(&self) -> *mut bool {\n         self.v.get().cast()\n     }\n@@ -1890,7 +1892,6 @@ impl<T> AtomicPtr<T> {\n     /// # Examples\n     ///\n     /// ```ignore (extern-declaration)\n-    /// #![feature(atomic_mut_ptr)]\n     /// use std::sync::atomic::AtomicPtr;\n     ///\n     /// extern \"C\" {\n@@ -1906,7 +1907,8 @@ impl<T> AtomicPtr<T> {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"atomic_mut_ptr\", reason = \"recently added\", issue = \"66893\")]\n+    #[stable(feature = \"atomic_as_ptr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"atomic_as_ptr\", since = \"CURRENT_RUSTC_VERSION\")]\n     pub const fn as_ptr(&self) -> *mut *mut T {\n         self.p.get()\n     }\n@@ -2859,9 +2861,8 @@ macro_rules! atomic_int {\n             /// # }\n             /// ```\n             #[inline]\n-            #[unstable(feature = \"atomic_mut_ptr\",\n-                   reason = \"recently added\",\n-                   issue = \"66893\")]\n+            #[stable(feature = \"atomic_as_ptr\", since = \"CURRENT_RUSTC_VERSION\")]\n+            #[rustc_const_stable(feature = \"atomic_as_ptr\", since = \"CURRENT_RUSTC_VERSION\")]\n             pub const fn as_ptr(&self) -> *mut $int_type {\n                 self.v.get()\n             }"}, {"sha": "4e7b6080835002b6101811241b3ca69ae13f6a64", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -274,7 +274,6 @@\n #![feature(utf8_chunks)]\n //\n // Library features (core):\n-#![feature(atomic_mut_ptr)]\n #![feature(char_internals)]\n #![feature(core_intrinsics)]\n #![feature(duration_constants)]"}, {"sha": "427d8ff6f2e4de429c3d86e1a2f10ca19d9753f7", "filename": "library/std/src/sys/hermit/futex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffutex.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -16,7 +16,7 @@ pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -\n \n     let r = unsafe {\n         abi::futex_wait(\n-            futex.as_mut_ptr(),\n+            futex.as_ptr(),\n             expected,\n             timespec.as_ref().map_or(null(), |t| t as *const abi::timespec),\n             abi::FUTEX_RELATIVE_TIMEOUT,\n@@ -28,12 +28,12 @@ pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -\n \n #[inline]\n pub fn futex_wake(futex: &AtomicU32) -> bool {\n-    unsafe { abi::futex_wake(futex.as_mut_ptr(), 1) > 0 }\n+    unsafe { abi::futex_wake(futex.as_ptr(), 1) > 0 }\n }\n \n #[inline]\n pub fn futex_wake_all(futex: &AtomicU32) {\n     unsafe {\n-        abi::futex_wake(futex.as_mut_ptr(), i32::MAX);\n+        abi::futex_wake(futex.as_ptr(), i32::MAX);\n     }\n }"}, {"sha": "743e93a2fd4dbc5f8c6f526629d3c7bd0e80c5b8", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -15,7 +15,6 @@\n \n #![allow(missing_docs, nonstandard_style, unsafe_op_in_unsafe_fn)]\n \n-use crate::intrinsics;\n use crate::os::raw::c_char;\n \n pub mod alloc;"}, {"sha": "54d0d8a8ec25ec6d97b31ba82b184df89bf12af5", "filename": "src/bootstrap/CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/src%2Fbootstrap%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/src%2Fbootstrap%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCHANGELOG.md?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -47,6 +47,7 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n - Add `--keep-stage-std`, which behaves like `keep-stage` but allows the stage\n   0 compiler artifacts (i.e., stage1/bin/rustc) to be rebuilt if changed\n   [#77120](https://github.com/rust-lang/rust/pull/77120).\n+- File locking is now used to avoid collisions between multiple running instances of `x.py` (e.g. when using `rust-analyzer` and `x.py` at the same time). Note that Solaris and possibly other non Unix and non Windows systems don't support it [#108607](https://github.com/rust-lang/rust/pull/108607). This might possibly lead to build data corruption.\n \n \n ## [Version 1] - 2020-09-11"}, {"sha": "afe3fc1741b30e91d7b36a3f82b80aa157e53fef", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -32,7 +32,6 @@ test = false\n [dependencies]\n build_helper = { path = \"../tools/build_helper\" }\n cmake = \"0.1.38\"\n-fd-lock = \"3.0.8\"\n filetime = \"0.2\"\n getopts = \"0.2.19\"\n cc = \"1.0.69\"\n@@ -56,6 +55,10 @@ walkdir = \"2\"\n # Dependencies needed by the build-metrics feature\n sysinfo = { version = \"0.26.0\", optional = true }\n \n+# Solaris doesn't support flock() and thus fd-lock is not option now\n+[target.'cfg(not(target_os = \"solaris\"))'.dependencies]\n+fd-lock = \"3.0.8\"\n+\n [target.'cfg(windows)'.dependencies.winapi]\n version = \"0.3\"\n features = ["}, {"sha": "912d875e445ea2e3bd1e90a44f67dac8f8760b3d", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -7,15 +7,18 @@\n \n use std::env;\n \n-use bootstrap::{t, Build, Config, Subcommand, VERSION};\n+#[cfg(all(any(unix, windows), not(target_os = \"solaris\")))]\n+use bootstrap::t;\n+use bootstrap::{Build, Config, Subcommand, VERSION};\n \n fn main() {\n     let args = env::args().skip(1).collect::<Vec<_>>();\n     let config = Config::parse(&args);\n \n-    let mut build_lock;\n-    let _build_lock_guard;\n-    if cfg!(any(unix, windows)) {\n+    #[cfg(all(any(unix, windows), not(target_os = \"solaris\")))]\n+    {\n+        let mut build_lock;\n+        let _build_lock_guard;\n         let path = config.out.join(\"lock\");\n         build_lock = fd_lock::RwLock::new(t!(std::fs::File::create(&path)));\n         _build_lock_guard = match build_lock.try_write() {\n@@ -30,9 +33,9 @@ fn main() {\n                 t!(build_lock.write())\n             }\n         };\n-    } else {\n-        println!(\"warning: file locking not supported for target, not locking build directory\");\n     }\n+    #[cfg(any(not(any(unix, windows)), target_os = \"solaris\"))]\n+    println!(\"warning: file locking not supported for target, not locking build directory\");\n \n     // check_version warnings are not printed during setup\n     let changelog_suggestion =\n@@ -125,7 +128,7 @@ fn get_lock_owner(f: &std::path::Path) -> Option<u64> {\n     })\n }\n \n-#[cfg(not(target_os = \"linux\"))]\n+#[cfg(not(any(target_os = \"linux\", target_os = \"solaris\")))]\n fn get_lock_owner(_: &std::path::Path) -> Option<u64> {\n     // FIXME: Implement on other OS's\n     None"}, {"sha": "16dc8c63abc96e989ac6016c37a80a378b46fee2", "filename": "src/bootstrap/config/tests.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/src%2Fbootstrap%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/src%2Fbootstrap%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig%2Ftests.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -1,5 +1,5 @@\n use super::{Config, TomlConfig};\n-use std::path::Path;\n+use std::{env, path::Path};\n \n fn toml(config: &str) -> impl '_ + Fn(&Path) -> TomlConfig {\n     |&_| toml::from_str(config).unwrap()\n@@ -33,4 +33,35 @@ fn download_ci_llvm() {\n     ));\n }\n \n-// FIXME: add test for detecting `src` and `out`\n+#[test]\n+fn detect_src_and_out() {\n+    let cfg = parse(\"\");\n+\n+    // This will bring absolute form of `src/bootstrap` path\n+    let current_dir = std::env::current_dir().unwrap();\n+\n+    // get `src` by moving into project root path\n+    let expected_src = current_dir.ancestors().nth(2).unwrap();\n+\n+    assert_eq!(&cfg.src, expected_src);\n+\n+    // This should bring output path of bootstrap in absolute form\n+    let cargo_target_dir = env::var_os(\"CARGO_TARGET_DIR\")\n+        .expect(\"CARGO_TARGET_DIR must been provided for the test environment from bootstrap\");\n+\n+    // Move to `build` from `build/bootstrap`\n+    let expected_out = Path::new(&cargo_target_dir).parent().unwrap();\n+    assert_eq!(&cfg.out, expected_out);\n+\n+    let args: Vec<String> = env::args().collect();\n+\n+    // Another test for `out` as a sanity check\n+    //\n+    // This will bring something similar to:\n+    //     `{config_toml_place}/build/bootstrap/debug/deps/bootstrap-c7ee91d5661e2804`\n+    // `{config_toml_place}` can be anywhere, not just in the rust project directory.\n+    let dep = Path::new(args.first().unwrap());\n+    let expected_out = dep.ancestors().nth(4).unwrap();\n+\n+    assert_eq!(&cfg.out, expected_out);\n+}"}, {"sha": "1f3e4cd4fd88b5b5d45feb86a11b6d2f93e5a974", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -1 +1 @@\n-Subproject commit 79b53665a7c61d171fb8c5ad0b73b371f9ee6ba7\n+Subproject commit 1f3e4cd4fd88b5b5d45feb86a11b6d2f93e5a974"}, {"sha": "24c87f6663aed55b05d2cc286878f28f21918825", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -1 +1 @@\n-Subproject commit a9afb04b47a84a6753e4dc657348c324c876102c\n+Subproject commit 24c87f6663aed55b05d2cc286878f28f21918825"}, {"sha": "b1b6d693cd1461e53de4132c1b183ace31cd36e5", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -1 +1 @@\n-Subproject commit b06dab84083390e0ee1e998f466545a8a1a76a9f\n+Subproject commit b1b6d693cd1461e53de4132c1b183ace31cd36e5"}, {"sha": "358f6ad566c25e669f29a85043de493ed389eeee", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{DefKind, Namespace, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::Mutability;\n-use rustc_middle::ty::{Ty, TyCtxt};\n+use rustc_middle::ty::{fast_reject::TreatProjections, Ty, TyCtxt};\n use rustc_middle::{bug, ty};\n use rustc_resolve::rustdoc::MalformedGenerics;\n use rustc_resolve::rustdoc::{prepare_to_doc_link_resolution, strip_generics_from_path};\n@@ -735,7 +735,7 @@ fn trait_impls_for<'a>(\n         trace!(\"considering explicit impl for trait {:?}\", trait_);\n \n         // Look at each trait implementation to see if it's an impl for `did`\n-        tcx.find_map_relevant_impl(trait_, ty, |impl_| {\n+        tcx.find_map_relevant_impl(trait_, ty, TreatProjections::ForLookup, |impl_| {\n             let trait_ref = tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n             // Check if these are the same type.\n             let impl_type = trait_ref.skip_binder().self_ty();"}, {"sha": "db2aa20bde7ab53ba47cb363421e3210f0adeca1", "filename": "tests/codegen/simd-wide-sum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/tests%2Fcodegen%2Fsimd-wide-sum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/tests%2Fcodegen%2Fsimd-wide-sum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsimd-wide-sum.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -C opt-level=3 --edition=2021\n+// compile-flags: -C opt-level=3 -Z merge-functions=disabled --edition=2021\n // only-x86_64\n // ignore-debug: the debug assertions get in the way\n "}, {"sha": "0c400d7bf97244745e45084dc4f69aa3bce97cba", "filename": "tests/ui/target-feature/invalid-attribute.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/tests%2Fui%2Ftarget-feature%2Finvalid-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/tests%2Fui%2Ftarget-feature%2Finvalid-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftarget-feature%2Finvalid-attribute.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -14,6 +14,21 @@\n \n #![warn(unused_attributes)]\n \n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+extern crate alloc;\n+//~^ NOTE not a function\n+\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+use alloc::alloc::alloc;\n+//~^ NOTE not a function\n+\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+extern \"Rust\" {}\n+//~^ NOTE not a function\n+\n #[target_feature = \"+sse2\"]\n //~^ ERROR malformed `target_feature` attribute\n #[target_feature(enable = \"foo\")]\n@@ -59,6 +74,11 @@ union Qux {\n     f2: u16,\n }\n \n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+type Uwu = ();\n+//~^ NOTE not a function\n+\n #[target_feature(enable = \"sse2\")]\n //~^ ERROR attribute should be applied to a function\n trait Baz {}\n@@ -69,6 +89,21 @@ trait Baz {}\n #[target_feature(enable = \"sse2\")]\n unsafe fn test() {}\n \n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+static A: () = ();\n+//~^ NOTE not a function\n+\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+impl Quux for u8 {}\n+//~^ NOTE not a function\n+\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+impl Foo {}\n+//~^ NOTE not a function\n+\n trait Quux {\n     fn foo();\n }"}, {"sha": "6d37d0917bc6135f0e1de413e3e9b300e0399684", "filename": "tests/ui/target-feature/invalid-attribute.stderr", "status": "modified", "additions": 79, "deletions": 16, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/tests%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/tests%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -1,11 +1,38 @@\n error: malformed `target_feature` attribute input\n-  --> $DIR/invalid-attribute.rs:17:1\n+  --> $DIR/invalid-attribute.rs:32:1\n    |\n LL | #[target_feature = \"+sse2\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[target_feature(enable = \"name\")]`\n \n error: attribute should be applied to a function definition\n-  --> $DIR/invalid-attribute.rs:34:1\n+  --> $DIR/invalid-attribute.rs:17:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | extern crate alloc;\n+   | ------------------- not a function definition\n+\n+error: attribute should be applied to a function definition\n+  --> $DIR/invalid-attribute.rs:22:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | use alloc::alloc::alloc;\n+   | ------------------------ not a function definition\n+\n+error: attribute should be applied to a function definition\n+  --> $DIR/invalid-attribute.rs:27:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | extern \"Rust\" {}\n+   | ---------------- not a function definition\n+\n+error: attribute should be applied to a function definition\n+  --> $DIR/invalid-attribute.rs:49:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -14,7 +41,7 @@ LL | mod another {}\n    | -------------- not a function definition\n \n error: attribute should be applied to a function definition\n-  --> $DIR/invalid-attribute.rs:39:1\n+  --> $DIR/invalid-attribute.rs:54:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -23,7 +50,7 @@ LL | const FOO: usize = 7;\n    | --------------------- not a function definition\n \n error: attribute should be applied to a function definition\n-  --> $DIR/invalid-attribute.rs:44:1\n+  --> $DIR/invalid-attribute.rs:59:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -32,7 +59,7 @@ LL | struct Foo;\n    | ----------- not a function definition\n \n error: attribute should be applied to a function definition\n-  --> $DIR/invalid-attribute.rs:49:1\n+  --> $DIR/invalid-attribute.rs:64:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -41,7 +68,7 @@ LL | enum Bar {}\n    | ----------- not a function definition\n \n error: attribute should be applied to a function definition\n-  --> $DIR/invalid-attribute.rs:54:1\n+  --> $DIR/invalid-attribute.rs:69:1\n    |\n LL |   #[target_feature(enable = \"sse2\")]\n    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -54,7 +81,16 @@ LL | | }\n    | |_- not a function definition\n \n error: attribute should be applied to a function definition\n-  --> $DIR/invalid-attribute.rs:62:1\n+  --> $DIR/invalid-attribute.rs:77:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | type Uwu = ();\n+   | -------------- not a function definition\n+\n+error: attribute should be applied to a function definition\n+  --> $DIR/invalid-attribute.rs:82:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -63,7 +99,34 @@ LL | trait Baz {}\n    | ------------ not a function definition\n \n error: attribute should be applied to a function definition\n-  --> $DIR/invalid-attribute.rs:85:5\n+  --> $DIR/invalid-attribute.rs:92:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | static A: () = ();\n+   | ------------------ not a function definition\n+\n+error: attribute should be applied to a function definition\n+  --> $DIR/invalid-attribute.rs:97:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | impl Quux for u8 {}\n+   | ------------------- not a function definition\n+\n+error: attribute should be applied to a function definition\n+  --> $DIR/invalid-attribute.rs:102:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | impl Foo {}\n+   | ----------- not a function definition\n+\n+error: attribute should be applied to a function definition\n+  --> $DIR/invalid-attribute.rs:120:5\n    |\n LL |       #[target_feature(enable = \"sse2\")]\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -75,7 +138,7 @@ LL | |     }\n    | |_____- not a function definition\n \n error: attribute should be applied to a function definition\n-  --> $DIR/invalid-attribute.rs:93:5\n+  --> $DIR/invalid-attribute.rs:128:5\n    |\n LL |     #[target_feature(enable = \"sse2\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -84,25 +147,25 @@ LL |     || {};\n    |     ----- not a function definition\n \n error: the feature named `foo` is not valid for this target\n-  --> $DIR/invalid-attribute.rs:19:18\n+  --> $DIR/invalid-attribute.rs:34:18\n    |\n LL | #[target_feature(enable = \"foo\")]\n    |                  ^^^^^^^^^^^^^^ `foo` is not valid for this target\n \n error: malformed `target_feature` attribute input\n-  --> $DIR/invalid-attribute.rs:22:18\n+  --> $DIR/invalid-attribute.rs:37:18\n    |\n LL | #[target_feature(bar)]\n    |                  ^^^ help: must be of the form: `enable = \"..\"`\n \n error: malformed `target_feature` attribute input\n-  --> $DIR/invalid-attribute.rs:24:18\n+  --> $DIR/invalid-attribute.rs:39:18\n    |\n LL | #[target_feature(disable = \"baz\")]\n    |                  ^^^^^^^^^^^^^^^ help: must be of the form: `enable = \"..\"`\n \n error[E0658]: `#[target_feature(..)]` can only be applied to `unsafe` functions\n-  --> $DIR/invalid-attribute.rs:28:1\n+  --> $DIR/invalid-attribute.rs:43:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -114,13 +177,13 @@ LL | fn bar() {}\n    = help: add `#![feature(target_feature_11)]` to the crate attributes to enable\n \n error: cannot use `#[inline(always)]` with `#[target_feature]`\n-  --> $DIR/invalid-attribute.rs:67:1\n+  --> $DIR/invalid-attribute.rs:87:1\n    |\n LL | #[inline(always)]\n    | ^^^^^^^^^^^^^^^^^\n \n error[E0658]: `#[target_feature(..)]` can only be applied to `unsafe` functions\n-  --> $DIR/invalid-attribute.rs:77:5\n+  --> $DIR/invalid-attribute.rs:112:5\n    |\n LL |     #[target_feature(enable = \"sse2\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -131,6 +194,6 @@ LL |     fn foo() {}\n    = note: see issue #69098 <https://github.com/rust-lang/rust/issues/69098> for more information\n    = help: add `#![feature(target_feature_11)]` to the crate attributes to enable\n \n-error: aborting due to 15 previous errors\n+error: aborting due to 22 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "92bad959095d260b28aed3e01018ce3c244251a1", "filename": "tests/ui/traits/new-solver/nested-obligations-with-bound-vars-gat.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-obligations-with-bound-vars-gat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-obligations-with-bound-vars-gat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-obligations-with-bound-vars-gat.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -0,0 +1,43 @@\n+// check-pass\n+// compile-flags: -Ztrait-solver=next\n+// Issue 96230\n+\n+use std::fmt::Debug;\n+\n+trait Classic {\n+    type Assoc;\n+}\n+\n+trait Gat {\n+    type Assoc<'a>;\n+}\n+\n+struct Foo;\n+\n+impl Classic for Foo {\n+    type Assoc = ();\n+}\n+\n+impl Gat for Foo {\n+    type Assoc<'i> = ();\n+}\n+\n+fn classic_debug<T: Classic>(_: T)\n+where\n+    T::Assoc: Debug,\n+{\n+}\n+\n+fn gat_debug<T: Gat>(_: T)\n+where\n+    for<'a> T::Assoc<'a>: Debug,\n+{\n+}\n+\n+fn main() {\n+    classic_debug::<Foo>(Foo); // fine\n+    classic_debug(Foo); // fine\n+\n+    gat_debug::<Foo>(Foo); // fine\n+    gat_debug(Foo); // boom\n+}"}, {"sha": "1dca86d3630b1a82e99700380b0b301e9183e771", "filename": "tests/ui/traits/new-solver/runaway-impl-candidate-selection.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/tests%2Fui%2Ftraits%2Fnew-solver%2Frunaway-impl-candidate-selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/tests%2Fui%2Ftraits%2Fnew-solver%2Frunaway-impl-candidate-selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frunaway-impl-candidate-selection.rs?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+// In the new solver, we are trying to select `<?0 as Iterator>::Item: Debug`,\n+// which, naively can be unified with every impl of `Debug` if we're not careful.\n+// This test makes sure that we treat projections with inference var substs as\n+// placeholders during fast reject.\n+\n+fn iter<T: Iterator>() -> <T as Iterator>::Item {\n+    todo!()\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", iter::<_>());\n+    //~^ ERROR type annotations needed\n+}"}, {"sha": "47004821ad7c6c1ce0058b2c17ede639331b365d", "filename": "tests/ui/traits/new-solver/runaway-impl-candidate-selection.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c54af457d05722321ca88c2ae0e5706ef803c5fb/tests%2Fui%2Ftraits%2Fnew-solver%2Frunaway-impl-candidate-selection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c54af457d05722321ca88c2ae0e5706ef803c5fb/tests%2Fui%2Ftraits%2Fnew-solver%2Frunaway-impl-candidate-selection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frunaway-impl-candidate-selection.stderr?ref=c54af457d05722321ca88c2ae0e5706ef803c5fb", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/runaway-impl-candidate-selection.rs:13:22\n+   |\n+LL |     println!(\"{:?}\", iter::<_>());\n+   |                      ^^^^^^^^^ cannot infer type of the type parameter `T` declared on the function `iter`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}]}