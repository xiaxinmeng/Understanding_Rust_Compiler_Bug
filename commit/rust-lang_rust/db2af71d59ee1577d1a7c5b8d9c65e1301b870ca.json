{"sha": "db2af71d59ee1577d1a7c5b8d9c65e1301b870ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMmFmNzFkNTllZTE1NzdkMWE3YzViOGQ5YzY1ZTEzMDFiODcwY2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-30T05:54:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-30T05:54:55Z"}, "message": "Auto merge of #27174 - Gankro:rc-sat, r=alexcrichton\n\nSee https://internals.rust-lang.org/t/rc-is-unsafe-mostly-on-32-bit-targets-due-to-overflow/2120 for detailed discussion of this problem.", "tree": {"sha": "614c68db45b21538235673f99eedcd6ca630ace3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/614c68db45b21538235673f99eedcd6ca630ace3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db2af71d59ee1577d1a7c5b8d9c65e1301b870ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db2af71d59ee1577d1a7c5b8d9c65e1301b870ca", "html_url": "https://github.com/rust-lang/rust/commit/db2af71d59ee1577d1a7c5b8d9c65e1301b870ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db2af71d59ee1577d1a7c5b8d9c65e1301b870ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b9ada599747648cd10d9971e97ddb610712b711", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b9ada599747648cd10d9971e97ddb610712b711", "html_url": "https://github.com/rust-lang/rust/commit/8b9ada599747648cd10d9971e97ddb610712b711"}, {"sha": "22e21004582902cc1b7d1bef89d09728cbe64ca2", "url": "https://api.github.com/repos/rust-lang/rust/commits/22e21004582902cc1b7d1bef89d09728cbe64ca2", "html_url": "https://github.com/rust-lang/rust/commit/22e21004582902cc1b7d1bef89d09728cbe64ca2"}], "stats": {"total": 49, "additions": 42, "deletions": 7}, "files": [{"sha": "46b6a5722eabebe26ce565062bcbcad179e3d564", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/db2af71d59ee1577d1a7c5b8d9c65e1301b870ca/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db2af71d59ee1577d1a7c5b8d9c65e1301b870ca/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=db2af71d59ee1577d1a7c5b8d9c65e1301b870ca", "patch": "@@ -78,16 +78,18 @@ use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n use core::fmt;\n use core::cmp::Ordering;\n use core::mem::{align_of_val, size_of_val};\n-use core::intrinsics::drop_in_place;\n+use core::intrinsics::{drop_in_place, abort};\n use core::mem;\n use core::nonzero::NonZero;\n use core::ops::{Deref, CoerceUnsized};\n use core::ptr;\n use core::marker::Unsize;\n use core::hash::{Hash, Hasher};\n-use core::usize;\n+use core::{usize, isize};\n use heap::deallocate;\n \n+const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n+\n /// An atomically reference counted wrapper for shared state.\n ///\n /// # Examples\n@@ -312,7 +314,21 @@ impl<T: ?Sized> Clone for Arc<T> {\n         // another must already provide any required synchronization.\n         //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n-        self.inner().strong.fetch_add(1, Relaxed);\n+        let old_size = self.inner().strong.fetch_add(1, Relaxed);\n+\n+        // However we need to guard against massive refcounts in case someone\n+        // is `mem::forget`ing Arcs. If we don't do this the count can overflow\n+        // and users will use-after free. We racily saturate to `isize::MAX` on\n+        // the assumption that there aren't ~2 billion threads incrementing\n+        // the reference count at once. This branch will never be taken in\n+        // any realistic program.\n+        //\n+        // We abort because such a program is incredibly degenerate, and we\n+        // don't care to support it.\n+        if old_size > MAX_REFCOUNT {\n+            unsafe { abort(); }\n+        }\n+\n         Arc { _ptr: self._ptr }\n     }\n }\n@@ -617,7 +633,13 @@ impl<T: ?Sized> Clone for Weak<T> {\n         // fetch_add (ignoring the lock) because the weak count is only locked\n         // where are *no other* weak pointers in existence. (So we can't be\n         // running this code in that case).\n-        self.inner().weak.fetch_add(1, Relaxed);\n+        let old_size = self.inner().weak.fetch_add(1, Relaxed);\n+\n+        // See comments in Arc::clone() for why we do this (for mem::forget).\n+        if old_size > MAX_REFCOUNT {\n+            unsafe { abort(); }\n+        }\n+\n         return Weak { _ptr: self._ptr }\n     }\n }"}, {"sha": "e4e3b3b209c1aca8cf8bfef1e43213ed48085f29", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/db2af71d59ee1577d1a7c5b8d9c65e1301b870ca/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db2af71d59ee1577d1a7c5b8d9c65e1301b870ca/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=db2af71d59ee1577d1a7c5b8d9c65e1301b870ca", "patch": "@@ -161,7 +161,7 @@ use core::cell::Cell;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n-use core::intrinsics::{assume, drop_in_place};\n+use core::intrinsics::{assume, drop_in_place, abort};\n use core::marker::{self, Unsize};\n use core::mem::{self, align_of, size_of, align_of_val, size_of_val, forget};\n use core::nonzero::NonZero;\n@@ -858,6 +858,15 @@ impl<T: ?Sized+fmt::Debug> fmt::Debug for Weak<T> {\n     }\n }\n \n+// NOTE: We checked_add here to deal with mem::forget safety. In particular\n+// if you mem::forget Rcs (or Weaks), the ref-count can overflow, and then\n+// you can free the allocation while outstanding Rcs (or Weaks) exist.\n+// We abort because this is such a degenerate scenario that we don't care about\n+// what happens -- no real program should ever experience this.\n+//\n+// This should have negligible overhead since you don't actually need to\n+// clone these much in Rust thanks to ownership and move-semantics.\n+\n #[doc(hidden)]\n trait RcBoxPtr<T: ?Sized> {\n     fn inner(&self) -> &RcBox<T>;\n@@ -866,7 +875,9 @@ trait RcBoxPtr<T: ?Sized> {\n     fn strong(&self) -> usize { self.inner().strong.get() }\n \n     #[inline]\n-    fn inc_strong(&self) { self.inner().strong.set(self.strong() + 1); }\n+    fn inc_strong(&self) {\n+        self.inner().strong.set(self.strong().checked_add(1).unwrap_or_else(|| unsafe { abort() }));\n+    }\n \n     #[inline]\n     fn dec_strong(&self) { self.inner().strong.set(self.strong() - 1); }\n@@ -875,7 +886,9 @@ trait RcBoxPtr<T: ?Sized> {\n     fn weak(&self) -> usize { self.inner().weak.get() }\n \n     #[inline]\n-    fn inc_weak(&self) { self.inner().weak.set(self.weak() + 1); }\n+    fn inc_weak(&self) {\n+        self.inner().weak.set(self.weak().checked_add(1).unwrap_or_else(|| unsafe { abort() }));\n+    }\n \n     #[inline]\n     fn dec_weak(&self) { self.inner().weak.set(self.weak() - 1); }"}]}