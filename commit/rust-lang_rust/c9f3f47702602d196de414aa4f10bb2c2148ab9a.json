{"sha": "c9f3f47702602d196de414aa4f10bb2c2148ab9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ZjNmNDc3MDI2MDJkMTk2ZGU0MTRhYTRmMTBiYjJjMjE0OGFiOWE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-06-12T21:08:44Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-13T20:53:55Z"}, "message": "librustc: Forbid `transmute` from being called on types whose size is\nonly known post-monomorphization, and report `transmute` errors before\nthe code is generated for that `transmute`.\n\nThis can break code that looked like:\n\n    unsafe fn f<T>(x: T) {\n        let y: int = transmute(x);\n    }\n\nChange such code to take a type parameter that has the same size as the\ntype being transmuted to.\n\nCloses #12898.\n\n[breaking-change]", "tree": {"sha": "9a1b3943e8b6f01f77750333547178f2b92ce7ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a1b3943e8b6f01f77750333547178f2b92ce7ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9f3f47702602d196de414aa4f10bb2c2148ab9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9f3f47702602d196de414aa4f10bb2c2148ab9a", "html_url": "https://github.com/rust-lang/rust/commit/c9f3f47702602d196de414aa4f10bb2c2148ab9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9f3f47702602d196de414aa4f10bb2c2148ab9a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c4a10a159a021a586a8a35552cbbe4f60e644a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c4a10a159a021a586a8a35552cbbe4f60e644a2", "html_url": "https://github.com/rust-lang/rust/commit/8c4a10a159a021a586a8a35552cbbe4f60e644a2"}], "stats": {"total": 354, "additions": 323, "deletions": 31}, "files": [{"sha": "33f2a49d6d560cba10c9dd49d185c1663fa312ce", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=c9f3f47702602d196de414aa4f10bb2c2148ab9a", "patch": "@@ -307,6 +307,20 @@ extern \"rust-intrinsic\" {\n     /// `forget` is unsafe because the caller is responsible for\n     /// ensuring the argument is deallocated already.\n     pub fn forget<T>(_: T) -> ();\n+\n+    /// Unsafely transforms a value of one type into a value of another type.\n+    ///\n+    /// Both types must have the same size and alignment, and this guarantee\n+    /// is enforced at compile-time.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::mem;\n+    ///\n+    /// let v: &[u8] = unsafe { mem::transmute(\"L\") };\n+    /// assert!(v == [76u8]);\n+    /// ```\n     pub fn transmute<T,U>(e: T) -> U;\n \n     /// Returns `true` if a type requires drop glue."}, {"sha": "237efcd0096d0e190e7490d4cf64db62d5ff5ac0", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=c9f3f47702602d196de414aa4f10bb2c2148ab9a", "patch": "@@ -17,6 +17,8 @@ use ptr;\n use intrinsics;\n use intrinsics::{bswap16, bswap32, bswap64};\n \n+pub use intrinsics::transmute;\n+\n /// Returns the size of a type in bytes.\n #[inline]\n #[stable]\n@@ -412,29 +414,6 @@ pub fn drop<T>(_x: T) { }\n #[stable]\n pub unsafe fn forget<T>(thing: T) { intrinsics::forget(thing) }\n \n-/// Unsafely transforms a value of one type into a value of another type.\n-///\n-/// Both types must have the same size and alignment, and this guarantee is\n-/// enforced at compile-time.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::mem;\n-///\n-/// let v: &[u8] = unsafe { mem::transmute(\"L\") };\n-/// assert!(v == [76u8]);\n-/// ```\n-#[inline]\n-#[unstable = \"this function will be modified to reject invocations of it which \\\n-              cannot statically prove that T and U are the same size. For \\\n-              example, this function, as written today, will be rejected in \\\n-              the future because the size of T and U cannot be statically \\\n-              known to be the same\"]\n-pub unsafe fn transmute<T, U>(thing: T) -> U {\n-    intrinsics::transmute(thing)\n-}\n-\n /// Interprets `src` as `&U`, and then reads `src` without moving the contained\n /// value.\n ///"}, {"sha": "2268ce843658796c75cfb99b5bd57364237fe8a2", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=c9f3f47702602d196de414aa4f10bb2c2148ab9a", "patch": "@@ -333,6 +333,9 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n             time(time_passes, \"privacy checking\", maps, |(a, b)|\n                  middle::privacy::check_crate(&ty_cx, &exp_map2, a, b, krate));\n \n+    time(time_passes, \"intrinsic checking\", (), |_|\n+         middle::intrinsicck::check_crate(&ty_cx, krate));\n+\n     time(time_passes, \"effect checking\", (), |_|\n          middle::effect::check_crate(&ty_cx, krate));\n "}, {"sha": "1e39aaa3a5fac61a7b0dc0a201be9acbf5d5ab77", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c9f3f47702602d196de414aa4f10bb2c2148ab9a", "patch": "@@ -85,6 +85,7 @@ pub mod middle {\n     pub mod dependency_format;\n     pub mod weak_lang_items;\n     pub mod save;\n+    pub mod intrinsicck;\n }\n \n pub mod front {"}, {"sha": "93913f842711197bc6e032975920dfb15a3edd40", "filename": "src/librustc/middle/intrinsicck.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=c9f3f47702602d196de414aa4f10bb2c2148ab9a", "patch": "@@ -0,0 +1,155 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use metadata::csearch;\n+use middle::def::DefFn;\n+use middle::subst::Subst;\n+use middle::ty::{TransmuteRestriction, ctxt, ty_bare_fn};\n+use middle::ty;\n+\n+use syntax::abi::RustIntrinsic;\n+use syntax::ast::DefId;\n+use syntax::ast;\n+use syntax::ast_map::NodeForeignItem;\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+use syntax::visit::Visitor;\n+use syntax::visit;\n+\n+fn type_size_is_affected_by_type_parameters(tcx: &ty::ctxt, typ: ty::t)\n+                                            -> bool {\n+    let mut result = false;\n+    ty::maybe_walk_ty(typ, |typ| {\n+        match ty::get(typ).sty {\n+            ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_ptr(_) |\n+            ty::ty_rptr(..) | ty::ty_bare_fn(..) | ty::ty_closure(..) => {\n+                false\n+            }\n+            ty::ty_param(_) => {\n+                result = true;\n+                // No need to continue; we now know the result.\n+                false\n+            }\n+            ty::ty_enum(did, ref substs) => {\n+                for enum_variant in (*ty::enum_variants(tcx, did)).iter() {\n+                    for argument_type in enum_variant.args.iter() {\n+                        let argument_type = argument_type.subst(tcx, substs);\n+                        result = result ||\n+                            type_size_is_affected_by_type_parameters(\n+                                tcx,\n+                                argument_type);\n+                    }\n+                }\n+\n+                // Don't traverse substitutions.\n+                false\n+            }\n+            ty::ty_struct(did, ref substs) => {\n+                for field in ty::struct_fields(tcx, did, substs).iter() {\n+                    result = result ||\n+                        type_size_is_affected_by_type_parameters(tcx,\n+                                                                 field.mt.ty);\n+                }\n+\n+                // Don't traverse substitutions.\n+                false\n+            }\n+            _ => true,\n+        }\n+    });\n+    result\n+}\n+\n+struct IntrinsicCheckingVisitor<'a> {\n+    tcx: &'a ctxt,\n+}\n+\n+impl<'a> IntrinsicCheckingVisitor<'a> {\n+    fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n+        if def_id.krate == ast::LOCAL_CRATE {\n+            match self.tcx.map.get(def_id.node) {\n+                NodeForeignItem(ref item) => {\n+                    token::get_ident(item.ident) ==\n+                        token::intern_and_get_ident(\"transmute\")\n+                }\n+                _ => false,\n+            }\n+        } else {\n+            match csearch::get_item_path(self.tcx, def_id).last() {\n+                None => false,\n+                Some(ref last) => {\n+                    token::get_name(last.name()) ==\n+                        token::intern_and_get_ident(\"transmute\")\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_transmute(&self, span: Span, from: ty::t, to: ty::t) {\n+        if type_size_is_affected_by_type_parameters(self.tcx, from) {\n+            self.tcx.sess.span_err(span,\n+                                   \"cannot transmute from a type that \\\n+                                    contains type parameters\");\n+        }\n+        if type_size_is_affected_by_type_parameters(self.tcx, to) {\n+            self.tcx.sess.span_err(span,\n+                                   \"cannot transmute to a type that contains \\\n+                                    type parameters\");\n+        }\n+\n+        let restriction = TransmuteRestriction {\n+            span: span,\n+            from: from,\n+            to: to,\n+        };\n+        self.tcx.transmute_restrictions.borrow_mut().push(restriction);\n+    }\n+}\n+\n+impl<'a> Visitor<()> for IntrinsicCheckingVisitor<'a> {\n+    fn visit_expr(&mut self, expr: &ast::Expr, (): ()) {\n+        match expr.node {\n+            ast::ExprPath(..) => {\n+                match ty::resolve_expr(self.tcx, expr) {\n+                    DefFn(did, _) if self.def_id_is_transmute(did) => {\n+                        let typ = ty::node_id_to_type(self.tcx, expr.id);\n+                        match ty::get(typ).sty {\n+                            ty_bare_fn(ref bare_fn_ty)\n+                                    if bare_fn_ty.abi == RustIntrinsic => {\n+                                let from = *bare_fn_ty.sig.inputs.get(0);\n+                                let to = bare_fn_ty.sig.output;\n+                                self.check_transmute(expr.span, from, to);\n+                            }\n+                            _ => {\n+                                self.tcx\n+                                    .sess\n+                                    .span_bug(expr.span,\n+                                              \"transmute wasn't a bare fn?!\");\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_expr(self, expr, ());\n+    }\n+}\n+\n+pub fn check_crate(tcx: &ctxt, krate: &ast::Crate) {\n+    let mut visitor = IntrinsicCheckingVisitor {\n+        tcx: tcx,\n+    };\n+\n+    visit::walk_crate(&mut visitor, krate, ());\n+}\n+"}, {"sha": "14c8d5454aac8f58f1202024460b349180f75ce9", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c9f3f47702602d196de414aa4f10bb2c2148ab9a", "patch": "@@ -59,6 +59,7 @@ use middle::trans::expr;\n use middle::trans::foreign;\n use middle::trans::glue;\n use middle::trans::inline;\n+use middle::trans::intrinsic;\n use middle::trans::machine;\n use middle::trans::machine::{llalign_of_min, llsize_of, llsize_of_real};\n use middle::trans::meth;\n@@ -2329,6 +2330,11 @@ pub fn trans_crate(krate: ast::Crate,\n \n     let ccx = CrateContext::new(llmod_id.as_slice(), tcx, exp_map2,\n                                 Sha256::new(), link_meta, reachable);\n+\n+    // First, verify intrinsics.\n+    intrinsic::check_intrinsics(&ccx);\n+\n+    // Next, translate the module.\n     {\n         let _icx = push_ctxt(\"text\");\n         trans_mod(&ccx, &krate.module);"}, {"sha": "648a2c335e6860f0121e49840b5272e37953c1bf", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=c9f3f47702602d196de414aa4f10bb2c2148ab9a", "patch": "@@ -390,7 +390,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n                     ast_map::NodeExpr(e) => e.span,\n                     _ => fail!(\"transmute has non-expr arg\"),\n                 };\n-                ccx.sess().span_fatal(sp,\n+                ccx.sess().span_bug(sp,\n                     format!(\"transmute called on types with different sizes: \\\n                              {} ({} bit{}) to \\\n                              {} ({} bit{})\",\n@@ -564,3 +564,41 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n     }\n     fcx.cleanup();\n }\n+\n+/// Performs late verification that intrinsics are used correctly. At present,\n+/// the only intrinsic that needs such verification is `transmute`.\n+pub fn check_intrinsics(ccx: &CrateContext) {\n+    for transmute_restriction in ccx.tcx\n+                                    .transmute_restrictions\n+                                    .borrow()\n+                                    .iter() {\n+        let llfromtype = type_of::sizing_type_of(ccx,\n+                                                 transmute_restriction.from);\n+        let lltotype = type_of::sizing_type_of(ccx,\n+                                               transmute_restriction.to);\n+        let from_type_size = machine::llbitsize_of_real(ccx, llfromtype);\n+        let to_type_size = machine::llbitsize_of_real(ccx, lltotype);\n+        if from_type_size != to_type_size {\n+            ccx.sess()\n+               .span_err(transmute_restriction.span,\n+                format!(\"transmute called on types with different sizes: \\\n+                         {} ({} bit{}) to {} ({} bit{})\",\n+                        ty_to_str(ccx.tcx(), transmute_restriction.from),\n+                        from_type_size as uint,\n+                        if from_type_size == 1 {\n+                            \"\"\n+                        } else {\n+                            \"s\"\n+                        },\n+                        ty_to_str(ccx.tcx(), transmute_restriction.to),\n+                        to_type_size as uint,\n+                        if to_type_size == 1 {\n+                            \"\"\n+                        } else {\n+                            \"s\"\n+                        }).as_slice());\n+        }\n+    }\n+    ccx.sess().abort_if_errors();\n+}\n+"}, {"sha": "02300fccdae16402bcadd0363ad4f4f52c3f0750", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c9f3f47702602d196de414aa4f10bb2c2148ab9a", "patch": "@@ -235,6 +235,17 @@ pub enum AutoRef {\n     AutoBorrowObj(Region, ast::Mutability),\n }\n \n+/// A restriction that certain types must be the same size. The use of\n+/// `transmute` gives rise to these restrictions.\n+pub struct TransmuteRestriction {\n+    /// The span from whence the restriction comes.\n+    pub span: Span,\n+    /// The type being transmuted from.\n+    pub from: t,\n+    /// The type being transmuted to.\n+    pub to: t,\n+}\n+\n /// The data structure to keep track of all the information that typechecker\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n@@ -357,6 +368,11 @@ pub struct ctxt {\n \n     pub node_lint_levels: RefCell<HashMap<(ast::NodeId, lint::Lint),\n                                           (lint::Level, lint::LintSource)>>,\n+\n+    /// The types that must be asserted to be the same size for `transmute`\n+    /// to be valid. We gather up these restrictions in the intrinsicck pass\n+    /// and check them in trans.\n+    pub transmute_restrictions: RefCell<Vec<TransmuteRestriction>>,\n }\n \n pub enum tbox_flag {\n@@ -1118,6 +1134,7 @@ pub fn mk_ctxt(s: Session,\n         vtable_map: RefCell::new(FnvHashMap::new()),\n         dependency_formats: RefCell::new(HashMap::new()),\n         node_lint_levels: RefCell::new(HashMap::new()),\n+        transmute_restrictions: RefCell::new(Vec::new()),\n     }\n }\n \n@@ -2711,8 +2728,7 @@ pub fn pat_ty(cx: &ctxt, pat: &ast::Pat) -> t {\n //\n // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n-// instead of \"fn(t) -> T with T = int\". If this isn't what you want, see\n-// expr_ty_params_and_ty() below.\n+// instead of \"fn(t) -> T with T = int\".\n pub fn expr_ty(cx: &ctxt, expr: &ast::Expr) -> t {\n     return node_id_to_type(cx, expr.id);\n }"}, {"sha": "7d74b8c7296522f1a5f187173a005235c41f67bd", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=c9f3f47702602d196de414aa4f10bb2c2148ab9a", "patch": "@@ -126,9 +126,11 @@ impl<'a> PluginLoader<'a> {\n         };\n \n         unsafe {\n-            let registrar: PluginRegistrarFun =\n+            let registrar =\n                 match lib.symbol(symbol.as_slice()) {\n-                    Ok(registrar) => registrar,\n+                    Ok(registrar) => {\n+                        mem::transmute::<*u8,PluginRegistrarFun>(registrar)\n+                    }\n                     // again fatal if we can't register macros\n                     Err(err) => self.sess.span_fatal(vi.span, err.as_slice())\n                 };"}, {"sha": "e5bced8038baf49f2a325a51497e6c739906d17a", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=c9f3f47702602d196de414aa4f10bb2c2148ab9a", "patch": "@@ -12,6 +12,7 @@ use clean;\n \n use dl = std::dynamic_lib;\n use serialize::json;\n+use std::mem;\n use std::string::String;\n \n pub type PluginJson = Option<(String, json::Json)>;\n@@ -45,9 +46,11 @@ impl PluginManager {\n         let x = self.prefix.join(libname(name));\n         let lib_result = dl::DynamicLibrary::open(Some(&x));\n         let lib = lib_result.unwrap();\n-        let plugin = unsafe { lib.symbol(\"rustdoc_plugin_entrypoint\") }.unwrap();\n+        unsafe {\n+            let plugin = lib.symbol(\"rustdoc_plugin_entrypoint\").unwrap();\n+            self.callbacks.push(mem::transmute::<*u8,PluginCallback>(plugin));\n+        }\n         self.dylibs.push(lib);\n-        self.callbacks.push(plugin);\n     }\n \n     /// Load a normal Rust function as a plugin."}, {"sha": "61f7997071e8bc389e73d8c87003b048fce369da", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=c9f3f47702602d196de414aa4f10bb2c2148ab9a", "patch": "@@ -134,7 +134,7 @@ impl DynamicLibrary {\n     }\n \n     /// Access the value at the symbol of the dynamic library\n-    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<T, String> {\n+    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*T, String> {\n         // This function should have a lifetime constraint of 'a on\n         // T but that feature is still unimplemented\n "}, {"sha": "5ea1c496c769f68b273cf6b08cbf84cbc8639d00", "filename": "src/test/compile-fail/transmute-different-sizes.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs?ref=c9f3f47702602d196de414aa4f10bb2c2148ab9a", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that `transmute` cannot be called on types of different size.\n+\n+use std::mem::transmute;\n+\n+unsafe fn f() {\n+    let _: i8 = transmute(16i16);\n+    //~^ ERROR transmute called on types with different sizes\n+}\n+\n+unsafe fn g<T>(x: &T) {\n+    let _: i8 = transmute(x);\n+    //~^ ERROR transmute called on types with different sizes\n+}\n+\n+fn main() {}\n+\n+"}, {"sha": "53391a0e8947b9088b3d9398d88019a130279ed3", "filename": "src/test/compile-fail/transmute-type-parameters.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f3f47702602d196de414aa4f10bb2c2148ab9a/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs?ref=c9f3f47702602d196de414aa4f10bb2c2148ab9a", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that `transmute` cannot be called on type parameters.\n+\n+use std::mem::transmute;\n+\n+unsafe fn f<T>(x: T) {\n+    let _: int = transmute(x);  //~ ERROR cannot transmute\n+}\n+\n+unsafe fn g<T>(x: (T, int)) {\n+    let _: int = transmute(x);  //~ ERROR cannot transmute\n+}\n+\n+unsafe fn h<T>(x: [T, ..10]) {\n+    let _: int = transmute(x);  //~ ERROR cannot transmute\n+}\n+\n+struct Bad<T> {\n+    f: T,\n+}\n+\n+unsafe fn i<T>(x: Bad<T>) {\n+    let _: int = transmute(x);  //~ ERROR cannot transmute\n+}\n+\n+enum Worse<T> {\n+    A(T),\n+    B,\n+}\n+\n+unsafe fn j<T>(x: Worse<T>) {\n+    let _: int = transmute(x);  //~ ERROR cannot transmute\n+}\n+\n+unsafe fn k<T>(x: Option<T>) {\n+    let _: int = transmute(x);  //~ ERROR cannot transmute\n+}\n+\n+fn main() {}"}]}