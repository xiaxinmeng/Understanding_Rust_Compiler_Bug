{"sha": "14027f3e784de815de726a8fb0e74875781c9caf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MDI3ZjNlNzg0ZGU4MTVkZTcyNmE4ZmIwZTc0ODc1NzgxYzljYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-11T22:08:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-11T22:08:01Z"}, "message": "Auto merge of #73259 - Dylan-DPC:rollup-m6nw1n0, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #73033 (Fix #[thread_local] statics as asm! sym operands)\n - #73036 (std: Enable atomic.fence emission on wasm32)\n - #73163 (Add long error explanation for E0724)\n - #73187 (Remove missed `cfg(bootstrap)`)\n - #73195 (Provide suggestion to convert numeric op LHS rather than unwrapping RHS)\n - #73247 (Add various Zulip notifications for prioritization)\n - #73254 (Add comment about LocalDefId -> DefId)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "669d687c8323ce3b452ef2418bfe4f2ebcd5f352", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/669d687c8323ce3b452ef2418bfe4f2ebcd5f352"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14027f3e784de815de726a8fb0e74875781c9caf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14027f3e784de815de726a8fb0e74875781c9caf", "html_url": "https://github.com/rust-lang/rust/commit/14027f3e784de815de726a8fb0e74875781c9caf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14027f3e784de815de726a8fb0e74875781c9caf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a37c32e2d5fb186627ffe99a391c7fd6fd159334", "url": "https://api.github.com/repos/rust-lang/rust/commits/a37c32e2d5fb186627ffe99a391c7fd6fd159334", "html_url": "https://github.com/rust-lang/rust/commit/a37c32e2d5fb186627ffe99a391c7fd6fd159334"}, {"sha": "85a48d07e302b6989fc77a6e8413dff492688e91", "url": "https://api.github.com/repos/rust-lang/rust/commits/85a48d07e302b6989fc77a6e8413dff492688e91", "html_url": "https://github.com/rust-lang/rust/commit/85a48d07e302b6989fc77a6e8413dff492688e91"}], "stats": {"total": 2390, "additions": 2278, "deletions": 112}, "files": [{"sha": "1cd68f2881b7c7c3f497c29f980a3360ba08fc47", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -2623,15 +2623,7 @@ unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(target_arch = \"wasm32\", allow(unused_variables))]\n pub fn fence(order: Ordering) {\n-    // On wasm32 it looks like fences aren't implemented in LLVM yet in that\n-    // they will cause LLVM to abort. The wasm instruction set doesn't have\n-    // fences right now. There's discussion online about the best way for tools\n-    // to conventionally implement fences at\n-    // https://github.com/WebAssembly/tool-conventions/issues/59. We should\n-    // follow that discussion and implement a solution when one comes about!\n-    #[cfg(not(target_arch = \"wasm32\"))]\n     // SAFETY: using an atomic fence is safe.\n     unsafe {\n         match order {"}, {"sha": "ef59ad486eefe5fa12be6cebef0f19de2fc282a1", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -927,12 +927,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         span_bug!(span, \"invalid type for asm sym (fn)\");\n                     }\n                 }\n-                mir::InlineAsmOperand::SymStatic { ref value } => {\n-                    if let Some(def_id) = value.check_static_ptr(bx.tcx()) {\n-                        InlineAsmOperandRef::SymStatic { def_id }\n-                    } else {\n-                        span_bug!(span, \"invalid type for asm sym (static)\");\n-                    }\n+                mir::InlineAsmOperand::SymStatic { def_id } => {\n+                    InlineAsmOperandRef::SymStatic { def_id }\n                 }\n             })\n             .collect();"}, {"sha": "3fb5e04efc9227953ea9efd18215fc8aac0dc11c", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -409,6 +409,7 @@ E0718: include_str!(\"./error_codes/E0718.md\"),\n E0719: include_str!(\"./error_codes/E0719.md\"),\n E0720: include_str!(\"./error_codes/E0720.md\"),\n E0723: include_str!(\"./error_codes/E0723.md\"),\n+E0724: include_str!(\"./error_codes/E0724.md\"),\n E0725: include_str!(\"./error_codes/E0725.md\"),\n E0727: include_str!(\"./error_codes/E0727.md\"),\n E0728: include_str!(\"./error_codes/E0728.md\"),\n@@ -617,7 +618,6 @@ E0762: include_str!(\"./error_codes/E0762.md\"),\n     E0717, // rustc_promotable without stability attribute\n //  E0721, // `await` keyword\n     E0722, // Malformed `#[optimize]` attribute\n-    E0724, // `#[ffi_returns_twice]` is only allowed in foreign functions\n     E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n //  E0738, // Removed; errored on `#[track_caller] fn`s in `extern \"Rust\" { ... }`.\n     E0755, // `#[ffi_pure]` is only allowed on foreign functions"}, {"sha": "7a7ba15485434836c9754da42db925d1a098a5d8", "filename": "src/librustc_error_codes/error_codes/E0724.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_error_codes%2Ferror_codes%2FE0724.md", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_error_codes%2Ferror_codes%2FE0724.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0724.md?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -0,0 +1,24 @@\n+`#[ffi_returns_twice]` was used on non-foreign function.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0724\n+#![feature(ffi_returns_twice)]\n+#![crate_type = \"lib\"]\n+\n+#[ffi_returns_twice] // error!\n+pub fn foo() {}\n+```\n+\n+`#[ffi_returns_twice]` can only be used on foreign function declarations.\n+For example, we might correct the previous example by declaring\n+the function inside of an\u00a0`extern`\u00a0block.\n+\n+```\n+#![feature(ffi_returns_twice)]\n+\n+extern {\n+   #[ffi_returns_twice] // ok!\n+   pub fn foo();\n+}\n+```"}, {"sha": "129f9691ea521b4d7405c0a570d5b945a2e32c8f", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -1243,7 +1243,7 @@ pub enum InlineAsmOperand<'tcx> {\n         value: Box<Constant<'tcx>>,\n     },\n     SymStatic {\n-        value: Box<Constant<'tcx>>,\n+        def_id: DefId,\n     },\n }\n \n@@ -1639,9 +1639,11 @@ impl<'tcx> TerminatorKind<'tcx> {\n                         InlineAsmOperand::Const { value } => {\n                             write!(fmt, \"const {:?}\", value)?;\n                         }\n-                        InlineAsmOperand::SymFn { value }\n-                        | InlineAsmOperand::SymStatic { value } => {\n-                            write!(fmt, \"sym {:?}\", value)?;\n+                        InlineAsmOperand::SymFn { value } => {\n+                            write!(fmt, \"sym_fn {:?}\", value)?;\n+                        }\n+                        InlineAsmOperand::SymStatic { def_id } => {\n+                            write!(fmt, \"sym_static {:?}\", def_id)?;\n                         }\n                     }\n                 }"}, {"sha": "5f9fcdca516b1ae802515bbbbc656dfb226be0be", "filename": "src/librustc_middle/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fvisit.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -564,10 +564,10 @@ macro_rules! make_mir_visitor {\n                                         );\n                                     }\n                                 }\n-                                InlineAsmOperand::SymFn { value }\n-                                | InlineAsmOperand::SymStatic { value } => {\n+                                InlineAsmOperand::SymFn { value } => {\n                                     self.visit_constant(value, source_location);\n                                 }\n+                                InlineAsmOperand::SymStatic { def_id: _ } => {}\n                             }\n                         }\n                     }"}, {"sha": "17fa641ae6c17d1c6edd2ee56e348d677d1454ca", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -209,7 +209,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                             }\n                         }\n                         InlineAsmOperand::SymFn { value: _ }\n-                        | InlineAsmOperand::SymStatic { value: _ } => {}\n+                        | InlineAsmOperand::SymStatic { def_id: _ } => {}\n                     }\n                 }\n             }"}, {"sha": "b703237a18e111b3f76c7e56f5b8090a4b7200b8", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -760,7 +760,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                             }\n                         }\n                         InlineAsmOperand::SymFn { value: _ }\n-                        | InlineAsmOperand::SymStatic { value: _ } => {}\n+                        | InlineAsmOperand::SymStatic { def_id: _ } => {}\n                     }\n                 }\n             }"}, {"sha": "41c7bd95a96cc1e877fe7e63362e76f3bdef3e84", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -439,7 +439,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                             }\n                         }\n                         InlineAsmOperand::SymFn { value: _ }\n-                        | InlineAsmOperand::SymStatic { value: _ } => {}\n+                        | InlineAsmOperand::SymStatic { def_id: _ } => {}\n                     }\n                 }\n             }"}, {"sha": "994d1e69f2e3e709cefadfa34f4205121b151bf7", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -634,9 +634,19 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             }\n             mir::TerminatorKind::InlineAsm { ref operands, .. } => {\n                 for op in operands {\n-                    if let mir::InlineAsmOperand::SymFn { value } = op {\n-                        let fn_ty = self.monomorphize(value.literal.ty);\n-                        visit_fn_use(self.tcx, fn_ty, false, &mut self.output);\n+                    match *op {\n+                        mir::InlineAsmOperand::SymFn { ref value } => {\n+                            let fn_ty = self.monomorphize(value.literal.ty);\n+                            visit_fn_use(self.tcx, fn_ty, false, &mut self.output);\n+                        }\n+                        mir::InlineAsmOperand::SymStatic { def_id } => {\n+                            let instance = Instance::mono(self.tcx, def_id);\n+                            if should_monomorphize_locally(self.tcx, &instance) {\n+                                trace!(\"collecting asm sym static {:?}\", def_id);\n+                                self.output.push(MonoItem::Static(def_id));\n+                            }\n+                        }\n+                        _ => {}\n                     }\n                 }\n             }"}, {"sha": "0d5bd4c7e61b90a5448f5c593a25bc9930b2a827", "filename": "src/librustc_mir_build/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -358,8 +358,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         hair::InlineAsmOperand::SymFn { expr } => {\n                             mir::InlineAsmOperand::SymFn { value: box this.as_constant(expr) }\n                         }\n-                        hair::InlineAsmOperand::SymStatic { expr } => {\n-                            mir::InlineAsmOperand::SymStatic { value: box this.as_constant(expr) }\n+                        hair::InlineAsmOperand::SymStatic { def_id } => {\n+                            mir::InlineAsmOperand::SymStatic { def_id }\n                         }\n                     })\n                     .collect();"}, {"sha": "703f6ef8dc41e91fcc74c4e3ff8256f477d37dc1", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -467,25 +467,8 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                                     }\n                                 }\n \n-                                Res::Def(DefKind::Static, id) => {\n-                                    ty = cx.tcx.static_ptr_ty(id);\n-                                    let ptr = cx.tcx.create_static_alloc(id);\n-                                    InlineAsmOperand::SymStatic {\n-                                        expr: Expr {\n-                                            ty,\n-                                            temp_lifetime,\n-                                            span: expr.span,\n-                                            kind: ExprKind::StaticRef {\n-                                                literal: ty::Const::from_scalar(\n-                                                    cx.tcx,\n-                                                    Scalar::Ptr(ptr.into()),\n-                                                    ty,\n-                                                ),\n-                                                def_id: id,\n-                                            },\n-                                        }\n-                                        .to_ref(),\n-                                    }\n+                                Res::Def(DefKind::Static, def_id) => {\n+                                    InlineAsmOperand::SymStatic { def_id }\n                                 }\n \n                                 _ => {"}, {"sha": "ccff510f2d4e5ca7d49ca2087018394bbf93e669", "filename": "src/librustc_mir_build/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -377,7 +377,7 @@ crate enum InlineAsmOperand<'tcx> {\n         expr: ExprRef<'tcx>,\n     },\n     SymStatic {\n-        expr: ExprRef<'tcx>,\n+        def_id: DefId,\n     },\n }\n "}, {"sha": "0a70be1f152e9120bebb83a92f310b26e5261634", "filename": "src/librustc_span/def_id.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_span%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_span%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fdef_id.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -133,6 +133,8 @@ impl rustc_serialize::UseSpecializedDecodable for DefIndex {}\n \n /// A `DefId` identifies a particular *definition*, by combining a crate\n /// index and a def index.\n+///\n+/// You can create a `DefId` from a `LocalDefId` using `local_def_id.to_def_id()`.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n pub struct DefId {\n     pub krate: CrateNum,"}, {"sha": "96c0d98ab0618d7d19f71a9bc69277646d9f74cc", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -1377,7 +1377,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 }\n \n                 if let Some(expr) = expression {\n-                    fcx.emit_coerce_suggestions(&mut err, expr, found, expected);\n+                    fcx.emit_coerce_suggestions(&mut err, expr, found, expected, None);\n                 }\n \n                 // Error possibly reported in `check_assign` so avoid emitting error again."}, {"sha": "019b4ca66060c295c6b799e4e0e79dffc7790f37", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 79, "deletions": 30, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -24,10 +24,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         self.annotate_expected_due_to_let_ty(err, expr);\n         self.suggest_compatible_variants(err, expr, expected, expr_ty);\n-        self.suggest_deref_ref_or_into(err, expr, expected, expr_ty);\n+        self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr);\n         if self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty) {\n             return;\n         }\n@@ -102,9 +103,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n         allow_two_phase: AllowTwoPhase,\n     ) -> Ty<'tcx> {\n-        let (ty, err) = self.demand_coerce_diag(expr, checked_ty, expected, allow_two_phase);\n+        let (ty, err) =\n+            self.demand_coerce_diag(expr, checked_ty, expected, expected_ty_expr, allow_two_phase);\n         if let Some(mut err) = err {\n             err.emit();\n         }\n@@ -121,6 +124,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n         allow_two_phase: AllowTwoPhase,\n     ) -> (Ty<'tcx>, Option<DiagnosticBuilder<'tcx>>) {\n         let expected = self.resolve_vars_with_obligations(expected);\n@@ -141,7 +145,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return (expected, None);\n         }\n \n-        self.emit_coerce_suggestions(&mut err, expr, expr_ty, expected);\n+        self.emit_coerce_suggestions(&mut err, expr, expr_ty, expected, expected_ty_expr);\n \n         (expected, Some(err))\n     }\n@@ -671,6 +675,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> bool {\n         if self.tcx.sess.source_map().is_imported(expr.span) {\n             // Ignore if span is from within a macro.\n@@ -747,7 +752,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let msg = format!(\"you can convert an `{}` to `{}`\", checked_ty, expected_ty);\n         let cast_msg = format!(\"you can cast an `{} to `{}`\", checked_ty, expected_ty);\n-        let try_msg = format!(\"{} and panic if the converted value wouldn't fit\", msg);\n         let lit_msg = format!(\n             \"change the type of the numeric literal from `{}` to `{}`\",\n             checked_ty, expected_ty,\n@@ -761,7 +765,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n \n         let cast_suggestion = format!(\"{}{} as {}\", prefix, with_opt_paren(&src), expected_ty);\n-        let try_into_suggestion = format!(\"{}{}.try_into().unwrap()\", prefix, with_opt_paren(&src));\n         let into_suggestion = format!(\"{}{}.into()\", prefix, with_opt_paren(&src));\n         let suffix_suggestion = with_opt_paren(&format_args!(\n             \"{}{}\",\n@@ -782,22 +785,55 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let in_const_context = self.tcx.hir().is_inside_const_context(expr.hir_id);\n+\n+        let suggest_fallible_into_or_lhs_from =\n+            |err: &mut DiagnosticBuilder<'_>, exp_to_found_is_fallible: bool| {\n+                // If we know the expression the expected type is derived from, we might be able\n+                // to suggest a widening conversion rather than a narrowing one (which may\n+                // panic). For example, given x: u8 and y: u32, if we know the span of \"x\",\n+                //   x > y\n+                // can be given the suggestion \"u32::from(x) > y\" rather than\n+                // \"x > y.try_into().unwrap()\".\n+                let lhs_expr_and_src = expected_ty_expr.and_then(|expr| {\n+                    match self.tcx.sess.source_map().span_to_snippet(expr.span).ok() {\n+                        Some(src) => Some((expr, src)),\n+                        None => None,\n+                    }\n+                });\n+                let (span, msg, suggestion) = if let (Some((lhs_expr, lhs_src)), false) =\n+                    (lhs_expr_and_src, exp_to_found_is_fallible)\n+                {\n+                    let msg = format!(\n+                        \"you can convert `{}` from `{}` to `{}`, matching the type of `{}`\",\n+                        lhs_src, expected_ty, checked_ty, src\n+                    );\n+                    let suggestion = format!(\"{}::from({})\", checked_ty, lhs_src,);\n+                    (lhs_expr.span, msg, suggestion)\n+                } else {\n+                    let msg = format!(\"{} and panic if the converted value wouldn't fit\", msg);\n+                    let suggestion =\n+                        format!(\"{}{}.try_into().unwrap()\", prefix, with_opt_paren(&src));\n+                    (expr.span, msg, suggestion)\n+                };\n+                err.span_suggestion(span, &msg, suggestion, Applicability::MachineApplicable);\n+            };\n+\n         let suggest_to_change_suffix_or_into =\n-            |err: &mut DiagnosticBuilder<'_>, is_fallible: bool| {\n+            |err: &mut DiagnosticBuilder<'_>,\n+             found_to_exp_is_fallible: bool,\n+             exp_to_found_is_fallible: bool| {\n                 let msg = if literal_is_ty_suffixed(expr) {\n                     &lit_msg\n                 } else if in_const_context {\n                     // Do not recommend `into` or `try_into` in const contexts.\n                     return;\n-                } else if is_fallible {\n-                    &try_msg\n+                } else if found_to_exp_is_fallible {\n+                    return suggest_fallible_into_or_lhs_from(err, exp_to_found_is_fallible);\n                 } else {\n                     &msg\n                 };\n                 let suggestion = if literal_is_ty_suffixed(expr) {\n                     suffix_suggestion.clone()\n-                } else if is_fallible {\n-                    try_into_suggestion\n                 } else {\n                     into_suggestion.clone()\n                 };\n@@ -806,41 +842,54 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         match (&expected_ty.kind, &checked_ty.kind) {\n             (&ty::Int(ref exp), &ty::Int(ref found)) => {\n-                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                    (Some(exp), Some(found)) if exp < found => true,\n-                    (None, Some(8 | 16)) => false,\n-                    (None, _) | (_, None) => true,\n-                    _ => false,\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if exp < found => (true, false),\n+                    (Some(exp), Some(found)) if exp > found => (false, true),\n+                    (None, Some(8 | 16)) => (false, true),\n+                    (Some(8 | 16), None) => (true, false),\n+                    (None, _) | (_, None) => (true, true),\n+                    _ => (false, false),\n                 };\n-                suggest_to_change_suffix_or_into(err, is_fallible);\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n             (&ty::Uint(ref exp), &ty::Uint(ref found)) => {\n-                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                    (Some(exp), Some(found)) if exp < found => true,\n-                    (None, Some(8 | 16)) => false,\n-                    (None, _) | (_, None) => true,\n-                    _ => false,\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if exp < found => (true, false),\n+                    (Some(exp), Some(found)) if exp > found => (false, true),\n+                    (None, Some(8 | 16)) => (false, true),\n+                    (Some(8 | 16), None) => (true, false),\n+                    (None, _) | (_, None) => (true, true),\n+                    _ => (false, false),\n                 };\n-                suggest_to_change_suffix_or_into(err, is_fallible);\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n             (&ty::Int(exp), &ty::Uint(found)) => {\n-                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                    (Some(exp), Some(found)) if found < exp => false,\n-                    (None, Some(8)) => false,\n-                    _ => true,\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if found < exp => (false, true),\n+                    (None, Some(8)) => (false, true),\n+                    _ => (true, true),\n                 };\n-                suggest_to_change_suffix_or_into(err, is_fallible);\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n-            (&ty::Uint(_), &ty::Int(_)) => {\n-                suggest_to_change_suffix_or_into(err, true);\n+            (&ty::Uint(exp), &ty::Int(found)) => {\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if found > exp => (true, false),\n+                    (Some(8), None) => (true, false),\n+                    _ => (true, true),\n+                };\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n             (&ty::Float(ref exp), &ty::Float(ref found)) => {\n                 if found.bit_width() < exp.bit_width() {\n-                    suggest_to_change_suffix_or_into(err, false);\n+                    suggest_to_change_suffix_or_into(err, false, true);\n                 } else if literal_is_ty_suffixed(expr) {\n                     err.span_suggestion(\n                         expr.span,"}, {"sha": "bc3ef73d851ebcdc0258c517ea26f86de9ddda98", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n             let expr = expr.peel_drop_temps();\n-            self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty);\n+            self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty, None);\n             extend_err(&mut err);\n             // Error possibly reported in `check_assign` so avoid emitting error again.\n             err.emit_unless(self.is_assign_to_bool(expr, expected_ty));\n@@ -98,10 +98,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> Ty<'tcx> {\n         let ty = self.check_expr_with_hint(expr, expected);\n         // checks don't need two phase\n-        self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n+        self.demand_coerce(expr, ty, expected, expected_ty_expr, AllowTwoPhase::No)\n     }\n \n     pub(super) fn check_expr_with_hint(\n@@ -776,7 +777,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: &Span,\n     ) -> Ty<'tcx> {\n         let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n-        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n+        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty, Some(lhs));\n \n         let expected_ty = expected.coercion_target_type(self, expr.span);\n         if expected_ty == self.tcx.types.bool {\n@@ -1026,7 +1027,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (element_ty, t) = match uty {\n             Some(uty) => {\n-                self.check_expr_coercable_to_type(&element, uty);\n+                self.check_expr_coercable_to_type(&element, uty, None);\n                 (uty, uty)\n             }\n             None => {\n@@ -1063,7 +1064,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| match flds {\n             Some(ref fs) if i < fs.len() => {\n                 let ety = fs[i].expect_ty();\n-                self.check_expr_coercable_to_type(&e, ety);\n+                self.check_expr_coercable_to_type(&e, ety, None);\n                 ety\n             }\n             _ => self.check_expr_with_expectation(&e, NoExpectation),\n@@ -1237,7 +1238,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Make sure to give a type to the field even if there's\n             // an error, so we can continue type-checking.\n-            self.check_expr_coercable_to_type(&field.expr, field_type);\n+            self.check_expr_coercable_to_type(&field.expr, field_type, None);\n         }\n \n         // Make sure the programmer specified correct number of fields.\n@@ -1735,7 +1736,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n                 Some((index_ty, element_ty)) => {\n                     // two-phase not needed because index_ty is never mutable\n-                    self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n+                    self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);\n                     element_ty\n                 }\n                 None => {\n@@ -1788,7 +1789,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         match self.resume_yield_tys {\n             Some((resume_ty, yield_ty)) => {\n-                self.check_expr_coercable_to_type(&value, yield_ty);\n+                self.check_expr_coercable_to_type(&value, yield_ty, None);\n \n                 resume_ty\n             }\n@@ -1797,7 +1798,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // information. Hence, we check the source of the yield expression here and check its\n             // value's type against `()` (this check should always hold).\n             None if src.is_await() => {\n-                self.check_expr_coercable_to_type(&value, self.tcx.mk_unit());\n+                self.check_expr_coercable_to_type(&value, self.tcx.mk_unit(), None);\n                 self.tcx.mk_unit()\n             }\n             _ => {\n@@ -1836,11 +1837,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match ty.kind {\n                 ty::FnDef(..) => {\n                     let fnptr_ty = self.tcx.mk_fn_ptr(ty.fn_sig(self.tcx));\n-                    self.demand_coerce(expr, ty, fnptr_ty, AllowTwoPhase::No);\n+                    self.demand_coerce(expr, ty, fnptr_ty, None, AllowTwoPhase::No);\n                 }\n                 ty::Ref(_, base_ty, mutbl) => {\n                     let ptr_ty = self.tcx.mk_ptr(ty::TypeAndMut { ty: base_ty, mutbl });\n-                    self.demand_coerce(expr, ty, ptr_ty, AllowTwoPhase::No);\n+                    self.demand_coerce(expr, ty, ptr_ty, None, AllowTwoPhase::No);\n                 }\n                 _ => {}\n             }"}, {"sha": "fabedc3800ae45c399bc2af3dc454a9a0ae54c05", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -1046,7 +1046,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n             // Gather locals in statics (because of block expressions).\n             GatherLocalsVisitor { fcx: &fcx, parent_id: id }.visit_body(body);\n \n-            fcx.check_expr_coercable_to_type(&body.value, revealed_ty);\n+            fcx.check_expr_coercable_to_type(&body.value, revealed_ty, None);\n \n             fcx.write_ty(id, revealed_ty);\n \n@@ -4123,7 +4123,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let coerce_ty = expected.only_has_type(self).unwrap_or(formal_ty);\n                 // We're processing function arguments so we definitely want to use\n                 // two-phase borrows.\n-                self.demand_coerce(&arg, checked_ty, coerce_ty, AllowTwoPhase::Yes);\n+                self.demand_coerce(&arg, checked_ty, coerce_ty, None, AllowTwoPhase::Yes);\n                 final_arg_types.push((i, checked_ty, coerce_ty));\n \n                 // 3. Relate the expected type and the formal one,\n@@ -4541,7 +4541,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.demand_eqtype(init.span, local_ty, init_ty);\n             init_ty\n         } else {\n-            self.check_expr_coercable_to_type(init, local_ty)\n+            self.check_expr_coercable_to_type(init, local_ty, None)\n         }\n     }\n \n@@ -5027,6 +5027,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         if let Some((sp, msg, suggestion, applicability)) = self.check_ref(expr, found, expected) {\n             err.span_suggestion(sp, msg, suggestion, applicability);\n@@ -5037,7 +5038,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let sp = self.sess().source_map().guess_head_span(sp);\n                 err.span_label(sp, &format!(\"{} defined here\", found));\n             }\n-        } else if !self.check_for_cast(err, expr, found, expected) {\n+        } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n             let is_struct_pat_shorthand_field =\n                 self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, expr.span);\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);"}, {"sha": "a3a27dc138be96f11605c2b3d898905673bc3160", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -57,9 +57,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n                 // && and || are a simple case.\n-                self.check_expr_coercable_to_type(lhs_expr, tcx.types.bool);\n+                self.check_expr_coercable_to_type(lhs_expr, tcx.types.bool, None);\n                 let lhs_diverges = self.diverges.get();\n-                self.check_expr_coercable_to_type(rhs_expr, tcx.types.bool);\n+                self.check_expr_coercable_to_type(rhs_expr, tcx.types.bool, None);\n \n                 // Depending on the LHS' value, the RHS can never execute.\n                 self.diverges.set(lhs_diverges);\n@@ -170,7 +170,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: lhs_expr.span,\n                 });\n-                self.demand_coerce(lhs_expr, lhs_ty, fresh_var, AllowTwoPhase::No)\n+                self.demand_coerce(lhs_expr, lhs_ty, fresh_var, Some(rhs_expr), AllowTwoPhase::No)\n             }\n             IsAssign::Yes => {\n                 // rust-lang/rust#52126: We have to use strict\n@@ -196,7 +196,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let result = self.lookup_op_method(lhs_ty, &[rhs_ty_var], Op::Binary(op, is_assign));\n \n         // see `NB` above\n-        let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n+        let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var, Some(lhs_expr));\n         let rhs_ty = self.resolve_vars_with_obligations(rhs_ty);\n \n         let return_ty = match result {"}, {"sha": "f6f16f686e55781048b787e555b30519e4a52402", "filename": "src/libunwind/build.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibunwind%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Flibunwind%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Fbuild.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -36,12 +36,6 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=gcc_pic\");\n     } else if target.contains(\"pc-windows-gnu\") {\n         // This is handled in the target spec with late_link_args_[static|dynamic]\n-\n-        // cfg!(bootstrap) doesn't work in build scripts\n-        if env::var(\"RUSTC_STAGE\").ok() == Some(\"0\".to_string()) {\n-            println!(\"cargo:rustc-link-lib=static-nobundle=gcc_eh\");\n-            println!(\"cargo:rustc-link-lib=static-nobundle=pthread\");\n-        }\n     } else if target.contains(\"uwp-windows-gnu\") {\n         println!(\"cargo:rustc-link-lib=unwind\");\n     } else if target.contains(\"fuchsia\") {"}, {"sha": "8cff16aa75f695a76479b8185bd3cdf282524ce4", "filename": "src/test/ui/asm/sym.rs", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Ftest%2Fui%2Fasm%2Fsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Ftest%2Fui%2Fasm%2Fsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fsym.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -1,8 +1,9 @@\n // no-system-llvm\n // only-x86_64\n+// only-linux\n // run-pass\n \n-#![feature(asm, track_caller)]\n+#![feature(asm, track_caller, thread_local)]\n \n extern \"C\" fn f1() -> i32 {\n     111\n@@ -15,9 +16,9 @@ fn f2() -> i32 {\n }\n \n macro_rules! call {\n-    ($func:path) => {{\n-        let result: i32;\n+    ($func:path) => {\n         unsafe {\n+            let result: i32;\n             asm!(\"call {}\", sym $func,\n                 out(\"rax\") result,\n                 out(\"rcx\") _, out(\"rdx\") _, out(\"rdi\") _, out(\"rsi\") _,\n@@ -27,12 +28,53 @@ macro_rules! call {\n                 out(\"xmm8\") _, out(\"xmm9\") _, out(\"xmm10\") _, out(\"xmm11\") _,\n                 out(\"xmm12\") _, out(\"xmm13\") _, out(\"xmm14\") _, out(\"xmm15\") _,\n             );\n+            result\n         }\n-        result\n-    }}\n+    }\n }\n \n+macro_rules! static_addr {\n+    ($s:expr) => {\n+        unsafe {\n+            let result: *const u32;\n+            // LEA performs a RIP-relative address calculation and returns the address\n+            asm!(\"lea {}, [rip + {}]\", out(reg) result, sym $s);\n+            result\n+        }\n+    }\n+}\n+macro_rules! static_tls_addr {\n+    ($s:expr) => {\n+        unsafe {\n+            let result: *const u32;\n+            asm!(\n+                \"\n+                    # Load TLS base address\n+                    mov {out}, qword ptr fs:[0]\n+                    # Calculate the address of sym in the TLS block. The @tpoff\n+                    # relocation gives the offset of the symbol from the start\n+                    # of the TLS block.\n+                    lea {out}, [{out} + {sym}@tpoff]\n+                \",\n+                out = out(reg) result,\n+                sym = sym $s\n+            );\n+            result\n+        }\n+    }\n+}\n+\n+static S1: u32 = 111;\n+#[thread_local]\n+static S2: u32 = 222;\n+\n fn main() {\n     assert_eq!(call!(f1), 111);\n     assert_eq!(call!(f2), 222);\n+    assert_eq!(static_addr!(S1), &S1 as *const u32);\n+    assert_eq!(static_tls_addr!(S2), &S2 as *const u32);\n+    std::thread::spawn(|| {\n+        assert_eq!(static_addr!(S1), &S1 as *const u32);\n+        assert_eq!(static_tls_addr!(S2), &S2 as *const u32);\n+    });\n }"}, {"sha": "2b7f5694f02069b12a51cf0ecdf512ef5ee13a6a", "filename": "src/test/ui/ffi_returns_twice.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Ftest%2Fui%2Fffi_returns_twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Ftest%2Fui%2Fffi_returns_twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fffi_returns_twice.stderr?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -6,3 +6,4 @@ LL | #[ffi_returns_twice]\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0724`."}, {"sha": "edb085e71d324305230daea52c5e346abf44bdfa", "filename": "src/test/ui/numeric/numeric-cast-binop.fixed", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.fixed?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -0,0 +1,320 @@\n+// run-rustfix\n+\n+// The `try_into` suggestion doesn't include this, but we do suggest it after applying it\n+use std::convert::TryInto;\n+\n+#[allow(unused_must_use)]\n+fn main() {\n+    let x_usize: usize = 1;\n+    let x_u128: u128 = 2;\n+    let x_u64: u64 = 3;\n+    let x_u32: u32 = 4;\n+    let x_u16: u16 = 5;\n+    let x_u8: u8 = 6;\n+    let x_isize: isize = 7;\n+    let x_i64: i64 = 8;\n+    let x_i32: i32 = 9;\n+    let x_i16: i16 = 10;\n+    let x_i8: i8 = 11;\n+    let x_i128: i128 = 12;\n+\n+    /* u<->u */\n+    {\n+        u16::from(x_u8) > x_u16;\n+        //~^ ERROR mismatched types\n+        u32::from(x_u8) > x_u32;\n+        //~^ ERROR mismatched types\n+        u64::from(x_u8) > x_u64;\n+        //~^ ERROR mismatched types\n+        u128::from(x_u8) > x_u128;\n+        //~^ ERROR mismatched types\n+        usize::from(x_u8) > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u16 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        u32::from(x_u16) > x_u32;\n+        //~^ ERROR mismatched types\n+        u64::from(x_u16) > x_u64;\n+        //~^ ERROR mismatched types\n+        u128::from(x_u16) > x_u128;\n+        //~^ ERROR mismatched types\n+        usize::from(x_u16) > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u32 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_u32 > x_u16.into();\n+        //~^ ERROR mismatched types\n+        u64::from(x_u32) > x_u64;\n+        //~^ ERROR mismatched types\n+        u128::from(x_u32) > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_u64 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_u64 > x_u16.into();\n+        //~^ ERROR mismatched types\n+        x_u64 > x_u32.into();\n+        //~^ ERROR mismatched types\n+        u128::from(x_u64) > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_u128 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u16.into();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u32.into();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u64.into();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_usize > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_usize > x_u16.into();\n+        //~^ ERROR mismatched types\n+        x_usize > x_u32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_usize > x_u64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_usize > x_u128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* i<->i */\n+    {\n+        i16::from(x_i8) > x_i16;\n+        //~^ ERROR mismatched types\n+        i32::from(x_i8) > x_i32;\n+        //~^ ERROR mismatched types\n+        i64::from(x_i8) > x_i64;\n+        //~^ ERROR mismatched types\n+        i128::from(x_i8) > x_i128;\n+        //~^ ERROR mismatched types\n+        isize::from(x_i8) > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i16 > x_i8.into();\n+        //~^ ERROR mismatched types\n+        i32::from(x_i16) > x_i32;\n+        //~^ ERROR mismatched types\n+        i64::from(x_i16) > x_i64;\n+        //~^ ERROR mismatched types\n+        i128::from(x_i16) > x_i128;\n+        //~^ ERROR mismatched types\n+        isize::from(x_i16) > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i32 > x_i8.into();\n+        //~^ ERROR mismatched types\n+        x_i32 > x_i16.into();\n+        //~^ ERROR mismatched types\n+        i64::from(x_i32) > x_i64;\n+        //~^ ERROR mismatched types\n+        i128::from(x_i32) > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_i64 > x_i8.into();\n+        //~^ ERROR mismatched types\n+        x_i64 > x_i16.into();\n+        //~^ ERROR mismatched types\n+        x_i64 > x_i32.into();\n+        //~^ ERROR mismatched types\n+        i128::from(x_i64) > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_i128 > x_i8.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i16.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i32.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i64.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_isize > x_i8.into();\n+        //~^ ERROR mismatched types\n+        x_isize > x_i16.into();\n+        //~^ ERROR mismatched types\n+        x_isize > x_i32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_isize > x_i64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_isize > x_i128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* u<->i */\n+    {\n+        x_u8 > x_i8.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        i16::from(x_u8) > x_i16;\n+        //~^ ERROR mismatched types\n+        i32::from(x_u8) > x_i32;\n+        //~^ ERROR mismatched types\n+        i64::from(x_u8) > x_i64;\n+        //~^ ERROR mismatched types\n+        i128::from(x_u8) > x_i128;\n+        //~^ ERROR mismatched types\n+        isize::from(x_u8) > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_u16 > x_i8.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u16 > x_i16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        i32::from(x_u16) > x_i32;\n+        //~^ ERROR mismatched types\n+        i64::from(x_u16) > x_i64;\n+        //~^ ERROR mismatched types\n+        i128::from(x_u16) > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_u32 > x_i8.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        i64::from(x_u32) > x_i64;\n+        //~^ ERROR mismatched types\n+        i128::from(x_u32) > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_u64 > x_i8.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        i128::from(x_u64) > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_u128 > x_i8.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_usize > x_i8.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_usize > x_i16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_usize > x_i32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_usize > x_i64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_usize > x_i128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_usize > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* i<->u */\n+    {\n+        x_i8 > x_u8.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i8 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_i16 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i16 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_i32 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u16.into();\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i32 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_i64 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u16.into();\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u32.into();\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i64 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_i128 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u16.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u32.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u64.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_isize > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_isize > x_u16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_isize > x_u32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_isize > x_u64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_isize > x_u128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_isize > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+    }\n+}"}, {"sha": "c1ed8de8ad8c3ed03a0635e7f65936597b5e07c8", "filename": "src/test/ui/numeric/numeric-cast-binop.rs", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.rs?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -0,0 +1,320 @@\n+// run-rustfix\n+\n+// The `try_into` suggestion doesn't include this, but we do suggest it after applying it\n+use std::convert::TryInto;\n+\n+#[allow(unused_must_use)]\n+fn main() {\n+    let x_usize: usize = 1;\n+    let x_u128: u128 = 2;\n+    let x_u64: u64 = 3;\n+    let x_u32: u32 = 4;\n+    let x_u16: u16 = 5;\n+    let x_u8: u8 = 6;\n+    let x_isize: isize = 7;\n+    let x_i64: i64 = 8;\n+    let x_i32: i32 = 9;\n+    let x_i16: i16 = 10;\n+    let x_i8: i8 = 11;\n+    let x_i128: i128 = 12;\n+\n+    /* u<->u */\n+    {\n+        x_u8 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u16 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u32 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u64 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u128 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_usize > x_u8;\n+        //~^ ERROR mismatched types\n+        x_usize > x_u16;\n+        //~^ ERROR mismatched types\n+        x_usize > x_u32;\n+        //~^ ERROR mismatched types\n+        x_usize > x_u64;\n+        //~^ ERROR mismatched types\n+        x_usize > x_u128;\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* i<->i */\n+    {\n+        x_i8 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i16 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i32 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i64 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i128 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_isize > x_i8;\n+        //~^ ERROR mismatched types\n+        x_isize > x_i16;\n+        //~^ ERROR mismatched types\n+        x_isize > x_i32;\n+        //~^ ERROR mismatched types\n+        x_isize > x_i64;\n+        //~^ ERROR mismatched types\n+        x_isize > x_i128;\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* u<->i */\n+    {\n+        x_u8 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_u16 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_u32 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_u64 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_u128 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_usize > x_i8;\n+        //~^ ERROR mismatched types\n+        x_usize > x_i16;\n+        //~^ ERROR mismatched types\n+        x_usize > x_i32;\n+        //~^ ERROR mismatched types\n+        x_usize > x_i64;\n+        //~^ ERROR mismatched types\n+        x_usize > x_i128;\n+        //~^ ERROR mismatched types\n+        x_usize > x_isize;\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* i<->u */\n+    {\n+        x_i8 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_i16 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_i32 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_i64 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_i128 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_isize > x_u8;\n+        //~^ ERROR mismatched types\n+        x_isize > x_u16;\n+        //~^ ERROR mismatched types\n+        x_isize > x_u32;\n+        //~^ ERROR mismatched types\n+        x_isize > x_u64;\n+        //~^ ERROR mismatched types\n+        x_isize > x_u128;\n+        //~^ ERROR mismatched types\n+        x_isize > x_usize;\n+        //~^ ERROR mismatched types\n+    }\n+}"}, {"sha": "47be817b78908909c17746a94310c5151da79688", "filename": "src/test/ui/numeric/numeric-cast-binop.stderr", "status": "added", "additions": 1385, "deletions": 0, "changes": 1385, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.stderr?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -0,0 +1,1385 @@\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:23:16\n+   |\n+LL |         x_u8 > x_u16;\n+   |                ^^^^^ expected `u8`, found `u16`\n+   |\n+help: you can convert `x_u8` from `u8` to `u16`, matching the type of `x_u16`\n+   |\n+LL |         u16::from(x_u8) > x_u16;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:25:16\n+   |\n+LL |         x_u8 > x_u32;\n+   |                ^^^^^ expected `u8`, found `u32`\n+   |\n+help: you can convert `x_u8` from `u8` to `u32`, matching the type of `x_u32`\n+   |\n+LL |         u32::from(x_u8) > x_u32;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:27:16\n+   |\n+LL |         x_u8 > x_u64;\n+   |                ^^^^^ expected `u8`, found `u64`\n+   |\n+help: you can convert `x_u8` from `u8` to `u64`, matching the type of `x_u64`\n+   |\n+LL |         u64::from(x_u8) > x_u64;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:29:16\n+   |\n+LL |         x_u8 > x_u128;\n+   |                ^^^^^^ expected `u8`, found `u128`\n+   |\n+help: you can convert `x_u8` from `u8` to `u128`, matching the type of `x_u128`\n+   |\n+LL |         u128::from(x_u8) > x_u128;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:31:16\n+   |\n+LL |         x_u8 > x_usize;\n+   |                ^^^^^^^ expected `u8`, found `usize`\n+   |\n+help: you can convert `x_u8` from `u8` to `usize`, matching the type of `x_usize`\n+   |\n+LL |         usize::from(x_u8) > x_usize;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:34:17\n+   |\n+LL |         x_u16 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `u16`, found `u8`\n+   |                 help: you can convert an `u8` to `u16`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:36:17\n+   |\n+LL |         x_u16 > x_u32;\n+   |                 ^^^^^ expected `u16`, found `u32`\n+   |\n+help: you can convert `x_u16` from `u16` to `u32`, matching the type of `x_u32`\n+   |\n+LL |         u32::from(x_u16) > x_u32;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:38:17\n+   |\n+LL |         x_u16 > x_u64;\n+   |                 ^^^^^ expected `u16`, found `u64`\n+   |\n+help: you can convert `x_u16` from `u16` to `u64`, matching the type of `x_u64`\n+   |\n+LL |         u64::from(x_u16) > x_u64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:40:17\n+   |\n+LL |         x_u16 > x_u128;\n+   |                 ^^^^^^ expected `u16`, found `u128`\n+   |\n+help: you can convert `x_u16` from `u16` to `u128`, matching the type of `x_u128`\n+   |\n+LL |         u128::from(x_u16) > x_u128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:42:17\n+   |\n+LL |         x_u16 > x_usize;\n+   |                 ^^^^^^^ expected `u16`, found `usize`\n+   |\n+help: you can convert `x_u16` from `u16` to `usize`, matching the type of `x_usize`\n+   |\n+LL |         usize::from(x_u16) > x_usize;\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:45:17\n+   |\n+LL |         x_u32 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `u32`, found `u8`\n+   |                 help: you can convert an `u8` to `u32`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:47:17\n+   |\n+LL |         x_u32 > x_u16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `u32`, found `u16`\n+   |                 help: you can convert an `u16` to `u32`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:49:17\n+   |\n+LL |         x_u32 > x_u64;\n+   |                 ^^^^^ expected `u32`, found `u64`\n+   |\n+help: you can convert `x_u32` from `u32` to `u64`, matching the type of `x_u64`\n+   |\n+LL |         u64::from(x_u32) > x_u64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:51:17\n+   |\n+LL |         x_u32 > x_u128;\n+   |                 ^^^^^^ expected `u32`, found `u128`\n+   |\n+help: you can convert `x_u32` from `u32` to `u128`, matching the type of `x_u128`\n+   |\n+LL |         u128::from(x_u32) > x_u128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:53:17\n+   |\n+LL |         x_u32 > x_usize;\n+   |                 ^^^^^^^ expected `u32`, found `usize`\n+   |\n+help: you can convert an `usize` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:56:17\n+   |\n+LL |         x_u64 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `u64`, found `u8`\n+   |                 help: you can convert an `u8` to `u64`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:58:17\n+   |\n+LL |         x_u64 > x_u16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `u64`, found `u16`\n+   |                 help: you can convert an `u16` to `u64`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:60:17\n+   |\n+LL |         x_u64 > x_u32;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `u64`, found `u32`\n+   |                 help: you can convert an `u32` to `u64`: `x_u32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:62:17\n+   |\n+LL |         x_u64 > x_u128;\n+   |                 ^^^^^^ expected `u64`, found `u128`\n+   |\n+help: you can convert `x_u64` from `u64` to `u128`, matching the type of `x_u128`\n+   |\n+LL |         u128::from(x_u64) > x_u128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:64:17\n+   |\n+LL |         x_u64 > x_usize;\n+   |                 ^^^^^^^ expected `u64`, found `usize`\n+   |\n+help: you can convert an `usize` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:67:18\n+   |\n+LL |         x_u128 > x_u8;\n+   |                  ^^^^\n+   |                  |\n+   |                  expected `u128`, found `u8`\n+   |                  help: you can convert an `u8` to `u128`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:69:18\n+   |\n+LL |         x_u128 > x_u16;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `u128`, found `u16`\n+   |                  help: you can convert an `u16` to `u128`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:71:18\n+   |\n+LL |         x_u128 > x_u32;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `u128`, found `u32`\n+   |                  help: you can convert an `u32` to `u128`: `x_u32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:73:18\n+   |\n+LL |         x_u128 > x_u64;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `u128`, found `u64`\n+   |                  help: you can convert an `u64` to `u128`: `x_u64.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:75:18\n+   |\n+LL |         x_u128 > x_usize;\n+   |                  ^^^^^^^ expected `u128`, found `usize`\n+   |\n+help: you can convert an `usize` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_usize.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:78:19\n+   |\n+LL |         x_usize > x_u8;\n+   |                   ^^^^\n+   |                   |\n+   |                   expected `usize`, found `u8`\n+   |                   help: you can convert an `u8` to `usize`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:80:19\n+   |\n+LL |         x_usize > x_u16;\n+   |                   ^^^^^\n+   |                   |\n+   |                   expected `usize`, found `u16`\n+   |                   help: you can convert an `u16` to `usize`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:82:19\n+   |\n+LL |         x_usize > x_u32;\n+   |                   ^^^^^ expected `usize`, found `u32`\n+   |\n+help: you can convert an `u32` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_u32.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:84:19\n+   |\n+LL |         x_usize > x_u64;\n+   |                   ^^^^^ expected `usize`, found `u64`\n+   |\n+help: you can convert an `u64` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_u64.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:86:19\n+   |\n+LL |         x_usize > x_u128;\n+   |                   ^^^^^^ expected `usize`, found `u128`\n+   |\n+help: you can convert an `u128` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_u128.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:92:16\n+   |\n+LL |         x_i8 > x_i16;\n+   |                ^^^^^ expected `i8`, found `i16`\n+   |\n+help: you can convert `x_i8` from `i8` to `i16`, matching the type of `x_i16`\n+   |\n+LL |         i16::from(x_i8) > x_i16;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:94:16\n+   |\n+LL |         x_i8 > x_i32;\n+   |                ^^^^^ expected `i8`, found `i32`\n+   |\n+help: you can convert `x_i8` from `i8` to `i32`, matching the type of `x_i32`\n+   |\n+LL |         i32::from(x_i8) > x_i32;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:96:16\n+   |\n+LL |         x_i8 > x_i64;\n+   |                ^^^^^ expected `i8`, found `i64`\n+   |\n+help: you can convert `x_i8` from `i8` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_i8) > x_i64;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:98:16\n+   |\n+LL |         x_i8 > x_i128;\n+   |                ^^^^^^ expected `i8`, found `i128`\n+   |\n+help: you can convert `x_i8` from `i8` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_i8) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:100:16\n+   |\n+LL |         x_i8 > x_isize;\n+   |                ^^^^^^^ expected `i8`, found `isize`\n+   |\n+help: you can convert `x_i8` from `i8` to `isize`, matching the type of `x_isize`\n+   |\n+LL |         isize::from(x_i8) > x_isize;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:103:17\n+   |\n+LL |         x_i16 > x_i8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i16`, found `i8`\n+   |                 help: you can convert an `i8` to `i16`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:105:17\n+   |\n+LL |         x_i16 > x_i32;\n+   |                 ^^^^^ expected `i16`, found `i32`\n+   |\n+help: you can convert `x_i16` from `i16` to `i32`, matching the type of `x_i32`\n+   |\n+LL |         i32::from(x_i16) > x_i32;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:107:17\n+   |\n+LL |         x_i16 > x_i64;\n+   |                 ^^^^^ expected `i16`, found `i64`\n+   |\n+help: you can convert `x_i16` from `i16` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_i16) > x_i64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:109:17\n+   |\n+LL |         x_i16 > x_i128;\n+   |                 ^^^^^^ expected `i16`, found `i128`\n+   |\n+help: you can convert `x_i16` from `i16` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_i16) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:111:17\n+   |\n+LL |         x_i16 > x_isize;\n+   |                 ^^^^^^^ expected `i16`, found `isize`\n+   |\n+help: you can convert `x_i16` from `i16` to `isize`, matching the type of `x_isize`\n+   |\n+LL |         isize::from(x_i16) > x_isize;\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:114:17\n+   |\n+LL |         x_i32 > x_i8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i32`, found `i8`\n+   |                 help: you can convert an `i8` to `i32`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:116:17\n+   |\n+LL |         x_i32 > x_i16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i32`, found `i16`\n+   |                 help: you can convert an `i16` to `i32`: `x_i16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:118:17\n+   |\n+LL |         x_i32 > x_i64;\n+   |                 ^^^^^ expected `i32`, found `i64`\n+   |\n+help: you can convert `x_i32` from `i32` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_i32) > x_i64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:120:17\n+   |\n+LL |         x_i32 > x_i128;\n+   |                 ^^^^^^ expected `i32`, found `i128`\n+   |\n+help: you can convert `x_i32` from `i32` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_i32) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:122:17\n+   |\n+LL |         x_i32 > x_isize;\n+   |                 ^^^^^^^ expected `i32`, found `isize`\n+   |\n+help: you can convert an `isize` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:125:17\n+   |\n+LL |         x_i64 > x_i8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i64`, found `i8`\n+   |                 help: you can convert an `i8` to `i64`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:127:17\n+   |\n+LL |         x_i64 > x_i16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i64`, found `i16`\n+   |                 help: you can convert an `i16` to `i64`: `x_i16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:129:17\n+   |\n+LL |         x_i64 > x_i32;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i64`, found `i32`\n+   |                 help: you can convert an `i32` to `i64`: `x_i32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:131:17\n+   |\n+LL |         x_i64 > x_i128;\n+   |                 ^^^^^^ expected `i64`, found `i128`\n+   |\n+help: you can convert `x_i64` from `i64` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_i64) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:133:17\n+   |\n+LL |         x_i64 > x_isize;\n+   |                 ^^^^^^^ expected `i64`, found `isize`\n+   |\n+help: you can convert an `isize` to `i64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i64 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:136:18\n+   |\n+LL |         x_i128 > x_i8;\n+   |                  ^^^^\n+   |                  |\n+   |                  expected `i128`, found `i8`\n+   |                  help: you can convert an `i8` to `i128`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:138:18\n+   |\n+LL |         x_i128 > x_i16;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `i16`\n+   |                  help: you can convert an `i16` to `i128`: `x_i16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:140:18\n+   |\n+LL |         x_i128 > x_i32;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `i32`\n+   |                  help: you can convert an `i32` to `i128`: `x_i32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:142:18\n+   |\n+LL |         x_i128 > x_i64;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `i64`\n+   |                  help: you can convert an `i64` to `i128`: `x_i64.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:144:18\n+   |\n+LL |         x_i128 > x_isize;\n+   |                  ^^^^^^^ expected `i128`, found `isize`\n+   |\n+help: you can convert an `isize` to `i128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i128 > x_isize.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:147:19\n+   |\n+LL |         x_isize > x_i8;\n+   |                   ^^^^\n+   |                   |\n+   |                   expected `isize`, found `i8`\n+   |                   help: you can convert an `i8` to `isize`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:149:19\n+   |\n+LL |         x_isize > x_i16;\n+   |                   ^^^^^\n+   |                   |\n+   |                   expected `isize`, found `i16`\n+   |                   help: you can convert an `i16` to `isize`: `x_i16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:151:19\n+   |\n+LL |         x_isize > x_i32;\n+   |                   ^^^^^ expected `isize`, found `i32`\n+   |\n+help: you can convert an `i32` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_i32.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:153:19\n+   |\n+LL |         x_isize > x_i64;\n+   |                   ^^^^^ expected `isize`, found `i64`\n+   |\n+help: you can convert an `i64` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_i64.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:155:19\n+   |\n+LL |         x_isize > x_i128;\n+   |                   ^^^^^^ expected `isize`, found `i128`\n+   |\n+help: you can convert an `i128` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_i128.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:161:16\n+   |\n+LL |         x_u8 > x_i8;\n+   |                ^^^^ expected `u8`, found `i8`\n+   |\n+help: you can convert an `i8` to `u8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u8 > x_i8.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:163:16\n+   |\n+LL |         x_u8 > x_i16;\n+   |                ^^^^^ expected `u8`, found `i16`\n+   |\n+help: you can convert `x_u8` from `u8` to `i16`, matching the type of `x_i16`\n+   |\n+LL |         i16::from(x_u8) > x_i16;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:165:16\n+   |\n+LL |         x_u8 > x_i32;\n+   |                ^^^^^ expected `u8`, found `i32`\n+   |\n+help: you can convert `x_u8` from `u8` to `i32`, matching the type of `x_i32`\n+   |\n+LL |         i32::from(x_u8) > x_i32;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:167:16\n+   |\n+LL |         x_u8 > x_i64;\n+   |                ^^^^^ expected `u8`, found `i64`\n+   |\n+help: you can convert `x_u8` from `u8` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_u8) > x_i64;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:169:16\n+   |\n+LL |         x_u8 > x_i128;\n+   |                ^^^^^^ expected `u8`, found `i128`\n+   |\n+help: you can convert `x_u8` from `u8` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_u8) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:171:16\n+   |\n+LL |         x_u8 > x_isize;\n+   |                ^^^^^^^ expected `u8`, found `isize`\n+   |\n+help: you can convert `x_u8` from `u8` to `isize`, matching the type of `x_isize`\n+   |\n+LL |         isize::from(x_u8) > x_isize;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:174:17\n+   |\n+LL |         x_u16 > x_i8;\n+   |                 ^^^^ expected `u16`, found `i8`\n+   |\n+help: you can convert an `i8` to `u16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u16 > x_i8.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:176:17\n+   |\n+LL |         x_u16 > x_i16;\n+   |                 ^^^^^ expected `u16`, found `i16`\n+   |\n+help: you can convert an `i16` to `u16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u16 > x_i16.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:178:17\n+   |\n+LL |         x_u16 > x_i32;\n+   |                 ^^^^^ expected `u16`, found `i32`\n+   |\n+help: you can convert `x_u16` from `u16` to `i32`, matching the type of `x_i32`\n+   |\n+LL |         i32::from(x_u16) > x_i32;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:180:17\n+   |\n+LL |         x_u16 > x_i64;\n+   |                 ^^^^^ expected `u16`, found `i64`\n+   |\n+help: you can convert `x_u16` from `u16` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_u16) > x_i64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:182:17\n+   |\n+LL |         x_u16 > x_i128;\n+   |                 ^^^^^^ expected `u16`, found `i128`\n+   |\n+help: you can convert `x_u16` from `u16` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_u16) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:184:17\n+   |\n+LL |         x_u16 > x_isize;\n+   |                 ^^^^^^^ expected `u16`, found `isize`\n+   |\n+help: you can convert an `isize` to `u16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u16 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:187:17\n+   |\n+LL |         x_u32 > x_i8;\n+   |                 ^^^^ expected `u32`, found `i8`\n+   |\n+help: you can convert an `i8` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_i8.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:189:17\n+   |\n+LL |         x_u32 > x_i16;\n+   |                 ^^^^^ expected `u32`, found `i16`\n+   |\n+help: you can convert an `i16` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_i16.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:191:17\n+   |\n+LL |         x_u32 > x_i32;\n+   |                 ^^^^^ expected `u32`, found `i32`\n+   |\n+help: you can convert an `i32` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_i32.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:193:17\n+   |\n+LL |         x_u32 > x_i64;\n+   |                 ^^^^^ expected `u32`, found `i64`\n+   |\n+help: you can convert `x_u32` from `u32` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_u32) > x_i64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:195:17\n+   |\n+LL |         x_u32 > x_i128;\n+   |                 ^^^^^^ expected `u32`, found `i128`\n+   |\n+help: you can convert `x_u32` from `u32` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_u32) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:197:17\n+   |\n+LL |         x_u32 > x_isize;\n+   |                 ^^^^^^^ expected `u32`, found `isize`\n+   |\n+help: you can convert an `isize` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:200:17\n+   |\n+LL |         x_u64 > x_i8;\n+   |                 ^^^^ expected `u64`, found `i8`\n+   |\n+help: you can convert an `i8` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_i8.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:202:17\n+   |\n+LL |         x_u64 > x_i16;\n+   |                 ^^^^^ expected `u64`, found `i16`\n+   |\n+help: you can convert an `i16` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_i16.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:204:17\n+   |\n+LL |         x_u64 > x_i32;\n+   |                 ^^^^^ expected `u64`, found `i32`\n+   |\n+help: you can convert an `i32` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_i32.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:206:17\n+   |\n+LL |         x_u64 > x_i64;\n+   |                 ^^^^^ expected `u64`, found `i64`\n+   |\n+help: you can convert an `i64` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_i64.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:208:17\n+   |\n+LL |         x_u64 > x_i128;\n+   |                 ^^^^^^ expected `u64`, found `i128`\n+   |\n+help: you can convert `x_u64` from `u64` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_u64) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:210:17\n+   |\n+LL |         x_u64 > x_isize;\n+   |                 ^^^^^^^ expected `u64`, found `isize`\n+   |\n+help: you can convert an `isize` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:213:18\n+   |\n+LL |         x_u128 > x_i8;\n+   |                  ^^^^ expected `u128`, found `i8`\n+   |\n+help: you can convert an `i8` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i8.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:215:18\n+   |\n+LL |         x_u128 > x_i16;\n+   |                  ^^^^^ expected `u128`, found `i16`\n+   |\n+help: you can convert an `i16` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i16.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:217:18\n+   |\n+LL |         x_u128 > x_i32;\n+   |                  ^^^^^ expected `u128`, found `i32`\n+   |\n+help: you can convert an `i32` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i32.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:219:18\n+   |\n+LL |         x_u128 > x_i64;\n+   |                  ^^^^^ expected `u128`, found `i64`\n+   |\n+help: you can convert an `i64` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i64.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:221:18\n+   |\n+LL |         x_u128 > x_i128;\n+   |                  ^^^^^^ expected `u128`, found `i128`\n+   |\n+help: you can convert an `i128` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i128.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:223:18\n+   |\n+LL |         x_u128 > x_isize;\n+   |                  ^^^^^^^ expected `u128`, found `isize`\n+   |\n+help: you can convert an `isize` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_isize.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:226:19\n+   |\n+LL |         x_usize > x_i8;\n+   |                   ^^^^ expected `usize`, found `i8`\n+   |\n+help: you can convert an `i8` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i8.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:228:19\n+   |\n+LL |         x_usize > x_i16;\n+   |                   ^^^^^ expected `usize`, found `i16`\n+   |\n+help: you can convert an `i16` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i16.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:230:19\n+   |\n+LL |         x_usize > x_i32;\n+   |                   ^^^^^ expected `usize`, found `i32`\n+   |\n+help: you can convert an `i32` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i32.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:232:19\n+   |\n+LL |         x_usize > x_i64;\n+   |                   ^^^^^ expected `usize`, found `i64`\n+   |\n+help: you can convert an `i64` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i64.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:234:19\n+   |\n+LL |         x_usize > x_i128;\n+   |                   ^^^^^^ expected `usize`, found `i128`\n+   |\n+help: you can convert an `i128` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i128.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:236:19\n+   |\n+LL |         x_usize > x_isize;\n+   |                   ^^^^^^^ expected `usize`, found `isize`\n+   |\n+help: you can convert an `isize` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_isize.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:242:16\n+   |\n+LL |         x_i8 > x_u8;\n+   |                ^^^^ expected `i8`, found `u8`\n+   |\n+help: you can convert an `u8` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u8.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:244:16\n+   |\n+LL |         x_i8 > x_u16;\n+   |                ^^^^^ expected `i8`, found `u16`\n+   |\n+help: you can convert an `u16` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u16.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:246:16\n+   |\n+LL |         x_i8 > x_u32;\n+   |                ^^^^^ expected `i8`, found `u32`\n+   |\n+help: you can convert an `u32` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u32.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:248:16\n+   |\n+LL |         x_i8 > x_u64;\n+   |                ^^^^^ expected `i8`, found `u64`\n+   |\n+help: you can convert an `u64` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u64.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:250:16\n+   |\n+LL |         x_i8 > x_u128;\n+   |                ^^^^^^ expected `i8`, found `u128`\n+   |\n+help: you can convert an `u128` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u128.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:252:16\n+   |\n+LL |         x_i8 > x_usize;\n+   |                ^^^^^^^ expected `i8`, found `usize`\n+   |\n+help: you can convert an `usize` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_usize.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:255:17\n+   |\n+LL |         x_i16 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i16`, found `u8`\n+   |                 help: you can convert an `u8` to `i16`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:257:17\n+   |\n+LL |         x_i16 > x_u16;\n+   |                 ^^^^^ expected `i16`, found `u16`\n+   |\n+help: you can convert an `u16` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_u16.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:259:17\n+   |\n+LL |         x_i16 > x_u32;\n+   |                 ^^^^^ expected `i16`, found `u32`\n+   |\n+help: you can convert an `u32` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_u32.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:261:17\n+   |\n+LL |         x_i16 > x_u64;\n+   |                 ^^^^^ expected `i16`, found `u64`\n+   |\n+help: you can convert an `u64` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_u64.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:263:17\n+   |\n+LL |         x_i16 > x_u128;\n+   |                 ^^^^^^ expected `i16`, found `u128`\n+   |\n+help: you can convert an `u128` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_u128.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:265:17\n+   |\n+LL |         x_i16 > x_usize;\n+   |                 ^^^^^^^ expected `i16`, found `usize`\n+   |\n+help: you can convert an `usize` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:268:17\n+   |\n+LL |         x_i32 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i32`, found `u8`\n+   |                 help: you can convert an `u8` to `i32`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:270:17\n+   |\n+LL |         x_i32 > x_u16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i32`, found `u16`\n+   |                 help: you can convert an `u16` to `i32`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:272:17\n+   |\n+LL |         x_i32 > x_u32;\n+   |                 ^^^^^ expected `i32`, found `u32`\n+   |\n+help: you can convert an `u32` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_u32.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:274:17\n+   |\n+LL |         x_i32 > x_u64;\n+   |                 ^^^^^ expected `i32`, found `u64`\n+   |\n+help: you can convert an `u64` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_u64.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:276:17\n+   |\n+LL |         x_i32 > x_u128;\n+   |                 ^^^^^^ expected `i32`, found `u128`\n+   |\n+help: you can convert an `u128` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_u128.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:278:17\n+   |\n+LL |         x_i32 > x_usize;\n+   |                 ^^^^^^^ expected `i32`, found `usize`\n+   |\n+help: you can convert an `usize` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:281:17\n+   |\n+LL |         x_i64 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i64`, found `u8`\n+   |                 help: you can convert an `u8` to `i64`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:283:17\n+   |\n+LL |         x_i64 > x_u16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i64`, found `u16`\n+   |                 help: you can convert an `u16` to `i64`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:285:17\n+   |\n+LL |         x_i64 > x_u32;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i64`, found `u32`\n+   |                 help: you can convert an `u32` to `i64`: `x_u32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:287:17\n+   |\n+LL |         x_i64 > x_u64;\n+   |                 ^^^^^ expected `i64`, found `u64`\n+   |\n+help: you can convert an `u64` to `i64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i64 > x_u64.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:289:17\n+   |\n+LL |         x_i64 > x_u128;\n+   |                 ^^^^^^ expected `i64`, found `u128`\n+   |\n+help: you can convert an `u128` to `i64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i64 > x_u128.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:291:17\n+   |\n+LL |         x_i64 > x_usize;\n+   |                 ^^^^^^^ expected `i64`, found `usize`\n+   |\n+help: you can convert an `usize` to `i64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i64 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:294:18\n+   |\n+LL |         x_i128 > x_u8;\n+   |                  ^^^^\n+   |                  |\n+   |                  expected `i128`, found `u8`\n+   |                  help: you can convert an `u8` to `i128`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:296:18\n+   |\n+LL |         x_i128 > x_u16;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `u16`\n+   |                  help: you can convert an `u16` to `i128`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:298:18\n+   |\n+LL |         x_i128 > x_u32;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `u32`\n+   |                  help: you can convert an `u32` to `i128`: `x_u32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:300:18\n+   |\n+LL |         x_i128 > x_u64;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `u64`\n+   |                  help: you can convert an `u64` to `i128`: `x_u64.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:302:18\n+   |\n+LL |         x_i128 > x_u128;\n+   |                  ^^^^^^ expected `i128`, found `u128`\n+   |\n+help: you can convert an `u128` to `i128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i128 > x_u128.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:304:18\n+   |\n+LL |         x_i128 > x_usize;\n+   |                  ^^^^^^^ expected `i128`, found `usize`\n+   |\n+help: you can convert an `usize` to `i128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i128 > x_usize.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:307:19\n+   |\n+LL |         x_isize > x_u8;\n+   |                   ^^^^\n+   |                   |\n+   |                   expected `isize`, found `u8`\n+   |                   help: you can convert an `u8` to `isize`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:309:19\n+   |\n+LL |         x_isize > x_u16;\n+   |                   ^^^^^ expected `isize`, found `u16`\n+   |\n+help: you can convert an `u16` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_u16.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:311:19\n+   |\n+LL |         x_isize > x_u32;\n+   |                   ^^^^^ expected `isize`, found `u32`\n+   |\n+help: you can convert an `u32` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_u32.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:313:19\n+   |\n+LL |         x_isize > x_u64;\n+   |                   ^^^^^ expected `isize`, found `u64`\n+   |\n+help: you can convert an `u64` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_u64.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:315:19\n+   |\n+LL |         x_isize > x_u128;\n+   |                   ^^^^^^ expected `isize`, found `u128`\n+   |\n+help: you can convert an `u128` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_u128.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:317:19\n+   |\n+LL |         x_isize > x_usize;\n+   |                   ^^^^^^^ expected `isize`, found `usize`\n+   |\n+help: you can convert an `usize` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_usize.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 132 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "0eae13b06b9cfdd4ef9b41e8f53016d2b26fa751", "filename": "triagebot.toml", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/14027f3e784de815de726a8fb0e74875781c9caf/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/14027f3e784de815de726a8fb0e74875781c9caf/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=14027f3e784de815de726a8fb0e74875781c9caf", "patch": "@@ -58,7 +58,9 @@ label = \"O-ARM\"\n \n [prioritize]\n label = \"I-prioritize\"\n-prioritize_on = [\n+\n+[autolabel.\"I-prioritize\"]\n+trigger_labels = [\n     \"regression-from-stable-to-stable\",\n     \"regression-from-stable-to-beta\",\n     \"regression-from-stable-to-nightly\",\n@@ -70,4 +72,46 @@ exclude_labels = [\n     \"T-release\",\n     \"requires-nightly\",\n ]\n-zulip_stream = 227806\n+\n+[notify-zulip.\"I-prioritize\"]\n+zulip_stream = 227806 # #t-compiler/wg-prioritization\n+topic = \"I-prioritize #{number} {title}\"\n+message_on_add = \"@**WG-prioritization** issue #{number} has been requested for prioritization.\"\n+message_on_remove = \"Issue #{number}'s prioritization request has been removed.\"\n+\n+[notify-zulip.\"I-nominated\"]\n+required_labels = [\"T-compiler\"]\n+zulip_stream = 227806 # #t-compiler/wg-prioritization\n+topic = \"I-prioritize #{number} {title}\"\n+message_on_add = \"@**WG-prioritization** #{number} has been nominated for discussion in `T-compiler` meeting.\"\n+message_on_remove = \"#{number}'s nomination has been removed.\"\n+\n+[notify-zulip.\"beta-nominated\"]\n+zulip_stream = 227806 # #t-compiler/wg-prioritization\n+topic = \"Backport #{number} {title}\"\n+message_on_add = \"@**WG-prioritization** PR #{number} has been requested for beta backport.\"\n+message_on_remove = \"PR #{number}'s beta backport request has been removed.\"\n+\n+[notify-zulip.\"stable-nominated\"]\n+zulip_stream = 227806 # #t-compiler/wg-prioritization\n+topic = \"Backport #{number} {title}\"\n+message_on_add = \"@**WG-prioritization** PR #{number} has been requested for stable backport.\"\n+message_on_remove = \"PR #{number}'s stable backport request has been removed.\"\n+\n+[notify-zulip.\"S-waiting-on-team\"]\n+required_labels = [\"T-compiler\"]\n+zulip_stream = 227806 # #t-compiler/wg-prioritization\n+topic = \"S-waiting-on-team #{number} {title}\"\n+message_on_add = \"@**WG-prioritization** PR #{number} is waiting on `T-compiler`.\"\n+message_on_remove = \"PR #{number}'s is no longer waiting on `T-compiler`.\"\n+\n+[notify-zulip.\"P-critical\"]\n+zulip_stream = 227806 # #t-compiler/wg-prioritization\n+topic = \"P-critical #{number} {title}\"\n+message_on_add = \"@**WG-prioritization** issue #{number} has been assigned `P-critical`.\"\n+\n+[notify-zulip.\"P-high\"]\n+required_labels = [\"regression-from-stable-to-*\"]\n+zulip_stream = 227806 # #t-compiler/wg-prioritization\n+topic = \"P-high regression #{number} {title}\"\n+message_on_add = \"@**WG-prioritization** issue #{number} has been assigned `P-high` and is a regression.\""}]}