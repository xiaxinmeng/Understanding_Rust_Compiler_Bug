{"sha": "2612bbcba08dd81730edd8f2139005fb7a409294", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MTJiYmNiYTA4ZGQ4MTczMGVkZDhmMjEzOTAwNWZiN2E0MDkyOTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-28T16:54:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-28T16:54:44Z"}, "message": "Auto merge of #50521 - gnzlbg:simd_float, r=alexcrichton\n\nAdd simd math intrinsics and gather/scatter\n\nThis PR adds simd math intrinsics for floating-point vectors (sqrt, sin, cos, pow, exp, log, fma, abs, etc.) and the generic simd gather/scatter intrinsics.", "tree": {"sha": "b7993112e875ff8b125bb9b263e440ac03fae9d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7993112e875ff8b125bb9b263e440ac03fae9d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2612bbcba08dd81730edd8f2139005fb7a409294", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2612bbcba08dd81730edd8f2139005fb7a409294", "html_url": "https://github.com/rust-lang/rust/commit/2612bbcba08dd81730edd8f2139005fb7a409294", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2612bbcba08dd81730edd8f2139005fb7a409294/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2c4d4e2f05b7fcca62eef7cf5ce83d51907a6ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2c4d4e2f05b7fcca62eef7cf5ce83d51907a6ec", "html_url": "https://github.com/rust-lang/rust/commit/a2c4d4e2f05b7fcca62eef7cf5ce83d51907a6ec"}, {"sha": "de60483e6dc8542ea8d1c0daaba45e17b986a13f", "url": "https://api.github.com/repos/rust-lang/rust/commits/de60483e6dc8542ea8d1c0daaba45e17b986a13f", "html_url": "https://github.com/rust-lang/rust/commit/de60483e6dc8542ea8d1c0daaba45e17b986a13f"}], "stats": {"total": 2294, "additions": 2289, "deletions": 5}, "files": [{"sha": "b774d7c5def217a9a17f5bc501bc8ef60cdb7d07", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -522,6 +522,15 @@ fn declare_intrinsic(cx: &CodegenCx, key: &str) -> Option<ValueRef> {\n     let t_f32 = Type::f32(cx);\n     let t_f64 = Type::f64(cx);\n \n+    let t_v2f32 = Type::vector(&t_f32, 2);\n+    let t_v4f32 = Type::vector(&t_f32, 4);\n+    let t_v8f32 = Type::vector(&t_f32, 8);\n+    let t_v16f32 = Type::vector(&t_f32, 16);\n+\n+    let t_v2f64 = Type::vector(&t_f64, 2);\n+    let t_v4f64 = Type::vector(&t_f64, 4);\n+    let t_v8f64 = Type::vector(&t_f64, 8);\n+\n     ifn!(\"llvm.memcpy.p0i8.p0i8.i16\", fn(i8p, i8p, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memcpy.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n     ifn!(\"llvm.memcpy.p0i8.p0i8.i64\", fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n@@ -537,37 +546,145 @@ fn declare_intrinsic(cx: &CodegenCx, key: &str) -> Option<ValueRef> {\n     ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);\n \n     ifn!(\"llvm.powi.f32\", fn(t_f32, t_i32) -> t_f32);\n+    ifn!(\"llvm.powi.v2f32\", fn(t_v2f32, t_i32) -> t_v2f32);\n+    ifn!(\"llvm.powi.v4f32\", fn(t_v4f32, t_i32) -> t_v4f32);\n+    ifn!(\"llvm.powi.v8f32\", fn(t_v8f32, t_i32) -> t_v8f32);\n+    ifn!(\"llvm.powi.v16f32\", fn(t_v16f32, t_i32) -> t_v16f32);\n     ifn!(\"llvm.powi.f64\", fn(t_f64, t_i32) -> t_f64);\n+    ifn!(\"llvm.powi.v2f64\", fn(t_v2f64, t_i32) -> t_v2f64);\n+    ifn!(\"llvm.powi.v4f64\", fn(t_v4f64, t_i32) -> t_v4f64);\n+    ifn!(\"llvm.powi.v8f64\", fn(t_v8f64, t_i32) -> t_v8f64);\n+\n     ifn!(\"llvm.pow.f32\", fn(t_f32, t_f32) -> t_f32);\n+    ifn!(\"llvm.pow.v2f32\", fn(t_v2f32, t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.pow.v4f32\", fn(t_v4f32, t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.pow.v8f32\", fn(t_v8f32, t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.pow.v16f32\", fn(t_v16f32, t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.pow.f64\", fn(t_f64, t_f64) -> t_f64);\n+    ifn!(\"llvm.pow.v2f64\", fn(t_v2f64, t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.pow.v4f64\", fn(t_v4f64, t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.pow.v8f64\", fn(t_v8f64, t_v8f64) -> t_v8f64);\n \n     ifn!(\"llvm.sqrt.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.sqrt.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.sqrt.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.sqrt.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.sqrt.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.sqrt.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.sqrt.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.sqrt.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.sqrt.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.sin.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.sin.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.sin.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.sin.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.sin.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.sin.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.sin.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.sin.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.sin.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.cos.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.cos.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.cos.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.cos.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.cos.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.cos.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.cos.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.cos.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.cos.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.exp.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.exp.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.exp.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.exp.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.exp.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.exp.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.exp.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.exp.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.exp.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.exp2.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.exp2.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.exp2.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.exp2.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.exp2.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.exp2.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.exp2.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.exp2.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.exp2.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.log.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.log.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.log.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.log.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.log.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.log.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.log.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.log10.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log10.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.log10.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.log10.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.log10.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.log10.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log10.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.log10.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.log10.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.log2.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log2.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.log2.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.log2.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.log2.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.log2.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log2.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.log2.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.log2.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n     ifn!(\"llvm.fma.f32\", fn(t_f32, t_f32, t_f32) -> t_f32);\n+    ifn!(\"llvm.fma.v2f32\", fn(t_v2f32, t_v2f32, t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.fma.v4f32\", fn(t_v4f32, t_v4f32, t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.fma.v8f32\", fn(t_v8f32, t_v8f32, t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.fma.v16f32\", fn(t_v16f32, t_v16f32, t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.fma.f64\", fn(t_f64, t_f64, t_f64) -> t_f64);\n+    ifn!(\"llvm.fma.v2f64\", fn(t_v2f64, t_v2f64, t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.fma.v4f64\", fn(t_v4f64, t_v4f64, t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.fma.v8f64\", fn(t_v8f64, t_v8f64, t_v8f64) -> t_v8f64);\n \n     ifn!(\"llvm.fabs.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.fabs.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.fabs.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.fabs.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.fabs.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.fabs.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.fabs.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.fabs.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.fabs.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n     ifn!(\"llvm.floor.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.floor.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.floor.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.floor.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.floor.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.floor.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.floor.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.floor.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.floor.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.ceil.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.ceil.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.ceil.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.ceil.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.ceil.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.ceil.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.ceil.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.ceil.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.ceil.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.trunc.f32\", fn(t_f32) -> t_f32);\n     ifn!(\"llvm.trunc.f64\", fn(t_f64) -> t_f64);\n "}, {"sha": "6bb5456f9034f7ee91d3c45b24a8e6055b322a46", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -1140,6 +1140,359 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n \n+    fn simd_simple_float_intrinsic<'a, 'tcx>(name: &str,\n+                                             in_elem: &::rustc::ty::TyS,\n+                                             in_ty: &::rustc::ty::TyS,\n+                                             in_len: usize,\n+                                             bx: &Builder<'a, 'tcx>,\n+                                             span: Span,\n+                                             args: &[OperandRef<'tcx>])\n+                                             -> Result<ValueRef, ()> {\n+        macro_rules! emit_error {\n+            ($msg: tt) => {\n+                emit_error!($msg, )\n+            };\n+            ($msg: tt, $($fmt: tt)*) => {\n+                span_invalid_monomorphization_error(\n+                    bx.sess(), span,\n+                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \",\n+                                     $msg),\n+                             name, $($fmt)*));\n+            }\n+        }\n+        macro_rules! return_error {\n+            ($($fmt: tt)*) => {\n+                {\n+                    emit_error!($($fmt)*);\n+                    return Err(());\n+                }\n+            }\n+        }\n+        let ety = match in_elem.sty {\n+            ty::TyFloat(f) if f.bit_width() == 32 => {\n+                if in_len < 2 || in_len > 16 {\n+                    return_error!(\n+                        \"unsupported floating-point vector `{}` with length `{}` \\\n+                         out-of-range [2, 16]\",\n+                        in_ty, in_len);\n+                }\n+                \"f32\"\n+            },\n+            ty::TyFloat(f) if f.bit_width() == 64 => {\n+                if in_len < 2 || in_len > 8 {\n+                    return_error!(\"unsupported floating-point vector `{}` with length `{}` \\\n+                                   out-of-range [2, 8]\",\n+                                  in_ty, in_len);\n+                }\n+                \"f64\"\n+            },\n+            ty::TyFloat(f) => {\n+                return_error!(\"unsupported element type `{}` of floating-point vector `{}`\",\n+                              f, in_ty);\n+            },\n+            _ => {\n+                return_error!(\"`{}` is not a floating-point type\", in_ty);\n+            }\n+        };\n+\n+        let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", name, in_len, ety);\n+        let intrinsic = bx.cx.get_intrinsic(&llvm_name);\n+        let c = bx.call(intrinsic,\n+                        &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n+                        None);\n+        unsafe { llvm::LLVMRustSetHasUnsafeAlgebra(c) };\n+        return Ok(c);\n+    }\n+\n+    if name == \"simd_fsqrt\" {\n+        return simd_simple_float_intrinsic(\"sqrt\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fsin\" {\n+        return simd_simple_float_intrinsic(\"sin\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fcos\" {\n+        return simd_simple_float_intrinsic(\"cos\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fabs\" {\n+        return simd_simple_float_intrinsic(\"fabs\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_floor\" {\n+        return simd_simple_float_intrinsic(\"floor\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_ceil\" {\n+        return simd_simple_float_intrinsic(\"ceil\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fexp\" {\n+        return simd_simple_float_intrinsic(\"exp\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fexp2\" {\n+        return simd_simple_float_intrinsic(\"exp2\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_flog10\" {\n+        return simd_simple_float_intrinsic(\"log10\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_flog2\" {\n+        return simd_simple_float_intrinsic(\"log2\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_flog\" {\n+        return simd_simple_float_intrinsic(\"log\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fpowi\" {\n+        return simd_simple_float_intrinsic(\"powi\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fpow\"  {\n+        return simd_simple_float_intrinsic(\"pow\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fma\" {\n+        return simd_simple_float_intrinsic(\"fma\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    // FIXME: use:\n+    //  https://github.com/llvm-mirror/llvm/blob/master/include/llvm/IR/Function.h#L182\n+    //  https://github.com/llvm-mirror/llvm/blob/master/include/llvm/IR/Intrinsics.h#L81\n+    fn llvm_vector_str(elem_ty: ty::Ty, vec_len: usize, no_pointers: usize) -> String {\n+        let p0s: String = \"p0\".repeat(no_pointers);\n+        match elem_ty.sty {\n+            ty::TyInt(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n+            ty::TyUint(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n+            ty::TyFloat(v) => format!(\"v{}{}f{}\", vec_len, p0s, v.bit_width()),\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    fn llvm_vector_ty(cx: &CodegenCx, elem_ty: ty::Ty, vec_len: usize,\n+                      mut no_pointers: usize) -> Type {\n+        // FIXME: use cx.layout_of(ty).llvm_type() ?\n+        let mut elem_ty = match elem_ty.sty {\n+            ty::TyInt(v) => Type::int_from_ty(cx, v),\n+            ty::TyUint(v) => Type::uint_from_ty(cx, v),\n+            ty::TyFloat(v) => Type::float_from_ty(cx, v),\n+            _ => unreachable!(),\n+        };\n+        while no_pointers > 0 {\n+            elem_ty = elem_ty.ptr_to();\n+            no_pointers -= 1;\n+        }\n+        Type::vector(&elem_ty, vec_len as u64)\n+    }\n+\n+\n+    if name == \"simd_gather\"  {\n+        // simd_gather(values: <N x T>, pointers: <N x *_ T>,\n+        //             mask: <N x i{M}>) -> <N x T>\n+        // * N: number of elements in the input vectors\n+        // * T: type of the element to load\n+        // * M: any integer width is supported, will be truncated to i1\n+\n+        // All types must be simd vector types\n+        require_simd!(in_ty, \"first\");\n+        require_simd!(arg_tys[1], \"second\");\n+        require_simd!(arg_tys[2], \"third\");\n+        require_simd!(ret_ty, \"return\");\n+\n+        // Of the same length:\n+        require!(in_len == arg_tys[1].simd_size(tcx),\n+                 \"expected {} argument with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\", \"second\", in_len, in_ty, arg_tys[1],\n+                 arg_tys[1].simd_size(tcx));\n+        require!(in_len == arg_tys[2].simd_size(tcx),\n+                 \"expected {} argument with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\", \"third\", in_len, in_ty, arg_tys[2],\n+                 arg_tys[2].simd_size(tcx));\n+\n+        // The return type must match the first argument type\n+        require!(ret_ty == in_ty,\n+                 \"expected return type `{}`, found `{}`\",\n+                 in_ty, ret_ty);\n+\n+        // This counts how many pointers\n+        fn ptr_count(t: ty::Ty) -> usize {\n+            match t.sty {\n+                ty::TyRawPtr(p) => 1 + ptr_count(p.ty),\n+                _ => 0,\n+            }\n+        }\n+\n+        // Non-ptr type\n+        fn non_ptr(t: ty::Ty) -> ty::Ty {\n+            match t.sty {\n+                ty::TyRawPtr(p) => non_ptr(p.ty),\n+                _ => t,\n+            }\n+        }\n+\n+        // The second argument must be a simd vector with an element type that's a pointer\n+        // to the element type of the first argument\n+        let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).sty {\n+            ty::TyRawPtr(p) if p.ty == in_elem => (ptr_count(arg_tys[1].simd_type(tcx)),\n+                                                   non_ptr(arg_tys[1].simd_type(tcx))),\n+            _ => {\n+                require!(false, \"expected element type `{}` of second argument `{}` \\\n+                                 to be a pointer to the element type `{}` of the first \\\n+                                 argument `{}`, found `{}` != `*_ {}`\",\n+                         arg_tys[1].simd_type(tcx).sty, arg_tys[1], in_elem, in_ty,\n+                         arg_tys[1].simd_type(tcx).sty, in_elem);\n+                unreachable!();\n+            }\n+        };\n+        assert!(pointer_count > 0);\n+        assert!(pointer_count - 1 == ptr_count(arg_tys[0].simd_type(tcx)));\n+        assert_eq!(underlying_ty, non_ptr(arg_tys[0].simd_type(tcx)));\n+\n+        // The element type of the third argument must be a signed integer type of any width:\n+        match arg_tys[2].simd_type(tcx).sty {\n+            ty::TyInt(_) => (),\n+            _ => {\n+                require!(false, \"expected element type `{}` of third argument `{}` \\\n+                                 to be a signed integer type\",\n+                         arg_tys[2].simd_type(tcx).sty, arg_tys[2]);\n+            }\n+        }\n+\n+        // Alignment of T, must be a constant integer value:\n+        let alignment_ty = Type::i32(bx.cx);\n+        let alignment = C_i32(bx.cx, bx.cx.align_of(in_elem).abi() as i32);\n+\n+        // Truncate the mask vector to a vector of i1s:\n+        let (mask, mask_ty) = {\n+            let i1 = Type::i1(bx.cx);\n+            let i1xn = Type::vector(&i1, in_len as u64);\n+            (bx.trunc(args[2].immediate(), i1xn), i1xn)\n+        };\n+\n+        // Type of the vector of pointers:\n+        let llvm_pointer_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count);\n+        let llvm_pointer_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count);\n+\n+        // Type of the vector of elements:\n+        let llvm_elem_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count - 1);\n+        let llvm_elem_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count - 1);\n+\n+        let llvm_intrinsic = format!(\"llvm.masked.gather.{}.{}\",\n+                                     llvm_elem_vec_str, llvm_pointer_vec_str);\n+        let f = declare::declare_cfn(bx.cx, &llvm_intrinsic,\n+                                     Type::func(&[llvm_pointer_vec_ty, alignment_ty, mask_ty,\n+                                                  llvm_elem_vec_ty], &llvm_elem_vec_ty));\n+        llvm::SetUnnamedAddr(f, false);\n+        let v = bx.call(f, &[args[1].immediate(), alignment, mask, args[0].immediate()],\n+                        None);\n+        return Ok(v);\n+    }\n+\n+    if name == \"simd_scatter\"  {\n+        // simd_scatter(values: <N x T>, pointers: <N x *mut T>,\n+        //             mask: <N x i{M}>) -> ()\n+        // * N: number of elements in the input vectors\n+        // * T: type of the element to load\n+        // * M: any integer width is supported, will be truncated to i1\n+\n+        // All types must be simd vector types\n+        require_simd!(in_ty, \"first\");\n+        require_simd!(arg_tys[1], \"second\");\n+        require_simd!(arg_tys[2], \"third\");\n+\n+        // Of the same length:\n+        require!(in_len == arg_tys[1].simd_size(tcx),\n+                 \"expected {} argument with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\", \"second\", in_len, in_ty, arg_tys[1],\n+                 arg_tys[1].simd_size(tcx));\n+        require!(in_len == arg_tys[2].simd_size(tcx),\n+                 \"expected {} argument with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\", \"third\", in_len, in_ty, arg_tys[2],\n+                 arg_tys[2].simd_size(tcx));\n+\n+        // This counts how many pointers\n+        fn ptr_count(t: ty::Ty) -> usize {\n+            match t.sty {\n+                ty::TyRawPtr(p) => 1 + ptr_count(p.ty),\n+                _ => 0,\n+            }\n+        }\n+\n+        // Non-ptr type\n+        fn non_ptr(t: ty::Ty) -> ty::Ty {\n+            match t.sty {\n+                ty::TyRawPtr(p) => non_ptr(p.ty),\n+                _ => t,\n+            }\n+        }\n+\n+        // The second argument must be a simd vector with an element type that's a pointer\n+        // to the element type of the first argument\n+        let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).sty {\n+            ty::TyRawPtr(p) if p.ty == in_elem && p.mutbl == hir::MutMutable\n+                => (ptr_count(arg_tys[1].simd_type(tcx)),\n+                    non_ptr(arg_tys[1].simd_type(tcx))),\n+            _ => {\n+                require!(false, \"expected element type `{}` of second argument `{}` \\\n+                                 to be a pointer to the element type `{}` of the first \\\n+                                 argument `{}`, found `{}` != `*mut {}`\",\n+                         arg_tys[1].simd_type(tcx).sty, arg_tys[1], in_elem, in_ty,\n+                         arg_tys[1].simd_type(tcx).sty, in_elem);\n+                unreachable!();\n+            }\n+        };\n+        assert!(pointer_count > 0);\n+        assert!(pointer_count - 1 == ptr_count(arg_tys[0].simd_type(tcx)));\n+        assert_eq!(underlying_ty, non_ptr(arg_tys[0].simd_type(tcx)));\n+\n+        // The element type of the third argument must be a signed integer type of any width:\n+        match arg_tys[2].simd_type(tcx).sty {\n+            ty::TyInt(_) => (),\n+            _ => {\n+                require!(false, \"expected element type `{}` of third argument `{}` \\\n+                                 to be a signed integer type\",\n+                         arg_tys[2].simd_type(tcx).sty, arg_tys[2]);\n+            }\n+        }\n+\n+        // Alignment of T, must be a constant integer value:\n+        let alignment_ty = Type::i32(bx.cx);\n+        let alignment = C_i32(bx.cx, bx.cx.align_of(in_elem).abi() as i32);\n+\n+        // Truncate the mask vector to a vector of i1s:\n+        let (mask, mask_ty) = {\n+            let i1 = Type::i1(bx.cx);\n+            let i1xn = Type::vector(&i1, in_len as u64);\n+            (bx.trunc(args[2].immediate(), i1xn), i1xn)\n+        };\n+\n+        let ret_t = Type::void(bx.cx);\n+\n+        // Type of the vector of pointers:\n+        let llvm_pointer_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count);\n+        let llvm_pointer_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count);\n+\n+        // Type of the vector of elements:\n+        let llvm_elem_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count - 1);\n+        let llvm_elem_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count - 1);\n+\n+        let llvm_intrinsic = format!(\"llvm.masked.scatter.{}.{}\",\n+                                     llvm_elem_vec_str, llvm_pointer_vec_str);\n+        let f = declare::declare_cfn(bx.cx, &llvm_intrinsic,\n+                                     Type::func(&[llvm_elem_vec_ty,\n+                                                  llvm_pointer_vec_ty,\n+                                                  alignment_ty,\n+                                                  mask_ty], &ret_t));\n+        llvm::SetUnnamedAddr(f, false);\n+        let v = bx.call(f, &[args[0].immediate(), args[1].immediate(), alignment, mask],\n+                        None);\n+        return Ok(v);\n+    }\n+\n     macro_rules! arith_red {\n         ($name:tt : $integer_reduce:ident, $float_reduce:ident, $ordered:expr) => {\n             if name == $name {"}, {"sha": "5546aa58d4cfa41dbe14906590e34c3350baeb0a", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -351,9 +351,26 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         \"simd_add\" | \"simd_sub\" | \"simd_mul\" | \"simd_rem\" |\n         \"simd_div\" | \"simd_shl\" | \"simd_shr\" |\n         \"simd_and\" | \"simd_or\" | \"simd_xor\" |\n-        \"simd_fmin\" | \"simd_fmax\" => {\n+        \"simd_fmin\" | \"simd_fmax\" | \"simd_fpow\" => {\n             (1, vec![param(0), param(0)], param(0))\n         }\n+        \"simd_fsqrt\" | \"simd_fsin\" | \"simd_fcos\" | \"simd_fexp\" | \"simd_fexp2\" |\n+        \"simd_flog2\" | \"simd_flog10\" | \"simd_flog\" |\n+        \"simd_fabs\" | \"simd_floor\" | \"simd_ceil\" => {\n+            (1, vec![param(0)], param(0))\n+        }\n+        \"simd_fpowi\" => {\n+            (1, vec![param(0), tcx.types.i32], param(0))\n+        }\n+        \"simd_fma\" => {\n+            (1, vec![param(0), param(0), param(0)], param(0))\n+        }\n+        \"simd_gather\" => {\n+            (3, vec![param(0), param(1), param(2)], param(0))\n+        }\n+        \"simd_scatter\" => {\n+            (3, vec![param(0), param(1), param(2)], tcx.mk_nil())\n+        }\n         \"simd_insert\" => (2, vec![param(0), tcx.types.u32, param(1)], param(0)),\n         \"simd_extract\" => (2, vec![param(0), tcx.types.u32], param(1)),\n         \"simd_cast\" => (2, vec![param(0)], param(1)),"}, {"sha": "49f1f3e8565c633b2c834932ef2be0a83ee2b177", "filename": "src/test/codegen/simd-intrinsic-float-abs.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-abs.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fabs<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @fabs_32x2\n+#[no_mangle]\n+pub unsafe fn fabs_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call fast <2 x float> @llvm.fabs.v2f32\n+    simd_fabs(a)\n+}\n+\n+// CHECK-LABEL: @fabs_32x4\n+#[no_mangle]\n+pub unsafe fn fabs_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call fast <4 x float> @llvm.fabs.v4f32\n+    simd_fabs(a)\n+}\n+\n+// CHECK-LABEL: @fabs_32x8\n+#[no_mangle]\n+pub unsafe fn fabs_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call fast <8 x float> @llvm.fabs.v8f32\n+    simd_fabs(a)\n+}\n+\n+// CHECK-LABEL: @fabs_32x16\n+#[no_mangle]\n+pub unsafe fn fabs_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call fast <16 x float> @llvm.fabs.v16f32\n+    simd_fabs(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @fabs_64x4\n+#[no_mangle]\n+pub unsafe fn fabs_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call fast <4 x double> @llvm.fabs.v4f64\n+    simd_fabs(a)\n+}\n+\n+// CHECK-LABEL: @fabs_64x2\n+#[no_mangle]\n+pub unsafe fn fabs_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call fast <2 x double> @llvm.fabs.v2f64\n+    simd_fabs(a)\n+}\n+\n+// CHECK-LABEL: @fabs_64x8\n+#[no_mangle]\n+pub unsafe fn fabs_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call fast <8 x double> @llvm.fabs.v8f64\n+    simd_fabs(a)\n+}"}, {"sha": "4a6f162e16b1b23c3f0c741e7b524a15f1ee4951", "filename": "src/test/codegen/simd-intrinsic-float-ceil.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-ceil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-ceil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-ceil.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_ceil<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @ceil_32x2\n+#[no_mangle]\n+pub unsafe fn ceil_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call fast <2 x float> @llvm.ceil.v2f32\n+    simd_ceil(a)\n+}\n+\n+// CHECK-LABEL: @ceil_32x4\n+#[no_mangle]\n+pub unsafe fn ceil_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call fast <4 x float> @llvm.ceil.v4f32\n+    simd_ceil(a)\n+}\n+\n+// CHECK-LABEL: @ceil_32x8\n+#[no_mangle]\n+pub unsafe fn ceil_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call fast <8 x float> @llvm.ceil.v8f32\n+    simd_ceil(a)\n+}\n+\n+// CHECK-LABEL: @ceil_32x16\n+#[no_mangle]\n+pub unsafe fn ceil_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call fast <16 x float> @llvm.ceil.v16f32\n+    simd_ceil(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @ceil_64x4\n+#[no_mangle]\n+pub unsafe fn ceil_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call fast <4 x double> @llvm.ceil.v4f64\n+    simd_ceil(a)\n+}\n+\n+// CHECK-LABEL: @ceil_64x2\n+#[no_mangle]\n+pub unsafe fn ceil_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call fast <2 x double> @llvm.ceil.v2f64\n+    simd_ceil(a)\n+}\n+\n+// CHECK-LABEL: @ceil_64x8\n+#[no_mangle]\n+pub unsafe fn ceil_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call fast <8 x double> @llvm.ceil.v8f64\n+    simd_ceil(a)\n+}"}, {"sha": "6304c6c644f42aba93e9046a1060addec881b279", "filename": "src/test/codegen/simd-intrinsic-float-cos.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-cos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-cos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-cos.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fcos<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @fcos_32x2\n+#[no_mangle]\n+pub unsafe fn fcos_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call fast <2 x float> @llvm.cos.v2f32\n+    simd_fcos(a)\n+}\n+\n+// CHECK-LABEL: @fcos_32x4\n+#[no_mangle]\n+pub unsafe fn fcos_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call fast <4 x float> @llvm.cos.v4f32\n+    simd_fcos(a)\n+}\n+\n+// CHECK-LABEL: @fcos_32x8\n+#[no_mangle]\n+pub unsafe fn fcos_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call fast <8 x float> @llvm.cos.v8f32\n+    simd_fcos(a)\n+}\n+\n+// CHECK-LABEL: @fcos_32x16\n+#[no_mangle]\n+pub unsafe fn fcos_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call fast <16 x float> @llvm.cos.v16f32\n+    simd_fcos(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @fcos_64x4\n+#[no_mangle]\n+pub unsafe fn fcos_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call fast <4 x double> @llvm.cos.v4f64\n+    simd_fcos(a)\n+}\n+\n+// CHECK-LABEL: @fcos_64x2\n+#[no_mangle]\n+pub unsafe fn fcos_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call fast <2 x double> @llvm.cos.v2f64\n+    simd_fcos(a)\n+}\n+\n+// CHECK-LABEL: @fcos_64x8\n+#[no_mangle]\n+pub unsafe fn fcos_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call fast <8 x double> @llvm.cos.v8f64\n+    simd_fcos(a)\n+}"}, {"sha": "110031c645143165fa0ea13f14bf3cb8fcc30380", "filename": "src/test/codegen/simd-intrinsic-float-exp.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-exp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-exp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-exp.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fexp<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @exp_32x2\n+#[no_mangle]\n+pub unsafe fn exp_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call fast <2 x float> @llvm.exp.v2f32\n+    simd_fexp(a)\n+}\n+\n+// CHECK-LABEL: @exp_32x4\n+#[no_mangle]\n+pub unsafe fn exp_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call fast <4 x float> @llvm.exp.v4f32\n+    simd_fexp(a)\n+}\n+\n+// CHECK-LABEL: @exp_32x8\n+#[no_mangle]\n+pub unsafe fn exp_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call fast <8 x float> @llvm.exp.v8f32\n+    simd_fexp(a)\n+}\n+\n+// CHECK-LABEL: @exp_32x16\n+#[no_mangle]\n+pub unsafe fn exp_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call fast <16 x float> @llvm.exp.v16f32\n+    simd_fexp(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @exp_64x4\n+#[no_mangle]\n+pub unsafe fn exp_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call fast <4 x double> @llvm.exp.v4f64\n+    simd_fexp(a)\n+}\n+\n+// CHECK-LABEL: @exp_64x2\n+#[no_mangle]\n+pub unsafe fn exp_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call fast <2 x double> @llvm.exp.v2f64\n+    simd_fexp(a)\n+}\n+\n+// CHECK-LABEL: @exp_64x8\n+#[no_mangle]\n+pub unsafe fn exp_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call fast <8 x double> @llvm.exp.v8f64\n+    simd_fexp(a)\n+}"}, {"sha": "dc62c90822f0c54ecbaf11813a596d12cb648af3", "filename": "src/test/codegen/simd-intrinsic-float-exp2.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-exp2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-exp2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-exp2.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fexp2<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @exp2_32x2\n+#[no_mangle]\n+pub unsafe fn exp2_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call fast <2 x float> @llvm.exp2.v2f32\n+    simd_fexp2(a)\n+}\n+\n+// CHECK-LABEL: @exp2_32x4\n+#[no_mangle]\n+pub unsafe fn exp2_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call fast <4 x float> @llvm.exp2.v4f32\n+    simd_fexp2(a)\n+}\n+\n+// CHECK-LABEL: @exp2_32x8\n+#[no_mangle]\n+pub unsafe fn exp2_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call fast <8 x float> @llvm.exp2.v8f32\n+    simd_fexp2(a)\n+}\n+\n+// CHECK-LABEL: @exp2_32x16\n+#[no_mangle]\n+pub unsafe fn exp2_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call fast <16 x float> @llvm.exp2.v16f32\n+    simd_fexp2(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @exp2_64x4\n+#[no_mangle]\n+pub unsafe fn exp2_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call fast <4 x double> @llvm.exp2.v4f64\n+    simd_fexp2(a)\n+}\n+\n+// CHECK-LABEL: @exp2_64x2\n+#[no_mangle]\n+pub unsafe fn exp2_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call fast <2 x double> @llvm.exp2.v2f64\n+    simd_fexp2(a)\n+}\n+\n+// CHECK-LABEL: @exp2_64x8\n+#[no_mangle]\n+pub unsafe fn exp2_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call fast <8 x double> @llvm.exp2.v8f64\n+    simd_fexp2(a)\n+}"}, {"sha": "9bc8ca0d1527f145222090ec2cd7b43b71613527", "filename": "src/test/codegen/simd-intrinsic-float-floor.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-floor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-floor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-floor.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_floor<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @floor_32x2\n+#[no_mangle]\n+pub unsafe fn floor_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call fast <2 x float> @llvm.floor.v2f32\n+    simd_floor(a)\n+}\n+\n+// CHECK-LABEL: @floor_32x4\n+#[no_mangle]\n+pub unsafe fn floor_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call fast <4 x float> @llvm.floor.v4f32\n+    simd_floor(a)\n+}\n+\n+// CHECK-LABEL: @floor_32x8\n+#[no_mangle]\n+pub unsafe fn floor_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call fast <8 x float> @llvm.floor.v8f32\n+    simd_floor(a)\n+}\n+\n+// CHECK-LABEL: @floor_32x16\n+#[no_mangle]\n+pub unsafe fn floor_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call fast <16 x float> @llvm.floor.v16f32\n+    simd_floor(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @floor_64x4\n+#[no_mangle]\n+pub unsafe fn floor_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call fast <4 x double> @llvm.floor.v4f64\n+    simd_floor(a)\n+}\n+\n+// CHECK-LABEL: @floor_64x2\n+#[no_mangle]\n+pub unsafe fn floor_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call fast <2 x double> @llvm.floor.v2f64\n+    simd_floor(a)\n+}\n+\n+// CHECK-LABEL: @floor_64x8\n+#[no_mangle]\n+pub unsafe fn floor_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call fast <8 x double> @llvm.floor.v8f64\n+    simd_floor(a)\n+}"}, {"sha": "acd7f717214f1ff39259f7db2b584d51d19b4827", "filename": "src/test/codegen/simd-intrinsic-float-fma.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-fma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-fma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-fma.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fma<T>(x: T, b: T, c: T) -> T;\n+}\n+\n+// CHECK-LABEL: @fma_32x2\n+#[no_mangle]\n+pub unsafe fn fma_32x2(a: f32x2, b: f32x2, c: f32x2) -> f32x2 {\n+    // CHECK: call fast <2 x float> @llvm.fma.v2f32\n+    simd_fma(a, b, c)\n+}\n+\n+// CHECK-LABEL: @fma_32x4\n+#[no_mangle]\n+pub unsafe fn fma_32x4(a: f32x4, b: f32x4, c: f32x4) -> f32x4 {\n+    // CHECK: call fast <4 x float> @llvm.fma.v4f32\n+    simd_fma(a, b, c)\n+}\n+\n+// CHECK-LABEL: @fma_32x8\n+#[no_mangle]\n+pub unsafe fn fma_32x8(a: f32x8, b: f32x8, c: f32x8) -> f32x8 {\n+    // CHECK: call fast <8 x float> @llvm.fma.v8f32\n+    simd_fma(a, b, c)\n+}\n+\n+// CHECK-LABEL: @fma_32x16\n+#[no_mangle]\n+pub unsafe fn fma_32x16(a: f32x16, b: f32x16, c: f32x16) -> f32x16 {\n+    // CHECK: call fast <16 x float> @llvm.fma.v16f32\n+    simd_fma(a, b, c)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @fma_64x4\n+#[no_mangle]\n+pub unsafe fn fma_64x4(a: f64x4, b: f64x4, c: f64x4) -> f64x4 {\n+    // CHECK: call fast <4 x double> @llvm.fma.v4f64\n+    simd_fma(a, b, c)\n+}\n+\n+// CHECK-LABEL: @fma_64x2\n+#[no_mangle]\n+pub unsafe fn fma_64x2(a: f64x2, b: f64x2, c: f64x2) -> f64x2 {\n+    // CHECK: call fast <2 x double> @llvm.fma.v2f64\n+    simd_fma(a, b, c)\n+}\n+\n+// CHECK-LABEL: @fma_64x8\n+#[no_mangle]\n+pub unsafe fn fma_64x8(a: f64x8, b: f64x8, c: f64x8) -> f64x8 {\n+    // CHECK: call fast <8 x double> @llvm.fma.v8f64\n+    simd_fma(a, b, c)\n+}"}, {"sha": "2bad0bba48a78c05ca54bb0893edfd353307fecb", "filename": "src/test/codegen/simd-intrinsic-float-fsqrt.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-fsqrt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-fsqrt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-fsqrt.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fsqrt<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @fsqrt_32x2\n+#[no_mangle]\n+pub unsafe fn fsqrt_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call fast <2 x float> @llvm.sqrt.v2f32\n+    simd_fsqrt(a)\n+}\n+\n+// CHECK-LABEL: @fsqrt_32x4\n+#[no_mangle]\n+pub unsafe fn fsqrt_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call fast <4 x float> @llvm.sqrt.v4f32\n+    simd_fsqrt(a)\n+}\n+\n+// CHECK-LABEL: @fsqrt_32x8\n+#[no_mangle]\n+pub unsafe fn fsqrt_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call fast <8 x float> @llvm.sqrt.v8f32\n+    simd_fsqrt(a)\n+}\n+\n+// CHECK-LABEL: @fsqrt_32x16\n+#[no_mangle]\n+pub unsafe fn fsqrt_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call fast <16 x float> @llvm.sqrt.v16f32\n+    simd_fsqrt(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @fsqrt_64x4\n+#[no_mangle]\n+pub unsafe fn fsqrt_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call fast <4 x double> @llvm.sqrt.v4f64\n+    simd_fsqrt(a)\n+}\n+\n+// CHECK-LABEL: @fsqrt_64x2\n+#[no_mangle]\n+pub unsafe fn fsqrt_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call fast <2 x double> @llvm.sqrt.v2f64\n+    simd_fsqrt(a)\n+}\n+\n+// CHECK-LABEL: @fsqrt_64x8\n+#[no_mangle]\n+pub unsafe fn fsqrt_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call fast <8 x double> @llvm.sqrt.v8f64\n+    simd_fsqrt(a)\n+}"}, {"sha": "d3829efe09b0e80579910eb6644a916bcad5e8bc", "filename": "src/test/codegen/simd-intrinsic-float-log.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_flog<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @log_32x2\n+#[no_mangle]\n+pub unsafe fn log_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call fast <2 x float> @llvm.log.v2f32\n+    simd_flog(a)\n+}\n+\n+// CHECK-LABEL: @log_32x4\n+#[no_mangle]\n+pub unsafe fn log_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call fast <4 x float> @llvm.log.v4f32\n+    simd_flog(a)\n+}\n+\n+// CHECK-LABEL: @log_32x8\n+#[no_mangle]\n+pub unsafe fn log_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call fast <8 x float> @llvm.log.v8f32\n+    simd_flog(a)\n+}\n+\n+// CHECK-LABEL: @log_32x16\n+#[no_mangle]\n+pub unsafe fn log_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call fast <16 x float> @llvm.log.v16f32\n+    simd_flog(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @log_64x4\n+#[no_mangle]\n+pub unsafe fn log_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call fast <4 x double> @llvm.log.v4f64\n+    simd_flog(a)\n+}\n+\n+// CHECK-LABEL: @log_64x2\n+#[no_mangle]\n+pub unsafe fn log_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call fast <2 x double> @llvm.log.v2f64\n+    simd_flog(a)\n+}\n+\n+// CHECK-LABEL: @log_64x8\n+#[no_mangle]\n+pub unsafe fn log_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call fast <8 x double> @llvm.log.v8f64\n+    simd_flog(a)\n+}"}, {"sha": "47f19e499fa7dc0389d177d281d230fb72ab9fb1", "filename": "src/test/codegen/simd-intrinsic-float-log10.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log10.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_flog10<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @log10_32x2\n+#[no_mangle]\n+pub unsafe fn log10_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call fast <2 x float> @llvm.log10.v2f32\n+    simd_flog10(a)\n+}\n+\n+// CHECK-LABEL: @log10_32x4\n+#[no_mangle]\n+pub unsafe fn log10_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call fast <4 x float> @llvm.log10.v4f32\n+    simd_flog10(a)\n+}\n+\n+// CHECK-LABEL: @log10_32x8\n+#[no_mangle]\n+pub unsafe fn log10_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call fast <8 x float> @llvm.log10.v8f32\n+    simd_flog10(a)\n+}\n+\n+// CHECK-LABEL: @log10_32x16\n+#[no_mangle]\n+pub unsafe fn log10_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call fast <16 x float> @llvm.log10.v16f32\n+    simd_flog10(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @log10_64x4\n+#[no_mangle]\n+pub unsafe fn log10_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call fast <4 x double> @llvm.log10.v4f64\n+    simd_flog10(a)\n+}\n+\n+// CHECK-LABEL: @log10_64x2\n+#[no_mangle]\n+pub unsafe fn log10_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call fast <2 x double> @llvm.log10.v2f64\n+    simd_flog10(a)\n+}\n+\n+// CHECK-LABEL: @log10_64x8\n+#[no_mangle]\n+pub unsafe fn log10_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call fast <8 x double> @llvm.log10.v8f64\n+    simd_flog10(a)\n+}"}, {"sha": "e36a5887b61964c45cc114058650d43cdd626fc1", "filename": "src/test/codegen/simd-intrinsic-float-log2.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log2.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_flog2<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @log2_32x2\n+#[no_mangle]\n+pub unsafe fn log2_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call fast <2 x float> @llvm.log2.v2f32\n+    simd_flog2(a)\n+}\n+\n+// CHECK-LABEL: @log2_32x4\n+#[no_mangle]\n+pub unsafe fn log2_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call fast <4 x float> @llvm.log2.v4f32\n+    simd_flog2(a)\n+}\n+\n+// CHECK-LABEL: @log2_32x8\n+#[no_mangle]\n+pub unsafe fn log2_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call fast <8 x float> @llvm.log2.v8f32\n+    simd_flog2(a)\n+}\n+\n+// CHECK-LABEL: @log2_32x16\n+#[no_mangle]\n+pub unsafe fn log2_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call fast <16 x float> @llvm.log2.v16f32\n+    simd_flog2(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @log2_64x4\n+#[no_mangle]\n+pub unsafe fn log2_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call fast <4 x double> @llvm.log2.v4f64\n+    simd_flog2(a)\n+}\n+\n+// CHECK-LABEL: @log2_64x2\n+#[no_mangle]\n+pub unsafe fn log2_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call fast <2 x double> @llvm.log2.v2f64\n+    simd_flog2(a)\n+}\n+\n+// CHECK-LABEL: @log2_64x8\n+#[no_mangle]\n+pub unsafe fn log2_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call fast <8 x double> @llvm.log2.v8f64\n+    simd_flog2(a)\n+}"}, {"sha": "d963c7e8ddf1b60511b6ed237971d4aec92e5a0a", "filename": "src/test/codegen/simd-intrinsic-float-minmax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-minmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-minmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-minmax.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -16,7 +16,7 @@\n #![crate_type = \"lib\"]\n \n #![feature(repr_simd, platform_intrinsics)]\n-#[allow(non_camel_case_types)]\n+#![allow(non_camel_case_types)]\n \n #[repr(simd)]\n #[derive(Copy, Clone, PartialEq, Debug)]"}, {"sha": "bb2ac362203025852c9c650bac40b8c8ab421af6", "filename": "src/test/codegen/simd-intrinsic-float-pow.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-pow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-pow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-pow.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fpow<T>(x: T, b: T) -> T;\n+}\n+\n+// CHECK-LABEL: @fpow_32x2\n+#[no_mangle]\n+pub unsafe fn fpow_32x2(a: f32x2, b: f32x2) -> f32x2 {\n+    // CHECK: call fast <2 x float> @llvm.pow.v2f32\n+    simd_fpow(a, b)\n+}\n+\n+// CHECK-LABEL: @fpow_32x4\n+#[no_mangle]\n+pub unsafe fn fpow_32x4(a: f32x4, b: f32x4) -> f32x4 {\n+    // CHECK: call fast <4 x float> @llvm.pow.v4f32\n+    simd_fpow(a, b)\n+}\n+\n+// CHECK-LABEL: @fpow_32x8\n+#[no_mangle]\n+pub unsafe fn fpow_32x8(a: f32x8, b: f32x8) -> f32x8 {\n+    // CHECK: call fast <8 x float> @llvm.pow.v8f32\n+    simd_fpow(a, b)\n+}\n+\n+// CHECK-LABEL: @fpow_32x16\n+#[no_mangle]\n+pub unsafe fn fpow_32x16(a: f32x16, b: f32x16) -> f32x16 {\n+    // CHECK: call fast <16 x float> @llvm.pow.v16f32\n+    simd_fpow(a, b)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @fpow_64x4\n+#[no_mangle]\n+pub unsafe fn fpow_64x4(a: f64x4, b: f64x4) -> f64x4 {\n+    // CHECK: call fast <4 x double> @llvm.pow.v4f64\n+    simd_fpow(a, b)\n+}\n+\n+// CHECK-LABEL: @fpow_64x2\n+#[no_mangle]\n+pub unsafe fn fpow_64x2(a: f64x2, b: f64x2) -> f64x2 {\n+    // CHECK: call fast <2 x double> @llvm.pow.v2f64\n+    simd_fpow(a, b)\n+}\n+\n+// CHECK-LABEL: @fpow_64x8\n+#[no_mangle]\n+pub unsafe fn fpow_64x8(a: f64x8, b: f64x8) -> f64x8 {\n+    // CHECK: call fast <8 x double> @llvm.pow.v8f64\n+    simd_fpow(a, b)\n+}"}, {"sha": "6e28af262ace60188463b05cc0b9f16a4a436d7b", "filename": "src/test/codegen/simd-intrinsic-float-powi.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-powi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-powi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-powi.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fpowi<T>(x: T, b: i32) -> T;\n+}\n+\n+// CHECK-LABEL: @fpowi_32x2\n+#[no_mangle]\n+pub unsafe fn fpowi_32x2(a: f32x2, b: i32) -> f32x2 {\n+    // CHECK: call fast <2 x float> @llvm.powi.v2f32\n+    simd_fpowi(a, b)\n+}\n+\n+// CHECK-LABEL: @fpowi_32x4\n+#[no_mangle]\n+pub unsafe fn fpowi_32x4(a: f32x4, b: i32) -> f32x4 {\n+    // CHECK: call fast <4 x float> @llvm.powi.v4f32\n+    simd_fpowi(a, b)\n+}\n+\n+// CHECK-LABEL: @fpowi_32x8\n+#[no_mangle]\n+pub unsafe fn fpowi_32x8(a: f32x8, b: i32) -> f32x8 {\n+    // CHECK: call fast <8 x float> @llvm.powi.v8f32\n+    simd_fpowi(a, b)\n+}\n+\n+// CHECK-LABEL: @fpowi_32x16\n+#[no_mangle]\n+pub unsafe fn fpowi_32x16(a: f32x16, b: i32) -> f32x16 {\n+    // CHECK: call fast <16 x float> @llvm.powi.v16f32\n+    simd_fpowi(a, b)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @fpowi_64x4\n+#[no_mangle]\n+pub unsafe fn fpowi_64x4(a: f64x4, b: i32) -> f64x4 {\n+    // CHECK: call fast <4 x double> @llvm.powi.v4f64\n+    simd_fpowi(a, b)\n+}\n+\n+// CHECK-LABEL: @fpowi_64x2\n+#[no_mangle]\n+pub unsafe fn fpowi_64x2(a: f64x2, b: i32) -> f64x2 {\n+    // CHECK: call fast <2 x double> @llvm.powi.v2f64\n+    simd_fpowi(a, b)\n+}\n+\n+// CHECK-LABEL: @fpowi_64x8\n+#[no_mangle]\n+pub unsafe fn fpowi_64x8(a: f64x8, b: i32) -> f64x8 {\n+    // CHECK: call fast <8 x double> @llvm.powi.v8f64\n+    simd_fpowi(a, b)\n+}"}, {"sha": "26100ed5c3f03f79de41f06fb664c26c50912569", "filename": "src/test/codegen/simd-intrinsic-float-sin.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-sin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-sin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-sin.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fsin<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @fsin_32x2\n+#[no_mangle]\n+pub unsafe fn fsin_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call fast <2 x float> @llvm.sin.v2f32\n+    simd_fsin(a)\n+}\n+\n+// CHECK-LABEL: @fsin_32x4\n+#[no_mangle]\n+pub unsafe fn fsin_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call fast <4 x float> @llvm.sin.v4f32\n+    simd_fsin(a)\n+}\n+\n+// CHECK-LABEL: @fsin_32x8\n+#[no_mangle]\n+pub unsafe fn fsin_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call fast <8 x float> @llvm.sin.v8f32\n+    simd_fsin(a)\n+}\n+\n+// CHECK-LABEL: @fsin_32x16\n+#[no_mangle]\n+pub unsafe fn fsin_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call fast <16 x float> @llvm.sin.v16f32\n+    simd_fsin(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @fsin_64x4\n+#[no_mangle]\n+pub unsafe fn fsin_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call fast <4 x double> @llvm.sin.v4f64\n+    simd_fsin(a)\n+}\n+\n+// CHECK-LABEL: @fsin_64x2\n+#[no_mangle]\n+pub unsafe fn fsin_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call fast <2 x double> @llvm.sin.v2f64\n+    simd_fsin(a)\n+}\n+\n+// CHECK-LABEL: @fsin_64x8\n+#[no_mangle]\n+pub unsafe fn fsin_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call fast <8 x double> @llvm.sin.v8f64\n+    simd_fsin(a)\n+}"}, {"sha": "6c47bf3e321fbb3eb19afb6bb564f9d9f558f2f5", "filename": "src/test/codegen/simd-intrinsic-generic-gather.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-gather.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-gather.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-gather.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+// ignore-tidy-linelength\n+// min-llvm-version 6.0\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct Vec2<T>(pub T, pub T);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct Vec4<T>(pub T, pub T, pub T, pub T);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_gather<T, P, M>(value: T, pointers: P, mask: M) -> T;\n+}\n+\n+// CHECK-LABEL: @gather_f32x2\n+#[no_mangle]\n+pub unsafe fn gather_f32x2(pointers: Vec2<*const f32>, mask: Vec2<i32>,\n+                           values: Vec2<f32>) -> Vec2<f32> {\n+    // CHECK: call <2 x float> @llvm.masked.gather.v2f32.v2p0f32(<2 x float*> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}}, <2 x float> {{.*}})\n+    simd_gather(values, pointers, mask)\n+}\n+\n+// CHECK-LABEL: @gather_pf32x2\n+#[no_mangle]\n+pub unsafe fn gather_pf32x2(pointers: Vec2<*const *const f32>, mask: Vec2<i32>,\n+                           values: Vec2<*const f32>) -> Vec2<*const f32> {\n+    // CHECK: call <2 x float*> @llvm.masked.gather.v2p0f32.v2p0p0f32(<2 x float**> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}}, <2 x float*> {{.*}})\n+    simd_gather(values, pointers, mask)\n+}"}, {"sha": "7b5b2e55e2949986fc9ffec3a7ee46acaa9a0ec5", "filename": "src/test/codegen/simd-intrinsic-generic-scatter.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-scatter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-scatter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-scatter.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+// ignore-tidy-linelength\n+// min-llvm-version 6.0\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct Vec2<T>(pub T, pub T);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct Vec4<T>(pub T, pub T, pub T, pub T);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_scatter<T, P, M>(value: T, pointers: P, mask: M);\n+}\n+\n+// CHECK-LABEL: @scatter_f32x2\n+#[no_mangle]\n+pub unsafe fn scatter_f32x2(pointers: Vec2<*mut f32>, mask: Vec2<i32>,\n+                            values: Vec2<f32>) {\n+    // CHECK: call void @llvm.masked.scatter.v2f32.v2p0f32(<2 x float> {{.*}}, <2 x float*> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}})\n+    simd_scatter(values, pointers, mask)\n+}\n+\n+\n+// CHECK-LABEL: @scatter_pf32x2\n+#[no_mangle]\n+pub unsafe fn scatter_pf32x2(pointers: Vec2<*mut *const f32>, mask: Vec2<i32>,\n+                             values: Vec2<*const f32>) {\n+    // CHECK: call void @llvm.masked.scatter.v2p0f32.v2p0p0f32(<2 x float*> {{.*}}, <2 x float**> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}})\n+    simd_scatter(values, pointers, mask)\n+}"}, {"sha": "4597674b3f1d2d953be005d90714813ac3e74379", "filename": "src/test/run-pass/simd-intrinsic-float-math.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-float-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-float-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-float-math.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+// ignore-android\n+\n+// FIXME: this test fails on arm-android because the NDK version 14 is too old.\n+// It needs at least version 18. We disable it on all android build bots because\n+// there is no way in compile-test to disable it for an (arch,os) pair.\n+\n+// Test that the simd floating-point math intrinsics produce correct results.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fsqrt<T>(x: T) -> T;\n+    fn simd_fabs<T>(x: T) -> T;\n+    fn simd_fsin<T>(x: T) -> T;\n+    fn simd_fcos<T>(x: T) -> T;\n+    fn simd_ceil<T>(x: T) -> T;\n+    fn simd_fexp<T>(x: T) -> T;\n+    fn simd_fexp2<T>(x: T) -> T;\n+    fn simd_floor<T>(x: T) -> T;\n+    fn simd_fma<T>(x: T, y: T, z: T) -> T;\n+    fn simd_flog<T>(x: T) -> T;\n+    fn simd_flog10<T>(x: T) -> T;\n+    fn simd_flog2<T>(x: T) -> T;\n+    fn simd_fpow<T>(x: T, y: T) -> T;\n+    fn simd_fpowi<T>(x: T, y: i32) -> T;\n+}\n+\n+fn main() {\n+    let x = f32x4(1.0, 1.0, 1.0, 1.0);\n+    let y = f32x4(-1.0, -1.0, -1.0, -1.0);\n+    let z = f32x4(0.0, 0.0, 0.0, 0.0);\n+\n+    let h = f32x4(0.5, 0.5, 0.5, 0.5);\n+\n+    unsafe {\n+        let r = simd_fabs(y);\n+        assert_eq!(x, r);\n+\n+        let r = simd_fcos(z);\n+        assert_eq!(x, r);\n+\n+        let r = simd_ceil(h);\n+        assert_eq!(x, r);\n+\n+        let r = simd_fexp(z);\n+        assert_eq!(x, r);\n+\n+        let r = simd_fexp2(z);\n+        assert_eq!(x, r);\n+\n+        let r = simd_floor(h);\n+        assert_eq!(z, r);\n+\n+        let r = simd_fma(x, h, h);\n+        assert_eq!(x, r);\n+\n+        let r = simd_fsqrt(x);\n+        assert_eq!(x, r);\n+\n+        let r = simd_flog(x);\n+        assert_eq!(z, r);\n+\n+        let r = simd_flog2(x);\n+        assert_eq!(z, r);\n+\n+        let r = simd_flog10(x);\n+        assert_eq!(z, r);\n+\n+        let r = simd_fpow(h, x);\n+        assert_eq!(h, r);\n+\n+        let r = simd_fpowi(h, 1);\n+        assert_eq!(h, r);\n+\n+        let r = simd_fsin(z);\n+        assert_eq!(z, r);\n+    }\n+}"}, {"sha": "71c0139bb03bb5222dfbb8c9a2691f8812c971ea", "filename": "src/test/run-pass/simd-intrinsic-float-minmax.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-float-minmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-float-minmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-float-minmax.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n // ignore-emscripten\n-// min-llvm-version 6.0\n+// min-llvm-version 7.0\n // error-pattern: panicked\n \n // Test that the simd_f{min,max} intrinsics produce the correct results.\n \n #![feature(repr_simd, platform_intrinsics)]\n-#[allow(non_camel_case_types)]\n+#![allow(non_camel_case_types)]\n \n #[repr(simd)]\n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -43,7 +43,6 @@ fn main() {\n         let minn = simd_fmin(y, n);\n         assert_eq!(minn, y);\n \n-        // FIXME(49261)\n         let max0 = simd_fmax(x, y);\n         let max1 = simd_fmax(y, x);\n         assert_eq!(max0, max1);", "previous_filename": "src/test/run-fail/simd-intrinsic-float-minmax.rs"}, {"sha": "54143739a88f931648e5dff6975aecd2d98bed8d", "filename": "src/test/run-pass/simd-intrinsic-generic-gather.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-gather.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2612bbcba08dd81730edd8f2139005fb7a409294/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-gather.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-gather.rs?ref=2612bbcba08dd81730edd8f2139005fb7a409294", "patch": "@@ -0,0 +1,151 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+// min-llvm-version 6.0\n+\n+// Test that the simd_{gather,scatter} intrinsics produce the correct results.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+struct x4<T>(pub T, pub T, pub T, pub T);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_gather<T, U, V>(x: T, y: U, z: V) -> T;\n+    fn simd_scatter<T, U, V>(x: T, y: U, z: V) -> ();\n+}\n+\n+fn main() {\n+    let mut x = [0_f32, 1., 2., 3., 4., 5., 6., 7.];\n+\n+    let default = x4(-3_f32, -3., -3., -3.);\n+    let s_strided = x4(0_f32, 2., -3., 6.);\n+    let mask = x4(-1_i32, -1, 0, -1);\n+\n+    // reading from *const\n+    unsafe {\n+        let pointer = &x[0] as *const f32;\n+        let pointers =  x4(\n+            pointer.offset(0) as *const f32,\n+            pointer.offset(2),\n+            pointer.offset(4),\n+            pointer.offset(6)\n+        );\n+\n+        let r_strided = simd_gather(default, pointers, mask);\n+\n+        assert_eq!(r_strided, s_strided);\n+    }\n+\n+    // reading from *mut\n+    unsafe {\n+        let pointer = &mut x[0] as *mut f32;\n+        let pointers = x4(\n+            pointer.offset(0) as *mut f32,\n+            pointer.offset(2),\n+            pointer.offset(4),\n+            pointer.offset(6)\n+        );\n+\n+        let r_strided = simd_gather(default, pointers, mask);\n+\n+        assert_eq!(r_strided, s_strided);\n+    }\n+\n+    // writing to *mut\n+    unsafe {\n+        let pointer = &mut x[0] as *mut f32;\n+        let pointers = x4(\n+            pointer.offset(0) as *mut f32,\n+            pointer.offset(2),\n+            pointer.offset(4),\n+            pointer.offset(6)\n+        );\n+\n+        let values = x4(42_f32, 43_f32, 44_f32, 45_f32);\n+        simd_scatter(values, pointers, mask);\n+\n+        assert_eq!(x, [42., 1., 43., 3., 4., 5., 45., 7.]);\n+    }\n+\n+    // test modifying array of *const f32\n+    let mut y = [\n+        &x[0] as *const f32,\n+        &x[1] as *const f32,\n+        &x[2] as *const f32,\n+        &x[3] as *const f32,\n+        &x[4] as *const f32,\n+        &x[5] as *const f32,\n+        &x[6] as *const f32,\n+        &x[7] as *const f32\n+    ];\n+\n+    let default = x4(y[0], y[0], y[0], y[0]);\n+    let s_strided = x4(y[0], y[2], y[0], y[6]);\n+\n+    // reading from *const\n+    unsafe {\n+        let pointer = &y[0] as *const *const f32;\n+        let pointers = x4(\n+            pointer.offset(0) as *const *const f32,\n+            pointer.offset(2),\n+            pointer.offset(4),\n+            pointer.offset(6)\n+        );\n+\n+        let r_strided = simd_gather(default, pointers, mask);\n+\n+        assert_eq!(r_strided, s_strided);\n+    }\n+\n+    // reading from *mut\n+    unsafe {\n+        let pointer = &mut y[0] as *mut *const f32;\n+        let pointers = x4(\n+            pointer.offset(0) as *mut *const f32,\n+            pointer.offset(2),\n+            pointer.offset(4),\n+            pointer.offset(6)\n+        );\n+\n+        let r_strided = simd_gather(default, pointers, mask);\n+\n+        assert_eq!(r_strided, s_strided);\n+    }\n+\n+    // writing to *mut\n+    unsafe {\n+        let pointer = &mut y[0] as *mut *const f32;\n+        let pointers = x4(\n+            pointer.offset(0) as *mut *const f32,\n+            pointer.offset(2),\n+            pointer.offset(4),\n+            pointer.offset(6)\n+        );\n+\n+        let values = x4(y[7], y[6], y[5], y[1]);\n+        simd_scatter(values, pointers, mask);\n+\n+        let s = [\n+            &x[7] as *const f32,\n+            &x[1] as *const f32,\n+            &x[6] as *const f32,\n+            &x[3] as *const f32,\n+            &x[4] as *const f32,\n+            &x[5] as *const f32,\n+            &x[1] as *const f32,\n+            &x[7] as *const f32\n+        ];\n+        assert_eq!(y, s);\n+    }\n+}"}]}