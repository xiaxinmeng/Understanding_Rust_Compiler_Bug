{"sha": "f57a28b2dbb1823b88b5db270145a4f324820390", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1N2EyOGIyZGJiMTgyM2I4OGI1ZGIyNzAxNDVhNGYzMjQ4MjAzOTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-10-29T10:12:50Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-09T00:45:49Z"}, "message": "Improve error reporting for region inference failures to make use of\nall the information it has at its disposal. Unfortunately this also\nreveals that we need to improve the reporting heuristics further,\nas sometimes the errors it chooses to emit seem somewhat mystifying\nand are not related to the actual problem.", "tree": {"sha": "44bb201695620e567c8b067b3d71ddf7e2e5fb8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44bb201695620e567c8b067b3d71ddf7e2e5fb8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f57a28b2dbb1823b88b5db270145a4f324820390", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f57a28b2dbb1823b88b5db270145a4f324820390", "html_url": "https://github.com/rust-lang/rust/commit/f57a28b2dbb1823b88b5db270145a4f324820390", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f57a28b2dbb1823b88b5db270145a4f324820390/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "168ac5290e9d4a787e020735f96fa789060a8f76", "url": "https://api.github.com/repos/rust-lang/rust/commits/168ac5290e9d4a787e020735f96fa789060a8f76", "html_url": "https://github.com/rust-lang/rust/commit/168ac5290e9d4a787e020735f96fa789060a8f76"}], "stats": {"total": 194, "additions": 174, "deletions": 20}, "files": [{"sha": "635de28194df9c5fa945965e0b6cf848e1d7c2c7", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 174, "deletions": 20, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/f57a28b2dbb1823b88b5db270145a4f324820390/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f57a28b2dbb1823b88b5db270145a4f324820390/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=f57a28b2dbb1823b88b5db270145a4f324820390", "patch": "@@ -73,6 +73,7 @@ use middle::typeck::infer::region_inference::SubSupConflict;\n use middle::typeck::infer::region_inference::SupSupConflict;\n use syntax::opt_vec::OptVec;\n use util::ppaux::UserString;\n+use util::ppaux::bound_region_to_str;\n use util::ppaux::note_and_explain_region;\n \n pub trait ErrorReporting {\n@@ -110,6 +111,13 @@ pub trait ErrorReporting {\n                                region2: Region);\n }\n \n+trait ErrorReportingHelpers {\n+    fn report_inference_failure(@mut self,\n+                                var_origin: RegionVariableOrigin);\n+\n+    fn note_region_origin(@mut self,\n+                          origin: SubregionOrigin);\n+}\n \n impl ErrorReporting for InferCtxt {\n     fn report_region_errors(@mut self,\n@@ -398,30 +406,23 @@ impl ErrorReporting for InferCtxt {\n                                sub_region: Region,\n                                sup_origin: SubregionOrigin,\n                                sup_region: Region) {\n-        self.tcx.sess.span_err(\n-            var_origin.span(),\n-            format!(\"cannot infer an appropriate lifetime \\\n-                  due to conflicting requirements\"));\n+        self.report_inference_failure(var_origin);\n \n         note_and_explain_region(\n             self.tcx,\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n             \"...\");\n \n-        self.tcx.sess.span_note(\n-            sup_origin.span(),\n-            format!(\"...due to the following expression\"));\n+        self.note_region_origin(sup_origin);\n \n         note_and_explain_region(\n             self.tcx,\n             \"but, the lifetime must be valid for \",\n             sub_region,\n             \"...\");\n \n-        self.tcx.sess.span_note(\n-            sub_origin.span(),\n-            format!(\"...due to the following expression\"));\n+        self.note_region_origin(sub_origin);\n     }\n \n     fn report_sup_sup_conflict(@mut self,\n@@ -430,30 +431,183 @@ impl ErrorReporting for InferCtxt {\n                                region1: Region,\n                                origin2: SubregionOrigin,\n                                region2: Region) {\n-        self.tcx.sess.span_err(\n-            var_origin.span(),\n-            format!(\"cannot infer an appropriate lifetime \\\n-                  due to conflicting requirements\"));\n+        self.report_inference_failure(var_origin);\n \n         note_and_explain_region(\n             self.tcx,\n             \"first, the lifetime must be contained by \",\n             region1,\n             \"...\");\n \n-        self.tcx.sess.span_note(\n-            origin1.span(),\n-            format!(\"...due to the following expression\"));\n+        self.note_region_origin(origin1);\n \n         note_and_explain_region(\n             self.tcx,\n             \"but, the lifetime must also be contained by \",\n             region2,\n             \"...\");\n \n-        self.tcx.sess.span_note(\n-            origin2.span(),\n-            format!(\"...due to the following expression\"));\n+        self.note_region_origin(origin2);\n+    }\n+}\n+\n+impl ErrorReportingHelpers for InferCtxt {\n+    fn report_inference_failure(@mut self,\n+                                var_origin: RegionVariableOrigin) {\n+        let var_description = match var_origin {\n+            infer::MiscVariable(_) => ~\"\",\n+            infer::PatternRegion(_) => ~\" for pattern\",\n+            infer::AddrOfRegion(_) => ~\" for borrow expression\",\n+            infer::AddrOfSlice(_) => ~\" for slice expression\",\n+            infer::Autoref(_) => ~\" for autoref\",\n+            infer::Coercion(_) => ~\" for automatic coercion\",\n+            infer::BoundRegionInFnCall(_, br) => {\n+                format!(\" for {}in function call\",\n+                        bound_region_to_str(self.tcx, \"region \", true, br))\n+            }\n+            infer::BoundRegionInFnType(_, br) => {\n+                format!(\" for {}in function type\",\n+                        bound_region_to_str(self.tcx, \"region \", true, br))\n+            }\n+            infer::BoundRegionInTypeOrImpl(_) => {\n+                format!(\" for region in type/impl\")\n+            }\n+            infer::BoundRegionInCoherence(*) => {\n+                format!(\" for coherence check\")\n+            }\n+        };\n+\n+        self.tcx.sess.span_err(\n+            var_origin.span(),\n+            format!(\"cannot infer an appropriate lifetime{} \\\n+                    due to conflicting requirements\",\n+                    var_description));\n+    }\n+\n+    fn note_region_origin(@mut self,\n+                          origin: SubregionOrigin) {\n+        match origin {\n+            infer::Subtype(ref trace) => {\n+                let desc = match trace.origin {\n+                    infer::Misc(_) => {\n+                        format!(\"types are compatible\")\n+                    }\n+                    infer::MethodCompatCheck(_) => {\n+                        format!(\"method type is compatible with trait\")\n+                    }\n+                    infer::ExprAssignable(_) => {\n+                        format!(\"expression is assignable\")\n+                    }\n+                    infer::RelateTraitRefs(_) => {\n+                        format!(\"traits are compatible\")\n+                    }\n+                    infer::RelateSelfType(_) => {\n+                        format!(\"type matches impl\")\n+                    }\n+                    infer::MatchExpression(_) => {\n+                        format!(\"match arms have compatible types\")\n+                    }\n+                    infer::IfExpression(_) => {\n+                        format!(\"if and else have compatible types\")\n+                    }\n+                };\n+\n+                match self.values_str(&trace.values) {\n+                    Some(values_str) => {\n+                        self.tcx.sess.span_note(\n+                            trace.origin.span(),\n+                            format!(\"...so that {} ({})\",\n+                                    desc, values_str));\n+                    }\n+                    None => {\n+                        // Really should avoid printing this error at\n+                        // all, since it is derived, but that would\n+                        // require more refactoring than I feel like\n+                        // doing right now. - nmatsakis\n+                        self.tcx.sess.span_note(\n+                            trace.origin.span(),\n+                            format!(\"...so that {}\", desc));\n+                    }\n+                }\n+            }\n+            infer::Reborrow(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that borrowed pointer does not outlive \\\n+                    borrowed content\");\n+            }\n+            infer::InfStackClosure(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that closure does not outlive its stack frame\");\n+            }\n+            infer::InvokeClosure(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that closure is not invoked outside its lifetime\");\n+            }\n+            infer::DerefPointer(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that pointer is not dereferenced \\\n+                    outside its lifetime\");\n+            }\n+            infer::FreeVariable(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that captured variable does not outlive the \\\n+                    enclosing closure\");\n+            }\n+            infer::IndexSlice(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that slice is not indexed outside the lifetime\");\n+            }\n+            infer::RelateObjectBound(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that source pointer does not outlive \\\n+                     lifetime bound of the object type\");\n+            }\n+            infer::CallRcvr(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that method receiver is valid for the method call\");\n+            }\n+            infer::CallArg(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that argument is valid for the call\");\n+            }\n+            infer::CallReturn(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that return value is valid for the call\");\n+            }\n+            infer::AddrOf(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that borrowed pointer is valid \\\n+                     at the time of borrow\");\n+            }\n+            infer::AutoBorrow(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that automatically borrowed pointer is valid \\\n+                     at the time of borrow\");\n+            }\n+            infer::BindingTypeIsNotValidAtDecl(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that variable is valid at time of its declaration\");\n+            }\n+            infer::ReferenceOutlivesReferent(_, span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that the pointer does not outlive the \\\n+                    data it points at\");\n+            }\n+        }\n     }\n }\n "}]}