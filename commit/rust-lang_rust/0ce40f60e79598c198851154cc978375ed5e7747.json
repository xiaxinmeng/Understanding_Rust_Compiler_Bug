{"sha": "0ce40f60e79598c198851154cc978375ed5e7747", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjZTQwZjYwZTc5NTk4YzE5ODg1MTE1NGNjOTc4Mzc1ZWQ1ZTc3NDc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-21T11:42:26Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-21T11:47:24Z"}, "message": "Drop support for iter, put, and for-each\n\nCloses #1056", "tree": {"sha": "7630cef97499e29332aa03197994d8733763f342", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7630cef97499e29332aa03197994d8733763f342"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ce40f60e79598c198851154cc978375ed5e7747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ce40f60e79598c198851154cc978375ed5e7747", "html_url": "https://github.com/rust-lang/rust/commit/0ce40f60e79598c198851154cc978375ed5e7747", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ce40f60e79598c198851154cc978375ed5e7747/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "050170d2af94ea81b9b964901e4de7eb79583332", "url": "https://api.github.com/repos/rust-lang/rust/commits/050170d2af94ea81b9b964901e4de7eb79583332", "html_url": "https://github.com/rust-lang/rust/commit/050170d2af94ea81b9b964901e4de7eb79583332"}], "stats": {"total": 560, "additions": 66, "deletions": 494}, "files": [{"sha": "25519a0492384f4288ba5749305f1e322c5788b4", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -251,11 +251,6 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         ret ty::mk_fn(st.tcx, ast::proto_bare, func.args, func.ty, func.cf,\n                       func.cs);\n       }\n-      'W' {\n-        let func = parse_ty_fn(st, sd);\n-        ret ty::mk_fn(st.tcx, ast::proto_iter, func.args, func.ty, func.cf,\n-                      func.cs);\n-      }\n       'B' {\n         let func = parse_ty_fn(st, sd);\n         ret ty::mk_fn(st.tcx, ast::proto_block, func.args, func.ty, func.cf,\n@@ -281,7 +276,6 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         while peek(st) as char != ']' {\n             let proto;\n             alt next(st) as char {\n-              'W' { proto = ast::proto_iter; }\n               'f' { proto = ast::proto_bare; }\n             }\n             let name = \"\";"}, {"sha": "c9c1cf7f7e03675578e22e7a60817db89914d6c5", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -194,7 +194,6 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n }\n fn enc_proto(w: io::writer, proto: proto) {\n     alt proto {\n-      proto_iter. { w.write_char('W'); }\n       proto_shared(_) { w.write_char('F'); }\n       proto_block. { w.write_char('B'); }\n       proto_bare. { w.write_char('f'); }"}, {"sha": "36f6d0f0017e89feb2c2b6c81f5b2259bc888ae6", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -98,23 +98,6 @@ fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n         handled = false;\n       }\n       ast::expr_alt(input, arms) { check_alt(*cx, input, arms, sc, v); }\n-      ast::expr_put(val) {\n-        alt val {\n-          some(ex) {\n-            let root = expr_root(*cx, ex, false);\n-            if !is_none(root.mut) {\n-                cx.tcx.sess.span_err(ex.span,\n-                                     \"result of put must be\" +\n-                                         \" immutably rooted\");\n-            }\n-            visit_expr(cx, ex, sc, v);\n-          }\n-          _ { }\n-        }\n-      }\n-      ast::expr_for_each(decl, call, blk) {\n-        check_for_each(*cx, decl, call, blk, sc, v);\n-      }\n       ast::expr_for(decl, seq, blk) { check_for(*cx, decl, seq, blk, sc, v); }\n       ast::expr_path(pt) {\n         check_var(*cx, ex, pt, ex.id, false, sc);\n@@ -424,21 +407,6 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n     }\n }\n \n-fn check_for_each(cx: ctx, local: @ast::local, call: @ast::expr,\n-                  blk: ast::blk, sc: scope, v: vt<scope>) {\n-    v.visit_expr(call, sc, v);\n-    alt call.node {\n-      ast::expr_call(f, args) {\n-        let new_bs = sc.bs + check_call(cx, f, args);\n-        for proot in pattern_roots(cx.tcx, none, local.node.pat) {\n-            new_bs += [mk_binding(cx, proot.id, proot.span, none,\n-                                  unsafe_set(proot.mut))];\n-        }\n-        visit::visit_block(blk, {bs: new_bs with sc}, v);\n-      }\n-    }\n-}\n-\n fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n              sc: scope, v: vt<scope>) {\n     v.visit_expr(seq, sc, v);"}, {"sha": "0128b3aad98202ce284e0c78d94d93f85f0f2db2", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -41,11 +41,6 @@ fn collect_freevars(def_map: resolve::def_map, walker: fn@(visit::vt<int>)) ->\n                     visit::visit_expr(expr, depth + 1, v);\n                 }\n               }\n-              ast::expr_for_each(dcl, x, b) {\n-                v.visit_local(dcl, depth, v);\n-                v.visit_expr(x, depth, v);\n-                v.visit_block(b, depth + 1, v);\n-              }\n               ast::expr_path(path) {\n                 let def = def_map.get(expr.id), i = 0;\n                 while i < depth {\n@@ -91,21 +86,9 @@ fn annotate_freevars(def_map: resolve::def_map, crate: @ast::crate) ->\n             let vars = collect_freevars(def_map, start_walk);\n             freevars.insert(nid, vars);\n         };\n-    let walk_expr =\n-        lambda (expr: @ast::expr) {\n-            alt expr.node {\n-              ast::expr_for_each(local, _, body) {\n-                let start_walk =\n-                    lambda (v: visit::vt<int>) { v.visit_block(body, 1, v); };\n-                let vars = collect_freevars(def_map, start_walk);\n-                freevars.insert(body.node.id, vars);\n-              }\n-              _ { }\n-            }\n-        };\n \n     let visitor =\n-        visit::mk_simple_visitor(@{visit_fn: walk_fn, visit_expr: walk_expr\n+        visit::mk_simple_visitor(@{visit_fn: walk_fn\n                                       with *visit::default_simple_visitor()});\n     visit::visit_crate(*crate, (), visitor);\n "}, {"sha": "c72dd389227edf538b657f575283a0355859770e", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -37,7 +37,7 @@ tag scope {\n     scope_item(@ast::item);\n     scope_fn(ast::fn_decl, ast::proto, [ast::ty_param]);\n     scope_native_item(@ast::native_item);\n-    scope_loop(@ast::local, bool); // there's only 1 decl per loop.\n+    scope_loop(@ast::local); // there's only 1 decl per loop.\n \n     scope_block(ast::blk, @mutable uint, @mutable uint);\n     scope_arm(ast::arm);\n@@ -381,9 +381,8 @@ fn visit_arm_with_scope(a: ast::arm, sc: scopes, v: vt<scopes>) {\n \n fn visit_expr_with_scope(x: @ast::expr, sc: scopes, v: vt<scopes>) {\n     alt x.node {\n-      ast::expr_for(decl, coll, blk) | ast::expr_for_each(decl, coll, blk) {\n-        let f_e = alt x.node { expr_for_each(_, _, _) { true } _ { false } };\n-        let new_sc = cons(scope_loop(decl, f_e), @sc);\n+      ast::expr_for(decl, coll, blk) {\n+        let new_sc = cons(scope_loop(decl), @sc);\n         v.visit_expr(coll, sc, v);\n         v.visit_local(decl, new_sc, v);\n         v.visit_block(blk, new_sc, v);\n@@ -589,7 +588,6 @@ fn lookup_in_scope_strict(e: env, sc: scopes, sp: span, name: ident,\n \n fn scope_is_fn(sc: scope) -> bool {\n     ret alt sc {\n-          scope_fn(_, ast::proto_iter., _) |\n           scope_fn(_, ast::proto_bare., _) |\n           scope_native_item(_) {\n             true\n@@ -600,7 +598,7 @@ fn scope_is_fn(sc: scope) -> bool {\n \n fn scope_closes(sc: scope) -> option::t<bool> {\n     alt sc {\n-      scope_fn(_, ast::proto_block., _) | scope_loop(_, true) { some(true) }\n+      scope_fn(_, ast::proto_block., _) { some(true) }\n       scope_fn(_, ast::proto_shared(_), _) { some(false) }\n       _ { none }\n     }\n@@ -662,7 +660,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n           scope_fn(decl, _, ty_params) {\n             ret lookup_in_fn(name, decl, ty_params, ns);\n           }\n-          scope_loop(local, _) {\n+          scope_loop(local) {\n             if ns == ns_value {\n                 alt lookup_in_pat(name, local.node.pat) {\n                   some(did) { ret some(ast::def_binding(did)); }"}, {"sha": "6f9456dea2aaad2bcf750b1ba2fe373f43c491e2", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 21, "deletions": 225, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -82,7 +82,7 @@ fn type_of_explicit_args(cx: @crate_ctxt, sp: span, inputs: [ty::arg]) ->\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn type_of_fn(cx: @crate_ctxt, sp: span, proto: ast::proto,\n+fn type_of_fn(cx: @crate_ctxt, sp: span,\n               is_method: bool, ret_ref: bool, inputs: [ty::arg],\n               output: ty::t, ty_param_count: uint)\n    : non_ty_var(cx, output) -> TypeRef {\n@@ -102,18 +102,6 @@ fn type_of_fn(cx: @crate_ctxt, sp: span, proto: ast::proto,\n         let i = 0u;\n         while i < ty_param_count { atys += [T_ptr(cx.tydesc_type)]; i += 1u; }\n     }\n-    if proto == ast::proto_iter {\n-        // If it's an iter, the 'output' type of the iter is actually the\n-        // *input* type of the function we're given as our iter-block\n-        // argument.\n-        let iter_body_ty = ty::mk_iter_body_fn(cx.tcx, output);\n-        // FIXME: this check could be avoided pretty easily if we had\n-        // postconditions\n-        // (or better yet, just use a constraiend type that expresses\n-        // non-ty-var things)\n-        check non_ty_var(cx, iter_body_ty);\n-        atys += [type_of_inner(cx, sp, iter_body_ty)];\n-    }\n     // ... then explicit args.\n     atys += type_of_explicit_args(cx, sp, inputs);\n     ret T_fn(atys, llvm::LLVMVoidType());\n@@ -129,8 +117,7 @@ fn type_of_fn_from_ty(cx: @crate_ctxt, sp: span, fty: ty::t,\n     // (see Issue #586)\n     let ret_ty = ty::ty_fn_ret(cx.tcx, fty);\n     check non_ty_var(cx, ret_ty);\n-    ret type_of_fn(cx, sp, ty::ty_fn_proto(cx.tcx, fty),\n-                   false, by_ref, ty::ty_fn_args(cx.tcx, fty),\n+    ret type_of_fn(cx, sp, false, by_ref, ty::ty_fn_args(cx.tcx, fty),\n                    ret_ty, ty_param_count);\n }\n \n@@ -2739,12 +2726,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n fn build_closure(cx: @block_ctxt, upvars: @[ast::def], copying: bool) ->\n    {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n     // If we need to, package up the iterator body to call\n-    let env_vals = alt cx.fcx.lliterbody {\n-      some(body) when !copying {\n-        [env_direct(body, option::get(cx.fcx.iterbodyty), true)]\n-      }\n-      _ { [] }\n-    };\n+    let env_vals = [];\n     // Package up the upvars\n     for def in *upvars {\n         let lv = trans_local_var(cx, def);\n@@ -2819,17 +2801,6 @@ fn load_environment(enclosing_cx: @block_ctxt, fcx: @fn_ctxt, envty: ty::t,\n     // Populate the upvars from the environment.\n     let path = [0, abi::box_rc_field_body, abi::closure_elt_bindings];\n     i = 0u;\n-    // If this is an aliasing closure/for-each body, we need to load\n-    // the iterbody.\n-    if !copying && !option::is_none(enclosing_cx.fcx.lliterbody) {\n-        // Silly check\n-        check type_is_tup_like(bcx, ty);\n-        let iterbodyptr = GEP_tup_like(bcx, ty, llclosure, path + [0]);\n-        fcx.lliterbody = some(Load(bcx, iterbodyptr.val));\n-        bcx = iterbodyptr.bcx;\n-        i += 1u;\n-    }\n-\n     // Load the actual upvars.\n     for upvar_def in *upvars {\n         // Silly check\n@@ -2844,86 +2815,6 @@ fn load_environment(enclosing_cx: @block_ctxt, fcx: @fn_ctxt, envty: ty::t,\n     }\n }\n \n-fn trans_for_each(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n-                  body: ast::blk) -> @block_ctxt {\n-    /*\n-     * The translation is a little .. complex here. Code like:\n-     *\n-     *    let ty1 p = ...;\n-     *\n-     *    let ty1 q = ...;\n-     *\n-     *    foreach (ty v in foo(a,b)) { body(p,q,v) }\n-     *\n-     *\n-     * Turns into a something like so (C/Rust mishmash):\n-     *\n-     *    type env = { *ty1 p, *ty2 q, ... };\n-     *\n-     *    let env e = { &p, &q, ... };\n-     *\n-     *    fn foreach123_body(env* e, ty v) { body(*(e->p),*(e->q),v) }\n-     *\n-     *    foo([foreach123_body, env*], a, b);\n-     *\n-     */\n-\n-    // Step 1: Generate code to build an environment containing pointers\n-    // to all of the upvars\n-    let lcx = cx.fcx.lcx;\n-    let ccx = lcx.ccx;\n-\n-    // FIXME: possibly support alias-mode here?\n-    let decl_ty = node_id_type(ccx, local.node.id);\n-    let upvars = get_freevars(ccx.tcx, body.node.id);\n-\n-    let llenv = build_closure(cx, upvars, false);\n-\n-    // Step 2: Declare foreach body function.\n-    let s: str =\n-        mangle_internal_name_by_path_and_seq(ccx, lcx.path, \"foreach\");\n-\n-    // The 'env' arg entering the body function is a fake env member (as in\n-    // the env-part of the normal rust calling convention) that actually\n-    // points to a stack allocated env in this frame. We bundle that env\n-    // pointer along with the foreach-body-fn pointer into a 'normal' fn pair\n-    // and pass it in as a first class fn-arg to the iterator.\n-    let iter_body_fn = ty::mk_iter_body_fn(ccx.tcx, decl_ty);\n-    // FIXME: should be a postcondition on mk_iter_body_fn\n-    check returns_non_ty_var(ccx, iter_body_fn);\n-    let iter_body_llty =\n-        type_of_fn_from_ty(ccx, cx.sp, iter_body_fn, 0u);\n-    let lliterbody: ValueRef =\n-        decl_internal_cdecl_fn(ccx.llmod, s, iter_body_llty);\n-    let fcx = new_fn_ctxt_w_id(lcx, cx.sp, lliterbody, body.node.id,\n-                               ast::return_val);\n-    fcx.iterbodyty = cx.fcx.iterbodyty;\n-\n-    // Generate code to load the environment out of the\n-    // environment pointer.\n-    load_environment(cx, fcx, llenv.ptrty, upvars, false);\n-\n-    let bcx = new_top_block_ctxt(fcx);\n-    // Add bindings for the loop variable alias.\n-    bcx = trans_alt::bind_irrefutable_pat(bcx, local.node.pat,\n-                                          llvm::LLVMGetParam(fcx.llfn, 2u),\n-                                          false);\n-    let lltop = bcx.llbb;\n-    bcx = trans_block(bcx, body);\n-    finish_fn(fcx, lltop);\n-\n-    build_return(bcx);\n-\n-    // Step 3: Call iter passing [lliterbody, llenv], plus other args.\n-    alt seq.node {\n-      ast::expr_call(f, args) {\n-        let pair =\n-            create_real_fn_pair(cx, iter_body_llty, lliterbody, llenv.ptr);\n-        ret trans_call(cx, f, some(pair), args, seq.id, ignore);\n-      }\n-    }\n-}\n-\n fn trans_while(cx: @block_ctxt, cond: @ast::expr, body: ast::blk)\n     -> @block_ctxt {\n     let next_cx = new_sub_block_ctxt(cx, \"while next\");\n@@ -3151,9 +3042,8 @@ fn trans_object_field_inner(bcx: @block_ctxt, o: ValueRef,\n     // FIXME: constrain ty_obj?\n     check non_ty_var(ccx, ret_ty);\n \n-    let ll_fn_ty = type_of_fn(ccx, bcx.sp, ty::ty_fn_proto(tcx, fn_ty),\n-                              true, ret_ref, ty::ty_fn_args(tcx, fn_ty),\n-                              ret_ty, 0u);\n+    let ll_fn_ty = type_of_fn(ccx, bcx.sp, true, ret_ref,\n+                              ty::ty_fn_args(tcx, fn_ty), ret_ty, 0u);\n     v = Load(bcx, PointerCast(bcx, v, T_ptr(T_ptr(ll_fn_ty))));\n     ret {bcx: bcx, mthptr: v, objptr: o};\n }\n@@ -3310,7 +3200,7 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n       // This is a by-ref returning call. Regular calls are not lval\n       ast::expr_call(f, args) {\n         let cell = empty_dest_cell();\n-        let bcx = trans_call(cx, f, none, args, e.id, by_val(cell));\n+        let bcx = trans_call(cx, f, args, e.id, by_val(cell));\n         ret lval_owned(bcx, *cell);\n       }\n       _ { bcx_ccx(cx).sess.span_bug(e.span, \"non-lval in trans_lval\"); }\n@@ -3762,8 +3652,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n //  - new_fn_ctxt\n //  - trans_args\n fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n-              gen: option::t<generic_info>,\n-              lliterbody: option::t<ValueRef>, es: [@ast::expr], fn_ty: ty::t,\n+              gen: option::t<generic_info>, es: [@ast::expr], fn_ty: ty::t,\n               dest: dest)\n    -> {bcx: @block_ctxt,\n        outer_cx: @block_ctxt,\n@@ -3802,8 +3691,7 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n     } else {\n         alt dest {\n           ignore. {\n-            if ty::type_is_nil(tcx, retty) ||\n-               !option::is_none(lliterbody) {\n+            if ty::type_is_nil(tcx, retty) {\n                 llvm::LLVMGetUndef(T_ptr(llretty))\n             } else { alloca(cx, llretty) }\n           }\n@@ -3830,21 +3718,6 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n     // Args >2: ty_params ...\n     llargs += lltydescs;\n \n-    // ... then possibly an lliterbody argument.\n-    alt lliterbody {\n-      none. { }\n-      some(lli) {\n-        let lli =\n-            if ty::type_contains_params(tcx, retty) {\n-                let body_ty = ty::mk_iter_body_fn(tcx, retty);\n-                check non_ty_var(ccx, body_ty);\n-                let body_llty = type_of_inner(ccx, cx.sp, body_ty);\n-                PointerCast(bcx, lli, T_ptr(body_llty))\n-            } else { lli };\n-        llargs += [Load(cx, lli)];\n-      }\n-    }\n-\n     // ... then explicit args.\n \n     // First we figure out the caller's view of the types of the arguments.\n@@ -3873,8 +3746,8 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n }\n \n fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n-              lliterbody: option::t<ValueRef>, args: [@ast::expr],\n-              id: ast::node_id, dest: dest) -> @block_ctxt {\n+              args: [@ast::expr], id: ast::node_id, dest: dest)\n+    -> @block_ctxt {\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n     // with trans_call.\n@@ -3911,8 +3784,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n \n     let ret_ty = ty::node_id_to_type(tcx, id);\n     let args_res =\n-        trans_args(bcx, in_cx, llenv, f_res.generic, lliterbody, args,\n-                   fn_expr_ty, dest);\n+        trans_args(bcx, in_cx, llenv, f_res.generic, args, fn_expr_ty, dest);\n     Br(args_res.outer_cx, cx.llbb);\n     bcx = args_res.bcx;\n     let llargs = args_res.args;\n@@ -4304,7 +4176,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         ret trans_anon_obj(bcx, e.span, anon_obj, e.id, dest);\n       }\n       ast::expr_call(f, args) {\n-        ret trans_call(bcx, f, none, args, e.id, dest);\n+        ret trans_call(bcx, f, args, e.id, dest);\n       }\n       ast::expr_field(_, _) {\n         fail \"Taking the value of a method does not work yet (issue #435)\";\n@@ -4331,10 +4203,6 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         check (ast_util::is_call_expr(ex));\n         ret trans_be(bcx, ex);\n       }\n-      ast::expr_put(ex) {\n-        assert dest == ignore;\n-        ret trans_put(bcx, ex);\n-      }\n       ast::expr_fail(expr) {\n         assert dest == ignore;\n         ret trans_fail_expr(bcx, some(e.span), expr);\n@@ -4375,10 +4243,6 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         assert dest == ignore;\n         ret trans_for(bcx, decl, seq, body);\n       }\n-      ast::expr_for_each(decl, seq, body) {\n-        assert dest == ignore;\n-        ret trans_for_each(bcx, decl, seq, body);\n-      }\n       ast::expr_while(cond, body) {\n         assert dest == ignore;\n         ret trans_while(bcx, cond, body);\n@@ -4591,47 +4455,6 @@ fn trans_fail_value(bcx: @block_ctxt, sp_opt: option::t<span>,\n     ret bcx;\n }\n \n-fn trans_put(in_cx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n-    let cx = new_scope_block_ctxt(in_cx, \"put\");\n-    Br(in_cx, cx.llbb);\n-    let llcallee = C_nil();\n-    let llenv = C_nil();\n-    alt cx.fcx.lliterbody {\n-      some(lli) {\n-        let slot = alloca(cx, val_ty(lli));\n-        Store(cx, lli, slot);\n-        llcallee = GEP(cx, slot, [C_int(0), C_int(abi::fn_field_code)]);\n-        llcallee = Load(cx, llcallee);\n-        llenv = GEP(cx, slot, [C_int(0), C_int(abi::fn_field_box)]);\n-        llenv = Load(cx, llenv);\n-      }\n-    }\n-    let bcx = cx;\n-    let dummy_retslot = alloca(bcx, T_nil());\n-    let llargs: [ValueRef] = [dummy_retslot, llenv];\n-    alt e {\n-      none. {\n-        llargs += [C_null(T_ptr(T_nil()))];\n-      }\n-      some(x) {\n-        let e_ty = ty::expr_ty(bcx_tcx(cx), x);\n-        let arg = {mode: ast::by_ref, ty: e_ty};\n-        let arg_tys = type_of_explicit_args(bcx_ccx(cx), x.span, [arg]);\n-        let z = [];\n-        let k = [];\n-        let r = trans_arg_expr(bcx, arg, arg_tys[0], z, k, x);\n-        bcx = r.bcx;\n-        llargs += [r.val];\n-      }\n-    }\n-    bcx = invoke(bcx, llcallee, llargs);\n-    bcx = trans_block_cleanups(bcx, cx);\n-    let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n-    if bcx.unreachable { Unreachable(next_cx); }\n-    Br(bcx, next_cx.llbb);\n-    ret next_cx;\n-}\n-\n fn trans_break_cont(sp: span, bcx: @block_ctxt, to_end: bool)\n     -> @block_ctxt {\n     // Locate closest loop block, outputting cleanup as we go.\n@@ -5086,8 +4909,6 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: span, llfndecl: ValueRef,\n           mutable llreturn: llbbs.rt,\n           mutable llobstacktoken: none::<ValueRef>,\n           mutable llself: none::<val_self_pair>,\n-          mutable lliterbody: none::<ValueRef>,\n-          mutable iterbodyty: none::<ty::t>,\n           llargs: new_int_hash::<local_val>(),\n           llobjfields: new_int_hash::<ValueRef>(),\n           lllocals: new_int_hash::<local_val>(),\n@@ -5118,8 +4939,7 @@ fn new_fn_ctxt(cx: @local_ctxt, sp: span, llfndecl: ValueRef) -> @fn_ctxt {\n // spaces that have been created for them (by code in the llallocas field of\n // the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n // field of the fn_ctxt with\n-fn create_llargs_for_fn_args(cx: @fn_ctxt, proto: ast::proto,\n-                             ty_self: option::t<ty::t>, ret_ty: ty::t,\n+fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: option::t<ty::t>,\n                              args: [ast::arg], ty_params: [ast::ty_param]) {\n     // Skip the implicit arguments 0, and 1.  TODO: Pull out 2u and define\n     // it as a constant, since we're using it in several places in trans this\n@@ -5139,17 +4959,6 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, proto: ast::proto,\n       }\n     }\n \n-    // If the function is actually an iter, populate the lliterbody field of\n-    // the function context with the ValueRef that we get from\n-    // llvm::LLVMGetParam for the iter's body.\n-    if proto == ast::proto_iter {\n-        cx.iterbodyty = some(ty::mk_iter_body_fn(fcx_tcx(cx), ret_ty));\n-        let llarg = llvm::LLVMGetParam(cx.llfn, arg_n);\n-        assert (llarg as int != 0);\n-        cx.lliterbody = some::<ValueRef>(llarg);\n-        arg_n += 1u;\n-    }\n-\n     // Populate the llargs field of the function context with the ValueRefs\n     // that we get from llvm::LLVMGetParam for each argument.\n     for arg: ast::arg in args {\n@@ -5282,9 +5091,7 @@ fn trans_closure(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n \n     // Set up arguments to the function.\n     let fcx = new_fn_ctxt_w_id(cx, sp, llfndecl, id, f.decl.cf);\n-    create_llargs_for_fn_args(fcx, f.proto, ty_self,\n-                              ty::ret_ty_of_fn(cx.ccx.tcx, id), f.decl.inputs,\n-                              ty_params);\n+    create_llargs_for_fn_args(fcx, ty_self, f.decl.inputs, ty_params);\n     alt fcx.llself {\n       some(llself) { populate_fn_ctxt_from_llself(fcx, llself); }\n       _ { }\n@@ -5307,7 +5114,6 @@ fn trans_closure(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n     // (trans_block, trans_expr, et cetera).\n     if ty::type_is_bot(cx.ccx.tcx, block_ty) ||\n        ty::type_is_nil(cx.ccx.tcx, block_ty) ||\n-       f.proto == ast::proto_iter ||\n        option::is_none(f.body.node.expr) {\n         bcx = trans_block_dps(bcx, f.body, ignore);\n     } else if ty::type_is_immediate(cx.ccx.tcx, block_ty) {\n@@ -5349,9 +5155,7 @@ fn trans_res_ctor(cx: @local_ctxt, sp: span, dtor: ast::_fn,\n     }\n     let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n     let ret_t = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n-    create_llargs_for_fn_args(fcx, ast::proto_shared(ast::sugar_normal),\n-                              none::<ty::t>, ret_t,\n-                              dtor.decl.inputs, ty_params);\n+    create_llargs_for_fn_args(fcx, none, dtor.decl.inputs, ty_params);\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n     let arg_t = arg_tys_of_fn(cx.ccx, ctor_id)[0].ty;\n@@ -5410,10 +5214,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n       }\n     }\n     let fcx = new_fn_ctxt(cx, variant.span, llfndecl);\n-    create_llargs_for_fn_args(fcx, ast::proto_shared(ast::sugar_normal),\n-                              none::<ty::t>,\n-                              ty::ret_ty_of_fn(cx.ccx.tcx, variant.node.id),\n-                              fn_args, ty_params);\n+    create_llargs_for_fn_args(fcx, none, fn_args, ty_params);\n     let ty_param_substs: [ty::t] = [];\n     i = 0u;\n     for tp: ast::ty_param in ty_params {\n@@ -5573,11 +5374,10 @@ fn register_fn_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n     let llfty =\n         type_of_fn_from_ty(ccx, sp, node_type, std::vec::len(ty_params));\n     alt ty::struct(ccx.tcx, node_type) {\n-      ty::ty_fn(proto, inputs, output, rs, _) {\n+      ty::ty_fn(_, inputs, output, rs, _) {\n         check non_ty_var(ccx, output);\n-        llfty = type_of_fn(ccx, sp, proto, false,\n-                           ast_util::ret_by_ref(rs), inputs, output,\n-                           vec::len(ty_params));\n+        llfty = type_of_fn(ccx, sp, false, ast_util::ret_by_ref(rs), inputs,\n+                           output, vec::len(ty_params));\n       }\n       _ { ccx.sess.bug(\"register_fn(): fn item doesn't have fn type!\"); }\n     }\n@@ -5618,9 +5418,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let nt = ty::mk_nil(ccx.tcx);\n         check non_ty_var(ccx, nt);\n \n-        let llfty = type_of_fn(ccx, sp, ast::proto_shared(ast::sugar_normal),\n-                               false, false,\n-                               [vecarg_ty], nt, 0u);\n+        let llfty = type_of_fn(ccx, sp, false, false, [vecarg_ty], nt, 0u);\n         let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n                               lib::llvm::LLVMCCallConv, llfty);\n \n@@ -5732,9 +5530,7 @@ fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span, ty_param_count: uint,\n     alt ty::struct(cx.tcx, x) {\n       ty::ty_native_fn(abi, args, out) {\n         check non_ty_var(cx, out);\n-        ret type_of_fn(cx, sp, ast::proto_shared(ast::sugar_normal),\n-                       false, false, args, out,\n-                       ty_param_count);\n+        ret type_of_fn(cx, sp, false, false, args, out, ty_param_count);\n       }\n     }\n }"}, {"sha": "218de8124dcbcb6dc1aac32bbedc5f6b3e16abd0", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -191,12 +191,6 @@ type fn_ctxt =\n     // If this function is actually a iter, a block containing the\n     // code called whenever the iter calls 'put'.\n \n-    // If this function is actually a iter, the type of the function\n-    // that that we call when we call 'put'. Having to track this is\n-    // pretty irritating. We have to do it because we need the type if\n-    // we are going to put the iterbody into a closure (if it appears\n-    // in a for-each inside of an iter).\n-\n     // The next four items: hash tables mapping from AST def_ids to\n     // LLVM-stuff-in-the-frame.\n \n@@ -245,8 +239,6 @@ type fn_ctxt =\n      mutable llreturn: BasicBlockRef,\n      mutable llobstacktoken: option::t<ValueRef>,\n      mutable llself: option::t<val_self_pair>,\n-     mutable lliterbody: option::t<ValueRef>,\n-     mutable iterbodyty: option::t<ty::t>,\n      llargs: hashmap<ast::node_id, local_val>,\n      llobjfields: hashmap<ast::node_id, ValueRef>,\n      lllocals: hashmap<ast::node_id, local_val>,\n@@ -340,8 +332,7 @@ fn get_res_dtor(ccx: @crate_ctxt, sp: span, did: ast::def_id, inner_t: ty::t)\n     let nil_res = ty::mk_nil(ccx.tcx);\n     // FIXME: Silly check -- mk_nil should have a postcondition\n     check non_ty_var(ccx, nil_res);\n-    let f_t = type_of_fn(ccx, sp, ast::proto_shared(ast::sugar_normal),\n-                         false, false,\n+    let f_t = type_of_fn(ccx, sp, false, false,\n                          [{mode: ast::by_ref, ty: inner_t}],\n                          nil_res, params);\n     ret trans::get_extern_const(ccx.externs, ccx.llmod,"}, {"sha": "ea3947a32ed715bf6963b971230a9e54c8aef058", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -52,10 +52,7 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n     let lltop = bcx.llbb;\n \n     // Both regular arguments and type parameters are handled here.\n-    create_llargs_for_fn_args(fcx, ast::proto_shared(ast::sugar_normal),\n-                              none::<ty::t>,\n-                              ty::ret_ty_of_fn(ccx.tcx, ctor_id), fn_args,\n-                              ty_params);\n+    create_llargs_for_fn_args(fcx, none::<ty::t>, fn_args, ty_params);\n     let arg_tys: [ty::arg] = arg_tys_of_fn(ccx, ctor_id);\n     bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys, true);\n \n@@ -888,9 +885,9 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n     let llfnty = T_nil();\n     let ccx = cx.ccx;\n     alt ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id)) {\n-      ty::ty_fn(proto, inputs, output, rs, _) {\n+      ty::ty_fn(_, inputs, output, rs, _) {\n         check non_ty_var(ccx, output);\n-        llfnty = type_of_fn(ccx, m.span, proto, true,\n+        llfnty = type_of_fn(ccx, m.span, true,\n                             ast_util::ret_by_ref(rs), inputs, output,\n                             vec::len(ty_params));\n       }\n@@ -944,7 +941,7 @@ fn type_of_meth(ccx: @crate_ctxt, sp: span, m: @ty::method,\n                 tps: [ast::ty_param]) -> TypeRef {\n     let out_ty = m.output;\n     check non_ty_var(ccx, out_ty);\n-    type_of_fn(ccx, sp, m.proto, true, ast_util::ret_by_ref(m.cf),\n+    type_of_fn(ccx, sp, true, ast_util::ret_by_ref(m.cf),\n                m.inputs, out_ty, vec::len(tps))\n }\n "}, {"sha": "42bfe2f4db9e2bf1b91443885426266ed9d313d2", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -117,10 +117,9 @@ fn check_states_against_conditions(fcx: fn_ctxt, f: _fn, tps: [ast::ty_param],\n \n     /* Check that the return value is initialized */\n     let post = aux::block_poststate(fcx.ccx, f.body);\n-    if f.proto != ast::proto_iter &&\n-           !promises(fcx, post, fcx.enclosing.i_return) &&\n-           !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n-           f.decl.cf == return_val {\n+    if !promises(fcx, post, fcx.enclosing.i_return) &&\n+       !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n+       f.decl.cf == return_val {\n         fcx.ccx.tcx.sess.span_err(f.body.span,\n                                   \"In function \" + fcx.name +\n                                       \", not all control paths \\"}, {"sha": "dee66e6df4dc791aa720cee5757b1c7877f7c705", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -343,15 +343,6 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         find_pre_post_expr(fcx, arg);\n         copy_pre_post(fcx.ccx, e.id, arg);\n       }\n-      expr_put(opt) {\n-        alt opt {\n-          some(arg) {\n-            find_pre_post_expr(fcx, arg);\n-            copy_pre_post(fcx.ccx, e.id, arg);\n-          }\n-          none. { clear_pp(expr_pp(fcx.ccx, e)); }\n-        }\n-      }\n       expr_fn(f) {\n         let rslt = expr_pp(fcx.ccx, e);\n         clear_pp(rslt);\n@@ -459,14 +450,6 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_for(d, index, body) {\n         find_pre_post_loop(fcx, d, index, body, e.id);\n       }\n-      expr_for_each(d, index, body) {\n-        find_pre_post_loop(fcx, d, index, body, e.id);\n-        let rslt = expr_pp(fcx.ccx, e);\n-        clear_pp(rslt);\n-        for def in *freevars::get_freevars(fcx.ccx.tcx, body.node.id) {\n-            handle_var_def(fcx, rslt, def, \"upvar\");\n-        }\n-      }\n       expr_index(val, sub) { find_pre_post_exprs(fcx, [val, sub], e.id); }\n       expr_alt(ex, alts) {\n         find_pre_post_expr(fcx, ex);"}, {"sha": "39f87f0f11458b6150dae4bcccf460fc02f2c476", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -361,14 +361,6 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         ret find_pre_post_state_sub(fcx, pres, ex, e.id, none);\n       }\n       expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n-      expr_put(maybe_e) {\n-        alt maybe_e {\n-          some(arg) {\n-            ret find_pre_post_state_sub(fcx, pres, arg, e.id, none);\n-          }\n-          none. { ret pure_exp(fcx.ccx, e.id, pres); }\n-        }\n-      }\n       expr_lit(l) { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_fn(f) { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_block(b) {\n@@ -530,9 +522,6 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       expr_for(d, index, body) {\n         ret find_pre_post_state_loop(fcx, pres, d, index, body, e.id);\n       }\n-      expr_for_each(d, index, body) {\n-        ret find_pre_post_state_loop(fcx, pres, d, index, body, e.id);\n-      }\n       expr_index(val, sub) {\n         ret find_pre_post_state_two(fcx, pres, val, sub, e.id, oper_pure);\n       }"}, {"sha": "305d05a5b5d8280a91c05481dd3f252579f646a3", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -1010,7 +1010,6 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n       // here yet, leading to weirdness around closure.\n       ty_fn(proto, _, _, _, _) {\n         result = alt proto {\n-          ast::proto_iter. { ast::kind_shared }\n           ast::proto_block. { ast::kind_pinned }\n           ast::proto_shared(_) { ast::kind_shared }\n           ast::proto_bare. { ast::kind_unique }\n@@ -2042,14 +2041,7 @@ mod unify {\n             }\n         }\n \n-        ret if (e_proto == ast::proto_iter\n-            || a_proto == ast::proto_iter) {\n-            if e_proto != a_proto {\n-                some(ures_err(terr_mismatch))\n-            } else {\n-                none\n-            }\n-        } else if e_proto == a_proto {\n+        ret if e_proto == a_proto {\n             none\n         } else if variance == invariant {\n             if e_proto != a_proto {"}, {"sha": "7e4c80d5a2791642a3194a2e57d1e144cce2e007", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 15, "deletions": 68, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -1560,8 +1560,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     // A generic function to factor out common logic from call and bind\n     // expressions.\n     fn check_call_or_bind(fcx: @fn_ctxt, sp: span, f: @ast::expr,\n-                          args: [option::t<@ast::expr>], call_kind: call_kind)\n-       -> bool {\n+                          args: [option::t<@ast::expr>]) -> bool {\n         // Check the function.\n         let bot = check_expr(fcx, f);\n \n@@ -1570,22 +1569,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n         let sty = structure_of(fcx, sp, fty);\n \n-        // Check that we aren't confusing iter calls and fn calls\n-        alt sty {\n-          ty::ty_fn(ast::proto_iter., _, _, _, _) {\n-            if call_kind != kind_for_each {\n-                fcx.ccx.tcx.sess.span_err\n-                    (sp, \"calling iter outside of for each loop\");\n-            }\n-          }\n-          _ {\n-            if call_kind == kind_for_each {\n-                fcx.ccx.tcx.sess.span_err\n-                    (sp, \"calling non-iter as sequence of for each loop\");\n-            }\n-          }\n-        }\n-\n         // Grab the argument types\n         let arg_tys =\n             alt sty {\n@@ -1669,27 +1652,26 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     }\n \n     // A generic function for checking call expressions\n-    fn check_call(fcx: @fn_ctxt, sp: span, f: @ast::expr, args: [@ast::expr],\n-                  call_kind: call_kind) -> bool {\n+    fn check_call(fcx: @fn_ctxt, sp: span, f: @ast::expr, args: [@ast::expr])\n+        -> bool {\n         let args_opt_0: [option::t<@ast::expr>] = [];\n         for arg: @ast::expr in args {\n             args_opt_0 += [some::<@ast::expr>(arg)];\n         }\n \n         // Call the generic checker.\n-        ret check_call_or_bind(fcx, sp, f, args_opt_0, call_kind);\n+        ret check_call_or_bind(fcx, sp, f, args_opt_0);\n     }\n \n     // A generic function for doing all of the checking for call expressions\n     fn check_call_full(fcx: @fn_ctxt, sp: span, f: @ast::expr,\n-                       args: [@ast::expr], call_kind: call_kind,\n-                       id: ast::node_id) -> bool {\n+                       args: [@ast::expr], id: ast::node_id) -> bool {\n         /* here we're kind of hosed, as f can be any expr\n         need to restrict it to being an explicit expr_path if we're\n         inside a pure function, and need an environment mapping from\n         function name onto purity-designation */\n         require_pure_call(fcx.ccx, fcx.purity, f, sp);\n-        let bot = check_call(fcx, sp, f, args, call_kind);\n+        let bot = check_call(fcx, sp, f, args);\n \n         // Pull the return type out of the type of the function.\n         let rt_1;\n@@ -1707,9 +1689,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     }\n \n     // A generic function for checking for or for-each loops\n-    fn check_for_or_for_each(fcx: @fn_ctxt, local: @ast::local,\n-                             element_ty: ty::t, body: ast::blk,\n-                             node_id: ast::node_id) -> bool {\n+    fn check_for(fcx: @fn_ctxt, local: @ast::local,\n+                 element_ty: ty::t, body: ast::blk,\n+                 node_id: ast::node_id) -> bool {\n         let locid = lookup_local(fcx, local.span, local.node.id);\n         element_ty =\n             demand::simple(fcx, local.span, element_ty,\n@@ -1893,23 +1875,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         }\n         write::bot_ty(tcx, id);\n       }\n-      ast::expr_put(expr_opt) {\n-        require_impure(tcx.sess, fcx.purity, expr.span);\n-        if fcx.proto != ast::proto_iter {\n-            tcx.sess.span_err(expr.span, \"put in non-iterator\");\n-        }\n-        alt expr_opt {\n-          none. {\n-            let nil = ty::mk_nil(tcx);\n-            if !are_compatible(fcx, fcx.ret_ty, nil) {\n-                tcx.sess.span_err(expr.span,\n-                                  \"put; in iterator yielding non-nil\");\n-            }\n-          }\n-          some(e) { bot = check_expr_with(fcx, e, fcx.ret_ty); }\n-        }\n-        write::nil_ty(tcx, id);\n-      }\n       ast::expr_be(e) {\n         // FIXME: prove instead of assert\n         assert (ast_util::is_call_expr(e));\n@@ -1979,21 +1944,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                 + \"but found \" + ty_to_str(tcx, ety));\n           }\n         }\n-        bot |= check_for_or_for_each(fcx, decl, elt_ty, body, id);\n-      }\n-      ast::expr_for_each(decl, seq, body) {\n-        alt seq.node {\n-          ast::expr_call(f, args) {\n-            bot =\n-                check_call_full(fcx, seq.span, f, args, kind_for_each,\n-                                seq.id);\n-          }\n-          _ {\n-            tcx.sess.span_fatal(expr.span,\n-                                \"sequence in for each loop not a call\");\n-          }\n-        }\n-        bot |= check_for_or_for_each(fcx, decl, expr_ty(tcx, seq), body, id);\n+        bot |= check_for(fcx, decl, elt_ty, body, id);\n       }\n       ast::expr_while(cond, body) {\n         bot = check_expr_with(fcx, cond, ty::mk_bool(tcx));\n@@ -2069,7 +2020,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_bind(f, args) {\n         // Call the generic checker.\n-        bot = check_call_or_bind(fcx, expr.span, f, args, kind_bind);\n+        bot = check_call_or_bind(fcx, expr.span, f, args);\n \n         // Pull the argument and return types out.\n         let proto, arg_tys, rt, cf, constrs;\n@@ -2122,7 +2073,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         write::ty_only_fixup(fcx, id, ft);\n       }\n       ast::expr_call(f, args) {\n-        bot = check_call_full(fcx, expr.span, f, args, kind_call, expr.id);\n+        bot = check_call_full(fcx, expr.span, f, args, expr.id);\n       }\n       ast::expr_self_method(ident) {\n         let t = ty::mk_nil(tcx);\n@@ -2716,16 +2667,12 @@ fn check_fn(ccx: @crate_ctxt, f: ast::_fn, id: ast::node_id,\n     check_constraints(fcx, decl.constraints, decl.inputs);\n     check_block(fcx, body);\n \n-    // For non-iterator fns, we unify the tail expr's type with the\n+    // We unify the tail expr's type with the\n     // function result type, if there is a tail expr.\n-    // We don't do this check for an iterator, as the tail expr doesn't\n-    // have to have the result type of the iterator.\n     alt body.node.expr {\n       some(tail_expr) {\n-        if f.proto != ast::proto_iter {\n-            let tail_expr_ty = expr_ty(ccx.tcx, tail_expr);\n-            demand::simple(fcx, tail_expr.span, fcx.ret_ty, tail_expr_ty);\n-        }\n+        let tail_expr_ty = expr_ty(ccx.tcx, tail_expr);\n+        demand::simple(fcx, tail_expr.span, fcx.ret_ty, tail_expr_ty);\n       }\n       none. { }\n     }"}, {"sha": "a971653c5f11c2e4078af725e2d12cf0bc575976", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -109,7 +109,6 @@ tag proto_sugar {\n }\n \n tag proto {\n-    proto_iter;\n     proto_bare;\n     proto_shared(proto_sugar);\n     proto_block;\n@@ -197,7 +196,6 @@ tag expr_ {\n     expr_ternary(@expr, @expr, @expr);\n     expr_while(@expr, blk);\n     expr_for(@local, @expr, blk);\n-    expr_for_each(@local, @expr, blk);\n     expr_do_while(blk, @expr);\n     expr_alt(@expr, [arm]);\n     expr_fn(_fn);\n@@ -219,7 +217,6 @@ tag expr_ {\n     expr_break;\n     expr_cont;\n     expr_ret(option::t<@expr>);\n-    expr_put(option::t<@expr>);\n     expr_be(@expr);\n     expr_log(int, @expr);\n "}, {"sha": "276967b792b637b8388bbad571a2ffb6ec0824a7", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -377,10 +377,6 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_for(fld.fold_local(decl), fld.fold_expr(expr),\n                      fld.fold_block(blk))\n           }\n-          expr_for_each(decl, expr, blk) {\n-            expr_for_each(fld.fold_local(decl), fld.fold_expr(expr),\n-                          fld.fold_block(blk))\n-          }\n           expr_do_while(blk, expr) {\n             expr_do_while(fld.fold_block(blk), fld.fold_expr(expr))\n           }\n@@ -413,7 +409,6 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_break. { e }\n           expr_cont. { e }\n           expr_ret(e) { expr_ret(option::map(fld.fold_expr, e)) }\n-          expr_put(e) { expr_put(option::map(fld.fold_expr, e)) }\n           expr_be(e) { expr_be(fld.fold_expr(e)) }\n           expr_log(lv, e) { expr_log(lv, fld.fold_expr(e)) }\n           expr_assert(e) { expr_assert(fld.fold_expr(e)) }"}, {"sha": "1a29a033f562184fe98bb3a6939b8464ad4ca8cc", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 36, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -148,10 +148,8 @@ fn bad_expr_word_table() -> hashmap<str, ()> {\n     words.insert(\"do\", ());\n     words.insert(\"alt\", ());\n     words.insert(\"for\", ());\n-    words.insert(\"each\", ());\n     words.insert(\"break\", ());\n     words.insert(\"cont\", ());\n-    words.insert(\"put\", ());\n     words.insert(\"ret\", ());\n     words.insert(\"be\", ());\n     words.insert(\"fail\", ());\n@@ -160,13 +158,11 @@ fn bad_expr_word_table() -> hashmap<str, ()> {\n     words.insert(\"check\", ());\n     words.insert(\"assert\", ());\n     words.insert(\"claim\", ());\n-    words.insert(\"prove\", ());\n     words.insert(\"native\", ());\n     words.insert(\"fn\", ());\n     words.insert(\"lambda\", ());\n     words.insert(\"pure\", ());\n     words.insert(\"unsafe\", ());\n-    words.insert(\"iter\", ());\n     words.insert(\"block\", ());\n     words.insert(\"import\", ());\n     words.insert(\"export\", ());\n@@ -566,9 +562,6 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n     } else if eat_word(p, \"block\") {\n         t = parse_ty_fn(ast::proto_block, p);\n         alt t { ast::ty_fn(_, _, out, _, _) { hi = out.span.hi; } }\n-    } else if eat_word(p, \"iter\") {\n-        t = parse_ty_fn(ast::proto_iter, p);\n-        alt t { ast::ty_fn(_, _, out, _, _) { hi = out.span.hi; } }\n     } else if eat_word(p, \"obj\") {\n         t = parse_ty_obj(p, hi);\n     } else if p.peek() == token::MOD_SEP || is_ident(p.peek()) {\n@@ -964,15 +957,6 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n     } else if eat_word(p, \"cont\") {\n         ex = ast::expr_cont;\n         hi = p.get_hi_pos();\n-    } else if eat_word(p, \"put\") {\n-        alt p.peek() {\n-          token::SEMI. { ex = ast::expr_put(none); }\n-          _ {\n-            let e = parse_expr(p);\n-            hi = e.span.hi;\n-            ex = ast::expr_put(some(e));\n-          }\n-        }\n     } else if eat_word(p, \"be\") {\n         let e = parse_expr(p);\n \n@@ -1341,15 +1325,12 @@ fn parse_else_expr(p: parser) -> @ast::expr {\n \n fn parse_for_expr(p: parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n-    let is_each = eat_word(p, \"each\");\n     let decl = parse_local(p, false);\n     expect_word(p, \"in\");\n     let seq = parse_expr(p);\n     let body = parse_block_no_value(p);\n     let hi = body.span.hi;\n-    if is_each {\n-        ret mk_expr(p, lo, hi, ast::expr_for_each(decl, seq, body));\n-    } else { ret mk_expr(p, lo, hi, ast::expr_for(decl, seq, body)); }\n+    ret mk_expr(p, lo, hi, ast::expr_for(decl, seq, body));\n }\n \n fn parse_while_expr(p: parser) -> @ast::expr {\n@@ -1640,8 +1621,7 @@ fn expr_has_value(e: @ast::expr) -> bool {\n         found_expr\n       }\n       ast::expr_block(blk) | ast::expr_while(_, blk) |\n-      ast::expr_for(_, _, blk) | ast::expr_for_each(_, _, blk) |\n-      ast::expr_do_while(blk, _) {\n+      ast::expr_for(_, _, blk) | ast::expr_do_while(blk, _) {\n         !option::is_none(blk.node.expr)\n       }\n       _ { true }\n@@ -1837,7 +1817,7 @@ fn mk_item(p: parser, lo: uint, hi: uint, ident: ast::ident, node: ast::item_,\n           span: ast_util::mk_sp(lo, hi)};\n }\n \n-fn parse_item_fn_or_iter(p: parser, purity: ast::purity, proto: ast::proto,\n+fn parse_item_fn(p: parser, purity: ast::purity, proto: ast::proto,\n                          attrs: [ast::attribute], il: ast::inlineness) ->\n    @ast::item {\n     let lo = p.get_last_lo_pos();\n@@ -2167,9 +2147,7 @@ fn parse_fn_anon_proto(p: parser) -> ast::proto {\n }\n \n fn parse_method_proto(p: parser) -> ast::proto {\n-    if eat_word(p, \"iter\") {\n-        ret ast::proto_iter;\n-    } else if eat_word(p, \"fn\") {\n+    if eat_word(p, \"fn\") {\n         ret ast::proto_bare;\n     } else { unexpected(p, p.peek()); }\n }\n@@ -2180,27 +2158,24 @@ fn parse_item(p: parser, attrs: [ast::attribute]) -> option::t<@ast::item> {\n     } else if eat_word(p, \"inline\") {\n         expect_word(p, \"fn\");\n         let proto = parse_fn_item_proto(p);\n-        ret some(parse_item_fn_or_iter(p, ast::impure_fn, proto,\n+        ret some(parse_item_fn(p, ast::impure_fn, proto,\n                                        attrs, ast::il_inline));\n     } else if is_word(p, \"fn\") && p.look_ahead(1u) != token::LPAREN {\n         p.bump();\n         let proto = parse_fn_item_proto(p);\n-        ret some(parse_item_fn_or_iter(p, ast::impure_fn, proto,\n-                                       attrs, ast::il_normal));\n+        ret some(parse_item_fn(p, ast::impure_fn, proto,\n+                               attrs, ast::il_normal));\n     } else if eat_word(p, \"pure\") {\n         expect_word(p, \"fn\");\n         let proto = parse_fn_item_proto(p);\n-        ret some(parse_item_fn_or_iter(p, ast::pure_fn, proto, attrs,\n-                                       ast::il_normal));\n+        ret some(parse_item_fn(p, ast::pure_fn, proto, attrs,\n+                               ast::il_normal));\n     } else if is_word(p, \"unsafe\") && p.look_ahead(1u) != token::LBRACE {\n         p.bump();\n         expect_word(p, \"fn\");\n         let proto = parse_fn_item_proto(p);\n-        ret some(parse_item_fn_or_iter(p, ast::unsafe_fn, proto,\n-                                       attrs, ast::il_normal));\n-    } else if eat_word(p, \"iter\") {\n-        ret some(parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_iter,\n-                                       attrs, ast::il_normal));\n+        ret some(parse_item_fn(p, ast::unsafe_fn, proto,\n+                               attrs, ast::il_normal));\n     } else if eat_word(p, \"mod\") {\n         ret some(parse_item_mod(p, attrs));\n     } else if eat_word(p, \"native\") {"}, {"sha": "9a7944f47c83e372044c126bf70fbe374d51ee68", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -606,8 +606,7 @@ fn print_possibly_embedded_block(s: ps, blk: ast::blk, embedded: embed_type,\n // alt, do, & while unambiguously without being parenthesized\n fn print_maybe_parens_discrim(s: ps, e: @ast::expr) {\n     let disambig = alt e.node {\n-      ast::expr_ret(none.) | ast::expr_put(none.) |\n-      ast::expr_fail(none.) { true }\n+      ast::expr_ret(none.) | ast::expr_fail(none.) { true }\n       _ { false }\n     };\n     if disambig { popen(s); }\n@@ -796,12 +795,6 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         space(s.s);\n         print_block(s, blk);\n       }\n-      ast::expr_for_each(decl, expr, blk) {\n-        head(s, \"for each\");\n-        print_for_decl(s, decl, expr);\n-        space(s.s);\n-        print_block(s, blk);\n-      }\n       ast::expr_do_while(blk, expr) {\n         head(s, \"do\");\n         space(s.s);\n@@ -924,13 +917,6 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n           _ { }\n         }\n       }\n-      ast::expr_put(result) {\n-        word(s.s, \"put\");\n-        alt result {\n-          some(expr) { word(s.s, \" \"); print_expr(s, expr); }\n-          _ { }\n-        }\n-      }\n       ast::expr_be(result) { word_nbsp(s, \"be\"); print_expr(s, result); }\n       ast::expr_log(lvl, expr) {\n         alt lvl { 1 { word_nbsp(s, \"log\"); } 0 { word_nbsp(s, \"log_err\"); } }\n@@ -1005,7 +991,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n \n fn print_expr_parens_if_not_bot(s: ps, ex: @ast::expr) {\n     let parens = alt ex.node {\n-      ast::expr_fail(_) | ast::expr_ret(_) | ast::expr_put(_) |\n+      ast::expr_fail(_) | ast::expr_ret(_) |\n       ast::expr_binary(_, _, _) | ast::expr_unary(_, _) |\n       ast::expr_ternary(_, _, _) | ast::expr_move(_, _) |\n       ast::expr_copy(_) | ast::expr_assign(_, _) | ast::expr_be(_) |\n@@ -1319,7 +1305,6 @@ fn need_parens(expr: @ast::expr, outer_prec: int) -> bool {\n       ast::expr_swap(_, _) { true }\n       ast::expr_assign_op(_, _, _) { true }\n       ast::expr_ret(_) { true }\n-      ast::expr_put(_) { true }\n       ast::expr_be(_) { true }\n       ast::expr_assert(_) { true }\n       ast::expr_check(_, _) { true }\n@@ -1643,7 +1628,6 @@ fn ast_fn_constrs_str(decl: ast::fn_decl, constrs: [@ast::constr]) -> str {\n \n fn proto_to_str(p: ast::proto) -> str {\n     ret alt p {\n-          ast::proto_iter. { \"iter\" }\n           ast::proto_bare. { \"fn\" }\n           ast::proto_block. { \"block\" }\n           ast::proto_shared(ast::sugar_normal.) { \"fn@\" }\n@@ -1679,7 +1663,7 @@ fn ends_in_lit_int(ex: @ast::expr) -> bool {\n       ast::expr_assign_op(_, _, sub) | ast::expr_swap(_, sub) |\n       ast::expr_log(_, sub) | ast::expr_assert(sub) |\n       ast::expr_check(_, sub) { ends_in_lit_int(sub) }\n-      ast::expr_fail(osub) | ast::expr_ret(osub) | ast::expr_put(osub) {\n+      ast::expr_fail(osub) | ast::expr_ret(osub) {\n         alt osub {\n           some(ex) { ends_in_lit_int(ex) }\n           _ { false }"}, {"sha": "3cd44fe10da3288ef8db191a415d24f17be700ab", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -274,7 +274,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         v.visit_expr(el, e, v);\n       }\n       expr_while(x, b) { v.visit_expr(x, e, v); v.visit_block(b, e, v); }\n-      expr_for(dcl, x, b) | expr_for_each(dcl, x, b) {\n+      expr_for(dcl, x, b) {\n         v.visit_local(dcl, e, v);\n         v.visit_expr(x, e, v);\n         v.visit_block(b, e, v);\n@@ -301,7 +301,6 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       expr_break. { }\n       expr_cont. { }\n       expr_ret(eo) { visit_expr_opt(eo, e, v); }\n-      expr_put(eo) { visit_expr_opt(eo, e, v); }\n       expr_be(x) { v.visit_expr(x, e, v); }\n       expr_log(_, x) { v.visit_expr(x, e, v); }\n       expr_check(_, x) { v.visit_expr(x, e, v); }"}, {"sha": "22b85fac3da1e13c091287c13718d6e8b0498b61", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -271,17 +271,6 @@ fn lit_eq(l: @ast::lit, m: @ast::lit) -> bool {\n     }\n }\n \n-tag call_kind { kind_call; kind_spawn; kind_bind; kind_for_each; }\n-\n-fn call_kind_str(c: call_kind) -> str {\n-    alt c {\n-      kind_call. { \"Call\" }\n-      kind_spawn. { \"Spawn\" }\n-      kind_bind. { \"Bind\" }\n-      kind_for_each. { \"For-Each\" }\n-    }\n-}\n-\n fn is_main_name(path: [ast::ident]) -> bool {\n     str::eq(option::get(std::vec::last(path)), \"main\")\n }"}, {"sha": "80b2636c9600ea73b7b650527e7e9d167b5654d8", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ce40f60e79598c198851154cc978375ed5e7747/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce40f60e79598c198851154cc978375ed5e7747/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=0ce40f60e79598c198851154cc978375ed5e7747", "patch": "@@ -49,7 +49,6 @@ fn common_exprs() -> [ast::expr] {\n      dse(ast::expr_fail(option::none)),\n      dse(ast::expr_fail(option::some(@dse(ast::expr_lit(@dsl(ast::lit_str(\"boo\"))))))),\n      dse(ast::expr_ret(option::none)),\n-     dse(ast::expr_put(option::none)),\n      dse(ast::expr_lit(@dsl(ast::lit_nil))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(true)))),\n@@ -74,7 +73,6 @@ pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n           ast::expr_block(_) { false }\n           ast::expr_alt(_, _) { false }\n           ast::expr_for(_, _, _) { false }\n-          ast::expr_for_each(_, _, _) { false }\n           ast::expr_while(_, _) { false }\n \n           // https://github.com/graydon/rust/issues/955\n@@ -89,7 +87,6 @@ pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n \n           ast::expr_fail(option::none.) { false }\n           ast::expr_ret(option::none.) { false }\n-          ast::expr_put(option::none.) { false }\n \n           // https://github.com/graydon/rust/issues/953\n           ast::expr_fail(option::some(_)) { false }"}]}