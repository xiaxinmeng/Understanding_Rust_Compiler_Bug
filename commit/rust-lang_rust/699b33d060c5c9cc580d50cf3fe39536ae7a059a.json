{"sha": "699b33d060c5c9cc580d50cf3fe39536ae7a059a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5OWIzM2QwNjBjNWM5Y2M1ODBkNTBjZjNmZTM5NTM2YWU3YTA1OWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-26T00:15:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-11T15:25:42Z"}, "message": "rustc: Support various flavors of linkages\n\nIt is often convenient to have forms of weak linkage or other various types of\nlinkage. Sadly, just using these flavors of linkage are not compatible with\nRust's typesystem and how it considers some pointers to be non-null.\n\nAs a compromise, this commit adds support for weak linkage to external symbols,\nbut it requires that this is only placed on extern statics of type `*T`.\nCodegen-wise, we get translations like:\n\n    // rust code\n    extern {\n        #[linkage = \"extern_weak\"]\n        static foo: *i32;\n    }\n\n    // generated IR\n    @foo = extern_weak global i32\n    @_some_internal_symbol = internal global *i32 @foo\n\nAll references to the rust value of `foo` then reference `_some_internal_symbol`\ninstead of the symbol `_foo` itself. This allows us to guarantee that the\naddress of `foo` will never be null while the value may sometimes be null.\n\nAn example was implemented in `std::rt::thread` to determine if\n`__pthread_get_minstack()` is available at runtime, and a test is checked in to\nuse it for a static value as well. Function pointers a little odd because you\nstill need to transmute the pointer value to a function pointer, but it's\nthankfully better than not having this capability at all.", "tree": {"sha": "eb8f7134c63af0df0376b27a02174b05b691b373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb8f7134c63af0df0376b27a02174b05b691b373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/699b33d060c5c9cc580d50cf3fe39536ae7a059a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/699b33d060c5c9cc580d50cf3fe39536ae7a059a", "html_url": "https://github.com/rust-lang/rust/commit/699b33d060c5c9cc580d50cf3fe39536ae7a059a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/699b33d060c5c9cc580d50cf3fe39536ae7a059a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "001705610505065ff50502390af933e0b264853a", "url": "https://api.github.com/repos/rust-lang/rust/commits/001705610505065ff50502390af933e0b264853a", "html_url": "https://github.com/rust-lang/rust/commit/001705610505065ff50502390af933e0b264853a"}], "stats": {"total": 321, "additions": 243, "deletions": 78}, "files": [{"sha": "36f6cedb4f158fcf690107b9ac9ca4e27487974f", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=699b33d060c5c9cc580d50cf3fe39536ae7a059a", "patch": "@@ -53,6 +53,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"simd\", Active),\n     (\"default_type_params\", Active),\n     (\"quote\", Active),\n+    (\"linkage\", Active),\n \n     // These are used to test this portion of the compiler, they don't actually\n     // mean anything\n@@ -238,6 +239,19 @@ impl Visitor<()> for Context {\n         }\n     }\n \n+    fn visit_foreign_item(&mut self, i: &ast::ForeignItem, _: ()) {\n+        match i.node {\n+            ast::ForeignItemFn(..) | ast::ForeignItemStatic(..) => {\n+                if attr::contains_name(i.attrs.as_slice(), \"linkage\") {\n+                    self.gate_feature(\"linkage\", i.span,\n+                                      \"the `linkage` attribute is experimental \\\n+                                       and not portable across platforms\")\n+                }\n+            }\n+        }\n+        visit::walk_foreign_item(self, i, ())\n+    }\n+\n     fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n         match t.node {\n             ast::TyClosure(closure) if closure.onceness == ast::Once &&"}, {"sha": "1351e87c7f6488033bf67010684e64462e26d2e9", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=699b33d060c5c9cc580d50cf3fe39536ae7a059a", "patch": "@@ -983,7 +983,7 @@ static other_attrs: &'static [&'static str] = &[\n \n     // fn-level\n     \"test\", \"bench\", \"should_fail\", \"ignore\", \"inline\", \"lang\", \"main\", \"start\",\n-    \"no_split_stack\", \"cold\", \"macro_registrar\",\n+    \"no_split_stack\", \"cold\", \"macro_registrar\", \"linkage\",\n \n     // internal attribute: bypass privacy inside items\n     \"!resolve_unexported\","}, {"sha": "156a4f914a9093a2be1febb2b937ccc39ee7c350", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=699b33d060c5c9cc580d50cf3fe39536ae7a059a", "patch": "@@ -2107,7 +2107,6 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n \n                 ast_map::NodeForeignItem(ni) => {\n-                    let ty = ty::node_id_to_type(ccx.tcx, ni.id);\n                     foreign = true;\n \n                     match ni.node {\n@@ -2116,41 +2115,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                             foreign::register_foreign_item_fn(ccx, abis, ni)\n                         }\n                         ast::ForeignItemStatic(..) => {\n-                            // Treat the crate map static specially in order to\n-                            // a weak-linkage-like functionality where it's\n-                            // dynamically resolved at runtime. If we're\n-                            // building a library, then we declare the static\n-                            // with weak linkage, but if we're building a\n-                            // library then we've already declared the crate map\n-                            // so use that instead.\n-                            if attr::contains_name(ni.attrs.as_slice(),\n-                                                   \"crate_map\") {\n-                                if ccx.sess.building_library.get() {\n-                                    let s = \"_rust_crate_map_toplevel\";\n-                                    let g = unsafe {\n-                                        s.with_c_str(|buf| {\n-                                            let ty = type_of(ccx, ty);\n-                                            llvm::LLVMAddGlobal(ccx.llmod,\n-                                                                ty.to_ref(),\n-                                                                buf)\n-                                        })\n-                                    };\n-                                    lib::llvm::SetLinkage(g,\n-                                        lib::llvm::ExternalWeakLinkage);\n-                                    g\n-                                } else {\n-                                    ccx.crate_map\n-                                }\n-                            } else {\n-                                let ident = foreign::link_name(ni);\n-                                unsafe {\n-                                    ident.get().with_c_str(|buf| {\n-                                        let ty = type_of(ccx, ty);\n-                                        llvm::LLVMAddGlobal(ccx.llmod,\n-                                                            ty.to_ref(), buf)\n-                                    })\n-                                }\n-                            }\n+                            foreign::register_static(ccx, ni)\n                         }\n                     }\n                 }"}, {"sha": "f37d4b9859d4232bbd8fceefb537f557eaad194b", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 100, "deletions": 1, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=699b33d060c5c9cc580d50cf3fe39536ae7a059a", "patch": "@@ -11,7 +11,7 @@\n \n use back::{link};\n use lib::llvm::llvm;\n-use lib::llvm::{ValueRef, CallConv, StructRetAttribute};\n+use lib::llvm::{ValueRef, CallConv, StructRetAttribute, Linkage};\n use lib;\n use middle::trans::base::push_ctxt;\n use middle::trans::base;\n@@ -105,6 +105,105 @@ pub fn llvm_calling_convention(ccx: &CrateContext,\n     })\n }\n \n+pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n+    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n+    // applicable to variable declarations and may not really make sense for\n+    // Rust code in the first place but whitelist them anyway and trust that\n+    // the user knows what s/he's doing. Who knows, unanticipated use cases\n+    // may pop up in the future.\n+    //\n+    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n+    // and don't have to be, LLVM treats them as no-ops.\n+    match name {\n+        \"appending\" => Some(lib::llvm::AppendingLinkage),\n+        \"available_externally\" => Some(lib::llvm::AvailableExternallyLinkage),\n+        \"common\" => Some(lib::llvm::CommonLinkage),\n+        \"extern_weak\" => Some(lib::llvm::ExternalWeakLinkage),\n+        \"external\" => Some(lib::llvm::ExternalLinkage),\n+        \"internal\" => Some(lib::llvm::InternalLinkage),\n+        \"linker_private\" => Some(lib::llvm::LinkerPrivateLinkage),\n+        \"linker_private_weak\" => Some(lib::llvm::LinkerPrivateWeakLinkage),\n+        \"linkonce\" => Some(lib::llvm::LinkOnceAnyLinkage),\n+        \"linkonce_odr\" => Some(lib::llvm::LinkOnceODRLinkage),\n+        \"private\" => Some(lib::llvm::PrivateLinkage),\n+        \"weak\" => Some(lib::llvm::WeakAnyLinkage),\n+        \"weak_odr\" => Some(lib::llvm::WeakODRLinkage),\n+        _ => None,\n+    }\n+}\n+\n+pub fn register_static(ccx: @CrateContext,\n+                       foreign_item: @ast::ForeignItem) -> ValueRef {\n+    let ty = ty::node_id_to_type(ccx.tcx, foreign_item.id);\n+    let llty = type_of::type_of(ccx, ty);\n+\n+    // Treat the crate map static specially in order to\n+    // a weak-linkage-like functionality where it's\n+    // dynamically resolved at runtime. If we're\n+    // building a library, then we declare the static\n+    // with weak linkage, but if we're building a\n+    // library then we've already declared the crate map\n+    // so use that instead.\n+    if attr::contains_name(foreign_item.attrs.as_slice(), \"crate_map\") {\n+        return if ccx.sess.building_library.get() {\n+            let s = \"_rust_crate_map_toplevel\";\n+            let g = unsafe {\n+                s.with_c_str(|buf| {\n+                    llvm::LLVMAddGlobal(ccx.llmod, llty.to_ref(), buf)\n+                })\n+            };\n+            lib::llvm::SetLinkage(g, lib::llvm::ExternalWeakLinkage);\n+            g\n+        } else {\n+            ccx.crate_map\n+        }\n+    }\n+\n+    let ident = link_name(foreign_item);\n+    match attr::first_attr_value_str_by_name(foreign_item.attrs.as_slice(),\n+                                             \"linkage\") {\n+        // If this is a static with a linkage specified, then we need to handle\n+        // it a little specially. The typesystem prevents things like &T and\n+        // extern \"C\" fn() from being non-null, so we can't just declare a\n+        // static and call it a day. Some linkages (like weak) will make it such\n+        // that the static actually has a null value.\n+        Some(name) => {\n+            let linkage = match llvm_linkage_by_name(name.get()) {\n+                Some(linkage) => linkage,\n+                None => {\n+                    ccx.sess.span_fatal(foreign_item.span,\n+                                        \"invalid linkage specified\");\n+                }\n+            };\n+            let llty2 = match ty::get(ty).sty {\n+                ty::ty_ptr(ref mt) => type_of::type_of(ccx, mt.ty),\n+                _ => {\n+                    ccx.sess.span_fatal(foreign_item.span,\n+                                        \"must have type `*T` or `*mut T`\");\n+                }\n+            };\n+            unsafe {\n+                let g1 = ident.get().with_c_str(|buf| {\n+                    llvm::LLVMAddGlobal(ccx.llmod, llty2.to_ref(), buf)\n+                });\n+                lib::llvm::SetLinkage(g1, linkage);\n+\n+                let real_name = \"_rust_extern_with_linkage_\" + ident.get();\n+                let g2 = real_name.with_c_str(|buf| {\n+                    llvm::LLVMAddGlobal(ccx.llmod, llty.to_ref(), buf)\n+                });\n+                lib::llvm::SetLinkage(g2, lib::llvm::InternalLinkage);\n+                llvm::LLVMSetInitializer(g2, g1);\n+                g2\n+            }\n+        }\n+        None => unsafe {\n+            ident.get().with_c_str(|buf| {\n+                llvm::LLVMAddGlobal(ccx.llmod, llty.to_ref(), buf)\n+            })\n+        }\n+    }\n+}\n \n pub fn register_foreign_item_fn(ccx: @CrateContext, abis: AbiSet,\n                                 foreign_item: @ast::ForeignItem) -> ValueRef {"}, {"sha": "4d3d1641bd0c2f7bead882224ce09f01bdc13e51", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=699b33d060c5c9cc580d50cf3fe39536ae7a059a", "patch": "@@ -52,10 +52,9 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n \n-#[feature(macro_rules, globs, asm, managed_boxes, thread_local, link_args, simd)];\n+#[feature(macro_rules, globs, asm, managed_boxes, thread_local, link_args,\n+          simd, linkage, default_type_params)];\n \n-// Turn on default type parameters.\n-#[feature(default_type_params)];\n // NOTE remove the following two attributes after the next snapshot.\n #[allow(unrecognized_lint)];\n #[allow(default_type_param_usage)];"}, {"sha": "e27698d7dd0a8dc95a35949c391dde1502fcf634", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 26, "deletions": 37, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=699b33d060c5c9cc580d50cf3fe39536ae7a059a", "patch": "@@ -221,7 +221,7 @@ mod imp {\n                                                PTHREAD_CREATE_JOINABLE), 0);\n \n         // Reserve room for the red zone, the runtime's stack of last resort.\n-        let stack_size = cmp::max(stack, RED_ZONE + __pthread_get_minstack(&attr) as uint);\n+        let stack_size = cmp::max(stack, RED_ZONE + min_stack_size(&attr) as uint);\n         match pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t) {\n             0 => {\n             },\n@@ -261,51 +261,39 @@ mod imp {\n     #[cfg(not(target_os = \"macos\"), not(target_os = \"android\"))]\n     pub unsafe fn yield_now() { assert_eq!(pthread_yield(), 0); }\n \n-    #[cfg(not(target_os = \"linux\"))]\n-    unsafe fn __pthread_get_minstack(_: *libc::pthread_attr_t) -> libc::size_t {\n-        libc::PTHREAD_STACK_MIN\n-    }\n-\n     // glibc >= 2.15 has a __pthread_get_minstack() function that returns\n     // PTHREAD_STACK_MIN plus however many bytes are needed for thread-local\n     // storage.  We need that information to avoid blowing up when a small stack\n     // is created in an application with big thread-local storage requirements.\n     // See #6233 for rationale and details.\n     //\n-    // Dynamically resolve the symbol for compatibility with older versions\n-    // of glibc.  Assumes that we've been dynamically linked to libpthread\n-    // but that is currently always the case.  Note that this means we take\n-    // a dlopen/dlsym/dlclose hit for every new thread.  Mitigating that by\n-    // caching the symbol or the function's return value has its drawbacks:\n-    //\n-    //  * Caching the symbol breaks when libpthread.so is reloaded because\n-    //    its address changes.\n-    //\n-    //  * Caching the return value assumes that it's a fixed quantity.\n-    //    Not very future-proof and untrue in the presence of guard pages\n-    //    The reason __pthread_get_minstack() takes a *libc::pthread_attr_t\n-    //    as its argument is because it takes pthread_attr_setguardsize() into\n-    //    account.\n-    //\n-    // A better solution is to define __pthread_get_minstack() as a weak symbol\n-    // but there is currently no way to express that in Rust code.\n-    #[cfg(target_os = \"linux\")]\n-    unsafe fn __pthread_get_minstack(attr: *libc::pthread_attr_t) -> libc::size_t {\n-        use option::None;\n-        use result::{Err, Ok};\n-        use unstable::dynamic_lib;\n-        match dynamic_lib::DynamicLibrary::open(None) {\n-            Err(err) => fail!(\"DynamicLibrary::open(): {}\", err),\n-            Ok(handle) => {\n-                match handle.symbol::<extern \"C\" fn(*libc::pthread_attr_t) ->\n-                                     libc::size_t>(\"__pthread_get_minstack\") {\n-                    Err(_) => libc::PTHREAD_STACK_MIN,\n-                    Ok(__pthread_get_minstack) => __pthread_get_minstack(attr),\n-                }\n-            }\n+    // Link weakly to the symbol for compatibility with older versions of glibc.\n+    // Assumes that we've been dynamically linked to libpthread but that is\n+    // currently always the case.  Note that you need to check that the symbol\n+    // is non-null before calling it!\n+    #[cfg(target_os = \"linux\", not(stage0))]\n+    fn min_stack_size(attr: *libc::pthread_attr_t) -> libc::size_t {\n+        use ptr::RawPtr;\n+        type F = extern \"C\" unsafe fn(*libc::pthread_attr_t) -> libc::size_t;\n+        extern {\n+            #[linkage = \"extern_weak\"]\n+            static __pthread_get_minstack: *();\n+        }\n+        if __pthread_get_minstack.is_null() {\n+            PTHREAD_STACK_MIN\n+        } else {\n+            unsafe { cast::transmute::<*(), F>(__pthread_get_minstack)(attr) }\n         }\n     }\n \n+    // __pthread_get_minstack() is marked as weak but extern_weak linkage is\n+    // not supported on OS X, hence this kludge...\n+    #[cfg(not(target_os = \"linux\"))]\n+    #[cfg(stage0)]\n+    fn min_stack_size(_: *libc::pthread_attr_t) -> libc::size_t {\n+        PTHREAD_STACK_MIN\n+    }\n+\n     extern {\n         fn pthread_create(native: *mut libc::pthread_t,\n                           attr: *libc::pthread_attr_t,\n@@ -347,3 +335,4 @@ mod tests {\n         assert_eq!(42, Thread::start_stack(1, proc () 42).join());\n     }\n }\n+"}, {"sha": "9017ee88363b7fa9987124a8b7b8b8ea54114dee", "filename": "src/test/auxiliary/linkage1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Ftest%2Fauxiliary%2Flinkage1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Ftest%2Fauxiliary%2Flinkage1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flinkage1.rs?ref=699b33d060c5c9cc580d50cf3fe39536ae7a059a", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[no_mangle]\n+pub static foo: int = 3;"}, {"sha": "a045b838d5157832854c6f4056bb1d6bd023a4ae", "filename": "src/test/compile-fail/linkage1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Ftest%2Fcompile-fail%2Flinkage1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Ftest%2Fcompile-fail%2Flinkage1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flinkage1.rs?ref=699b33d060c5c9cc580d50cf3fe39536ae7a059a", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern {\n+    #[linkage = \"extern_weak\"] static foo: int;\n+    //~^ ERROR: the `linkage` attribute is experimental and not portable\n+}"}, {"sha": "524324fa1f1b23bca0163025c93d02880e3d35d3", "filename": "src/test/compile-fail/linkage2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Ftest%2Fcompile-fail%2Flinkage2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Ftest%2Fcompile-fail%2Flinkage2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flinkage2.rs?ref=699b33d060c5c9cc580d50cf3fe39536ae7a059a", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(linkage)];\n+\n+extern {\n+    #[linkage = \"extern_weak\"] static foo: i32;\n+    //~^ ERROR: must have type `*T`\n+}\n+\n+fn main() {\n+    println!(\"{}\", foo);\n+}"}, {"sha": "2da800bcb1cf5d3672752134a651176a90a5df02", "filename": "src/test/compile-fail/linkage3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Ftest%2Fcompile-fail%2Flinkage3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Ftest%2Fcompile-fail%2Flinkage3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flinkage3.rs?ref=699b33d060c5c9cc580d50cf3fe39536ae7a059a", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(linkage)];\n+\n+extern {\n+    #[linkage = \"foo\"] static foo: *i32;\n+    //~^ ERROR: invalid linkage specified\n+}\n+\n+fn main() {\n+    println!(\"{}\", foo);\n+}\n+"}, {"sha": "8f8b0cfecb28d5bc5dd863a02db7b2597207e576", "filename": "src/test/run-pass/linkage1.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Ftest%2Frun-pass%2Flinkage1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699b33d060c5c9cc580d50cf3fe39536ae7a059a/src%2Ftest%2Frun-pass%2Flinkage1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinkage1.rs?ref=699b33d060c5c9cc580d50cf3fe39536ae7a059a", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-win32\n+// ignore-fast\n+// ignore-android\n+// ignore-macos\n+// aux-build:linkage1.rs\n+\n+#[feature(linkage)];\n+\n+extern crate other = \"linkage1\";\n+\n+extern {\n+    #[linkage = \"extern_weak\"]\n+    static foo: *int;\n+    #[linkage = \"extern_weak\"]\n+    static something_that_should_never_exist: *mut int;\n+}\n+\n+fn main() {\n+    assert!(!foo.is_null());\n+    assert_eq!(unsafe { *foo }, 3);\n+    assert!(something_that_should_never_exist.is_null());\n+}"}]}