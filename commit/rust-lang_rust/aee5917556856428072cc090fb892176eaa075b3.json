{"sha": "aee5917556856428072cc090fb892176eaa075b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZTU5MTc1NTY4NTY0MjgwNzJjYzA5MGZiODkyMTc2ZWFhMDc1YjM=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-13T16:35:48Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-13T17:22:43Z"}, "message": "macro expansion for methods\n\nCloses #4621", "tree": {"sha": "d52f0afa07835d283f7c9c4254a1421e5073cc1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d52f0afa07835d283f7c9c4254a1421e5073cc1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aee5917556856428072cc090fb892176eaa075b3", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aee5917556856428072cc090fb892176eaa075b3", "html_url": "https://github.com/rust-lang/rust/commit/aee5917556856428072cc090fb892176eaa075b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aee5917556856428072cc090fb892176eaa075b3/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb333ca3926df37a6529e4546147642bbce89c41", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb333ca3926df37a6529e4546147642bbce89c41", "html_url": "https://github.com/rust-lang/rust/commit/bb333ca3926df37a6529e4546147642bbce89c41"}], "stats": {"total": 72, "additions": 47, "deletions": 25}, "files": [{"sha": "58689389769c9979b063793d3cc69131cd251c0a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 47, "deletions": 25, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/aee5917556856428072cc090fb892176eaa075b3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee5917556856428072cc090fb892176eaa075b3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=aee5917556856428072cc090fb892176eaa075b3", "patch": "@@ -544,7 +544,7 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n             match expanded.make_items() {\n                 Some(items) => {\n                     items.move_iter()\n-                        .flat_map(|i| mark_item(i, fm).move_iter())\n+                        .map(|i| mark_item(i, fm))\n                         .flat_map(|i| fld.fold_item(i).move_iter())\n                         .collect()\n                 }\n@@ -563,14 +563,14 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n \n /// Expand a stmt\n //\n-// I don't understand why this returns a vector... it looks like someone got\n+// I don't understand why this returns a vector... it looks like we're\n // half done adding machinery to allow macros to expand into multiple statements.\n fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<Gc<Stmt>> {\n     let (mac, semi) = match s.node {\n         StmtMac(ref mac, semi) => (mac, semi),\n         _ => return expand_non_macro_stmt(s, fld)\n     };\n-    let expanded_stmt = match expand_mac_invoc(mac,s.span,\n+    let expanded_stmt = match expand_mac_invoc(mac,&s.span,\n                                                 |r|{r.make_stmt()},\n                                                 |sts,mrk|{mark_stmt(sts,mrk)},\n                                                 fld) {\n@@ -905,26 +905,41 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n }\n \n // expand a method\n-fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> Gc<ast::Method> {\n+fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> SmallVector<Gc<ast::Method>> {\n     let id = fld.new_id(m.id);\n-    box(GC) ast::Method {\n-        attrs: m.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n-        id: id,\n-        span: fld.new_span(m.span),\n-        node: match m.node {\n-            ast::MethDecl(ident, ref generics, ref explicit_self, fn_style, decl, body, vis) => {\n-                let (rewritten_fn_decl, rewritten_body)\n-                    = expand_and_rename_fn_decl_and_block(decl,body,fld);\n-\n-                ast::MethDecl(fld.fold_ident(ident),\n-                         fold_generics(generics, fld),\n-                         fld.fold_explicit_self(explicit_self),\n-                         fn_style,\n-                         rewritten_fn_decl,\n-                         rewritten_body,\n-                         vis)\n-            },\n-            ast::MethMac(ref _mac) => fail!(\"expansion in method position not implemented yet!\")\n+    match m.node {\n+        ast::MethDecl(ident, ref generics, ref explicit_self, fn_style, decl, body, vis) => {\n+            let (rewritten_fn_decl, rewritten_body)\n+                = expand_and_rename_fn_decl_and_block(decl,body,fld);\n+            SmallVector::one(box(GC) ast::Method {\n+                    attrs: m.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n+                    id: id,\n+                    span: fld.new_span(m.span),\n+                    node: ast::MethDecl(fld.fold_ident(ident),\n+                                        fold_generics(generics, fld),\n+                                        fld.fold_explicit_self(explicit_self),\n+                                        fn_style,\n+                                        rewritten_fn_decl,\n+                                        rewritten_body,\n+                                        vis)\n+                })\n+        },\n+        ast::MethMac(ref mac) => {\n+            let maybe_new_methods =\n+                expand_mac_invoc(mac, &m.span,\n+                                 |r|{r.make_methods()},\n+                                 |meths,mark|{\n+                    meths.move_iter().map(|m|{mark_method(m,mark)})\n+                        .collect()},\n+                                 fld);\n+\n+            let new_methods = match maybe_new_methods {\n+                Some(methods) => methods,\n+                None => SmallVector::zero()\n+            };\n+\n+            // expand again if necessary\n+            new_methods.move_iter().flat_map(|m| fld.fold_method(m).move_iter()).collect()\n         }\n     }\n }\n@@ -983,7 +998,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_arm(arm, self)\n     }\n \n-    fn fold_method(&mut self, method: Gc<ast::Method>) -> Gc<ast::Method> {\n+    fn fold_method(&mut self, method: Gc<ast::Method>) -> SmallVector<Gc<ast::Method>> {\n         expand_method(method, self)\n     }\n \n@@ -1098,12 +1113,19 @@ fn mark_pat(pat: Gc<ast::Pat>, m: Mrk) -> Gc<ast::Pat> {\n // apply a given mark to the given stmt. Used following the expansion of a macro.\n fn mark_stmt(expr: &ast::Stmt, m: Mrk) -> Gc<ast::Stmt> {\n     Marker{mark:m}.fold_stmt(expr)\n-            .expect_one(\"marking a stmt didn't return a stmt\")\n+        .expect_one(\"marking a stmt didn't return exactly one stmt\")\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_item(expr: Gc<ast::Item>, m: Mrk) -> SmallVector<Gc<ast::Item>> {\n+fn mark_item(expr: Gc<ast::Item>, m: Mrk) -> Gc<ast::Item> {\n     Marker{mark:m}.fold_item(expr)\n+        .expect_one(\"marking an item didn't return exactly one item\")\n+}\n+\n+// apply a given mark to the given item. Used following the expansion of a macro.\n+fn mark_method(expr: Gc<ast::Method>, m: Mrk) -> Gc<ast::Method> {\n+    Marker{mark:m}.fold_method(expr)\n+        .expect_one(\"marking an item didn't return exactly one method\")\n }\n \n fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {"}]}