{"sha": "81ee3586b5d75497af25e77756be8f629d711aaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZWUzNTg2YjVkNzU0OTdhZjI1ZTc3NzU2YmU4ZjYyOWQ3MTFhYWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-19T17:00:24Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-19T17:00:24Z"}, "message": "rollup merge of #17318 : nick29581/slice", "tree": {"sha": "0a34469c940e83723b3c8b1e1413f3f50aaea879", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a34469c940e83723b3c8b1e1413f3f50aaea879"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81ee3586b5d75497af25e77756be8f629d711aaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81ee3586b5d75497af25e77756be8f629d711aaf", "html_url": "https://github.com/rust-lang/rust/commit/81ee3586b5d75497af25e77756be8f629d711aaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81ee3586b5d75497af25e77756be8f629d711aaf/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "html_url": "https://github.com/rust-lang/rust/commit/b94075c9cefb3baedd4b0c01c9c11393e83ea66a"}, {"sha": "cf9c586fccb1063ea6f75609c702df909d4ac3f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf9c586fccb1063ea6f75609c702df909d4ac3f1", "html_url": "https://github.com/rust-lang/rust/commit/cf9c586fccb1063ea6f75609c702df909d4ac3f1"}], "stats": {"total": 1080, "additions": 975, "deletions": 105}, "files": [{"sha": "4051f682134367be27630c47bdf056b03ba6d7cc", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -20,6 +20,7 @@ use core::default::Default;\n use core::fmt;\n use core::mem;\n use core::num;\n+use core::ops;\n use core::ptr;\n use core::raw::Slice as RawSlice;\n use core::uint;\n@@ -464,6 +465,47 @@ impl<T> Index<uint,T> for Vec<T> {\n     }\n }*/\n \n+impl<T> ops::Slice<uint, [T]> for Vec<T> {\n+    #[inline]\n+    fn as_slice_<'a>(&'a self) -> &'a [T] {\n+        self.as_slice()\n+    }\n+\n+    #[inline]\n+    fn slice_from_<'a>(&'a self, start: &uint) -> &'a [T] {\n+        self.as_slice().slice_from_(start)\n+    }\n+\n+    #[inline]\n+    fn slice_to_<'a>(&'a self, end: &uint) -> &'a [T] {\n+        self.as_slice().slice_to_(end)\n+    }\n+    #[inline]\n+    fn slice_<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        self.as_slice().slice_(start, end)\n+    }\n+}\n+\n+impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n+    #[inline]\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n+        self.as_mut_slice()\n+    }\n+\n+    #[inline]\n+    fn slice_from_mut_<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_from_mut_(start)\n+    }\n+\n+    #[inline]\n+    fn slice_to_mut_<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_to_mut_(end)\n+    }\n+    #[inline]\n+    fn slice_mut_<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_mut_(start, end)\n+    }\n+}\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> {\n@@ -2327,6 +2369,44 @@ mod tests {\n         let _ = vec[3];\n     }\n \n+    // NOTE uncomment after snapshot\n+    /*\n+    #[test]\n+    #[should_fail]\n+    fn test_slice_out_of_bounds_1() {\n+        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        x[-1..];\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_slice_out_of_bounds_2() {\n+        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        x[..6];\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_slice_out_of_bounds_3() {\n+        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        x[-1..4];\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_slice_out_of_bounds_4() {\n+        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        x[1..6];\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_slice_out_of_bounds_5() {\n+        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        x[3..2];\n+    }\n+    */\n+\n     #[test]\n     fn test_swap_remove_empty() {\n         let mut vec: Vec<uint> = vec!();"}, {"sha": "718d311999552ef7390375babb41952e4b754224", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 102, "deletions": 3, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -638,7 +638,7 @@ shr_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n  * ```\n  */\n #[lang=\"index\"]\n-pub trait Index<Index,Result> {\n+pub trait Index<Index, Result> {\n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index<'a>(&'a self, index: &Index) -> &'a Result;\n }\n@@ -651,7 +651,7 @@ pub trait Index<Index,Result> {\n  * # Example\n  *\n  * A trivial implementation of `IndexMut`. When `Foo[Foo]` happens, it ends up\n- * calling `index`, and therefore, `main` prints `Indexing!`.\n+ * calling `index_mut`, and therefore, `main` prints `Indexing!`.\n  *\n  * ```\n  * struct Foo;\n@@ -669,11 +669,110 @@ pub trait Index<Index,Result> {\n  * ```\n  */\n #[lang=\"index_mut\"]\n-pub trait IndexMut<Index,Result> {\n+pub trait IndexMut<Index, Result> {\n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Result;\n }\n \n+/**\n+ *\n+ * The `Slice` trait is used to specify the functionality of slicing operations\n+ * like `arr[from..to]` when used in an immutable context.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `Slice`. When `Foo[..Foo]` happens, it ends up\n+ * calling `slice_to`, and therefore, `main` prints `Slicing!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl ::core::ops::Slice<Foo, Foo> for Foo {\n+ *     fn as_slice_<'a>(&'a self) -> &'a Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ *     fn slice_from_<'a>(&'a self, from: &Foo) -> &'a Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ *     fn slice_to_<'a>(&'a self, to: &Foo) -> &'a Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ *     fn slice_<'a>(&'a self, from: &Foo, to: &Foo) -> &'a Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     Foo[..Foo];\n+ * }\n+ * ```\n+ */\n+// FIXME(#17273) remove the postscript _s\n+#[lang=\"slice\"]\n+pub trait Slice<Idx, Sized? Result> for Sized? {\n+    /// The method for the slicing operation foo[]\n+    fn as_slice_<'a>(&'a self) -> &'a Result;\n+    /// The method for the slicing operation foo[from..]\n+    fn slice_from_<'a>(&'a self, from: &Idx) -> &'a Result;\n+    /// The method for the slicing operation foo[..to]\n+    fn slice_to_<'a>(&'a self, to: &Idx) -> &'a Result;\n+    /// The method for the slicing operation foo[from..to]\n+    fn slice_<'a>(&'a self, from: &Idx, to: &Idx) -> &'a Result;\n+}\n+\n+/**\n+ *\n+ * The `SliceMut` trait is used to specify the functionality of slicing\n+ * operations like `arr[from..to]`, when used in a mutable context.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `SliceMut`. When `Foo[Foo..]` happens, it ends up\n+ * calling `slice_from_mut`, and therefore, `main` prints `Slicing!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl ::core::ops::SliceMut<Foo, Foo> for Foo {\n+ *     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ *     fn slice_from_mut_<'a>(&'a mut self, from: &Foo) -> &'a mut Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ *     fn slice_to_mut_<'a>(&'a mut self, to: &Foo) -> &'a mut Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ *     fn slice_mut_<'a>(&'a mut self, from: &Foo, to: &Foo) -> &'a mut Foo {\n+ *         println!(\"Slicing!\");\n+ *         self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     Foo[mut Foo..];\n+ * }\n+ * ```\n+ */\n+// FIXME(#17273) remove the postscript _s\n+#[lang=\"slice_mut\"]\n+pub trait SliceMut<Idx, Sized? Result> for Sized? {\n+    /// The method for the slicing operation foo[]\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Result;\n+    /// The method for the slicing operation foo[from..]\n+    fn slice_from_mut_<'a>(&'a mut self, from: &Idx) -> &'a mut Result;\n+    /// The method for the slicing operation foo[..to]\n+    fn slice_to_mut_<'a>(&'a mut self, to: &Idx) -> &'a mut Result;\n+    /// The method for the slicing operation foo[from..to]\n+    fn slice_mut_<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n+}\n /**\n  *\n  * The `Deref` trait is used to specify the functionality of dereferencing"}, {"sha": "5368cb4450294e2dd726c0cf4bafc49700c83311", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -42,6 +42,7 @@ use cmp;\n use default::Default;\n use iter::*;\n use num::{CheckedAdd, Saturating, div_rem};\n+use ops;\n use option::{None, Option, Some};\n use ptr;\n use ptr::RawPtr;\n@@ -475,6 +476,63 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n }\n \n+impl<T> ops::Slice<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_slice_<'a>(&'a self) -> &'a [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from_<'a>(&'a self, start: &uint) -> &'a [T] {\n+        self.slice_(start, &self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to_<'a>(&'a self, end: &uint) -> &'a [T] {\n+        self.slice_(&0, end)\n+    }\n+    #[inline]\n+    fn slice_<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+\n+impl<T> ops::SliceMut<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from_mut_<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        let len = &self.len();\n+        self.slice_mut_(start, len)\n+    }\n+\n+    #[inline]\n+    fn slice_to_mut_<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.slice_mut_(&0, end)\n+    }\n+    #[inline]\n+    fn slice_mut_<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+\n /// Extension methods for vectors such that their elements are\n /// mutable.\n #[experimental = \"may merge with other traits; may lose region param; needs review\"]"}, {"sha": "b268c2a7a518b7ae08f975a3542453c82c74f7c5", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -424,6 +424,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.call(expr, pred, &**l, Some(&**r).into_iter())\n             }\n \n+            ast::ExprSlice(ref base, ref start, ref end, _) => {\n+                self.call(expr,\n+                          pred,\n+                          &**base,\n+                          start.iter().chain(end.iter()).map(|x| &**x))\n+            }\n+\n             ast::ExprUnary(_, ref e) if self.is_method_call(expr) => {\n                 self.call(expr, pred, &**e, None::<ast::Expr>.iter())\n             }"}, {"sha": "adb789665f35bc783d03c08d234cd5504d0792aa", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -316,7 +316,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             ast::ExprPath(..) => { }\n \n             ast::ExprUnary(ast::UnDeref, ref base) => {      // *base\n-                if !self.walk_overloaded_operator(expr, &**base, None) {\n+                if !self.walk_overloaded_operator(expr, &**base, Vec::new()) {\n                     self.select_from_expr(&**base);\n                 }\n             }\n@@ -330,12 +330,23 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             }\n \n             ast::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n-                if !self.walk_overloaded_operator(expr, &**lhs, Some(&**rhs)) {\n+                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs]) {\n                     self.select_from_expr(&**lhs);\n                     self.consume_expr(&**rhs);\n                 }\n             }\n \n+            ast::ExprSlice(ref base, ref start, ref end, _) => {    // base[start..end]\n+                let args = match (start, end) {\n+                    (&Some(ref e1), &Some(ref e2)) => vec![&**e1, &**e2],\n+                    (&Some(ref e), &None) => vec![&**e],\n+                    (&None, &Some(ref e)) => vec![&**e],\n+                    (&None, &None) => Vec::new()\n+                };\n+                let overloaded = self.walk_overloaded_operator(expr, &**base, args);\n+                assert!(overloaded);\n+            }\n+\n             ast::ExprCall(ref callee, ref args) => {    // callee(args)\n                 self.walk_callee(expr, &**callee);\n                 self.consume_exprs(args);\n@@ -430,13 +441,13 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             }\n \n             ast::ExprUnary(_, ref lhs) => {\n-                if !self.walk_overloaded_operator(expr, &**lhs, None) {\n+                if !self.walk_overloaded_operator(expr, &**lhs, Vec::new()) {\n                     self.consume_expr(&**lhs);\n                 }\n             }\n \n             ast::ExprBinary(_, ref lhs, ref rhs) => {\n-                if !self.walk_overloaded_operator(expr, &**lhs, Some(&**rhs)) {\n+                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs]) {\n                     self.consume_expr(&**lhs);\n                     self.consume_expr(&**rhs);\n                 }\n@@ -774,7 +785,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     fn walk_overloaded_operator(&mut self,\n                                 expr: &ast::Expr,\n                                 receiver: &ast::Expr,\n-                                rhs: Option<&ast::Expr>)\n+                                rhs: Vec<&ast::Expr>)\n                                 -> bool\n     {\n         if !self.typer.is_method_call(expr.id) {"}, {"sha": "daba3b701c03bdac4e8907a6040e04b903f21a51", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -247,6 +247,8 @@ lets_do_this! {\n     ShrTraitLangItem,                \"shr\",                     shr_trait;\n     IndexTraitLangItem,              \"index\",                   index_trait;\n     IndexMutTraitLangItem,           \"index_mut\",               index_mut_trait;\n+    SliceTraitLangItem,              \"slice\",                   slice_trait;\n+    SliceMutTraitLangItem,           \"slice_mut\",               slice_mut_trait;\n \n     UnsafeTypeLangItem,              \"unsafe\",                  unsafe_type;\n "}, {"sha": "ac5f9df6bfea8587b7e0da7f54b0cf8f73858049", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -501,7 +501,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n \n       // otherwise, live nodes are not required:\n       ExprIndex(..) | ExprField(..) | ExprTupField(..) | ExprVec(..) |\n-      ExprCall(..) | ExprMethodCall(..) | ExprTup(..) |\n+      ExprCall(..) | ExprMethodCall(..) | ExprTup(..) | ExprSlice(..) |\n       ExprBinary(..) | ExprAddrOf(..) |\n       ExprCast(..) | ExprUnary(..) | ExprBreak(_) |\n       ExprAgain(_) | ExprLit(_) | ExprRet(..) | ExprBlock(..) |\n@@ -1174,6 +1174,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**l, r_succ)\n           }\n \n+          ExprSlice(ref e1, ref e2, ref e3, _) => {\n+            let succ = e3.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n+            let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n+            self.propagate_through_expr(&**e1, succ)\n+          }\n+\n           ExprAddrOf(_, ref e) |\n           ExprCast(ref e, _) |\n           ExprUnary(_, ref e) |\n@@ -1457,7 +1463,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ExprWhile(..) | ExprLoop(..) | ExprIndex(..) | ExprField(..) |\n       ExprTupField(..) | ExprVec(..) | ExprTup(..) | ExprBinary(..) |\n       ExprCast(..) | ExprUnary(..) | ExprRet(..) | ExprBreak(..) |\n-      ExprAgain(..) | ExprLit(_) | ExprBlock(..) |\n+      ExprAgain(..) | ExprLit(_) | ExprBlock(..) | ExprSlice(..) |\n       ExprMac(..) | ExprAddrOf(..) | ExprStruct(..) | ExprRepeat(..) |\n       ExprParen(..) | ExprFnBlock(..) | ExprProc(..) | ExprUnboxedFn(..) |\n       ExprPath(..) | ExprBox(..) => {"}, {"sha": "7c620bd8c825f83a11d521d57bb187d56d3d3102", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -494,7 +494,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n           ast::ExprFnBlock(..) | ast::ExprProc(..) |\n           ast::ExprUnboxedFn(..) | ast::ExprRet(..) |\n-          ast::ExprUnary(..) |\n+          ast::ExprUnary(..) | ast::ExprSlice(..) |\n           ast::ExprMethodCall(..) | ast::ExprCast(..) |\n           ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprIf(..) |\n           ast::ExprBinary(..) | ast::ExprWhile(..) |"}, {"sha": "53c13f5628455864fee4c8e36546284165f92085", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -858,10 +858,10 @@ pub enum CallArgs<'a> {\n     // value.\n     ArgVals(&'a [ValueRef]),\n \n-    // For overloaded operators: `(lhs, Option(rhs, rhs_id))`. `lhs`\n+    // For overloaded operators: `(lhs, Vec(rhs, rhs_id))`. `lhs`\n     // is the left-hand-side and `rhs/rhs_id` is the datum/expr-id of\n-    // the right-hand-side (if any).\n-    ArgOverloadedOp(Datum<Expr>, Option<(Datum<Expr>, ast::NodeId)>),\n+    // the right-hand-side arguments (if any).\n+    ArgOverloadedOp(Datum<Expr>, Vec<(Datum<Expr>, ast::NodeId)>),\n \n     // Supply value of arguments as a list of expressions that must be\n     // translated, for overloaded call operators.\n@@ -1045,17 +1045,13 @@ pub fn trans_args<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                 DontAutorefArg)\n             }));\n \n-            match rhs {\n-                Some((rhs, rhs_id)) => {\n-                    assert_eq!(arg_tys.len(), 2);\n-\n-                    llargs.push(unpack_result!(bcx, {\n-                        trans_arg_datum(bcx, *arg_tys.get(1), rhs,\n-                                        arg_cleanup_scope,\n-                                        DoAutorefArg(rhs_id))\n-                    }));\n-                }\n-                None => assert_eq!(arg_tys.len(), 1)\n+            assert_eq!(arg_tys.len(), 1 + rhs.len());\n+            for (rhs, rhs_id) in rhs.move_iter() {\n+                llargs.push(unpack_result!(bcx, {\n+                    trans_arg_datum(bcx, *arg_tys.get(1), rhs,\n+                                    arg_cleanup_scope,\n+                                    DoAutorefArg(rhs_id))\n+                }));\n             }\n         }\n         ArgVals(vs) => {"}, {"sha": "2d6b08ce2708363df49371ade8dc3338bed9df42", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -3479,6 +3479,12 @@ fn populate_scope_map(cx: &CrateContext,\n                 walk_expr(cx, &**rhs, scope_stack, scope_map);\n             }\n \n+            ast::ExprSlice(ref base, ref start, ref end, _) => {\n+                walk_expr(cx, &**base, scope_stack, scope_map);\n+                start.as_ref().map(|x| walk_expr(cx, &**x, scope_stack, scope_map));\n+                end.as_ref().map(|x| walk_expr(cx, &**x, scope_stack, scope_map));\n+            }\n+\n             ast::ExprVec(ref init_expressions) |\n             ast::ExprTup(ref init_expressions) => {\n                 for ie in init_expressions.iter() {"}, {"sha": "cfbe362a0aad1f8a1e176560f1e51d1006fd4387", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -589,6 +589,34 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprIndex(ref base, ref idx) => {\n             trans_index(bcx, expr, &**base, &**idx, MethodCall::expr(expr.id))\n         }\n+        ast::ExprSlice(ref base, ref start, ref end, _) => {\n+            let _icx = push_ctxt(\"trans_slice\");\n+            let ccx = bcx.ccx();\n+\n+            let method_call = MethodCall::expr(expr.id);\n+            let method_ty = ccx.tcx()\n+                               .method_map\n+                               .borrow()\n+                               .find(&method_call)\n+                               .map(|method| method.ty);\n+            let base_datum = unpack_datum!(bcx, trans(bcx, &**base));\n+\n+            let mut args = vec![];\n+            start.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n+            end.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n+\n+            let result_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty.unwrap()));\n+            let scratch = rvalue_scratch_datum(bcx, result_ty, \"trans_slice\");\n+\n+            unpack_result!(bcx,\n+                           trans_overloaded_op(bcx,\n+                                               expr,\n+                                               method_call,\n+                                               base_datum,\n+                                               args,\n+                                               Some(SaveIn(scratch.val))));\n+            DatumBlock::new(bcx, scratch.to_expr_datum())\n+        }\n         ast::ExprBox(_, ref contents) => {\n             // Special case for `Box<T>` and `Gc<T>`\n             let box_ty = expr_ty(bcx, expr);\n@@ -724,7 +752,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                    index_expr,\n                                                    method_call,\n                                                    base_datum,\n-                                                   Some((ix_datum, idx.id)),\n+                                                   vec![(ix_datum, idx.id)],\n                                                    None));\n             let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty));\n             let elt_ty = match ty::deref(ref_ty, true) {\n@@ -1043,20 +1071,20 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let lhs = unpack_datum!(bcx, trans(bcx, &**lhs));\n             let rhs_datum = unpack_datum!(bcx, trans(bcx, &**rhs));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), lhs,\n-                                Some((rhs_datum, rhs.id)), Some(dest)).bcx\n+                                vec![(rhs_datum, rhs.id)], Some(dest)).bcx\n         }\n         ast::ExprUnary(_, ref subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n             let arg = unpack_datum!(bcx, trans(bcx, &**subexpr));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id),\n-                                arg, None, Some(dest)).bcx\n+                                arg, Vec::new(), Some(dest)).bcx\n         }\n         ast::ExprIndex(ref base, ref idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n             let base = unpack_datum!(bcx, trans(bcx, &**base));\n             let idx_datum = unpack_datum!(bcx, trans(bcx, &**idx));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), base,\n-                                Some((idx_datum, idx.id)), Some(dest)).bcx\n+                                vec![(idx_datum, idx.id)], Some(dest)).bcx\n         }\n         ast::ExprCast(ref val, _) => {\n             // DPS output mode means this is a trait cast:\n@@ -1740,7 +1768,7 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    expr: &ast::Expr,\n                                    method_call: MethodCall,\n                                    lhs: Datum<Expr>,\n-                                   rhs: Option<(Datum<Expr>, ast::NodeId)>,\n+                                   rhs: Vec<(Datum<Expr>, ast::NodeId)>,\n                                    dest: Option<Dest>)\n                                    -> Result<'blk, 'tcx> {\n     let method_ty = bcx.tcx().method_map.borrow().get(&method_call).ty;\n@@ -2063,7 +2091,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n             unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,\n-                                                    datum, None, Some(SaveIn(scratch.val))));\n+                                                    datum, Vec::new(), Some(SaveIn(scratch.val))));\n             scratch.to_expr_datum()\n         }\n         None => {"}, {"sha": "e287ce8cc18079b5aaa604d9b27d859ed423b541", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -3646,6 +3646,9 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             // the index method invoked for `a[i]` always yields an `&T`\n             ast::ExprIndex(..) => LvalueExpr,\n \n+            // the slice method invoked for `a[..]` always yields an `&T`\n+            ast::ExprSlice(..) => LvalueExpr,\n+\n             // `for` loops are statements\n             ast::ExprForLoop(..) => RvalueStmtExpr,\n \n@@ -3698,7 +3701,8 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprUnary(ast::UnDeref, _) |\n         ast::ExprField(..) |\n         ast::ExprTupField(..) |\n-        ast::ExprIndex(..) => {\n+        ast::ExprIndex(..) |\n+        ast::ExprSlice(..) => {\n             LvalueExpr\n         }\n "}, {"sha": "f50eacda6201ca6b79d627e56051f44ead4d8f22", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 205, "deletions": 62, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -109,7 +109,7 @@ use middle::typeck::rscope::RegionScope;\n use middle::typeck::{lookup_def_ccx};\n use middle::typeck::no_params;\n use middle::typeck::{require_same_types};\n-use middle::typeck::{MethodCall, MethodMap, ObjectCastMap};\n+use middle::typeck::{MethodCall, MethodCallee, MethodMap, ObjectCastMap};\n use middle::typeck::{TypeAndSubsts};\n use middle::typeck;\n use middle::lang_items::TypeIdLangItem;\n@@ -123,7 +123,6 @@ use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n use std::mem::replace;\n use std::rc::Rc;\n-use std::slice;\n use syntax::abi;\n use syntax::ast::{ProvidedMethod, RequiredMethod, TypeTraitItem};\n use syntax::ast;\n@@ -2187,12 +2186,12 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n }\n \n /// Attempts to resolve a call expression as an overloaded call.\n-fn try_overloaded_call(fcx: &FnCtxt,\n-                       call_expression: &ast::Expr,\n-                       callee: &ast::Expr,\n-                       callee_type: ty::t,\n-                       args: &[P<ast::Expr>])\n-                       -> bool {\n+fn try_overloaded_call<'a>(fcx: &FnCtxt,\n+                           call_expression: &ast::Expr,\n+                           callee: &ast::Expr,\n+                           callee_type: ty::t,\n+                           args: &[&'a P<ast::Expr>])\n+                           -> bool {\n     // Bail out if the callee is a bare function or a closure. We check those\n     // manually.\n     match *structure_of(fcx, callee.span, callee_type) {\n@@ -2275,18 +2274,125 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n         (method, _) => method\n     };\n \n+    make_return_type(fcx, method_call, method)\n+}\n+\n+fn get_method_ty(method: &Option<MethodCallee>) -> ty::t {\n+    match method {\n+        &Some(ref method) => method.ty,\n+        &None => ty::mk_err()\n+    }\n+}\n+\n+fn make_return_type(fcx: &FnCtxt,\n+                    method_call: Option<MethodCall>,\n+                    method: Option<MethodCallee>)\n+                    -> Option<ty::mt> {\n     match method {\n         Some(method) => {\n             let ref_ty = ty::ty_fn_ret(method.ty);\n             match method_call {\n                 Some(method_call) => {\n-                    fcx.inh.method_map.borrow_mut().insert(method_call, method);\n+                    fcx.inh.method_map.borrow_mut().insert(method_call,\n+                                                           method);\n                 }\n                 None => {}\n             }\n             ty::deref(ref_ty, true)\n         }\n-        None => None\n+        None => None,\n+    }\n+}\n+\n+fn try_overloaded_slice(fcx: &FnCtxt,\n+                        method_call: Option<MethodCall>,\n+                        expr: &ast::Expr,\n+                        base_expr: &ast::Expr,\n+                        base_ty: ty::t,\n+                        start_expr: &Option<P<ast::Expr>>,\n+                        end_expr: &Option<P<ast::Expr>>,\n+                        mutbl: &ast::Mutability)\n+                        -> Option<ty::mt> {\n+    let method = if mutbl == &ast::MutMutable {\n+        // Try `SliceMut` first, if preferred.\n+        match fcx.tcx().lang_items.slice_mut_trait() {\n+            Some(trait_did) => {\n+                let method_name = match (start_expr, end_expr) {\n+                    (&Some(_), &Some(_)) => \"slice_mut_\",\n+                    (&Some(_), &None) => \"slice_from_mut_\",\n+                    (&None, &Some(_)) => \"slice_to_mut_\",\n+                    (&None, &None) => \"as_mut_slice_\",\n+                };\n+\n+                method::lookup_in_trait(fcx,\n+                                        expr.span,\n+                                        Some(&*base_expr),\n+                                        token::intern(method_name),\n+                                        trait_did,\n+                                        base_ty,\n+                                        [],\n+                                        DontAutoderefReceiver,\n+                                        IgnoreStaticMethods)\n+            }\n+            _ => None,\n+        }\n+    } else {\n+        // Otherwise, fall back to `Slice`.\n+        // FIXME(#17293) this will not coerce base_expr, so we miss the Slice\n+        // trait for `&mut [T]`.\n+        match fcx.tcx().lang_items.slice_trait() {\n+            Some(trait_did) => {\n+                let method_name = match (start_expr, end_expr) {\n+                    (&Some(_), &Some(_)) => \"slice_\",\n+                    (&Some(_), &None) => \"slice_from_\",\n+                    (&None, &Some(_)) => \"slice_to_\",\n+                    (&None, &None) => \"as_slice_\",\n+                };\n+\n+                method::lookup_in_trait(fcx,\n+                                        expr.span,\n+                                        Some(&*base_expr),\n+                                        token::intern(method_name),\n+                                        trait_did,\n+                                        base_ty,\n+                                        [],\n+                                        DontAutoderefReceiver,\n+                                        IgnoreStaticMethods)\n+            }\n+            _ => None,\n+        }\n+    };\n+\n+\n+    // Regardless of whether the lookup succeeds, check the method arguments\n+    // so that we have *some* type for each argument.\n+    let method_type = get_method_ty(&method);\n+\n+    let mut args = vec![];\n+    start_expr.as_ref().map(|x| args.push(x));\n+    end_expr.as_ref().map(|x| args.push(x));\n+\n+    check_method_argument_types(fcx,\n+                                expr.span,\n+                                method_type,\n+                                expr,\n+                                args.as_slice(),\n+                                DoDerefArgs,\n+                                DontTupleArguments);\n+\n+    match method {\n+        Some(method) => {\n+            let result_ty = ty::ty_fn_ret(method.ty);\n+            match method_call {\n+                Some(method_call) => {\n+                    fcx.inh.method_map.borrow_mut().insert(method_call,\n+                                                           method);\n+                }\n+                None => {}\n+            }\n+            Some(ty::mt { ty: result_ty, mutbl: ast::MutImmutable })\n+        }\n+        None => None,\n     }\n }\n \n@@ -2332,32 +2438,16 @@ fn try_overloaded_index(fcx: &FnCtxt,\n \n     // Regardless of whether the lookup succeeds, check the method arguments\n     // so that we have *some* type for each argument.\n-    let method_type = match method {\n-        Some(ref method) => method.ty,\n-        None => ty::mk_err()\n-    };\n+    let method_type = get_method_ty(&method);\n     check_method_argument_types(fcx,\n                                 expr.span,\n                                 method_type,\n                                 expr,\n-                                slice::ref_slice(index_expr),\n+                                &[index_expr],\n                                 DoDerefArgs,\n                                 DontTupleArguments);\n \n-    match method {\n-        Some(method) => {\n-            let ref_ty = ty::ty_fn_ret(method.ty);\n-            match method_call {\n-                Some(method_call) => {\n-                    fcx.inh.method_map.borrow_mut().insert(method_call,\n-                                                           method);\n-                }\n-                None => {}\n-            }\n-            ty::deref(ref_ty, true)\n-        }\n-        None => None,\n-    }\n+    make_return_type(fcx, method_call, method)\n }\n \n /// Given the head of a `for` expression, looks up the `next` method in the\n@@ -2441,14 +2531,14 @@ fn lookup_method_for_for_loop(fcx: &FnCtxt,\n     }\n }\n \n-fn check_method_argument_types(fcx: &FnCtxt,\n-                               sp: Span,\n-                               method_fn_ty: ty::t,\n-                               callee_expr: &ast::Expr,\n-                               args_no_rcvr: &[P<ast::Expr>],\n-                               deref_args: DerefArgs,\n-                               tuple_arguments: TupleArgumentsFlag)\n-                               -> ty::t {\n+fn check_method_argument_types<'a>(fcx: &FnCtxt,\n+                                   sp: Span,\n+                                   method_fn_ty: ty::t,\n+                                   callee_expr: &ast::Expr,\n+                                   args_no_rcvr: &[&'a P<ast::Expr>],\n+                                   deref_args: DerefArgs,\n+                                   tuple_arguments: TupleArgumentsFlag)\n+                                   -> ty::t {\n     if ty::type_is_error(method_fn_ty) {\n        let err_inputs = err_args(args_no_rcvr.len());\n         check_argument_types(fcx,\n@@ -2482,14 +2572,14 @@ fn check_method_argument_types(fcx: &FnCtxt,\n     }\n }\n \n-fn check_argument_types(fcx: &FnCtxt,\n-                        sp: Span,\n-                        fn_inputs: &[ty::t],\n-                        _callee_expr: &ast::Expr,\n-                        args: &[P<ast::Expr>],\n-                        deref_args: DerefArgs,\n-                        variadic: bool,\n-                        tuple_arguments: TupleArgumentsFlag) {\n+fn check_argument_types<'a>(fcx: &FnCtxt,\n+                            sp: Span,\n+                            fn_inputs: &[ty::t],\n+                            _callee_expr: &ast::Expr,\n+                            args: &[&'a P<ast::Expr>],\n+                            deref_args: DerefArgs,\n+                            variadic: bool,\n+                            tuple_arguments: TupleArgumentsFlag) {\n     /*!\n      *\n      * Generic function that factors out common logic from\n@@ -2626,7 +2716,7 @@ fn check_argument_types(fcx: &FnCtxt,\n                     DontDerefArgs => {}\n                 }\n \n-                check_expr_coercable_to_type(fcx, &**arg, formal_ty);\n+                check_expr_coercable_to_type(fcx, &***arg, formal_ty);\n             }\n         }\n     }\n@@ -2635,12 +2725,12 @@ fn check_argument_types(fcx: &FnCtxt,\n     // arguments which we skipped above.\n     if variadic {\n         for arg in args.iter().skip(expected_arg_count) {\n-            check_expr(fcx, &**arg);\n+            check_expr(fcx, &***arg);\n \n             // There are a few types which get autopromoted when passed via varargs\n             // in C but we just error out instead and require explicit casts.\n             let arg_ty = structurally_resolved_type(fcx, arg.span,\n-                                                    fcx.expr_ty(&**arg));\n+                                                    fcx.expr_ty(&***arg));\n             match ty::get(arg_ty).sty {\n                 ty::ty_float(ast::TyF32) => {\n                     fcx.type_error_message(arg.span,\n@@ -2876,10 +2966,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n            expr.repr(fcx.tcx()), expected.repr(fcx.tcx()));\n \n     // A generic function for doing all of the checking for call expressions\n-    fn check_call(fcx: &FnCtxt,\n-                  call_expr: &ast::Expr,\n-                  f: &ast::Expr,\n-                  args: &[P<ast::Expr>]) {\n+    fn check_call<'a>(fcx: &FnCtxt,\n+                      call_expr: &ast::Expr,\n+                      f: &ast::Expr,\n+                      args: &[&'a P<ast::Expr>]) {\n         // Store the type of `f` as the type of the callee\n         let fn_ty = fcx.expr_ty(f);\n \n@@ -2989,11 +3079,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         };\n \n         // Call the generic checker.\n+        let args: Vec<_> = args.slice_from(1).iter().map(|x| x).collect();\n         let ret_ty = check_method_argument_types(fcx,\n                                                  method_name.span,\n                                                  fn_ty,\n                                                  expr,\n-                                                 args.slice_from(1),\n+                                                 args.as_slice(),\n                                                  DontDerefArgs,\n                                                  DontTupleArguments);\n \n@@ -3084,12 +3175,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             None => None\n         };\n         let args = match rhs {\n-            Some(rhs) => slice::ref_slice(rhs),\n-            None => {\n-                // Work around the lack of coercion.\n-                let empty: &[_] = &[];\n-                empty\n-            }\n+            Some(rhs) => vec![rhs],\n+            None => vec![]\n         };\n         match method {\n             Some(method) => {\n@@ -3101,7 +3188,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                             op_ex.span,\n                                             method_ty,\n                                             op_ex,\n-                                            args,\n+                                            args.as_slice(),\n                                             DoDerefArgs,\n                                             DontTupleArguments)\n             }\n@@ -3114,7 +3201,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                             op_ex.span,\n                                             expected_ty,\n                                             op_ex,\n-                                            args,\n+                                            args.as_slice(),\n                                             DoDerefArgs,\n                                             DontTupleArguments);\n                 ty::mk_err()\n@@ -4135,12 +4222,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           check_expr(fcx, &**f);\n           let f_ty = fcx.expr_ty(&**f);\n \n+          let args: Vec<_> = args.iter().map(|x| x).collect();\n           if !try_overloaded_call(fcx, expr, &**f, f_ty, args.as_slice()) {\n               check_call(fcx, expr, &**f, args.as_slice());\n               let (args_bot, args_err) = args.iter().fold((false, false),\n                  |(rest_bot, rest_err), a| {\n                      // is this not working?\n-                     let a_ty = fcx.expr_ty(&**a);\n+                     let a_ty = fcx.expr_ty(&***a);\n                      (rest_bot || ty::type_is_bot(a_ty),\n                       rest_err || ty::type_is_error(a_ty))});\n               if ty::type_is_error(f_ty) || args_err {\n@@ -4426,6 +4514,61 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n               }\n           }\n        }\n+       ast::ExprSlice(ref base, ref start, ref end, ref mutbl) => {\n+          check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n+          let raw_base_t = fcx.expr_ty(&**base);\n+\n+          let mut some_err = false;\n+          if ty::type_is_error(raw_base_t) || ty::type_is_bot(raw_base_t) {\n+              fcx.write_ty(id, raw_base_t);\n+              some_err = true;\n+          }\n+\n+          {\n+              let check_slice_idx = |e: &ast::Expr| {\n+                  check_expr(fcx, e);\n+                  let e_t = fcx.expr_ty(e);\n+                  if ty::type_is_error(e_t) || ty::type_is_bot(e_t) {\n+                    fcx.write_ty(id, e_t);\n+                    some_err = true;\n+                  }\n+              };\n+              start.as_ref().map(|e| check_slice_idx(&**e));\n+              end.as_ref().map(|e| check_slice_idx(&**e));\n+          }\n+\n+          if !some_err {\n+              let base_t = structurally_resolved_type(fcx,\n+                                                      expr.span,\n+                                                      raw_base_t);\n+              let method_call = MethodCall::expr(expr.id);\n+              match try_overloaded_slice(fcx,\n+                                         Some(method_call),\n+                                         expr,\n+                                         &**base,\n+                                         base_t,\n+                                         start,\n+                                         end,\n+                                         mutbl) {\n+                  Some(mt) => fcx.write_ty(id, mt.ty),\n+                  None => {\n+                        fcx.type_error_message(expr.span,\n+                           |actual| {\n+                                format!(\"cannot take a {}slice of a value with type `{}`\",\n+                                        if mutbl == &ast::MutMutable {\n+                                            \"mutable \"\n+                                        } else {\n+                                            \"\"\n+                                        },\n+                                        actual)\n+                           },\n+                           base_t,\n+                           None);\n+                        fcx.write_ty(id, ty::mk_err())\n+                  }\n+              }\n+          }\n+       }\n     }\n \n     debug!(\"type of expr({}) {} is...\", expr.id,"}, {"sha": "f98a2dac0841cd5ebbd37a7252b26a11fdd8a748", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -245,6 +245,7 @@ mod svh_visitor {\n         SawExprAssign,\n         SawExprAssignOp(ast::BinOp),\n         SawExprIndex,\n+        SawExprSlice,\n         SawExprPath,\n         SawExprAddrOf(ast::Mutability),\n         SawExprRet,\n@@ -279,6 +280,7 @@ mod svh_visitor {\n             ExprField(_, id, _)      => SawExprField(content(id.node)),\n             ExprTupField(_, id, _)   => SawExprTupField(id.node),\n             ExprIndex(..)            => SawExprIndex,\n+            ExprSlice(..)            => SawExprSlice,\n             ExprPath(..)             => SawExprPath,\n             ExprAddrOf(m, _)         => SawExprAddrOf(m),\n             ExprBreak(id)            => SawExprBreak(id.map(content)),"}, {"sha": "5c84745c20c6fabc1d4c8cd5854c72c356a91d2d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -538,6 +538,7 @@ pub enum Expr_ {\n     ExprField(P<Expr>, SpannedIdent, Vec<P<Ty>>),\n     ExprTupField(P<Expr>, Spanned<uint>, Vec<P<Ty>>),\n     ExprIndex(P<Expr>, P<Expr>),\n+    ExprSlice(P<Expr>, Option<P<Expr>>, Option<P<Expr>>, Mutability),\n \n     /// Variable reference, possibly containing `::` and/or\n     /// type parameters, e.g. foo::bar::<baz>"}, {"sha": "7ebb11c148bd2964973becee5635e76b2c87a025", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -1252,6 +1252,12 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n             ExprIndex(el, er) => {\n                 ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n             }\n+            ExprSlice(e, e1, e2, m) => {\n+                ExprSlice(folder.fold_expr(e),\n+                          e1.map(|x| folder.fold_expr(x)),\n+                          e2.map(|x| folder.fold_expr(x)),\n+                          m)\n+            }\n             ExprPath(pth) => ExprPath(folder.fold_path(pth)),\n             ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|x| folder.fold_ident(x))),\n             ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|x| folder.fold_ident(x))),"}, {"sha": "069d30cbd835416c3e655a47aed42593b6fc9605", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 96, "deletions": 9, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -23,7 +23,7 @@ use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, EMPTY_CTXT, EnumDef, Explicit\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n use ast::{ExprBreak, ExprCall, ExprCast};\n-use ast::{ExprField, ExprTupField, ExprFnBlock, ExprIf, ExprIndex};\n+use ast::{ExprField, ExprTupField, ExprFnBlock, ExprIf, ExprIndex, ExprSlice};\n use ast::{ExprLit, ExprLoop, ExprMac};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary, ExprUnboxedFn};\n@@ -1987,6 +1987,14 @@ impl<'a> Parser<'a> {\n         ExprIndex(expr, idx)\n     }\n \n+    pub fn mk_slice(&mut self, expr: P<Expr>,\n+                    start: Option<P<Expr>>,\n+                    end: Option<P<Expr>>,\n+                    mutbl: Mutability)\n+                    -> ast::Expr_ {\n+        ExprSlice(expr, start, end, mutbl)\n+    }\n+\n     pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent,\n                     tys: Vec<P<Ty>>) -> ast::Expr_ {\n         ExprField(expr, ident, tys)\n@@ -2401,13 +2409,87 @@ impl<'a> Parser<'a> {\n               }\n \n               // expr[...]\n+              // Could be either an index expression or a slicing expression.\n+              // Any slicing non-terminal can have a mutable version with `mut`\n+              // after the opening square bracket.\n               token::LBRACKET => {\n                 self.bump();\n-                let ix = self.parse_expr();\n-                hi = self.span.hi;\n-                self.commit_expr_expecting(&*ix, token::RBRACKET);\n-                let index = self.mk_index(e, ix);\n-                e = self.mk_expr(lo, hi, index)\n+                let mutbl = if self.eat_keyword(keywords::Mut) {\n+                    MutMutable\n+                } else {\n+                    MutImmutable\n+                };\n+                match self.token {\n+                    // e[]\n+                    token::RBRACKET => {\n+                        self.bump();\n+                        hi = self.span.hi;\n+                        let slice = self.mk_slice(e, None, None, mutbl);\n+                        e = self.mk_expr(lo, hi, slice)\n+                    }\n+                    // e[..e]\n+                    token::DOTDOT => {\n+                        self.bump();\n+                        match self.token {\n+                            // e[..]\n+                            token::RBRACKET => {\n+                                self.bump();\n+                                hi = self.span.hi;\n+                                let slice = self.mk_slice(e, None, None, mutbl);\n+                                e = self.mk_expr(lo, hi, slice);\n+\n+                                self.span_err(e.span, \"incorrect slicing expression: `[..]`\");\n+                                self.span_note(e.span,\n+                                    \"use `expr[]` to construct a slice of the whole of expr\");\n+                            }\n+                            // e[..e]\n+                            _ => {\n+                                hi = self.span.hi;\n+                                let e2 = self.parse_expr();\n+                                self.commit_expr_expecting(&*e2, token::RBRACKET);\n+                                let slice = self.mk_slice(e, None, Some(e2), mutbl);\n+                                e = self.mk_expr(lo, hi, slice)\n+                            }\n+                        }\n+                    }\n+                    // e[e] | e[e..] | e[e..e]\n+                    _ => {\n+                        let ix = self.parse_expr();\n+                        match self.token {\n+                            // e[e..] | e[e..e]\n+                            token::DOTDOT => {\n+                                self.bump();\n+                                let e2 = match self.token {\n+                                    // e[e..]\n+                                    token::RBRACKET => {\n+                                        self.bump();\n+                                        None\n+                                    }\n+                                    // e[e..e]\n+                                    _ => {\n+                                        let e2 = self.parse_expr();\n+                                        self.commit_expr_expecting(&*e2, token::RBRACKET);\n+                                        Some(e2)\n+                                    }\n+                                };\n+                                hi = self.span.hi;\n+                                let slice = self.mk_slice(e, Some(ix), e2, mutbl);\n+                                e = self.mk_expr(lo, hi, slice)\n+                            }\n+                            // e[e]\n+                            _ => {\n+                                if mutbl == ast::MutMutable {\n+                                    self.span_err(e.span,\n+                                                  \"`mut` keyword is invalid in index expressions\");\n+                                }\n+                                hi = self.span.hi;\n+                                self.commit_expr_expecting(&*ix, token::RBRACKET);\n+                                let index = self.mk_index(e, ix);\n+                                e = self.mk_expr(lo, hi, index)\n+                            }\n+                        }\n+                    }\n+                }\n               }\n \n               _ => return e\n@@ -3154,7 +3236,8 @@ impl<'a> Parser<'a> {\n             // These expressions are limited to literals (possibly\n             // preceded by unary-minus) or identifiers.\n             let val = self.parse_literal_maybe_minus();\n-            if self.token == token::DOTDOT &&\n+            // FIXME(#17295) remove the DOTDOT option.\n+            if (self.token == token::DOTDOTDOT || self.token == token::DOTDOT) &&\n                     self.look_ahead(1, |t| {\n                         *t != token::COMMA && *t != token::RBRACKET\n                     }) {\n@@ -3199,12 +3282,16 @@ impl<'a> Parser<'a> {\n                 }\n             });\n \n-            if self.look_ahead(1, |t| *t == token::DOTDOT) &&\n+            // FIXME(#17295) remove the DOTDOT option.\n+            if self.look_ahead(1, |t| *t == token::DOTDOTDOT || *t == token::DOTDOT) &&\n                     self.look_ahead(2, |t| {\n                         *t != token::COMMA && *t != token::RBRACKET\n                     }) {\n                 let start = self.parse_expr_res(RestrictionNoBarOp);\n-                self.eat(&token::DOTDOT);\n+                // FIXME(#17295) remove the DOTDOT option (self.eat(&token::DOTDOTDOT)).\n+                if self.token == token::DOTDOTDOT || self.token == token::DOTDOT {\n+                    self.bump();\n+                }\n                 let end = self.parse_expr_res(RestrictionNoBarOp);\n                 pat = PatRange(start, end);\n             } else if is_plain_ident(&self.token) && !can_be_enum_or_struct {"}, {"sha": "473179a037a527409aad2c14b3e51e04aa73d706", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -1651,6 +1651,28 @@ impl<'a> State<'a> {\n                 try!(self.print_expr(&**index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n+            ast::ExprSlice(ref e, ref start, ref end, ref mutbl) => {\n+                try!(self.print_expr(&**e));\n+                try!(word(&mut self.s, \"[\"));\n+                if mutbl == &ast::MutMutable {\n+                    try!(word(&mut self.s, \"mut\"));\n+                    if start.is_some() || end.is_some() {\n+                        try!(space(&mut self.s));\n+                    }\n+                }\n+                match start {\n+                    &Some(ref e) => try!(self.print_expr(&**e)),\n+                    _ => {}\n+                }\n+                if start.is_some() || end.is_some() {\n+                    try!(word(&mut self.s, \"..\"));\n+                }\n+                match end {\n+                    &Some(ref e) => try!(self.print_expr(&**e)),\n+                    _ => {}\n+                }\n+                try!(word(&mut self.s, \"]\"));\n+            }\n             ast::ExprPath(ref path) => try!(self.print_path(path, true)),\n             ast::ExprBreak(opt_ident) => {\n                 try!(word(&mut self.s, \"break\"));\n@@ -1944,7 +1966,7 @@ impl<'a> State<'a> {\n             ast::PatRange(ref begin, ref end) => {\n                 try!(self.print_expr(&**begin));\n                 try!(space(&mut self.s));\n-                try!(word(&mut self.s, \"..\"));\n+                try!(word(&mut self.s, \"...\"));\n                 try!(self.print_expr(&**end));\n             }\n             ast::PatVec(ref before, ref slice, ref after) => {"}, {"sha": "32084856817e1e961652cacfe54a1deb993625ff", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -785,6 +785,11 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(&**main_expression);\n             visitor.visit_expr(&**index_expression)\n         }\n+        ExprSlice(ref main_expression, ref start, ref end, _) => {\n+            visitor.visit_expr(&**main_expression);\n+            walk_expr_opt(visitor, start);\n+            walk_expr_opt(visitor, end)\n+        }\n         ExprPath(ref path) => {\n             visitor.visit_path(path, expression.id)\n         }"}, {"sha": "d0339745c9eafc9cb4e43599c967b8cb5ec2f47e", "filename": "src/test/compile-fail/slice-1.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Fcompile-fail%2Fslice-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Fcompile-fail%2Fslice-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-1.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test slicing expr[..] is an error and gives a helpful error message.\n+\n+struct Foo;\n+\n+fn main() {\n+    let x = Foo;\n+    x[..]; //~ ERROR incorrect slicing expression: `[..]`\n+    //~^ NOTE use `expr[]` to construct a slice of the whole of expr\n+}"}, {"sha": "fbfc438321c8e4ab22dea549b83bc52af85cb958", "filename": "src/test/compile-fail/slice-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-2.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that slicing syntax gives errors if we have not implemented the trait.\n+\n+struct Foo;\n+\n+fn main() {\n+    let x = Foo;\n+    x[]; //~ ERROR cannot take a slice of a value with type `Foo`\n+    x[Foo..]; //~ ERROR cannot take a slice of a value with type `Foo`\n+    x[..Foo]; //~ ERROR cannot take a slice of a value with type `Foo`\n+    x[Foo..Foo]; //~ ERROR cannot take a slice of a value with type `Foo`\n+    x[mut]; //~ ERROR cannot take a mutable slice of a value with type `Foo`\n+    x[mut Foo..]; //~ ERROR cannot take a mutable slice of a value with type `Foo`\n+    x[mut ..Foo]; //~ ERROR cannot take a mutable slice of a value with type `Foo`\n+    x[mut Foo..Foo]; //~ ERROR cannot take a mutable slice of a value with type `Foo`\n+}"}, {"sha": "3d12511134fa003d869babf982460a1a79ff9ea3", "filename": "src/test/compile-fail/slice-borrow.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test slicing expressions doesn't defeat the borrow checker.\n+\n+fn main() {\n+    let y;\n+    {\n+        let x: &[int] = &[1, 2, 3, 4, 5]; //~ ERROR borrowed value does not live long enough\n+        y = x[1..];\n+    }\n+}"}, {"sha": "1176b637cece091337be1faa8eceef0644442c63", "filename": "src/test/compile-fail/slice-mut-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test mutability and slicing syntax.\n+\n+fn main() {\n+    let x: &[int] = &[1, 2, 3, 4, 5];\n+    // Can't mutably slice an immutable slice\n+    let y = x[mut 2..4]; //~ ERROR cannot take a mutable slice of a value with type `&[int]`\n+}"}, {"sha": "8cd7c4ed0bb077d4808c382fa5c3df76807fe454", "filename": "src/test/compile-fail/slice-mut.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test mutability and slicing syntax.\n+\n+fn main() {\n+    let x: &[int] = &[1, 2, 3, 4, 5];\n+    // Immutable slices are not mutable.\n+    let y: &mut[_] = x[2..4]; //~ ERROR cannot borrow immutable dereference of `&`-pointer as mutabl\n+\n+    let x: &mut [int] = &mut [1, 2, 3, 4, 5];\n+    // Can't borrow mutably twice\n+    let y = x[mut 1..2];\n+    let y = x[mut 4..5]; //~ERROR cannot borrow\n+}"}, {"sha": "088756992453e2423b723ebfe8544b88244bb2d7", "filename": "src/test/run-pass/match-range-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Frun-pass%2Fmatch-range-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Frun-pass%2Fmatch-range-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-range-static.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -13,7 +13,7 @@ static e: int = 42;\n \n pub fn main() {\n     match 7 {\n-        s..e => (),\n+        s...e => (),\n         _ => (),\n     }\n }"}, {"sha": "3c0933a055cba7e788d85cadfecbb85327f43da4", "filename": "src/test/run-pass/slice-2.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Frun-pass%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Frun-pass%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-2.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test slicing expressions on slices and Vecs.\n+\n+fn main() {\n+    let x: &[int] = &[1, 2, 3, 4, 5];\n+    let cmp: &[int] = &[1, 2, 3, 4, 5];\n+    assert!(x[] == cmp)\n+    let cmp: &[int] = &[3, 4, 5];\n+    assert!(x[2..] == cmp)\n+    let cmp: &[int] = &[1, 2, 3];\n+    assert!(x[..3] == cmp)\n+    let cmp: &[int] = &[2, 3, 4];\n+    assert!(x[1..4] == cmp)\n+\n+    let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+    let cmp: &[int] = &[1, 2, 3, 4, 5];\n+    assert!(x[] == cmp)\n+    let cmp: &[int] = &[3, 4, 5];\n+    assert!(x[2..] == cmp)\n+    let cmp: &[int] = &[1, 2, 3];\n+    assert!(x[..3] == cmp)\n+    let cmp: &[int] = &[2, 3, 4];\n+    assert!(x[1..4] == cmp)\n+\n+    let x: &mut [int] = &mut [1, 2, 3, 4, 5];\n+    {\n+        let cmp: &mut [int] = &mut [1, 2, 3, 4, 5];\n+        assert!(x[mut] == cmp)\n+    }\n+    {\n+        let cmp: &mut [int] = &mut [3, 4, 5];\n+        assert!(x[mut 2..] == cmp)\n+    }\n+    {\n+        let cmp: &mut [int] = &mut [1, 2, 3];\n+        assert!(x[mut ..3] == cmp)\n+    }\n+    {\n+        let cmp: &mut [int] = &mut [2, 3, 4];\n+        assert!(x[mut 1..4] == cmp)\n+    }\n+\n+    let mut x: Vec<int> = vec![1, 2, 3, 4, 5];\n+    {\n+        let cmp: &mut [int] = &mut [1, 2, 3, 4, 5];\n+        assert!(x[mut] == cmp)\n+    }\n+    {\n+        let cmp: &mut [int] = &mut [3, 4, 5];\n+        assert!(x[mut 2..] == cmp)\n+    }\n+    {\n+        let cmp: &mut [int] = &mut [1, 2, 3];\n+        assert!(x[mut ..3] == cmp)\n+    }\n+    {\n+        let cmp: &mut [int] = &mut [2, 3, 4];\n+        assert!(x[mut 1..4] == cmp)\n+    }\n+}"}, {"sha": "f6972023a72a5830653b58c5adf5d429951fce83", "filename": "src/test/run-pass/slice-fail-1.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Frun-pass%2Fslice-fail-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Frun-pass%2Fslice-fail-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-fail-1.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that is a slicing expr[..] fails, the correct cleanups happen.\n+\n+use std::task;\n+\n+struct Foo;\n+\n+static mut DTOR_COUNT: int = 0;\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) { unsafe { DTOR_COUNT += 1; } }\n+}\n+\n+fn foo() {\n+    let x: &[_] = &[Foo, Foo];\n+    x[3..4];\n+}\n+\n+fn main() {\n+    let _ = task::try(proc() foo());\n+    unsafe { assert!(DTOR_COUNT == 2); }\n+}"}, {"sha": "cbe65fcd83d2dcaa1c44c4fd487e5b5e52049e11", "filename": "src/test/run-pass/slice-fail-2.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Frun-pass%2Fslice-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Frun-pass%2Fslice-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-fail-2.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that is a slicing expr[..] fails, the correct cleanups happen.\n+\n+use std::task;\n+\n+struct Foo;\n+\n+static mut DTOR_COUNT: int = 0;\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) { unsafe { DTOR_COUNT += 1; } }\n+}\n+\n+fn bar() -> uint {\n+    fail!();\n+}\n+\n+fn foo() {\n+    let x: &[_] = &[Foo, Foo];\n+    x[3..bar()];\n+}\n+\n+fn main() {\n+    let _ = task::try(proc() foo());\n+    unsafe { assert!(DTOR_COUNT == 2); }\n+}"}, {"sha": "39feb075add55ff87fa3e46dd50a275c724a9c49", "filename": "src/test/run-pass/slice.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Frun-pass%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ee3586b5d75497af25e77756be8f629d711aaf/src%2Ftest%2Frun-pass%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice.rs?ref=81ee3586b5d75497af25e77756be8f629d711aaf", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test slicing sugar.\n+\n+extern crate core;\n+use core::ops::{Slice,SliceMut};\n+\n+static mut COUNT: uint = 0;\n+\n+struct Foo;\n+\n+impl Slice<Foo, Foo> for Foo {\n+    fn as_slice_<'a>(&'a self) -> &'a Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+    fn slice_from_<'a>(&'a self, _from: &Foo) -> &'a Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+    fn slice_to_<'a>(&'a self, _to: &Foo) -> &'a Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+    fn slice_<'a>(&'a self, _from: &Foo, _to: &Foo) -> &'a Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+}\n+\n+impl SliceMut<Foo, Foo> for Foo {\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+    fn slice_from_mut_<'a>(&'a mut self, _from: &Foo) -> &'a mut Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+    fn slice_to_mut_<'a>(&'a mut self, _to: &Foo) -> &'a mut Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+    fn slice_mut_<'a>(&'a mut self, _from: &Foo, _to: &Foo) -> &'a mut Foo {\n+        unsafe { COUNT += 1; }\n+        self\n+    }\n+}\n+fn main() {\n+    let mut x = Foo;\n+    x[];\n+    x[Foo..];\n+    x[..Foo];\n+    x[Foo..Foo];\n+    x[mut];\n+    x[mut Foo..];\n+    x[mut ..Foo];\n+    x[mut Foo..Foo];\n+    unsafe {\n+        assert!(COUNT == 8);\n+    }\n+}"}]}