{"sha": "58c299f81de4f8deb46b3e6ec045298a669c59aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4YzI5OWY4MWRlNGY4ZGViNDZiM2U2ZWMwNDUyOThhNjY5YzU5YWE=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-10-15T18:37:21Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-10-27T19:55:04Z"}, "message": "Fix prefix range expressions being not parsed", "tree": {"sha": "36a79c87bede34cad01972142f0d4445acabdfb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36a79c87bede34cad01972142f0d4445acabdfb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58c299f81de4f8deb46b3e6ec045298a669c59aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58c299f81de4f8deb46b3e6ec045298a669c59aa", "html_url": "https://github.com/rust-lang/rust/commit/58c299f81de4f8deb46b3e6ec045298a669c59aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58c299f81de4f8deb46b3e6ec045298a669c59aa/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "884b58913ae27c3916f90ae05af01fd8030b6670", "url": "https://api.github.com/repos/rust-lang/rust/commits/884b58913ae27c3916f90ae05af01fd8030b6670", "html_url": "https://github.com/rust-lang/rust/commit/884b58913ae27c3916f90ae05af01fd8030b6670"}], "stats": {"total": 151, "additions": 77, "deletions": 74}, "files": [{"sha": "6845b92dac0b93bc8b9c6db4e720d5b35db63abd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 68, "deletions": 74, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/58c299f81de4f8deb46b3e6ec045298a669c59aa/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58c299f81de4f8deb46b3e6ec045298a669c59aa/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=58c299f81de4f8deb46b3e6ec045298a669c59aa", "patch": "@@ -2602,53 +2602,50 @@ impl<'a> Parser<'a> {\n     pub fn parse_prefix_expr(&mut self) -> PResult<P<Expr>> {\n         let lo = self.span.lo;\n         let hi;\n-\n         // Note: when adding new unary operators, don't forget to adjust Token::can_begin_expr()\n-        let ex;\n-        match self.token {\n-          token::Not => {\n-            try!(self.bump());\n-            let e = try!(self.parse_prefix_expr());\n-            hi = e.span.hi;\n-            ex = self.mk_unary(UnNot, e);\n-          }\n-          token::BinOp(token::Minus) => {\n-            try!(self.bump());\n-            let e = try!(self.parse_prefix_expr());\n-            hi = e.span.hi;\n-            ex = self.mk_unary(UnNeg, e);\n-          }\n-          token::BinOp(token::Star) => {\n-            try!(self.bump());\n-            let e = try!(self.parse_prefix_expr());\n-            hi = e.span.hi;\n-            ex = self.mk_unary(UnDeref, e);\n-          }\n-          token::BinOp(token::And) | token::AndAnd => {\n-            try!(self.expect_and());\n-            let m = try!(self.parse_mutability());\n-            let e = try!(self.parse_prefix_expr());\n-            hi = e.span.hi;\n-            ex = ExprAddrOf(m, e);\n-          }\n-          token::Ident(..) if self.token.is_keyword(keywords::In) => {\n-              try!(self.bump());\n-              let place = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n-              let blk = try!(self.parse_block());\n-              let span = blk.span;\n-              hi = span.hi;\n-              let blk_expr = self.mk_expr(span.lo, span.hi, ExprBlock(blk));\n-              self.span_warn(span, \"in PLACE BLOCK syntax is deprecated and will be removed soon\");\n-              ex = ExprInPlace(place, blk_expr);\n-          }\n-          token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n-              try!(self.bump());\n-              let subexpression = try!(self.parse_prefix_expr());\n-              hi = subexpression.span.hi;\n-              ex = ExprBox(subexpression);\n-          }\n-          _ => return self.parse_dot_or_call_expr()\n-        }\n+        let ex = match self.token {\n+            token::Not => {\n+                try!(self.bump());\n+                let e = try!(self.parse_prefix_expr());\n+                hi = e.span.hi;\n+                self.mk_unary(UnNot, e)\n+            }\n+            token::BinOp(token::Minus) => {\n+                try!(self.bump());\n+                let e = try!(self.parse_prefix_expr());\n+                hi = e.span.hi;\n+                self.mk_unary(UnNeg, e)\n+            }\n+            token::BinOp(token::Star) => {\n+                try!(self.bump());\n+                let e = try!(self.parse_prefix_expr());\n+                hi = e.span.hi;\n+                self.mk_unary(UnDeref, e)\n+            }\n+            token::BinOp(token::And) | token::AndAnd => {\n+                try!(self.expect_and());\n+                let m = try!(self.parse_mutability());\n+                let e = try!(self.parse_prefix_expr());\n+                hi = e.span.hi;\n+                ExprAddrOf(m, e)\n+            }\n+            token::Ident(..) if self.token.is_keyword(keywords::In) => {\n+                try!(self.bump());\n+                let place = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n+                let blk = try!(self.parse_block());\n+                let span = blk.span;\n+                hi = span.hi;\n+                let blk_expr = self.mk_expr(span.lo, span.hi, ExprBlock(blk));\n+                ExprInPlace(place, blk_expr)\n+            }\n+            token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n+                try!(self.bump());\n+                let subexpression = try!(self.parse_prefix_expr());\n+                hi = subexpression.span.hi;\n+                ExprBox(subexpression)\n+            }\n+            _ => return self.parse_dot_or_call_expr()\n+        };\n         return Ok(self.mk_expr(lo, hi, ex));\n     }\n \n@@ -2657,35 +2654,15 @@ impl<'a> Parser<'a> {\n     /// This parses an expression accounting for associativity and precedence of the operators in\n     /// the expression.\n     pub fn parse_assoc_expr(&mut self) -> PResult<P<Expr>> {\n-        if self.token == token::DotDot {\n-            // prefix-form of range notation `..expr` and `..`\n-            // This has the precedence just higher than assignment expressions (much lower than\n-            // other prefix expressions) to be consistent with the postfix-form `expr..`\n-            // If it isn\u2019t clear yet, this is a hack of the worst kind (one that also probably\n-            // can\u2019t be fixed anymore because stability guarantees).\n-            let lo = self.span.lo;\n-            let mut hi = self.span.hi;\n-            try!(self.bump());\n-            let opt_end = if self.is_at_start_of_range_notation_rhs() {\n-                // RHS must be parsed with more associativity than DotDot.\n-                let next_prec = AssocOp::from_token(&token::DotDot).unwrap().precedence() + 1;\n-                let end = try!(self.parse_assoc_expr_with(next_prec, None));\n-                hi = end.span.hi;\n-                Some(end)\n-            } else {\n-                None\n-            };\n-            let r = self.mk_range(None, opt_end);\n-            Ok(self.mk_expr(lo, hi, r))\n-        } else {\n-            self.parse_assoc_expr_with(0, None)\n-        }\n+        self.parse_assoc_expr_with(0, None)\n     }\n \n     /// Parse an associative expression with operators of at least `min_prec` precedence\n     pub fn parse_assoc_expr_with(&mut self, min_prec: usize, lhs: Option<P<Expr>>) -> PResult<P<Expr>> {\n         let mut lhs = if lhs.is_some() {\n             lhs.unwrap()\n+        } else if self.token == token::DotDot {\n+            return self.parse_prefix_range_expr();\n         } else {\n             try!(self.parse_prefix_expr())\n         };\n@@ -2710,13 +2687,10 @@ impl<'a> Parser<'a> {\n                 continue\n             } else if op == AssocOp::DotDot {\n                     // If we didn\u2019t have to handle `x..`, it would be pretty easy to generalise\n-                    // here by simply doing something along the lines of\n-                    //\n-                    //     break_from_this_loop_after_setting_lhs = true;\n-                    //     rhs = self.parse_assoc_expr_with(op.precedence() + 1, None);\n+                    // it to the Fixity::None code.\n                     //\n                     // We have 2 alternatives here: `x..y` and `x..` The other two variants are\n-                    // handled in `parse_assoc_expr`\n+                    // handled with `parse_prefix_range_expr` call above.\n                     let rhs = if self.is_at_start_of_range_notation_rhs() {\n                         self.parse_assoc_expr_with(op.precedence() + 1, None).ok()\n                     } else {\n@@ -2800,6 +2774,26 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Parse prefix-forms of range notation: `..expr` and `..`\n+    fn parse_prefix_range_expr(&mut self) -> PResult<P<Expr>> {\n+        debug_assert!(self.token == token::DotDot);\n+        let lo = self.span.lo;\n+        let mut hi = self.span.hi;\n+        try!(self.bump());\n+        let opt_end = if self.is_at_start_of_range_notation_rhs() {\n+            // RHS must be parsed with more associativity than DotDot.\n+            let next_prec = AssocOp::from_token(&token::DotDot).unwrap().precedence() + 1;\n+            Some(try!(self.parse_assoc_expr_with(next_prec, None).map(|x|{\n+                hi = x.span.hi;\n+                x\n+            })))\n+         } else {\n+            None\n+        };\n+        let r = self.mk_range(None, opt_end);\n+        Ok(self.mk_expr(lo, hi, r))\n+    }\n+\n     fn is_at_start_of_range_notation_rhs(&self) -> bool {\n         if self.token.can_begin_expr() {\n             // parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`."}, {"sha": "d09a23c12f184d24542c4b869d2b41341dff74ac", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58c299f81de4f8deb46b3e6ec045298a669c59aa/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58c299f81de4f8deb46b3e6ec045298a669c59aa/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=58c299f81de4f8deb46b3e6ec045298a669c59aa", "patch": "@@ -1,3 +1,12 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n use parse::token::{Token, BinOpToken, keywords};\n use ast;\n "}]}