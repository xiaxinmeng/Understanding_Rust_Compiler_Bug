{"sha": "c35177582ba22dc7eb3d0d08e972424aed8bd374", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNTE3NzU4MmJhMjJkYzdlYjNkMGQwOGU5NzI0MjRhZWQ4YmQzNzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-23T22:34:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-23T22:34:44Z"}, "message": "Auto merge of #77102 - Dylan-DPC:rollup-2jfrg3u, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #76898 (Record `tcx.def_span` instead of `item.span` in crate metadata)\n - #76939 (emit errors during AbstractConst building)\n - #76965 (Add cfg(target_has_atomic_equal_alignment) and use it for Atomic::from_mut.)\n - #76993 (Changing the alloc() to accept &self instead of &mut self)\n - #76994 (fix small typo in docs and comments)\n - #77017 (Add missing examples on Vec iter types)\n - #77042 (Improve documentation for ToSocketAddrs)\n - #77047 (Miri: more informative deallocation error messages)\n - #77055 (Add #[track_caller] to more panicking Cell functions)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "7c25b8cd1004b2f7ba74d9ad3b3be6fefe5783cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c25b8cd1004b2f7ba74d9ad3b3be6fefe5783cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c35177582ba22dc7eb3d0d08e972424aed8bd374", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c35177582ba22dc7eb3d0d08e972424aed8bd374", "html_url": "https://github.com/rust-lang/rust/commit/c35177582ba22dc7eb3d0d08e972424aed8bd374", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c35177582ba22dc7eb3d0d08e972424aed8bd374/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b4085359ae798dedb05c95ad42520557bd25320", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b4085359ae798dedb05c95ad42520557bd25320", "html_url": "https://github.com/rust-lang/rust/commit/8b4085359ae798dedb05c95ad42520557bd25320"}, {"sha": "c3c03f2f05f3144c2c24ff10fc6d1cca49a5f0be", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3c03f2f05f3144c2c24ff10fc6d1cca49a5f0be", "html_url": "https://github.com/rust-lang/rust/commit/c3c03f2f05f3144c2c24ff10fc6d1cca49a5f0be"}], "stats": {"total": 751, "additions": 552, "deletions": 199}, "files": [{"sha": "8b7fd59cd874ae57c665d559af0de011bad64126", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -26,6 +26,11 @@ const GATED_CFGS: &[GatedCfg] = &[\n     (sym::target_thread_local, sym::cfg_target_thread_local, cfg_fn!(cfg_target_thread_local)),\n     (sym::target_has_atomic, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n     (sym::target_has_atomic_load_store, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n+    (\n+        sym::target_has_atomic_equal_alignment,\n+        sym::cfg_target_has_atomic,\n+        cfg_fn!(cfg_target_has_atomic),\n+    ),\n     (sym::sanitize, sym::cfg_sanitize, cfg_fn!(cfg_sanitize)),\n     (sym::version, sym::cfg_version, cfg_fn!(cfg_version)),\n ];"}, {"sha": "6aa28d04ae197ff5ca3a1a7ed2a9c3816e719865", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -733,7 +733,7 @@ fn get_nullable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'t\n }\n \n /// Check if this enum can be safely exported based on the \"nullable pointer optimization\". If it\n-/// can, return the the type that `ty` can be safely converted to, otherwise return `None`.\n+/// can, return the type that `ty` can be safely converted to, otherwise return `None`.\n /// Currently restricted to function pointers, boxes, references, `core::num::NonZero*`,\n /// `core::ptr::NonNull`, and `#[repr(transparent)]` newtypes.\n /// FIXME: This duplicates code in codegen."}, {"sha": "72d54a26b01d4469350c351559bb5f3f2757aadf", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -11,6 +11,7 @@ use rustc_data_structures::fingerprint::{Fingerprint, FingerprintDecoder};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{AtomicCell, Lock, LockGuard, Lrc, OnceCell};\n+use rustc_errors::ErrorReported;\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, ProcMacroDerive};\n use rustc_hir as hir;\n@@ -1201,13 +1202,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n-    ) -> Option<&'tcx [mir::abstract_const::Node<'tcx>]> {\n+    ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n         self.root\n             .tables\n             .mir_abstract_consts\n             .get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n-            .map_or(None, |v| Some(v.decode((self, tcx))))\n+            .map_or(Ok(None), |v| Ok(Some(v.decode((self, tcx)))))\n     }\n \n     fn get_unused_generic_params(&self, id: DefIndex) -> FiniteBitSet<u32> {"}, {"sha": "556cf419920769015c2c545b93777cd8c5062b4e", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -1117,7 +1117,7 @@ impl EncodeContext<'a, 'tcx> {\n             }\n \n             let abstract_const = self.tcx.mir_abstract_const(def_id);\n-            if let Some(abstract_const) = abstract_const {\n+            if let Ok(Some(abstract_const)) = abstract_const {\n                 record!(self.tables.mir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n             }\n         }\n@@ -1300,7 +1300,7 @@ impl EncodeContext<'a, 'tcx> {\n         });\n         record!(self.tables.visibility[def_id] <-\n             ty::Visibility::from_hir(&item.vis, item.hir_id, tcx));\n-        record!(self.tables.span[def_id] <- item.span);\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- item.attrs);\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {"}, {"sha": "d41e5680602194c30fc939bd7ae1c9daba845ec9", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -23,6 +23,12 @@ pub enum ErrorHandled {\n     TooGeneric,\n }\n \n+impl From<ErrorReported> for ErrorHandled {\n+    fn from(err: ErrorReported) -> ErrorHandled {\n+        ErrorHandled::Reported(err)\n+    }\n+}\n+\n CloneTypeFoldableAndLiftImpls! {\n     ErrorHandled,\n }"}, {"sha": "a8b748833556d8e87df876add7b8bf7d4c8d39e5", "filename": "compiler/rustc_middle/src/mir/predecessors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -33,7 +33,7 @@ impl PredecessorCache {\n         self.cache = OnceCell::new();\n     }\n \n-    /// Returns the the predecessor graph for this MIR.\n+    /// Returns the predecessor graph for this MIR.\n     #[inline]\n     pub(super) fn compute(\n         &self,"}, {"sha": "33854432af5a094237493239e999f2fc290cefd7", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -247,15 +247,15 @@ rustc_queries! {\n         /// Try to build an abstract representation of the given constant.\n         query mir_abstract_const(\n             key: DefId\n-        ) -> Option<&'tcx [mir::abstract_const::Node<'tcx>]> {\n+        ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n             desc {\n                 |tcx| \"building an abstract representation for {}\", tcx.def_path_str(key),\n             }\n         }\n         /// Try to build an abstract representation of the given constant.\n         query mir_abstract_const_of_const_arg(\n             key: (LocalDefId, DefId)\n-        ) -> Option<&'tcx [mir::abstract_const::Node<'tcx>]> {\n+        ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n             desc {\n                 |tcx|\n                 \"building an abstract representation for the const argument {}\","}, {"sha": "baaf6f27ee821377069a336a1e6532723b16d209", "filename": "compiler/rustc_mir/src/borrow_check/member_constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmember_constraints.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> MemberConstraintSet<'tcx, ty::RegionVid> {\n     /// Pushes a member constraint into the set.\n     ///\n     /// The input member constraint `m_c` is in the form produced by\n-    /// the the `rustc_middle::infer` code.\n+    /// the `rustc_middle::infer` code.\n     ///\n     /// The `to_region_vid` callback fn is used to convert the regions\n     /// within into `RegionVid` format -- it typically consults the"}, {"sha": "f3e373813ca537c3e40bcccb63b2410f254bcea1", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -285,9 +285,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             None => {\n                 // Deallocating global memory -- always an error\n                 return Err(match self.tcx.get_global_alloc(ptr.alloc_id) {\n-                    Some(GlobalAlloc::Function(..)) => err_ub_format!(\"deallocating a function\"),\n+                    Some(GlobalAlloc::Function(..)) => {\n+                        err_ub_format!(\"deallocating {}, which is a function\", ptr.alloc_id)\n+                    }\n                     Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n-                        err_ub_format!(\"deallocating static memory\")\n+                        err_ub_format!(\"deallocating {}, which is static memory\", ptr.alloc_id)\n                     }\n                     None => err_ub!(PointerUseAfterFree(ptr.alloc_id)),\n                 }\n@@ -297,15 +299,17 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         if alloc_kind != kind {\n             throw_ub_format!(\n-                \"deallocating {} memory using {} deallocation operation\",\n+                \"deallocating {}, which is {} memory, using {} deallocation operation\",\n+                ptr.alloc_id,\n                 alloc_kind,\n                 kind\n             );\n         }\n         if let Some((size, align)) = old_size_and_align {\n             if size != alloc.size || align != alloc.align {\n                 throw_ub_format!(\n-                    \"incorrect layout on deallocation: allocation has size {} and alignment {}, but gave size {} and alignment {}\",\n+                    \"incorrect layout on deallocation: {} has size {} and alignment {}, but gave size {} and alignment {}\",\n+                    ptr.alloc_id,\n                     alloc.size.bytes(),\n                     alloc.align.bytes(),\n                     size.bytes(),"}, {"sha": "a9b8a6181d499b443221e99e84c435cb53b2fe66", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -321,7 +321,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let target_block = self.cfg.start_new_block();\n             let mut schedule_drops = true;\n             // We keep a stack of all of the bindings and type asciptions\n-            // from the the parent candidates that we visit, that also need to\n+            // from the parent candidates that we visit, that also need to\n             // be bound for each candidate.\n             traverse_candidate(\n                 candidate,"}, {"sha": "d42a786a18fe9cfcebd1ffd59f20d195312b8620", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -67,7 +67,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a type suitable for a function or function pointer parameter.\n     /// The difference from `parse_ty` is that this version allows `...`\n-    /// (`CVarArgs`) at the top level of the the type.\n+    /// (`CVarArgs`) at the top level of the type.\n     pub(super) fn parse_ty_for_param(&mut self) -> PResult<'a, P<Ty>> {\n         self.parse_ty_common(AllowPlus::Yes, RecoverQPath::Yes, AllowCVariadic::Yes)\n     }"}, {"sha": "ab96b0333f43fd3617dd0617e9962c7b8ca62779", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -12,6 +12,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::impl_stable_hash_via_hash;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n+use rustc_target::abi::{Align, TargetDataLayout};\n use rustc_target::spec::{Target, TargetTriple};\n \n use crate::parse::CrateConfig;\n@@ -748,6 +749,9 @@ pub fn default_configuration(sess: &Session) -> CrateConfig {\n     let min_atomic_width = sess.target.target.min_atomic_width();\n     let max_atomic_width = sess.target.target.max_atomic_width();\n     let atomic_cas = sess.target.target.options.atomic_cas;\n+    let layout = TargetDataLayout::parse(&sess.target.target).unwrap_or_else(|err| {\n+        sess.fatal(&err);\n+    });\n \n     let mut ret = FxHashSet::default();\n     ret.reserve(6); // the minimum number of insertions\n@@ -769,18 +773,27 @@ pub fn default_configuration(sess: &Session) -> CrateConfig {\n     if sess.target.target.options.has_elf_tls {\n         ret.insert((sym::target_thread_local, None));\n     }\n-    for &i in &[8, 16, 32, 64, 128] {\n+    for &(i, align) in &[\n+        (8, layout.i8_align.abi),\n+        (16, layout.i16_align.abi),\n+        (32, layout.i32_align.abi),\n+        (64, layout.i64_align.abi),\n+        (128, layout.i128_align.abi),\n+    ] {\n         if i >= min_atomic_width && i <= max_atomic_width {\n-            let mut insert_atomic = |s| {\n+            let mut insert_atomic = |s, align: Align| {\n                 ret.insert((sym::target_has_atomic_load_store, Some(Symbol::intern(s))));\n                 if atomic_cas {\n                     ret.insert((sym::target_has_atomic, Some(Symbol::intern(s))));\n                 }\n+                if align.bits() == i {\n+                    ret.insert((sym::target_has_atomic_equal_alignment, Some(Symbol::intern(s))));\n+                }\n             };\n             let s = i.to_string();\n-            insert_atomic(&s);\n+            insert_atomic(&s, align);\n             if &s == wordsz {\n-                insert_atomic(\"ptr\");\n+                insert_atomic(\"ptr\", layout.pointer_align.abi);\n             }\n         }\n     }"}, {"sha": "2d5c6451d1a52d59a421d46a6530da9dafde364c", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -110,7 +110,7 @@ symbols! {\n     // called `sym::proc_macro` because then it's easy to mistakenly think it\n     // represents \"proc_macro\".\n     //\n-    // As well as the symbols listed, there are symbols for the the strings\n+    // As well as the symbols listed, there are symbols for the strings\n     // \"0\", \"1\", ..., \"9\", which are accessible via `sym::integer`.\n     //\n     // The proc macro will abort if symbols are not in alphabetical order (as\n@@ -1071,6 +1071,7 @@ symbols! {\n         target_feature,\n         target_feature_11,\n         target_has_atomic,\n+        target_has_atomic_equal_alignment,\n         target_has_atomic_load_store,\n         target_os,\n         target_pointer_width,"}, {"sha": "351167105ec7a689350c41656d991d6033069497", "filename": "compiler/rustc_target/src/spec/wasm32_wasi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_wasi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_wasi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_wasi.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -30,7 +30,7 @@\n //! ## No interop with C required\n //!\n //! By default the `crt-static` target feature is enabled, and when enabled\n-//! this means that the the bundled version of `libc.a` found in `liblibc.rlib`\n+//! this means that the bundled version of `libc.a` found in `liblibc.rlib`\n //! is used. This isn't intended really for interoperation with a C because it\n //! may be the case that Rust's bundled C library is incompatible with a\n //! foreign-compiled C library. In this use case, though, we use `rust-lld` and"}, {"sha": "a53075448eddc5980b20dc1ac9331ff94b71b357", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -15,6 +15,7 @@\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n+#![feature(never_type)]\n #![feature(crate_visibility_modifier)]\n #![feature(or_patterns)]\n #![recursion_limit = \"512\"] // For rustdoc"}, {"sha": "0cfcaca9060336f2140a0e24d7f6e7647518047b", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 115, "deletions": 77, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -8,6 +8,7 @@\n //! In this case we try to build an abstract representation of this constant using\n //! `mir_abstract_const` which can then be checked for structural equality with other\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n+use rustc_errors::ErrorReported;\n use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n@@ -31,15 +32,15 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n ) -> Result<(), ErrorHandled> {\n     debug!(\"is_const_evaluatable({:?}, {:?})\", def, substs);\n     if infcx.tcx.features().const_evaluatable_checked {\n-        if let Some(ct) = AbstractConst::new(infcx.tcx, def, substs) {\n+        if let Some(ct) = AbstractConst::new(infcx.tcx, def, substs)? {\n             for pred in param_env.caller_bounds() {\n                 match pred.skip_binders() {\n                     ty::PredicateAtom::ConstEvaluatable(b_def, b_substs) => {\n                         debug!(\"is_const_evaluatable: caller_bound={:?}, {:?}\", b_def, b_substs);\n                         if b_def == def && b_substs == substs {\n                             debug!(\"is_const_evaluatable: caller_bound ~~> ok\");\n                             return Ok(());\n-                        } else if AbstractConst::new(infcx.tcx, b_def, b_substs)\n+                        } else if AbstractConst::new(infcx.tcx, b_def, b_substs)?\n                             .map_or(false, |b_ct| try_unify(infcx.tcx, ct, b_ct))\n                         {\n                             debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n@@ -114,15 +115,15 @@ impl AbstractConst<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         def: ty::WithOptConstParam<DefId>,\n         substs: SubstsRef<'tcx>,\n-    ) -> Option<AbstractConst<'tcx>> {\n+    ) -> Result<Option<AbstractConst<'tcx>>, ErrorReported> {\n         let inner = match (def.did.as_local(), def.const_param_did) {\n             (Some(did), Some(param_did)) => {\n                 tcx.mir_abstract_const_of_const_arg((did, param_did))?\n             }\n             _ => tcx.mir_abstract_const(def.did)?,\n         };\n \n-        Some(AbstractConst { inner, substs })\n+        Ok(inner.map(|inner| AbstractConst { inner, substs }))\n     }\n \n     #[inline]\n@@ -148,53 +149,83 @@ struct AbstractConstBuilder<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, body: &'a mir::Body<'tcx>) -> Option<AbstractConstBuilder<'a, 'tcx>> {\n-        // We only allow consts without control flow, so\n-        // we check for cycles here which simplifies the\n-        // rest of this implementation.\n-        if body.is_cfg_cyclic() {\n-            return None;\n-        }\n+    fn error(&mut self, span: Option<Span>, msg: &str) -> Result<!, ErrorReported> {\n+        self.tcx\n+            .sess\n+            .struct_span_err(self.body.span, \"overly complex generic constant\")\n+            .span_label(span.unwrap_or(self.body.span), msg)\n+            .help(\"consider moving this anonymous constant into a `const` function\")\n+            .emit();\n \n-        // We don't have to look at concrete constants, as we\n-        // can just evaluate them.\n-        if !body.is_polymorphic {\n-            return None;\n-        }\n+        Err(ErrorReported)\n+    }\n \n-        Some(AbstractConstBuilder {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        body: &'a mir::Body<'tcx>,\n+    ) -> Result<Option<AbstractConstBuilder<'a, 'tcx>>, ErrorReported> {\n+        let mut builder = AbstractConstBuilder {\n             tcx,\n             body,\n             nodes: IndexVec::new(),\n             locals: IndexVec::from_elem(NodeId::MAX, &body.local_decls),\n             checked_op_locals: BitSet::new_empty(body.local_decls.len()),\n-        })\n+        };\n+\n+        // We don't have to look at concrete constants, as we\n+        // can just evaluate them.\n+        if !body.is_polymorphic {\n+            return Ok(None);\n+        }\n+\n+        // We only allow consts without control flow, so\n+        // we check for cycles here which simplifies the\n+        // rest of this implementation.\n+        if body.is_cfg_cyclic() {\n+            builder.error(None, \"cyclic anonymous constants are forbidden\")?;\n+        }\n+\n+        Ok(Some(builder))\n     }\n-    fn operand_to_node(&mut self, op: &mir::Operand<'tcx>) -> Option<NodeId> {\n-        debug!(\"operand_to_node: op={:?}\", op);\n+\n+    fn place_to_local(\n+        &mut self,\n+        span: Span,\n+        p: &mir::Place<'tcx>,\n+    ) -> Result<mir::Local, ErrorReported> {\n         const ZERO_FIELD: mir::Field = mir::Field::from_usize(0);\n+        // Do not allow any projections.\n+        //\n+        // One exception are field accesses on the result of checked operations,\n+        // which are required to support things like `1 + 2`.\n+        if let Some(p) = p.as_local() {\n+            debug_assert!(!self.checked_op_locals.contains(p));\n+            Ok(p)\n+        } else if let &[mir::ProjectionElem::Field(ZERO_FIELD, _)] = p.projection.as_ref() {\n+            // Only allow field accesses if the given local\n+            // contains the result of a checked operation.\n+            if self.checked_op_locals.contains(p.local) {\n+                Ok(p.local)\n+            } else {\n+                self.error(Some(span), \"unsupported projection\")?;\n+            }\n+        } else {\n+            self.error(Some(span), \"unsupported projection\")?;\n+        }\n+    }\n+\n+    fn operand_to_node(\n+        &mut self,\n+        span: Span,\n+        op: &mir::Operand<'tcx>,\n+    ) -> Result<NodeId, ErrorReported> {\n+        debug!(\"operand_to_node: op={:?}\", op);\n         match op {\n             mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n-                // Do not allow any projections.\n-                //\n-                // One exception are field accesses on the result of checked operations,\n-                // which are required to support things like `1 + 2`.\n-                if let Some(p) = p.as_local() {\n-                    debug_assert!(!self.checked_op_locals.contains(p));\n-                    Some(self.locals[p])\n-                } else if let &[mir::ProjectionElem::Field(ZERO_FIELD, _)] = p.projection.as_ref() {\n-                    // Only allow field accesses if the given local\n-                    // contains the result of a checked operation.\n-                    if self.checked_op_locals.contains(p.local) {\n-                        Some(self.locals[p.local])\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n-                }\n+                let local = self.place_to_local(span, p)?;\n+                Ok(self.locals[local])\n             }\n-            mir::Operand::Constant(ct) => Some(self.nodes.push(Node::Leaf(ct.literal))),\n+            mir::Operand::Constant(ct) => Ok(self.nodes.push(Node::Leaf(ct.literal))),\n         }\n     }\n \n@@ -217,44 +248,45 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Option<()> {\n+    fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Result<(), ErrorReported> {\n         debug!(\"AbstractConstBuilder: stmt={:?}\", stmt);\n         match stmt.kind {\n             StatementKind::Assign(box (ref place, ref rvalue)) => {\n-                let local = place.as_local()?;\n+                let local = self.place_to_local(stmt.source_info.span, place)?;\n                 match *rvalue {\n                     Rvalue::Use(ref operand) => {\n-                        self.locals[local] = self.operand_to_node(operand)?;\n-                        Some(())\n+                        self.locals[local] =\n+                            self.operand_to_node(stmt.source_info.span, operand)?;\n+                        Ok(())\n                     }\n                     Rvalue::BinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(lhs)?;\n-                        let rhs = self.operand_to_node(rhs)?;\n+                        let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n+                        let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n                         self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n                         if op.is_checkable() {\n                             bug!(\"unexpected unchecked checkable binary operation\");\n                         } else {\n-                            Some(())\n+                            Ok(())\n                         }\n                     }\n                     Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(lhs)?;\n-                        let rhs = self.operand_to_node(rhs)?;\n+                        let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n+                        let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n                         self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n                         self.checked_op_locals.insert(local);\n-                        Some(())\n+                        Ok(())\n                     }\n                     Rvalue::UnaryOp(op, ref operand) if Self::check_unop(op) => {\n-                        let operand = self.operand_to_node(operand)?;\n+                        let operand = self.operand_to_node(stmt.source_info.span, operand)?;\n                         self.locals[local] = self.nodes.push(Node::UnaryOp(op, operand));\n-                        Some(())\n+                        Ok(())\n                     }\n-                    _ => None,\n+                    _ => self.error(Some(stmt.source_info.span), \"unsupported rvalue\")?,\n                 }\n             }\n             // These are not actually relevant for us here, so we can ignore them.\n-            StatementKind::StorageLive(_) | StatementKind::StorageDead(_) => Some(()),\n-            _ => None,\n+            StatementKind::StorageLive(_) | StatementKind::StorageDead(_) => Ok(()),\n+            _ => self.error(Some(stmt.source_info.span), \"unsupported statement\")?,\n         }\n     }\n \n@@ -266,11 +298,11 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n     fn build_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n-    ) -> Option<Option<mir::BasicBlock>> {\n+    ) -> Result<Option<mir::BasicBlock>, ErrorReported> {\n         debug!(\"AbstractConstBuilder: terminator={:?}\", terminator);\n         match terminator.kind {\n-            TerminatorKind::Goto { target } => Some(Some(target)),\n-            TerminatorKind::Return => Some(None),\n+            TerminatorKind::Goto { target } => Ok(Some(target)),\n+            TerminatorKind::Return => Ok(None),\n             TerminatorKind::Call {\n                 ref func,\n                 ref args,\n@@ -288,17 +320,17 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 //\n                 // This is currently fairly irrelevant as it requires `const Trait`s.\n                 from_hir_call: true,\n-                fn_span: _,\n+                fn_span,\n             } => {\n-                let local = place.as_local()?;\n-                let func = self.operand_to_node(func)?;\n+                let local = self.place_to_local(fn_span, place)?;\n+                let func = self.operand_to_node(fn_span, func)?;\n                 let args = self.tcx.arena.alloc_from_iter(\n                     args.iter()\n-                        .map(|arg| self.operand_to_node(arg))\n-                        .collect::<Option<Vec<NodeId>>>()?,\n+                        .map(|arg| self.operand_to_node(terminator.source_info.span, arg))\n+                        .collect::<Result<Vec<NodeId>, _>>()?,\n                 );\n                 self.locals[local] = self.nodes.push(Node::FunctionCall(func, args));\n-                Some(Some(target))\n+                Ok(Some(target))\n             }\n             // We only allow asserts for checked operations.\n             //\n@@ -315,19 +347,19 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n                     // Only allow asserts checking the result of a checked operation.\n                     if self.checked_op_locals.contains(p.local) {\n-                        return Some(Some(target));\n+                        return Ok(Some(target));\n                     }\n                 }\n \n-                None\n+                self.error(Some(terminator.source_info.span), \"unsupported assertion\")?;\n             }\n-            _ => None,\n+            _ => self.error(Some(terminator.source_info.span), \"unsupported terminator\")?,\n         }\n     }\n \n     /// Builds the abstract const by walking the mir from start to finish\n     /// and bailing out when encountering an unsupported operation.\n-    fn build(mut self) -> Option<&'tcx [Node<'tcx>]> {\n+    fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorReported> {\n         let mut block = &self.body.basic_blocks()[mir::START_BLOCK];\n         // We checked for a cyclic cfg above, so this should terminate.\n         loop {\n@@ -339,7 +371,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             if let Some(next) = self.build_terminator(block.terminator())? {\n                 block = &self.body.basic_blocks()[next];\n             } else {\n-                return Some(self.tcx.arena.alloc_from_iter(self.nodes));\n+                return Ok(self.tcx.arena.alloc_from_iter(self.nodes));\n             }\n         }\n     }\n@@ -349,7 +381,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n pub(super) fn mir_abstract_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> Option<&'tcx [Node<'tcx>]> {\n+) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n     if tcx.features().const_evaluatable_checked {\n         match tcx.def_kind(def.did) {\n             // FIXME(const_evaluatable_checked): We currently only do this for anonymous constants,\n@@ -358,12 +390,12 @@ pub(super) fn mir_abstract_const<'tcx>(\n             //\n             // Right now we do neither of that and simply always fail to unify them.\n             DefKind::AnonConst => (),\n-            _ => return None,\n+            _ => return Ok(None),\n         }\n         let body = tcx.mir_const(def).borrow();\n-        AbstractConstBuilder::new(tcx, &body)?.build()\n+        AbstractConstBuilder::new(tcx, &body)?.map(AbstractConstBuilder::build).transpose()\n     } else {\n-        None\n+        Ok(None)\n     }\n }\n \n@@ -374,13 +406,19 @@ pub(super) fn try_unify_abstract_consts<'tcx>(\n         (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n     ),\n ) -> bool {\n-    if let Some(a) = AbstractConst::new(tcx, a, a_substs) {\n-        if let Some(b) = AbstractConst::new(tcx, b, b_substs) {\n-            return try_unify(tcx, a, b);\n+    (|| {\n+        if let Some(a) = AbstractConst::new(tcx, a, a_substs)? {\n+            if let Some(b) = AbstractConst::new(tcx, b, b_substs)? {\n+                return Ok(try_unify(tcx, a, b));\n+            }\n         }\n-    }\n \n-    false\n+        Ok(false)\n+    })()\n+    .unwrap_or_else(|ErrorReported| true)\n+    // FIXME(const_evaluatable_checked): We should instead have this\n+    // method return the resulting `ty::Const` and return `ConstKind::Error`\n+    // on `ErrorReported`.\n }\n \n /// Tries to unify two abstract constants using structural equality."}, {"sha": "97172d391ba659a71f4f84e3c2b6a311bd8c3468", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -672,7 +672,7 @@ fn binding_opaque_type_cycle_error(\n ) {\n     let mut err = struct_span_err!(tcx.sess, span, E0720, \"cannot resolve opaque type\");\n     err.span_label(span, \"cannot resolve opaque type\");\n-    // Find the the owner that declared this `impl Trait` type.\n+    // Find the owner that declared this `impl Trait` type.\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let mut prev_hir_id = hir_id;\n     let mut hir_id = tcx.hir().get_parent_node(hir_id);"}, {"sha": "8b8cdbf252555089b8e1f0db64b367afa1d2240f", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -145,7 +145,7 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n \n impl Global {\n     #[inline]\n-    fn alloc_impl(&mut self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocErr> {\n         match layout.size() {\n             0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),\n             // SAFETY: `layout` is non-zero in size,\n@@ -160,7 +160,7 @@ impl Global {\n     // SAFETY: Same as `AllocRef::grow`\n     #[inline]\n     unsafe fn grow_impl(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -208,17 +208,17 @@ impl Global {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         self.alloc_impl(layout, false)\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         self.alloc_impl(layout, true)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n             // SAFETY: `layout` is non-zero in size,\n             // other conditions must be upheld by the caller\n@@ -228,7 +228,7 @@ unsafe impl AllocRef for Global {\n \n     #[inline]\n     unsafe fn grow(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -239,7 +239,7 @@ unsafe impl AllocRef for Global {\n \n     #[inline]\n     unsafe fn grow_zeroed(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -250,7 +250,7 @@ unsafe impl AllocRef for Global {\n \n     #[inline]\n     unsafe fn shrink(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,"}, {"sha": "1844d3ae004f4dbbbbad92543d19367a8da1ad39", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -170,7 +170,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         Self::allocate_in(capacity, AllocInit::Zeroed, alloc)\n     }\n \n-    fn allocate_in(capacity: usize, init: AllocInit, mut alloc: A) -> Self {\n+    fn allocate_in(capacity: usize, init: AllocInit, alloc: A) -> Self {\n         if mem::size_of::<T>() == 0 {\n             Self::new_in(alloc)\n         } else {"}, {"sha": "e4c8b3709dfeeb9809d998747a40625579ba1038", "filename": "library/alloc/src/raw_vec/tests.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use std::cell::Cell;\n \n #[test]\n fn allocator_param() {\n@@ -17,32 +18,32 @@ fn allocator_param() {\n     // A dumb allocator that consumes a fixed amount of fuel\n     // before allocation attempts start failing.\n     struct BoundedAlloc {\n-        fuel: usize,\n+        fuel: Cell<usize>,\n     }\n     unsafe impl AllocRef for BoundedAlloc {\n-        fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+        fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n             let size = layout.size();\n-            if size > self.fuel {\n+            if size > self.fuel.get() {\n                 return Err(AllocErr);\n             }\n             match Global.alloc(layout) {\n                 ok @ Ok(_) => {\n-                    self.fuel -= size;\n+                    self.fuel.set(self.fuel.get() - size);\n                     ok\n                 }\n                 err @ Err(_) => err,\n             }\n         }\n-        unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {\n             unsafe { Global.dealloc(ptr, layout) }\n         }\n     }\n \n-    let a = BoundedAlloc { fuel: 500 };\n+    let a = BoundedAlloc { fuel: Cell::new(500) };\n     let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n-    assert_eq!(v.alloc.fuel, 450);\n+    assert_eq!(v.alloc.fuel.get(), 450);\n     v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n-    assert_eq!(v.alloc.fuel, 250);\n+    assert_eq!(v.alloc.fuel.get(), 250);\n }\n \n #[test]"}, {"sha": "8a9463cb518280934ffc2ab75ebac7b31bf66ff8", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -2849,6 +2849,13 @@ where\n ///\n /// This `struct` is created by the `into_iter` method on [`Vec`] (provided\n /// by the [`IntoIterator`] trait).\n+///\n+/// # Example\n+///\n+/// ```\n+/// let v = vec![0, 1, 2];\n+/// let iter: std::vec::IntoIter<_> = v.into_iter();\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     buf: NonNull<T>,\n@@ -3092,6 +3099,13 @@ impl<T> AsIntoIter for IntoIter<T> {\n ///\n /// This `struct` is created by [`Vec::drain`].\n /// See its documentation for more.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let mut v = vec![0, 1, 2];\n+/// let iter: std::vec::Drain<_> = v.drain(..);\n+/// ```\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a, T: 'a> {\n     /// Index of tail to preserve\n@@ -3221,6 +3235,14 @@ impl<T> FusedIterator for Drain<'_, T> {}\n ///\n /// This struct is created by [`Vec::splice()`].\n /// See its documentation for more.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let mut v = vec![0, 1, 2];\n+/// let new = [7, 8];\n+/// let iter: std::vec::Splice<_> = v.splice(1.., new.iter().cloned());\n+/// ```\n #[derive(Debug)]\n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n pub struct Splice<'a, I: Iterator + 'a> {\n@@ -3337,6 +3359,15 @@ impl<T> Drain<'_, T> {\n ///\n /// This struct is created by [`Vec::drain_filter`].\n /// See its documentation for more.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(drain_filter)]\n+///\n+/// let mut v = vec![0, 1, 2];\n+/// let iter: std::vec::DrainFilter<_, _> = v.drain_filter(|x| *x % 2 == 0);\n+/// ```\n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n #[derive(Debug)]\n pub struct DrainFilter<'a, T, F>"}, {"sha": "a7239a4b14fae82bf92be0ae533f98ccc148bd79", "filename": "library/alloc/tests/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Falloc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Falloc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fheap.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -11,7 +11,7 @@ fn std_heap_overaligned_request() {\n     check_overalign_requests(Global)\n }\n \n-fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n+fn check_overalign_requests<T: AllocRef>(allocator: T) {\n     for &align in &[4, 8, 16, 32] {\n         // less than and bigger than `MIN_ALIGN`\n         for &size in &[align / 2, align - 1] {"}, {"sha": "f9eb8981bbfc24d1a8dafeb52803d4b391edec3c", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -109,7 +109,7 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr>;\n+    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr>;\n \n     /// Behaves like `alloc`, but also ensures that the returned memory is zero-initialized.\n     ///\n@@ -126,7 +126,7 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         let ptr = self.alloc(layout)?;\n         // SAFETY: `alloc` returns a valid memory block\n         unsafe { ptr.as_non_null_ptr().as_ptr().write_bytes(0, ptr.len()) }\n@@ -142,7 +142,7 @@ pub unsafe trait AllocRef {\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n+    unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout);\n \n     /// Attempts to extend the memory block.\n     ///\n@@ -183,7 +183,7 @@ pub unsafe trait AllocRef {\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn grow(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -244,7 +244,7 @@ pub unsafe trait AllocRef {\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn grow_zeroed(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -308,7 +308,7 @@ pub unsafe trait AllocRef {\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn shrink(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -337,35 +337,35 @@ pub unsafe trait AllocRef {\n     ///\n     /// The returned adaptor also implements `AllocRef` and will simply borrow this.\n     #[inline(always)]\n-    fn by_ref(&mut self) -> &mut Self {\n+    fn by_ref(&mut self) -> &Self {\n         self\n     }\n }\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-unsafe impl<A> AllocRef for &mut A\n+unsafe impl<A> AllocRef for &A\n where\n     A: AllocRef + ?Sized,\n {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         (**self).alloc(layout)\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         (**self).alloc_zeroed(layout)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {\n         // SAFETY: the safety contract must be upheld by the caller\n         unsafe { (**self).dealloc(ptr, layout) }\n     }\n \n     #[inline]\n     unsafe fn grow(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -376,7 +376,7 @@ where\n \n     #[inline]\n     unsafe fn grow_zeroed(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -387,7 +387,7 @@ where\n \n     #[inline]\n     unsafe fn shrink(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,"}, {"sha": "15ec13ca65a18db729a174cc04bfaf770de69f4f", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -697,6 +697,7 @@ impl<T> RefCell<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"refcell_replace\", since = \"1.24.0\")]\n+    #[track_caller]\n     pub fn replace(&self, t: T) -> T {\n         mem::replace(&mut *self.borrow_mut(), t)\n     }\n@@ -719,6 +720,7 @@ impl<T> RefCell<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"refcell_replace_swap\", since = \"1.35.0\")]\n+    #[track_caller]\n     pub fn replace_with<F: FnOnce(&mut T) -> T>(&self, f: F) -> T {\n         let mut_borrow = &mut *self.borrow_mut();\n         let replacement = f(mut_borrow);\n@@ -1052,6 +1054,7 @@ impl<T: Clone> Clone for RefCell<T> {\n     ///\n     /// Panics if the value is currently mutably borrowed.\n     #[inline]\n+    #[track_caller]\n     fn clone(&self) -> RefCell<T> {\n         RefCell::new(self.borrow().clone())\n     }"}, {"sha": "5c9cfe27101f07edbcfbbe669bf4074ec0385584", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -327,6 +327,28 @@ impl AtomicBool {\n         unsafe { &mut *(self.v.get() as *mut bool) }\n     }\n \n+    /// Get atomic access to a `&mut bool`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(atomic_from_mut)]\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let mut some_bool = true;\n+    /// let a = AtomicBool::from_mut(&mut some_bool);\n+    /// a.store(false, Ordering::Relaxed);\n+    /// assert_eq!(some_bool, false);\n+    /// ```\n+    #[inline]\n+    #[cfg(target_has_atomic_equal_alignment = \"8\")]\n+    #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n+    pub fn from_mut(v: &mut bool) -> &Self {\n+        // SAFETY: the mutable reference guarantees unique ownership, and\n+        // alignment of both `bool` and `Self` is 1.\n+        unsafe { &*(v as *mut bool as *mut Self) }\n+    }\n+\n     /// Consumes the atomic and returns the contained value.\n     ///\n     /// This is safe because passing `self` by value guarantees that no other threads are\n@@ -819,6 +841,32 @@ impl<T> AtomicPtr<T> {\n         self.p.get_mut()\n     }\n \n+    /// Get atomic access to a pointer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(atomic_from_mut)]\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let mut some_ptr = &mut 123 as *mut i32;\n+    /// let a = AtomicPtr::from_mut(&mut some_ptr);\n+    /// a.store(&mut 456, Ordering::Relaxed);\n+    /// assert_eq!(unsafe { *some_ptr }, 456);\n+    /// ```\n+    #[inline]\n+    #[cfg(target_has_atomic_equal_alignment = \"ptr\")]\n+    #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n+    pub fn from_mut(v: &mut *mut T) -> &Self {\n+        use crate::mem::align_of;\n+        let [] = [(); align_of::<AtomicPtr<()>>() - align_of::<*mut ()>()];\n+        // SAFETY:\n+        //  - the mutable reference guarantees unique ownership.\n+        //  - the alignment of `*mut T` and `Self` is the same on all platforms\n+        //    supported by rust, as verified above.\n+        unsafe { &*(v as *mut *mut T as *mut Self) }\n+    }\n+\n     /// Consumes the atomic and returns the contained value.\n     ///\n     /// This is safe because passing `self` by value guarantees that no other threads are\n@@ -1113,6 +1161,7 @@ macro_rules! if_not_8_bit {\n #[cfg(target_has_atomic_load_store = \"8\")]\n macro_rules! atomic_int {\n     ($cfg_cas:meta,\n+     $cfg_align:meta,\n      $stable:meta,\n      $stable_cxchg:meta,\n      $stable_debug:meta,\n@@ -1231,6 +1280,45 @@ assert_eq!(some_var.load(Ordering::SeqCst), 5);\n                 }\n             }\n \n+            doc_comment! {\n+                concat!(\"Get atomic access to a `&mut \", stringify!($int_type), \"`.\n+\n+\",\n+if_not_8_bit! {\n+    $int_type,\n+    concat!(\n+        \"**Note:** This function is only available on targets where `\",\n+        stringify!($int_type), \"` has an alignment of \", $align, \" bytes.\"\n+    )\n+},\n+\"\n+\n+# Examples\n+\n+```\n+#![feature(atomic_from_mut)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let mut some_int = 123;\n+let a = \", stringify!($atomic_type), \"::from_mut(&mut some_int);\n+a.store(100, Ordering::Relaxed);\n+assert_eq!(some_int, 100);\n+```\n+                \"),\n+                #[inline]\n+                #[$cfg_align]\n+                #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n+                pub fn from_mut(v: &mut $int_type) -> &Self {\n+                    use crate::mem::align_of;\n+                    let [] = [(); align_of::<Self>() - align_of::<$int_type>()];\n+                    // SAFETY:\n+                    //  - the mutable reference guarantees unique ownership.\n+                    //  - the alignment of `$int_type` and `Self` is the\n+                    //    same, as promised by $cfg_align and verified above.\n+                    unsafe { &*(v as *mut $int_type as *mut Self) }\n+                }\n+            }\n+\n             doc_comment! {\n                 concat!(\"Consumes the atomic and returns the contained value.\n \n@@ -1873,6 +1961,7 @@ let mut atomic = \", stringify!($atomic_type), \"::new(1);\n #[cfg(target_has_atomic_load_store = \"8\")]\n atomic_int! {\n     cfg(target_has_atomic = \"8\"),\n+    cfg(target_has_atomic_equal_alignment = \"8\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1891,6 +1980,7 @@ atomic_int! {\n #[cfg(target_has_atomic_load_store = \"8\")]\n atomic_int! {\n     cfg(target_has_atomic = \"8\"),\n+    cfg(target_has_atomic_equal_alignment = \"8\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1909,6 +1999,7 @@ atomic_int! {\n #[cfg(target_has_atomic_load_store = \"16\")]\n atomic_int! {\n     cfg(target_has_atomic = \"16\"),\n+    cfg(target_has_atomic_equal_alignment = \"16\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1927,6 +2018,7 @@ atomic_int! {\n #[cfg(target_has_atomic_load_store = \"16\")]\n atomic_int! {\n     cfg(target_has_atomic = \"16\"),\n+    cfg(target_has_atomic_equal_alignment = \"16\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1945,6 +2037,7 @@ atomic_int! {\n #[cfg(target_has_atomic_load_store = \"32\")]\n atomic_int! {\n     cfg(target_has_atomic = \"32\"),\n+    cfg(target_has_atomic_equal_alignment = \"32\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1963,6 +2056,7 @@ atomic_int! {\n #[cfg(target_has_atomic_load_store = \"32\")]\n atomic_int! {\n     cfg(target_has_atomic = \"32\"),\n+    cfg(target_has_atomic_equal_alignment = \"32\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1981,6 +2075,7 @@ atomic_int! {\n #[cfg(target_has_atomic_load_store = \"64\")]\n atomic_int! {\n     cfg(target_has_atomic = \"64\"),\n+    cfg(target_has_atomic_equal_alignment = \"64\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1999,6 +2094,7 @@ atomic_int! {\n #[cfg(target_has_atomic_load_store = \"64\")]\n atomic_int! {\n     cfg(target_has_atomic = \"64\"),\n+    cfg(target_has_atomic_equal_alignment = \"64\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -2017,6 +2113,7 @@ atomic_int! {\n #[cfg(target_has_atomic_load_store = \"128\")]\n atomic_int! {\n     cfg(target_has_atomic = \"128\"),\n+    cfg(target_has_atomic_equal_alignment = \"128\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -2035,6 +2132,7 @@ atomic_int! {\n #[cfg(target_has_atomic_load_store = \"128\")]\n atomic_int! {\n     cfg(target_has_atomic = \"128\"),\n+    cfg(target_has_atomic_equal_alignment = \"128\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -2074,6 +2172,7 @@ macro_rules! ptr_width {\n #[cfg(target_has_atomic_load_store = \"ptr\")]\n atomic_int! {\n     cfg(target_has_atomic = \"ptr\"),\n+    cfg(target_has_atomic_equal_alignment = \"ptr\"),\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n@@ -2092,6 +2191,7 @@ atomic_int! {\n #[cfg(target_has_atomic_load_store = \"ptr\")]\n atomic_int! {\n     cfg(target_has_atomic = \"ptr\"),\n+    cfg(target_has_atomic_equal_alignment = \"ptr\"),\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),"}, {"sha": "ba158511f64c085eae97538d255f77bebc398c95", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -133,7 +133,7 @@ pub struct System;\n \n impl System {\n     #[inline]\n-    fn alloc_impl(&mut self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocErr> {\n         match layout.size() {\n             0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),\n             // SAFETY: `layout` is non-zero in size,\n@@ -152,7 +152,7 @@ impl System {\n     // SAFETY: Same as `AllocRef::grow`\n     #[inline]\n     unsafe fn grow_impl(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -190,7 +190,7 @@ impl System {\n             old_size => unsafe {\n                 let new_ptr = self.alloc_impl(new_layout, zeroed)?;\n                 ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), old_size);\n-                self.dealloc(ptr, old_layout);\n+                AllocRef::dealloc(&self, ptr, old_layout);\n                 Ok(new_ptr)\n             },\n         }\n@@ -202,17 +202,17 @@ impl System {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for System {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         self.alloc_impl(layout, false)\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         self.alloc_impl(layout, true)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n             // SAFETY: `layout` is non-zero in size,\n             // other conditions must be upheld by the caller\n@@ -222,7 +222,7 @@ unsafe impl AllocRef for System {\n \n     #[inline]\n     unsafe fn grow(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -233,7 +233,7 @@ unsafe impl AllocRef for System {\n \n     #[inline]\n     unsafe fn grow_zeroed(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -244,7 +244,7 @@ unsafe impl AllocRef for System {\n \n     #[inline]\n     unsafe fn shrink(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -257,7 +257,7 @@ unsafe impl AllocRef for System {\n         match new_layout.size() {\n             // SAFETY: conditions must be upheld by the caller\n             0 => unsafe {\n-                self.dealloc(ptr, old_layout);\n+                AllocRef::dealloc(&self, ptr, old_layout);\n                 Ok(NonNull::slice_from_raw_parts(new_layout.dangling(), 0))\n             },\n \n@@ -277,9 +277,9 @@ unsafe impl AllocRef for System {\n             // `new_ptr`. Thus, the call to `copy_nonoverlapping` is safe. The safety contract\n             // for `dealloc` must be upheld by the caller.\n             new_size => unsafe {\n-                let new_ptr = self.alloc(new_layout)?;\n+                let new_ptr = AllocRef::alloc(&self, new_layout)?;\n                 ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), new_size);\n-                self.dealloc(ptr, old_layout);\n+                AllocRef::dealloc(&self, ptr, old_layout);\n                 Ok(new_ptr)\n             },\n         }"}, {"sha": "e213963d25046b836e446200333cdbeef05345fd", "filename": "library/std/src/net/addr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -745,9 +745,9 @@ impl hash::Hash for SocketAddrV6 {\n ///    `(`[`Ipv4Addr`]`, `[`u16`]`)`, `(`[`Ipv6Addr`]`, `[`u16`]`)`:\n ///    [`to_socket_addrs`] constructs a [`SocketAddr`] trivially.\n ///\n-///  * `(`[`&str`]`, `[`u16`]`)`: the string should be either a string representation\n+///  * `(`[`&str`]`, `[`u16`]`)`: [`&str`] should be either a string representation\n ///    of an [`IpAddr`] address as expected by [`FromStr`] implementation or a host\n-///    name.\n+///    name. [`u16`] is the port number.\n ///\n ///  * [`&str`]: the string should be either a string representation of a\n ///    [`SocketAddr`] as expected by its [`FromStr`] implementation or a string like"}, {"sha": "dfb5d3e9e38d0fb40cd49abd79cf1d32df56d6ce", "filename": "src/test/ui/allocator/custom.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -10,6 +10,7 @@ extern crate helper;\n \n use std::alloc::{self, AllocRef, Global, Layout, System};\n use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::ptr::NonNull;\n \n static HITS: AtomicUsize = AtomicUsize::new(0);\n \n@@ -18,12 +19,12 @@ struct A;\n unsafe impl alloc::GlobalAlloc for A {\n     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n         HITS.fetch_add(1, Ordering::SeqCst);\n-        System.alloc(layout)\n+        alloc::GlobalAlloc::alloc(&System, layout)\n     }\n \n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n         HITS.fetch_add(1, Ordering::SeqCst);\n-        System.dealloc(ptr, layout)\n+        AllocRef::dealloc(&System, NonNull::new(ptr).unwrap(), layout)\n     }\n }\n "}, {"sha": "bf946160075704d38ca7a525602daef209bcca0a", "filename": "src/test/ui/atomic-from-mut-not-available.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fatomic-from-mut-not-available.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fatomic-from-mut-not-available.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fatomic-from-mut-not-available.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -0,0 +1,7 @@\n+// only-x86\n+// only-linux\n+\n+fn main() {\n+    core::sync::atomic::AtomicU64::from_mut(&mut 0u64);\n+    //~^ ERROR: no function or associated item named `from_mut` found for struct `AtomicU64`\n+}"}, {"sha": "d1ebca8a29e93121466649b7f50261de1e2d7563", "filename": "src/test/ui/atomic-from-mut-not-available.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fatomic-from-mut-not-available.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fatomic-from-mut-not-available.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fatomic-from-mut-not-available.stderr?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -0,0 +1,9 @@\n+error[E0599]: no function or associated item named `from_mut` found for struct `AtomicU64` in the current scope\n+  --> $DIR/atomic-from-mut-not-available.rs:5:36\n+   |\n+LL |     core::sync::atomic::AtomicU64::from_mut(&mut 0u64);\n+   |                                    ^^^^^^^^ function or associated item not found in `AtomicU64`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "32f43591e37b9d33f777aec73be281a5b187fa06", "filename": "src/test/ui/const-generics/const_evaluatable_checked/closures.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fclosures.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -0,0 +1,6 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n+//~^ ERROR overly complex generic constant\n+\n+fn main() {}"}, {"sha": "9f0b7252e8326ff2893c633d2ea735670ed8de3c", "filename": "src/test/ui/const-generics/const_evaluatable_checked/closures.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fclosures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fclosures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fclosures.stderr?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -0,0 +1,12 @@\n+error: overly complex generic constant\n+  --> $DIR/closures.rs:3:35\n+   |\n+LL | fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n+   |                                   ^^^^-------^^\n+   |                                       |\n+   |                                       unsupported rvalue\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+\n+error: aborting due to previous error\n+"}, {"sha": "a6bb39208a42d9d2b16a0c0ec4013d652ac18f20", "filename": "src/test/ui/const-generics/const_evaluatable_checked/let-bindings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -4,8 +4,8 @@\n // We do not yet want to support let-bindings in abstract consts,\n // so this test should keep failing for now.\n fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-    //~^ ERROR constant expression depends\n-    //~| ERROR constant expression depends\n+    //~^ ERROR overly complex generic constant\n+    //~| ERROR overly complex generic constant\n     Default::default()\n }\n "}, {"sha": "5749defb3e12c679227424fb7eef06d8bf66ad61", "filename": "src/test/ui/const-generics/const_evaluatable_checked/let-bindings.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.stderr?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -1,18 +1,22 @@\n-error: constant expression depends on a generic parameter\n-  --> $DIR/let-bindings.rs:6:91\n+error: overly complex generic constant\n+  --> $DIR/let-bindings.rs:6:68\n    |\n LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-   |                                                                                           ^^^^^^^ required by this bound in `test::{{constant}}#0`\n+   |                                                                    ^^^^^^-^^^^^^^^^^^^^\n+   |                                                                          |\n+   |                                                                          unsupported statement\n    |\n-   = note: this may fail depending on what value the parameter takes\n+   = help: consider moving this anonymous constant into a `const` function\n \n-error: constant expression depends on a generic parameter\n-  --> $DIR/let-bindings.rs:6:30\n+error: overly complex generic constant\n+  --> $DIR/let-bindings.rs:6:35\n    |\n LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^^^^^^-^^^^^^^^^^^^^\n+   |                                         |\n+   |                                         unsupported statement\n    |\n-   = note: this may fail depending on what value the parameter takes\n+   = help: consider moving this anonymous constant into a `const` function\n \n error: aborting due to 2 previous errors\n "}, {"sha": "eb1b42c57bc51f905566b45ec2e76c69e082e6c2", "filename": "src/test/ui/consts/miri_unleashed/drop.stderr", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -1,22 +1,16 @@\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-LL | / pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n-LL | |     // Code here does not matter - this is replaced by the\n-LL | |     // real drop glue by the compiler.\n-LL | |\n-LL | |     // SAFETY: see comment above\n-LL | |     unsafe { drop_in_place(to_drop) }\n-LL | | }\n-   | | ^\n-   | | |\n-   | |_calling non-const function `<Vec<i32> as Drop>::drop`\n-   |   inside `drop_in_place::<Vec<i32>> - shim(Some(Vec<i32>))` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+LL | pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | calling non-const function `<Vec<i32> as Drop>::drop`\n+   | inside `drop_in_place::<Vec<i32>> - shim(Some(Vec<i32>))` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    | \n   ::: $DIR/drop.rs:18:1\n    |\n-LL |   };\n-   |   - inside `TEST_BAD` at $DIR/drop.rs:18:1\n+LL | };\n+   | - inside `TEST_BAD` at $DIR/drop.rs:18:1\n \n warning: skipping const checks\n    |"}, {"sha": "049fdd84d8c22e71a8dae4a329b97cfbe60f74fe", "filename": "src/test/ui/feature-gates/feature-gate-cfg-target-has-atomic.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-has-atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-has-atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-has-atomic.rs?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -87,6 +87,30 @@ fn main() {\n     //~^ ERROR `cfg(target_has_atomic)` is experimental and subject to change\n     cfg!(target_has_atomic = \"ptr\");\n     //~^ ERROR `cfg(target_has_atomic)` is experimental and subject to change\n+    cfg!(target_has_atomic_load_store = \"8\");\n+    //~^ ERROR `cfg(target_has_atomic_load_store)` is experimental and subject to change\n+    cfg!(target_has_atomic_load_store = \"16\");\n+    //~^ ERROR `cfg(target_has_atomic_load_store)` is experimental and subject to change\n+    cfg!(target_has_atomic_load_store = \"32\");\n+    //~^ ERROR `cfg(target_has_atomic_load_store)` is experimental and subject to change\n+    cfg!(target_has_atomic_load_store = \"64\");\n+    //~^ ERROR `cfg(target_has_atomic_load_store)` is experimental and subject to change\n+    cfg!(target_has_atomic_load_store = \"128\");\n+    //~^ ERROR `cfg(target_has_atomic_load_store)` is experimental and subject to change\n+    cfg!(target_has_atomic_load_store = \"ptr\");\n+    //~^ ERROR `cfg(target_has_atomic_load_store)` is experimental and subject to change\n+    cfg!(target_has_atomic_equal_alignment = \"8\");\n+    //~^ ERROR `cfg(target_has_atomic_equal_alignment)` is experimental and subject to change\n+    cfg!(target_has_atomic_equal_alignment = \"16\");\n+    //~^ ERROR `cfg(target_has_atomic_equal_alignment)` is experimental and subject to change\n+    cfg!(target_has_atomic_equal_alignment = \"32\");\n+    //~^ ERROR `cfg(target_has_atomic_equal_alignment)` is experimental and subject to change\n+    cfg!(target_has_atomic_equal_alignment = \"64\");\n+    //~^ ERROR `cfg(target_has_atomic_equal_alignment)` is experimental and subject to change\n+    cfg!(target_has_atomic_equal_alignment = \"128\");\n+    //~^ ERROR `cfg(target_has_atomic_equal_alignment)` is experimental and subject to change\n+    cfg!(target_has_atomic_equal_alignment = \"ptr\");\n+    //~^ ERROR `cfg(target_has_atomic_equal_alignment)` is experimental and subject to change\n }\n \n #[macro_export]"}, {"sha": "16e1dc644008433ca55be33c2449b5fed9309028", "filename": "src/test/ui/feature-gates/feature-gate-cfg-target-has-atomic.stderr", "status": "modified", "additions": 109, "deletions": 1, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-has-atomic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-has-atomic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-has-atomic.stderr?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -160,6 +160,114 @@ LL |     cfg!(target_has_atomic = \"ptr\");\n    = note: see issue #32976 <https://github.com/rust-lang/rust/issues/32976> for more information\n    = help: add `#![feature(cfg_target_has_atomic)]` to the crate attributes to enable\n \n-error: aborting due to 18 previous errors\n+error[E0658]: `cfg(target_has_atomic_load_store)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:90:10\n+   |\n+LL |     cfg!(target_has_atomic_load_store = \"8\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #32976 <https://github.com/rust-lang/rust/issues/32976> for more information\n+   = help: add `#![feature(cfg_target_has_atomic)]` to the crate attributes to enable\n+\n+error[E0658]: `cfg(target_has_atomic_load_store)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:92:10\n+   |\n+LL |     cfg!(target_has_atomic_load_store = \"16\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #32976 <https://github.com/rust-lang/rust/issues/32976> for more information\n+   = help: add `#![feature(cfg_target_has_atomic)]` to the crate attributes to enable\n+\n+error[E0658]: `cfg(target_has_atomic_load_store)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:94:10\n+   |\n+LL |     cfg!(target_has_atomic_load_store = \"32\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #32976 <https://github.com/rust-lang/rust/issues/32976> for more information\n+   = help: add `#![feature(cfg_target_has_atomic)]` to the crate attributes to enable\n+\n+error[E0658]: `cfg(target_has_atomic_load_store)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:96:10\n+   |\n+LL |     cfg!(target_has_atomic_load_store = \"64\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #32976 <https://github.com/rust-lang/rust/issues/32976> for more information\n+   = help: add `#![feature(cfg_target_has_atomic)]` to the crate attributes to enable\n+\n+error[E0658]: `cfg(target_has_atomic_load_store)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:98:10\n+   |\n+LL |     cfg!(target_has_atomic_load_store = \"128\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #32976 <https://github.com/rust-lang/rust/issues/32976> for more information\n+   = help: add `#![feature(cfg_target_has_atomic)]` to the crate attributes to enable\n+\n+error[E0658]: `cfg(target_has_atomic_load_store)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:100:10\n+   |\n+LL |     cfg!(target_has_atomic_load_store = \"ptr\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #32976 <https://github.com/rust-lang/rust/issues/32976> for more information\n+   = help: add `#![feature(cfg_target_has_atomic)]` to the crate attributes to enable\n+\n+error[E0658]: `cfg(target_has_atomic_equal_alignment)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:102:10\n+   |\n+LL |     cfg!(target_has_atomic_equal_alignment = \"8\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #32976 <https://github.com/rust-lang/rust/issues/32976> for more information\n+   = help: add `#![feature(cfg_target_has_atomic)]` to the crate attributes to enable\n+\n+error[E0658]: `cfg(target_has_atomic_equal_alignment)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:104:10\n+   |\n+LL |     cfg!(target_has_atomic_equal_alignment = \"16\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #32976 <https://github.com/rust-lang/rust/issues/32976> for more information\n+   = help: add `#![feature(cfg_target_has_atomic)]` to the crate attributes to enable\n+\n+error[E0658]: `cfg(target_has_atomic_equal_alignment)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:106:10\n+   |\n+LL |     cfg!(target_has_atomic_equal_alignment = \"32\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #32976 <https://github.com/rust-lang/rust/issues/32976> for more information\n+   = help: add `#![feature(cfg_target_has_atomic)]` to the crate attributes to enable\n+\n+error[E0658]: `cfg(target_has_atomic_equal_alignment)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:108:10\n+   |\n+LL |     cfg!(target_has_atomic_equal_alignment = \"64\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #32976 <https://github.com/rust-lang/rust/issues/32976> for more information\n+   = help: add `#![feature(cfg_target_has_atomic)]` to the crate attributes to enable\n+\n+error[E0658]: `cfg(target_has_atomic_equal_alignment)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:110:10\n+   |\n+LL |     cfg!(target_has_atomic_equal_alignment = \"128\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #32976 <https://github.com/rust-lang/rust/issues/32976> for more information\n+   = help: add `#![feature(cfg_target_has_atomic)]` to the crate attributes to enable\n+\n+error[E0658]: `cfg(target_has_atomic_equal_alignment)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:112:10\n+   |\n+LL |     cfg!(target_has_atomic_equal_alignment = \"ptr\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #32976 <https://github.com/rust-lang/rust/issues/32976> for more information\n+   = help: add `#![feature(cfg_target_has_atomic)]` to the crate attributes to enable\n+\n+error: aborting due to 30 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "63b8b29d6ce2861db2a879c6d2d2bca76fa67d3c", "filename": "src/test/ui/macros/same-sequence-span.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -17,15 +17,11 @@ LL |                $(= $z:tt)*\n error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fragments\n   --> $DIR/same-sequence-span.rs:19:1\n    |\n-LL |   proc_macro_sequence::make_foo!();\n-   |   ^--------------------------------\n-   |   |\n-   |  _in this macro invocation\n+LL | proc_macro_sequence::make_foo!();\n+   | ---------------------------------^^^^^^^^^^^^^\n    | |\n-LL | |\n-LL | |\n-LL | | fn main() {}\n-...  |\n+   | not allowed after `expr` fragments\n+   | in this macro invocation\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)"}, {"sha": "81cebae17aeba4d1690326f5831650a86638be59", "filename": "src/test/ui/proc-macro/meta-macro-hygiene.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -1,6 +1,6 @@\n-Def site: $DIR/auxiliary/make-macro.rs:7:9: 16:10 (#5)\n+Def site: $DIR/auxiliary/make-macro.rs:7:9: 7:56 (#5)\n Input: TokenStream [Ident { ident: \"$crate\", span: $DIR/meta-macro-hygiene.rs:24:37: 24:43 (#4) }, Punct { ch: ':', spacing: Joint, span: $DIR/meta-macro-hygiene.rs:24:43: 24:45 (#4) }, Punct { ch: ':', spacing: Alone, span: $DIR/meta-macro-hygiene.rs:24:43: 24:45 (#4) }, Ident { ident: \"dummy\", span: $DIR/meta-macro-hygiene.rs:24:45: 24:50 (#4) }, Punct { ch: '!', spacing: Alone, span: $DIR/meta-macro-hygiene.rs:24:50: 24:51 (#4) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: $DIR/meta-macro-hygiene.rs:24:51: 24:53 (#4) }]\n-Respanned: TokenStream [Ident { ident: \"$crate\", span: $DIR/auxiliary/make-macro.rs:7:9: 16:10 (#5) }, Punct { ch: ':', spacing: Joint, span: $DIR/auxiliary/make-macro.rs:7:9: 16:10 (#5) }, Punct { ch: ':', spacing: Alone, span: $DIR/auxiliary/make-macro.rs:7:9: 16:10 (#5) }, Ident { ident: \"dummy\", span: $DIR/auxiliary/make-macro.rs:7:9: 16:10 (#5) }, Punct { ch: '!', spacing: Alone, span: $DIR/auxiliary/make-macro.rs:7:9: 16:10 (#5) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: $DIR/auxiliary/make-macro.rs:7:9: 16:10 (#5) }]\n+Respanned: TokenStream [Ident { ident: \"$crate\", span: $DIR/auxiliary/make-macro.rs:7:9: 7:56 (#5) }, Punct { ch: ':', spacing: Joint, span: $DIR/auxiliary/make-macro.rs:7:9: 7:56 (#5) }, Punct { ch: ':', spacing: Alone, span: $DIR/auxiliary/make-macro.rs:7:9: 7:56 (#5) }, Ident { ident: \"dummy\", span: $DIR/auxiliary/make-macro.rs:7:9: 7:56 (#5) }, Punct { ch: '!', spacing: Alone, span: $DIR/auxiliary/make-macro.rs:7:9: 7:56 (#5) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: $DIR/auxiliary/make-macro.rs:7:9: 7:56 (#5) }]\n #![feature /* 0#0 */(prelude_import)]\n // ignore-tidy-linelength\n // aux-build:make-macro.rs"}, {"sha": "662682d40b2c68640e5c057d43f531802f1e90c7", "filename": "src/test/ui/proc-macro/meta-macro.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro.stdout?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -1,3 +1,3 @@\n-Def site: $DIR/auxiliary/make-macro.rs:7:9: 16:10 (#4)\n+Def site: $DIR/auxiliary/make-macro.rs:7:9: 7:56 (#4)\n Input: TokenStream []\n Respanned: TokenStream []"}, {"sha": "5bf381607c5ed6eb78b7886bc211e17270f6d38f", "filename": "src/test/ui/recursion/issue-38591-non-regular-dropck-recursion.stderr", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -1,26 +1,14 @@\n error: reached the recursion limit while instantiating `drop_in_place::<S<fn(fn(fn(fn(fn...)))))))))))))))))))))))))))))>))`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-LL | / pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n-LL | |     // Code here does not matter - this is replaced by the\n-LL | |     // real drop glue by the compiler.\n-LL | |\n-LL | |     // SAFETY: see comment above\n-LL | |     unsafe { drop_in_place(to_drop) }\n-LL | | }\n-   | |_^\n+LL | pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: `drop_in_place` defined here\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-LL | / pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n-LL | |     // Code here does not matter - this is replaced by the\n-LL | |     // real drop glue by the compiler.\n-LL | |\n-LL | |     // SAFETY: see comment above\n-LL | |     unsafe { drop_in_place(to_drop) }\n-LL | | }\n-   | |_^\n+LL | pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the full type name has been written to '$TEST_BUILD_DIR/recursion/issue-38591-non-regular-dropck-recursion/issue-38591-non-regular-dropck-recursion.long-type.txt'\n \n error: aborting due to previous error"}, {"sha": "a2ddffff997d882af39f5f3ac15b1c9c34b8566f", "filename": "src/test/ui/type_length_limit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Ftype_length_limit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c35177582ba22dc7eb3d0d08e972424aed8bd374/src%2Ftest%2Fui%2Ftype_length_limit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype_length_limit.stderr?ref=c35177582ba22dc7eb3d0d08e972424aed8bd374", "patch": "@@ -2,7 +2,7 @@ error: reached the type-length limit while instantiating `std::mem::drop::<Optio\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    |\n LL | pub fn drop<T>(_x: T) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the full type name has been written to '$TEST_BUILD_DIR/type_length_limit/type_length_limit.long-type.txt'\n    = help: consider adding a `#![type_length_limit=\"8\"]` attribute to your crate"}]}