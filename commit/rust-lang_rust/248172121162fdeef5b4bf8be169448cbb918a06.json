{"sha": "248172121162fdeef5b4bf8be169448cbb918a06", "node_id": "C_kwDOAAsO6NoAKDI0ODE3MjEyMTE2MmZkZWVmNWI0YmY4YmUxNjk0NDhjYmI5MThhMDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-20T18:13:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-20T18:13:09Z"}, "message": "Auto merge of #13447 - Veykril:didsavedoc-block, r=Veykril\n\nfix: Fix DidSaveDocument requests blocking the server on startup\n\nFollow up to https://github.com/rust-lang/rust-analyzer/pull/13428\nFixes https://github.com/rust-lang/rust-analyzer/issues/13434", "tree": {"sha": "670758c37a6add34773678bd389ce5b3dec7a37e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/670758c37a6add34773678bd389ce5b3dec7a37e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/248172121162fdeef5b4bf8be169448cbb918a06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/248172121162fdeef5b4bf8be169448cbb918a06", "html_url": "https://github.com/rust-lang/rust/commit/248172121162fdeef5b4bf8be169448cbb918a06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/248172121162fdeef5b4bf8be169448cbb918a06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7741e3dc732b4b8db9621b9002abd92f1f949cee", "url": "https://api.github.com/repos/rust-lang/rust/commits/7741e3dc732b4b8db9621b9002abd92f1f949cee", "html_url": "https://github.com/rust-lang/rust/commit/7741e3dc732b4b8db9621b9002abd92f1f949cee"}, {"sha": "de195ff97cda417c61c8760bb332167b2c377078", "url": "https://api.github.com/repos/rust-lang/rust/commits/de195ff97cda417c61c8760bb332167b2c377078", "html_url": "https://github.com/rust-lang/rust/commit/de195ff97cda417c61c8760bb332167b2c377078"}], "stats": {"total": 215, "additions": 132, "deletions": 83}, "files": [{"sha": "416817ca0b42c8c3bd4d7bb4c9c8b3afa7c43906", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/248172121162fdeef5b4bf8be169448cbb918a06/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/248172121162fdeef5b4bf8be169448cbb918a06/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=248172121162fdeef5b4bf8be169448cbb918a06", "patch": "@@ -486,6 +486,16 @@ impl Analysis {\n         self.with_db(|db| parent_module::crates_for(db, file_id))\n     }\n \n+    /// Returns crates this file belongs too.\n+    pub fn transitive_rev_deps(&self, crate_id: CrateId) -> Cancellable<Vec<CrateId>> {\n+        self.with_db(|db| db.crate_graph().transitive_rev_deps(crate_id).collect())\n+    }\n+\n+    /// Returns crates this file *might* belong too.\n+    pub fn relevant_crates_for(&self, file_id: FileId) -> Cancellable<Vec<CrateId>> {\n+        self.with_db(|db| db.relevant_crates(file_id).iter().copied().collect())\n+    }\n+\n     /// Returns the edition of the given crate.\n     pub fn crate_edition(&self, crate_id: CrateId) -> Cancellable<Edition> {\n         self.with_db(|db| db.crate_graph()[crate_id].edition)"}, {"sha": "506f9452cf1964d003e3d3f06b5c20f5bcc9cde5", "filename": "crates/ide/src/parent_module.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/248172121162fdeef5b4bf8be169448cbb918a06/crates%2Fide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/248172121162fdeef5b4bf8be169448cbb918a06/crates%2Fide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fparent_module.rs?ref=248172121162fdeef5b4bf8be169448cbb918a06", "patch": "@@ -1,8 +1,9 @@\n-use hir::Semantics;\n+use hir::{db::DefDatabase, Semantics};\n use ide_db::{\n     base_db::{CrateId, FileId, FileLoader, FilePosition},\n     RootDatabase,\n };\n+use itertools::Itertools;\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, AstNode},\n@@ -55,7 +56,12 @@ pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<Na\n \n /// Returns `Vec` for the same reason as `parent_module`\n pub(crate) fn crates_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n-    db.relevant_crates(file_id).iter().copied().collect()\n+    db.relevant_crates(file_id)\n+        .iter()\n+        .copied()\n+        .filter(|&crate_id| db.crate_def_map(crate_id).modules_for_file(file_id).next().is_some())\n+        .sorted()\n+        .collect()\n }\n \n #[cfg(test)]"}, {"sha": "6ede194babc2067529fdec2f810fbee62cc1c06d", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/248172121162fdeef5b4bf8be169448cbb918a06/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/248172121162fdeef5b4bf8be169448cbb918a06/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=248172121162fdeef5b4bf8be169448cbb918a06", "patch": "@@ -118,7 +118,11 @@ impl CargoTargetSpec {\n         global_state_snapshot: &GlobalStateSnapshot,\n         file_id: FileId,\n     ) -> Result<Option<CargoTargetSpec>> {\n-        let (cargo_ws, target) = match global_state_snapshot.cargo_target_for_file_id(file_id) {\n+        let crate_id = match &*global_state_snapshot.analysis.crates_for(file_id)? {\n+            &[crate_id, ..] => crate_id,\n+            _ => return Ok(None),\n+        };\n+        let (cargo_ws, target) = match global_state_snapshot.cargo_target_for_crate_root(crate_id) {\n             Some(it) => it,\n             None => return Ok(None),\n         };"}, {"sha": "3fb06c31f7ca792c068e1dcf81e1dab7c7f8af9c", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/248172121162fdeef5b4bf8be169448cbb918a06/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/248172121162fdeef5b4bf8be169448cbb918a06/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=248172121162fdeef5b4bf8be169448cbb918a06", "patch": "@@ -8,7 +8,7 @@ use std::{sync::Arc, time::Instant};\n use crossbeam_channel::{unbounded, Receiver, Sender};\n use flycheck::FlycheckHandle;\n use ide::{Analysis, AnalysisHost, Cancellable, Change, FileId};\n-use ide_db::base_db::{FileLoader, SourceDatabase};\n+use ide_db::base_db::{CrateId, FileLoader, SourceDatabase};\n use lsp_types::{SemanticTokens, Url};\n use parking_lot::{Mutex, RwLock};\n use proc_macro_api::ProcMacroServer;\n@@ -64,7 +64,7 @@ pub(crate) struct GlobalState {\n     pub(crate) source_root_config: SourceRootConfig,\n     pub(crate) proc_macro_clients: Vec<Result<ProcMacroServer, String>>,\n \n-    pub(crate) flycheck: Vec<FlycheckHandle>,\n+    pub(crate) flycheck: Arc<[FlycheckHandle]>,\n     pub(crate) flycheck_sender: Sender<flycheck::Message>,\n     pub(crate) flycheck_receiver: Receiver<flycheck::Message>,\n \n@@ -117,6 +117,7 @@ pub(crate) struct GlobalStateSnapshot {\n     vfs: Arc<RwLock<(vfs::Vfs, NoHashHashMap<FileId, LineEndings>)>>,\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub(crate) proc_macros_loaded: bool,\n+    pub(crate) flycheck: Arc<[FlycheckHandle]>,\n }\n \n impl std::panic::UnwindSafe for GlobalStateSnapshot {}\n@@ -155,7 +156,7 @@ impl GlobalState {\n             source_root_config: SourceRootConfig::default(),\n             proc_macro_clients: vec![],\n \n-            flycheck: Vec::new(),\n+            flycheck: Arc::new([]),\n             flycheck_sender,\n             flycheck_receiver,\n \n@@ -295,6 +296,7 @@ impl GlobalState {\n             mem_docs: self.mem_docs.clone(),\n             semantic_tokens_cache: Arc::clone(&self.semantic_tokens_cache),\n             proc_macros_loaded: !self.fetch_build_data_queue.last_op_result().0.is_empty(),\n+            flycheck: self.flycheck.clone(),\n         }\n     }\n \n@@ -398,10 +400,15 @@ impl GlobalStateSnapshot {\n         url_from_abs_path(path)\n     }\n \n-    pub(crate) fn cargo_target_for_file_id(\n+    pub(crate) fn file_id_to_file_path(&self, file_id: FileId) -> vfs::VfsPath {\n+        self.vfs.read().0.file_path(file_id)\n+    }\n+\n+    pub(crate) fn cargo_target_for_crate_root(\n         &self,\n-        file_id: FileId,\n+        crate_id: CrateId,\n     ) -> Option<(&CargoWorkspace, Target)> {\n+        let file_id = self.analysis.crate_root(crate_id).ok()?;\n         let path = self.vfs.read().0.file_path(file_id);\n         let path = path.as_path()?;\n         self.workspaces.iter().find_map(|ws| match ws {"}, {"sha": "34795a8eb40ab7844e11af047f8127b16a814247", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/248172121162fdeef5b4bf8be169448cbb918a06/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/248172121162fdeef5b4bf8be169448cbb918a06/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=248172121162fdeef5b4bf8be169448cbb918a06", "patch": "@@ -1782,7 +1782,15 @@ fn run_rustfmt(\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let file_id = from_proto::file_id(snap, &text_document.uri)?;\n     let file = snap.analysis.file_text(file_id)?;\n-    let crate_ids = snap.analysis.crates_for(file_id)?;\n+\n+    // find the edition of the package the file belongs to\n+    // (if it belongs to multiple we'll just pick the first one and pray)\n+    let edition = snap\n+        .analysis\n+        .relevant_crates_for(file_id)?\n+        .into_iter()\n+        .find_map(|crate_id| snap.cargo_target_for_crate_root(crate_id))\n+        .map(|(ws, target)| ws[ws[target].package].edition);\n \n     let line_index = snap.file_line_index(file_id)?;\n \n@@ -1808,9 +1816,7 @@ fn run_rustfmt(\n                     );\n                 }\n             }\n-            if let Some(&crate_id) = crate_ids.first() {\n-                // Assume all crates are in the same edition\n-                let edition = snap.analysis.crate_edition(crate_id)?;\n+            if let Some(edition) = edition {\n                 cmd.arg(\"--edition\");\n                 cmd.arg(edition.to_string());\n             }"}, {"sha": "319b86c58b5c86fa2cb8f7e18240d406dd6312ac", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 84, "deletions": 69, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/248172121162fdeef5b4bf8be169448cbb918a06/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/248172121162fdeef5b4bf8be169448cbb918a06/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=248172121162fdeef5b4bf8be169448cbb918a06", "patch": "@@ -10,7 +10,7 @@ use std::{\n use always_assert::always;\n use crossbeam_channel::{select, Receiver};\n use flycheck::FlycheckHandle;\n-use ide_db::base_db::{SourceDatabase, SourceDatabaseExt, VfsPath};\n+use ide_db::base_db::{SourceDatabaseExt, VfsPath};\n use itertools::Itertools;\n use lsp_server::{Connection, Notification, Request};\n use lsp_types::notification::Notification as _;\n@@ -191,7 +191,7 @@ impl GlobalState {\n         // NOTE: don't count blocking select! call as a loop-turn time\n         let _p = profile::span(\"GlobalState::handle_event\");\n \n-        tracing::debug!(\"handle_event({:?})\", event);\n+        tracing::debug!(\"{:?} handle_event({:?})\", loop_start, event);\n         let task_queue_len = self.task_pool.handle.len();\n         if task_queue_len > 0 {\n             tracing::info!(\"task queue len: {}\", task_queue_len);\n@@ -727,7 +727,7 @@ impl GlobalState {\n                         .insert(path.clone(), DocumentData::new(params.text_document.version))\n                         .is_err();\n                     if already_exists {\n-                        tracing::error!(\"duplicate DidOpenTextDocument: {}\", path)\n+                        tracing::error!(\"duplicate DidOpenTextDocument: {}\", path);\n                     }\n                     this.vfs\n                         .write()\n@@ -774,83 +774,98 @@ impl GlobalState {\n                 Ok(())\n             })?\n             .on::<lsp_types::notification::DidSaveTextDocument>(|this, params| {\n-                let mut updated = false;\n                 if let Ok(vfs_path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    let (vfs, _) = &*this.vfs.read();\n-\n-                    // Trigger flychecks for all workspaces that depend on the saved file\n-                    if let Some(file_id) = vfs.file_id(&vfs_path) {\n-                        let analysis = this.analysis_host.analysis();\n-                        // Crates containing or depending on the saved file\n-                        let crate_ids: Vec<_> = analysis\n-                            .crates_for(file_id)?\n-                            .into_iter()\n-                            .flat_map(|id| {\n-                                this.analysis_host\n-                                    .raw_database()\n-                                    .crate_graph()\n-                                    .transitive_rev_deps(id)\n-                            })\n-                            .sorted()\n-                            .unique()\n-                            .collect();\n-\n-                        let crate_root_paths: Vec<_> = crate_ids\n-                            .iter()\n-                            .filter_map(|&crate_id| {\n-                                analysis\n-                                    .crate_root(crate_id)\n-                                    .map(|file_id| {\n-                                        vfs.file_path(file_id).as_path().map(ToOwned::to_owned)\n-                                    })\n-                                    .transpose()\n-                            })\n-                            .collect::<ide::Cancellable<_>>()?;\n-                        let crate_root_paths: Vec<_> =\n-                            crate_root_paths.iter().map(Deref::deref).collect();\n-\n-                        // Find all workspaces that have at least one target containing the saved file\n-                        let workspace_ids =\n-                            this.workspaces.iter().enumerate().filter(|(_, ws)| match ws {\n-                                project_model::ProjectWorkspace::Cargo { cargo, .. } => {\n-                                    cargo.packages().any(|pkg| {\n-                                        cargo[pkg].targets.iter().any(|&it| {\n-                                            crate_root_paths.contains(&cargo[it].root.as_path())\n-                                        })\n-                                    })\n-                                }\n-                                project_model::ProjectWorkspace::Json { project, .. } => project\n-                                    .crates()\n-                                    .any(|(c, _)| crate_ids.iter().any(|&crate_id| crate_id == c)),\n-                                project_model::ProjectWorkspace::DetachedFiles { .. } => false,\n-                            });\n-\n-                        // Find and trigger corresponding flychecks\n-                        for flycheck in &this.flycheck {\n-                            for (id, _) in workspace_ids.clone() {\n-                                if id == flycheck.id() {\n-                                    updated = true;\n-                                    flycheck.restart();\n-                                    continue;\n-                                }\n-                            }\n-                        }\n-                    }\n-\n                     // Re-fetch workspaces if a workspace related file has changed\n                     if let Some(abs_path) = vfs_path.as_path() {\n                         if reload::should_refresh_for_change(&abs_path, ChangeKind::Modify) {\n                             this.fetch_workspaces_queue\n                                 .request_op(format!(\"DidSaveTextDocument {}\", abs_path.display()));\n                         }\n                     }\n+\n+                    let file_id = this.vfs.read().0.file_id(&vfs_path);\n+                    if let Some(file_id) = file_id {\n+                        let world = this.snapshot();\n+                        let mut updated = false;\n+                        let task = move || -> std::result::Result<(), ide::Cancelled> {\n+                            // Trigger flychecks for all workspaces that depend on the saved file\n+                            // Crates containing or depending on the saved file\n+                            let crate_ids: Vec<_> = world\n+                                .analysis\n+                                .crates_for(file_id)?\n+                                .into_iter()\n+                                .flat_map(|id| world.analysis.transitive_rev_deps(id))\n+                                .flatten()\n+                                .sorted()\n+                                .unique()\n+                                .collect();\n+\n+                            let crate_root_paths: Vec<_> = crate_ids\n+                                .iter()\n+                                .filter_map(|&crate_id| {\n+                                    world\n+                                        .analysis\n+                                        .crate_root(crate_id)\n+                                        .map(|file_id| {\n+                                            world\n+                                                .file_id_to_file_path(file_id)\n+                                                .as_path()\n+                                                .map(ToOwned::to_owned)\n+                                        })\n+                                        .transpose()\n+                                })\n+                                .collect::<ide::Cancellable<_>>()?;\n+                            let crate_root_paths: Vec<_> =\n+                                crate_root_paths.iter().map(Deref::deref).collect();\n+\n+                            // Find all workspaces that have at least one target containing the saved file\n+                            let workspace_ids =\n+                                world.workspaces.iter().enumerate().filter(|(_, ws)| match ws {\n+                                    project_model::ProjectWorkspace::Cargo { cargo, .. } => {\n+                                        cargo.packages().any(|pkg| {\n+                                            cargo[pkg].targets.iter().any(|&it| {\n+                                                crate_root_paths.contains(&cargo[it].root.as_path())\n+                                            })\n+                                        })\n+                                    }\n+                                    project_model::ProjectWorkspace::Json { project, .. } => {\n+                                        project.crates().any(|(c, _)| {\n+                                            crate_ids.iter().any(|&crate_id| crate_id == c)\n+                                        })\n+                                    }\n+                                    project_model::ProjectWorkspace::DetachedFiles { .. } => false,\n+                                });\n+\n+                            // Find and trigger corresponding flychecks\n+                            for flycheck in world.flycheck.iter() {\n+                                for (id, _) in workspace_ids.clone() {\n+                                    if id == flycheck.id() {\n+                                        updated = true;\n+                                        flycheck.restart();\n+                                        continue;\n+                                    }\n+                                }\n+                            }\n+                            // No specific flycheck was triggered, so let's trigger all of them.\n+                            if !updated {\n+                                for flycheck in world.flycheck.iter() {\n+                                    flycheck.restart();\n+                                }\n+                            }\n+                            Ok(())\n+                        };\n+                        this.task_pool.handle.spawn_with_sender(move |_| {\n+                            if let Err(e) = std::panic::catch_unwind(task) {\n+                                tracing::error!(\"DidSaveTextDocument flycheck task panicked: {e:?}\")\n+                            }\n+                        });\n+                        return Ok(());\n+                    }\n                 }\n \n                 // No specific flycheck was triggered, so let's trigger all of them.\n-                if !updated {\n-                    for flycheck in &this.flycheck {\n-                        flycheck.restart();\n-                    }\n+                for flycheck in this.flycheck.iter() {\n+                    flycheck.restart();\n                 }\n                 Ok(())\n             })?"}, {"sha": "cc7600a2fa98538754b87fd9274b7d56507f4d6c", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/248172121162fdeef5b4bf8be169448cbb918a06/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/248172121162fdeef5b4bf8be169448cbb918a06/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=248172121162fdeef5b4bf8be169448cbb918a06", "patch": "@@ -466,7 +466,7 @@ impl GlobalState {\n         let config = match self.config.flycheck() {\n             Some(it) => it,\n             None => {\n-                self.flycheck = Vec::new();\n+                self.flycheck = Arc::new([]);\n                 self.diagnostics.clear_check_all();\n                 return;\n             }\n@@ -510,7 +510,8 @@ impl GlobalState {\n                     })\n                     .collect()\n             }\n-        };\n+        }\n+        .into();\n     }\n }\n "}]}