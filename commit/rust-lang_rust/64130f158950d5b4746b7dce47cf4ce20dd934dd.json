{"sha": "64130f158950d5b4746b7dce47cf4ce20dd934dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MTMwZjE1ODk1MGQ1YjQ3NDZiN2RjZTQ3Y2Y0Y2UyMGRkOTM0ZGQ=", "commit": {"author": {"name": "Gareth Daniel Smith", "email": "garethdanielsmith@gmail.com", "date": "2012-05-19T18:25:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-22T00:38:04Z"}, "message": "add a bunch more rand::rng extension methods - one for each primitive type and also some choose/shuffle functions (for https://github.com/mozilla/rust/issues/2379)", "tree": {"sha": "88c899f9f59a8f29dae0d29c76e6153e63ccf40a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88c899f9f59a8f29dae0d29c76e6153e63ccf40a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64130f158950d5b4746b7dce47cf4ce20dd934dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64130f158950d5b4746b7dce47cf4ce20dd934dd", "html_url": "https://github.com/rust-lang/rust/commit/64130f158950d5b4746b7dce47cf4ce20dd934dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64130f158950d5b4746b7dce47cf4ce20dd934dd/comments", "author": {"login": "Dretch", "id": 1428731, "node_id": "MDQ6VXNlcjE0Mjg3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1428731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dretch", "html_url": "https://github.com/Dretch", "followers_url": "https://api.github.com/users/Dretch/followers", "following_url": "https://api.github.com/users/Dretch/following{/other_user}", "gists_url": "https://api.github.com/users/Dretch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dretch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dretch/subscriptions", "organizations_url": "https://api.github.com/users/Dretch/orgs", "repos_url": "https://api.github.com/users/Dretch/repos", "events_url": "https://api.github.com/users/Dretch/events{/privacy}", "received_events_url": "https://api.github.com/users/Dretch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11e81951bb514b55fab0057442a168e81d6f37cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/11e81951bb514b55fab0057442a168e81d6f37cc", "html_url": "https://github.com/rust-lang/rust/commit/11e81951bb514b55fab0057442a168e81d6f37cc"}], "stats": {"total": 313, "additions": 275, "deletions": 38}, "files": [{"sha": "2dac731f5671b30f628a48af29e49397f62fb141", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 275, "deletions": 38, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/64130f158950d5b4746b7dce47cf4ce20dd934dd/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64130f158950d5b4746b7dce47cf4ce20dd934dd/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=64130f158950d5b4746b7dce47cf4ce20dd934dd", "patch": "@@ -1,6 +1,6 @@\n #[doc = \"Random number generation\"];\n \n-export rng, extensions;\n+export rng, weighted, extensions;\n \n enum rctx {}\n \n@@ -17,44 +17,214 @@ iface rng {\n     fn next() -> u32;\n }\n \n+#[doc = \"A value with a particular weight compared to other values\"]\n+type weighted<T> = { weight: uint, item: T };\n+\n #[doc = \"Extension methods for random number generators\"]\n impl extensions for rng {\n \n+    #[doc = \"Return a random int\"]\n+    fn gen_int() -> int {\n+        self.gen_i64() as int\n+    }\n+\n+    #[doc = \"Return an int randomly chosen from the range [start, end], \\\n+             failing if start > end\"]\n+    fn gen_int_from(start: int, end: int) -> int {\n+        assert start <= end;\n+        start + int::abs(self.gen_int() % (end - start + 1))\n+    }\n+\n+    #[doc = \"Return a random i8\"]\n+    fn gen_i8() -> i8 {\n+        self.next() as i8\n+    }\n+\n+    #[doc = \"Return a random i16\"]\n+    fn gen_i16() -> i16 {\n+        self.next() as i16\n+    }\n+\n+    #[doc = \"Return a random i32\"]\n+    fn gen_i32() -> i32 {\n+        self.next() as i32\n+    }\n+\n+    #[doc = \"Return a random i64\"]\n+    fn gen_i64() -> i64 {\n+        (self.next() as i64 << 32) | self.next() as i64\n+    }\n+\n+    #[doc = \"Return a random uint\"]\n+    fn gen_uint() -> uint {\n+        self.gen_u64() as u64\n+    }\n+\n+    #[doc = \"Return a uint randomly chosen from the range [start, end], \\\n+             failing if start > end\"]\n+    fn gen_uint_from(start: uint, end: uint) -> uint {\n+        assert start <= end;\n+        start + (self.gen_uint() % (end - start + 1u))\n+    }\n+\n+    #[doc = \"Return a random u8\"]\n+    fn gen_u8() -> u8 {\n+        self.next() as u8\n+    }\n+\n+    #[doc = \"Return a random u16\"]\n+    fn gen_u16() -> u16 {\n+        self.next() as u16\n+    }\n+\n+    #[doc = \"Return a random u32\"]\n+    fn gen_u32() -> u32 {\n+        self.next()\n+    }\n+\n+    #[doc = \"Return a random u64\"]\n+    fn gen_u64() -> u64 {\n+        (self.next() as u64 << 32) | self.next() as u64\n+    }\n+\n     #[doc = \"Return a random float\"]\n     fn gen_float() -> float {\n-          let u1 = self.next() as float;\n-          let u2 = self.next() as float;\n-          let u3 = self.next() as float;\n-          let scale = u32::max_value as float;\n-          ret ((u1 / scale + u2) / scale + u3) / scale;\n+        self.gen_f64() as float\n     }\n \n-    #[doc = \"Return a random string composed of A-Z, a-z, 0-9.\"]\n+    #[doc = \"Return a random f32\"]\n+    fn gen_f32() -> f32 {\n+        self.gen_f64() as f32\n+    }\n+\n+    #[doc = \"Return a random f64\"]\n+    fn gen_f64() -> f64 {\n+        let u1 = self.next() as f64;\n+        let u2 = self.next() as f64;\n+        let u3 = self.next() as f64;\n+        let scale = u32::max_value as f64;\n+        ret ((u1 / scale + u2) / scale + u3) / scale;\n+    }\n+\n+    #[doc = \"Return a random char\"]\n+    fn gen_char() -> char {\n+        self.next() as char\n+    }\n+\n+    #[doc = \"Return a char randomly chosen from chars, failing if chars is \\\n+             empty\"]\n+    fn gen_char_from(chars: str) -> char {\n+        assert !chars.is_empty();\n+        self.choose(str::chars(chars))\n+    }\n+\n+    #[doc = \"Return a random bool\"]\n+    fn gen_bool() -> bool {\n+        self.next() & 1u32 == 1u32\n+    }\n+\n+    #[doc = \"Return a bool with a 1 in n chance of true\"]\n+    fn gen_weighted_bool(n: uint) -> bool {\n+        if n == 0u {\n+            true\n+        } else {\n+            self.gen_uint_from(1u, n) == 1u\n+        }\n+    }\n+\n+    #[doc = \"Return a random string of the specified length composed of A-Z, \\\n+             a-z, 0-9\"]\n     fn gen_str(len: uint) -> str {\n         let charset = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                       \"abcdefghijklmnopqrstuvwxyz\" +\n                       \"0123456789\";\n         let mut s = \"\";\n         let mut i = 0u;\n         while (i < len) {\n-            let n = self.next() as uint % charset.len();\n-            s = s + str::from_char(str::char_at(charset, n));\n+            s = s + str::from_char(self.gen_char_from(charset));\n             i += 1u;\n         }\n         s\n     }\n \n-    #[doc = \"Return a random byte string.\"]\n+    #[doc = \"Return a random byte string of the specified length\"]\n     fn gen_bytes(len: uint) -> [u8] {\n-        let mut v = [];\n-        let mut i = 0u;\n-        while i < len {\n-            let n = self.next() as uint;\n-            v += [(n % (u8::max_value as uint)) as u8];\n-            i += 1u;\n+        vec::from_fn(len) {|_i|\n+            self.gen_u8()\n+        }\n+    }\n+\n+    #[doc = \"Choose an item randomly, failing if values is empty\"]\n+    fn choose<T:copy>(values: [T]) -> T {\n+        self.choose_option(values).get()\n+    }\n+\n+    #[doc = \"Choose some(item) randomly, returning none if values is empty\"]\n+    fn choose_option<T:copy>(values: [T]) -> option<T> {\n+        if values.is_empty() {\n+            none\n+        } else {\n+            some(values[self.gen_uint_from(0u, values.len() - 1u)])\n         }\n-        v\n     }\n+\n+    #[doc = \"Choose an item respecting the relative weights, failing if \\\n+             the sum of the weights is 0\"]\n+    fn choose_weighted<T: copy>(v : [weighted<T>]) -> T {\n+        self.choose_weighted_option(v).get()\n+    }\n+\n+    #[doc = \"Choose some(item) respecting the relative weights, returning \\\n+             none if the sum of the weights is 0\"]\n+    fn choose_weighted_option<T:copy>(v: [weighted<T>]) -> option<T> {\n+        let mut total = 0u;\n+        for v.each {|item|\n+            total += item.weight;\n+        }\n+        if total == 0u {\n+            ret none;\n+        }\n+        let chosen = self.gen_uint_from(0u, total - 1u);\n+        let mut so_far = 0u;\n+        for v.each {|item|\n+            so_far += item.weight;\n+            if so_far > chosen {\n+                ret some(item.item);\n+            }\n+        }\n+        unreachable();\n+    }\n+\n+    #[doc = \"Return a vec containing copies of the items, in order, where \\\n+             the weight of the item determines how many copies there are\"]\n+    fn weighted_vec<T:copy>(v: [weighted<T>]) -> [T] {\n+        let mut r = [];\n+        for v.each {|item|\n+            uint::range(0u, item.weight) {|_i|\n+                r += [item.item];\n+            }\n+        }\n+        r\n+    }\n+\n+    #[doc = \"Shuffle a vec\"]\n+    fn shuffle<T:copy>(values: [T]) -> [T] {\n+        let mut m = vec::to_mut(values);\n+        self.shuffle_mut(m);\n+        ret vec::from_mut(m);\n+    }\n+\n+    #[doc = \"Shuffle a mutable vec in place\"]\n+    fn shuffle_mut<T>(&values: [mut T]) {\n+        let mut i = values.len();\n+        while i >= 2u {\n+            // invariant: elements with index >= i have been locked in place.\n+            i -= 1u;\n+            // lock element i in place.\n+            vec::swap(values, i, self.gen_uint_from(0u, i));\n+        }\n+    }\n+\n }\n \n #[doc = \"Create a random number generator\"]\n@@ -72,27 +242,33 @@ fn rng() -> rng {\n mod tests {\n \n     #[test]\n-    fn test() {\n-        let r1 = rand::rng();\n-        log(debug, r1.next());\n-        log(debug, r1.next());\n-        {\n-            let r2 = rand::rng();\n-            log(debug, r1.next());\n-            log(debug, r2.next());\n-            log(debug, r1.next());\n-            log(debug, r1.next());\n-            log(debug, r2.next());\n-            log(debug, r2.next());\n-            log(debug, r1.next());\n-            log(debug, r1.next());\n-            log(debug, r1.next());\n-            log(debug, r2.next());\n-            log(debug, r2.next());\n-            log(debug, r2.next());\n-        }\n-        log(debug, r1.next());\n-        log(debug, r1.next());\n+    fn gen_int_from() {\n+        let r = rand::rng();\n+        let a = r.gen_int_from(-3, 42);\n+        assert a >= -3 && a <= 42;\n+        assert r.gen_int_from(0, 0) == 0;\n+        assert r.gen_int_from(-12, -12) == -12;\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn gen_int_from_fail() {\n+        rand::rng().gen_int_from(5, -2);\n+    }\n+\n+    #[test]\n+    fn gen_uint_from() {\n+        let r = rand::rng();\n+        let a = r.gen_uint_from(3u, 42u);\n+        assert a >= 3u && a <= 42u;\n+        assert r.gen_uint_from(0u, 0u) == 0u;\n+        assert r.gen_uint_from(12u, 12u) == 12u;\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn gen_uint_from_fail() {\n+        rand::rng().gen_uint_from(5u, 2u);\n     }\n \n     #[test]\n@@ -103,6 +279,13 @@ mod tests {\n         log(debug, (a, b));\n     }\n \n+    #[test]\n+    fn gen_weighted_bool() {\n+        let r = rand::rng();\n+        assert r.gen_weighted_bool(0u) == true;\n+        assert r.gen_weighted_bool(1u) == true;\n+    }\n+\n     #[test]\n     fn gen_str() {\n         let r = rand::rng();\n@@ -121,6 +304,60 @@ mod tests {\n         assert r.gen_bytes(10u).len() == 10u;\n         assert r.gen_bytes(16u).len() == 16u;\n     }\n+\n+    #[test]\n+    fn choose() {\n+        let r = rand::rng();\n+        assert r.choose([1, 1, 1]) == 1;\n+    }\n+\n+    #[test]\n+    fn choose_option() {\n+        let r = rand::rng();\n+        assert r.choose_option([]) == none::<int>;\n+        assert r.choose_option([1, 1, 1]) == some(1);\n+    }\n+\n+    #[test]\n+    fn choose_weighted() {\n+        let r = rand::rng();\n+        assert r.choose_weighted([{weight: 1u, item: 42}]) == 42;\n+        assert r.choose_weighted([\n+            {weight: 0u, item: 42},\n+            {weight: 1u, item: 43}\n+        ]) == 43;\n+    }\n+\n+    #[test]\n+    fn choose_weighted_option() {\n+        let r = rand::rng();\n+        assert r.choose_weighted_option([{weight: 1u, item: 42}]) == some(42);\n+        assert r.choose_weighted_option([\n+            {weight: 0u, item: 42},\n+            {weight: 1u, item: 43}\n+        ]) == some(43);\n+        assert r.choose_weighted_option([]) == none::<int>;\n+    }\n+\n+    #[test]\n+    fn weighted_vec() {\n+        let r = rand::rng();\n+        let empty: [int] = [];\n+        assert r.weighted_vec([]) == empty;\n+        assert r.weighted_vec([\n+            {weight: 0u, item: 3u},\n+            {weight: 1u, item: 2u},\n+            {weight: 2u, item: 1u}\n+        ]) == [2u, 1u, 1u];\n+    }\n+\n+    #[test]\n+    fn shuffle() {\n+        let r = rand::rng();\n+        let empty: [int] = [];\n+        assert r.shuffle([]) == empty;\n+        assert r.shuffle([1, 1, 1]) == [1, 1, 1];\n+    }\n }\n \n "}]}