{"sha": "ee2bfae011e368e224d6d4f4c9fad13606ee99da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMmJmYWUwMTFlMzY4ZTIyNGQ2ZDRmNGM5ZmFkMTM2MDZlZTk5ZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-16T13:10:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-16T13:10:59Z"}, "message": "auto merge of #20972 : FlaPer87/rust/oibit-send-and-friends, r=nikomatsakis\n\nThis PR adds rules for negative implementations. It follows pretty much what the [RFC](https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md) says with 1 main difference:\r\n\r\nInstead of positive implementations override negative implementations, this have been implemented in a way that a negative implementation of `Trait` for `T` will overlap with a positive implementation, causing a coherence error.\r\n\r\n@nikomatsakis r?\r\n\r\ncc #13231\r\n\r\n[breaking-change]", "tree": {"sha": "189eebe03c5b7fba71d429db8e0561a45d1317cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/189eebe03c5b7fba71d429db8e0561a45d1317cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee2bfae011e368e224d6d4f4c9fad13606ee99da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee2bfae011e368e224d6d4f4c9fad13606ee99da", "html_url": "https://github.com/rust-lang/rust/commit/ee2bfae011e368e224d6d4f4c9fad13606ee99da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee2bfae011e368e224d6d4f4c9fad13606ee99da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3d71be65cccfddd232e733c11129ed53961f980", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3d71be65cccfddd232e733c11129ed53961f980", "html_url": "https://github.com/rust-lang/rust/commit/f3d71be65cccfddd232e733c11129ed53961f980"}, {"sha": "cb852239033baf4f44ab448f27127d6ab906c7c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb852239033baf4f44ab448f27127d6ab906c7c0", "html_url": "https://github.com/rust-lang/rust/commit/cb852239033baf4f44ab448f27127d6ab906c7c0"}], "stats": {"total": 781, "additions": 676, "deletions": 105}, "files": [{"sha": "6c85330603514a0ea109774787be9f18397019b0", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -68,6 +68,7 @@\n #![allow(unknown_features)]\n #![feature(lang_items, unsafe_destructor)]\n #![feature(box_syntax)]\n+#![feature(optin_builtin_traits)]\n #![allow(unknown_features)] #![feature(int_uint)]\n \n #[macro_use]"}, {"sha": "0e18cdda8dd894cb747c835240e9ef8c66f250a9", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -174,6 +174,7 @@ struct RcBox<T> {\n /// See the [module level documentation](../index.html) for more details.\n #[unsafe_no_drop_flag]\n #[stable]\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct Rc<T> {\n     // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n     // type via Deref\n@@ -182,6 +183,24 @@ pub struct Rc<T> {\n     _noshare: marker::NoSync\n }\n \n+/// An immutable reference-counted pointer type.\n+///\n+/// See the [module level documentation](../index.html) for more details.\n+#[unsafe_no_drop_flag]\n+#[stable]\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub struct Rc<T> {\n+    // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n+    // type via Deref\n+    _ptr: NonZero<*mut RcBox<T>>,\n+}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl<T> !marker::Send for Rc<T> {}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl<T> !marker::Sync for Rc<T> {}\n+\n impl<T> Rc<T> {\n     /// Constructs a new `Rc<T>`.\n     ///\n@@ -193,6 +212,7 @@ impl<T> Rc<T> {\n     /// let five = Rc::new(5i);\n     /// ```\n     #[stable]\n+    #[cfg(stage0)] // NOTE remove after next snapshot\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n@@ -210,6 +230,32 @@ impl<T> Rc<T> {\n         }\n     }\n \n+    /// Constructs a new `Rc<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    /// ```\n+    #[stable]\n+    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+    pub fn new(value: T) -> Rc<T> {\n+        unsafe {\n+            Rc {\n+                // there is an implicit weak pointer owned by all the strong pointers, which\n+                // ensures that the weak destructor never frees the allocation while the strong\n+                // destructor is running, even if the weak pointer is stored inside the strong one.\n+                _ptr: NonZero::new(transmute(box RcBox {\n+                    value: value,\n+                    strong: Cell::new(1),\n+                    weak: Cell::new(1)\n+                })),\n+            }\n+        }\n+    }\n+\n     /// Downgrades the `Rc<T>` to a `Weak<T>` reference.\n     ///\n     /// # Examples\n@@ -221,6 +267,7 @@ impl<T> Rc<T> {\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n+    #[cfg(stage0)] // NOTE remove after next snapshot\n     #[unstable = \"Weak pointers may not belong in this module\"]\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n@@ -230,6 +277,24 @@ impl<T> Rc<T> {\n             _noshare: marker::NoSync\n         }\n     }\n+\n+    /// Downgrades the `Rc<T>` to a `Weak<T>` reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    /// ```\n+    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+    #[unstable = \"Weak pointers may not belong in this module\"]\n+    pub fn downgrade(&self) -> Weak<T> {\n+        self.inc_weak();\n+        Weak { _ptr: self._ptr }\n+    }\n }\n \n /// Get the number of weak references to this value.\n@@ -432,10 +497,31 @@ impl<T> Clone for Rc<T> {\n     /// five.clone();\n     /// ```\n     #[inline]\n+    #[cfg(stage0)] // NOTE remove after next snapshot\n     fn clone(&self) -> Rc<T> {\n         self.inc_strong();\n         Rc { _ptr: self._ptr, _nosend: marker::NoSend, _noshare: marker::NoSync }\n     }\n+\n+    /// Makes a clone of the `Rc<T>`.\n+    ///\n+    /// This increases the strong reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five.clone();\n+    /// ```\n+    #[inline]\n+    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+    fn clone(&self) -> Rc<T> {\n+        self.inc_strong();\n+        Rc { _ptr: self._ptr }\n+    }\n }\n \n #[stable]\n@@ -636,6 +722,7 @@ impl<T: fmt::String> fmt::String for Rc<T> {\n /// See the [module level documentation](../index.html) for more.\n #[unsafe_no_drop_flag]\n #[unstable = \"Weak pointers may not belong in this module.\"]\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct Weak<T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -644,6 +731,29 @@ pub struct Weak<T> {\n     _noshare: marker::NoSync\n }\n \n+/// A weak version of `Rc<T>`.\n+///\n+/// Weak references do not count when determining if the inner value should be dropped.\n+///\n+/// See the [module level documentation](../index.html) for more.\n+#[unsafe_no_drop_flag]\n+#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub struct Weak<T> {\n+    // FIXME #12808: strange names to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _ptr: NonZero<*mut RcBox<T>>,\n+}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+#[allow(unstable)]\n+impl<T> !marker::Send for Weak<T> {}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+#[allow(unstable)]\n+impl<T> !marker::Sync for Weak<T> {}\n+\n+\n #[unstable = \"Weak pointers may not belong in this module.\"]\n impl<T> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n@@ -663,6 +773,7 @@ impl<T> Weak<T> {\n     ///\n     /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n     /// ```\n+    #[cfg(stage0)] // NOTE remove after next snapshot\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n         if self.strong() == 0 {\n             None\n@@ -671,6 +782,33 @@ impl<T> Weak<T> {\n             Some(Rc { _ptr: self._ptr, _nosend: marker::NoSend, _noshare: marker::NoSync })\n         }\n     }\n+\n+    /// Upgrades a weak reference to a strong reference.\n+    ///\n+    /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n+    ///\n+    /// Returns `None` if there were no strong references and the data was destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    ///\n+    /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n+    /// ```\n+    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+    pub fn upgrade(&self) -> Option<Rc<T>> {\n+        if self.strong() == 0 {\n+            None\n+        } else {\n+            self.inc_strong();\n+            Some(Rc { _ptr: self._ptr })\n+        }\n+    }\n }\n \n #[unsafe_destructor]\n@@ -733,10 +871,31 @@ impl<T> Clone for Weak<T> {\n     /// weak_five.clone();\n     /// ```\n     #[inline]\n+    #[cfg(stage0)] // NOTE remove after next snapshot\n     fn clone(&self) -> Weak<T> {\n         self.inc_weak();\n         Weak { _ptr: self._ptr, _nosend: marker::NoSend, _noshare: marker::NoSync }\n     }\n+\n+    /// Makes a clone of the `Weak<T>`.\n+    ///\n+    /// This increases the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let weak_five = Rc::new(5i).downgrade();\n+    ///\n+    /// weak_five.clone();\n+    /// ```\n+    #[inline]\n+    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+    fn clone(&self) -> Weak<T> {\n+        self.inc_weak();\n+        Weak { _ptr: self._ptr }\n+    }\n }\n \n #[unstable = \"Show is experimental.\"]"}, {"sha": "ec4007c4c6dd425b891f26a1fe7c542e06e2e7b2", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -509,12 +509,13 @@ impl<'b, T> DerefMut for RefMut<'b, T> {\n ///\n /// ```rust\n /// use std::cell::UnsafeCell;\n-/// use std::marker;\n+/// use std::marker::Sync;\n ///\n /// struct NotThreadSafe<T> {\n ///     value: UnsafeCell<T>,\n-///     marker: marker::NoSync\n /// }\n+///\n+/// unsafe impl<T> Sync for NotThreadSafe<T> {}\n /// ```\n ///\n /// **NOTE:** `UnsafeCell<T>` fields are public to allow static initializers. It"}, {"sha": "715a79abe854056aeeb8c200d901c6a97761f375", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -286,6 +286,7 @@ pub struct InvariantLifetime<'a>;\n #[unstable = \"likely to change with new variance strategy\"]\n #[lang=\"no_send_bound\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct NoSend;\n \n /// A type which is considered \"not POD\", meaning that it is not\n@@ -303,6 +304,7 @@ pub struct NoCopy;\n #[unstable = \"likely to change with new variance strategy\"]\n #[lang=\"no_sync_bound\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct NoSync;\n \n /// A type which is considered managed by the GC. This is typically"}, {"sha": "e34fb37e1c5551b499270a49387b193550fc07b7", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -262,6 +262,15 @@ pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n     }\n }\n \n+pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                               def: ast::DefId)\n+                               -> Option<ast::ImplPolarity>\n+{\n+    let cstore = &tcx.sess.cstore;\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_impl_polarity(&*cdata, def.node)\n+}\n+\n // Given a def_id for an impl, return the trait it implements,\n // if there is one.\n pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,"}, {"sha": "6bf1798d246a409e5b36e7d0531380e6e965c54d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -371,6 +371,15 @@ fn parse_unsafety(item_doc: rbml::Doc) -> ast::Unsafety {\n     }\n }\n \n+fn parse_polarity(item_doc: rbml::Doc) -> ast::ImplPolarity {\n+    let polarity_doc = reader::get_doc(item_doc, tag_polarity);\n+    if reader::doc_as_u8(polarity_doc) != 0 {\n+        ast::ImplPolarity::Negative\n+    } else {\n+        ast::ImplPolarity::Positive\n+    }\n+}\n+\n fn parse_associated_type_names(item_doc: rbml::Doc) -> Vec<ast::Name> {\n     let names_doc = reader::get_doc(item_doc, tag_associated_type_names);\n     let mut names = Vec::new();\n@@ -436,6 +445,20 @@ pub fn get_repr_attrs(cdata: Cmd, id: ast::NodeId) -> Vec<attr::ReprAttr> {\n     }\n }\n \n+pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n+                               id: ast::NodeId)\n+                               -> Option<ast::ImplPolarity>\n+{\n+    let item_doc = lookup_item(id, cdata.data());\n+    let fam = item_family(item_doc);\n+    match fam {\n+        Family::Impl => {\n+            Some(parse_polarity(item_doc))\n+        }\n+        _ => None\n+    }\n+}\n+\n pub fn get_impl_trait<'tcx>(cdata: Cmd,\n                             id: ast::NodeId,\n                             tcx: &ty::ctxt<'tcx>)"}, {"sha": "62649653a6972374b5be5bfb901882e28f52d3eb", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -611,6 +611,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(None);\n         }\n \n+\n         // If there are *NO* candidates, that there are no impls --\n         // that we know of, anyway. Note that in the case where there\n         // are unbound type variables within the obligation, it might\n@@ -626,6 +627,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // Just one candidate left.\n         let candidate = candidates.pop().unwrap();\n+\n+        match candidate {\n+            ImplCandidate(def_id) => {\n+                match ty::trait_impl_polarity(self.tcx(), def_id) {\n+                    Some(ast::ImplPolarity::Negative) => return Err(Unimplemented),\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n         Ok(Some(candidate))\n     }\n \n@@ -714,18 +726,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 debug!(\"obligation self ty is {}\",\n                        obligation.predicate.0.self_ty().repr(self.tcx()));\n \n-                try!(self.assemble_candidates_from_impls(obligation, &mut candidates.vec));\n+                try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n \n                 try!(self.assemble_builtin_bound_candidates(ty::BoundCopy,\n                                                             stack,\n                                                             &mut candidates));\n             }\n             Some(bound @ ty::BoundSend) |\n             Some(bound @ ty::BoundSync) => {\n-                try!(self.assemble_candidates_from_impls(obligation, &mut candidates.vec));\n+                try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n \n                 // No explicit impls were declared for this type, consider the fallback rules.\n-                if candidates.vec.is_empty() {\n+                if candidates.vec.is_empty() && !candidates.ambiguous {\n                     try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n                 }\n             }\n@@ -741,7 +753,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // (And unboxed candidates only apply to the Fn/FnMut/etc traits.)\n                 try!(self.assemble_unboxed_closure_candidates(obligation, &mut candidates));\n                 try!(self.assemble_fn_pointer_candidates(obligation, &mut candidates));\n-                try!(self.assemble_candidates_from_impls(obligation, &mut candidates.vec));\n+                try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n                 self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n             }\n         }\n@@ -1013,9 +1025,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Search for impls that might apply to `obligation`.\n     fn assemble_candidates_from_impls(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n-                                      candidate_vec: &mut Vec<SelectionCandidate<'tcx>>)\n+                                      candidates: &mut SelectionCandidateSet<'tcx>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        debug!(\"assemble_candidates_from_impls(self_ty={})\", self_ty.repr(self.tcx()));\n+\n         let all_impls = self.all_impls(obligation.predicate.def_id());\n         for &impl_def_id in all_impls.iter() {\n             self.infcx.probe(|snapshot| {\n@@ -1024,7 +1039,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 match self.match_impl(impl_def_id, obligation, snapshot,\n                                       &skol_map, skol_obligation_trait_pred.trait_ref.clone()) {\n                     Ok(_) => {\n-                        candidate_vec.push(ImplCandidate(impl_def_id));\n+                        candidates.vec.push(ImplCandidate(impl_def_id));\n                     }\n                     Err(()) => { }\n                 }\n@@ -2214,8 +2229,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// Returns set of all impls for a given trait.\n     fn all_impls(&self, trait_def_id: ast::DefId) -> Vec<ast::DefId> {\n-        ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n-                                                            trait_def_id);\n+        ty::populate_implementations_for_trait_if_necessary(self.tcx(), trait_def_id);\n+\n         match self.tcx().trait_impls.borrow().get(&trait_def_id) {\n             None => Vec::new(),\n             Some(impls) => impls.borrow().clone()"}, {"sha": "c72fbc745651a5049b8bc096d9e77cc8126a5074", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -1891,7 +1891,7 @@ pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::R\n /// normal trait predicate (`T : TraitRef<...>`) and one of these\n /// predicates. Form #2 is a broader form in that it also permits\n /// equality between arbitrary types. Processing an instance of Form\n-/// \\#2 eventually yields one of these `ProjectionPredicate`\n+/// #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n #[derive(Clone, PartialEq, Eq, Hash, Show)]\n pub struct ProjectionPredicate<'tcx> {\n@@ -5035,6 +5035,23 @@ pub fn trait_items<'tcx>(cx: &ctxt<'tcx>, trait_did: ast::DefId)\n     }\n }\n \n+pub fn trait_impl_polarity<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n+                            -> Option<ast::ImplPolarity> {\n+     if id.krate == ast::LOCAL_CRATE {\n+         match cx.map.find(id.node) {\n+             Some(ast_map::NodeItem(item)) => {\n+                 match item.node {\n+                     ast::ItemImpl(_, polarity, _, _, _, _) => Some(polarity),\n+                     _ => None\n+                 }\n+             }\n+             _ => None\n+         }\n+     } else {\n+         csearch::get_impl_polarity(cx, id)\n+     }\n+}\n+\n pub fn impl_or_trait_item<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                 -> ImplOrTraitItem<'tcx> {\n     lookup_locally_or_in_crate_store(\"impl_or_trait_items\",\n@@ -5984,13 +6001,15 @@ pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n pub fn record_trait_implementation(tcx: &ctxt,\n                                    trait_def_id: DefId,\n                                    impl_def_id: DefId) {\n+\n     match tcx.trait_impls.borrow().get(&trait_def_id) {\n         Some(impls_for_trait) => {\n             impls_for_trait.borrow_mut().push(impl_def_id);\n             return;\n         }\n         None => {}\n     }\n+\n     tcx.trait_impls.borrow_mut().insert(trait_def_id, Rc::new(RefCell::new(vec!(impl_def_id))));\n }\n "}, {"sha": "7e38321049ed7a8c9acf85a71287224d19cff672", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -1597,7 +1597,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         debug!(\"register_predicate({})\",\n                obligation.repr(self.tcx()));\n-\n         self.inh.fulfillment_cx\n             .borrow_mut()\n             .register_predicate_obligation(self.infcx(), obligation);"}, {"sha": "e6390212c6002ca09d726ac418be058dfef8c704", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -56,9 +56,38 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                ty::item_path_str(ccx.tcx, local_def(item.id)));\n \n         match item.node {\n-            ast::ItemImpl(..) => {\n+            /// Right now we check that every default trait implementation\n+            /// has an implementation of itself. Basically, a case like:\n+            ///\n+            /// `impl Trait for T {}`\n+            ///\n+            /// has a requirement of `T: Trait` which was required for default\n+            /// method implementations. Although this could be improved now that\n+            /// there's a better infrastructure in place for this, it's being left\n+            /// for a follow-up work.\n+            ///\n+            /// Since there's such a requirement, we need to check *just* positive\n+            /// implementations, otherwise things like:\n+            ///\n+            /// impl !Send for T {}\n+            ///\n+            /// won't be allowed unless there's an *explicit* implementation of `Send`\n+            /// for `T`\n+            ast::ItemImpl(_, ast::ImplPolarity::Positive, _, _, _, _) => {\n                 self.check_impl(item);\n             }\n+            ast::ItemImpl(_, ast::ImplPolarity::Negative, _, Some(ref tref), _, _) => {\n+                let trait_ref = ty::node_id_to_trait_ref(ccx.tcx, tref.ref_id);\n+                match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n+                    Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n+                    Some(_) | None => {\n+                        ccx.tcx.sess.span_err(\n+                            item.span,\n+                            format!(\"negative impls are currently \\\n+                                     allowed just for `Send` and `Sync`\").as_slice())\n+                    }\n+                }\n+            }\n             ast::ItemFn(..) => {\n                 self.check_item_type(item);\n             }"}, {"sha": "ce7ba9ac11e6576c04921bafb3575f3fce7d84d6", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -38,36 +38,34 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         // check_for_overlapping_impls_of_trait() check, since that\n         // check can populate this table further with impls from other\n         // crates.\n-        let trait_def_ids: Vec<ast::DefId> =\n-            self.tcx.trait_impls.borrow().keys().map(|&d| d).collect();\n-\n-        for trait_def_id in trait_def_ids.iter() {\n-            self.check_for_overlapping_impls_of_trait(*trait_def_id);\n+        let trait_def_ids: Vec<(ast::DefId, Vec<ast::DefId>)> =\n+            self.tcx.trait_impls.borrow().iter().map(|(&k, v)| {\n+                // FIXME -- it seems like this method actually pushes\n+                // duplicate impls onto the list\n+                ty::populate_implementations_for_trait_if_necessary(self.tcx, k);\n+                (k, v.borrow().clone())\n+            }).collect();\n+\n+        for &(trait_def_id, ref impls) in trait_def_ids.iter() {\n+            self.check_for_overlapping_impls_of_trait(trait_def_id, impls);\n         }\n     }\n \n     fn check_for_overlapping_impls_of_trait(&self,\n-                                            trait_def_id: ast::DefId)\n+                                            trait_def_id: ast::DefId,\n+                                            trait_impls: &Vec<ast::DefId>)\n     {\n         debug!(\"check_for_overlapping_impls_of_trait(trait_def_id={})\",\n                trait_def_id.repr(self.tcx));\n \n-        // FIXME -- it seems like this method actually pushes\n-        // duplicate impls onto the list\n-        ty::populate_implementations_for_trait_if_necessary(self.tcx,\n-                                                            trait_def_id);\n-\n-        let mut impls = Vec::new();\n-        self.push_impls_of_trait(trait_def_id, &mut impls);\n-\n-        for (i, &impl1_def_id) in impls.iter().enumerate() {\n+        for (i, &impl1_def_id) in trait_impls.iter().enumerate() {\n             if impl1_def_id.krate != ast::LOCAL_CRATE {\n                 // we don't need to check impls if both are external;\n                 // that's the other crate's job.\n                 continue;\n             }\n \n-            for &impl2_def_id in impls.slice_from(i+1).iter() {\n+            for &impl2_def_id in trait_impls.slice_from(i+1).iter() {\n                 self.check_if_impls_overlap(trait_def_id,\n                                             impl1_def_id,\n                                             impl2_def_id);\n@@ -108,15 +106,6 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         }\n     }\n \n-    fn push_impls_of_trait(&self,\n-                           trait_def_id: ast::DefId,\n-                           out: &mut Vec<ast::DefId>) {\n-        match self.tcx.trait_impls.borrow().get(&trait_def_id) {\n-            Some(impls) => { out.push_all(impls.borrow().as_slice()); }\n-            None => { /* no impls */ }\n-        }\n-    }\n-\n     fn span_of_impl(&self, impl_did: ast::DefId) -> Span {\n         assert_eq!(impl_did.krate, ast::LOCAL_CRATE);\n         self.tcx.map.span(impl_did.node)"}, {"sha": "e30d0a29938aa91090365b87c7cc8fd1c5bbd2c1", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -30,7 +30,7 @@ struct UnsafetyChecker<'cx, 'tcx:'cx> {\n impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v ast::Item) {\n         match item.node {\n-            ast::ItemImpl(unsafety, _, _, _, _, _) => {\n+            ast::ItemImpl(unsafety, polarity, _, _, _, _) => {\n                 match ty::impl_trait_ref(self.tcx, ast_util::local_def(item.id)) {\n                     None => {\n                         // Inherent impl.\n@@ -46,23 +46,34 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n \n                     Some(trait_ref) => {\n                         let trait_def = ty::lookup_trait_def(self.tcx, trait_ref.def_id);\n-                        match (trait_def.unsafety, unsafety) {\n-                            (ast::Unsafety::Normal, ast::Unsafety::Unsafe) => {\n+                        match (trait_def.unsafety, unsafety, polarity) {\n+                            (ast::Unsafety::Unsafe,\n+                             ast::Unsafety::Unsafe, ast::ImplPolarity::Negative) => {\n+                                self.tcx.sess.span_err(\n+                                    item.span,\n+                                    format!(\"negative implementations are not unsafe\").as_slice());\n+                            }\n+\n+                            (ast::Unsafety::Normal, ast::Unsafety::Unsafe, _) => {\n                                 self.tcx.sess.span_err(\n                                     item.span,\n                                     format!(\"implementing the trait `{}` is not unsafe\",\n                                             trait_ref.user_string(self.tcx)).as_slice());\n                             }\n \n-                            (ast::Unsafety::Unsafe, ast::Unsafety::Normal) => {\n+                            (ast::Unsafety::Unsafe,\n+                             ast::Unsafety::Normal, ast::ImplPolarity::Positive) => {\n                                 self.tcx.sess.span_err(\n                                     item.span,\n                                     format!(\"the trait `{}` requires an `unsafe impl` declaration\",\n                                             trait_ref.user_string(self.tcx)).as_slice());\n                             }\n \n-                            (ast::Unsafety::Unsafe, ast::Unsafety::Unsafe) |\n-                            (ast::Unsafety::Normal, ast::Unsafety::Normal) => {\n+                            (ast::Unsafety::Unsafe,\n+                             ast::Unsafety::Normal, ast::ImplPolarity::Negative) |\n+                            (ast::Unsafety::Unsafe,\n+                             ast::Unsafety::Unsafe, ast::ImplPolarity::Positive) |\n+                            (ast::Unsafety::Normal, ast::Unsafety::Normal, _) => {\n                                 /* OK */\n                             }\n                         }"}, {"sha": "182344452a484580154d250f765c6a9e50fc19c0", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -110,6 +110,7 @@\n #![feature(slicing_syntax, unboxed_closures)]\n #![feature(box_syntax)]\n #![feature(old_impl_check)]\n+#![feature(optin_builtin_traits)]\n #![allow(unknown_features)] #![feature(int_uint)]\n \n // Don't link to std. We are std."}, {"sha": "17e690e9540925e323a6b52b0d34d99e197e2f96", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -14,6 +14,7 @@ use thread::Thread;\n use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n use sync::Arc;\n use marker::{Sync, Send};\n+#[cfg(stage0)] // NOTE remove use after next snapshot\n use marker::{NoSend, NoSync};\n use mem;\n use clone::Clone;\n@@ -31,12 +32,25 @@ pub struct SignalToken {\n     inner: Arc<Inner>,\n }\n \n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct WaitToken {\n     inner: Arc<Inner>,\n     no_send: NoSend,\n     no_sync: NoSync,\n }\n \n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub struct WaitToken {\n+    inner: Arc<Inner>,\n+}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl !Send for WaitToken {}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl !Sync for WaitToken {}\n+\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub fn tokens() -> (WaitToken, SignalToken) {\n     let inner = Arc::new(Inner {\n         thread: Thread::current(),\n@@ -53,6 +67,21 @@ pub fn tokens() -> (WaitToken, SignalToken) {\n     (wait_token, signal_token)\n }\n \n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub fn tokens() -> (WaitToken, SignalToken) {\n+    let inner = Arc::new(Inner {\n+        thread: Thread::current(),\n+        woken: ATOMIC_BOOL_INIT,\n+    });\n+    let wait_token = WaitToken {\n+        inner: inner.clone(),\n+    };\n+    let signal_token = SignalToken {\n+        inner: inner\n+    };\n+    (wait_token, signal_token)\n+}\n+\n impl SignalToken {\n     pub fn signal(&self) -> bool {\n         let wake = !self.inner.woken.compare_and_swap(false, true, Ordering::SeqCst);"}, {"sha": "0ba19b706176b8f0beb25e87d4f63c8a244bc851", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -370,12 +370,24 @@ unsafe impl<T:Send> Send for Sender<T> { }\n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n #[stable]\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct SyncSender<T> {\n     inner: Arc<RacyCell<sync::Packet<T>>>,\n     // can't share in an arc\n     _marker: marker::NoSync,\n }\n \n+/// The sending-half of Rust's synchronous channel type. This half can only be\n+/// owned by one task, but it can be cloned to send to other tasks.\n+#[stable]\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub struct SyncSender<T> {\n+    inner: Arc<RacyCell<sync::Packet<T>>>,\n+}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl<T> !marker::Sync for SyncSender<T> {}\n+\n /// An error returned from the `send` function on channels.\n ///\n /// A `send` operation can only fail if the receiving end of a channel is\n@@ -677,10 +689,16 @@ impl<T: Send> Drop for Sender<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T: Send> SyncSender<T> {\n+    #[cfg(stage0)] // NOTE remove impl after next snapshot\n     fn new(inner: Arc<RacyCell<sync::Packet<T>>>) -> SyncSender<T> {\n         SyncSender { inner: inner, _marker: marker::NoSync }\n     }\n \n+    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+    fn new(inner: Arc<RacyCell<sync::Packet<T>>>) -> SyncSender<T> {\n+        SyncSender { inner: inner }\n+    }\n+\n     /// Sends a value on this synchronous channel.\n     ///\n     /// This function will *block* until space in the internal buffer becomes"}, {"sha": "62a7b823ec8acd5e9df8af58cd441a084c1699ac", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -66,13 +66,26 @@ use sync::mpsc::blocking::{self, SignalToken};\n \n /// The \"receiver set\" of the select interface. This structure is used to manage\n /// a set of receivers which are being selected over.\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct Select {\n     head: *mut Handle<'static, ()>,\n     tail: *mut Handle<'static, ()>,\n     next_id: Cell<uint>,\n     marker1: marker::NoSend,\n }\n \n+/// The \"receiver set\" of the select interface. This structure is used to manage\n+/// a set of receivers which are being selected over.\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub struct Select {\n+    head: *mut Handle<'static, ()>,\n+    tail: *mut Handle<'static, ()>,\n+    next_id: Cell<uint>,\n+}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl !marker::Send for Select {}\n+\n /// A handle to a receiver which is currently a member of a `Select` set of\n /// receivers.  This handle is used to keep the receiver in the set as well as\n /// interact with the underlying receiver.\n@@ -113,6 +126,7 @@ impl Select {\n     ///\n     /// Usage of this struct directly can sometimes be burdensome, and usage is\n     /// rather much easier through the `select!` macro.\n+    #[cfg(stage0)] // NOTE remove impl after next snapshot\n     pub fn new() -> Select {\n         Select {\n             marker1: marker::NoSend,\n@@ -122,6 +136,20 @@ impl Select {\n         }\n     }\n \n+    /// Creates a new selection structure. This set is initially empty and\n+    /// `wait` will panic!() if called.\n+    ///\n+    /// Usage of this struct directly can sometimes be burdensome, and usage is\n+    /// rather much easier through the `select!` macro.\n+    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+    pub fn new() -> Select {\n+        Select {\n+            head: 0 as *mut Handle<'static, ()>,\n+            tail: 0 as *mut Handle<'static, ()>,\n+            next_id: Cell::new(1),\n+        }\n+    }\n+\n     /// Creates a new handle into this receiver set for a new receiver. Note\n     /// that this does *not* add the receiver to the receiver set, for that you\n     /// must call the `add` method on the handle itself."}, {"sha": "73d5332d16fe4f02dd4ea48a947b9121bf8d1ee4", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -160,6 +160,7 @@ unsafe impl Sync for StaticMutex {}\n /// Deref and DerefMut implementations\n #[must_use]\n #[stable]\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct MutexGuard<'a, T: 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n@@ -169,6 +170,25 @@ pub struct MutexGuard<'a, T: 'a> {\n     __marker: marker::NoSend,\n }\n \n+/// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n+/// dropped (falls out of scope), the lock will be unlocked.\n+///\n+/// The data protected by the mutex can be access through this guard via its\n+/// Deref and DerefMut implementations\n+#[must_use]\n+#[stable]\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub struct MutexGuard<'a, T: 'a> {\n+    // funny underscores due to how Deref/DerefMut currently work (they\n+    // disregard field privacy).\n+    __lock: &'a StaticMutex,\n+    __data: &'a UnsafeCell<T>,\n+    __poison: poison::Guard,\n+}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl<'a, T> !marker::Send for MutexGuard<'a, T> {}\n+\n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n #[unstable = \"may be merged with Mutex in the future\"]\n@@ -279,6 +299,7 @@ impl StaticMutex {\n }\n \n impl<'mutex, T> MutexGuard<'mutex, T> {\n+    #[cfg(stage0)] // NOTE remove afte next snapshot\n     fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n            -> LockResult<MutexGuard<'mutex, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n@@ -290,6 +311,18 @@ impl<'mutex, T> MutexGuard<'mutex, T> {\n             }\n         })\n     }\n+\n+    #[cfg(not(stage0))] // NOTE remove cfg afte next snapshot\n+    fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n+           -> LockResult<MutexGuard<'mutex, T>> {\n+        poison::map_result(lock.poison.borrow(), |guard| {\n+            MutexGuard {\n+                __lock: lock,\n+                __data: data,\n+                __poison: guard,\n+            }\n+        })\n+    }\n }\n \n #[stable]"}, {"sha": "237f6d08a9541885314e25706655aebf614f760b", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -110,23 +110,52 @@ pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n /// dropped.\n #[must_use]\n #[stable]\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct RwLockReadGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n     __marker: marker::NoSend,\n }\n \n+/// RAII structure used to release the shared read access of a lock when\n+/// dropped.\n+#[must_use]\n+#[stable]\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub struct RwLockReadGuard<'a, T: 'a> {\n+    __lock: &'a StaticRwLock,\n+    __data: &'a UnsafeCell<T>,\n+}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl<'a, T> !marker::Send for RwLockReadGuard<'a, T> {}\n+\n /// RAII structure used to release the exclusive write access of a lock when\n /// dropped.\n #[must_use]\n #[stable]\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct RwLockWriteGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n     __poison: poison::Guard,\n     __marker: marker::NoSend,\n }\n \n+/// RAII structure used to release the exclusive write access of a lock when\n+/// dropped.\n+#[must_use]\n+#[stable]\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub struct RwLockWriteGuard<'a, T: 'a> {\n+    __lock: &'a StaticRwLock,\n+    __data: &'a UnsafeCell<T>,\n+    __poison: poison::Guard,\n+}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl<'a, T> !marker::Send for RwLockWriteGuard<'a, T> {}\n+\n impl<T: Send + Sync> RwLock<T> {\n     /// Creates a new instance of an RwLock which is unlocked and read to go.\n     #[stable]\n@@ -303,6 +332,7 @@ impl StaticRwLock {\n }\n \n impl<'rwlock, T> RwLockReadGuard<'rwlock, T> {\n+    #[cfg(stage0)] // NOTE remove impl after next snapshot\n     fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockReadGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |_| {\n@@ -313,8 +343,20 @@ impl<'rwlock, T> RwLockReadGuard<'rwlock, T> {\n             }\n         })\n     }\n+\n+    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n+           -> LockResult<RwLockReadGuard<'rwlock, T>> {\n+        poison::map_result(lock.poison.borrow(), |_| {\n+            RwLockReadGuard {\n+                __lock: lock,\n+                __data: data,\n+            }\n+        })\n+    }\n }\n impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n+    #[cfg(stage0)] // NOTE remove impl after next snapshot\n     fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n@@ -326,6 +368,18 @@ impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n             }\n         })\n     }\n+\n+    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n+           -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n+        poison::map_result(lock.poison.borrow(), |guard| {\n+            RwLockWriteGuard {\n+                __lock: lock,\n+                __data: data,\n+                __poison: guard,\n+            }\n+        })\n+    }\n }\n \n #[stable]"}, {"sha": "c9dfb8201a98acb968382bb4d87dfb7b35406436", "filename": "src/test/compile-fail/coherence-conflicting-negative-trait-impl.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+\n+trait MyTrait {}\n+\n+struct TestType<T>;\n+\n+unsafe impl<T: MyTrait> Send for TestType<T> {}\n+//~^ ERROR conflicting implementations for trait `core::marker::Send`\n+//~^^ ERROR conflicting implementations for trait `core::marker::Send`\n+\n+impl<T: MyTrait> !Send for TestType<T> {}\n+//~^ ERROR conflicting implementations for trait `core::marker::Send`\n+\n+unsafe impl<T> Send for TestType<T> {}\n+//~^ ERROR error: conflicting implementations for trait `core::marker::Send`\n+\n+impl !Send for TestType<i32> {}\n+\n+fn main() {}"}, {"sha": "3b335d586f39184c0922de71aa196fac8263e653", "filename": "src/test/compile-fail/coherence-negative-impls-safe.rs", "status": "renamed", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fcoherence-negative-impls-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fcoherence-negative-impls-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-negative-impls-safe.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker;\n+#![feature(optin_builtin_traits)]\n \n-fn foo<P: Sync>(p: P) { }\n+use std::marker::Send;\n \n-fn main()\n-{\n-    foo(marker::NoSync); //~ ERROR the trait `core::marker::Sync` is not implemented\n-}\n+struct TestType;\n+\n+unsafe impl !Send for TestType {}\n+//~^ ERROR negative implementations are not unsafe\n+\n+fn main() {}", "previous_filename": "src/test/compile-fail/marker-no-share.rs"}, {"sha": "f9f965e1ae39dc2a5a6ae78adb18c119f9b98b80", "filename": "src/test/compile-fail/coherence-orphan.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fcoherence-orphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fcoherence-orphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-orphan.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -8,8 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n // aux-build:coherence-orphan-lib.rs\n \n+#![feature(optin_builtin_traits)]\n+\n extern crate \"coherence-orphan-lib\" as lib;\n \n use lib::TheTrait;\n@@ -22,4 +25,7 @@ impl TheTrait<TheType> for isize { } //~ ERROR E0117\n \n impl TheTrait<isize> for TheType { }\n \n+impl !Send for Vec<isize> { } //~ ERROR E0117\n+//~^ ERROR conflicting\n+\n fn main() { }"}, {"sha": "fa8035a79652ea27a1c7f8e67aad9d47562b6bad", "filename": "src/test/compile-fail/issue-17718-static-sync.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-sync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-sync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-sync.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker;\n+#![feature(optin_builtin_traits)]\n \n-struct Foo { marker: marker::NoSync }\n+use std::marker::Sync;\n+\n+struct Foo;\n+impl !Sync for Foo {}\n \n static FOO: usize = 3;\n-static BAR: Foo = Foo { marker: marker::NoSync };\n+static BAR: Foo = Foo;\n //~^ ERROR: the trait `core::marker::Sync` is not implemented\n \n fn main() {}"}, {"sha": "90ecfb6015dcd4a3a672caee67d558c80fabed83", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -35,5 +35,4 @@ struct A {\n fn main() {\n     let a = A {v: box B{v: None} as Box<Foo+Send>};\n     //~^ ERROR the trait `core::marker::Send` is not implemented\n-    //~^^ ERROR the trait `core::marker::Send` is not implemented\n }"}, {"sha": "5bc769f8e117b62e452e9d691fcce54c3e8f577a", "filename": "src/test/compile-fail/kindck-nonsendable-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -19,6 +19,5 @@ fn main() {\n     let x = Rc::new(3us);\n     bar(move|| foo(x));\n     //~^ ERROR `core::marker::Send` is not implemented\n-    //~^^ ERROR `core::marker::Send` is not implemented\n }\n "}, {"sha": "1657d602e24c485de42a3591d5006b92899e49fc", "filename": "src/test/compile-fail/mutable-enum-indirect.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -11,13 +11,18 @@\n // Tests that an `&` pointer to something inherently mutable is itself\n // to be considered mutable.\n \n-use std::marker;\n+#![feature(optin_builtin_traits)]\n \n-enum Foo { A(marker::NoSync) }\n+use std::marker::Sync;\n+\n+struct NoSync;\n+impl !Sync for NoSync {}\n+\n+enum Foo { A(NoSync) }\n \n fn bar<T: Sync>(_: T) {}\n \n fn main() {\n-    let x = Foo::A(marker::NoSync);\n+    let x = Foo::A(NoSync);\n     bar(&x); //~ ERROR the trait `core::marker::Sync` is not implemented\n }"}, {"sha": "52335ab76bda23abd042a9f09bc4e1997d70dd39", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -37,7 +37,6 @@ fn main() {\n \n     Thread::spawn(move|| {\n         //~^ ERROR `core::marker::Send` is not implemented\n-        //~^^ ERROR `core::marker::Send` is not implemented\n         let y = x;\n         println!(\"{:?}\", y);\n     });"}, {"sha": "625d51260c4dcc4375d6704da1a11ce35adacc6b", "filename": "src/test/compile-fail/no_send-enum.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fno_send-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fno_send-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_send-enum.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -8,16 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker;\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::Send;\n+\n+struct NoSend;\n+impl !Send for NoSend {}\n \n enum Foo {\n-    A(marker::NoSend)\n+    A(NoSend)\n }\n \n fn bar<T: Send>(_: T) {}\n \n fn main() {\n-    let x = Foo::A(marker::NoSend);\n+    let x = Foo::A(NoSend);\n     bar(x);\n     //~^ ERROR `core::marker::Send` is not implemented\n }"}, {"sha": "d404988bd9848cb79a2a70fc53c1d4a8a576dc4e", "filename": "src/test/compile-fail/no_send-rc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fno_send-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fno_send-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_send-rc.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -16,5 +16,4 @@ fn main() {\n     let x = Rc::new(5is);\n     bar(x);\n     //~^ ERROR `core::marker::Send` is not implemented\n-    //~^^ ERROR `core::marker::Send` is not implemented\n }"}, {"sha": "7f16db0ba947be19ea11269408e9f2a68458763b", "filename": "src/test/compile-fail/no_send-struct.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fno_send-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fno_send-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_send-struct.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -8,17 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker;\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::Send;\n \n struct Foo {\n     a: isize,\n-    ns: marker::NoSend\n }\n \n+impl !Send for Foo {}\n+\n fn bar<T: Send>(_: T) {}\n \n fn main() {\n-    let x = Foo { a: 5, ns: marker::NoSend };\n+    let x = Foo { a: 5 };\n     bar(x);\n     //~^ ERROR the trait `core::marker::Send` is not implemented\n }"}, {"sha": "9331afdbbb5d7d792a150e4cf128a9c635f182f5", "filename": "src/test/compile-fail/no_share-enum.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fno_share-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fno_share-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_share-enum.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -8,14 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker;\n+#![feature(optin_builtin_traits)]\n \n-enum Foo { A(marker::NoSync) }\n+use std::marker::Sync;\n+\n+struct NoSync;\n+impl !Sync for NoSync {}\n+\n+enum Foo { A(NoSync) }\n \n fn bar<T: Sync>(_: T) {}\n \n fn main() {\n-    let x = Foo::A(marker::NoSync);\n+    let x = Foo::A(NoSync);\n     bar(x);\n     //~^ ERROR the trait `core::marker::Sync` is not implemented\n }"}, {"sha": "4917db602e175f1fc6aabef3102ad0d2de792a7c", "filename": "src/test/compile-fail/no_share-rc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fno_share-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fno_share-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_share-rc.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -17,5 +17,4 @@ fn main() {\n     let x = Rc::new(RefCell::new(5is));\n     bar(x);\n     //~^ ERROR the trait `core::marker::Sync` is not implemented\n-    //~^^ ERROR the trait `core::marker::Sync` is not implemented\n }"}, {"sha": "b5ccceb3b2a7d9ec72bc6fc286af790ff6e9cd8a", "filename": "src/test/compile-fail/no_share-struct.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fno_share-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Fno_share-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_share-struct.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker;\n+#![feature(optin_builtin_traits)]\n \n-struct Foo { a: isize, m: marker::NoSync }\n+use std::marker::Sync;\n+\n+struct Foo { a: isize }\n+impl !Sync for Foo {}\n \n fn bar<T: Sync>(_: T) {}\n \n fn main() {\n-    let x = Foo { a: 5, m: marker::NoSync };\n+    let x = Foo { a: 5 };\n     bar(x);\n     //~^ ERROR the trait `core::marker::Sync` is not implemented\n }"}, {"sha": "dc3385f4bb92f38e7366800fa15f31dc6f1291ca", "filename": "src/test/compile-fail/task-rng-isnt-sendable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -17,5 +17,4 @@ fn test_send<S: Send>() {}\n pub fn main() {\n     test_send::<rand::ThreadRng>();\n     //~^ ERROR `core::marker::Send` is not implemented\n-    //~^^ ERROR `core::marker::Send` is not implemented\n }"}, {"sha": "3ef760053c709fc8b9115b0981b59ea15d4c3ee4", "filename": "src/test/compile-fail/traits-negative-impls.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Ftraits-negative-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Ftraits-negative-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-negative-impls.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The dummy functions are used to avoid adding new cfail files.\n+// What happens is that the compiler attempts to squash duplicates and some\n+// errors are not reported. This way, we make sure that, for each function, different\n+// typeck phases are involved and all errors are reported.\n+\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::Send;\n+\n+struct Outer<T: Send>(T);\n+\n+struct TestType;\n+impl !Send for TestType {}\n+\n+struct Outer2<T>(T);\n+\n+unsafe impl<T: Send> Sync for Outer2<T> {}\n+\n+fn is_send<T: Send>(_: T) {}\n+fn is_sync<T: Sync>(_: T) {}\n+\n+fn dummy() {\n+    Outer(TestType);\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `TestType`\n+\n+    is_send(TestType);\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `TestType`\n+\n+    is_send((8, TestType));\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `TestType`\n+}\n+\n+fn dummy2() {\n+    is_send(Box::new(TestType));\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `TestType`\n+}\n+\n+fn dummy3() {\n+    is_send(Box::new(Outer2(TestType)));\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `TestType`\n+}\n+\n+fn main() {\n+    // This will complain about a missing Send impl because `Sync` is implement *just*\n+    // for T that are `Send`. Look at #20366 and #19950\n+    is_sync(Outer2(TestType));\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `TestType`\n+}"}, {"sha": "9da79b11cf0b7f1229e6bcab83fc2a1c47920fbd", "filename": "src/test/compile-fail/typeck-negative-impls-builtin.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Ftypeck-negative-impls-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Ftypeck-negative-impls-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-negative-impls-builtin.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+\n+struct TestType;\n+\n+trait TestTrait {}\n+\n+impl !TestTrait for TestType {}\n+//~^ ERROR  negative impls are currently allowed just for `Send` and `Sync`\n+\n+fn main() {}"}, {"sha": "38e3b57634838460e9036bc8e989dd54440f717d", "filename": "src/test/compile-fail/typeck-unsafe-always-share.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Ftypeck-unsafe-always-share.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Ftypeck-unsafe-always-share.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-unsafe-always-share.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -10,37 +10,33 @@\n \n // Verify that UnsafeCell is *always* sync regardless if `T` is sync.\n \n-// ignore-tidy-linelength\n+#![feature(optin_builtin_traits)]\n \n use std::cell::UnsafeCell;\n-use std::marker;\n+use std::marker::Sync;\n \n struct MySync<T> {\n     u: UnsafeCell<T>\n }\n \n-struct NoSync {\n-    m: marker::NoSync\n-}\n-\n-fn test<T: Sync>(s: T){\n+struct NoSync;\n+impl !Sync for NoSync {}\n \n-}\n+fn test<T: Sync>(s: T) {}\n \n fn main() {\n     let us = UnsafeCell::new(MySync{u: UnsafeCell::new(0is)});\n     test(us);\n     //~^ ERROR `core::marker::Sync` is not implemented\n \n-    let uns = UnsafeCell::new(NoSync{m: marker::NoSync});\n+    let uns = UnsafeCell::new(NoSync);\n     test(uns);\n     //~^ ERROR `core::marker::Sync` is not implemented\n \n     let ms = MySync{u: uns};\n     test(ms);\n     //~^ ERROR `core::marker::Sync` is not implemented\n \n-    let ns = NoSync{m: marker::NoSync};\n-    test(ns);\n+    test(NoSync);\n     //~^ ERROR `core::marker::Sync` is not implemented\n }"}, {"sha": "322de45daf03e8e17881af8bfed703ad42dd395b", "filename": "src/test/compile-fail/unique-unique-kind.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -19,5 +19,4 @@ fn main() {\n     let i = box Rc::new(100is);\n     f(i);\n     //~^ ERROR `core::marker::Send` is not implemented\n-    //~^^ ERROR `core::marker::Send` is not implemented\n }"}, {"sha": "f51eee379347c2e40c8c088b22c19bd29d598032", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -31,6 +31,5 @@ fn main() {\n   let cat = \"kitty\".to_string();\n   let (tx, _) = channel();\n   //~^ ERROR `core::marker::Send` is not implemented\n-  //~^^ ERROR `core::marker::Send` is not implemented\n   tx.send(foo(42, Rc::new(cat)));\n }"}, {"sha": "7d3a921301e342a97f1279b3d96240ea2483eee0", "filename": "src/test/pretty/trait-polarity.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fpretty%2Ftrait-polarity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Fpretty%2Ftrait-polarity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ftrait-polarity.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -12,12 +12,8 @@\n \n // pp-exact\n \n-trait UnsafeTrait {\n-    fn foo(&self);\n-}\n+struct Test;\n \n-impl !UnsafeTrait for int {\n-    fn foo(&self) { }\n-}\n+impl !Send for Test { }\n \n pub fn main() { }"}, {"sha": "7844ef3faca458ae8869d6f0a364a68a18f9d803", "filename": "src/test/run-pass/coherence-negative-impls-safe.rs", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Frun-pass%2Fcoherence-negative-impls-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Frun-pass%2Fcoherence-negative-impls-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-negative-impls-safe.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker;\n+#![feature(optin_builtin_traits)]\n \n-fn foo<P:Send>(p: P) { }\n+use std::marker::Send;\n \n-fn main()\n-{\n-    foo(marker::NoSend); //~ ERROR the trait `core::marker::Send` is not implemented\n-}\n+struct TestType;\n+\n+impl !Send for TestType {}\n+\n+fn main() {}", "previous_filename": "src/test/compile-fail/marker-no-send.rs"}, {"sha": "3344844d49ff786523bf094b4af715906895e40d", "filename": "src/test/run-pass/syntax-trait-polarity.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Frun-pass%2Fsyntax-trait-polarity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Frun-pass%2Fsyntax-trait-polarity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-trait-polarity.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -18,14 +18,12 @@ impl TestType {}\n \n trait TestTrait {}\n \n-unsafe impl !Send for TestType {}\n-impl !TestTrait for TestType {}\n+impl !Send for TestType {}\n \n struct TestType2<T>;\n \n impl<T> TestType2<T> {}\n \n-unsafe impl<T> !Send for TestType2<T> {}\n-impl<T> !TestTrait for TestType2<T> {}\n+impl<T> !Send for TestType2<T> {}\n \n fn main() {}"}, {"sha": "09c7d077705b501ce7619c37b6fb827d25f565fe", "filename": "src/test/run-pass/traits-negative-impls.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Frun-pass%2Ftraits-negative-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2bfae011e368e224d6d4f4c9fad13606ee99da/src%2Ftest%2Frun-pass%2Ftraits-negative-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-negative-impls.rs?ref=ee2bfae011e368e224d6d4f4c9fad13606ee99da", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::Send;\n+\n+pub struct WaitToken;\n+impl !Send for WaitToken {}\n+\n+pub struct Test<T>(T);\n+unsafe impl<T: 'static> Send for Test<T> {}\n+\n+pub fn spawn<F>(_: F) -> () where F: FnOnce(), F: Send + 'static {}\n+\n+fn main() {\n+    let wt = Test(WaitToken);\n+    spawn(move || {\n+        let x = wt;\n+        println!(\"Hello, World!\");\n+    });\n+}"}]}