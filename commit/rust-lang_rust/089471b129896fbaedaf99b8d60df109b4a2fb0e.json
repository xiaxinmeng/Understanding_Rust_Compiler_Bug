{"sha": "089471b129896fbaedaf99b8d60df109b4a2fb0e", "node_id": "C_kwDOAAsO6NoAKDA4OTQ3MWIxMjk4OTZmYmFlZGFmOTliOGQ2MGRmMTA5YjRhMmZiMGU", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-07-28T09:17:55Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-07-28T09:17:55Z"}, "message": "change the type of `note` field to `Option<String>`", "tree": {"sha": "888926ab85a0878ef7f5178eec7949b952dc3f37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/888926ab85a0878ef7f5178eec7949b952dc3f37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/089471b129896fbaedaf99b8d60df109b4a2fb0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/089471b129896fbaedaf99b8d60df109b4a2fb0e", "html_url": "https://github.com/rust-lang/rust/commit/089471b129896fbaedaf99b8d60df109b4a2fb0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/089471b129896fbaedaf99b8d60df109b4a2fb0e/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ada80a13b97a01176a1660453060e296a72cf1bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ada80a13b97a01176a1660453060e296a72cf1bb", "html_url": "https://github.com/rust-lang/rust/commit/ada80a13b97a01176a1660453060e296a72cf1bb"}], "stats": {"total": 47, "additions": 21, "deletions": 26}, "files": [{"sha": "22a307a15edc095bfd98dcb8e2a50d46890e0312", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/089471b129896fbaedaf99b8d60df109b4a2fb0e/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089471b129896fbaedaf99b8d60df109b4a2fb0e/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=089471b129896fbaedaf99b8d60df109b4a2fb0e", "patch": "@@ -2023,7 +2023,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n \n         match (path.get(0), path.get(1)) {\n@@ -2058,12 +2058,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         &mut self,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = kw::SelfLower;\n         let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n-        if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n+        if let PathResult::Module(..) = result { Some((path, None)) } else { None }\n     }\n \n     /// Suggests a missing `crate::` if that resolves to an correct module.\n@@ -2077,20 +2077,20 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         &mut self,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Crate;\n         let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n                 path,\n-                vec![\n+                Some(\n                     \"`use` statements changed in Rust 2018; read more at \\\n                      <https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-\\\n                      clarity.html>\"\n                         .to_string(),\n-                ],\n+                ),\n             ))\n         } else {\n             None\n@@ -2108,12 +2108,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         &mut self,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Super;\n         let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n-        if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n+        if let PathResult::Module(..) = result { Some((path, None)) } else { None }\n     }\n \n     /// Suggests a missing external crate name if that resolves to an correct module.\n@@ -2130,7 +2130,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         &mut self,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         if path[1].ident.span.rust_2015() {\n             return None;\n         }\n@@ -2151,7 +2151,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 name, path, result\n             );\n             if let PathResult::Module(..) = result {\n-                return Some((path, Vec::new()));\n+                return Some((path, None));\n             }\n         }\n \n@@ -2175,7 +2175,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         import: &'b Import<'b>,\n         module: ModuleOrUniformRoot<'b>,\n         ident: Ident,\n-    ) -> Option<(Option<Suggestion>, Vec<String>)> {\n+    ) -> Option<(Option<Suggestion>, Option<String>)> {\n         let ModuleOrUniformRoot::Module(mut crate_module) = module else {\n             return None;\n         };\n@@ -2287,12 +2287,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 String::from(\"a macro with this name exists at the root of the crate\"),\n                 Applicability::MaybeIncorrect,\n             ));\n-            let note = vec![\n-                \"this could be because a macro annotated with `#[macro_export]` will be exported \\\n-                 at the root of the crate instead of the module where it is defined\"\n-                    .to_string(),\n-            ];\n-            Some((suggestion, note))\n+            Some((suggestion, Some(\"this could be because a macro annotated with `#[macro_export]` will be exported \\\n+            at the root of the crate instead of the module where it is defined\"\n+               .to_string())))\n         } else {\n             None\n         }"}, {"sha": "b89273990d8e58294df0af188e7c5063233941c3", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/089471b129896fbaedaf99b8d60df109b4a2fb0e/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089471b129896fbaedaf99b8d60df109b4a2fb0e/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=089471b129896fbaedaf99b8d60df109b4a2fb0e", "patch": "@@ -336,7 +336,7 @@ impl<'a> Resolver<'a> {\n struct UnresolvedImportError {\n     span: Span,\n     label: Option<String>,\n-    note: Vec<String>,\n+    note: Option<String>,\n     suggestion: Option<Suggestion>,\n }\n \n@@ -427,7 +427,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 let err = UnresolvedImportError {\n                     span: import.span,\n                     label: None,\n-                    note: Vec::new(),\n+                    note: None,\n                     suggestion: None,\n                 };\n                 if path.contains(\"::\") {\n@@ -463,10 +463,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         let mut diag = struct_span_err!(self.r.session, span, E0432, \"{}\", &msg);\n \n-        if let Some((_, UnresolvedImportError { note, .. })) = errors.iter().last() {\n-            for message in note {\n-                diag.note(message);\n-            }\n+        if let Some((_, UnresolvedImportError { note: Some(note), .. })) = errors.iter().last() {\n+            diag.note(note);\n         }\n \n         for (_, err) in errors.into_iter().take(MAX_LABEL_COUNT) {\n@@ -644,7 +642,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         None => UnresolvedImportError {\n                             span,\n                             label: Some(label),\n-                            note: Vec::new(),\n+                            note: None,\n                             suggestion,\n                         },\n                     };\n@@ -686,7 +684,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         return Some(UnresolvedImportError {\n                             span: import.span,\n                             label: Some(String::from(\"cannot glob-import a module into itself\")),\n-                            note: Vec::new(),\n+                            note: None,\n                             suggestion: None,\n                         });\n                     }\n@@ -830,7 +828,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 let (suggestion, note) =\n                     match self.check_for_module_export_macro(import, module, ident) {\n                         Some((suggestion, note)) => (suggestion.or(lev_suggestion), note),\n-                        _ => (lev_suggestion, Vec::new()),\n+                        _ => (lev_suggestion, None),\n                     };\n \n                 let label = match module {"}]}