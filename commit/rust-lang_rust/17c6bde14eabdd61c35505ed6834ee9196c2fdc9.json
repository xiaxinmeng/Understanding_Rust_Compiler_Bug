{"sha": "17c6bde14eabdd61c35505ed6834ee9196c2fdc9", "node_id": "C_kwDOAAsO6NoAKDE3YzZiZGUxNGVhYmRkNjFjMzU1MDVlZDY4MzRlZTkxOTZjMmZkYzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-20T00:40:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-20T00:40:07Z"}, "message": "Auto merge of #98265 - JohnTitor:rollup-wtfqc4g, r=JohnTitor\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #95534 (Add `core::mem::copy` to complement `core::mem::drop`.)\n - #97912 (Stabilize `Path::try_exists()` and improve doc)\n - #98225 (Make debug_triple depend on target json file content rather than file path)\n - #98257 (Fix typos in `IntoFuture` docs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "61e1a627a1e927274b548ce688fd437bab30ec13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61e1a627a1e927274b548ce688fd437bab30ec13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17c6bde14eabdd61c35505ed6834ee9196c2fdc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17c6bde14eabdd61c35505ed6834ee9196c2fdc9", "html_url": "https://github.com/rust-lang/rust/commit/17c6bde14eabdd61c35505ed6834ee9196c2fdc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "611e7b9cea2b982b63de7f6697b2a9079b0bf188", "url": "https://api.github.com/repos/rust-lang/rust/commits/611e7b9cea2b982b63de7f6697b2a9079b0bf188", "html_url": "https://github.com/rust-lang/rust/commit/611e7b9cea2b982b63de7f6697b2a9079b0bf188"}, {"sha": "761f83f683e231e5a75be6b7a064bf9b8b7f0c95", "url": "https://api.github.com/repos/rust-lang/rust/commits/761f83f683e231e5a75be6b7a064bf9b8b7f0c95", "html_url": "https://github.com/rust-lang/rust/commit/761f83f683e231e5a75be6b7a064bf9b8b7f0c95"}], "stats": {"total": 180, "additions": 142, "deletions": 38}, "files": [{"sha": "ba7cc4908b80f6b5cd524ec905ad897db4c0a08c", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=17c6bde14eabdd61c35505ed6834ee9196c2fdc9", "patch": "@@ -1,6 +1,5 @@\n #![feature(let_chains)]\n #![feature(once_cell)]\n-#![feature(path_try_exists)]\n #![feature(rustc_attrs)]\n #![feature(type_alias_impl_trait)]\n "}, {"sha": "fd0c3f36e7299fbd7072f709cf5325e8e5dd57c7", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 99, "deletions": 25, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=17c6bde14eabdd61c35505ed6834ee9196c2fdc9", "patch": "@@ -39,11 +39,13 @@ use crate::json::{Json, ToJson};\n use crate::spec::abi::{lookup as lookup_abi, Abi};\n use crate::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::symbol::{sym, Symbol};\n use serde_json::Value;\n use std::borrow::Cow;\n use std::collections::BTreeMap;\n use std::convert::TryFrom;\n+use std::hash::{Hash, Hasher};\n use std::iter::FromIterator;\n use std::ops::{Deref, DerefMut};\n use std::path::{Path, PathBuf};\n@@ -2183,7 +2185,7 @@ impl Target {\n             TargetTriple::TargetTriple(ref target_triple) => {\n                 load_builtin(target_triple).expect(\"built-in target\")\n             }\n-            TargetTriple::TargetPath(..) => {\n+            TargetTriple::TargetJson { .. } => {\n                 panic!(\"built-in targets doens't support target-paths\")\n             }\n         }\n@@ -2248,11 +2250,9 @@ impl Target {\n \n                 Err(format!(\"Could not find specification for target {:?}\", target_triple))\n             }\n-            TargetTriple::TargetPath(ref target_path) => {\n-                if target_path.is_file() {\n-                    return load_file(&target_path);\n-                }\n-                Err(format!(\"Target path {:?} is not a valid file\", target_path))\n+            TargetTriple::TargetJson { ref contents, .. } => {\n+                let obj = serde_json::from_str(contents).map_err(|e| e.to_string())?;\n+                Target::from_json(obj)\n             }\n         }\n     }\n@@ -2421,10 +2421,77 @@ impl ToJson for Target {\n }\n \n /// Either a target triple string or a path to a JSON file.\n-#[derive(PartialEq, Clone, Debug, Hash, Encodable, Decodable)]\n+#[derive(Clone, Debug)]\n pub enum TargetTriple {\n     TargetTriple(String),\n-    TargetPath(PathBuf),\n+    TargetJson {\n+        /// Warning: This field may only be used by rustdoc. Using it anywhere else will lead to\n+        /// inconsistencies as it is discarded during serialization.\n+        path_for_rustdoc: PathBuf,\n+        triple: String,\n+        contents: String,\n+    },\n+}\n+\n+// Use a manual implementation to ignore the path field\n+impl PartialEq for TargetTriple {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Self::TargetTriple(l0), Self::TargetTriple(r0)) => l0 == r0,\n+            (\n+                Self::TargetJson { path_for_rustdoc: _, triple: l_triple, contents: l_contents },\n+                Self::TargetJson { path_for_rustdoc: _, triple: r_triple, contents: r_contents },\n+            ) => l_triple == r_triple && l_contents == r_contents,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+// Use a manual implementation to ignore the path field\n+impl Hash for TargetTriple {\n+    fn hash<H: Hasher>(&self, state: &mut H) -> () {\n+        match self {\n+            TargetTriple::TargetTriple(triple) => {\n+                0u8.hash(state);\n+                triple.hash(state)\n+            }\n+            TargetTriple::TargetJson { path_for_rustdoc: _, triple, contents } => {\n+                1u8.hash(state);\n+                triple.hash(state);\n+                contents.hash(state)\n+            }\n+        }\n+    }\n+}\n+\n+// Use a manual implementation to prevent encoding the target json file path in the crate metadata\n+impl<S: Encoder> Encodable<S> for TargetTriple {\n+    fn encode(&self, s: &mut S) {\n+        match self {\n+            TargetTriple::TargetTriple(triple) => s.emit_enum_variant(0, |s| s.emit_str(triple)),\n+            TargetTriple::TargetJson { path_for_rustdoc: _, triple, contents } => s\n+                .emit_enum_variant(1, |s| {\n+                    s.emit_str(triple);\n+                    s.emit_str(contents)\n+                }),\n+        }\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for TargetTriple {\n+    fn decode(d: &mut D) -> Self {\n+        match d.read_usize() {\n+            0 => TargetTriple::TargetTriple(d.read_str().to_owned()),\n+            1 => TargetTriple::TargetJson {\n+                path_for_rustdoc: PathBuf::new(),\n+                triple: d.read_str().to_owned(),\n+                contents: d.read_str().to_owned(),\n+            },\n+            _ => {\n+                panic!(\"invalid enum variant tag while decoding `TargetTriple`, expected 0..2\");\n+            }\n+        }\n+    }\n }\n \n impl TargetTriple {\n@@ -2436,20 +2503,28 @@ impl TargetTriple {\n     /// Creates a target triple from the passed target path.\n     pub fn from_path(path: &Path) -> Result<Self, io::Error> {\n         let canonicalized_path = path.canonicalize()?;\n-        Ok(TargetTriple::TargetPath(canonicalized_path))\n+        let contents = std::fs::read_to_string(&canonicalized_path).map_err(|err| {\n+            io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                format!(\"target path {:?} is not a valid file: {}\", canonicalized_path, err),\n+            )\n+        })?;\n+        let triple = canonicalized_path\n+            .file_stem()\n+            .expect(\"target path must not be empty\")\n+            .to_str()\n+            .expect(\"target path must be valid unicode\")\n+            .to_owned();\n+        Ok(TargetTriple::TargetJson { path_for_rustdoc: canonicalized_path, triple, contents })\n     }\n \n     /// Returns a string triple for this target.\n     ///\n     /// If this target is a path, the file name (without extension) is returned.\n     pub fn triple(&self) -> &str {\n         match *self {\n-            TargetTriple::TargetTriple(ref triple) => triple,\n-            TargetTriple::TargetPath(ref path) => path\n-                .file_stem()\n-                .expect(\"target path must not be empty\")\n-                .to_str()\n-                .expect(\"target path must be valid unicode\"),\n+            TargetTriple::TargetTriple(ref triple)\n+            | TargetTriple::TargetJson { ref triple, .. } => triple,\n         }\n     }\n \n@@ -2459,16 +2534,15 @@ impl TargetTriple {\n     /// by `triple()`.\n     pub fn debug_triple(&self) -> String {\n         use std::collections::hash_map::DefaultHasher;\n-        use std::hash::{Hash, Hasher};\n-\n-        let triple = self.triple();\n-        if let TargetTriple::TargetPath(ref path) = *self {\n-            let mut hasher = DefaultHasher::new();\n-            path.hash(&mut hasher);\n-            let hash = hasher.finish();\n-            format!(\"{}-{}\", triple, hash)\n-        } else {\n-            triple.into()\n+\n+        match self {\n+            TargetTriple::TargetTriple(triple) => triple.to_owned(),\n+            TargetTriple::TargetJson { path_for_rustdoc: _, triple, contents: content } => {\n+                let mut hasher = DefaultHasher::new();\n+                content.hash(&mut hasher);\n+                let hash = hasher.finish();\n+                format!(\"{}-{}\", triple, hash)\n+            }\n         }\n     }\n }"}, {"sha": "ad9e80e117f1e016c3c1588a7a15757eb9863f48", "filename": "library/core/src/future/into_future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/library%2Fcore%2Fsrc%2Ffuture%2Finto_future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/library%2Fcore%2Fsrc%2Ffuture%2Finto_future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Finto_future.rs?ref=17c6bde14eabdd61c35505ed6834ee9196c2fdc9", "patch": "@@ -2,7 +2,7 @@ use crate::future::Future;\n \n /// Conversion into a `Future`.\n ///\n-/// By implementing `Intofuture` for a type, you define how it will be\n+/// By implementing `IntoFuture` for a type, you define how it will be\n /// converted to a future.\n ///\n /// # `.await` desugaring\n@@ -29,7 +29,7 @@ use crate::future::Future;\n /// When implementing futures manually there will often be a choice between\n /// implementing `Future` or `IntoFuture` for a type. Implementing `Future` is a\n /// good choice in most cases. But implementing `IntoFuture` is most useful when\n-/// implementing \"async builder\" types, which allows the type to be modified\n+/// implementing \"async builder\" types, which allow their values to be modified\n /// multiple times before being `.await`ed.\n ///\n /// ```rust"}, {"sha": "ecd2b75ae44271382ba80791968e2fb428e24c4b", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=17c6bde14eabdd61c35505ed6834ee9196c2fdc9", "patch": "@@ -973,6 +973,28 @@ pub const fn replace<T>(dest: &mut T, src: T) -> T {\n #[cfg_attr(not(test), rustc_diagnostic_item = \"mem_drop\")]\n pub fn drop<T>(_x: T) {}\n \n+/// Bitwise-copies a value.\n+///\n+/// This function is not magic; it is literally defined as\n+/// ```\n+/// pub fn copy<T: Copy>(x: &T) -> T { *x }\n+/// ```\n+///\n+/// It is useful when you want to pass a function pointer to a combinator, rather than defining a new closure.\n+///\n+/// Example:\n+/// ```\n+/// #![feature(mem_copy_fn)]\n+/// use core::mem::copy;\n+/// let result_from_ffi_function: Result<(), &i32> = Err(&1);\n+/// let result_copied: Result<(), i32> = result_from_ffi_function.map_err(copy);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"mem_copy_fn\", issue = \"98262\")]\n+pub fn copy<T: Copy>(x: &T) -> T {\n+    *x\n+}\n+\n /// Interprets `src` as having type `&U`, and then reads `src` without moving\n /// the contained value.\n ///"}, {"sha": "f46997b807ab230653d361ab92de59d16cc7ddef", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=17c6bde14eabdd61c35505ed6834ee9196c2fdc9", "patch": "@@ -2317,10 +2317,14 @@ impl AsInnerMut<fs_imp::DirBuilder> for DirBuilder {\n /// unrelated to the path not existing. (E.g. it will return `Err(_)` in case of permission\n /// denied on some of the parent directories.)\n ///\n+/// Note that while this avoids some pitfalls of the `exists()` method, it still can not\n+/// prevent time-of-check to time-of-use (TOCTOU) bugs. You should only use it in scenarios\n+/// where those bugs are not an issue.\n+///\n /// # Examples\n ///\n /// ```no_run\n-/// #![feature(path_try_exists)]\n+/// #![feature(fs_try_exists)]\n /// use std::fs;\n ///\n /// assert!(!fs::try_exists(\"does_not_exist.txt\").expect(\"Can't check existence of file does_not_exist.txt\"));\n@@ -2330,7 +2334,7 @@ impl AsInnerMut<fs_imp::DirBuilder> for DirBuilder {\n /// [`Path::exists`]: crate::path::Path::exists\n // FIXME: stabilization should modify documentation of `exists()` to recommend this method\n // instead.\n-#[unstable(feature = \"path_try_exists\", issue = \"83186\")]\n+#[unstable(feature = \"fs_try_exists\", issue = \"83186\")]\n #[inline]\n pub fn try_exists<P: AsRef<Path>>(path: P) -> io::Result<bool> {\n     fs_imp::try_exists(path.as_ref())"}, {"sha": "5dfeb517a1996439604baede7e69d6c955482c31", "filename": "library/std/src/path.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=17c6bde14eabdd61c35505ed6834ee9196c2fdc9", "patch": "@@ -2705,6 +2705,9 @@ impl Path {\n \n     /// Returns `true` if the path points at an existing entity.\n     ///\n+    /// Warning: this method may be error-prone, consider using [`try_exists()`] instead!\n+    /// It also has a risk of introducing time-of-check to time-of-use (TOCTOU) bugs.\n+    ///\n     /// This function will traverse symbolic links to query information about the\n     /// destination file.\n     ///\n@@ -2721,7 +2724,9 @@ impl Path {\n     /// # See Also\n     ///\n     /// This is a convenience function that coerces errors to false. If you want to\n-    /// check errors, call [`fs::metadata`].\n+    /// check errors, call [`Path::try_exists`].\n+    ///\n+    /// [`try_exists()`]: Self::try_exists\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     #[must_use]\n     #[inline]\n@@ -2738,20 +2743,20 @@ impl Path {\n     /// unrelated to the path not existing. (E.g. it will return `Err(_)` in case of permission\n     /// denied on some of the parent directories.)\n     ///\n+    /// Note that while this avoids some pitfalls of the `exists()` method, it still can not\n+    /// prevent time-of-check to time-of-use (TOCTOU) bugs. You should only use it in scenarios\n+    /// where those bugs are not an issue.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// #![feature(path_try_exists)]\n-    ///\n     /// use std::path::Path;\n     /// assert!(!Path::new(\"does_not_exist.txt\").try_exists().expect(\"Can't check existence of file does_not_exist.txt\"));\n     /// assert!(Path::new(\"/root/secret_file.txt\").try_exists().is_err());\n     /// ```\n     ///\n     /// [`exists()`]: Self::exists\n-    // FIXME: stabilization should modify documentation of `exists()` to recommend this method\n-    // instead.\n-    #[unstable(feature = \"path_try_exists\", issue = \"83186\")]\n+    #[stable(feature = \"path_try_exists\", since = \"1.63.0\")]\n     #[inline]\n     pub fn try_exists(&self) -> io::Result<bool> {\n         fs::try_exists(self)"}, {"sha": "ab72f4a3f502cf6991f2bac390341bbe99ec3446", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17c6bde14eabdd61c35505ed6834ee9196c2fdc9/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=17c6bde14eabdd61c35505ed6834ee9196c2fdc9", "patch": "@@ -365,8 +365,8 @@ fn run_test(\n     }\n     compiler.arg(\"--target\").arg(match target {\n         TargetTriple::TargetTriple(s) => s,\n-        TargetTriple::TargetPath(path) => {\n-            path.to_str().expect(\"target path must be valid unicode\").to_string()\n+        TargetTriple::TargetJson { path_for_rustdoc, .. } => {\n+            path_for_rustdoc.to_str().expect(\"target path must be valid unicode\").to_string()\n         }\n     });\n     if let ErrorOutputType::HumanReadable(kind) = rustdoc_options.error_format {"}]}