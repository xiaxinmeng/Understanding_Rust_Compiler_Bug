{"sha": "89259b34c04aff7052dd122552fac3070c830f4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5MjU5YjM0YzA0YWZmNzA1MmRkMTIyNTUyZmFjMzA3MGM4MzBmNGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-02T05:41:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-02T05:41:30Z"}, "message": "auto merge of #15085 : brson/rust/stridx, r=alexcrichton\n\nBeing able to index into the bytes of a string encourages\r\npoor UTF-8 hygiene. To get a view of `&[u8]` from either\r\na `String` or `&str` slice, use the `as_bytes()` method.\r\n\r\nCloses #12710.\r\n\r\n[breaking-change]\r\n\r\nIf the diffstat is any indication this shouldn't have a huge impact but it will have some. Most changes in the `str` and `path` module. A lot of the existing usages were in tests where ascii is expected. There are a number of other legit uses where the characters are known to be ascii.", "tree": {"sha": "d07053ae6f1c059a6a706dd80211795748cd9450", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d07053ae6f1c059a6a706dd80211795748cd9450"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89259b34c04aff7052dd122552fac3070c830f4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89259b34c04aff7052dd122552fac3070c830f4f", "html_url": "https://github.com/rust-lang/rust/commit/89259b34c04aff7052dd122552fac3070c830f4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89259b34c04aff7052dd122552fac3070c830f4f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd893d19223ae6979c180291be6b2a3b9311148a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd893d19223ae6979c180291be6b2a3b9311148a", "html_url": "https://github.com/rust-lang/rust/commit/bd893d19223ae6979c180291be6b2a3b9311148a"}, {"sha": "d21336ee0a3982bdc35f17cdc32b41f6de5603d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d21336ee0a3982bdc35f17cdc32b41f6de5603d4", "html_url": "https://github.com/rust-lang/rust/commit/d21336ee0a3982bdc35f17cdc32b41f6de5603d4"}], "stats": {"total": 188, "additions": 101, "deletions": 87}, "files": [{"sha": "fd8ce11d0b5a4bfdfc0256a830edff57445a8229", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -1569,8 +1569,8 @@ mod tests {\n         let n2: uint = v.len();\n         assert_eq!(n1, n2);\n         while i < n1 {\n-            let a: u8 = s1.as_slice()[i];\n-            let b: u8 = s2.as_slice()[i];\n+            let a: u8 = s1.as_bytes()[i];\n+            let b: u8 = s2.as_bytes()[i];\n             debug!(\"{}\", a);\n             debug!(\"{}\", b);\n             assert_eq!(a, b);"}, {"sha": "936e60388a66ae8223cca470b4f837d626399bfc", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -222,7 +222,7 @@ impl String {\n             return None\n         }\n \n-        let byte = self.as_slice()[len - 1];\n+        let byte = self.as_bytes()[len - 1];\n         self.vec.set_len(len - 1);\n         Some(byte)\n     }"}, {"sha": "94df7a5a6c2d9c7548a089e8e949fbc32936f226", "filename": "src/libcore/str.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -1743,7 +1743,7 @@ impl<'a> StrSlice<'a> for &'a str {\n     fn lines_any(&self) -> AnyLines<'a> {\n         self.lines().map(|line| {\n             let l = line.len();\n-            if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n+            if l > 0 && line.as_bytes()[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n             else { line }\n         })\n     }\n@@ -1867,26 +1867,26 @@ impl<'a> StrSlice<'a> for &'a str {\n     fn is_char_boundary(&self, index: uint) -> bool {\n         if index == self.len() { return true; }\n         if index > self.len() { return false; }\n-        let b = self[index];\n+        let b = self.as_bytes()[index];\n         return b < 128u8 || b >= 192u8;\n     }\n \n     #[inline]\n     fn char_range_at(&self, i: uint) -> CharRange {\n-        if self[i] < 128u8 {\n-            return CharRange {ch: self[i] as char, next: i + 1 };\n+        if self.as_bytes()[i] < 128u8 {\n+            return CharRange {ch: self.as_bytes()[i] as char, next: i + 1 };\n         }\n \n         // Multibyte case is a fn to allow char_range_at to inline cleanly\n         fn multibyte_char_range_at(s: &str, i: uint) -> CharRange {\n-            let mut val = s[i] as u32;\n+            let mut val = s.as_bytes()[i] as u32;\n             let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n             assert!((w != 0));\n \n             val = utf8_first_byte!(val, w);\n-            val = utf8_acc_cont_byte!(val, s[i + 1]);\n-            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n-            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n+            val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 1]);\n+            if w > 2 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 2]); }\n+            if w > 3 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 3]); }\n \n             return CharRange {ch: unsafe { mem::transmute(val) }, next: i + w};\n         }\n@@ -1899,23 +1899,25 @@ impl<'a> StrSlice<'a> for &'a str {\n         let mut prev = start;\n \n         prev = prev.saturating_sub(1);\n-        if self[prev] < 128 { return CharRange{ch: self[prev] as char, next: prev} }\n+        if self.as_bytes()[prev] < 128 {\n+            return CharRange{ch: self.as_bytes()[prev] as char, next: prev}\n+        }\n \n         // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n         fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n             // while there is a previous byte == 10......\n-            while i > 0 && s[i] & 192u8 == TAG_CONT_U8 {\n+            while i > 0 && s.as_bytes()[i] & 192u8 == TAG_CONT_U8 {\n                 i -= 1u;\n             }\n \n-            let mut val = s[i] as u32;\n+            let mut val = s.as_bytes()[i] as u32;\n             let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n             assert!((w != 0));\n \n             val = utf8_first_byte!(val, w);\n-            val = utf8_acc_cont_byte!(val, s[i + 1]);\n-            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n-            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n+            val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 1]);\n+            if w > 2 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 2]); }\n+            if w > 3 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 3]); }\n \n             return CharRange {ch: unsafe { mem::transmute(val) }, next: i};\n         }"}, {"sha": "0e525bc46e7c8b124226b32c65210d6ed3f4afca", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -370,7 +370,7 @@ impl Matches {\n }\n \n fn is_arg(arg: &str) -> bool {\n-    arg.len() > 1 && arg[0] == '-' as u8\n+    arg.len() > 1 && arg.as_bytes()[0] == '-' as u8\n }\n \n fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n@@ -553,7 +553,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n         } else {\n             let mut names;\n             let mut i_arg = None;\n-            if cur.as_slice()[1] == '-' as u8 {\n+            if cur.as_bytes()[1] == '-' as u8 {\n                 let tail = cur.as_slice().slice(2, curlen);\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {"}, {"sha": "17f29639601dd72455e0e7e38202970df8f3a298", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -657,8 +657,8 @@ pub fn sanitize(s: &str) -> String {\n \n     // Underscore-qualify anything that didn't start as an ident.\n     if result.len() > 0u &&\n-        result.as_slice()[0] != '_' as u8 &&\n-        ! char::is_XID_start(result.as_slice()[0] as char) {\n+        result.as_bytes()[0] != '_' as u8 &&\n+        ! char::is_XID_start(result.as_bytes()[0] as char) {\n         return format!(\"_{}\", result.as_slice());\n     }\n \n@@ -737,9 +737,9 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n     let extra2 = id % EXTRA_CHARS.len();\n     let id = id / EXTRA_CHARS.len();\n     let extra3 = id % EXTRA_CHARS.len();\n-    hash.push_char(EXTRA_CHARS[extra1] as char);\n-    hash.push_char(EXTRA_CHARS[extra2] as char);\n-    hash.push_char(EXTRA_CHARS[extra3] as char);\n+    hash.push_char(EXTRA_CHARS.as_bytes()[extra1] as char);\n+    hash.push_char(EXTRA_CHARS.as_bytes()[extra2] as char);\n+    hash.push_char(EXTRA_CHARS.as_bytes()[extra3] as char);\n \n     exported_name(path,\n                   hash.as_slice(),"}, {"sha": "78a29b52bdf5bc45974f05b5adf5bfe4ffc7d88b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -181,7 +181,7 @@ fn item_sized(item: ebml::Doc) -> ast::Sized {\n fn item_method_sort(item: ebml::Doc) -> char {\n     let mut ret = 'r';\n     reader::tagged_docs(item, tag_item_trait_method_sort, |doc| {\n-        ret = doc.as_str_slice()[0] as char;\n+        ret = doc.as_str_slice().as_bytes()[0] as char;\n         false\n     });\n     ret\n@@ -757,13 +757,13 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n     let explicit_self_doc = reader::get_doc(item, tag_item_trait_method_explicit_self);\n     let string = explicit_self_doc.as_str_slice();\n \n-    let explicit_self_kind = string[0];\n+    let explicit_self_kind = string.as_bytes()[0];\n     match explicit_self_kind as char {\n         's' => ast::SelfStatic,\n         'v' => ast::SelfValue,\n         '~' => ast::SelfUniq,\n         // FIXME(#4846) expl. region\n-        '&' => ast::SelfRegion(None, get_mutability(string[1])),\n+        '&' => ast::SelfRegion(None, get_mutability(string.as_bytes()[1])),\n         _ => fail!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n     }\n }"}, {"sha": "e7457f370d9adea16253276cb4fa5bc0b9224758", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -399,7 +399,7 @@ struct DeadVisitor<'a> {\n impl<'a> DeadVisitor<'a> {\n     fn should_warn_about_field(&mut self, node: &ast::StructField_) -> bool {\n         let (is_named, has_leading_underscore) = match node.ident() {\n-            Some(ref ident) => (true, token::get_ident(*ident).get()[0] == ('_' as u8)),\n+            Some(ref ident) => (true, token::get_ident(*ident).get().as_bytes()[0] == ('_' as u8)),\n             _ => (false, false)\n         };\n         let field_type = ty::node_id_to_type(self.tcx, node.id);"}, {"sha": "5c09466cd96820bdfb686760caf70ba973302ba7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -1511,7 +1511,7 @@ impl<'a> Liveness<'a> {\n \n     fn should_warn(&self, var: Variable) -> Option<String> {\n         let name = self.ir.variable_name(var);\n-        if name.len() == 0 || name.as_slice()[0] == ('_' as u8) {\n+        if name.len() == 0 || name.as_bytes()[0] == ('_' as u8) {\n             None\n         } else {\n             Some(name)"}, {"sha": "e1a2a5741fbe1b0d0e03ba62c41dd7666e647f6e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -126,7 +126,6 @@ pub enum FieldName {\n #[deriving(Clone, PartialEq, Eq, Hash)]\n pub enum ElementKind {\n     VecElement,\n-    StrElement,\n     OtherElement,\n }\n \n@@ -794,7 +793,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n         //! - `derefs`: the deref number to be used for\n         //!   the implicit index deref, if any (see above)\n \n-        let element_ty = match ty::index(base_cmt.ty) {\n+        let element_ty = match ty::array_element_ty(base_cmt.ty) {\n           Some(ref mt) => mt.ty,\n           None => {\n             self.tcx().sess.span_bug(\n@@ -1137,9 +1136,6 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n           cat_interior(_, InteriorElement(VecElement)) => {\n               \"vec content\".to_string()\n           }\n-          cat_interior(_, InteriorElement(StrElement)) => {\n-              \"str content\".to_string()\n-          }\n           cat_interior(_, InteriorElement(OtherElement)) => {\n               \"indexed content\".to_string()\n           }\n@@ -1320,7 +1316,6 @@ fn element_kind(t: ty::t) -> ElementKind {\n         ty::ty_rptr(_, ty::mt{ty:ty, ..}) |\n         ty::ty_uniq(ty) => match ty::get(ty).sty {\n             ty::ty_vec(_, None) => VecElement,\n-            ty::ty_str => StrElement,\n             _ => OtherElement\n         },\n         ty::ty_vec(..) => VecElement,"}, {"sha": "79630be7c5e0840c21dfdf99228ed5bbede7f7ac", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -2563,6 +2563,21 @@ pub fn deref(t: t, explicit: bool) -> Option<mt> {\n \n // Returns the type of t[i]\n pub fn index(t: t) -> Option<mt> {\n+    match get(t).sty {\n+        ty_vec(mt, Some(_)) => Some(mt),\n+        ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n+        ty_box(t) | ty_uniq(t) => match get(t).sty {\n+            ty_vec(mt, None) => Some(mt),\n+            _ => None,\n+        },\n+        _ => None\n+    }\n+}\n+\n+// Returns the type of elements contained within an 'array-like' type.\n+// This is exactly the same as the above, except it supports strings,\n+// which can't actually be indexed.\n+pub fn array_element_ty(t: t) -> Option<mt> {\n     match get(t).sty {\n         ty_vec(mt, Some(_)) => Some(mt),\n         ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |"}, {"sha": "e7f26c7bd910e5d21d61de30a703734684f9f1a4", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -1206,8 +1206,8 @@ mod test {\n         let mut cur = [0u8, .. 2];\n         for f in files {\n             let stem = f.filestem_str().unwrap();\n-            let root = stem[0] - ('0' as u8);\n-            let name = stem[1] - ('0' as u8);\n+            let root = stem.as_bytes()[0] - ('0' as u8);\n+            let name = stem.as_bytes()[1] - ('0' as u8);\n             assert!(cur[root as uint] < name);\n             cur[root as uint] = name;\n         }"}, {"sha": "113b0410875af7ad0d068d0b394554320715de96", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -242,14 +242,18 @@ impl GenericPathUnsafe for Path {\n         fn is_vol_abs(path: &str, prefix: Option<PathPrefix>) -> bool {\n             // assume prefix is Some(DiskPrefix)\n             let rest = path.slice_from(prefix_len(prefix));\n-            !rest.is_empty() && rest[0].is_ascii() && is_sep(rest[0] as char)\n+            !rest.is_empty() && rest.as_bytes()[0].is_ascii() && is_sep(rest.as_bytes()[0] as char)\n         }\n         fn shares_volume(me: &Path, path: &str) -> bool {\n             // path is assumed to have a prefix of Some(DiskPrefix)\n             let repr = me.repr.as_slice();\n             match me.prefix {\n-                Some(DiskPrefix) => repr[0] == path[0].to_ascii().to_upper().to_byte(),\n-                Some(VerbatimDiskPrefix) => repr[4] == path[0].to_ascii().to_upper().to_byte(),\n+                Some(DiskPrefix) => {\n+                    repr.as_bytes()[0] == path.as_bytes()[0].to_ascii().to_upper().to_byte()\n+                }\n+                Some(VerbatimDiskPrefix) => {\n+                    repr.as_bytes()[4] == path.as_bytes()[0].to_ascii().to_upper().to_byte()\n+                }\n                 _ => false\n             }\n         }\n@@ -279,7 +283,7 @@ impl GenericPathUnsafe for Path {\n             // if me is \"C:\" we don't want to add a path separator\n             match me.prefix {\n                 Some(DiskPrefix) if me.repr.len() == plen => (),\n-                _ if !(me.repr.len() > plen && me.repr.as_slice()[me.repr.len()-1] == SEP_BYTE) => {\n+                _ if !(me.repr.len() > plen && me.repr.as_bytes()[me.repr.len()-1] == SEP_BYTE) => {\n                     s.push_char(SEP);\n                 }\n                 _ => ()\n@@ -302,7 +306,7 @@ impl GenericPathUnsafe for Path {\n                     // absolute path, or cwd-relative and self is not same volume\n                     replace_path(self, path, prefix);\n                 }\n-                None if !path.is_empty() && is_sep_(self.prefix, path[0]) => {\n+                None if !path.is_empty() && is_sep_(self.prefix, path.as_bytes()[0]) => {\n                     // volume-relative path\n                     if self.prefix.is_some() {\n                         // truncate self down to the prefix, then append\n@@ -478,7 +482,7 @@ impl GenericPath for Path {\n         match self.prefix {\n             Some(DiskPrefix) => {\n                 let rest = self.repr.as_slice().slice_from(self.prefix_len());\n-                rest.len() > 0 && rest[0] == SEP_BYTE\n+                rest.len() > 0 && rest.as_bytes()[0] == SEP_BYTE\n             }\n             Some(_) => true,\n             None => false\n@@ -638,11 +642,11 @@ impl Path {\n         let s = match self.prefix {\n             Some(_) => {\n                 let plen = self.prefix_len();\n-                if repr.len() > plen && repr[plen] == SEP_BYTE {\n+                if repr.len() > plen && repr.as_bytes()[plen] == SEP_BYTE {\n                     repr.slice_from(plen+1)\n                 } else { repr.slice_from(plen) }\n             }\n-            None if repr[0] == SEP_BYTE => repr.slice_from(1),\n+            None if repr.as_bytes()[0] == SEP_BYTE => repr.slice_from(1),\n             None => repr\n         };\n         let ret = s.split_terminator(SEP).map(Some);\n@@ -665,14 +669,14 @@ impl Path {\n         match (self.prefix, other.prefix) {\n             (Some(DiskPrefix), Some(VerbatimDiskPrefix)) => {\n                 self.is_absolute() &&\n-                    s_repr[0].to_ascii().eq_ignore_case(o_repr[4].to_ascii())\n+                    s_repr.as_bytes()[0].to_ascii().eq_ignore_case(o_repr.as_bytes()[4].to_ascii())\n             }\n             (Some(VerbatimDiskPrefix), Some(DiskPrefix)) => {\n                 other.is_absolute() &&\n-                    s_repr[4].to_ascii().eq_ignore_case(o_repr[0].to_ascii())\n+                    s_repr.as_bytes()[4].to_ascii().eq_ignore_case(o_repr.as_bytes()[0].to_ascii())\n             }\n             (Some(VerbatimDiskPrefix), Some(VerbatimDiskPrefix)) => {\n-                s_repr[4].to_ascii().eq_ignore_case(o_repr[4].to_ascii())\n+                s_repr.as_bytes()[4].to_ascii().eq_ignore_case(o_repr.as_bytes()[4].to_ascii())\n             }\n             (Some(UNCPrefix(_,_)), Some(VerbatimUNCPrefix(_,_))) => {\n                 s_repr.slice(2, self.prefix_len()) == o_repr.slice(8, other.prefix_len())\n@@ -718,12 +722,12 @@ impl Path {\n             let mut comps = comps;\n             match (comps.is_some(),prefix) {\n                 (false, Some(DiskPrefix)) => {\n-                    if s[0] >= 'a' as u8 && s[0] <= 'z' as u8 {\n+                    if s.as_bytes()[0] >= 'a' as u8 && s.as_bytes()[0] <= 'z' as u8 {\n                         comps = Some(vec![]);\n                     }\n                 }\n                 (false, Some(VerbatimDiskPrefix)) => {\n-                    if s[4] >= 'a' as u8 && s[0] <= 'z' as u8 {\n+                    if s.as_bytes()[4] >= 'a' as u8 && s.as_bytes()[0] <= 'z' as u8 {\n                         comps = Some(vec![]);\n                     }\n                 }\n@@ -778,12 +782,12 @@ impl Path {\n                         let mut s = String::with_capacity(n);\n                         match prefix {\n                             Some(DiskPrefix) => {\n-                                s.push_char(prefix_[0].to_ascii().to_upper().to_char());\n+                                s.push_char(prefix_.as_bytes()[0].to_ascii().to_upper().to_char());\n                                 s.push_char(':');\n                             }\n                             Some(VerbatimDiskPrefix) => {\n                                 s.push_str(prefix_.slice_to(4));\n-                                s.push_char(prefix_[4].to_ascii().to_upper().to_char());\n+                                s.push_char(prefix_.as_bytes()[4].to_ascii().to_upper().to_char());\n                                 s.push_str(prefix_.slice_from(5));\n                             }\n                             Some(UNCPrefix(a,b)) => {\n@@ -845,7 +849,7 @@ impl Path {\n \n     fn has_nonsemantic_trailing_slash(&self) -> bool {\n         is_verbatim(self) && self.repr.len() > self.prefix_len()+1 &&\n-            self.repr.as_slice()[self.repr.len()-1] == SEP_BYTE\n+            self.repr.as_bytes()[self.repr.len()-1] == SEP_BYTE\n     }\n \n     fn update_normalized<S: Str>(&mut self, s: S) {\n@@ -861,7 +865,7 @@ impl Path {\n /// but absolute within that volume.\n #[inline]\n pub fn is_vol_relative(path: &Path) -> bool {\n-    path.prefix.is_none() && is_sep_byte(&path.repr.as_slice()[0])\n+    path.prefix.is_none() && is_sep_byte(&path.repr.as_bytes()[0])\n }\n \n /// Returns whether the path is considered \"cwd-relative\", which means a path\n@@ -991,8 +995,8 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             } else {\n                 // \\\\?\\path\n                 let idx = path.find('\\\\');\n-                if idx == Some(2) && path[1] == ':' as u8 {\n-                    let c = path[0];\n+                if idx == Some(2) && path.as_bytes()[1] == ':' as u8 {\n+                    let c = path.as_bytes()[0];\n                     if c.is_ascii() && ::char::is_alphabetic(c as char) {\n                         // \\\\?\\C:\\ path\n                         return Some(VerbatimDiskPrefix);\n@@ -1014,9 +1018,9 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             }\n             _ => ()\n         }\n-    } else if path.len() > 1 && path[1] == ':' as u8 {\n+    } else if path.len() > 1 && path.as_bytes()[1] == ':' as u8 {\n         // C:\n-        let c = path[0];\n+        let c = path.as_bytes()[0];\n         if c.is_ascii() && ::char::is_alphabetic(c as char) {\n             return Some(DiskPrefix);\n         }"}, {"sha": "dfaa9fb5fcb09507f31144396946f7708b588c40", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -415,7 +415,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n         }\n         let orig = fm.get_line(*lines.lines.get(0) as int);\n         for pos in range(0u, left-skip) {\n-            let cur_char = orig.as_slice()[pos] as char;\n+            let cur_char = orig.as_bytes()[pos] as char;\n             // Whenever a tab occurs on the previous line, we insert one on\n             // the error-point-squiggly-line as well (instead of a space).\n             // That way the squiggly line will usually appear in the correct"}, {"sha": "0f188fdf18a5a80c06ee94126b1ac47e16198674", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -1203,8 +1203,8 @@ impl<'a> StringReader<'a> {\n \n     fn read_one_line_comment(&mut self) -> String {\n         let val = self.read_to_eol();\n-        assert!((val.as_slice()[0] == '/' as u8 && val.as_slice()[1] == '/' as u8)\n-             || (val.as_slice()[0] == '#' as u8 && val.as_slice()[1] == '!' as u8));\n+        assert!((val.as_bytes()[0] == '/' as u8 && val.as_bytes()[1] == '/' as u8)\n+             || (val.as_bytes()[0] == '#' as u8 && val.as_bytes()[1] == '!' as u8));\n         return val;\n     }\n "}, {"sha": "f52a032961dd96a568628259f8d785e43ff21fbd", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -375,7 +375,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n     fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n         let mut i = pos;\n         for ch in needle.bytes() {\n-            if s[i] != ch {\n+            if s.as_bytes()[i] != ch {\n                 return false;\n             }\n             i += 1u;"}, {"sha": "0e73256893e9cc1c06450b755c3fc6ccdccbdc2d", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -324,8 +324,8 @@ impl Uuid {\n         let mut s: Vec<u8> = Vec::from_elem(32, 0u8);\n         for i in range(0u, 16u) {\n             let digit = format!(\"{:02x}\", self.bytes[i] as uint);\n-            *s.get_mut(i*2+0) = digit.as_slice()[0];\n-            *s.get_mut(i*2+1) = digit.as_slice()[1];\n+            *s.get_mut(i*2+0) = digit.as_bytes()[0];\n+            *s.get_mut(i*2+1) = digit.as_bytes()[1];\n         }\n         str::from_utf8(s.as_slice()).unwrap().to_string()\n     }"}, {"sha": "195c146c12fe719f26927bef8016837b91852345", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -183,7 +183,7 @@ fn main() {\n \n        if line.len() == 0u { continue; }\n \n-       match (line.as_slice()[0] as char, proc_mode) {\n+       match (line.as_bytes()[0] as char, proc_mode) {\n \n            // start processing if this is the one\n            ('>', false) => {"}, {"sha": "8b1f9eb19864fadf3a9caf31f5dcb686b4a09a4c", "filename": "src/test/compile-fail/integral-indexing.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -17,10 +17,10 @@ pub fn main() {\n     assert_eq!(v.as_slice()[3u32], 3); //~ ERROR: mismatched types\n     assert_eq!(v.as_slice()[3i32], 3); //~ ERROR: mismatched types\n     println!(\"{}\", v.as_slice()[3u8]); //~ ERROR: mismatched types\n-    assert_eq!(s.as_slice()[3u], 'd' as u8);\n-    assert_eq!(s.as_slice()[3u8], 'd' as u8); //~ ERROR: mismatched types\n-    assert_eq!(s.as_slice()[3i8], 'd' as u8); //~ ERROR: mismatched types\n-    assert_eq!(s.as_slice()[3u32], 'd' as u8); //~ ERROR: mismatched types\n-    assert_eq!(s.as_slice()[3i32], 'd' as u8); //~ ERROR: mismatched types\n-    println!(\"{}\", s.as_slice()[3u8]); //~ ERROR: mismatched types\n+    assert_eq!(s.as_bytes()[3u], 'd' as u8);\n+    assert_eq!(s.as_bytes()[3u8], 'd' as u8); //~ ERROR: mismatched types\n+    assert_eq!(s.as_bytes()[3i8], 'd' as u8); //~ ERROR: mismatched types\n+    assert_eq!(s.as_bytes()[3u32], 'd' as u8); //~ ERROR: mismatched types\n+    assert_eq!(s.as_bytes()[3i32], 'd' as u8); //~ ERROR: mismatched types\n+    println!(\"{}\", s.as_bytes()[3u8]); //~ ERROR: mismatched types\n }"}, {"sha": "25e4c90e7741b57aa64a80e099f0ed39d05b3a03", "filename": "src/test/compile-fail/str-idx.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Fcompile-fail%2Fstr-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Fcompile-fail%2Fstr-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstr-idx.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -11,8 +11,6 @@\n extern crate debug;\n \n pub fn main() {\n-    let s = \"hello\".to_string();\n-    let c: u8 = s.as_slice()[4];\n-    println!(\"{:?}\", c);\n-    assert_eq!(c, 0x6f as u8);\n+    let s: &str = \"hello\";\n+    let c: u8 = s[4]; //~ ERROR cannot index a value of type `&str`\n }", "previous_filename": "src/test/run-pass/str-idx.rs"}, {"sha": "c3ee76047d13428060432d2ded9cd7359bd79cb1", "filename": "src/test/run-fail/str-overrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -14,5 +14,5 @@ fn main() {\n     let s: String = \"hello\".to_string();\n \n     // Bounds-check failure.\n-    assert_eq!(s.as_slice()[5], 0x0 as u8);\n+    assert_eq!(s.as_bytes()[5], 0x0 as u8);\n }"}, {"sha": "5364cdc627f50b1f95d9304ef8c0756c1c2b89cb", "filename": "src/test/run-pass/estr-slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Frun-pass%2Festr-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Frun-pass%2Festr-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Festr-slice.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -17,8 +17,8 @@ pub fn main() {\n     println!(\"{}\", x);\n     println!(\"{}\", y);\n \n-    assert_eq!(x[0], 'h' as u8);\n-    assert_eq!(x[4], 'o' as u8);\n+    assert_eq!(x.as_bytes()[0], 'h' as u8);\n+    assert_eq!(x.as_bytes()[4], 'o' as u8);\n \n     let z : &str = \"thing\";\n     assert_eq!(v, x);"}, {"sha": "b562558822cd1bf2064f346d670fa17a58526175", "filename": "src/test/run-pass/estr-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Frun-pass%2Festr-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Frun-pass%2Festr-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Festr-uniq.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -15,6 +15,6 @@ pub fn main() {\n     let _y : String = \"there\".to_string();\n     let mut z = \"thing\".to_string();\n     z = x;\n-    assert_eq!(z.as_slice()[0], ('h' as u8));\n-    assert_eq!(z.as_slice()[4], ('o' as u8));\n+    assert_eq!(z.as_bytes()[0], ('h' as u8));\n+    assert_eq!(z.as_bytes()[4], ('o' as u8));\n }"}, {"sha": "ad0d2f11abd8611562a1c660f02d556142545134", "filename": "src/test/run-pass/str-concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Frun-pass%2Fstr-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Frun-pass%2Fstr-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-concat.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -16,5 +16,5 @@ pub fn main() {\n     let b: String = \"world\".to_string();\n     let s: String = format!(\"{}{}\", a, b);\n     println!(\"{}\", s.clone());\n-    assert_eq!(s.as_slice()[9], 'd' as u8);\n+    assert_eq!(s.as_bytes()[9], 'd' as u8);\n }"}, {"sha": "d45e7a20c3b2020271f71a5fa1ff7ac106cafcbb", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -39,10 +39,10 @@ fn test_str() {\n     let s0 = \"test\".to_string();\n     tx.send(s0);\n     let s1 = rx.recv();\n-    assert_eq!(s1.as_slice()[0], 't' as u8);\n-    assert_eq!(s1.as_slice()[1], 'e' as u8);\n-    assert_eq!(s1.as_slice()[2], 's' as u8);\n-    assert_eq!(s1.as_slice()[3], 't' as u8);\n+    assert_eq!(s1.as_bytes()[0], 't' as u8);\n+    assert_eq!(s1.as_bytes()[1], 'e' as u8);\n+    assert_eq!(s1.as_bytes()[2], 's' as u8);\n+    assert_eq!(s1.as_bytes()[3], 't' as u8);\n }\n \n #[deriving(Show)]"}, {"sha": "cfe9a772b2ee84de751ea38d3528d420f32b3bf1", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -99,7 +99,7 @@ fn check_legs(arc: Arc<Vec<Box<Pet+Share+Send>>>) {\n fn check_names(arc: Arc<Vec<Box<Pet+Share+Send>>>) {\n     for pet in arc.iter() {\n         pet.name(|name| {\n-            assert!(name[0] == 'a' as u8 && name[1] == 'l' as u8);\n+            assert!(name.as_bytes()[0] == 'a' as u8 && name.as_bytes()[1] == 'l' as u8);\n         })\n     }\n }"}, {"sha": "557d2e5878e1dd1bf03f18786fec07e04b666ac5", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89259b34c04aff7052dd122552fac3070c830f4f/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=89259b34c04aff7052dd122552fac3070c830f4f", "patch": "@@ -46,7 +46,7 @@ pub fn main() {\n         for ab in a.as_slice().bytes() {\n             println!(\"{}\", i);\n             println!(\"{}\", ab);\n-            let bb: u8 = b.as_slice()[i as uint];\n+            let bb: u8 = b.as_bytes()[i as uint];\n             println!(\"{}\", bb);\n             assert_eq!(ab, bb);\n             i += 1;"}]}