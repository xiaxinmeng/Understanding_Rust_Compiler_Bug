{"sha": "444cbcd729e4b55602fedcaef7fe902316d8ab49", "node_id": "C_kwDOAAsO6NoAKDQ0NGNiY2Q3MjllNGI1NTYwMmZlZGNhZWY3ZmU5MDIzMTZkOGFiNDk", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-20T18:38:33Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-21T17:15:00Z"}, "message": "Address goal nits", "tree": {"sha": "23187de30da5fe046de59a68bd8c23a4dde8a4e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23187de30da5fe046de59a68bd8c23a4dde8a4e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/444cbcd729e4b55602fedcaef7fe902316d8ab49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/444cbcd729e4b55602fedcaef7fe902316d8ab49", "html_url": "https://github.com/rust-lang/rust/commit/444cbcd729e4b55602fedcaef7fe902316d8ab49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/444cbcd729e4b55602fedcaef7fe902316d8ab49/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6a411c086e61926aa52022b1df3a4a94e934906", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6a411c086e61926aa52022b1df3a4a94e934906", "html_url": "https://github.com/rust-lang/rust/commit/d6a411c086e61926aa52022b1df3a4a94e934906"}], "stats": {"total": 92, "additions": 54, "deletions": 38}, "files": [{"sha": "cdb72d49834f0101f401660171e102675bfa9e3b", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/444cbcd729e4b55602fedcaef7fe902316d8ab49/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444cbcd729e4b55602fedcaef7fe902316d8ab49/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=444cbcd729e4b55602fedcaef7fe902316d8ab49", "patch": "@@ -1,7 +1,7 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n use super::infcx_ext::InferCtxtExt;\n-use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n+use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate_predicates;\n@@ -148,9 +148,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         if goal.predicate.self_ty().is_ty_var() {\n             return vec![Candidate {\n                 source: CandidateSource::BuiltinImpl,\n-                result: self\n-                    .make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity))\n-                    .unwrap(),\n+                result: self.make_canonical_response(Certainty::AMBIGUOUS).unwrap(),\n             }];\n         }\n "}, {"sha": "da2a1a19957e128f491b8a1bbc3b3384da637581", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 46, "deletions": 27, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/444cbcd729e4b55602fedcaef7fe902316d8ab49/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444cbcd729e4b55602fedcaef7fe902316d8ab49/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=444cbcd729e4b55602fedcaef7fe902316d8ab49", "patch": "@@ -19,6 +19,7 @@\n \n use std::mem;\n \n+use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarKind, CanonicalVarValues};\n use rustc_infer::infer::canonical::{OriginalQueryValues, QueryRegionConstraints, QueryResponse};\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n@@ -27,7 +28,7 @@ use rustc_infer::traits::Obligation;\n use rustc_middle::infer::canonical::Certainty as OldCertainty;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n-    RegionOutlivesPredicate, SubtypePredicate, ToPredicate, TypeOutlivesPredicate,\n+    CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, ToPredicate, TypeOutlivesPredicate,\n };\n use rustc_span::DUMMY_SP;\n \n@@ -89,6 +90,8 @@ pub enum Certainty {\n }\n \n impl Certainty {\n+    pub const AMBIGUOUS: Certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n+\n     /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n     /// use this function to unify the certainty of these goals\n     pub fn unify_and(self, other: Certainty) -> Certainty {\n@@ -248,21 +251,15 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 ty::PredicateKind::Subtype(predicate) => {\n                     self.compute_subtype_goal(Goal { param_env, predicate })\n                 }\n-                ty::PredicateKind::Coerce(predicate) => self.compute_subtype_goal(Goal {\n-                    param_env,\n-                    predicate: SubtypePredicate {\n-                        a_is_expected: true,\n-                        a: predicate.a,\n-                        b: predicate.b,\n-                    },\n-                }),\n-                ty::PredicateKind::ClosureKind(_, substs, kind) => self.compute_closure_kind_goal(\n-                    substs.as_closure().kind_ty().to_opt_closure_kind(),\n-                    kind,\n-                ),\n-                ty::PredicateKind::Ambiguous => {\n-                    self.make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity))\n+                ty::PredicateKind::Coerce(predicate) => {\n+                    self.compute_coerce_goal(Goal { param_env, predicate })\n                 }\n+                ty::PredicateKind::ClosureKind(def_id, substs, kind) => self\n+                    .compute_closure_kind_goal(Goal {\n+                        param_env,\n+                        predicate: (def_id, substs, kind),\n+                    }),\n+                ty::PredicateKind::Ambiguous => self.make_canonical_response(Certainty::AMBIGUOUS),\n                 // FIXME: implement these predicates :)\n                 ty::PredicateKind::WellFormed(_)\n                 | ty::PredicateKind::ObjectSafe(_)\n@@ -296,28 +293,50 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         self.make_canonical_response(Certainty::Yes)\n     }\n \n+    fn compute_coerce_goal(\n+        &mut self,\n+        goal: Goal<'tcx, CoercePredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        self.compute_subtype_goal(Goal {\n+            param_env: goal.param_env,\n+            predicate: SubtypePredicate {\n+                a_is_expected: false,\n+                a: goal.predicate.a,\n+                b: goal.predicate.b,\n+            },\n+        })\n+    }\n+\n     fn compute_subtype_goal(\n         &mut self,\n         goal: Goal<'tcx, SubtypePredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        self.infcx.probe(|_| {\n-            let InferOk { value: (), obligations } = self\n-                .infcx\n-                .at(&ObligationCause::dummy(), goal.param_env)\n-                .sub(goal.predicate.a, goal.predicate.b)?;\n-            self.evaluate_all_and_make_canonical_response(\n-                obligations.into_iter().map(|pred| pred.into()).collect(),\n-            )\n-        })\n+        if goal.predicate.a.is_ty_var() && goal.predicate.b.is_ty_var() {\n+            // FIXME: Do we want to register a subtype relation between these vars?\n+            // That won't actually reflect in the query response, so it seems moot.\n+            self.make_canonical_response(Certainty::AMBIGUOUS)\n+        } else {\n+            self.infcx.probe(|_| {\n+                let InferOk { value: (), obligations } = self\n+                    .infcx\n+                    .at(&ObligationCause::dummy(), goal.param_env)\n+                    .sub(goal.predicate.a, goal.predicate.b)?;\n+                self.evaluate_all_and_make_canonical_response(\n+                    obligations.into_iter().map(|pred| pred.into()).collect(),\n+                )\n+            })\n+        }\n     }\n \n     fn compute_closure_kind_goal(\n         &mut self,\n-        found_kind: Option<ty::ClosureKind>,\n-        expected_kind: ty::ClosureKind,\n+        goal: Goal<'tcx, (DefId, ty::SubstsRef<'tcx>, ty::ClosureKind)>,\n     ) -> QueryResult<'tcx> {\n+        let (_, substs, expected_kind) = goal.predicate;\n+        let found_kind = substs.as_closure().kind_ty().to_opt_closure_kind();\n+\n         let Some(found_kind) = found_kind else {\n-            return self.make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity));\n+            return self.make_canonical_response(Certainty::AMBIGUOUS);\n         };\n         if found_kind.extends(expected_kind) {\n             self.make_canonical_response(Certainty::Yes)"}, {"sha": "32e15f03998b3598431b58e417d87938e5cab02d", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/444cbcd729e4b55602fedcaef7fe902316d8ab49/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444cbcd729e4b55602fedcaef7fe902316d8ab49/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=444cbcd729e4b55602fedcaef7fe902316d8ab49", "patch": "@@ -3,7 +3,7 @@ use crate::traits::{specialization_graph, translate_substs};\n use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n use super::trait_goals::structural_traits;\n-use super::{Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n+use super::{Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n@@ -229,8 +229,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 goal.predicate.def_id(),\n                 impl_def_id\n             )? else {\n-                let certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n-                return ecx.make_canonical_response(trait_ref_certainty.unify_and(certainty));\n+                return ecx.make_canonical_response(trait_ref_certainty.unify_and(Certainty::AMBIGUOUS));\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -382,7 +381,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 .to_predicate(ecx.tcx());\n             Self::consider_assumption(ecx, goal, pred)\n         } else {\n-            ecx.make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity))\n+            ecx.make_canonical_response(Certainty::AMBIGUOUS)\n         }\n     }\n "}, {"sha": "4b6d673c999c96fd7dab198e99a3aec327ceba70", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/444cbcd729e4b55602fedcaef7fe902316d8ab49/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444cbcd729e4b55602fedcaef7fe902316d8ab49/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=444cbcd729e4b55602fedcaef7fe902316d8ab49", "patch": "@@ -4,7 +4,7 @@ use std::iter;\n \n use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n-use super::{Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n+use super::{Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n@@ -133,7 +133,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         if goal.predicate.self_ty().has_non_region_infer() {\n-            return ecx.make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity));\n+            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n         }\n \n         let tcx = ecx.tcx();\n@@ -171,7 +171,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 .to_predicate(ecx.tcx());\n             Self::consider_assumption(ecx, goal, pred)\n         } else {\n-            ecx.make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity))\n+            ecx.make_canonical_response(Certainty::AMBIGUOUS)\n         }\n     }\n "}]}