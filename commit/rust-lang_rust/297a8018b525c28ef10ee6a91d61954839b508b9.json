{"sha": "297a8018b525c28ef10ee6a91d61954839b508b9", "node_id": "C_kwDOAAsO6NoAKDI5N2E4MDE4YjUyNWMyOGVmMTBlZTZhOTFkNjE5NTQ4MzliNTA4Yjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-01T17:19:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-01T17:19:15Z"}, "message": "Auto merge of #95552 - matthiaskrgr:rollup-bxminn9, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #95032 (Clean up, categorize and sort unstable features in std.)\n - #95260 (Better suggestions for `Fn`-family trait selection errors)\n - #95293 (suggest wrapping single-expr blocks in square brackets)\n - #95344 (Make `impl Debug for rustdoc::clean::Item` easier to read)\n - #95388 (interpret: make isize::MAX the limit for dynamic value sizes)\n - #95530 (rustdoc: do not show primitives and keywords as private)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c34e18a769e70d916ce028e679aa19fe7d94523d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c34e18a769e70d916ce028e679aa19fe7d94523d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/297a8018b525c28ef10ee6a91d61954839b508b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/297a8018b525c28ef10ee6a91d61954839b508b9", "html_url": "https://github.com/rust-lang/rust/commit/297a8018b525c28ef10ee6a91d61954839b508b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/297a8018b525c28ef10ee6a91d61954839b508b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99da9aec246e6b500a4e589e4b9096306bb89b07", "url": "https://api.github.com/repos/rust-lang/rust/commits/99da9aec246e6b500a4e589e4b9096306bb89b07", "html_url": "https://github.com/rust-lang/rust/commit/99da9aec246e6b500a4e589e4b9096306bb89b07"}, {"sha": "c6750e491c683aa208f908c496a675dc2eceb005", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6750e491c683aa208f908c496a675dc2eceb005", "html_url": "https://github.com/rust-lang/rust/commit/c6750e491c683aa208f908c496a675dc2eceb005"}], "stats": {"total": 926, "additions": 702, "deletions": 224}, "files": [{"sha": "1b8186b5aadbace598262cae23a4f7141c40f1fd", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -23,8 +23,8 @@ use rustc_target::abi::{call::FnAbi, Align, HasDataLayout, Size, TargetDataLayou\n \n use super::{\n     AllocCheck, AllocId, GlobalId, Immediate, InterpErrorInfo, InterpResult, MPlaceTy, Machine,\n-    MemPlace, MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, Pointer, Provenance,\n-    Scalar, ScalarMaybeUninit, StackPopJump,\n+    MemPlace, MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, Pointer,\n+    PointerArithmetic, Provenance, Scalar, ScalarMaybeUninit, StackPopJump,\n };\n use crate::transform::validate::equal_up_to_regions;\n \n@@ -678,7 +678,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let size = size.align_to(align);\n \n                 // Check if this brought us over the size limit.\n-                if size.bytes() >= self.tcx.data_layout.obj_size_bound() {\n+                if size > self.max_size_of_val() {\n                     throw_ub!(InvalidMeta(\"total size is bigger than largest supported object\"));\n                 }\n                 Ok(Some((size, align)))\n@@ -694,9 +694,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let elem = layout.field(self, 0);\n \n                 // Make sure the slice is not too big.\n-                let size = elem.size.checked_mul(len, self).ok_or_else(|| {\n-                    err_ub!(InvalidMeta(\"slice is bigger than largest supported object\"))\n-                })?;\n+                let size = elem.size.bytes().saturating_mul(len); // we rely on `max_size_of_val` being smaller than `u64::MAX`.\n+                let size = Size::from_bytes(size);\n+                if size > self.max_size_of_val() {\n+                    throw_ub!(InvalidMeta(\"slice is bigger than largest supported object\"));\n+                }\n                 Ok(Some((size, elem.align.abi)))\n             }\n "}, {"sha": "c80d7d71787422ced418d9ea410c8c012ecd81cb", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -531,7 +531,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n         // We cannot overflow i64 as a type's size must be <= isize::MAX.\n         let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n-        // The computed offset, in bytes, cannot overflow an isize.\n+        // The computed offset, in bytes, must not overflow an isize.\n+        // `checked_mul` enforces a too small bound, but no actual allocation can be big enough for\n+        // the difference to be noticeable.\n         let offset_bytes =\n             offset_count.checked_mul(pointee_size).ok_or(err_ub!(PointerArithOverflow))?;\n         // The offset being in bounds cannot rely on \"wrapping around\" the address space.\n@@ -563,6 +565,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let count = self.read_scalar(&count)?.to_machine_usize(self)?;\n         let layout = self.layout_of(src.layout.ty.builtin_deref(true).unwrap().ty)?;\n         let (size, align) = (layout.size, layout.align.abi);\n+        // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n+        // but no actual allocation can be big enough for the difference to be noticeable.\n         let size = size.checked_mul(count, self).ok_or_else(|| {\n             err_ub_format!(\n                 \"overflow computing total size of `{}`\",\n@@ -588,6 +592,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let byte = self.read_scalar(&byte)?.to_u8()?;\n         let count = self.read_scalar(&count)?.to_machine_usize(self)?;\n \n+        // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n+        // but no actual allocation can be big enough for the difference to be noticeable.\n         let len = layout\n             .size\n             .checked_mul(count, self)"}, {"sha": "fc60a40e2ada6253881d91284c8fea91b833ae95", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -110,16 +110,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .read_ptr_sized(pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_SIZE).unwrap())?\n             .check_init()?;\n         let size = size.to_machine_usize(self)?;\n+        let size = Size::from_bytes(size);\n         let align = vtable\n             .read_ptr_sized(pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_ALIGN).unwrap())?\n             .check_init()?;\n         let align = align.to_machine_usize(self)?;\n         let align = Align::from_bytes(align).map_err(|e| err_ub!(InvalidVtableAlignment(e)))?;\n \n-        if size >= self.tcx.data_layout.obj_size_bound() {\n+        if size > self.max_size_of_val() {\n             throw_ub!(InvalidVtableSize);\n         }\n-        Ok((Size::from_bytes(size), align))\n+        Ok((size, align))\n     }\n \n     pub fn read_new_vtable_after_trait_upcasting_from_vtable("}, {"sha": "d915f9a5ae83c40e50304d5622890dcfda0c9a42", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -1091,7 +1091,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Compares two given types, eliding parts that are the same between them and highlighting\n     /// relevant differences, and return two representation of those types for highlighted printing.\n-    fn cmp(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> (DiagnosticStyledString, DiagnosticStyledString) {\n+    pub fn cmp(\n+        &self,\n+        t1: Ty<'tcx>,\n+        t2: Ty<'tcx>,\n+    ) -> (DiagnosticStyledString, DiagnosticStyledString) {\n         debug!(\"cmp(t1={}, t1.kind={:?}, t2={}, t2.kind={:?})\", t1, t1.kind(), t2, t2.kind());\n \n         // helper functions"}, {"sha": "813c0912f539679db80f57d1ec455580c0ccb1de", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -18,6 +18,11 @@ pub trait PointerArithmetic: HasDataLayout {\n         self.data_layout().pointer_size\n     }\n \n+    #[inline(always)]\n+    fn max_size_of_val(&self) -> Size {\n+        Size::from_bytes(self.machine_isize_max())\n+    }\n+\n     #[inline]\n     fn machine_usize_max(&self) -> u64 {\n         self.pointer_size().unsigned_int_max().try_into().unwrap()"}, {"sha": "3bddf7fb6ffc4c9daa6d090a0db08418d13081eb", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -119,9 +119,21 @@ impl<'tcx> ClosureKind {\n     /// See `Ty::to_opt_closure_kind` for more details.\n     pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self {\n-            ty::ClosureKind::Fn => tcx.types.i8,\n-            ty::ClosureKind::FnMut => tcx.types.i16,\n-            ty::ClosureKind::FnOnce => tcx.types.i32,\n+            ClosureKind::Fn => tcx.types.i8,\n+            ClosureKind::FnMut => tcx.types.i16,\n+            ClosureKind::FnOnce => tcx.types.i32,\n+        }\n+    }\n+\n+    pub fn from_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ClosureKind> {\n+        if Some(def_id) == tcx.lang_items().fn_once_trait() {\n+            Some(ClosureKind::FnOnce)\n+        } else if Some(def_id) == tcx.lang_items().fn_mut_trait() {\n+            Some(ClosureKind::FnMut)\n+        } else if Some(def_id) == tcx.lang_items().fn_trait() {\n+            Some(ClosureKind::Fn)\n+        } else {\n+            None\n         }\n     }\n }"}, {"sha": "20d035fba195a7219e62568ae977841e9fc9d51f", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -1919,17 +1919,13 @@ impl<'a> Parser<'a> {\n         match snapshot.parse_array_or_repeat_expr(attrs, token::Brace) {\n             Ok(arr) => {\n                 let hi = snapshot.prev_token.span;\n-                self.struct_span_err(\n-                    arr.span,\n-                    \"this code is interpreted as a block expression, not an array\",\n-                )\n-                .multipart_suggestion(\n-                    \"try using [] instead of {}\",\n-                    vec![(lo, \"[\".to_owned()), (hi, \"]\".to_owned())],\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .note(\"to define an array, one would use square brackets instead of curly braces\")\n-                .emit();\n+                self.struct_span_err(arr.span, \"this is a block expression, not an array\")\n+                    .multipart_suggestion(\n+                        \"to make an array, use square brackets instead of curly braces\",\n+                        vec![(lo, \"[\".to_owned()), (hi, \"]\".to_owned())],\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit();\n \n                 self.restore_snapshot(snapshot);\n                 Some(self.mk_expr_err(arr.span))"}, {"sha": "727847968e53a71034b5270b57579f84aba6bdeb", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 121, "deletions": 5, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -2,10 +2,10 @@ pub mod on_unimplemented;\n pub mod suggestions;\n \n use super::{\n-    EvaluationResult, FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes,\n-    Obligation, ObligationCause, ObligationCauseCode, OnUnimplementedDirective,\n-    OnUnimplementedNote, OutputTypeParameterMismatch, Overflow, PredicateObligation,\n-    SelectionContext, SelectionError, TraitNotObjectSafe,\n+    EvaluationResult, FulfillmentContext, FulfillmentError, FulfillmentErrorCode,\n+    MismatchedProjectionTypes, Obligation, ObligationCause, ObligationCauseCode,\n+    OnUnimplementedDirective, OnUnimplementedNote, OutputTypeParameterMismatch, Overflow,\n+    PredicateObligation, SelectionContext, SelectionError, TraitNotObjectSafe,\n };\n \n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n@@ -21,6 +21,8 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::GenericParam;\n use rustc_hir::Item;\n use rustc_hir::Node;\n+use rustc_infer::infer::error_reporting::same_type_modulo_infer;\n+use rustc_infer::traits::TraitEngine;\n use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::error::ExpectedFound;\n@@ -103,6 +105,17 @@ pub trait InferCtxtExt<'tcx> {\n         found_args: Vec<ArgKind>,\n         is_closure: bool,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>;\n+\n+    /// Checks if the type implements one of `Fn`, `FnMut`, or `FnOnce`\n+    /// in that order, and returns the generic type corresponding to the\n+    /// argument of that trait (corresponding to the closure arguments).\n+    fn type_implements_fn_trait(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: ty::Binder<'tcx, Ty<'tcx>>,\n+        constness: ty::BoundConstness,\n+        polarity: ty::ImplPolarity,\n+    ) -> Result<(ty::ClosureKind, ty::Binder<'tcx, Ty<'tcx>>), ()>;\n }\n \n impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n@@ -563,7 +576,64 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n \n                         // Try to report a help message\n-                        if !trait_ref.has_infer_types_or_consts()\n+                        if is_fn_trait\n+                            && let Ok((implemented_kind, params)) = self.type_implements_fn_trait(\n+                                obligation.param_env,\n+                                trait_ref.self_ty(),\n+                                trait_predicate.skip_binder().constness,\n+                                trait_predicate.skip_binder().polarity,\n+                            )\n+                        {\n+                            // If the type implements `Fn`, `FnMut`, or `FnOnce`, suppress the following\n+                            // suggestion to add trait bounds for the type, since we only typically implement\n+                            // these traits once.\n+\n+                            // Note if the `FnMut` or `FnOnce` is less general than the trait we're trying\n+                            // to implement.\n+                            let selected_kind =\n+                                ty::ClosureKind::from_def_id(self.tcx, trait_ref.def_id())\n+                                    .expect(\"expected to map DefId to ClosureKind\");\n+                            if !implemented_kind.extends(selected_kind) {\n+                                err.note(\n+                                    &format!(\n+                                        \"`{}` implements `{}`, but it must implement `{}`, which is more general\",\n+                                        trait_ref.skip_binder().self_ty(),\n+                                        implemented_kind,\n+                                        selected_kind\n+                                    )\n+                                );\n+                            }\n+\n+                            // Note any argument mismatches\n+                            let given_ty = params.skip_binder();\n+                            let expected_ty = trait_ref.skip_binder().substs.type_at(1);\n+                            if let ty::Tuple(given) = given_ty.kind()\n+                                && let ty::Tuple(expected) = expected_ty.kind()\n+                            {\n+                                if expected.len() != given.len() {\n+                                    // Note number of types that were expected and given\n+                                    err.note(\n+                                        &format!(\n+                                            \"expected a closure taking {} argument{}, but one taking {} argument{} was given\",\n+                                            given.len(),\n+                                            if given.len() == 1 { \"\" } else { \"s\" },\n+                                            expected.len(),\n+                                            if expected.len() == 1 { \"\" } else { \"s\" },\n+                                        )\n+                                    );\n+                                } else if !same_type_modulo_infer(given_ty, expected_ty) {\n+                                    // Print type mismatch\n+                                    let (expected_args, given_args) =\n+                                        self.cmp(given_ty, expected_ty);\n+                                    err.note_expected_found(\n+                                        &\"a closure with arguments\",\n+                                        expected_args,\n+                                        &\"a closure with arguments\",\n+                                        given_args,\n+                                    );\n+                                }\n+                            }\n+                        } else if !trait_ref.has_infer_types_or_consts()\n                             && self.predicate_can_apply(obligation.param_env, trait_ref)\n                         {\n                             // If a where-clause may be useful, remind the\n@@ -1148,6 +1218,52 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         err\n     }\n+\n+    fn type_implements_fn_trait(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: ty::Binder<'tcx, Ty<'tcx>>,\n+        constness: ty::BoundConstness,\n+        polarity: ty::ImplPolarity,\n+    ) -> Result<(ty::ClosureKind, ty::Binder<'tcx, Ty<'tcx>>), ()> {\n+        self.commit_if_ok(|_| {\n+            for trait_def_id in [\n+                self.tcx.lang_items().fn_trait(),\n+                self.tcx.lang_items().fn_mut_trait(),\n+                self.tcx.lang_items().fn_once_trait(),\n+            ] {\n+                let Some(trait_def_id) = trait_def_id else { continue };\n+                // Make a fresh inference variable so we can determine what the substitutions\n+                // of the trait are.\n+                let var = self.next_ty_var(TypeVariableOrigin {\n+                    span: DUMMY_SP,\n+                    kind: TypeVariableOriginKind::MiscVariable,\n+                });\n+                let substs = self.tcx.mk_substs_trait(ty.skip_binder(), &[var.into()]);\n+                let obligation = Obligation::new(\n+                    ObligationCause::dummy(),\n+                    param_env,\n+                    ty.rebind(ty::TraitPredicate {\n+                        trait_ref: ty::TraitRef::new(trait_def_id, substs),\n+                        constness,\n+                        polarity,\n+                    })\n+                    .to_predicate(self.tcx),\n+                );\n+                let mut fulfill_cx = FulfillmentContext::new_in_snapshot();\n+                fulfill_cx.register_predicate_obligation(self, obligation);\n+                if fulfill_cx.select_all_or_error(self).is_empty() {\n+                    return Ok((\n+                        ty::ClosureKind::from_def_id(self.tcx, trait_def_id)\n+                            .expect(\"expected to map DefId to ClosureKind\"),\n+                        ty.rebind(self.resolve_vars_if_possible(var)),\n+                    ));\n+                }\n+            }\n+\n+            Err(())\n+        })\n+    }\n }\n \n trait InferCtxtPrivExt<'hir, 'tcx> {"}, {"sha": "00bc16452b9b9e741c001de5a867b1bc4179ae13", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -39,6 +39,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.suggest_no_capture_closure(err, expected, expr_ty);\n         self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty);\n         self.suggest_missing_parentheses(err, expr);\n+        self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n         self.report_closure_inferred_return_type(err, expected);"}, {"sha": "2a1b7a5ab47ba6f696adb1293813718acb549987", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 80, "deletions": 65, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -774,57 +774,68 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let prev_diverges = self.diverges.get();\n         let ctxt = BreakableCtxt { coerce: Some(coerce), may_break: false };\n \n-        let (ctxt, ()) =\n-            self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n-                for (pos, s) in blk.stmts.iter().enumerate() {\n-                    self.check_stmt(s, blk.stmts.len() - 1 == pos);\n-                }\n+        let (ctxt, ()) = self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n+            for (pos, s) in blk.stmts.iter().enumerate() {\n+                self.check_stmt(s, blk.stmts.len() - 1 == pos);\n+            }\n \n-                // check the tail expression **without** holding the\n-                // `enclosing_breakables` lock below.\n-                let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n-\n-                let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n-                let coerce = ctxt.coerce.as_mut().unwrap();\n-                if let Some(tail_expr_ty) = tail_expr_ty {\n-                    let tail_expr = tail_expr.unwrap();\n-                    let span = self.get_expr_coercion_span(tail_expr);\n-                    let cause =\n-                        self.cause(span, ObligationCauseCode::BlockTailExpression(blk.hir_id));\n-                    coerce.coerce(self, &cause, tail_expr, tail_expr_ty);\n-                } else {\n-                    // Subtle: if there is no explicit tail expression,\n-                    // that is typically equivalent to a tail expression\n-                    // of `()` -- except if the block diverges. In that\n-                    // case, there is no value supplied from the tail\n-                    // expression (assuming there are no other breaks,\n-                    // this implies that the type of the block will be\n-                    // `!`).\n-                    //\n-                    // #41425 -- label the implicit `()` as being the\n-                    // \"found type\" here, rather than the \"expected type\".\n-                    if !self.diverges.get().is_always() {\n-                        // #50009 -- Do not point at the entire fn block span, point at the return type\n-                        // span, as it is the cause of the requirement, and\n-                        // `consider_hint_about_removing_semicolon` will point at the last expression\n-                        // if it were a relevant part of the error. This improves usability in editors\n-                        // that highlight errors inline.\n-                        let mut sp = blk.span;\n-                        let mut fn_span = None;\n-                        if let Some((decl, ident)) = self.get_parent_fn_decl(blk.hir_id) {\n-                            let ret_sp = decl.output.span();\n-                            if let Some(block_sp) = self.parent_item_span(blk.hir_id) {\n-                                // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n-                                // output would otherwise be incorrect and even misleading. Make sure\n-                                // the span we're aiming at correspond to a `fn` body.\n-                                if block_sp == blk.span {\n-                                    sp = ret_sp;\n-                                    fn_span = Some(ident.span);\n-                                }\n+            // check the tail expression **without** holding the\n+            // `enclosing_breakables` lock below.\n+            let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n+\n+            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+            let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n+            let coerce = ctxt.coerce.as_mut().unwrap();\n+            if let Some(tail_expr_ty) = tail_expr_ty {\n+                let tail_expr = tail_expr.unwrap();\n+                let span = self.get_expr_coercion_span(tail_expr);\n+                let cause = self.cause(span, ObligationCauseCode::BlockTailExpression(blk.hir_id));\n+                let ty_for_diagnostic = coerce.merged_ty();\n+                // We use coerce_inner here because we want to augment the error\n+                // suggesting to wrap the block in square brackets if it might've\n+                // been mistaken array syntax\n+                coerce.coerce_inner(\n+                    self,\n+                    &cause,\n+                    Some(tail_expr),\n+                    tail_expr_ty,\n+                    Some(&mut |diag: &mut Diagnostic| {\n+                        self.suggest_block_to_brackets(diag, blk, tail_expr_ty, ty_for_diagnostic);\n+                    }),\n+                    false,\n+                );\n+            } else {\n+                // Subtle: if there is no explicit tail expression,\n+                // that is typically equivalent to a tail expression\n+                // of `()` -- except if the block diverges. In that\n+                // case, there is no value supplied from the tail\n+                // expression (assuming there are no other breaks,\n+                // this implies that the type of the block will be\n+                // `!`).\n+                //\n+                // #41425 -- label the implicit `()` as being the\n+                // \"found type\" here, rather than the \"expected type\".\n+                if !self.diverges.get().is_always() {\n+                    // #50009 -- Do not point at the entire fn block span, point at the return type\n+                    // span, as it is the cause of the requirement, and\n+                    // `consider_hint_about_removing_semicolon` will point at the last expression\n+                    // if it were a relevant part of the error. This improves usability in editors\n+                    // that highlight errors inline.\n+                    let mut sp = blk.span;\n+                    let mut fn_span = None;\n+                    if let Some((decl, ident)) = self.get_parent_fn_decl(blk.hir_id) {\n+                        let ret_sp = decl.output.span();\n+                        if let Some(block_sp) = self.parent_item_span(blk.hir_id) {\n+                            // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n+                            // output would otherwise be incorrect and even misleading. Make sure\n+                            // the span we're aiming at correspond to a `fn` body.\n+                            if block_sp == blk.span {\n+                                sp = ret_sp;\n+                                fn_span = Some(ident.span);\n                             }\n                         }\n-                        coerce.coerce_forced_unit(\n+                    }\n+                    coerce.coerce_forced_unit(\n                         self,\n                         &self.misc(sp),\n                         &mut |err| {\n@@ -837,21 +848,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     // Our block must be a `assign desugar local; assignment`\n                                     if let Some(hir::Node::Block(hir::Block {\n                                         stmts:\n-                                            [hir::Stmt {\n-                                                kind:\n-                                                    hir::StmtKind::Local(hir::Local {\n-                                                        source: hir::LocalSource::AssignDesugar(_),\n-                                                        ..\n-                                                    }),\n-                                                ..\n-                                            }, hir::Stmt {\n-                                                kind:\n-                                                    hir::StmtKind::Expr(hir::Expr {\n-                                                        kind: hir::ExprKind::Assign(..),\n-                                                        ..\n-                                                    }),\n-                                                ..\n-                                            }],\n+                                            [\n+                                                hir::Stmt {\n+                                                    kind:\n+                                                        hir::StmtKind::Local(hir::Local {\n+                                                            source:\n+                                                                hir::LocalSource::AssignDesugar(_),\n+                                                            ..\n+                                                        }),\n+                                                    ..\n+                                                },\n+                                                hir::Stmt {\n+                                                    kind:\n+                                                        hir::StmtKind::Expr(hir::Expr {\n+                                                            kind: hir::ExprKind::Assign(..),\n+                                                            ..\n+                                                        }),\n+                                                    ..\n+                                                },\n+                                            ],\n                                         ..\n                                     })) = self.tcx.hir().find(blk.hir_id)\n                                     {\n@@ -871,9 +886,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         },\n                         false,\n                     );\n-                    }\n                 }\n-            });\n+            }\n+        });\n \n         if ctxt.may_break {\n             // If we can break from the block, then the block's exit is always reachable"}, {"sha": "68d555b3a651d224a2dbb0f16592b916aed2d0b2", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -766,6 +766,77 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Given an expression type mismatch, peel any `&` expressions until we get to\n+    /// a block expression, and then suggest replacing the braces with square braces\n+    /// if it was possibly mistaken array syntax.\n+    pub(crate) fn suggest_block_to_brackets_peeling_refs(\n+        &self,\n+        diag: &mut Diagnostic,\n+        mut expr: &hir::Expr<'_>,\n+        mut expr_ty: Ty<'tcx>,\n+        mut expected_ty: Ty<'tcx>,\n+    ) {\n+        loop {\n+            match (&expr.kind, expr_ty.kind(), expected_ty.kind()) {\n+                (\n+                    hir::ExprKind::AddrOf(_, _, inner_expr),\n+                    ty::Ref(_, inner_expr_ty, _),\n+                    ty::Ref(_, inner_expected_ty, _),\n+                ) => {\n+                    expr = *inner_expr;\n+                    expr_ty = *inner_expr_ty;\n+                    expected_ty = *inner_expected_ty;\n+                }\n+                (hir::ExprKind::Block(blk, _), _, _) => {\n+                    self.suggest_block_to_brackets(diag, *blk, expr_ty, expected_ty);\n+                    break;\n+                }\n+                _ => break,\n+            }\n+        }\n+    }\n+\n+    /// Suggest wrapping the block in square brackets instead of curly braces\n+    /// in case the block was mistaken array syntax, e.g. `{ 1 }` -> `[ 1 ]`.\n+    pub(crate) fn suggest_block_to_brackets(\n+        &self,\n+        diag: &mut Diagnostic,\n+        blk: &hir::Block<'_>,\n+        blk_ty: Ty<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) {\n+        if let ty::Slice(elem_ty) | ty::Array(elem_ty, _) = expected_ty.kind() {\n+            if self.can_coerce(blk_ty, *elem_ty)\n+                && blk.stmts.is_empty()\n+                && blk.rules == hir::BlockCheckMode::DefaultBlock\n+            {\n+                let source_map = self.tcx.sess.source_map();\n+                if let Ok(snippet) = source_map.span_to_snippet(blk.span) {\n+                    if snippet.starts_with('{') && snippet.ends_with('}') {\n+                        diag.multipart_suggestion_verbose(\n+                            \"to create an array, use square brackets instead of curly braces\",\n+                            vec![\n+                                (\n+                                    blk.span\n+                                        .shrink_to_lo()\n+                                        .with_hi(rustc_span::BytePos(blk.span.lo().0 + 1)),\n+                                    \"[\".to_string(),\n+                                ),\n+                                (\n+                                    blk.span\n+                                        .shrink_to_hi()\n+                                        .with_lo(rustc_span::BytePos(blk.span.hi().0 - 1)),\n+                                    \"]\".to_string(),\n+                                ),\n+                            ],\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn is_loop(&self, id: hir::HirId) -> bool {\n         let node = self.tcx.hir().get(id);\n         matches!(node, Node::Expr(Expr { kind: ExprKind::Loop(..), .. }))"}, {"sha": "819ec10a4b4b65c0caa682989a5054543d7b1f0d", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 74, "deletions": 63, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -218,111 +218,122 @@\n     feature(slice_index_methods, coerce_unsized, sgx_platform)\n )]\n #![deny(rustc::existing_doc_keyword)]\n-// std is implemented with unstable features, many of which are internal\n-// compiler details that will never be stable\n-// NB: the following list is sorted to minimize merge conflicts.\n+//\n+// Language features:\n #![feature(alloc_error_handler)]\n-#![feature(alloc_layout_extra)]\n-#![feature(allocator_api)]\n #![feature(allocator_internals)]\n #![feature(allow_internal_unsafe)]\n #![feature(allow_internal_unstable)]\n-#![feature(array_error_internals)]\n-#![feature(assert_matches)]\n #![feature(associated_type_bounds)]\n-#![feature(async_iterator)]\n-#![feature(atomic_mut_ptr)]\n-#![feature(bench_black_box)]\n #![feature(box_syntax)]\n #![feature(c_unwind)]\n-#![feature(c_variadic)]\n-#![feature(cfg_accessible)]\n-#![feature(cfg_eval)]\n #![feature(cfg_target_thread_local)]\n-#![feature(char_error_internals)]\n-#![feature(char_internals)]\n-#![feature(concat_bytes)]\n #![feature(concat_idents)]\n #![cfg_attr(bootstrap, feature(const_fn_fn_ptr_basics))]\n #![cfg_attr(bootstrap, feature(const_fn_trait_bound))]\n-#![feature(const_format_args)]\n-#![feature(const_io_structs)]\n-#![feature(const_ip)]\n-#![feature(const_ipv4)]\n-#![feature(const_ipv6)]\n #![feature(const_mut_refs)]\n-#![feature(const_option)]\n-#![feature(const_socketaddr)]\n #![feature(const_trait_impl)]\n-#![feature(c_size_t)]\n-#![feature(core_ffi_c)]\n-#![feature(core_intrinsics)]\n-#![feature(core_panic)]\n-#![feature(custom_test_frameworks)]\n #![feature(decl_macro)]\n+#![cfg_attr(not(bootstrap), feature(deprecated_suggestion))]\n #![feature(doc_cfg)]\n #![feature(doc_cfg_hide)]\n-#![feature(rustdoc_internals)]\n-#![cfg_attr(not(bootstrap), feature(deprecated_suggestion))]\n #![feature(doc_masked)]\n #![feature(doc_notable_trait)]\n #![feature(dropck_eyepatch)]\n-#![feature(duration_checked_float)]\n-#![feature(duration_constants)]\n-#![feature(edition_panic)]\n-#![feature(exact_size_is_empty)]\n #![feature(exhaustive_patterns)]\n-#![feature(extend_one)]\n-#![feature(float_minimum_maximum)]\n-#![feature(format_args_nl)]\n-#![feature(strict_provenance)]\n-#![feature(get_mut_unchecked)]\n-#![feature(hashmap_internals)]\n-#![feature(int_error_internals)]\n #![feature(intra_doc_pointers)]\n #![feature(lang_items)]\n #![feature(linkage)]\n-#![feature(log_syntax)]\n-#![feature(map_try_insert)]\n-#![feature(maybe_uninit_slice)]\n-#![feature(maybe_uninit_write_slice)]\n #![feature(min_specialization)]\n-#![feature(mixed_integer_ops)]\n #![feature(must_not_suspend)]\n #![feature(needs_panic_runtime)]\n #![feature(negative_impls)]\n #![feature(never_type)]\n-#![feature(new_uninit)]\n #![feature(nll)]\n+#![feature(platform_intrinsics)]\n+#![feature(prelude_import)]\n+#![feature(rustc_attrs)]\n+#![feature(rustdoc_internals)]\n+#![feature(staged_api)]\n+#![feature(thread_local)]\n+#![feature(try_blocks)]\n+//\n+// Library features (core):\n+#![feature(array_error_internals)]\n+#![feature(atomic_mut_ptr)]\n+#![feature(char_error_internals)]\n+#![feature(char_internals)]\n+#![feature(core_intrinsics)]\n+#![feature(duration_checked_float)]\n+#![feature(duration_constants)]\n+#![feature(exact_size_is_empty)]\n+#![feature(extend_one)]\n+#![feature(float_minimum_maximum)]\n+#![feature(hashmap_internals)]\n+#![feature(int_error_internals)]\n+#![feature(maybe_uninit_slice)]\n+#![feature(maybe_uninit_write_slice)]\n+#![feature(mixed_integer_ops)]\n #![feature(nonnull_slice_from_raw_parts)]\n-#![feature(once_cell)]\n+#![feature(panic_can_unwind)]\n #![feature(panic_info_message)]\n #![feature(panic_internals)]\n-#![feature(panic_can_unwind)]\n-#![feature(panic_unwind)]\n-#![feature(platform_intrinsics)]\n #![feature(portable_simd)]\n-#![feature(prelude_import)]\n #![feature(ptr_as_uninit)]\n #![feature(raw_os_nonzero)]\n-#![feature(rustc_attrs)]\n-#![feature(saturating_int_impl)]\n #![feature(slice_internals)]\n #![feature(slice_ptr_get)]\n-#![feature(staged_api)]\n #![feature(std_internals)]\n-#![feature(stdsimd)]\n #![feature(str_internals)]\n-#![feature(test)]\n-#![feature(thread_local)]\n-#![feature(thread_local_internals)]\n-#![feature(toowned_clone_into)]\n+#![feature(strict_provenance)]\n #![feature(total_cmp)]\n-#![feature(trace_macros)]\n-#![feature(try_blocks)]\n+//\n+// Library features (alloc):\n+#![feature(alloc_layout_extra)]\n+#![feature(allocator_api)]\n+#![feature(get_mut_unchecked)]\n+#![feature(map_try_insert)]\n+#![feature(new_uninit)]\n+#![feature(toowned_clone_into)]\n #![feature(try_reserve_kind)]\n #![feature(vec_into_raw_parts)]\n-// NB: the above list is sorted to minimize merge conflicts.\n+//\n+// Library features (unwind):\n+#![feature(panic_unwind)]\n+//\n+// Only for re-exporting:\n+#![feature(assert_matches)]\n+#![feature(async_iterator)]\n+#![feature(c_size_t)]\n+#![feature(c_variadic)]\n+#![feature(cfg_accessible)]\n+#![feature(cfg_eval)]\n+#![feature(concat_bytes)]\n+#![feature(const_format_args)]\n+#![feature(core_ffi_c)]\n+#![feature(core_panic)]\n+#![feature(custom_test_frameworks)]\n+#![feature(edition_panic)]\n+#![feature(format_args_nl)]\n+#![feature(log_syntax)]\n+#![feature(once_cell)]\n+#![feature(saturating_int_impl)]\n+#![feature(stdsimd)]\n+#![feature(test)]\n+#![feature(trace_macros)]\n+//\n+// Only used in tests/benchmarks:\n+#![feature(bench_black_box)]\n+//\n+// Only for const-ness:\n+#![feature(const_io_structs)]\n+#![feature(const_ip)]\n+#![feature(const_ipv4)]\n+#![feature(const_ipv6)]\n+#![feature(const_option)]\n+#![feature(const_socketaddr)]\n+#![feature(thread_local_internals)]\n+//\n #![default_lib_allocator]\n \n // Explicitly import the prelude. The compiler uses this same unstable attribute"}, {"sha": "7698c2de24d5c8d9e3b21b6c2d02a07aec0b1252", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -1,5 +1,6 @@\n use std::cell::RefCell;\n use std::default::Default;\n+use std::fmt;\n use std::hash::Hash;\n use std::iter;\n use std::lazy::SyncOnceCell as OnceCell;\n@@ -355,7 +356,7 @@ crate enum ExternalLocation {\n /// Anything with a source location and set of attributes and, optionally, a\n /// name. That is, anything that can be documented. This doesn't correspond\n /// directly to the AST's concept of an item; it's a strict superset.\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n crate struct Item {\n     /// The name of this item.\n     /// Optional because not every item has a name, e.g. impls.\n@@ -370,6 +371,27 @@ crate struct Item {\n     crate cfg: Option<Arc<Cfg>>,\n }\n \n+/// NOTE: this does NOT unconditionally print every item, to avoid thousands of lines of logs.\n+/// If you want to see the debug output for attributes and the `kind` as well, use `{:#?}` instead of `{:?}`.\n+impl fmt::Debug for Item {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let alternate = f.alternate();\n+        // hand-picked fields that don't bloat the logs too much\n+        let mut fmt = f.debug_struct(\"Item\");\n+        fmt.field(\"name\", &self.name)\n+            .field(\"visibility\", &self.visibility)\n+            .field(\"def_id\", &self.def_id);\n+        // allow printing the full item if someone really wants to\n+        if alternate {\n+            fmt.field(\"attrs\", &self.attrs).field(\"kind\", &self.kind).field(\"cfg\", &self.cfg);\n+        } else {\n+            fmt.field(\"kind\", &self.type_());\n+            fmt.field(\"docs\", &self.doc_value());\n+        }\n+        fmt.finish()\n+    }\n+}\n+\n // `Item` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Item, 56);\n@@ -471,14 +493,17 @@ impl Item {\n     ) -> Item {\n         trace!(\"name={:?}, def_id={:?}\", name, def_id);\n \n-        Item {\n-            def_id: def_id.into(),\n-            kind: box kind,\n-            name,\n-            attrs,\n-            visibility: cx.tcx.visibility(def_id).clean(cx),\n-            cfg,\n-        }\n+        // Primitives and Keywords are written in the source code as private modules.\n+        // The modules need to be private so that nobody actually uses them, but the\n+        // keywords and primitives that they are documenting are public.\n+        let visibility = if matches!(&kind, ItemKind::KeywordItem(..) | ItemKind::PrimitiveItem(..))\n+        {\n+            Visibility::Public\n+        } else {\n+            cx.tcx.visibility(def_id).clean(cx)\n+        };\n+\n+        Item { def_id: def_id.into(), kind: box kind, name, attrs, visibility, cfg }\n     }\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined"}, {"sha": "1cebe4c6797703667ec1f944bc2e92a71da3fd85", "filename": "src/test/rustdoc/keyword.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Frustdoc%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Frustdoc%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fkeyword.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -12,6 +12,7 @@\n // @has foo/index.html '//a/@href' '../foo/index.html'\n // @!has foo/foo/index.html\n // @!has-dir foo/foo\n+// @!has foo/index.html '//span' '\ud83d\udd12'\n #[doc(keyword = \"match\")]\n /// this is a test!\n mod foo{}"}, {"sha": "605ca4d170b39d7088f1c9d41951e22c9ef09888", "filename": "src/test/rustdoc/primitive.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Frustdoc%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Frustdoc%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -0,0 +1,21 @@\n+#![crate_name = \"foo\"]\n+\n+#![feature(rustdoc_internals)]\n+\n+// @has foo/index.html '//h2[@id=\"primitives\"]' 'Primitive Types'\n+// @has foo/index.html '//a[@href=\"primitive.i32.html\"]' 'i32'\n+// @has foo/index.html '//div[@class=\"sidebar-elems\"]//li/a' 'Primitive Types'\n+// @has foo/index.html '//div[@class=\"sidebar-elems\"]//li/a/@href' '#primitives'\n+// @has foo/primitive.i32.html '//a[@class=\"primitive\"]' 'i32'\n+// @has foo/primitive.i32.html '//span[@class=\"in-band\"]' 'Primitive Type i32'\n+// @has foo/primitive.i32.html '//section[@id=\"main-content\"]//div[@class=\"docblock\"]//p' 'this is a test!'\n+// @has foo/index.html '//a/@href' '../foo/index.html'\n+// @!has foo/index.html '//span' '\ud83d\udd12'\n+#[doc(primitive = \"i32\")]\n+/// this is a test!\n+mod i32{}\n+\n+// @has foo/primitive.bool.html '//section[@id=\"main-content\"]//div[@class=\"docblock\"]//p' 'hello'\n+#[doc(primitive = \"bool\")]\n+/// hello\n+mod bool {}"}, {"sha": "46901bd3b9b349b378b0e0c164d8d87e0d534d9b", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.32bit.stderr", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -104,6 +104,17 @@ LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:71:1\n    |\n+LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257e\u2500allocN\u2500\u257c ff ff ff 7f                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:74:1\n+   |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n@@ -113,7 +124,7 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:74:1\n+  --> $DIR/ub-wide-ptr.rs:77:1\n    |\n LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (going beyond the bounds of its allocation)\n@@ -124,7 +135,7 @@ LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999us\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:77:1\n+  --> $DIR/ub-wide-ptr.rs:80:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n@@ -135,7 +146,7 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:81:1\n+  --> $DIR/ub-wide-ptr.rs:84:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>[0]: encountered 0x03, but expected a boolean\n@@ -146,29 +157,29 @@ LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:87:1\n+  --> $DIR/ub-wide-ptr.rs:90:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.0: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500allocN\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257eallocN\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:90:1\n+  --> $DIR/ub-wide-ptr.rs:93:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.1[0]: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500allocN\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257eallocN\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:97:1\n+  --> $DIR/ub-wide-ptr.rs:100:1\n    |\n LL | / const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n LL | |\n@@ -183,7 +194,7 @@ LL | | };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:105:1\n+  --> $DIR/ub-wide-ptr.rs:108:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered too small vtable\n@@ -194,7 +205,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:108:1\n+  --> $DIR/ub-wide-ptr.rs:111:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered too small vtable\n@@ -205,7 +216,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:111:1\n+  --> $DIR/ub-wide-ptr.rs:114:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered dangling vtable pointer in wide pointer\n@@ -216,7 +227,7 @@ LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:113:1\n+  --> $DIR/ub-wide-ptr.rs:116:1\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered unaligned vtable pointer in wide pointer\n@@ -227,7 +238,7 @@ LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:115:1\n+  --> $DIR/ub-wide-ptr.rs:118:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -238,7 +249,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:117:1\n+  --> $DIR/ub-wide-ptr.rs:120:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -249,7 +260,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:119:1\n+  --> $DIR/ub-wide-ptr.rs:122:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -260,7 +271,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::trans\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:123:1\n+  --> $DIR/ub-wide-ptr.rs:126:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n@@ -271,7 +282,7 @@ LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_,\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:127:1\n+  --> $DIR/ub-wide-ptr.rs:130:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling vtable pointer in wide pointer\n@@ -282,7 +293,7 @@ LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:129:1\n+  --> $DIR/ub-wide-ptr.rs:132:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered too small vtable\n@@ -293,17 +304,17 @@ LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transm\n            }\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:135:5\n+  --> $DIR/ub-wide-ptr.rs:138:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: null pointer is not a valid pointer\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:139:5\n+  --> $DIR/ub-wide-ptr.rs:142:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: allocN has size N, so pointer to 12 bytes starting at offset N is out-of-bounds\n \n-error: aborting due to 28 previous errors\n+error: aborting due to 29 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "b76f88928678ae8ffffdd1ffd40e8479c6314e9a", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.64bit.stderr", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -104,6 +104,17 @@ LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:71:1\n    |\n+LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c ff ff ff ff ff ff ff 7f \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:74:1\n+   |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n@@ -113,7 +124,7 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:74:1\n+  --> $DIR/ub-wide-ptr.rs:77:1\n    |\n LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (going beyond the bounds of its allocation)\n@@ -124,7 +135,7 @@ LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999us\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:77:1\n+  --> $DIR/ub-wide-ptr.rs:80:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n@@ -135,7 +146,7 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:81:1\n+  --> $DIR/ub-wide-ptr.rs:84:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>[0]: encountered 0x03, but expected a boolean\n@@ -146,29 +157,29 @@ LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:87:1\n+  --> $DIR/ub-wide-ptr.rs:90:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.0: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:90:1\n+  --> $DIR/ub-wide-ptr.rs:93:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.1[0]: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:97:1\n+  --> $DIR/ub-wide-ptr.rs:100:1\n    |\n LL | / const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n LL | |\n@@ -183,7 +194,7 @@ LL | | };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:105:1\n+  --> $DIR/ub-wide-ptr.rs:108:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered too small vtable\n@@ -194,7 +205,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:108:1\n+  --> $DIR/ub-wide-ptr.rs:111:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered too small vtable\n@@ -205,7 +216,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:111:1\n+  --> $DIR/ub-wide-ptr.rs:114:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered dangling vtable pointer in wide pointer\n@@ -216,7 +227,7 @@ LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:113:1\n+  --> $DIR/ub-wide-ptr.rs:116:1\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered unaligned vtable pointer in wide pointer\n@@ -227,7 +238,7 @@ LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:115:1\n+  --> $DIR/ub-wide-ptr.rs:118:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -238,7 +249,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:117:1\n+  --> $DIR/ub-wide-ptr.rs:120:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -249,7 +260,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:119:1\n+  --> $DIR/ub-wide-ptr.rs:122:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -260,7 +271,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::trans\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:123:1\n+  --> $DIR/ub-wide-ptr.rs:126:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n@@ -271,7 +282,7 @@ LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_,\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:127:1\n+  --> $DIR/ub-wide-ptr.rs:130:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling vtable pointer in wide pointer\n@@ -282,7 +293,7 @@ LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:129:1\n+  --> $DIR/ub-wide-ptr.rs:132:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered too small vtable\n@@ -293,17 +304,17 @@ LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transm\n            }\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:135:5\n+  --> $DIR/ub-wide-ptr.rs:138:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: null pointer is not a valid pointer\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:139:5\n+  --> $DIR/ub-wide-ptr.rs:142:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: allocN has size N, so pointer to 24 bytes starting at offset N is out-of-bounds\n \n-error: aborting due to 28 previous errors\n+error: aborting due to 29 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "ea48a095df95c53ab7f61a134147c80c63aa7ee9", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -67,6 +67,9 @@ const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n // bad slice: length too big\n const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n //~^ ERROR it is undefined behavior to use this value\n+// bad slice: length computation overflows\n+const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n+//~^ ERROR it is undefined behavior to use this value\n // bad slice: length not an int\n const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n //~^ ERROR it is undefined behavior to use this value"}, {"sha": "5a78313c483504849499f4a03719aab3a4b14011", "filename": "src/test/ui/consts/const-size_of_val-align_of_val.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of_val-align_of_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of_val-align_of_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of_val-align_of_val.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -2,8 +2,9 @@\n \n #![feature(const_size_of_val, const_align_of_val)]\n #![feature(const_size_of_val_raw, const_align_of_val_raw, layout_for_ptr)]\n+#![feature(const_slice_from_raw_parts)]\n \n-use std::mem;\n+use std::{mem, ptr};\n \n struct Foo(u32);\n \n@@ -34,6 +35,8 @@ const ALIGN_OF_UGH: usize = mem::align_of_val(&UGH);\n const SIZE_OF_SLICE: usize = mem::size_of_val(\"foobar\".as_bytes());\n \n const SIZE_OF_DANGLING: usize = unsafe { mem::size_of_val_raw(0x100 as *const i32) };\n+const SIZE_OF_BIG: usize =\n+    unsafe { mem::size_of_val_raw(ptr::slice_from_raw_parts(0 as *const u8, isize::MAX as usize)) };\n const ALIGN_OF_DANGLING: usize = unsafe { mem::align_of_val_raw(0x100 as *const i16) };\n \n fn main() {\n@@ -46,6 +49,7 @@ fn main() {\n     assert_eq!(ALIGN_OF_UGH, mem::align_of::<Ugh>());\n \n     assert_eq!(SIZE_OF_DANGLING, mem::size_of::<i32>());\n+    assert_eq!(SIZE_OF_BIG, isize::MAX as usize);\n     assert_eq!(ALIGN_OF_DANGLING, mem::align_of::<i16>());\n \n     assert_eq!(SIZE_OF_SLICE, \"foobar\".len());"}, {"sha": "4d0109767fc0f245813c943456d311869a639bb6", "filename": "src/test/ui/did_you_mean/brackets-to-braces-single-element.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fdid_you_mean%2Fbrackets-to-braces-single-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fdid_you_mean%2Fbrackets-to-braces-single-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbrackets-to-braces-single-element.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -0,0 +1,10 @@\n+const A: [&str; 1] = { \"hello\" };\n+//~^ ERROR mismatched types\n+\n+const B: &[u32] = &{ 1 };\n+//~^ ERROR mismatched types\n+\n+const C: &&[u32; 1] = &&{ 1 };\n+//~^ ERROR mismatched types\n+\n+fn main() {}"}, {"sha": "6ded03e45b55e9bc1e608468b533d0c9e83d02b0", "filename": "src/test/ui/did_you_mean/brackets-to-braces-single-element.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fdid_you_mean%2Fbrackets-to-braces-single-element.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fdid_you_mean%2Fbrackets-to-braces-single-element.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbrackets-to-braces-single-element.stderr?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -0,0 +1,38 @@\n+error[E0308]: mismatched types\n+  --> $DIR/brackets-to-braces-single-element.rs:1:24\n+   |\n+LL | const A: [&str; 1] = { \"hello\" };\n+   |                        ^^^^^^^ expected array `[&'static str; 1]`, found `&str`\n+   |\n+help: to create an array, use square brackets instead of curly braces\n+   |\n+LL | const A: [&str; 1] = [ \"hello\" ];\n+   |                      ~         ~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/brackets-to-braces-single-element.rs:4:19\n+   |\n+LL | const B: &[u32] = &{ 1 };\n+   |                   ^^^^^^ expected slice `[u32]`, found integer\n+   |\n+   = note: expected reference `&'static [u32]`\n+              found reference `&{integer}`\n+help: to create an array, use square brackets instead of curly braces\n+   |\n+LL | const B: &[u32] = &[ 1 ];\n+   |                    ~   ~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/brackets-to-braces-single-element.rs:7:27\n+   |\n+LL | const C: &&[u32; 1] = &&{ 1 };\n+   |                           ^ expected array `[u32; 1]`, found integer\n+   |\n+help: to create an array, use square brackets instead of curly braces\n+   |\n+LL | const C: &&[u32; 1] = &&[ 1 ];\n+   |                         ~   ~\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "070ffaa1eff00fb2bc0116b39df25924ca49070a", "filename": "src/test/ui/did_you_mean/issue-87830-try-brackets-for-arrays.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-87830-try-brackets-for-arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-87830-try-brackets-for-arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-87830-try-brackets-for-arrays.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -1,15 +1,16 @@\n fn main() {}\n \n-const FOO: [u8; 3] = { //~ ERROR this code is interpreted as a block expression\n+const FOO: [u8; 3] = {\n+    //~^ ERROR this is a block expression, not an array\n     1, 2, 3\n };\n \n const BAR: [&str; 3] = {\"one\", \"two\", \"three\"};\n-//~^ ERROR this code is interpreted as a block expression\n+//~^ ERROR this is a block expression, not an array\n \n fn foo() {\n     {1, 2, 3};\n-    //~^ ERROR this code is interpreted as a block expression\n+    //~^ ERROR this is a block expression, not an array\n }\n \n fn bar() {"}, {"sha": "d5ad1a72b8250444ba5cd6a9a7e97b38af8584fd", "filename": "src/test/ui/did_you_mean/issue-87830-try-brackets-for-arrays.stderr", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-87830-try-brackets-for-arrays.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-87830-try-brackets-for-arrays.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-87830-try-brackets-for-arrays.stderr?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -1,46 +1,45 @@\n-error: this code is interpreted as a block expression, not an array\n+error: this is a block expression, not an array\n   --> $DIR/issue-87830-try-brackets-for-arrays.rs:3:22\n    |\n LL |   const FOO: [u8; 3] = {\n    |  ______________________^\n+LL | |\n LL | |     1, 2, 3\n LL | | };\n    | |_^\n    |\n-   = note: to define an array, one would use square brackets instead of curly braces\n-help: try using [] instead of {}\n+help: to make an array, use square brackets instead of curly braces\n    |\n LL ~ const FOO: [u8; 3] = [\n+LL |\n LL |     1, 2, 3\n LL ~ ];\n    |\n \n-error: this code is interpreted as a block expression, not an array\n-  --> $DIR/issue-87830-try-brackets-for-arrays.rs:7:24\n+error: this is a block expression, not an array\n+  --> $DIR/issue-87830-try-brackets-for-arrays.rs:8:24\n    |\n LL | const BAR: [&str; 3] = {\"one\", \"two\", \"three\"};\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: to define an array, one would use square brackets instead of curly braces\n-help: try using [] instead of {}\n+help: to make an array, use square brackets instead of curly braces\n    |\n LL | const BAR: [&str; 3] = [\"one\", \"two\", \"three\"];\n    |                        ~                     ~\n \n-error: this code is interpreted as a block expression, not an array\n-  --> $DIR/issue-87830-try-brackets-for-arrays.rs:11:5\n+error: this is a block expression, not an array\n+  --> $DIR/issue-87830-try-brackets-for-arrays.rs:12:5\n    |\n LL |     {1, 2, 3};\n    |     ^^^^^^^^^\n    |\n-   = note: to define an array, one would use square brackets instead of curly braces\n-help: try using [] instead of {}\n+help: to make an array, use square brackets instead of curly braces\n    |\n LL |     [1, 2, 3];\n    |     ~       ~\n \n error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n-  --> $DIR/issue-87830-try-brackets-for-arrays.rs:16:6\n+  --> $DIR/issue-87830-try-brackets-for-arrays.rs:17:6\n    |\n LL |     1, 2, 3\n    |      ^ expected one of `.`, `;`, `?`, `}`, or an operator"}, {"sha": "066bf431a83d78e4ae21581ee887296f120b6eab", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-62529-3.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-62529-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-62529-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-62529-3.stderr?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -4,6 +4,8 @@ error[E0277]: expected a `Fn<(<_ as ATC<'a>>::Type,)>` closure, found `F`\n LL |         call(f, ());\n    |         ^^^^ expected an `Fn<(<_ as ATC<'a>>::Type,)>` closure, found `F`\n    |\n+   = note: expected a closure with arguments `((),)`\n+              found a closure with arguments `(<_ as ATC<'a>>::Type,)`\n note: required by a bound in `call`\n   --> $DIR/issue-62529-3.rs:9:36\n    |"}, {"sha": "8b542bb69de2ed1e7dadc06f28f3685c424f2796", "filename": "src/test/ui/issues/issue-59494.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fissues%2Fissue-59494.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Fissues%2Fissue-59494.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59494.stderr?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -7,6 +7,8 @@ LL |     let t8 = t8n(t7, t7p(f, g));\n    |              required by a bound introduced by this call\n    |\n    = help: the trait `Fn<(_,)>` is not implemented for `impl Fn(((_, _), _))`\n+   = note: expected a closure with arguments `(((_, _), _),)`\n+              found a closure with arguments `(_,)`\n note: required by a bound in `t8n`\n   --> $DIR/issue-59494.rs:5:45\n    |"}, {"sha": "0ed64043a9a56d78924254d355ed48a0493f80b4", "filename": "src/test/ui/trait-bounds/mismatch-fn-trait.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Ftrait-bounds%2Fmismatch-fn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Ftrait-bounds%2Fmismatch-fn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-bounds%2Fmismatch-fn-trait.rs?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -0,0 +1,28 @@\n+fn take(_f: impl FnMut(i32)) {}\n+\n+fn test1(f: impl FnMut(u32)) {\n+    take(f)\n+    //~^ ERROR [E0277]\n+}\n+\n+fn test2(f: impl FnMut(i32, i32)) {\n+    take(f)\n+    //~^ ERROR [E0277]\n+}\n+\n+fn test3(f: impl FnMut()) {\n+    take(f)\n+    //~^ ERROR [E0277]\n+}\n+\n+fn test4(f: impl FnOnce(i32)) {\n+    take(f)\n+    //~^ ERROR [E0277]\n+}\n+\n+fn test5(f: impl FnOnce(u32)) {\n+    take(f)\n+    //~^ ERROR [E0277]\n+}\n+\n+fn main() {}"}, {"sha": "961e6d88fbef4f9a5bb03c42fc692250e79ac058", "filename": "src/test/ui/trait-bounds/mismatch-fn-trait.stderr", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Ftrait-bounds%2Fmismatch-fn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Ftrait-bounds%2Fmismatch-fn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-bounds%2Fmismatch-fn-trait.stderr?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -0,0 +1,81 @@\n+error[E0277]: expected a `FnMut<(i32,)>` closure, found `impl FnMut(u32)`\n+  --> $DIR/mismatch-fn-trait.rs:4:10\n+   |\n+LL |     take(f)\n+   |     ---- ^ expected an `FnMut<(i32,)>` closure, found `impl FnMut(u32)`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = note: expected a closure with arguments `(u32,)`\n+              found a closure with arguments `(i32,)`\n+note: required by a bound in `take`\n+  --> $DIR/mismatch-fn-trait.rs:1:18\n+   |\n+LL | fn take(_f: impl FnMut(i32)) {}\n+   |                  ^^^^^^^^^^ required by this bound in `take`\n+\n+error[E0277]: expected a `FnMut<(i32,)>` closure, found `impl FnMut(i32, i32)`\n+  --> $DIR/mismatch-fn-trait.rs:9:10\n+   |\n+LL |     take(f)\n+   |     ---- ^ expected an `FnMut<(i32,)>` closure, found `impl FnMut(i32, i32)`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = note: expected a closure taking 2 arguments, but one taking 1 argument was given\n+note: required by a bound in `take`\n+  --> $DIR/mismatch-fn-trait.rs:1:18\n+   |\n+LL | fn take(_f: impl FnMut(i32)) {}\n+   |                  ^^^^^^^^^^ required by this bound in `take`\n+\n+error[E0277]: expected a `FnMut<(i32,)>` closure, found `impl FnMut()`\n+  --> $DIR/mismatch-fn-trait.rs:14:10\n+   |\n+LL |     take(f)\n+   |     ---- ^ expected an `FnMut<(i32,)>` closure, found `impl FnMut()`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = note: expected a closure taking 0 arguments, but one taking 1 argument was given\n+note: required by a bound in `take`\n+  --> $DIR/mismatch-fn-trait.rs:1:18\n+   |\n+LL | fn take(_f: impl FnMut(i32)) {}\n+   |                  ^^^^^^^^^^ required by this bound in `take`\n+\n+error[E0277]: expected a `FnMut<(i32,)>` closure, found `impl FnOnce(i32)`\n+  --> $DIR/mismatch-fn-trait.rs:19:10\n+   |\n+LL |     take(f)\n+   |     ---- ^ expected an `FnMut<(i32,)>` closure, found `impl FnOnce(i32)`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = note: `impl FnOnce(i32)` implements `FnOnce`, but it must implement `FnMut`, which is more general\n+note: required by a bound in `take`\n+  --> $DIR/mismatch-fn-trait.rs:1:18\n+   |\n+LL | fn take(_f: impl FnMut(i32)) {}\n+   |                  ^^^^^^^^^^ required by this bound in `take`\n+\n+error[E0277]: expected a `FnMut<(i32,)>` closure, found `impl FnOnce(u32)`\n+  --> $DIR/mismatch-fn-trait.rs:24:10\n+   |\n+LL |     take(f)\n+   |     ---- ^ expected an `FnMut<(i32,)>` closure, found `impl FnOnce(u32)`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = note: `impl FnOnce(u32)` implements `FnOnce`, but it must implement `FnMut`, which is more general\n+   = note: expected a closure with arguments `(u32,)`\n+              found a closure with arguments `(i32,)`\n+note: required by a bound in `take`\n+  --> $DIR/mismatch-fn-trait.rs:1:18\n+   |\n+LL | fn take(_f: impl FnMut(i32)) {}\n+   |                  ^^^^^^^^^^ required by this bound in `take`\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "0ea1c1dcd5bde0c73bcd183398029e0ae87dd30a", "filename": "src/test/ui/unboxed-closures/unboxed-closures-fnmut-as-fn.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-fnmut-as-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/297a8018b525c28ef10ee6a91d61954839b508b9/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-fnmut-as-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-fnmut-as-fn.stderr?ref=297a8018b525c28ef10ee6a91d61954839b508b9", "patch": "@@ -7,6 +7,7 @@ LL |     let x = call_it(&S, 22);\n    |             required by a bound introduced by this call\n    |\n    = help: the trait `Fn<(isize,)>` is not implemented for `S`\n+   = note: `S` implements `FnMut`, but it must implement `Fn`, which is more general\n note: required by a bound in `call_it`\n   --> $DIR/unboxed-closures-fnmut-as-fn.rs:22:14\n    |"}]}