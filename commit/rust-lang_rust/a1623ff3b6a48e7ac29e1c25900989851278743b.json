{"sha": "a1623ff3b6a48e7ac29e1c25900989851278743b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNjIzZmYzYjZhNDhlN2FjMjllMWMyNTkwMDk4OTg1MTI3ODc0M2I=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-06-30T17:10:22Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-06-30T17:28:51Z"}, "message": "Deny unsafe ops in unsafe fns, part 6\nAnd final part!!!", "tree": {"sha": "55caa59b00e3e3a180b88c616ad2335623f82f77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55caa59b00e3e3a180b88c616ad2335623f82f77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1623ff3b6a48e7ac29e1c25900989851278743b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1623ff3b6a48e7ac29e1c25900989851278743b", "html_url": "https://github.com/rust-lang/rust/commit/a1623ff3b6a48e7ac29e1c25900989851278743b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1623ff3b6a48e7ac29e1c25900989851278743b/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3652337a9539e703682a6babbf816192760bd3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3652337a9539e703682a6babbf816192760bd3d", "html_url": "https://github.com/rust-lang/rust/commit/b3652337a9539e703682a6babbf816192760bd3d"}], "stats": {"total": 278, "additions": 185, "deletions": 93}, "files": [{"sha": "be4e051b1ca42b71e32f4218eebd39a8ea1e4d1a", "filename": "src/libcore/alloc/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -1,7 +1,6 @@\n //! Memory allocation APIs\n \n #![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n-#![deny(unsafe_op_in_unsafe_fn)]\n \n mod global;\n mod layout;"}, {"sha": "51d9695687f4afad7a141c95afb3cde5103715dc", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -187,7 +187,6 @@\n //!\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::cmp::Ordering;\n use crate::fmt::{self, Debug, Display};"}, {"sha": "c329eec76ac3d9e28afc61a2adae447ffa1006b5", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -1,7 +1,5 @@\n //! Character conversions.\n \n-#![deny(unsafe_op_in_unsafe_fn)]\n-\n use crate::convert::TryFrom;\n use crate::fmt;\n use crate::mem::transmute;"}, {"sha": "72555d781ed38e2580a6c2c15be5fc037938b035", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -1,7 +1,5 @@\n //! impl char {}\n \n-#![deny(unsafe_op_in_unsafe_fn)]\n-\n use crate::slice;\n use crate::str::from_utf8_unchecked_mut;\n use crate::unicode::printable::is_printable;"}, {"sha": "336c0b26bc7d71afffc08dae0d249eaf3ae0ffa5", "filename": "src/libcore/convert/num.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -1,5 +1,3 @@\n-#![deny(unsafe_op_in_unsafe_fn)]\n-\n use super::{From, TryFrom};\n use crate::num::TryFromIntError;\n "}, {"sha": "ca4632006509fec3f368a96001265ad5dacb9224", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -1,6 +1,5 @@\n #![stable(feature = \"\", since = \"1.30.0\")]\n #![allow(non_camel_case_types)]\n-#![deny(unsafe_op_in_unsafe_fn)]\n \n //! Utilities related to FFI bindings.\n "}, {"sha": "2555d91ae8d9a287a60d256ebc5adecae70eda38", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -85,5 +85,7 @@ where\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[inline]\n pub unsafe fn get_context<'a, 'b>(cx: ResumeTy) -> &'a mut Context<'b> {\n-    &mut *cx.0.as_ptr().cast()\n+    // SAFETY: the caller must guarantee that `cx.0` is a valid pointer\n+    // that fulfills all the requirements for a mutable reference.\n+    unsafe { &mut *cx.0.as_ptr().cast() }\n }"}, {"sha": "f2bbf646f3272b87d1c5beb7e8b22721f985abce", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -1,7 +1,6 @@\n //! An implementation of SipHash.\n \n #![allow(deprecated)] // the types in this module are deprecated\n-#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::cmp;\n use crate::marker::PhantomData;"}, {"sha": "9ebcde79b633d3ea0492f5c90991a1d803e15e0f", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -2,8 +2,6 @@\n \n //! Hints to compiler that affects how code should be emitted or optimized.\n \n-#![deny(unsafe_op_in_unsafe_fn)]\n-\n use crate::intrinsics;\n \n /// Informs the compiler that this point in the code is not reachable, enabling"}, {"sha": "3c0d5f8bfe7be2d550eced42d9d2ef0a395944e5", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -53,7 +53,6 @@\n     issue = \"none\"\n )]\n #![allow(missing_docs)]\n-#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::marker::DiscriminantKind;\n use crate::mem;"}, {"sha": "080b70c6368b286bf80f5636300001df18c2b4d0", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -309,7 +309,6 @@\n //! [`min`]: trait.Iterator.html#method.min\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::ops::Try;\n "}, {"sha": "81c2344e205c5718e8740181d8a2cc1836cc33ae", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -149,6 +149,7 @@\n #![feature(const_caller_location)]\n #![feature(no_niche)] // rust-lang/rust#68303\n #![feature(unsafe_block_in_unsafe_fn)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n #[prelude_import]\n #[allow(unused)]\n@@ -279,7 +280,13 @@ pub mod primitive;\n // set up in such a way that directly pulling it here works such that the\n // crate uses the this crate as its libcore.\n #[path = \"../stdarch/crates/core_arch/src/mod.rs\"]\n-#[allow(missing_docs, missing_debug_implementations, dead_code, unused_imports)]\n+#[allow(\n+    missing_docs,\n+    missing_debug_implementations,\n+    dead_code,\n+    unused_imports,\n+    unsafe_op_in_unsafe_fn\n+)]\n // FIXME: This annotation should be moved into rust-lang/stdarch after clashing_extern_declarations is\n // merged. It currently cannot because bootstrap fails as the lint hasn't been defined yet.\n #[cfg_attr(not(bootstrap), allow(clashing_extern_declarations))]"}, {"sha": "272088815ece90194a40aa0645902a484d7837fe", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -4,7 +4,6 @@\n //! types, initializing and manipulating memory.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::clone;\n use crate::cmp;"}, {"sha": "061d1ea6b1c46974ffe7f7e11d3c3a6a878c8842", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -9,7 +9,6 @@\n //! new code should use the associated constants directly on the primitive type.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::convert::FloatToInt;\n #[cfg(not(test))]"}, {"sha": "b0df4d64f6ee1880583c42f5bc83c8a5a6dbd9d2", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -9,7 +9,6 @@\n //! new code should use the associated constants directly on the primitive type.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::convert::FloatToInt;\n #[cfg(not(test))]"}, {"sha": "2ded2e9c086c83c5d45df0cec711b90acbf967a3", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -3,7 +3,6 @@\n //! Numeric traits and functions for the built-in numeric types.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::convert::Infallible;\n use crate::fmt;"}, {"sha": "da299f026f8f16c87f0d7dd4f64fe3e62f37491b", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -375,7 +375,6 @@\n //! [`i32`]: ../../std/primitive.i32.html\n \n #![stable(feature = \"pin\", since = \"1.33.0\")]\n-#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::cmp::{self, PartialEq, PartialOrd};\n use crate::fmt;"}, {"sha": "d1d7a71523822a12c2679917a2f355f064857783", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -95,7 +95,9 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n-        if self.is_null() { None } else { Some(&*self) }\n+        // SAFETY: the caller must guarantee that `self` is valid\n+        // for a reference if it isn't null.\n+        if self.is_null() { None } else { unsafe { Some(&*self) } }\n     }\n \n     /// Calculates the offset from a pointer.\n@@ -157,7 +159,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        intrinsics::offset(self, count)\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { intrinsics::offset(self, count) }\n     }\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n@@ -292,7 +295,8 @@ impl<T: ?Sized> *const T {\n     {\n         let pointee_size = mem::size_of::<T>();\n         assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n-        intrinsics::ptr_offset_from(self, origin)\n+        // SAFETY: the caller must uphold the safety contract for `ptr_offset_from`.\n+        unsafe { intrinsics::ptr_offset_from(self, origin) }\n     }\n \n     /// Returns whether two pointers are guaranteed to be equal.\n@@ -471,7 +475,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        self.offset(count as isize)\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { self.offset(count as isize) }\n     }\n \n     /// Calculates the offset from a pointer (convenience for\n@@ -534,7 +539,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        self.offset((count as isize).wrapping_neg())\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { self.offset((count as isize).wrapping_neg()) }\n     }\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n@@ -663,7 +669,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        read(self)\n+        // SAFETY: the caller must uphold the safety contract for `read`.\n+        unsafe { read(self) }\n     }\n \n     /// Performs a volatile read of the value from `self` without moving it. This\n@@ -682,7 +689,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        read_volatile(self)\n+        // SAFETY: the caller must uphold the safety contract for `read_volatile`.\n+        unsafe { read_volatile(self) }\n     }\n \n     /// Reads the value from `self` without moving it. This leaves the\n@@ -699,7 +707,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        read_unaligned(self)\n+        // SAFETY: the caller must uphold the safety contract for `read_unaligned`.\n+        unsafe { read_unaligned(self) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n@@ -716,7 +725,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        copy(self, dest, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy`.\n+        unsafe { copy(self, dest, count) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n@@ -733,7 +743,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        copy_nonoverlapping(self, dest, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.\n+        unsafe { copy_nonoverlapping(self, dest, count) }\n     }\n \n     /// Computes the offset that needs to be applied to the pointer in order to make it aligned to"}, {"sha": "5f028f9ea76cac453c771afc7f5cbbb42021d4e0", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 93, "deletions": 33, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -184,7 +184,9 @@ mod mut_ptr;\n pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n     // Code here does not matter - this is replaced by the\n     // real drop glue by the compiler.\n-    drop_in_place(to_drop)\n+\n+    // SAFETY: see comment above\n+    unsafe { drop_in_place(to_drop) }\n }\n \n /// Creates a null raw pointer.\n@@ -374,9 +376,15 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     let mut tmp = MaybeUninit::<T>::uninit();\n \n     // Perform the swap\n-    copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n-    copy(y, x, 1); // `x` and `y` may overlap\n-    copy_nonoverlapping(tmp.as_ptr(), y, 1);\n+    // SAFETY: the caller must guarantee that `x` and `y` are\n+    // valid for writes and properly aligned. `tmp` cannot be\n+    // overlapping either `x` or `y` because `tmp` was just allocated\n+    // on the stack as a separate allocated object.\n+    unsafe {\n+        copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n+        copy(y, x, 1); // `x` and `y` may overlap\n+        copy_nonoverlapping(tmp.as_ptr(), y, 1);\n+    }\n }\n \n /// Swaps `count * size_of::<T>()` bytes between the two regions of memory\n@@ -432,19 +440,26 @@ pub unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n     let x = x as *mut u8;\n     let y = y as *mut u8;\n     let len = mem::size_of::<T>() * count;\n-    swap_nonoverlapping_bytes(x, y, len)\n+    // SAFETY: the caller must guarantee that `x` and `y` are\n+    // valid for writes and properly aligned.\n+    unsafe { swap_nonoverlapping_bytes(x, y, len) }\n }\n \n #[inline]\n pub(crate) unsafe fn swap_nonoverlapping_one<T>(x: *mut T, y: *mut T) {\n     // For types smaller than the block optimization below,\n     // just swap directly to avoid pessimizing codegen.\n     if mem::size_of::<T>() < 32 {\n-        let z = read(x);\n-        copy_nonoverlapping(y, x, 1);\n-        write(y, z);\n+        // SAFETY: the caller must guarantee that `x` and `y` are valid\n+        // for writes, properly aligned, and non-overlapping.\n+        unsafe {\n+            let z = read(x);\n+            copy_nonoverlapping(y, x, 1);\n+            write(y, z);\n+        }\n     } else {\n-        swap_nonoverlapping(x, y, 1);\n+        // SAFETY: the caller must uphold the safety contract for `swap_nonoverlapping`.\n+        unsafe { swap_nonoverlapping(x, y, 1) };\n     }\n }\n \n@@ -471,14 +486,23 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n         // Declaring `t` here avoids aligning the stack when this loop is unused\n         let mut t = mem::MaybeUninit::<Block>::uninit();\n         let t = t.as_mut_ptr() as *mut u8;\n-        let x = x.add(i);\n-        let y = y.add(i);\n \n-        // Swap a block of bytes of x & y, using t as a temporary buffer\n-        // This should be optimized into efficient SIMD operations where available\n-        copy_nonoverlapping(x, t, block_size);\n-        copy_nonoverlapping(y, x, block_size);\n-        copy_nonoverlapping(t, y, block_size);\n+        // SAFETY: As `i < len`, and as the caller must guarantee that `x` and `y` are valid\n+        // for `len` bytes, `x + i` and `y + i` must be valid adresses, which fulfills the\n+        // safety contract for `add`.\n+        //\n+        // Also, the caller must guarantee that `x` and `y` are valid for writes, properly aligned,\n+        // and non-overlapping, which fulfills the safety contract for `copy_nonoverlapping`.\n+        unsafe {\n+            let x = x.add(i);\n+            let y = y.add(i);\n+\n+            // Swap a block of bytes of x & y, using t as a temporary buffer\n+            // This should be optimized into efficient SIMD operations where available\n+            copy_nonoverlapping(x, t, block_size);\n+            copy_nonoverlapping(y, x, block_size);\n+            copy_nonoverlapping(t, y, block_size);\n+        }\n         i += block_size;\n     }\n \n@@ -488,12 +512,16 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n         let rem = len - i;\n \n         let t = t.as_mut_ptr() as *mut u8;\n-        let x = x.add(i);\n-        let y = y.add(i);\n \n-        copy_nonoverlapping(x, t, rem);\n-        copy_nonoverlapping(y, x, rem);\n-        copy_nonoverlapping(t, y, rem);\n+        // SAFETY: see previous safety comment.\n+        unsafe {\n+            let x = x.add(i);\n+            let y = y.add(i);\n+\n+            copy_nonoverlapping(x, t, rem);\n+            copy_nonoverlapping(y, x, rem);\n+            copy_nonoverlapping(t, y, rem);\n+        }\n     }\n }\n \n@@ -540,7 +568,13 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n-    mem::swap(&mut *dst, &mut src); // cannot overlap\n+    // SAFETY: the caller must guarantee that `dst` is valid to be\n+    // cast to a mutable reference (valid for writes, aligned, initialized),\n+    // and cannot overlap `src` since `dst` must point to a distinct\n+    // allocated object.\n+    unsafe {\n+        mem::swap(&mut *dst, &mut src); // cannot overlap\n+    }\n     src\n }\n \n@@ -658,8 +692,16 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n pub unsafe fn read<T>(src: *const T) -> T {\n     // `copy_nonoverlapping` takes care of debug_assert.\n     let mut tmp = MaybeUninit::<T>::uninit();\n-    copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-    tmp.assume_init()\n+    // SAFETY: the caller must guarantee that `src` is valid for reads.\n+    // `src` cannot overlap `tmp` because `tmp` was just allocated on\n+    // the stack as a separate allocated object.\n+    //\n+    // Also, since we just wrote a valid value into `tmp`, it is guaranteed\n+    // to be properly initialized.\n+    unsafe {\n+        copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+        tmp.assume_init()\n+    }\n }\n \n /// Reads the value from `src` without moving it. This leaves the\n@@ -752,8 +794,16 @@ pub unsafe fn read<T>(src: *const T) -> T {\n pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n     // `copy_nonoverlapping` takes care of debug_assert.\n     let mut tmp = MaybeUninit::<T>::uninit();\n-    copy_nonoverlapping(src as *const u8, tmp.as_mut_ptr() as *mut u8, mem::size_of::<T>());\n-    tmp.assume_init()\n+    // SAFETY: the caller must guarantee that `src` is valid for reads.\n+    // `src` cannot overlap `tmp` because `tmp` was just allocated on\n+    // the stack as a separate allocated object.\n+    //\n+    // Also, since we just wrote a valid value into `tmp`, it is guaranteed\n+    // to be properly initialized.\n+    unsafe {\n+        copy_nonoverlapping(src as *const u8, tmp.as_mut_ptr() as *mut u8, mem::size_of::<T>());\n+        tmp.assume_init()\n+    }\n }\n \n /// Overwrites a memory location with the given value without reading or\n@@ -847,7 +897,8 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    intrinsics::move_val_init(&mut *dst, src)\n+    // SAFETY: the caller must uphold the safety contract for `move_val_init`.\n+    unsafe { intrinsics::move_val_init(&mut *dst, src) }\n }\n \n /// Overwrites a memory location with the given value without reading or\n@@ -939,8 +990,13 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n-    // `copy_nonoverlapping` takes care of debug_assert.\n-    copy_nonoverlapping(&src as *const T as *const u8, dst as *mut u8, mem::size_of::<T>());\n+    // SAFETY: the caller must guarantee that `dst` is valid for writes.\n+    // `dst` cannot overlap `src` because the caller has mutable access\n+    // to `dst` while `src` is owned by this function.\n+    unsafe {\n+        // `copy_nonoverlapping` takes care of debug_assert.\n+        copy_nonoverlapping(&src as *const T as *const u8, dst as *mut u8, mem::size_of::<T>());\n+    }\n     mem::forget(src);\n }\n \n@@ -1015,7 +1071,8 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    intrinsics::volatile_load(src)\n+    // SAFETY: the caller must uphold the safety contract for `volatile_load`.\n+    unsafe { intrinsics::volatile_load(src) }\n }\n \n /// Performs a volatile write of a memory location with the given value without\n@@ -1087,7 +1144,10 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    intrinsics::volatile_store(dst, src);\n+    // SAFETY: the caller must uphold the safety contract for `volatile_store`.\n+    unsafe {\n+        intrinsics::volatile_store(dst, src);\n+    }\n }\n \n /// Align pointer `p`.\n@@ -1173,8 +1233,8 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     }\n \n     let smoda = stride & a_minus_one;\n-    // a is power-of-two so cannot be 0. stride = 0 is handled above.\n-    let gcdpow = intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a));\n+    // SAFETY: a is power-of-two so cannot be 0. stride = 0 is handled above.\n+    let gcdpow = unsafe { intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a)) };\n     let gcd = 1usize << gcdpow;\n \n     if p as usize & (gcd.wrapping_sub(1)) == 0 {"}, {"sha": "7d4b6339b511f2b2e2ea331e156319b09af88da1", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -89,7 +89,9 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n-        if self.is_null() { None } else { Some(&*self) }\n+        // SAFETY: the caller must guarantee that `self` is valid for a\n+        // reference if it isn't null.\n+        if self.is_null() { None } else { unsafe { Some(&*self) } }\n     }\n \n     /// Calculates the offset from a pointer.\n@@ -151,7 +153,10 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        intrinsics::offset(self, count) as *mut T\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        // The obtained pointer is valid for writes since the caller must\n+        // guarantee that it points to the same allocated object as `self`.\n+        unsafe { intrinsics::offset(self, count) as *mut T }\n     }\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n@@ -270,7 +275,9 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {\n-        if self.is_null() { None } else { Some(&mut *self) }\n+        // SAFETY: the caller must guarantee that `self` is be valid for\n+        // a mutable reference if it isn't null.\n+        if self.is_null() { None } else { unsafe { Some(&mut *self) } }\n     }\n \n     /// Returns whether two pointers are guaranteed to be equal.\n@@ -406,7 +413,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        (self as *const T).offset_from(origin)\n+        // SAFETY: the caller must uphold the safety contract for `offset_from`.\n+        unsafe { (self as *const T).offset_from(origin) }\n     }\n \n     /// Calculates the distance between two pointers. The returned value is in\n@@ -518,7 +526,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        self.offset(count as isize)\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { self.offset(count as isize) }\n     }\n \n     /// Calculates the offset from a pointer (convenience for\n@@ -581,7 +590,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        self.offset((count as isize).wrapping_neg())\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { self.offset((count as isize).wrapping_neg()) }\n     }\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n@@ -710,7 +720,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        read(self)\n+        // SAFETY: the caller must uphold the safety contract for ``.\n+        unsafe { read(self) }\n     }\n \n     /// Performs a volatile read of the value from `self` without moving it. This\n@@ -729,7 +740,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        read_volatile(self)\n+        // SAFETY: the caller must uphold the safety contract for `read_volatile`.\n+        unsafe { read_volatile(self) }\n     }\n \n     /// Reads the value from `self` without moving it. This leaves the\n@@ -746,7 +758,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        read_unaligned(self)\n+        // SAFETY: the caller must uphold the safety contract for `read_unaligned`.\n+        unsafe { read_unaligned(self) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n@@ -763,7 +776,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        copy(self, dest, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy`.\n+        unsafe { copy(self, dest, count) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n@@ -780,7 +794,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        copy_nonoverlapping(self, dest, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.\n+        unsafe { copy_nonoverlapping(self, dest, count) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n@@ -797,7 +812,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        copy(src, self, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy`.\n+        unsafe { copy(src, self, count) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n@@ -814,7 +830,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        copy_nonoverlapping(src, self, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.\n+        unsafe { copy_nonoverlapping(src, self, count) }\n     }\n \n     /// Executes the destructor (if any) of the pointed-to value.\n@@ -825,7 +842,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn drop_in_place(self) {\n-        drop_in_place(self)\n+        // SAFETY: the caller must uphold the safety contract for `drop_in_place`.\n+        unsafe { drop_in_place(self) }\n     }\n \n     /// Overwrites a memory location with the given value without reading or\n@@ -840,7 +858,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        write(self, val)\n+        // SAFETY: the caller must uphold the safety contract for `write`.\n+        unsafe { write(self, val) }\n     }\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n@@ -855,7 +874,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        write_bytes(self, val, count)\n+        // SAFETY: the caller must uphold the safety contract for `write_bytes`.\n+        unsafe { write_bytes(self, val, count) }\n     }\n \n     /// Performs a volatile write of a memory location with the given value without\n@@ -874,7 +894,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        write_volatile(self, val)\n+        // SAFETY: the caller must uphold the safety contract for `write_volatile`.\n+        unsafe { write_volatile(self, val) }\n     }\n \n     /// Overwrites a memory location with the given value without reading or\n@@ -891,7 +912,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        write_unaligned(self, val)\n+        // SAFETY: the caller must uphold the safety contract for `write_unaligned`.\n+        unsafe { write_unaligned(self, val) }\n     }\n \n     /// Replaces the value at `self` with `src`, returning the old\n@@ -906,7 +928,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        replace(self, src)\n+        // SAFETY: the caller must uphold the safety contract for `replace`.\n+        unsafe { replace(self, src) }\n     }\n \n     /// Swaps the values at two mutable locations of the same type, without\n@@ -922,7 +945,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        swap(self, with)\n+        // SAFETY: the caller must uphold the safety contract for `swap`.\n+        unsafe { swap(self, with) }\n     }\n \n     /// Computes the offset that needs to be applied to the pointer in order to make it aligned to"}, {"sha": "c2d31bfb6a4ee717f01d547f2ca5133aa72a9e87", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -87,7 +87,8 @@ impl<T: ?Sized> NonNull<T> {\n     #[rustc_const_stable(feature = \"const_nonnull_new_unchecked\", since = \"1.32.0\")]\n     #[inline]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        NonNull { pointer: ptr as _ }\n+        // SAFETY: the caller must guarantee that `ptr` is non-null.\n+        unsafe { NonNull { pointer: ptr as _ } }\n     }\n \n     /// Creates a new `NonNull` if `ptr` is non-null.\n@@ -118,7 +119,9 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub unsafe fn as_ref(&self) -> &T {\n-        &*self.as_ptr()\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        unsafe { &*self.as_ptr() }\n     }\n \n     /// Mutably dereferences the content.\n@@ -129,7 +132,9 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n-        &mut *self.as_ptr()\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a mutable reference.\n+        unsafe { &mut *self.as_ptr() }\n     }\n \n     /// Casts to a pointer of another type."}, {"sha": "78647eee3389a3ee0d5a897b8af10fc8a3ced3b8", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -87,7 +87,8 @@ impl<T: ?Sized> Unique<T> {\n     /// `ptr` must be non-null.\n     #[inline]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        Unique { pointer: ptr as _, _marker: PhantomData }\n+        // SAFETY: the caller must guarantee that `ptr` is non-null.\n+        unsafe { Unique { pointer: ptr as _, _marker: PhantomData } }\n     }\n \n     /// Creates a new `Unique` if `ptr` is non-null.\n@@ -114,7 +115,9 @@ impl<T: ?Sized> Unique<T> {\n     /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n     #[inline]\n     pub unsafe fn as_ref(&self) -> &T {\n-        &*self.as_ptr()\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        unsafe { &*self.as_ptr() }\n     }\n \n     /// Mutably dereferences the content.\n@@ -124,7 +127,9 @@ impl<T: ?Sized> Unique<T> {\n     /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n     #[inline]\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n-        &mut *self.as_ptr()\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a mutable reference.\n+        unsafe { &mut *self.as_ptr() }\n     }\n \n     /// Casts to a pointer of another type."}, {"sha": "71d63a7115dbea395e5332b35c886e3cc4f3e4a2", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -8,7 +8,6 @@\n //! [`std::slice`]: ../../std/slice/index.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![deny(unsafe_op_in_unsafe_fn)]\n \n // How this module is organized.\n //"}, {"sha": "0014501d2c4d0624958317bcde37ecd587454180", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -7,7 +7,6 @@\n //! [`std::str`]: ../../std/str/index.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![deny(unsafe_op_in_unsafe_fn)]\n \n use self::pattern::Pattern;\n use self::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};"}, {"sha": "fcae6c86774f24c9397aee4d6626e55a2526f9db", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1623ff3b6a48e7ac29e1c25900989851278743b/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=a1623ff3b6a48e7ac29e1c25900989851278743b", "patch": "@@ -115,7 +115,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(dead_code))]\n #![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(unused_imports))]\n-#![deny(unsafe_op_in_unsafe_fn)]\n \n use self::Ordering::*;\n "}]}