{"sha": "6971b4b5c9450d191a684b2d94b2ff810c6984e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NzFiNGI1Yzk0NTBkMTkxYTY4NGIyZDk0YjJmZjgxMGM2OTg0ZTg=", "commit": {"author": {"name": "Emil Gardstr\u00f6m", "email": "emil.gardstrom@gmail.com", "date": "2017-03-27T13:36:43Z"}, "committer": {"name": "Emil Gardstr\u00f6m", "email": "emil.gardstrom@gmail.com", "date": "2017-03-30T01:29:32Z"}, "message": "Implemented support for workspaces\n\ncloses rust-lang-nursery/rustfmt#1244", "tree": {"sha": "6575d8fb8a758e2307a8a7374bb06e8dc7d0091f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6575d8fb8a758e2307a8a7374bb06e8dc7d0091f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6971b4b5c9450d191a684b2d94b2ff810c6984e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6971b4b5c9450d191a684b2d94b2ff810c6984e8", "html_url": "https://github.com/rust-lang/rust/commit/6971b4b5c9450d191a684b2d94b2ff810c6984e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6971b4b5c9450d191a684b2d94b2ff810c6984e8/comments", "author": {"login": "Emilgardis", "id": 1502855, "node_id": "MDQ6VXNlcjE1MDI4NTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1502855?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Emilgardis", "html_url": "https://github.com/Emilgardis", "followers_url": "https://api.github.com/users/Emilgardis/followers", "following_url": "https://api.github.com/users/Emilgardis/following{/other_user}", "gists_url": "https://api.github.com/users/Emilgardis/gists{/gist_id}", "starred_url": "https://api.github.com/users/Emilgardis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Emilgardis/subscriptions", "organizations_url": "https://api.github.com/users/Emilgardis/orgs", "repos_url": "https://api.github.com/users/Emilgardis/repos", "events_url": "https://api.github.com/users/Emilgardis/events{/privacy}", "received_events_url": "https://api.github.com/users/Emilgardis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Emilgardis", "id": 1502855, "node_id": "MDQ6VXNlcjE1MDI4NTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1502855?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Emilgardis", "html_url": "https://github.com/Emilgardis", "followers_url": "https://api.github.com/users/Emilgardis/followers", "following_url": "https://api.github.com/users/Emilgardis/following{/other_user}", "gists_url": "https://api.github.com/users/Emilgardis/gists{/gist_id}", "starred_url": "https://api.github.com/users/Emilgardis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Emilgardis/subscriptions", "organizations_url": "https://api.github.com/users/Emilgardis/orgs", "repos_url": "https://api.github.com/users/Emilgardis/repos", "events_url": "https://api.github.com/users/Emilgardis/events{/privacy}", "received_events_url": "https://api.github.com/users/Emilgardis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "603f26d8f18890a438c4febda3d16d51579a8036", "url": "https://api.github.com/repos/rust-lang/rust/commits/603f26d8f18890a438c4febda3d16d51579a8036", "html_url": "https://github.com/rust-lang/rust/commit/603f26d8f18890a438c4febda3d16d51579a8036"}], "stats": {"total": 112, "additions": 96, "deletions": 16}, "files": [{"sha": "0fcd0fd3f2db022204ef2a7d2460db17b381ff5a", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 96, "deletions": 16, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6971b4b5c9450d191a684b2d94b2ff810c6984e8/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6971b4b5c9450d191a684b2d94b2ff810c6984e8/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=6971b4b5c9450d191a684b2d94b2ff810c6984e8", "patch": "@@ -21,8 +21,10 @@ use std::io::Write;\n use std::path::PathBuf;\n use std::process::{Command, ExitStatus};\n use std::str;\n+use std::collections::HashSet;\n+use std::iter::FromIterator;\n \n-use getopts::Options;\n+use getopts::{Options, Matches};\n use rustc_serialize::json::Json;\n \n fn main() {\n@@ -39,6 +41,11 @@ fn execute() -> i32 {\n     opts.optflag(\"h\", \"help\", \"show this message\");\n     opts.optflag(\"q\", \"quiet\", \"no output printed to stdout\");\n     opts.optflag(\"v\", \"verbose\", \"use verbose output\");\n+    opts.optmulti(\"p\",\n+                  \"package\",\n+                  \"specify package to format (only usable in workspaces)\",\n+                  \"<package>\");\n+    opts.optflag(\"\", \"all\", \"format all packages (only usable in workspaces)\");\n \n     let matches = match opts.parse(env::args().skip(1).take_while(|a| a != \"--\")) {\n         Ok(m) => m,\n@@ -63,7 +70,9 @@ fn execute() -> i32 {\n         return success;\n     }\n \n-    match format_crate(verbosity) {\n+    let workspace_hitlist = WorkspaceHitlist::from_matches(&matches);\n+\n+    match format_crate(verbosity, workspace_hitlist) {\n         Err(e) => {\n             print_usage(&opts, &e.to_string());\n             failure\n@@ -92,8 +101,10 @@ pub enum Verbosity {\n     Quiet,\n }\n \n-fn format_crate(verbosity: Verbosity) -> Result<ExitStatus, std::io::Error> {\n-    let targets = try!(get_targets());\n+fn format_crate(verbosity: Verbosity,\n+                workspace_hitlist: WorkspaceHitlist)\n+                -> Result<ExitStatus, std::io::Error> {\n+    let targets = try!(get_targets(workspace_hitlist));\n \n     // Currently only bin and lib files get formatted\n     let files: Vec<_> = targets\n@@ -140,25 +151,94 @@ pub struct Target {\n     kind: TargetKind,\n }\n \n+#[derive(Debug, PartialEq, Eq)]\n+pub enum WorkspaceHitlist {\n+    All,\n+    Some(Vec<String>),\n+    None,\n+}\n+\n+impl WorkspaceHitlist {\n+    pub fn get_some<'a>(&'a self) -> Option<&'a [String]> {\n+        if let &WorkspaceHitlist::Some(ref hitlist) = self {\n+            Some(&hitlist)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn from_matches(matches: &Matches) -> WorkspaceHitlist {\n+        match (matches.opt_present(\"all\"), matches.opt_present(\"p\")) {\n+            (false, false) => WorkspaceHitlist::None,\n+            (true, _) => WorkspaceHitlist::All,\n+            (false, true) => WorkspaceHitlist::Some(matches.opt_strs(\"p\")),\n+        }\n+    }\n+}\n+\n // Returns a vector of all compile targets of a crate\n-fn get_targets() -> Result<Vec<Target>, std::io::Error> {\n+fn get_targets(workspace_hitlist: WorkspaceHitlist) -> Result<Vec<Target>, std::io::Error> {\n     let mut targets: Vec<Target> = vec![];\n-    let output = try!(Command::new(\"cargo\").arg(\"read-manifest\").output());\n+    if workspace_hitlist == WorkspaceHitlist::None {\n+        let output = try!(Command::new(\"cargo\").arg(\"read-manifest\").output());\n+        if output.status.success() {\n+            // None of the unwraps should fail if output of `cargo read-manifest` is correct\n+            let data = &String::from_utf8(output.stdout).unwrap();\n+            let json = Json::from_str(data).unwrap();\n+            let jtargets = json.find(\"targets\").unwrap().as_array().unwrap();\n+            for jtarget in jtargets {\n+                targets.push(target_from_json(jtarget));\n+            }\n+\n+            return Ok(targets);\n+        }\n+        return Err(std::io::Error::new(std::io::ErrorKind::NotFound,\n+                                       str::from_utf8(&output.stderr).unwrap()));\n+    }\n+    // This happens when cargo-fmt is not used inside a crate or\n+    // is used inside a workspace.\n+    // To ensure backward compatability, we only use `cargo metadata` for workspaces.\n+    // TODO: Is it possible only use metadata or read-manifest\n+    let output = Command::new(\"cargo\").arg(\"metadata\")\n+        .arg(\"--no-deps\")\n+        .output()?;\n     if output.status.success() {\n-        // None of the unwraps should fail if output of `cargo read-manifest` is correct\n         let data = &String::from_utf8(output.stdout).unwrap();\n         let json = Json::from_str(data).unwrap();\n-        let jtargets = json.find(\"targets\").unwrap().as_array().unwrap();\n-        for jtarget in jtargets {\n-            targets.push(target_from_json(jtarget));\n+        let mut hitlist: HashSet<&String> = if workspace_hitlist != WorkspaceHitlist::All {\n+            HashSet::from_iter(workspace_hitlist.get_some().unwrap())\n+        } else {\n+            HashSet::new() // Unused\n+        };\n+        let members: Vec<&Json> = json.find(\"packages\")\n+            .unwrap()\n+            .as_array()\n+            .unwrap()\n+            .into_iter()\n+            .filter(|member| if workspace_hitlist == WorkspaceHitlist::All {\n+                        true\n+                    } else {\n+                        let member_name = member.find(\"name\").unwrap().as_string().unwrap();\n+                        hitlist.take(&member_name.to_string()).is_some()\n+                    })\n+            .collect();\n+        if hitlist.len() != 0 {\n+            // Mimick cargo of only outputting one <package> spec.\n+            return Err(std::io::Error::new(std::io::ErrorKind::InvalidInput,\n+                                           format!(\"package `{}` is not a member of the workspace\",\n+                                                   hitlist.iter().next().unwrap())));\n         }\n-\n-        Ok(targets)\n-    } else {\n-        // This happens when cargo-fmt is not used inside a crate\n-        Err(std::io::Error::new(std::io::ErrorKind::NotFound,\n-                                str::from_utf8(&output.stderr).unwrap()))\n+        for member in members {\n+            let jtargets = member.find(\"targets\").unwrap().as_array().unwrap();\n+            for jtarget in jtargets {\n+                targets.push(target_from_json(jtarget));\n+            }\n+        }\n+        return Ok(targets);\n     }\n+    Err(std::io::Error::new(std::io::ErrorKind::NotFound,\n+                            str::from_utf8(&output.stderr).unwrap()))\n+\n }\n \n fn target_from_json(jtarget: &Json) -> Target {"}]}