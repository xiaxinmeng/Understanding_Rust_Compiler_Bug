{"sha": "1968622798ce565fe9f3905c972513393070a78e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5Njg2MjI3OThjZTU2NWZlOWYzOTA1Yzk3MjUxMzM5MzA3MGE3OGU=", "commit": {"author": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-15T10:16:47Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-22T00:24:21Z"}, "message": "Start refacting LLVM Type handling", "tree": {"sha": "97715d779766d274ff61513662823d70c1dc8e7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97715d779766d274ff61513662823d70c1dc8e7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1968622798ce565fe9f3905c972513393070a78e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1968622798ce565fe9f3905c972513393070a78e", "html_url": "https://github.com/rust-lang/rust/commit/1968622798ce565fe9f3905c972513393070a78e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1968622798ce565fe9f3905c972513393070a78e/comments", "author": null, "committer": null, "parents": [{"sha": "66d8e8b481a487d372936c553bf7a6d7435056c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/66d8e8b481a487d372936c553bf7a6d7435056c7", "html_url": "https://github.com/rust-lang/rust/commit/66d8e8b481a487d372936c553bf7a6d7435056c7"}], "stats": {"total": 316, "additions": 298, "deletions": 18}, "files": [{"sha": "14f5166b123a7ea60941f761af3102a018e0c97d", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1968622798ce565fe9f3905c972513393070a78e/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968622798ce565fe9f3905c972513393070a78e/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=1968622798ce565fe9f3905c972513393070a78e", "patch": "@@ -17,6 +17,8 @@ use core::ptr;\n use core::str;\n use core::vec;\n \n+use middle::trans::type_::Type;\n+\n pub type Opcode = u32;\n pub type Bool = c_uint;\n \n@@ -2121,8 +2123,8 @@ pub fn ConstFCmp(Pred: RealPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef {\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n-    type_names: HashMap<TypeRef, @str>,\n-    named_types: HashMap<@str, TypeRef>\n+    type_names: HashMap<TypeRef, ~str>,\n+    named_types: HashMap<~str, TypeRef>\n }\n \n impl TypeNames {\n@@ -2133,17 +2135,20 @@ impl TypeNames {\n         }\n     }\n \n-    pub fn associate_type(&mut self, s: @str, t: TypeRef) {\n-        assert!(self.type_names.insert(t, s));\n-        assert!(self.named_types.insert(s, t));\n+    pub fn associate_type(&mut self, s: &str, t: &Type) {\n+        assert!(self.type_names.insert(t.to_ref(), s.to_owned()));\n+        assert!(self.named_types.insert(s.to_owned(), t.to_ref()));\n     }\n \n-    pub fn find_name(&self, ty: &TypeRef) -> Option<@str> {\n-        self.type_names.find_copy(ty)\n+    pub fn find_name<'r>(&'r self, ty: &Type) -> Option<&'r str> {\n+        match self.type_names.find(ty.to_ref()) {\n+            Some(a) => Some(a.slice(0, a.len())),\n+            None => None\n+        }\n     }\n \n-    pub fn find_type(&self, s: &str) -> Option<TypeRef> {\n-        self.named_types.find_equiv(&s).map_consume(|x| *x)\n+    pub fn find_type(&self, s: &str) -> Option<Type> {\n+        self.named_types.find_equiv(&s).map_consume(|x| Type::from_ref(*x))\n     }\n \n     pub fn type_to_str(&self, ty: TypeRef) -> ~str {"}, {"sha": "ed5c2aa2e0b90f44d98bf956db8889decf7bd9a1", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1968622798ce565fe9f3905c972513393070a78e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968622798ce565fe9f3905c972513393070a78e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=1968622798ce565fe9f3905c972513393070a78e", "patch": "@@ -27,6 +27,8 @@ use middle::trans::shape;\n use middle::trans::type_use;\n use middle::ty;\n \n+use middle::trans::type_::Type;\n+\n use core::hash;\n use core::hashmap::{HashMap, HashSet};\n use core::str;\n@@ -106,10 +108,10 @@ pub struct CrateContext {\n      maps: astencode::Maps,\n      stats: Stats,\n      upcalls: @upcall::Upcalls,\n-     tydesc_type: TypeRef,\n-     int_type: TypeRef,\n-     float_type: TypeRef,\n-     opaque_vec_type: TypeRef,\n+     tydesc_type: Type,\n+     int_type: Type,\n+     float_type: Type,\n+     opaque_vec_type: Type,\n      builder: BuilderRef_res,\n      shape_cx: shape::Ctxt,\n      crate_map: ValueRef,\n@@ -145,10 +147,13 @@ impl CrateContext {\n             if sess.opts.extra_debuginfo {\n                 base::declare_dbg_intrinsics(llmod, &mut intrinsics);\n             }\n-            let int_type = T_int(targ_cfg);\n-            let float_type = T_float(targ_cfg);\n-            let tydesc_type = T_tydesc(targ_cfg);\n-            tn.associate_type(@\"tydesc\", tydesc_type);\n+            let int_type = Type::int(targ_cfg.arch);\n+            let float_type = Type::float(targ_cfg.arch);\n+            let tydesc_type = Type::tydesc(targ_cfg.arch);\n+            let opaque_vec_type = Type::opaque_vec(targ_cfg.arch);\n+\n+            tn.associate_type(\"tydesc\", &tydesc_type);\n+\n             let crate_map = decl_crate_map(sess, link_meta, llmod);\n             let dbg_cx = if sess.opts.debuginfo {\n                 Some(debuginfo::DebugContext::new(llmod, name.to_owned()))\n@@ -213,7 +218,7 @@ impl CrateContext {\n                   tydesc_type: tydesc_type,\n                   int_type: int_type,\n                   float_type: float_type,\n-                  opaque_vec_type: T_opaque_vec(targ_cfg),\n+                  opaque_vec_type: opaque_vec_type,\n                   builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                   shape_cx: mk_ctxt(llmod),\n                   crate_map: crate_map,"}, {"sha": "1345b92418e3d9d3b1076cb88896cb2ca83ce3bf", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1968622798ce565fe9f3905c972513393070a78e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968622798ce565fe9f3905c972513393070a78e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=1968622798ce565fe9f3905c972513393070a78e", "patch": "@@ -42,3 +42,4 @@ pub mod reachable;\n pub mod machine;\n pub mod adt;\n pub mod asm;\n+pub mod type_;"}, {"sha": "65f86c30ea301575de5539fda89b26414338819a", "filename": "src/librustc/middle/trans/type_.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/1968622798ce565fe9f3905c972513393070a78e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968622798ce565fe9f3905c972513393070a78e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=1968622798ce565fe9f3905c972513393070a78e", "patch": "@@ -0,0 +1,269 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use lib::llvm::{llvm, TypeRef, Bool, False, True};\n+\n+use middle::trans::context::CrateContext;\n+use middle::trans::base;\n+\n+use syntax::{ast,abi};\n+use syntax::abi::{X86, X86_64, Arm, Mips};\n+\n+use core::vec;\n+\n+use core::libc::{c_uint};\n+\n+pub struct Type {\n+    priv rf: TypeRef\n+}\n+\n+macro_rules! ty (\n+    ($e:expr) => ( Type::from_ref(unsafe {\n+\n+    }))\n+)\n+\n+/**\n+ * Wrapper for LLVM TypeRef\n+ */\n+impl Type {\n+    pub fn from_ref(r: TypeRef) -> Type {\n+        Type {\n+            rf: r\n+        }\n+    }\n+\n+    pub fn to_ref(&self) -> TypeRef {\n+        self.rf\n+    }\n+\n+    pub fn void() -> Type {\n+        ty!(llvm::LLVMVoidTypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn nil() -> Type {\n+        Type::empty_struct()\n+    }\n+\n+    pub fn metadata() -> Type {\n+        ty!(llvm::LLVMMetadataTypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn i1() -> Type {\n+        ty!(llvm::LLVMInt1TypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn i8() -> Type {\n+        ty!(llvm::LLVMInt8TypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn i16() -> Type {\n+        ty!(llvm::LLVMInt16TypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn i32() -> Type {\n+        ty!(llvm::LLVMInt32TypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn i64() -> Type {\n+        ty!(llvm::LLVMInt64TypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn f32() -> Type {\n+        ty!(llvm::LLVMFloatTypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn f64() -> Type {\n+        ty!(llvm::LLVMDoubleTypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn bool() -> Type {\n+        Type::i8()\n+    }\n+\n+    pub fn char() -> Type {\n+        Type::i32()\n+    }\n+\n+    pub fn int(arch: abi::Architecture) -> Type {\n+        match arch {\n+            X86 | Arm | Mips => Type::i32(),\n+            X86_64 => Type::i64()\n+        }\n+    }\n+\n+    pub fn float(_: abi::Architecture) -> Type {\n+        // All architectures currently just use doubles as the default\n+        // float size\n+        Type::f64()\n+    }\n+\n+    pub fn int_from_ty(ctx: &CrateContext, t: ast::int_ty) -> Type {\n+        match t {\n+            ast::ty_i => ctx.int_type,\n+            ast::ty_char => Type::char(),\n+            ast::ty_i8 => Type::i8(),\n+            ast::ty_i16 => Type::i16(),\n+            ast::ty_i32 => Type::i32(),\n+            ast::ty_i64 => Type::i64()\n+        }\n+    }\n+\n+    pub fn uint_from_ty(ctx: &CrateContext, t: ast::uint_ty) -> Type {\n+        match t {\n+            ast::ty_u => ctx.int_type,\n+            ast::ty_u8 => Type::i8(),\n+            ast::ty_u16 => Type::i16(),\n+            ast::ty_u32 => Type::i32(),\n+            ast::ty_u64 => Type::i64()\n+        }\n+    }\n+\n+    pub fn float_from_ty(ctx: &CrateContext, t: ast::float_ty) -> Type {\n+        match t {\n+            ast::ty_f => ctx.float_ty,\n+            ast::ty_f32 => Type::f32(),\n+            ast::ty_f64 => Type::f64()\n+        }\n+    }\n+\n+    pub fn size_t(arch: abi::Architecture) -> Type {\n+        Type::int(arch)\n+    }\n+\n+    pub fn func(args: &[Type], ret: &Type) -> Type {\n+        let vec : &[TypeRef] = unsafe { cast::transmute() };\n+        ty!(llvm::LLVMFunctionType(ret.to_ref(), vec::raw::to_ptr(vec),\n+                                   args.len() as c_uint, False))\n+    }\n+\n+    pub fn func_pair(cx: &CrateContext, fn_ty: &Type) -> Type {\n+        assert!(fn_ty.is_func(), \"`fn_ty` must be a function type\");\n+\n+        Type::struct_([fn_ty.ptr_to(), Type::opaque_cbox_ptr(cx)], false)\n+    }\n+\n+    pub fn ptr(ty: Type) -> Type {\n+        ty!(llvm::LLVMPointerType(ty, 0 as c_uint))\n+    }\n+\n+    pub fn struct_(els: &[Type], packed: bool) -> Type {\n+        let els : &[TypeRef] = unsafe { cast::transmute(els) };\n+        ty!(llvm::LLVMStructType(vec::raw::to_ptr(els), els.len() as c_uint, packed as Bool))\n+    }\n+\n+    pub fn named_struct(name: &str) -> Type {\n+        let ctx = base::task_llcx();\n+        ty!(name.as_c_str(|s| llvm::LLVMStructCreateNamed(ctx, s)))\n+    }\n+\n+    pub fn empty_struct() -> Type {\n+        Type::struct_([], false)\n+    }\n+\n+    pub fn vtable() -> Type {\n+        Type::array(Type::i8().ptr_to(), 1)\n+    }\n+\n+    pub fn generic_glue_fn(cx: &mut CrateContext) -> Type {\n+        match cx.tn.find_type(\"glue_fn\") {\n+            Some(ty) => return ty,\n+            None => ()\n+        }\n+\n+        let ty = cx.tydesc_type.get_field(abi::tydesc_field_drop_glue);\n+        cx.tn.associate_type(\"glue_fn\", ty);\n+\n+        return ty;\n+    }\n+\n+    pub fn tydesc(arch: abi::Architecture) -> Type {\n+        let mut tydesc = Type::named_struct(\"tydesc\");\n+        let tydescpp = tydesc.ptr_to().ptr_to();\n+        let pvoid = Type::i8().ptr_to();\n+        let glue_fn_ty = Type::func(\n+            [ Type::nil.ptr_to(), tydescpp, pvoid ],\n+            Type::void()).ptr_to();\n+\n+        let int_ty = Type::int(arch);\n+\n+        let elems = [\n+            int_type, int_type,\n+            glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty,\n+            pvoid, pvoid\n+        ];\n+\n+        tydesc.set_struct_body(elems, false);\n+\n+        return tydesc;\n+    }\n+\n+    pub fn array(ty: &Type, len: uint) -> Type {\n+        ty!(llvm::LLVMArrayType(ty.to_ref(), len as c_uint))\n+    }\n+\n+    pub fn vector(ty: &Type, len: uint) -> Type {\n+        ty!(llvm::LLVMVectorType(ty.to_ref(), len as c_uint))\n+    }\n+\n+    pub fn vec(arch: abi::Architecture, ty: &Type) -> Type {\n+        Type::struct_(\n+            [ Type::int(arch), Type::int(arch), Type::array(ty, 0) ],\n+        false)\n+    }\n+\n+    pub fn opaque_vec(arch: abi::Architecture) -> Type {\n+        Type::vec(arch, Type::i8())\n+    }\n+\n+    #[inline]\n+    pub fn box_header_fields(ctx: &CrateContext) -> ~[Type] {\n+        ~[\n+            ctx.int_type, ctx.tydesc_type.ptr_to(),\n+            Type::i8().ptr_to(), Type::i8().ptr_to()\n+        ]\n+    }\n+\n+    pub fn box_header(ctx: &CrateContext) -> Type {\n+        Type::struct_(Type::box_header_fields(ctx), false)\n+    }\n+\n+    pub fn box(ctx: &CrateContext, ty: &Type) -> Type {\n+        Type::struct_(Type::box_header_fields(ctx) + [t], false)\n+    }\n+\n+    pub fn opaque_box(ctx: &CrateContext) -> Type {\n+        Type::box(ctx, Type::i8())\n+    }\n+\n+    pub fn unique(ctx: &CrateContext, ty: &Type) -> Type {\n+        Type::box(ctx, ty)\n+    }\n+\n+    pub fn opaque_cbox_ptr(cx: &CrateContext) -> Type {\n+        Type::opaque_box().ptr_to()\n+    }\n+\n+    pub fn enum_discrim(cx: &CrateContext) -> Type {\n+        cx.int_type\n+    }\n+\n+    pub fn set_struct_body(&mut self, els: &[Type], packed: bool) {\n+        assert!(self.is_struct(), \"Type must be a struct\");\n+\n+        unsafe {\n+            let vec : &[TypeRef] = cast::transmute(els);\n+            llvm::LLVMStructSetBody(self.to_ref(), to_ptr(vec),\n+                                    els.len() as c_uint, packed as Bool)\n+        }\n+    }\n+}"}]}