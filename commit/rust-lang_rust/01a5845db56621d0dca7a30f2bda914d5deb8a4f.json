{"sha": "01a5845db56621d0dca7a30f2bda914d5deb8a4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxYTU4NDVkYjU2NjIxZDBkY2E3YTMwZjJiZGE5MTRkNWRlYjhhNGY=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-23T21:19:35Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-23T21:19:35Z"}, "message": "fix atomic intrinsic test cases", "tree": {"sha": "0fef0dc91727ce9f57f3909d9b5f390ac9ec174f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fef0dc91727ce9f57f3909d9b5f390ac9ec174f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01a5845db56621d0dca7a30f2bda914d5deb8a4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01a5845db56621d0dca7a30f2bda914d5deb8a4f", "html_url": "https://github.com/rust-lang/rust/commit/01a5845db56621d0dca7a30f2bda914d5deb8a4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01a5845db56621d0dca7a30f2bda914d5deb8a4f/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caceac06ce645e4a36637eedc25f5334369b6bbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/caceac06ce645e4a36637eedc25f5334369b6bbe", "html_url": "https://github.com/rust-lang/rust/commit/caceac06ce645e4a36637eedc25f5334369b6bbe"}], "stats": {"total": 112, "additions": 54, "deletions": 58}, "files": [{"sha": "b75462b3c4a20f2290cf19155c4907264f4dab11", "filename": "src/test/auxiliary/cci_intrinsic.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/01a5845db56621d0dca7a30f2bda914d5deb8a4f/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01a5845db56621d0dca7a30f2bda914d5deb8a4f/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs?ref=01a5845db56621d0dca7a30f2bda914d5deb8a4f", "patch": "@@ -1,19 +1,19 @@\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    fn atomic_xchng(&dst: int, src: int) -> int;\n-    fn atomic_xchng_acq(&dst: int, src: int) -> int;\n-    fn atomic_xchng_rel(&dst: int, src: int) -> int;\n+    fn atomic_xchg(dst: &mut int, src: int) -> int;\n+    fn atomic_xchg_acq(dst: &mut int, src: int) -> int;\n+    fn atomic_xchg_rel(dst: &mut int, src: int) -> int;\n     \n-    fn atomic_add(&dst: int, src: int) -> int;\n-    fn atomic_add_acq(&dst: int, src: int) -> int;\n-    fn atomic_add_rel(&dst: int, src: int) -> int;\n+    fn atomic_xadd(dst: &mut int, src: int) -> int;\n+    fn atomic_xadd_acq(dst: &mut int, src: int) -> int;\n+    fn atomic_xadd_rel(dst: &mut int, src: int) -> int;\n     \n-    fn atomic_sub(&dst: int, src: int) -> int;\n-    fn atomic_sub_acq(&dst: int, src: int) -> int;\n-    fn atomic_sub_rel(&dst: int, src: int) -> int;\n+    fn atomic_xsub(dst: &mut int, src: int) -> int;\n+    fn atomic_xsub_acq(dst: &mut int, src: int) -> int;\n+    fn atomic_xsub_rel(dst: &mut int, src: int) -> int;\n }\n \n #[inline(always)]\n-fn atomic_xchng(&dst: int, src: int) -> int {\n-    rusti::atomic_xchng(dst, src)\n-}\n\\ No newline at end of file\n+fn atomic_xchg(dst: &mut int, src: int) -> int {\n+    rusti::atomic_xchg(dst, src)\n+}"}, {"sha": "601bdde8b3a45f017a3c39152a22babe58403e03", "filename": "src/test/run-pass/intrinsic-atomics-cc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01a5845db56621d0dca7a30f2bda914d5deb8a4f/src%2Ftest%2Frun-pass%2Fintrinsic-atomics-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01a5845db56621d0dca7a30f2bda914d5deb8a4f/src%2Ftest%2Frun-pass%2Fintrinsic-atomics-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-atomics-cc.rs?ref=01a5845db56621d0dca7a30f2bda914d5deb8a4f", "patch": "@@ -4,10 +4,10 @@\n // xfail-test\n \n use cci_intrinsic;\n-import cci_intrinsic::atomic_xchng;\n+import cci_intrinsic::atomic_xchg;\n \n fn main() {\n     let mut x = 1;\n-    atomic_xchng(x, 5);\n+    atomic_xchg(&mut x, 5);\n     assert x == 5;\n }"}, {"sha": "512e0edbec93eb53787119b292aaca185db37c03", "filename": "src/test/run-pass/intrinsic-atomics.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/01a5845db56621d0dca7a30f2bda914d5deb8a4f/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01a5845db56621d0dca7a30f2bda914d5deb8a4f/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs?ref=01a5845db56621d0dca7a30f2bda914d5deb8a4f", "patch": "@@ -1,37 +1,37 @@\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    fn atomic_xchng(&dst: int, src: int) -> int;\n-    fn atomic_xchng_acq(&dst: int, src: int) -> int;\n-    fn atomic_xchng_rel(&dst: int, src: int) -> int;\n+    fn atomic_xchg(dst: &mut int, src: int) -> int;\n+    fn atomic_xchg_acq(dst: &mut int, src: int) -> int;\n+    fn atomic_xchg_rel(dst: &mut int, src: int) -> int;\n     \n-    fn atomic_add(&dst: int, src: int) -> int;\n-    fn atomic_add_acq(&dst: int, src: int) -> int;\n-    fn atomic_add_rel(&dst: int, src: int) -> int;\n+    fn atomic_xadd(dst: &mut int, src: int) -> int;\n+    fn atomic_xadd_acq(dst: &mut int, src: int) -> int;\n+    fn atomic_xadd_rel(dst: &mut int, src: int) -> int;\n     \n-    fn atomic_sub(&dst: int, src: int) -> int;\n-    fn atomic_sub_acq(&dst: int, src: int) -> int;\n-    fn atomic_sub_rel(&dst: int, src: int) -> int;\n+    fn atomic_xsub(dst: &mut int, src: int) -> int;\n+    fn atomic_xsub_acq(dst: &mut int, src: int) -> int;\n+    fn atomic_xsub_rel(dst: &mut int, src: int) -> int;\n }\n \n fn main() {\n-    let mut x = 1;\n+    let x = ~mut 1;\n \n-    assert rusti::atomic_xchng(x, 0) == 1;\n-    assert x == 0;\n+    assert rusti::atomic_xchg(x, 0) == 1;\n+    assert *x == 0;\n \n-    assert rusti::atomic_xchng_acq(x, 1) == 0;\n-    assert x == 1;\n+    assert rusti::atomic_xchg_acq(x, 1) == 0;\n+    assert *x == 1;\n \n-    assert rusti::atomic_xchng_rel(x, 0) == 1;\n-    assert x == 0;\n+    assert rusti::atomic_xchg_rel(x, 0) == 1;\n+    assert *x == 0;\n \n-    assert rusti::atomic_add(x, 1) == 0;\n-    assert rusti::atomic_add_acq(x, 1) == 1;\n-    assert rusti::atomic_add_rel(x, 1) == 2;\n-    assert x == 3;\n+    assert rusti::atomic_xadd(x, 1) == 0;\n+    assert rusti::atomic_xadd_acq(x, 1) == 1;\n+    assert rusti::atomic_xadd_rel(x, 1) == 2;\n+    assert *x == 3;\n \n-    assert rusti::atomic_sub(x, 1) == 3;\n-    assert rusti::atomic_sub_acq(x, 1) == 2;\n-    assert rusti::atomic_sub_rel(x, 1) == 1;\n-    assert x == 0;\n+    assert rusti::atomic_xsub(x, 1) == 3;\n+    assert rusti::atomic_xsub_acq(x, 1) == 2;\n+    assert rusti::atomic_xsub_rel(x, 1) == 1;\n+    assert *x == 0;\n }"}, {"sha": "a8678e6126d3137e0db7533429ea258f2f8d0d40", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/01a5845db56621d0dca7a30f2bda914d5deb8a4f/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01a5845db56621d0dca7a30f2bda914d5deb8a4f/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=01a5845db56621d0dca7a30f2bda914d5deb8a4f", "patch": "@@ -1,5 +1,5 @@\n mod pipes {\n-    import unsafe::{forget, reinterpret_cast};\n+    import unsafe::{forget, transmute};\n \n     enum state {\n         empty,\n@@ -25,30 +25,26 @@ mod pipes {\n \n     #[abi = \"rust-intrinsic\"]\n     mod rusti {\n-      fn atomic_xchng(&dst: int, src: int) -> int { fail; }\n-      fn atomic_xchng_acq(&dst: int, src: int) -> int { fail; }\n-      fn atomic_xchng_rel(&dst: int, src: int) -> int { fail; }\n+      fn atomic_xchg(_dst: &mut int, _src: int) -> int { fail; }\n+      fn atomic_xchg_acq(_dst: &mut int, _src: int) -> int { fail; }\n+      fn atomic_xchg_rel(_dst: &mut int, _src: int) -> int { fail; }\n     }\n \n     // We should consider moving this to core::unsafe, although I\n     // suspect graydon would want us to use void pointers instead.\n-    unsafe fn uniquify<T>(x: *T) -> ~T {\n-        unsafe { unsafe::reinterpret_cast(x) }\n+    unsafe fn uniquify<T>(+x: *T) -> ~T {\n+        unsafe { unsafe::transmute(x) }\n     }\n \n-    fn swap_state_acq(&dst: state, src: state) -> state {\n+    fn swap_state_acq(+dst: &mut state, src: state) -> state {\n         unsafe {\n-            reinterpret_cast(rusti::atomic_xchng_acq(\n-                *(ptr::mut_addr_of(dst) as *mut int),\n-                src as int))\n+            transmute(rusti::atomic_xchg_acq(transmute(dst), src as int))\n         }\n     }\n \n-    fn swap_state_rel(&dst: state, src: state) -> state {\n+    fn swap_state_rel(+dst: &mut state, src: state) -> state {\n         unsafe {\n-            reinterpret_cast(rusti::atomic_xchng_rel(\n-                *(ptr::mut_addr_of(dst) as *mut int),\n-                src as int))\n+            transmute(rusti::atomic_xchg_rel(transmute(dst), src as int))\n         }\n     }\n \n@@ -57,7 +53,7 @@ mod pipes {\n         let p = unsafe { uniquify(p) };\n         assert (*p).payload == none;\n         (*p).payload <- some(payload);\n-        let old_state = swap_state_rel((*p).state, full);\n+        let old_state = swap_state_rel(&mut (*p).state, full);\n         match old_state {\n           empty => {\n             // Yay, fastpath.\n@@ -82,7 +78,7 @@ mod pipes {\n         let p = p.unwrap();\n         let p = unsafe { uniquify(p) };\n         loop {\n-            let old_state = swap_state_acq((*p).state,\n+            let old_state = swap_state_acq(&mut (*p).state,\n                                            blocked);\n             match old_state {\n               empty | blocked => { task::yield(); }\n@@ -101,7 +97,7 @@ mod pipes {\n \n     fn sender_terminate<T: send>(p: *packet<T>) {\n         let p = unsafe { uniquify(p) };\n-        match swap_state_rel((*p).state, terminated) {\n+        match swap_state_rel(&mut (*p).state, terminated) {\n           empty | blocked => {\n             // The receiver will eventually clean up.\n             unsafe { forget(p) }\n@@ -118,7 +114,7 @@ mod pipes {\n \n     fn receiver_terminate<T: send>(p: *packet<T>) {\n         let p = unsafe { uniquify(p) };\n-        match swap_state_rel((*p).state, terminated) {\n+        match swap_state_rel(&mut (*p).state, terminated) {\n           empty => {\n             // the sender will clean up\n             unsafe { forget(p) }\n@@ -179,7 +175,7 @@ mod pingpong {\n \n     fn liberate_ping(-p: ping) -> pipes::send_packet<pong> unsafe {\n         let addr : *pipes::send_packet<pong> = match p {\n-          ping(x) => { unsafe::reinterpret_cast(ptr::addr_of(x)) }\n+          ping(x) => { unsafe::transmute(ptr::addr_of(x)) }\n         };\n         let liberated_value <- *addr;\n         unsafe::forget(p);\n@@ -188,7 +184,7 @@ mod pingpong {\n \n     fn liberate_pong(-p: pong) -> pipes::send_packet<ping> unsafe {\n         let addr : *pipes::send_packet<ping> = match p {\n-          pong(x) => { unsafe::reinterpret_cast(ptr::addr_of(x)) }\n+          pong(x) => { unsafe::transmute(ptr::addr_of(x)) }\n         };\n         let liberated_value <- *addr;\n         unsafe::forget(p);"}]}