{"sha": "b7c5599d22018ab6be88442c4668bc1697f85b8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3YzU1OTlkMjIwMThhYjZiZTg4NDQyYzQ2NjhiYzE2OTdmODViOGU=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2021-05-10T16:15:19Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2021-05-10T16:15:19Z"}, "message": "Adjust target search algorithm for rustlib path\n\nWith this the concerns expressed in #83800 should be addressed.", "tree": {"sha": "d1073b3273c158b7c329bb8382aef2923969ebd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1073b3273c158b7c329bb8382aef2923969ebd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7c5599d22018ab6be88442c4668bc1697f85b8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7c5599d22018ab6be88442c4668bc1697f85b8e", "html_url": "https://github.com/rust-lang/rust/commit/b7c5599d22018ab6be88442c4668bc1697f85b8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7c5599d22018ab6be88442c4668bc1697f85b8e/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fb1dee14b3eff979f91e99ad034cfe262fc78c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fb1dee14b3eff979f91e99ad034cfe262fc78c3", "html_url": "https://github.com/rust-lang/rust/commit/2fb1dee14b3eff979f91e99ad034cfe262fc78c3"}], "stats": {"total": 149, "additions": 83, "deletions": 66}, "files": [{"sha": "30a56badeb52e2fdb1e5d9bc742d77c7c09bcf0b", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7c5599d22018ab6be88442c4668bc1697f85b8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c5599d22018ab6be88442c4668bc1697f85b8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=b7c5599d22018ab6be88442c4668bc1697f85b8e", "patch": "@@ -1576,7 +1576,7 @@ fn add_rpath_args(\n         let target_triple = sess.opts.target_triple.triple();\n         let mut get_install_prefix_lib_path = || {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n-            let tlib = filesearch::relative_target_lib_path(&sess.sysroot, target_triple);\n+            let tlib = rustc_target::target_rustlib_path(&sess.sysroot, target_triple).join(\"lib\");\n             let mut path = PathBuf::from(install_prefix);\n             path.push(&tlib);\n "}, {"sha": "fd29053433e5555910730018003f6e38bddfe54d", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7c5599d22018ab6be88442c4668bc1697f85b8e/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c5599d22018ab6be88442c4668bc1697f85b8e/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=b7c5599d22018ab6be88442c4668bc1697f85b8e", "patch": "@@ -423,8 +423,7 @@ pub fn get_codegen_sysroot(\n         .iter()\n         .chain(sysroot_candidates.iter())\n         .map(|sysroot| {\n-            let libdir = filesearch::relative_target_lib_path(&sysroot, &target);\n-            sysroot.join(libdir).with_file_name(\"codegen-backends\")\n+            filesearch::make_target_lib_path(&sysroot, &target).with_file_name(\"codegen-backends\")\n         })\n         .find(|f| {\n             info!(\"codegen backend candidate: {}\", f.display());"}, {"sha": "6fe6a555f1af81ccf8f5c6b87039af4bf3ce5a65", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 15, "deletions": 53, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b7c5599d22018ab6be88442c4668bc1697f85b8e/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c5599d22018ab6be88442c4668bc1697f85b8e/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=b7c5599d22018ab6be88442c4668bc1697f85b8e", "patch": "@@ -1,6 +1,5 @@\n pub use self::FileMatch::*;\n \n-use std::borrow::Cow;\n use std::env;\n use std::fs;\n use std::path::{Path, PathBuf};\n@@ -91,26 +90,21 @@ impl<'a> FileSearch<'a> {\n \n     // Returns a list of directories where target-specific tool binaries are located.\n     pub fn get_tools_search_paths(&self, self_contained: bool) -> Vec<PathBuf> {\n-        let mut p = PathBuf::from(self.sysroot);\n-        p.push(find_libdir(self.sysroot).as_ref());\n-        p.push(RUST_LIB_DIR);\n-        p.push(&self.triple);\n-        p.push(\"bin\");\n+        let rustlib_path = rustc_target::target_rustlib_path(self.sysroot, &self.triple);\n+        let p = std::array::IntoIter::new([\n+            Path::new(&self.sysroot),\n+            Path::new(&rustlib_path),\n+            Path::new(\"bin\"),\n+        ])\n+        .collect::<PathBuf>();\n         if self_contained { vec![p.clone(), p.join(\"self-contained\")] } else { vec![p] }\n     }\n }\n \n-pub fn relative_target_lib_path(sysroot: &Path, target_triple: &str) -> PathBuf {\n-    let mut p = PathBuf::from(find_libdir(sysroot).as_ref());\n-    assert!(p.is_relative());\n-    p.push(RUST_LIB_DIR);\n-    p.push(target_triple);\n-    p.push(\"lib\");\n-    p\n-}\n-\n pub fn make_target_lib_path(sysroot: &Path, target_triple: &str) -> PathBuf {\n-    sysroot.join(&relative_target_lib_path(sysroot, target_triple))\n+    let rustlib_path = rustc_target::target_rustlib_path(sysroot, target_triple);\n+    std::array::IntoIter::new([sysroot, Path::new(&rustlib_path), Path::new(\"lib\")])\n+        .collect::<PathBuf>()\n }\n \n // This function checks if sysroot is found using env::args().next(), and if it\n@@ -157,11 +151,13 @@ pub fn get_or_default_sysroot() -> PathBuf {\n                     return None;\n                 }\n \n+                // Pop off `bin/rustc`, obtaining the suspected sysroot.\n                 p.pop();\n                 p.pop();\n-                let mut libdir = PathBuf::from(&p);\n-                libdir.push(find_libdir(&p).as_ref());\n-                if libdir.exists() { Some(p) } else { None }\n+                // Look for the target rustlib directory in the suspected sysroot.\n+                let mut rustlib_path = rustc_target::target_rustlib_path(&p, \"dummy\");\n+                rustlib_path.pop(); // pop off the dummy target.\n+                if rustlib_path.exists() { Some(p) } else { None }\n             }\n             None => None,\n         }\n@@ -171,37 +167,3 @@ pub fn get_or_default_sysroot() -> PathBuf {\n     // use env::current_exe() to imply sysroot.\n     from_env_args_next().unwrap_or_else(from_current_exe)\n }\n-\n-// The name of the directory rustc expects libraries to be located.\n-fn find_libdir(sysroot: &Path) -> Cow<'static, str> {\n-    // FIXME: This is a quick hack to make the rustc binary able to locate\n-    // Rust libraries in Linux environments where libraries might be installed\n-    // to lib64/lib32. This would be more foolproof by basing the sysroot off\n-    // of the directory where `librustc_driver` is located, rather than\n-    // where the rustc binary is.\n-    // If --libdir is set during configuration to the value other than\n-    // \"lib\" (i.e., non-default), this value is used (see issue #16552).\n-\n-    #[cfg(target_pointer_width = \"64\")]\n-    const PRIMARY_LIB_DIR: &str = \"lib64\";\n-\n-    #[cfg(target_pointer_width = \"32\")]\n-    const PRIMARY_LIB_DIR: &str = \"lib32\";\n-\n-    const SECONDARY_LIB_DIR: &str = \"lib\";\n-\n-    match option_env!(\"CFG_LIBDIR_RELATIVE\") {\n-        None | Some(\"lib\") => {\n-            if sysroot.join(PRIMARY_LIB_DIR).join(RUST_LIB_DIR).exists() {\n-                PRIMARY_LIB_DIR.into()\n-            } else {\n-                SECONDARY_LIB_DIR.into()\n-            }\n-        }\n-        Some(libdir) => libdir.into(),\n-    }\n-}\n-\n-// The name of rustc's own place to organize libraries.\n-// Used to be \"rustc\", now the default is \"rustlib\"\n-const RUST_LIB_DIR: &str = \"rustlib\";"}, {"sha": "48ace9b65b6787979655b871b4e63965abc75ef8", "filename": "compiler/rustc_target/src/lib.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b7c5599d22018ab6be88442c4668bc1697f85b8e/compiler%2Frustc_target%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c5599d22018ab6be88442c4668bc1697f85b8e/compiler%2Frustc_target%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Flib.rs?ref=b7c5599d22018ab6be88442c4668bc1697f85b8e", "patch": "@@ -15,6 +15,8 @@\n #![feature(associated_type_bounds)]\n #![feature(exhaustive_patterns)]\n \n+use std::path::{Path, PathBuf};\n+\n #[macro_use]\n extern crate rustc_macros;\n \n@@ -29,3 +31,52 @@ pub mod spec;\n /// This is a hack to allow using the `HashStable_Generic` derive macro\n /// instead of implementing everything in `rustc_middle`.\n pub trait HashStableContext {}\n+\n+/// The name of rustc's own place to organize libraries.\n+///\n+/// Used to be `rustc`, now the default is `rustlib`.\n+const RUST_LIB_DIR: &str = \"rustlib\";\n+\n+/// Returns a `rustlib` path for this particular target, relative to the provided sysroot.\n+///\n+/// For example: `target_sysroot_path(\"/usr\", \"x86_64-unknown-linux-gnu\")` =>\n+/// `\"lib*/rustlib/x86_64-unknown-linux-gnu\"`.\n+pub fn target_rustlib_path(sysroot: &Path, target_triple: &str) -> PathBuf {\n+    let libdir = find_libdir(sysroot);\n+    std::array::IntoIter::new([\n+        Path::new(libdir.as_ref()),\n+        Path::new(RUST_LIB_DIR),\n+        Path::new(target_triple),\n+    ])\n+    .collect::<PathBuf>()\n+}\n+\n+/// The name of the directory rustc expects libraries to be located.\n+fn find_libdir(sysroot: &Path) -> std::borrow::Cow<'static, str> {\n+    // FIXME: This is a quick hack to make the rustc binary able to locate\n+    // Rust libraries in Linux environments where libraries might be installed\n+    // to lib64/lib32. This would be more foolproof by basing the sysroot off\n+    // of the directory where `librustc_driver` is located, rather than\n+    // where the rustc binary is.\n+    // If --libdir is set during configuration to the value other than\n+    // \"lib\" (i.e., non-default), this value is used (see issue #16552).\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    const PRIMARY_LIB_DIR: &str = \"lib64\";\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    const PRIMARY_LIB_DIR: &str = \"lib32\";\n+\n+    const SECONDARY_LIB_DIR: &str = \"lib\";\n+\n+    match option_env!(\"CFG_LIBDIR_RELATIVE\") {\n+        None | Some(\"lib\") => {\n+            if sysroot.join(PRIMARY_LIB_DIR).join(RUST_LIB_DIR).exists() {\n+                PRIMARY_LIB_DIR.into()\n+            } else {\n+                SECONDARY_LIB_DIR.into()\n+            }\n+        }\n+        Some(libdir) => libdir.into(),\n+    }\n+}"}, {"sha": "4bffd6e8ddd354a7457e28c5321185b6b96e2db0", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b7c5599d22018ab6be88442c4668bc1697f85b8e/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c5599d22018ab6be88442c4668bc1697f85b8e/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=b7c5599d22018ab6be88442c4668bc1697f85b8e", "patch": "@@ -1897,15 +1897,15 @@ impl Target {\n         Ok(base)\n     }\n \n-    /// Search RUST_TARGET_PATH for a JSON file specifying the given target\n-    /// triple. If none is found, look for a file called `target.json` inside\n-    /// the sysroot under the target-triple's `rustlib` directory.\n-    /// Note that it could also just be a bare filename already, so also\n-    /// check for that. If one of the hardcoded targets we know about, just\n-    /// return it directly.\n+    /// Search for a JSON file specifying the given target triple.\n     ///\n-    /// The error string could come from any of the APIs called, including\n-    /// filesystem access and JSON decoding.\n+    /// If none is found in `$RUST_TARGET_PATH`, look for a file called `target.json` inside the\n+    /// sysroot under the target-triple's `rustlib` directory.  Note that it could also just be a\n+    /// bare filename already, so also check for that. If one of the hardcoded targets we know\n+    /// about, just return it directly.\n+    ///\n+    /// The error string could come from any of the APIs called, including filesystem access and\n+    /// JSON decoding.\n     pub fn search(target_triple: &TargetTriple, sysroot: &PathBuf) -> Result<Target, String> {\n         use rustc_serialize::json;\n         use std::env;\n@@ -1942,8 +1942,13 @@ impl Target {\n \n                 // Additionally look in the sysroot under `lib/rustlib/<triple>/target.json`\n                 // as a fallback.\n-                let p =\n-                    sysroot.join(\"lib\").join(\"rustlib\").join(&target_triple).join(\"target.json\");\n+                let rustlib_path = crate::target_rustlib_path(&sysroot, &target_triple);\n+                let p = std::array::IntoIter::new([\n+                    Path::new(sysroot),\n+                    Path::new(&rustlib_path),\n+                    Path::new(\"target.json\"),\n+                ])\n+                .collect::<PathBuf>();\n                 if p.is_file() {\n                     return load_file(&p);\n                 }"}]}