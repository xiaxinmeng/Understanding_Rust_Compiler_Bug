{"sha": "36c0ee97b9f888d576fe4302b0aad846b4446e6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2YzBlZTk3YjlmODg4ZDU3NmZlNDMwMmIwYWFkODQ2YjQ0NDZlNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-18T06:24:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-18T06:24:56Z"}, "message": "Auto merge of #53900 - davidtwco:issue-53771, r=nikomatsakis\n\nNLL regresses diagnostic for impl-trait/static-return-lifetime-infered.rs\n\nFixes #53771.\n\nr? @nikomatsakis\ncc @pnkfelix @estebank", "tree": {"sha": "21e41b217ecbfd4d21eac1c0f2bf2dee1d97f2ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21e41b217ecbfd4d21eac1c0f2bf2dee1d97f2ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36c0ee97b9f888d576fe4302b0aad846b4446e6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36c0ee97b9f888d576fe4302b0aad846b4446e6c", "html_url": "https://github.com/rust-lang/rust/commit/36c0ee97b9f888d576fe4302b0aad846b4446e6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36c0ee97b9f888d576fe4302b0aad846b4446e6c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b80cb47889e0ad9400b6708ce2b4c4b364b71982", "url": "https://api.github.com/repos/rust-lang/rust/commits/b80cb47889e0ad9400b6708ce2b4c4b364b71982", "html_url": "https://github.com/rust-lang/rust/commit/b80cb47889e0ad9400b6708ce2b4c4b364b71982"}, {"sha": "18c1374bf86bf061a7f5f73fcebea5abc2a80922", "url": "https://api.github.com/repos/rust-lang/rust/commits/18c1374bf86bf061a7f5f73fcebea5abc2a80922", "html_url": "https://github.com/rust-lang/rust/commit/18c1374bf86bf061a7f5f73fcebea5abc2a80922"}], "stats": {"total": 400, "additions": 276, "deletions": 124}, "files": [{"sha": "97b1978cb2eb2223af8e437504a15ee63945b470", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=36c0ee97b9f888d576fe4302b0aad846b4446e6c", "patch": "@@ -56,9 +56,9 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         let (span, sub, sup) = self.get_regions();\n \n         // Determine whether the sub and sup consist of both anonymous (elided) regions.\n-        let anon_reg_sup = self.is_suitable_region(sup)?;\n+        let anon_reg_sup = self.tcx.is_suitable_region(sup)?;\n \n-        let anon_reg_sub = self.is_suitable_region(sub)?;\n+        let anon_reg_sub = self.tcx.is_suitable_region(sub)?;\n         let scope_def_id_sup = anon_reg_sup.def_id;\n         let bregion_sup = anon_reg_sup.boundregion;\n         let scope_def_id_sub = anon_reg_sub.def_id;"}, {"sha": "10a2d179dd564e4aef52f81f24da3c75b115956f", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=36c0ee97b9f888d576fe4302b0aad846b4446e6c", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         region: Region<'tcx>,\n         br: &ty::BoundRegion,\n     ) -> Option<(&hir::Ty, &hir::FnDecl)> {\n-        if let Some(anon_reg) = self.is_suitable_region(region) {\n+        if let Some(anon_reg) = self.tcx.is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let fndecl = match self.tcx.hir.get(node_id) {"}, {"sha": "0eb634ea2cc8e4f3f11aa5ed74e63b3e47e427c5", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=36c0ee97b9f888d576fe4302b0aad846b4446e6c", "patch": "@@ -33,23 +33,23 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.//scope_def_id\n         let (named, anon, anon_arg_info, region_info) = if self.is_named_region(sub)\n-            && self.is_suitable_region(sup).is_some()\n+            && self.tcx.is_suitable_region(sup).is_some()\n             && self.find_arg_with_region(sup, sub).is_some()\n         {\n             (\n                 sub,\n                 sup,\n                 self.find_arg_with_region(sup, sub).unwrap(),\n-                self.is_suitable_region(sup).unwrap(),\n+                self.tcx.is_suitable_region(sup).unwrap(),\n             )\n-        } else if self.is_named_region(sup) && self.is_suitable_region(sub).is_some()\n+        } else if self.is_named_region(sup) && self.tcx.is_suitable_region(sub).is_some()\n             && self.find_arg_with_region(sub, sup).is_some()\n         {\n             (\n                 sup,\n                 sub,\n                 self.find_arg_with_region(sub, sup).unwrap(),\n-                self.is_suitable_region(sub).unwrap(),\n+                self.tcx.is_suitable_region(sub).unwrap(),\n             )\n         } else {\n             return None; // inapplicable"}, {"sha": "29ba23b58bc0ce8418d9f39a13f376bb7cff6599", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=36c0ee97b9f888d576fe4302b0aad846b4446e6c", "patch": "@@ -27,9 +27,9 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                     sup_origin,\n                     sup_r,\n                 ) => {\n-                    let anon_reg_sup = self.is_suitable_region(sup_r)?;\n+                    let anon_reg_sup = self.tcx.is_suitable_region(sup_r)?;\n                     if sub_r == &RegionKind::ReStatic &&\n-                        self.is_return_type_impl_trait(anon_reg_sup.def_id)\n+                        self.tcx.return_type_impl_trait(anon_reg_sup.def_id).is_some()\n                     {\n                         let sp = var_origin.span();\n                         let return_sp = sub_origin.span();"}, {"sha": "afc50fe1151665e3a37fb37549644f74013d5344", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=36c0ee97b9f888d576fe4302b0aad846b4446e6c", "patch": "@@ -15,7 +15,6 @@ use hir;\n use infer::error_reporting::nice_region_error::NiceRegionError;\n use ty::{self, Region, Ty};\n use hir::def_id::DefId;\n-use hir::Node;\n use syntax_pos::Span;\n \n // The struct contains the information about the anonymous region\n@@ -35,18 +34,6 @@ pub(super) struct AnonymousArgInfo<'tcx> {\n     pub is_first: bool,\n }\n \n-// This struct contains information regarding the\n-// Refree((FreeRegion) corresponding to lifetime conflict\n-#[derive(Debug)]\n-pub(super) struct FreeRegionInfo {\n-    // def id corresponding to FreeRegion\n-    pub def_id: DefId,\n-    // the bound region corresponding to FreeRegion\n-    pub boundregion: ty::BoundRegion,\n-    // checks if bound region is in Impl Item\n-    pub is_impl_item: bool,\n-}\n-\n impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     // This method walks the Type of the function body arguments using\n     // `fold_regions()` function and returns the\n@@ -122,36 +109,6 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // This method returns the DefId and the BoundRegion corresponding to the given region.\n-    pub(super) fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n-        let (suitable_region_binding_scope, bound_region) = match *region {\n-            ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n-            ty::ReEarlyBound(ref ebr) => (\n-                self.tcx.parent_def_id(ebr.def_id).unwrap(),\n-                ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n-            ),\n-            _ => return None, // not a free region\n-        };\n-\n-        let node_id = self.tcx\n-            .hir\n-            .as_local_node_id(suitable_region_binding_scope)\n-            .unwrap();\n-        let is_impl_item = match self.tcx.hir.find(node_id) {\n-            Some(Node::Item(..)) | Some(Node::TraitItem(..)) => false,\n-            Some(Node::ImplItem(..)) => {\n-                self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n-            }\n-            _ => return None,\n-        };\n-\n-        return Some(FreeRegionInfo {\n-            def_id: suitable_region_binding_scope,\n-            boundregion: bound_region,\n-            is_impl_item: is_impl_item,\n-        });\n-    }\n-\n     // Here, we check for the case where the anonymous region\n     // is in the return type.\n     // FIXME(#42703) - Need to handle certain cases here.\n@@ -176,22 +133,6 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    pub(super) fn is_return_type_impl_trait(\n-        &self,\n-        scope_def_id: DefId,\n-    ) -> bool {\n-        let ret_ty = self.tcx.type_of(scope_def_id);\n-        match ret_ty.sty {\n-            ty::FnDef(_, _) => {\n-                let sig = ret_ty.fn_sig(self.tcx);\n-                let output = self.tcx.erase_late_bound_regions(&sig.output());\n-                return output.is_impl_trait();\n-            }\n-            _ => {}\n-        }\n-        false\n-    }\n-\n     // Here we check for the case where anonymous region\n     // corresponds to self and if yes, we display E0312.\n     // FIXME(#42700) - Need to format self properly to\n@@ -203,24 +144,4 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                 .map(|i| i.method_has_self_argument) == Some(true)\n     }\n \n-    // Here we check if the bound region is in Impl Item.\n-    pub(super) fn is_bound_region_in_impl_item(\n-        &self,\n-        suitable_region_binding_scope: DefId,\n-    ) -> bool {\n-        let container_id = self.tcx\n-            .associated_item(suitable_region_binding_scope)\n-            .container\n-            .id();\n-        if self.tcx.impl_trait_ref(container_id).is_some() {\n-            // For now, we do not try to target impls of traits. This is\n-            // because this message is going to suggest that the user\n-            // change the fn signature, but they may not be free to do so,\n-            // since the signature must match the trait.\n-            //\n-            // FIXME(#42706) -- in some cases, we could do better here.\n-            return true;\n-        }\n-        false\n-    }\n }"}, {"sha": "03c0b680acf78327953bc3f37f05e4c49650ddd2", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=36c0ee97b9f888d576fe4302b0aad846b4446e6c", "patch": "@@ -17,7 +17,7 @@ use session::Session;\n use session::config::{BorrowckMode, OutputFilenames};\n use session::config::CrateType;\n use middle;\n-use hir::{TraitCandidate, HirId, ItemLocalId};\n+use hir::{TraitCandidate, HirId, ItemLocalId, Node};\n use hir::def::{Def, Export};\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as hir_map;\n@@ -872,6 +872,18 @@ impl<'tcx> CommonTypes<'tcx> {\n     }\n }\n \n+// This struct contains information regarding the `ReFree(FreeRegion)` corresponding to a lifetime\n+// conflict.\n+#[derive(Debug)]\n+pub struct FreeRegionInfo {\n+    // def id corresponding to FreeRegion\n+    pub def_id: DefId,\n+    // the bound region corresponding to FreeRegion\n+    pub boundregion: ty::BoundRegion,\n+    // checks if bound region is in Impl Item\n+    pub is_impl_item: bool,\n+}\n+\n /// The central data structure of the compiler. It stores references\n /// to the various **arenas** and also houses the results of the\n /// various **compiler queries** that have been performed. See the\n@@ -1571,6 +1583,74 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n         })\n     }\n+\n+    // This method returns the DefId and the BoundRegion corresponding to the given region.\n+    pub fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n+        let (suitable_region_binding_scope, bound_region) = match *region {\n+            ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n+            ty::ReEarlyBound(ref ebr) => (\n+                self.parent_def_id(ebr.def_id).unwrap(),\n+                ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n+            ),\n+            _ => return None, // not a free region\n+        };\n+\n+        let node_id = self.hir\n+            .as_local_node_id(suitable_region_binding_scope)\n+            .unwrap();\n+        let is_impl_item = match self.hir.find(node_id) {\n+            Some(Node::Item(..)) | Some(Node::TraitItem(..)) => false,\n+            Some(Node::ImplItem(..)) => {\n+                self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n+            }\n+            _ => return None,\n+        };\n+\n+        return Some(FreeRegionInfo {\n+            def_id: suitable_region_binding_scope,\n+            boundregion: bound_region,\n+            is_impl_item: is_impl_item,\n+        });\n+    }\n+\n+    pub fn return_type_impl_trait(\n+        &self,\n+        scope_def_id: DefId,\n+    ) -> Option<Ty<'tcx>> {\n+        let ret_ty = self.type_of(scope_def_id);\n+        match ret_ty.sty {\n+            ty::FnDef(_, _) => {\n+                let sig = ret_ty.fn_sig(*self);\n+                let output = self.erase_late_bound_regions(&sig.output());\n+                if output.is_impl_trait() {\n+                    Some(output)\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    // Here we check if the bound region is in Impl Item.\n+    pub fn is_bound_region_in_impl_item(\n+        &self,\n+        suitable_region_binding_scope: DefId,\n+    ) -> bool {\n+        let container_id = self.associated_item(suitable_region_binding_scope)\n+            .container\n+            .id();\n+        if self.impl_trait_ref(container_id).is_some() {\n+            // For now, we do not try to target impls of traits. This is\n+            // because this message is going to suggest that the user\n+            // change the fn signature, but they may not be free to do so,\n+            // since the signature must match the trait.\n+            //\n+            // FIXME(#42706) -- in some cases, we could do better here.\n+            return true;\n+        }\n+        false\n+    }\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {"}, {"sha": "940da6099e0824704c792dbca67fad55bbc1c0f8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=36c0ee97b9f888d576fe4302b0aad846b4446e6c", "patch": "@@ -80,7 +80,7 @@ pub use self::sty::TyKind::*;\n pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n \n-pub use self::context::{TyCtxt, GlobalArenas, AllArenas, tls, keep_local};\n+pub use self::context::{TyCtxt, FreeRegionInfo, GlobalArenas, AllArenas, tls, keep_local};\n pub use self::context::{Lift, TypeckTables};\n \n pub use self::instance::{Instance, InstanceDef};"}, {"sha": "dfed41cb1defd5de4bcf145a0f116dc8da4bcd7d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 90, "deletions": 3, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=36c0ee97b9f888d576fe4302b0aad846b4446e6c", "patch": "@@ -15,16 +15,19 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n use rustc::mir::{self, Location, Mir, Place, Rvalue, StatementKind, TerminatorKind};\n-use rustc::ty::{TyCtxt, RegionVid};\n+use rustc::ty::{self, TyCtxt, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_errors::Diagnostic;\n+use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use std::collections::VecDeque;\n use std::fmt;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n mod region_name;\n mod var_name;\n \n+use self::region_name::RegionName;\n+\n /// Constraints that are considered interesting can be categorized to\n /// determine why they are interesting. Order of variants indicates\n /// sort order of the category, thereby influencing diagnostic output.\n@@ -356,9 +359,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.universal_regions.is_local_free_region(fr),\n             self.universal_regions.is_local_free_region(outlived_fr),\n         );\n+\n         debug!(\"report_error: fr_is_local={:?} outlived_fr_is_local={:?} category={:?}\",\n                fr_is_local, outlived_fr_is_local, category);\n-\n         match (category, fr_is_local, outlived_fr_is_local) {\n             (ConstraintCategory::Assignment, true, false) |\n             (ConstraintCategory::CallArgument, true, false) =>\n@@ -465,9 +468,93 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             },\n         }\n \n+        self.add_static_impl_trait_suggestion(\n+            infcx, &mut diag, fr, fr_name, outlived_fr,\n+        );\n+\n         diag.buffer(errors_buffer);\n     }\n \n+    fn add_static_impl_trait_suggestion(\n+        &self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        diag: &mut DiagnosticBuilder<'_>,\n+        fr: RegionVid,\n+        // We need to pass `fr_name` - computing it again will label it twice.\n+        fr_name: RegionName,\n+        outlived_fr: RegionVid,\n+    ) {\n+        if let (\n+            Some(f),\n+            Some(ty::RegionKind::ReStatic)\n+        ) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n+            if let Some(ty::TyS {\n+                sty: ty::TyKind::Opaque(did, substs),\n+                ..\n+            }) = infcx.tcx.is_suitable_region(f)\n+                    .map(|r| r.def_id)\n+                    .map(|id| infcx.tcx.return_type_impl_trait(id))\n+                    .unwrap_or(None)\n+            {\n+                // Check whether or not the impl trait return type is intended to capture\n+                // data with the static lifetime.\n+                //\n+                // eg. check for `impl Trait + 'static` instead of `impl Trait`.\n+                let has_static_predicate = {\n+                    let predicates_of = infcx.tcx.predicates_of(*did);\n+                    let bounds = predicates_of.instantiate(infcx.tcx, substs);\n+\n+                    let mut found = false;\n+                    for predicate in bounds.predicates {\n+                        if let ty::Predicate::TypeOutlives(binder) = predicate {\n+                            if let ty::OutlivesPredicate(\n+                                _,\n+                                ty::RegionKind::ReStatic\n+                            ) = binder.skip_binder() {\n+                                found = true;\n+                                break;\n+                            }\n+                        }\n+                    }\n+\n+                    found\n+                };\n+\n+                debug!(\"add_static_impl_trait_suggestion: has_static_predicate={:?}\",\n+                       has_static_predicate);\n+                let static_str = keywords::StaticLifetime.name();\n+                // If there is a static predicate, then the only sensible suggestion is to replace\n+                // fr with `'static`.\n+                if has_static_predicate {\n+                    diag.help(\n+                        &format!(\n+                            \"consider replacing `{}` with `{}`\",\n+                            fr_name, static_str,\n+                        ),\n+                    );\n+                } else {\n+                    // Otherwise, we should suggest adding a constraint on the return type.\n+                    let span = infcx.tcx.def_span(*did);\n+                    if let Ok(snippet) = infcx.tcx.sess.source_map().span_to_snippet(span) {\n+                        let suggestable_fr_name = match fr_name {\n+                            RegionName::Named(name) => format!(\"{}\", name),\n+                            RegionName::Synthesized(_) => \"'_\".to_string(),\n+                        };\n+                        diag.span_suggestion(\n+                            span,\n+                            &format!(\n+                                \"to allow this impl Trait to capture borrowed data with lifetime \\\n+                                 `{}`, add `{}` as a constraint\",\n+                                fr_name, suggestable_fr_name,\n+                            ),\n+                            format!(\"{} + {}\", snippet, suggestable_fr_name),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     // Finds some region R such that `fr1: R` and `R` is live at\n     // `elem`.\n     crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {"}, {"sha": "857f1dae7ab5175c27e347630c3e743a5a8938f9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 81, "deletions": 31, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=36c0ee97b9f888d576fe4302b0aad846b4446e6c", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::fmt::{self, Display};\n use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::universal_regions::DefiningTy;\n use borrow_check::nll::ToRegionVid;\n@@ -21,8 +22,35 @@ use rustc::util::ppaux::with_highlight_region;\n use rustc_errors::DiagnosticBuilder;\n use syntax::ast::{Name, DUMMY_NODE_ID};\n use syntax::symbol::keywords;\n+use syntax_pos::Span;\n use syntax_pos::symbol::InternedString;\n \n+/// Name of a region used in error reporting. Variants denote the source of the region name -\n+/// whether it was synthesized for the error message and therefore should not be used in\n+/// suggestions; or whether it was found from the region.\n+#[derive(Debug)]\n+pub(crate) enum RegionName {\n+    Named(InternedString),\n+    Synthesized(InternedString),\n+}\n+\n+impl RegionName {\n+    fn as_interned_string(&self) -> &InternedString {\n+        match self {\n+            RegionName::Named(name) | RegionName::Synthesized(name) => name,\n+        }\n+    }\n+}\n+\n+impl Display for RegionName {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            RegionName::Named(name) | RegionName::Synthesized(name) =>\n+                write!(f, \"{}\", name),\n+        }\n+    }\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Maps from an internal MIR region vid to something that we can\n     /// report to the user. In some cases, the region vids will map\n@@ -57,7 +85,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr: RegionVid,\n         counter: &mut usize,\n         diag: &mut DiagnosticBuilder,\n-    ) -> InternedString {\n+    ) -> RegionName {\n         debug!(\"give_region_a_name(fr={:?}, counter={})\", fr, counter);\n \n         assert!(self.universal_regions.is_universal_region(fr));\n@@ -95,27 +123,31 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr: RegionVid,\n         counter: &mut usize,\n         diag: &mut DiagnosticBuilder<'_>,\n-    ) -> Option<InternedString> {\n+    ) -> Option<RegionName> {\n         let error_region = self.to_error_region(fr)?;\n \n         debug!(\"give_region_a_name: error_region = {:?}\", error_region);\n         match error_region {\n             ty::ReEarlyBound(ebr) => {\n                 if ebr.has_name() {\n-                    self.highlight_named_span(tcx, error_region, &ebr.name, diag);\n-                    Some(ebr.name)\n+                    let name = RegionName::Named(ebr.name);\n+                    self.highlight_named_span(tcx, error_region, &name, diag);\n+                    Some(name)\n                 } else {\n                     None\n                 }\n             }\n \n-            ty::ReStatic => Some(keywords::StaticLifetime.name().as_interned_str()),\n+            ty::ReStatic => Some(RegionName::Named(\n+                keywords::StaticLifetime.name().as_interned_str()\n+            )),\n \n             ty::ReFree(free_region) => match free_region.bound_region {\n                 ty::BoundRegion::BrNamed(_, name) => {\n+                    let name = RegionName::Named(name);\n                     self.highlight_named_span(tcx, error_region, &name, diag);\n                     Some(name)\n-                }\n+                },\n \n                 ty::BoundRegion::BrEnv => {\n                     let mir_node_id = tcx.hir.as_local_node_id(mir_def_id).expect(\"non-local mir\");\n@@ -132,7 +164,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         let region_name = self.synthesize_region_name(counter);\n                         diag.span_label(\n                             args_span,\n-                            format!(\"lifetime `{}` represents this closure's body\", region_name),\n+                            format!(\n+                                \"lifetime `{}` represents this closure's body\",\n+                                region_name\n+                            ),\n                         );\n \n                         let closure_kind_ty = substs.closure_kind_ty(def_id, tcx);\n@@ -174,6 +209,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n+    /// Get the span of a named region.\n+    pub(super) fn get_span_of_named_region(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        error_region: &RegionKind,\n+        name: &RegionName,\n+    ) -> Span {\n+        let scope = error_region.free_region_binding_scope(tcx);\n+        let node = tcx.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n+\n+        let span = tcx.sess.source_map().def_span(tcx.hir.span(node));\n+        if let Some(param) = tcx.hir.get_generics(scope).and_then(|generics| {\n+            generics.get_named(name.as_interned_string())\n+        }) {\n+            param.span\n+        } else {\n+            span\n+        }\n+    }\n+\n     /// Highlight a named span to provide context for error messages that\n     /// mention that span, for example:\n     ///\n@@ -192,23 +247,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         error_region: &RegionKind,\n-        name: &InternedString,\n+        name: &RegionName,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) {\n-        let cm = tcx.sess.source_map();\n+        let span = self.get_span_of_named_region(tcx, error_region, name);\n \n-        let scope = error_region.free_region_binding_scope(tcx);\n-        let node = tcx.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n-\n-        let mut sp = cm.def_span(tcx.hir.span(node));\n-        if let Some(param) = tcx.hir\n-            .get_generics(scope)\n-            .and_then(|generics| generics.get_named(name))\n-        {\n-            sp = param.span;\n-        }\n-\n-        diag.span_label(sp, format!(\"lifetime `{}` defined here\", name));\n+        diag.span_label(\n+            span,\n+            format!(\"lifetime `{}` defined here\", name),\n+        );\n     }\n \n     /// Find an argument that contains `fr` and label it with a fully\n@@ -227,7 +274,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr: RegionVid,\n         counter: &mut usize,\n         diag: &mut DiagnosticBuilder<'_>,\n-    ) -> Option<InternedString> {\n+    ) -> Option<RegionName> {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n         let argument_index = self.get_argument_index_for_region(infcx.tcx, fr)?;\n \n@@ -259,7 +306,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_index: usize,\n         counter: &mut usize,\n         diag: &mut DiagnosticBuilder<'_>,\n-    ) -> Option<InternedString> {\n+    ) -> Option<RegionName> {\n         let mir_node_id = infcx.tcx.hir.as_local_node_id(mir_def_id)?;\n         let fn_decl = infcx.tcx.hir.fn_decl(mir_node_id)?;\n         let argument_hir_ty: &hir::Ty = &fn_decl.inputs[argument_index];\n@@ -306,7 +353,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_ty: Ty<'tcx>,\n         counter: &mut usize,\n         diag: &mut DiagnosticBuilder<'_>,\n-    ) -> Option<InternedString> {\n+    ) -> Option<RegionName> {\n         let type_name = with_highlight_region(needle_fr, *counter, || {\n             infcx.extract_type_name(&argument_ty)\n         });\n@@ -361,7 +408,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_hir_ty: &hir::Ty,\n         counter: &mut usize,\n         diag: &mut DiagnosticBuilder<'_>,\n-    ) -> Option<InternedString> {\n+    ) -> Option<RegionName> {\n         let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty)> = &mut Vec::new();\n \n         search_stack.push((argument_ty, argument_hir_ty));\n@@ -457,7 +504,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         counter: &mut usize,\n         diag: &mut DiagnosticBuilder<'_>,\n         search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty)>,\n-    ) -> Option<InternedString> {\n+    ) -> Option<RegionName> {\n         // Did the user give explicit arguments? (e.g., `Foo<..>`)\n         let args = last_segment.args.as_ref()?;\n         let lifetime = self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n@@ -467,7 +514,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             | hir::LifetimeName::Underscore => {\n                 let region_name = self.synthesize_region_name(counter);\n                 let ampersand_span = lifetime.span;\n-                diag.span_label(ampersand_span, format!(\"let's call this `{}`\", region_name));\n+                diag.span_label(\n+                    ampersand_span,\n+                    format!(\"let's call this `{}`\", region_name)\n+                );\n                 return Some(region_name);\n             }\n \n@@ -544,7 +594,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr: RegionVid,\n         counter: &mut usize,\n         diag: &mut DiagnosticBuilder<'_>,\n-    ) -> Option<InternedString> {\n+    ) -> Option<RegionName> {\n         let upvar_index = self.get_upvar_index_for_region(tcx, fr)?;\n         let (upvar_name, upvar_span) =\n             self.get_upvar_name_and_span_for_region(tcx, mir, upvar_index);\n@@ -573,7 +623,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr: RegionVid,\n         counter: &mut usize,\n         diag: &mut DiagnosticBuilder<'_>,\n-    ) -> Option<InternedString> {\n+    ) -> Option<RegionName> {\n         let tcx = infcx.tcx;\n \n         let return_ty = self.universal_regions.unnormalized_output_ty;\n@@ -622,10 +672,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Create a synthetic region named `'1`, incrementing the\n     /// counter.\n-    fn synthesize_region_name(&self, counter: &mut usize) -> InternedString {\n+    fn synthesize_region_name(&self, counter: &mut usize) -> RegionName {\n         let c = *counter;\n         *counter += 1;\n \n-        Name::intern(&format!(\"'{:?}\", c)).as_interned_str()\n+        RegionName::Synthesized(Name::intern(&format!(\"'{:?}\", c)).as_interned_str())\n     }\n }"}, {"sha": "3019e3aa1f7324c64535d2ee08b85f7c5275dbce", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=36c0ee97b9f888d576fe4302b0aad846b4446e6c", "patch": "@@ -11,12 +11,18 @@ error: unsatisfied lifetime constraints\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n    |             -- lifetime `'a` defined here  ^ returning this value requires that `'a` must outlive `'static`\n+help: to allow this impl Trait to capture borrowed data with lifetime `'a`, add `'a` as a constraint\n+   |\n+LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n+   |                                ^^^^^^^^^^^^^^\n \n error: unsatisfied lifetime constraints\n   --> $DIR/must_outlive_least_region_or_bound.rs:22:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |               -- lifetime `'a` defined here                         ^ returning this value requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n \n error: unsatisfied lifetime constraints\n   --> $DIR/must_outlive_least_region_or_bound.rs:29:5"}, {"sha": "4bc8876c232e3354d3bf76a39e6d1a52265d77cb", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.nll.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36c0ee97b9f888d576fe4302b0aad846b4446e6c/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr?ref=36c0ee97b9f888d576fe4302b0aad846b4446e6c", "patch": "@@ -5,6 +5,10 @@ LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n    |                         - let's call the lifetime of this reference `'1`\n LL |         self.x.iter().map(|a| a.0)\n    |         ^^^^^^ cast requires that `'1` must outlive `'static`\n+help: to allow this impl Trait to capture borrowed data with lifetime `'1`, add `'_` as a constraint\n+   |\n+LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsatisfied lifetime constraints\n   --> $DIR/static-return-lifetime-infered.rs:21:9\n@@ -13,6 +17,10 @@ LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n    |                    -- lifetime `'a` defined here\n LL |         self.x.iter().map(|a| a.0)\n    |         ^^^^^^ cast requires that `'a` must outlive `'static`\n+help: to allow this impl Trait to capture borrowed data with lifetime `'a`, add `'a` as a constraint\n+   |\n+LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}]}