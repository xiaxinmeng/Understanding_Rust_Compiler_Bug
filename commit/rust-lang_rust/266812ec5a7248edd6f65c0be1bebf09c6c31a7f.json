{"sha": "266812ec5a7248edd6f65c0be1bebf09c6c31a7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2NjgxMmVjNWE3MjQ4ZWRkNmY2NWMwYmUxYmViZjA5YzZjMzFhN2Y=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-04-23T19:04:34Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-04-23T20:15:32Z"}, "message": "fix std::f32 and std::f64 constants\n\nSome of the constant values in std::f32 were incorrectly copied from\nstd::f64.  More broadly, both modules defined their constants redundantly\nin two places, which is what led to the bug.  Moreover, the specs for\nsome of the constants were incorrent, even when the values were correct.\n\nCloses #13297.  Closes #11537.", "tree": {"sha": "ac5db810f7518feee992ff6f5da77bbb5a6c19b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac5db810f7518feee992ff6f5da77bbb5a6c19b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/266812ec5a7248edd6f65c0be1bebf09c6c31a7f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/266812ec5a7248edd6f65c0be1bebf09c6c31a7f", "html_url": "https://github.com/rust-lang/rust/commit/266812ec5a7248edd6f65c0be1bebf09c6c31a7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/266812ec5a7248edd6f65c0be1bebf09c6c31a7f/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5dd3f05fe95168b5569d0f519636149479eb6ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5dd3f05fe95168b5569d0f519636149479eb6ac", "html_url": "https://github.com/rust-lang/rust/commit/b5dd3f05fe95168b5569d0f519636149479eb6ac"}], "stats": {"total": 169, "additions": 94, "deletions": 75}, "files": [{"sha": "6df549dbc791b8e149b6f46814a7b4b1cb007d19", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 54, "deletions": 45, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/266812ec5a7248edd6f65c0be1bebf09c6c31a7f/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266812ec5a7248edd6f65c0be1bebf09c6c31a7f/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=266812ec5a7248edd6f65c0be1bebf09c6c31a7f", "patch": "@@ -64,48 +64,56 @@ mod cmath {\n     }\n }\n \n-// FIXME(#11621): These constants should be deprecated once CTFE is implemented\n-// in favour of calling their respective functions in `Bounded` and `Float`.\n-\n pub static RADIX: uint = 2u;\n \n-pub static MANTISSA_DIGITS: uint = 53u;\n-pub static DIGITS: uint = 15u;\n+pub static MANTISSA_DIGITS: uint = 24u;\n+pub static DIGITS: uint = 6u;\n \n-pub static EPSILON: f64 = 2.220446e-16_f64;\n+pub static EPSILON: f32 = 1.19209290e-07_f32;\n \n-// FIXME (#1433): this is wrong, replace with hexadecimal (%a) statics\n-// below.\n-pub static MIN_VALUE: f64 = 2.225074e-308_f64;\n-pub static MAX_VALUE: f64 = 1.797693e+308_f64;\n+/// Minimum normalized f32 value\n+pub static MIN_VALUE: f32 = 1.17549435e-38_f32;\n+/// Maximum f32 value\n+pub static MAX_VALUE: f32 = 3.40282347e+38_f32;\n \n-pub static MIN_EXP: uint = -1021u;\n-pub static MAX_EXP: uint = 1024u;\n+pub static MIN_EXP: int = -125;\n+pub static MAX_EXP: int = 128;\n \n-pub static MIN_10_EXP: int = -307;\n-pub static MAX_10_EXP: int = 308;\n+pub static MIN_10_EXP: int = -37;\n+pub static MAX_10_EXP: int = 38;\n \n pub static NAN: f32 = 0.0_f32/0.0_f32;\n pub static INFINITY: f32 = 1.0_f32/0.0_f32;\n pub static NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n \n /// Various useful constants.\n pub mod consts {\n-    // FIXME (requires Issue #1433 to fix): replace with mathematical\n-    // staticants from cmath.\n+    // FIXME: replace with mathematical constants from cmath.\n \n     // FIXME(#11621): These constants should be deprecated once CTFE is\n     // implemented in favour of calling their respective functions in `Float`.\n \n     /// Archimedes' constant\n     pub static PI: f32 = 3.14159265358979323846264338327950288_f32;\n \n+    /// pi * 2.0\n+    pub static PI_2: f32 = 6.28318530717958647692528676655900576_f32;\n+\n     /// pi/2.0\n     pub static FRAC_PI_2: f32 = 1.57079632679489661923132169163975144_f32;\n \n+    /// pi/3.0\n+    pub static FRAC_PI_3: f32 = 1.04719755119659774615421446109316763_f32;\n+\n     /// pi/4.0\n     pub static FRAC_PI_4: f32 = 0.785398163397448309615660845819875721_f32;\n \n+    /// pi/6.0\n+    pub static FRAC_PI_6: f32 = 0.52359877559829887307710723054658381_f32;\n+\n+    /// pi/8.0\n+    pub static FRAC_PI_8: f32 = 0.39269908169872415480783042290993786_f32;\n+\n     /// 1.0/pi\n     pub static FRAC_1_PI: f32 = 0.318309886183790671537767526745028724_f32;\n \n@@ -251,24 +259,25 @@ impl Signed for f32 {\n }\n \n impl Bounded for f32 {\n+    // NOTE: this is the smallest non-infinite f32 value, *not* MIN_VALUE\n     #[inline]\n-    fn min_value() -> f32 { 1.17549435e-38 }\n+    fn min_value() -> f32 { -MAX_VALUE }\n \n     #[inline]\n-    fn max_value() -> f32 { 3.40282347e+38 }\n+    fn max_value() -> f32 { MAX_VALUE }\n }\n \n impl Primitive for f32 {}\n \n impl Float for f32 {\n     #[inline]\n-    fn nan() -> f32 { 0.0 / 0.0 }\n+    fn nan() -> f32 { NAN }\n \n     #[inline]\n-    fn infinity() -> f32 { 1.0 / 0.0 }\n+    fn infinity() -> f32 { INFINITY }\n \n     #[inline]\n-    fn neg_infinity() -> f32 { -1.0 / 0.0 }\n+    fn neg_infinity() -> f32 { NEG_INFINITY }\n \n     #[inline]\n     fn neg_zero() -> f32 { -0.0 }\n@@ -313,25 +322,25 @@ impl Float for f32 {\n     }\n \n     #[inline]\n-    fn mantissa_digits(_: Option<f32>) -> uint { 24 }\n+    fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS }\n \n     #[inline]\n-    fn digits(_: Option<f32>) -> uint { 6 }\n+    fn digits(_: Option<f32>) -> uint { DIGITS }\n \n     #[inline]\n-    fn epsilon() -> f32 { 1.19209290e-07 }\n+    fn epsilon() -> f32 { EPSILON }\n \n     #[inline]\n-    fn min_exp(_: Option<f32>) -> int { -125 }\n+    fn min_exp(_: Option<f32>) -> int { MIN_EXP }\n \n     #[inline]\n-    fn max_exp(_: Option<f32>) -> int { 128 }\n+    fn max_exp(_: Option<f32>) -> int { MAX_EXP }\n \n     #[inline]\n-    fn min_10_exp(_: Option<f32>) -> int { -37 }\n+    fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP }\n \n     #[inline]\n-    fn max_10_exp(_: Option<f32>) -> int { 38 }\n+    fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP }\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the\n     /// power of `exp`\n@@ -442,11 +451,11 @@ impl Float for f32 {\n \n     /// sqrt(2.0)\n     #[inline]\n-    fn sqrt2() -> f32 { 1.41421356237309504880168872420969808 }\n+    fn sqrt2() -> f32 { consts::SQRT2 }\n \n     /// 1.0 / sqrt(2.0)\n     #[inline]\n-    fn frac_1_sqrt2() -> f32 { 0.707106781186547524400844362104849039 }\n+    fn frac_1_sqrt2() -> f32 { consts::FRAC_1_SQRT2 }\n \n     #[inline]\n     fn sqrt(self) -> f32 {\n@@ -468,43 +477,43 @@ impl Float for f32 {\n \n     /// Archimedes' constant\n     #[inline]\n-    fn pi() -> f32 { 3.14159265358979323846264338327950288 }\n+    fn pi() -> f32 { consts::PI }\n \n     /// 2.0 * pi\n     #[inline]\n-    fn two_pi() -> f32 { 6.28318530717958647692528676655900576 }\n+    fn two_pi() -> f32 { consts::PI_2 }\n \n     /// pi / 2.0\n     #[inline]\n-    fn frac_pi_2() -> f32 { 1.57079632679489661923132169163975144 }\n+    fn frac_pi_2() -> f32 { consts::FRAC_PI_2 }\n \n     /// pi / 3.0\n     #[inline]\n-    fn frac_pi_3() -> f32 { 1.04719755119659774615421446109316763 }\n+    fn frac_pi_3() -> f32 { consts::FRAC_PI_3 }\n \n     /// pi / 4.0\n     #[inline]\n-    fn frac_pi_4() -> f32 { 0.785398163397448309615660845819875721 }\n+    fn frac_pi_4() -> f32 { consts::FRAC_PI_4 }\n \n     /// pi / 6.0\n     #[inline]\n-    fn frac_pi_6() -> f32 { 0.52359877559829887307710723054658381 }\n+    fn frac_pi_6() -> f32 { consts::FRAC_PI_6 }\n \n     /// pi / 8.0\n     #[inline]\n-    fn frac_pi_8() -> f32 { 0.39269908169872415480783042290993786 }\n+    fn frac_pi_8() -> f32 { consts::FRAC_PI_8 }\n \n     /// 1 .0/ pi\n     #[inline]\n-    fn frac_1_pi() -> f32 { 0.318309886183790671537767526745028724 }\n+    fn frac_1_pi() -> f32 { consts::FRAC_1_PI }\n \n     /// 2.0 / pi\n     #[inline]\n-    fn frac_2_pi() -> f32 { 0.636619772367581343075535053490057448 }\n+    fn frac_2_pi() -> f32 { consts::FRAC_2_PI }\n \n     /// 2.0 / sqrt(pi)\n     #[inline]\n-    fn frac_2_sqrtpi() -> f32 { 1.12837916709551257389615890312154517 }\n+    fn frac_2_sqrtpi() -> f32 { consts::FRAC_2_SQRTPI }\n \n     #[inline]\n     fn sin(self) -> f32 {\n@@ -549,23 +558,23 @@ impl Float for f32 {\n \n     /// Euler's number\n     #[inline]\n-    fn e() -> f32 { 2.71828182845904523536028747135266250 }\n+    fn e() -> f32 { consts::E }\n \n     /// log2(e)\n     #[inline]\n-    fn log2_e() -> f32 { 1.44269504088896340735992468100189214 }\n+    fn log2_e() -> f32 { consts::LOG2_E }\n \n     /// log10(e)\n     #[inline]\n-    fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }\n+    fn log10_e() -> f32 { consts::LOG10_E }\n \n     /// ln(2.0)\n     #[inline]\n-    fn ln_2() -> f32 { 0.693147180559945309417232121458176568 }\n+    fn ln_2() -> f32 { consts::LN_2 }\n \n     /// ln(10.0)\n     #[inline]\n-    fn ln_10() -> f32 { 2.30258509299404568401799145468436421 }\n+    fn ln_10() -> f32 { consts::LN_10 }\n \n     /// Returns the exponential of the number\n     #[inline]"}, {"sha": "63ddb88f8dc2ad0f2879ad8ae1891c88e5a176dc", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/266812ec5a7248edd6f65c0be1bebf09c6c31a7f/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266812ec5a7248edd6f65c0be1bebf09c6c31a7f/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=266812ec5a7248edd6f65c0be1bebf09c6c31a7f", "patch": "@@ -73,8 +73,6 @@ mod cmath {\n     }\n }\n \n-// FIXME (#1433): obtain these in a different way\n-\n // FIXME(#11621): These constants should be deprecated once CTFE is implemented\n // in favour of calling their respective functions in `Bounded` and `Float`.\n \n@@ -85,7 +83,9 @@ pub static DIGITS: uint = 15u;\n \n pub static EPSILON: f64 = 2.2204460492503131e-16_f64;\n \n+/// Minimum normalized f64 value\n pub static MIN_VALUE: f64 = 2.2250738585072014e-308_f64;\n+/// Maximum f64 value\n pub static MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n \n pub static MIN_EXP: int = -1021;\n@@ -100,25 +100,34 @@ pub static INFINITY: f64 = 1.0_f64/0.0_f64;\n \n pub static NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n \n-// FIXME (#1999): add is_normal, is_subnormal, and fpclassify\n-\n /// Various useful constants.\n pub mod consts {\n-    // FIXME (requires Issue #1433 to fix): replace with mathematical\n-    // constants from cmath.\n+    // FIXME: replace with mathematical constants from cmath.\n \n     // FIXME(#11621): These constants should be deprecated once CTFE is\n     // implemented in favour of calling their respective functions in `Float`.\n \n     /// Archimedes' constant\n     pub static PI: f64 = 3.14159265358979323846264338327950288_f64;\n \n+    /// pi * 2.0\n+    pub static PI_2: f64 = 6.28318530717958647692528676655900576_f64;\n+\n     /// pi/2.0\n     pub static FRAC_PI_2: f64 = 1.57079632679489661923132169163975144_f64;\n \n+    /// pi/3.0\n+    pub static FRAC_PI_3: f64 = 1.04719755119659774615421446109316763_f64;\n+\n     /// pi/4.0\n     pub static FRAC_PI_4: f64 = 0.785398163397448309615660845819875721_f64;\n \n+    /// pi/6.0\n+    pub static FRAC_PI_6: f64 = 0.52359877559829887307710723054658381_f64;\n+\n+    /// pi/8.0\n+    pub static FRAC_PI_8: f64 = 0.39269908169872415480783042290993786_f64;\n+\n     /// 1.0/pi\n     pub static FRAC_1_PI: f64 = 0.318309886183790671537767526745028724_f64;\n \n@@ -258,24 +267,25 @@ impl Signed for f64 {\n }\n \n impl Bounded for f64 {\n+    // NOTE: this is the smallest non-infinite f32 value, *not* MIN_VALUE\n     #[inline]\n-    fn min_value() -> f64 { 2.2250738585072014e-308 }\n+    fn min_value() -> f64 { -MAX_VALUE }\n \n     #[inline]\n-    fn max_value() -> f64 { 1.7976931348623157e+308 }\n+    fn max_value() -> f64 { MAX_VALUE }\n }\n \n impl Primitive for f64 {}\n \n impl Float for f64 {\n     #[inline]\n-    fn nan() -> f64 { 0.0 / 0.0 }\n+    fn nan() -> f64 { NAN }\n \n     #[inline]\n-    fn infinity() -> f64 { 1.0 / 0.0 }\n+    fn infinity() -> f64 { INFINITY }\n \n     #[inline]\n-    fn neg_infinity() -> f64 { -1.0 / 0.0 }\n+    fn neg_infinity() -> f64 { NEG_INFINITY }\n \n     #[inline]\n     fn neg_zero() -> f64 { -0.0 }\n@@ -450,11 +460,11 @@ impl Float for f64 {\n \n     /// sqrt(2.0)\n     #[inline]\n-    fn sqrt2() -> f64 { 1.41421356237309504880168872420969808 }\n+    fn sqrt2() -> f64 { consts::SQRT2 }\n \n     /// 1.0 / sqrt(2.0)\n     #[inline]\n-    fn frac_1_sqrt2() -> f64 { 0.707106781186547524400844362104849039 }\n+    fn frac_1_sqrt2() -> f64 { consts::FRAC_1_SQRT2 }\n \n     #[inline]\n     fn sqrt(self) -> f64 {\n@@ -476,43 +486,43 @@ impl Float for f64 {\n \n     /// Archimedes' constant\n     #[inline]\n-    fn pi() -> f64 { 3.14159265358979323846264338327950288 }\n+    fn pi() -> f64 { consts::PI }\n \n     /// 2.0 * pi\n     #[inline]\n-    fn two_pi() -> f64 { 6.28318530717958647692528676655900576 }\n+    fn two_pi() -> f64 { consts::PI_2 }\n \n     /// pi / 2.0\n     #[inline]\n-    fn frac_pi_2() -> f64 { 1.57079632679489661923132169163975144 }\n+    fn frac_pi_2() -> f64 { consts::FRAC_PI_2 }\n \n     /// pi / 3.0\n     #[inline]\n-    fn frac_pi_3() -> f64 { 1.04719755119659774615421446109316763 }\n+    fn frac_pi_3() -> f64 { consts::FRAC_PI_3 }\n \n     /// pi / 4.0\n     #[inline]\n-    fn frac_pi_4() -> f64 { 0.785398163397448309615660845819875721 }\n+    fn frac_pi_4() -> f64 { consts::FRAC_PI_4 }\n \n     /// pi / 6.0\n     #[inline]\n-    fn frac_pi_6() -> f64 { 0.52359877559829887307710723054658381 }\n+    fn frac_pi_6() -> f64 { consts::FRAC_PI_6 }\n \n     /// pi / 8.0\n     #[inline]\n-    fn frac_pi_8() -> f64 { 0.39269908169872415480783042290993786 }\n+    fn frac_pi_8() -> f64 { consts::FRAC_PI_8 }\n \n     /// 1.0 / pi\n     #[inline]\n-    fn frac_1_pi() -> f64 { 0.318309886183790671537767526745028724 }\n+    fn frac_1_pi() -> f64 { consts::FRAC_1_PI }\n \n     /// 2.0 / pi\n     #[inline]\n-    fn frac_2_pi() -> f64 { 0.636619772367581343075535053490057448 }\n+    fn frac_2_pi() -> f64 { consts::FRAC_2_PI }\n \n     /// 2.0 / sqrt(pi)\n     #[inline]\n-    fn frac_2_sqrtpi() -> f64 { 1.12837916709551257389615890312154517 }\n+    fn frac_2_sqrtpi() -> f64 { consts::FRAC_2_SQRTPI }\n \n     #[inline]\n     fn sin(self) -> f64 {\n@@ -557,23 +567,23 @@ impl Float for f64 {\n \n     /// Euler's number\n     #[inline]\n-    fn e() -> f64 { 2.71828182845904523536028747135266250 }\n+    fn e() -> f64 { consts::E }\n \n     /// log2(e)\n     #[inline]\n-    fn log2_e() -> f64 { 1.44269504088896340735992468100189214 }\n+    fn log2_e() -> f64 { consts::LOG2_E }\n \n     /// log10(e)\n     #[inline]\n-    fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }\n+    fn log10_e() -> f64 { consts::LOG10_E }\n \n     /// ln(2.0)\n     #[inline]\n-    fn ln_2() -> f64 { 0.693147180559945309417232121458176568 }\n+    fn ln_2() -> f64 { consts::LN_2 }\n \n     /// ln(10.0)\n     #[inline]\n-    fn ln_10() -> f64 { 2.30258509299404568401799145468436421 }\n+    fn ln_10() -> f64 { consts::LN_10 }\n \n     /// Returns the exponential of the number\n     #[inline]"}, {"sha": "dccca82dc79abac4359c0bf1457aa252bee61df8", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/266812ec5a7248edd6f65c0be1bebf09c6c31a7f/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266812ec5a7248edd6f65c0be1bebf09c6c31a7f/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=266812ec5a7248edd6f65c0be1bebf09c6c31a7f", "patch": "@@ -358,9 +358,9 @@ pub trait Float: Signed + Primitive {\n \n     /// Returns the number of binary digits of mantissa that this type supports.\n     fn mantissa_digits(unused_self: Option<Self>) -> uint;\n-    /// Returns the number of binary digits of exponent that this type supports.\n+    /// Returns the number of base-10 digits of precision that this type supports.\n     fn digits(unused_self: Option<Self>) -> uint;\n-    /// Returns the smallest positive number that this type can represent.\n+    /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n     fn epsilon() -> Self;\n     /// Returns the minimum binary exponent that this type can represent.\n     fn min_exp(unused_self: Option<Self>) -> int;"}]}