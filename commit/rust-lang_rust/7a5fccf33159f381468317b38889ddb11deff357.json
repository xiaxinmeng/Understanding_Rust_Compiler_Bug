{"sha": "7a5fccf33159f381468317b38889ddb11deff357", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNWZjY2YzMzE1OWYzODE0NjgzMTdiMzg4ODlkZGIxMWRlZmYzNTc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-07-11T22:06:56Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-02T00:45:03Z"}, "message": "rustc_apfloat: port the suite of unit tests.", "tree": {"sha": "fc1b5dceb00696b53c6bc556a58b7d7abcec3afc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc1b5dceb00696b53c6bc556a58b7d7abcec3afc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a5fccf33159f381468317b38889ddb11deff357", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a5fccf33159f381468317b38889ddb11deff357", "html_url": "https://github.com/rust-lang/rust/commit/7a5fccf33159f381468317b38889ddb11deff357", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a5fccf33159f381468317b38889ddb11deff357/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2686a7af791204948502295d383954d5895145f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2686a7af791204948502295d383954d5895145f7", "html_url": "https://github.com/rust-lang/rust/commit/2686a7af791204948502295d383954d5895145f7"}], "stats": {"total": 7546, "additions": 7546, "deletions": 0}, "files": [{"sha": "aff2076e038332ce77104c44fc8e048663627b14", "filename": "src/librustc_apfloat/tests/ieee.rs", "status": "added", "additions": 6891, "deletions": 0, "changes": 6891, "blob_url": "https://github.com/rust-lang/rust/blob/7a5fccf33159f381468317b38889ddb11deff357/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a5fccf33159f381468317b38889ddb11deff357/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs?ref=7a5fccf33159f381468317b38889ddb11deff357"}, {"sha": "145c3ddc869dfc17c5307720a56fa6db4cbc07ab", "filename": "src/librustc_apfloat/tests/ppc.rs", "status": "added", "additions": 655, "deletions": 0, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/7a5fccf33159f381468317b38889ddb11deff357/src%2Flibrustc_apfloat%2Ftests%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a5fccf33159f381468317b38889ddb11deff357/src%2Flibrustc_apfloat%2Ftests%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Ftests%2Fppc.rs?ref=7a5fccf33159f381468317b38889ddb11deff357", "patch": "@@ -0,0 +1,655 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate rustc_apfloat;\n+\n+use rustc_apfloat::{Category, Float, Round};\n+use rustc_apfloat::ppc::DoubleDouble;\n+\n+use std::cmp::Ordering;\n+\n+#[test]\n+fn ppc_double_double() {\n+    let test = DoubleDouble::ZERO;\n+    let expected = \"0x0p+0\".parse::<DoubleDouble>().unwrap();\n+    assert!(test.is_zero());\n+    assert!(!test.is_negative());\n+    assert!(test.bitwise_eq(expected));\n+    assert_eq!(0, test.to_bits());\n+\n+    let test = -DoubleDouble::ZERO;\n+    let expected = \"-0x0p+0\".parse::<DoubleDouble>().unwrap();\n+    assert!(test.is_zero());\n+    assert!(test.is_negative());\n+    assert!(test.bitwise_eq(expected));\n+    assert_eq!(0x8000000000000000, test.to_bits());\n+\n+    let test = \"1.0\".parse::<DoubleDouble>().unwrap();\n+    assert_eq!(0x3ff0000000000000, test.to_bits());\n+\n+    // LDBL_MAX\n+    let test = \"1.79769313486231580793728971405301e+308\"\n+        .parse::<DoubleDouble>()\n+        .unwrap();\n+    assert_eq!(0x7c8ffffffffffffe_7fefffffffffffff, test.to_bits());\n+\n+    // LDBL_MIN\n+    let test = \"2.00416836000897277799610805135016e-292\"\n+        .parse::<DoubleDouble>()\n+        .unwrap();\n+    assert_eq!(0x0000000000000000_0360000000000000, test.to_bits());\n+}\n+\n+#[test]\n+fn ppc_double_double_add_special() {\n+    let data = [\n+        // (1 + 0) + (-1 + 0) = Category::Zero\n+        (\n+            0x3ff0000000000000,\n+            0xbff0000000000000,\n+            Category::Zero,\n+            Round::NearestTiesToEven,\n+        ),\n+        // LDBL_MAX + (1.1 >> (1023 - 106) + 0)) = Category::Infinity\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x7948000000000000,\n+            Category::Infinity,\n+            Round::NearestTiesToEven,\n+        ),\n+        // FIXME: change the 4th 0x75effffffffffffe to 0x75efffffffffffff when\n+        // DoubleDouble's fallback is gone.\n+        // LDBL_MAX + (1.011111... >> (1023 - 106) + (1.1111111...0 >> (1023 -\n+        // 160))) = Category::Normal\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x75effffffffffffe_7947ffffffffffff,\n+            Category::Normal,\n+            Round::NearestTiesToEven,\n+        ),\n+        // LDBL_MAX + (1.1 >> (1023 - 106) + 0)) = Category::Infinity\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            Category::Infinity,\n+            Round::NearestTiesToEven,\n+        ),\n+        // NaN + (1 + 0) = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0x3ff0000000000000,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        {\n+            let mut a1 = DoubleDouble::from_bits(op1);\n+            let a2 = DoubleDouble::from_bits(op2);\n+            a1 = a1.add_r(a2, round).value;\n+\n+            assert_eq!(expected, a1.category(), \"{:#x} + {:#x}\", op1, op2);\n+        }\n+        {\n+            let a1 = DoubleDouble::from_bits(op1);\n+            let mut a2 = DoubleDouble::from_bits(op2);\n+            a2 = a2.add_r(a1, round).value;\n+\n+            assert_eq!(expected, a2.category(), \"{:#x} + {:#x}\", op2, op1);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_add() {\n+    let data = [\n+        // (1 + 0) + (1e-105 + 0) = (1 + 1e-105)\n+        (\n+            0x3ff0000000000000,\n+            0x3960000000000000,\n+            0x3960000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + 0) + (1e-106 + 0) = (1 + 1e-106)\n+        (\n+            0x3ff0000000000000,\n+            0x3950000000000000,\n+            0x3950000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + 1e-106) + (1e-106 + 0) = (1 + 1e-105)\n+        (\n+            0x3950000000000000_3ff0000000000000,\n+            0x3950000000000000,\n+            0x3960000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + 0) + (epsilon + 0) = (1 + epsilon)\n+        (\n+            0x3ff0000000000000,\n+            0x0000000000000001,\n+            0x0000000000000001_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // FIXME: change 0xf950000000000000 to 0xf940000000000000, when\n+        // DoubleDouble's fallback is gone.\n+        // (DBL_MAX - 1 << (1023 - 105)) + (1 << (1023 - 53) + 0) = DBL_MAX +\n+        // 1.11111... << (1023 - 52)\n+        (\n+            0xf950000000000000_7fefffffffffffff,\n+            0x7c90000000000000,\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            Round::NearestTiesToEven,\n+        ),\n+        // FIXME: change 0xf950000000000000 to 0xf940000000000000, when\n+        // DoubleDouble's fallback is gone.\n+        // (1 << (1023 - 53) + 0) + (DBL_MAX - 1 << (1023 - 105)) = DBL_MAX +\n+        // 1.11111... << (1023 - 52)\n+        (\n+            0x7c90000000000000,\n+            0xf950000000000000_7fefffffffffffff,\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        {\n+            let mut a1 = DoubleDouble::from_bits(op1);\n+            let a2 = DoubleDouble::from_bits(op2);\n+            a1 = a1.add_r(a2, round).value;\n+\n+            assert_eq!(expected, a1.to_bits(), \"{:#x} + {:#x}\", op1, op2);\n+        }\n+        {\n+            let a1 = DoubleDouble::from_bits(op1);\n+            let mut a2 = DoubleDouble::from_bits(op2);\n+            a2 = a2.add_r(a1, round).value;\n+\n+            assert_eq!(expected, a2.to_bits(), \"{:#x} + {:#x}\", op2, op1);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_subtract() {\n+    let data = [\n+        // (1 + 0) - (-1e-105 + 0) = (1 + 1e-105)\n+        (\n+            0x3ff0000000000000,\n+            0xb960000000000000,\n+            0x3960000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + 0) - (-1e-106 + 0) = (1 + 1e-106)\n+        (\n+            0x3ff0000000000000,\n+            0xb950000000000000,\n+            0x3950000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        let mut a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        a1 = a1.sub_r(a2, round).value;\n+\n+        assert_eq!(expected, a1.to_bits(), \"{:#x} - {:#x}\", op1, op2);\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_multiply_special() {\n+    let data = [\n+        // Category::NaN * Category::NaN = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0x7ff8000000000000,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::NaN * Category::Zero = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::NaN * Category::Infinity = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0x7ff0000000000000,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::NaN * Category::Normal = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0x3ff0000000000000,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::Infinity * Category::Infinity = Category::Infinity\n+        (\n+            0x7ff0000000000000,\n+            0x7ff0000000000000,\n+            Category::Infinity,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::Infinity * Category::Zero = Category::NaN\n+        (\n+            0x7ff0000000000000,\n+            0,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::Infinity * Category::Normal = Category::Infinity\n+        (\n+            0x7ff0000000000000,\n+            0x3ff0000000000000,\n+            Category::Infinity,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::Zero * Category::Zero = Category::Zero\n+        (0, 0, Category::Zero, Round::NearestTiesToEven),\n+        // Category::Zero * Category::Normal = Category::Zero\n+        (\n+            0,\n+            0x3ff0000000000000,\n+            Category::Zero,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        {\n+            let mut a1 = DoubleDouble::from_bits(op1);\n+            let a2 = DoubleDouble::from_bits(op2);\n+            a1 = a1.mul_r(a2, round).value;\n+\n+            assert_eq!(expected, a1.category(), \"{:#x} * {:#x}\", op1, op2);\n+        }\n+        {\n+            let a1 = DoubleDouble::from_bits(op1);\n+            let mut a2 = DoubleDouble::from_bits(op2);\n+            a2 = a2.mul_r(a1, round).value;\n+\n+            assert_eq!(expected, a2.category(), \"{:#x} * {:#x}\", op2, op1);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_multiply() {\n+    let data = [\n+        // 1/3 * 3 = 1.0\n+        (\n+            0x3c75555555555556_3fd5555555555555,\n+            0x4008000000000000,\n+            0x3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + epsilon) * (1 + 0) = Category::Zero\n+        (\n+            0x0000000000000001_3ff0000000000000,\n+            0x3ff0000000000000,\n+            0x0000000000000001_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + epsilon) * (1 + epsilon) = 1 + 2 * epsilon\n+        (\n+            0x0000000000000001_3ff0000000000000,\n+            0x0000000000000001_3ff0000000000000,\n+            0x0000000000000002_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // -(1 + epsilon) * (1 + epsilon) = -1\n+        (\n+            0x0000000000000001_bff0000000000000,\n+            0x0000000000000001_3ff0000000000000,\n+            0xbff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (0.5 + 0) * (1 + 2 * epsilon) = 0.5 + epsilon\n+        (\n+            0x3fe0000000000000,\n+            0x0000000000000002_3ff0000000000000,\n+            0x0000000000000001_3fe0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (0.5 + 0) * (1 + epsilon) = 0.5\n+        (\n+            0x3fe0000000000000,\n+            0x0000000000000001_3ff0000000000000,\n+            0x3fe0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // __LDBL_MAX__ * (1 + 1 << 106) = inf\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x3950000000000000_3ff0000000000000,\n+            0x7ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // __LDBL_MAX__ * (1 + 1 << 107) > __LDBL_MAX__, but not inf, yes =_=|||\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x3940000000000000_3ff0000000000000,\n+            0x7c8fffffffffffff_7fefffffffffffff,\n+            Round::NearestTiesToEven,\n+        ),\n+        // __LDBL_MAX__ * (1 + 1 << 108) = __LDBL_MAX__\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x3930000000000000_3ff0000000000000,\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        {\n+            let mut a1 = DoubleDouble::from_bits(op1);\n+            let a2 = DoubleDouble::from_bits(op2);\n+            a1 = a1.mul_r(a2, round).value;\n+\n+            assert_eq!(expected, a1.to_bits(), \"{:#x} * {:#x}\", op1, op2);\n+        }\n+        {\n+            let a1 = DoubleDouble::from_bits(op1);\n+            let mut a2 = DoubleDouble::from_bits(op2);\n+            a2 = a2.mul_r(a1, round).value;\n+\n+            assert_eq!(expected, a2.to_bits(), \"{:#x} * {:#x}\", op2, op1);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_divide() {\n+    // FIXME: Only a sanity check for now. Add more edge cases when the\n+    // double-double algorithm is implemented.\n+    let data = [\n+        // 1 / 3 = 1/3\n+        (\n+            0x3ff0000000000000,\n+            0x4008000000000000,\n+            0x3c75555555555556_3fd5555555555555,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        let mut a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        a1 = a1.div_r(a2, round).value;\n+\n+        assert_eq!(expected, a1.to_bits(), \"{:#x} / {:#x}\", op1, op2);\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_remainder() {\n+    let data = [\n+        // ieee_rem(3.0 + 3.0 << 53, 1.25 + 1.25 << 53) = (0.5 + 0.5 << 53)\n+        (\n+            0x3cb8000000000000_4008000000000000,\n+            0x3ca4000000000000_3ff4000000000000,\n+            0x3c90000000000000_3fe0000000000000,\n+        ),\n+        // ieee_rem(3.0 + 3.0 << 53, 1.75 + 1.75 << 53) = (-0.5 - 0.5 << 53)\n+        (\n+            0x3cb8000000000000_4008000000000000,\n+            0x3cac000000000000_3ffc000000000000,\n+            0xbc90000000000000_bfe0000000000000,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected) in &data {\n+        let a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        let result = a1.ieee_rem(a2).value;\n+\n+        assert_eq!(\n+            expected,\n+            result.to_bits(),\n+            \"ieee_rem({:#x}, {:#x})\",\n+            op1,\n+            op2\n+        );\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_mod() {\n+    let data = [\n+        // mod(3.0 + 3.0 << 53, 1.25 + 1.25 << 53) = (0.5 + 0.5 << 53)\n+        (\n+            0x3cb8000000000000_4008000000000000,\n+            0x3ca4000000000000_3ff4000000000000,\n+            0x3c90000000000000_3fe0000000000000,\n+        ),\n+        // mod(3.0 + 3.0 << 53, 1.75 + 1.75 << 53) = (1.25 + 1.25 << 53)\n+        // 0xbc98000000000000 doesn't seem right, but it's what we currently have.\n+        // FIXME: investigate\n+        (\n+            0x3cb8000000000000_4008000000000000,\n+            0x3cac000000000000_3ffc000000000000,\n+            0xbc98000000000000_3ff4000000000001,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected) in &data {\n+        let a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        let r = (a1 % a2).value;\n+\n+        assert_eq!(expected, r.to_bits(), \"fmod({:#x}, {:#x})\", op1, op2);\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_fma() {\n+    // Sanity check for now.\n+    let mut a = \"2\".parse::<DoubleDouble>().unwrap();\n+    a = a.mul_add(\n+        \"3\".parse::<DoubleDouble>().unwrap(),\n+        \"4\".parse::<DoubleDouble>().unwrap(),\n+    ).value;\n+    assert_eq!(\n+        Some(Ordering::Equal),\n+        \"10\".parse::<DoubleDouble>().unwrap().partial_cmp(&a)\n+    );\n+}\n+\n+#[test]\n+fn ppc_double_double_round_to_integral() {\n+    {\n+        let a = \"1.5\".parse::<DoubleDouble>().unwrap();\n+        let a = a.round_to_integral(Round::NearestTiesToEven).value;\n+        assert_eq!(\n+            Some(Ordering::Equal),\n+            \"2\".parse::<DoubleDouble>().unwrap().partial_cmp(&a)\n+        );\n+    }\n+    {\n+        let a = \"2.5\".parse::<DoubleDouble>().unwrap();\n+        let a = a.round_to_integral(Round::NearestTiesToEven).value;\n+        assert_eq!(\n+            Some(Ordering::Equal),\n+            \"2\".parse::<DoubleDouble>().unwrap().partial_cmp(&a)\n+        );\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_compare() {\n+    let data = [\n+        // (1 + 0) = (1 + 0)\n+        (\n+            0x3ff0000000000000,\n+            0x3ff0000000000000,\n+            Some(Ordering::Equal),\n+        ),\n+        // (1 + 0) < (1.00...1 + 0)\n+        (0x3ff0000000000000, 0x3ff0000000000001, Some(Ordering::Less)),\n+        // (1.00...1 + 0) > (1 + 0)\n+        (\n+            0x3ff0000000000001,\n+            0x3ff0000000000000,\n+            Some(Ordering::Greater),\n+        ),\n+        // (1 + 0) < (1 + epsilon)\n+        (\n+            0x3ff0000000000000,\n+            0x0000000000000001_3ff0000000000001,\n+            Some(Ordering::Less),\n+        ),\n+        // NaN != NaN\n+        (0x7ff8000000000000, 0x7ff8000000000000, None),\n+        // (1 + 0) != NaN\n+        (0x3ff0000000000000, 0x7ff8000000000000, None),\n+        // Inf = Inf\n+        (\n+            0x7ff0000000000000,\n+            0x7ff0000000000000,\n+            Some(Ordering::Equal),\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected) in &data {\n+        let a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        assert_eq!(\n+            expected,\n+            a1.partial_cmp(&a2),\n+            \"compare({:#x}, {:#x})\",\n+            op1,\n+            op2,\n+        );\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_bitwise_eq() {\n+    let data = [\n+        // (1 + 0) = (1 + 0)\n+        (0x3ff0000000000000, 0x3ff0000000000000, true),\n+        // (1 + 0) != (1.00...1 + 0)\n+        (0x3ff0000000000000, 0x3ff0000000000001, false),\n+        // NaN = NaN\n+        (0x7ff8000000000000, 0x7ff8000000000000, true),\n+        // NaN != NaN with a different bit pattern\n+        (\n+            0x7ff8000000000000,\n+            0x3ff0000000000000_7ff8000000000000,\n+            false,\n+        ),\n+        // Inf = Inf\n+        (0x7ff0000000000000, 0x7ff0000000000000, true),\n+    ];\n+\n+    for &(op1, op2, expected) in &data {\n+        let a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        assert_eq!(expected, a1.bitwise_eq(a2), \"{:#x} = {:#x}\", op1, op2);\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_change_sign() {\n+    let float = DoubleDouble::from_bits(0xbcb0000000000000_400f000000000000);\n+    {\n+        let actual = float.copy_sign(\"1\".parse::<DoubleDouble>().unwrap());\n+        assert_eq!(0xbcb0000000000000_400f000000000000, actual.to_bits());\n+    }\n+    {\n+        let actual = float.copy_sign(\"-1\".parse::<DoubleDouble>().unwrap());\n+        assert_eq!(0x3cb0000000000000_c00f000000000000, actual.to_bits());\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_factories() {\n+    assert_eq!(0, DoubleDouble::ZERO.to_bits());\n+    assert_eq!(\n+        0x7c8ffffffffffffe_7fefffffffffffff,\n+        DoubleDouble::largest().to_bits()\n+    );\n+    assert_eq!(0x0000000000000001, DoubleDouble::SMALLEST.to_bits());\n+    assert_eq!(\n+        0x0360000000000000,\n+        DoubleDouble::smallest_normalized().to_bits()\n+    );\n+    assert_eq!(\n+        0x0000000000000000_8000000000000000,\n+        (-DoubleDouble::ZERO).to_bits()\n+    );\n+    assert_eq!(\n+        0xfc8ffffffffffffe_ffefffffffffffff,\n+        (-DoubleDouble::largest()).to_bits()\n+    );\n+    assert_eq!(\n+        0x0000000000000000_8000000000000001,\n+        (-DoubleDouble::SMALLEST).to_bits()\n+    );\n+    assert_eq!(\n+        0x0000000000000000_8360000000000000,\n+        (-DoubleDouble::smallest_normalized()).to_bits()\n+    );\n+    assert!(DoubleDouble::SMALLEST.is_smallest());\n+    assert!(DoubleDouble::largest().is_largest());\n+}\n+\n+#[test]\n+fn ppc_double_double_is_denormal() {\n+    assert!(DoubleDouble::SMALLEST.is_denormal());\n+    assert!(!DoubleDouble::largest().is_denormal());\n+    assert!(!DoubleDouble::smallest_normalized().is_denormal());\n+    {\n+        // (4 + 3) is not normalized\n+        let data = 0x4008000000000000_4010000000000000;\n+        assert!(DoubleDouble::from_bits(data).is_denormal());\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_exact_inverse() {\n+    assert!(\n+        \"2.0\"\n+            .parse::<DoubleDouble>()\n+            .unwrap()\n+            .get_exact_inverse()\n+            .unwrap()\n+            .bitwise_eq(\"0.5\".parse::<DoubleDouble>().unwrap())\n+    );\n+}\n+\n+#[test]\n+fn ppc_double_double_scalbn() {\n+    // 3.0 + 3.0 << 53\n+    let input = 0x3cb8000000000000_4008000000000000;\n+    let result = DoubleDouble::from_bits(input).scalbn(1);\n+    // 6.0 + 6.0 << 53\n+    assert_eq!(0x3cc8000000000000_4018000000000000, result.to_bits());\n+}\n+\n+#[test]\n+fn ppc_double_double_frexp() {\n+    // 3.0 + 3.0 << 53\n+    let input = 0x3cb8000000000000_4008000000000000;\n+    let mut exp = 0;\n+    // 0.75 + 0.75 << 53\n+    let result = DoubleDouble::from_bits(input).frexp(&mut exp);\n+    assert_eq!(2, exp);\n+    assert_eq!(0x3c98000000000000_3fe8000000000000, result.to_bits());\n+}"}]}