{"sha": "2ea8922b8ab8ce7f820869778950346a749ed757", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYTg5MjJiOGFiOGNlN2Y4MjA4Njk3Nzg5NTAzNDZhNzQ5ZWQ3NTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-03T04:39:08Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-03T04:39:08Z"}, "message": "Merge remote-tracking branch 'brson/uv'", "tree": {"sha": "e01333834940c454c3fad6a8c6f2ac35a039aa19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e01333834940c454c3fad6a8c6f2ac35a039aa19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ea8922b8ab8ce7f820869778950346a749ed757", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ea8922b8ab8ce7f820869778950346a749ed757", "html_url": "https://github.com/rust-lang/rust/commit/2ea8922b8ab8ce7f820869778950346a749ed757", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ea8922b8ab8ce7f820869778950346a749ed757/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1caf45d5df582d04abb7921137323136b9a42c7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1caf45d5df582d04abb7921137323136b9a42c7b", "html_url": "https://github.com/rust-lang/rust/commit/1caf45d5df582d04abb7921137323136b9a42c7b"}, {"sha": "18ac4eee3b38b3af0e252630c590325fb40ba54f", "url": "https://api.github.com/repos/rust-lang/rust/commits/18ac4eee3b38b3af0e252630c590325fb40ba54f", "html_url": "https://github.com/rust-lang/rust/commit/18ac4eee3b38b3af0e252630c590325fb40ba54f"}], "stats": {"total": 1890, "additions": 1305, "deletions": 585}, "files": [{"sha": "66b7ddc6daf016353892cd92a62e844984b897a3", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ea8922b8ab8ce7f820869778950346a749ed757/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea8922b8ab8ce7f820869778950346a749ed757/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=2ea8922b8ab8ce7f820869778950346a749ed757", "patch": "@@ -31,6 +31,7 @@ export splitn;\n export rsplit;\n export rsplitn;\n export shift;\n+export unshift;\n export pop;\n export push, push_all, push_all_move;\n export grow;"}, {"sha": "cf2e223ecde6878c02676d052a2aa01b306f8c36", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 319, "deletions": 24, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/2ea8922b8ab8ce7f820869778950346a749ed757/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea8922b8ab8ce7f820869778950346a749ed757/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=2ea8922b8ab8ce7f820869778950346a749ed757", "patch": "@@ -4,16 +4,35 @@ Types/fns concerning Internet Protocol (IP), versions 4 & 6\n \n import vec;\n import uint;\n+import iotask = uv::iotask::iotask;\n+import interact = uv::iotask::interact;\n+import comm::methods;\n+\n+import sockaddr_in = uv::ll::sockaddr_in;\n+import sockaddr_in6 = uv::ll::sockaddr_in6;\n+import addrinfo = uv::ll::addrinfo;\n+import uv_getaddrinfo_t = uv::ll::uv_getaddrinfo_t;\n+import uv_ip4_addr = uv::ll::ip4_addr;\n+import uv_ip4_name = uv::ll::ip4_name;\n+import uv_ip6_addr = uv::ll::ip6_addr;\n+import uv_ip6_name = uv::ll::ip6_name;\n+import uv_getaddrinfo = uv::ll::getaddrinfo;\n+import uv_freeaddrinfo = uv::ll::freeaddrinfo;\n+import create_uv_getaddrinfo_t = uv::ll::getaddrinfo_t;\n+import set_data_for_req = uv::ll::set_data_for_req;\n+import get_data_for_req = uv::ll::get_data_for_req;\n+import ll = uv::ll;\n \n export ip_addr, parse_addr_err;\n export format_addr;\n-export v4;\n+export v4, v6;\n+export get_addr;\n \n #[doc = \"An IP address\"]\n enum ip_addr {\n     #[doc=\"An IPv4 address\"]\n-    ipv4(u8, u8, u8, u8),\n-    ipv6(u16,u16,u16,u16,u16,u16,u16,u16)\n+    ipv4(sockaddr_in),\n+    ipv6(sockaddr_in6)\n }\n \n #[doc=\"\n@@ -32,22 +51,88 @@ Convert a `ip_addr` to a str\n \"]\n fn format_addr(ip: ip_addr) -> str {\n     alt ip {\n-      ipv4(a, b, c, d) {\n-        #fmt[\"%u.%u.%u.%u\", a as uint, b as uint, c as uint, d as uint]\n+      ipv4(addr) {\n+        unsafe {\n+            let result = uv_ip4_name(&addr);\n+            if result == \"\" {\n+                fail \"failed to convert inner sockaddr_in address to str\"\n+            }\n+            result\n+        }\n       }\n-      ipv6(_, _, _, _, _, _, _, _) {\n-        fail \"FIXME (#2651) impl parsing of ipv6 addr\";\n+      ipv6(addr) {\n+        unsafe {\n+            let result = uv_ip6_name(&addr);\n+            if result == \"\" {\n+                fail \"failed to convert inner sockaddr_in address to str\"\n+            }\n+            result\n+        }\n       }\n     }\n }\n \n+#[doc=\"\n+Represents errors returned from `net::ip::get_addr()`\n+\"]\n+enum ip_get_addr_err {\n+    get_addr_unknown_error\n+}\n+\n+#[doc=\"\n+Attempts name resolution on the provided `node` string\n+\n+# Arguments\n+\n+* `node` - a string representing some host address\n+* `iotask` - a `uv::iotask` used to interact with the underlying event loop\n+\n+# Returns\n+\n+A `result<[ip_addr]/~, ip_get_addr_err>` instance that will contain\n+a vector of `ip_addr` results, in the case of success, or an error\n+object in the case of failure\n+\"]\n+fn get_addr(++node: str, iotask: iotask)\n+        -> result::result<[ip_addr]/~, ip_get_addr_err> unsafe {\n+    do comm::listen |output_ch| {\n+        do str::unpack_slice(node) |node_ptr, len| {\n+            log(debug, #fmt(\"slice len %?\", len));\n+            let handle = create_uv_getaddrinfo_t();\n+            let handle_ptr = ptr::addr_of(handle);\n+            let handle_data: get_addr_data = {\n+                output_ch: output_ch\n+            };\n+            let handle_data_ptr = ptr::addr_of(handle_data);\n+            do interact(iotask) |loop_ptr| {\n+                let result = uv_getaddrinfo(\n+                    loop_ptr,\n+                    handle_ptr,\n+                    get_addr_cb,\n+                    node_ptr,\n+                    ptr::null(),\n+                    ptr::null());\n+                alt result {\n+                  0i32 {\n+                    set_data_for_req(handle_ptr, handle_data_ptr);\n+                  }\n+                  _ {\n+                    output_ch.send(result::err(get_addr_unknown_error));\n+                  }\n+                }\n+            };\n+            output_ch.recv()\n+        }\n+    }\n+}\n+\n mod v4 {\n     #[doc = \"\n     Convert a str to `ip_addr`\n \n     # Failure\n \n-j    Fails if the string is not a valid IPv4 address\n+    Fails if the string is not a valid IPv4 address\n \n     # Arguments\n \n@@ -59,45 +144,255 @@ j    Fails if the string is not a valid IPv4 address\n     \"]\n     fn parse_addr(ip: str) -> ip_addr {\n         alt try_parse_addr(ip) {\n-          result::ok(addr) { addr }\n+          result::ok(addr) { copy(addr) }\n           result::err(err_data) {\n             fail err_data.err_msg\n           }\n         }\n     }\n-    fn try_parse_addr(ip: str) -> result::result<ip_addr,parse_addr_err> {\n+    // the simple, old style numberic representation of\n+    // ipv4\n+    type ipv4_rep = { a: u8, b: u8, c: u8, d:u8 };\n+    impl x for ipv4_rep {\n+        // this is pretty dastardly, i know\n+        unsafe fn as_u32() -> u32 {\n+            *((ptr::addr_of(self)) as *u32)\n+        }\n+    }\n+    fn parse_to_ipv4_rep(ip: str) -> result::result<ipv4_rep, str> {\n         let parts = vec::map(str::split_char(ip, '.'), |s| {\n             alt uint::from_str(s) {\n               some(n) if n <= 255u { n }\n               _ { 256u }\n             }\n         });\n         if vec::len(parts) != 4u {\n-            result::err({err_msg: #fmt(\"'%s' doesn't have 4 parts\",\n-                        ip)})\n-        }\n+                result::err(#fmt(\"'%s' doesn't have 4 parts\", ip))\n+                }\n         else if vec::contains(parts, 256u) {\n-            result::err({err_msg: #fmt(\"invalid octal in provided addr '%s'\",\n-                        ip)})\n+                result::err(#fmt(\"invalid octal in addr '%s'\", ip))\n+                }\n+        else {\n+            result::ok({a: parts[0] as u8, b: parts[1] as u8,\n+                        c: parts[2] as u8, d: parts[3] as u8})\n+        }\n+    }\n+    fn try_parse_addr(ip: str) -> result::result<ip_addr,parse_addr_err> {\n+        unsafe {\n+            let INADDR_NONE = ll::get_INADDR_NONE();\n+            let ip_rep_result = parse_to_ipv4_rep(ip);\n+            if result::is_err(ip_rep_result) {\n+                let err_str = result::get_err(ip_rep_result);\n+                ret result::err({err_msg: err_str})\n+            }\n+            // ipv4_rep.as_u32 is unsafe :/\n+            let input_is_inaddr_none =\n+                result::get(ip_rep_result).as_u32() == INADDR_NONE;\n+\n+            let new_addr = uv_ip4_addr(ip, 22);\n+            let reformatted_name = uv_ip4_name(&new_addr);\n+            log(debug, #fmt(\"try_parse_addr: input ip: %s reparsed ip: %s\",\n+                            ip, reformatted_name));\n+            let ref_ip_rep_result = parse_to_ipv4_rep(reformatted_name);\n+            if result::is_err(ref_ip_rep_result) {\n+                let err_str = result::get_err(ref_ip_rep_result);\n+                ret result::err({err_msg: err_str})\n+            }\n+            if result::get(ref_ip_rep_result).as_u32() == INADDR_NONE &&\n+                 !input_is_inaddr_none {\n+                ret result::err(\n+                    {err_msg: \"uv_ip4_name produced invalid result.\"})\n+            }\n+            else {\n+                result::ok(ipv4(copy(new_addr)))\n+            }\n+        }\n+    }\n+}\n+mod v6 {\n+    #[doc = \"\n+    Convert a str to `ip_addr`\n+\n+    # Failure\n+\n+    Fails if the string is not a valid IPv6 address\n+\n+    # Arguments\n+\n+    * ip - an ipv6 string. See RFC2460 for spec.\n+\n+    # Returns\n+\n+    * an `ip_addr` of the `ipv6` variant\n+    \"]\n+    fn parse_addr(ip: str) -> ip_addr {\n+        alt try_parse_addr(ip) {\n+          result::ok(addr) { copy(addr) }\n+          result::err(err_data) {\n+            fail err_data.err_msg\n+          }\n+        }\n+    }\n+    fn try_parse_addr(ip: str) -> result::result<ip_addr,parse_addr_err> {\n+        unsafe {\n+            // need to figure out how to establish a parse failure..\n+            let new_addr = uv_ip6_addr(ip, 22);\n+            let reparsed_name = uv_ip6_name(&new_addr);\n+            log(debug, #fmt(\"v6::try_parse_addr ip: '%s' reparsed '%s'\",\n+                            ip, reparsed_name));\n+            // '::' appears to be uv_ip6_name() returns for bogus\n+            // parses..\n+            if  ip != \"::\" && reparsed_name == \"::\" {\n+                result::err({err_msg:#fmt(\"failed to parse '%s'\",\n+                                           ip)})\n+            }\n+            else {\n+                result::ok(ipv6(new_addr))\n+            }\n+        }\n+    }\n+}\n+\n+type get_addr_data = {\n+    output_ch: comm::chan<result::result<[ip_addr]/~,ip_get_addr_err>>\n+};\n+\n+crust fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n+                     res: *addrinfo) unsafe {\n+    log(debug, \"in get_addr_cb\");\n+    let handle_data = get_data_for_req(handle) as\n+        *get_addr_data;\n+    if status == 0i32 {\n+        if res != (ptr::null::<addrinfo>()) {\n+            let mut out_vec = []/~;\n+            log(debug, #fmt(\"initial addrinfo: %?\", res));\n+            let mut curr_addr = res;\n+            loop {\n+                let new_ip_addr = if ll::is_ipv4_addrinfo(curr_addr) {\n+                    ipv4(copy((\n+                        *ll::addrinfo_as_sockaddr_in(curr_addr))))\n+                }\n+                else if ll::is_ipv6_addrinfo(curr_addr) {\n+                    ipv6(copy((\n+                        *ll::addrinfo_as_sockaddr_in6(curr_addr))))\n+                }\n+                else {\n+                    log(debug, \"curr_addr is not of family AF_INET or \"+\n+                        \"AF_INET6. Error.\");\n+                    (*handle_data).output_ch.send(\n+                        result::err(get_addr_unknown_error));\n+                    break;\n+                };\n+                out_vec += [new_ip_addr]/~;\n+\n+                let next_addr = ll::get_next_addrinfo(curr_addr);\n+                if next_addr == ptr::null::<addrinfo>() as *addrinfo {\n+                    log(debug, \"null next_addr encountered. no mas\");\n+                    break;\n+                }\n+                else {\n+                    curr_addr = next_addr;\n+                    log(debug, #fmt(\"next_addr addrinfo: %?\", curr_addr));\n+                }\n+            }\n+            log(debug, #fmt(\"successful process addrinfo result, len: %?\",\n+                            vec::len(out_vec)));\n+            (*handle_data).output_ch.send(result::ok(out_vec));\n         }\n         else {\n-            result::ok(ipv4(parts[0] as u8, parts[1] as u8,\n-                 parts[2] as u8, parts[3] as u8))\n+            log(debug, \"addrinfo pointer is NULL\");\n+            (*handle_data).output_ch.send(\n+                result::err(get_addr_unknown_error));\n         }\n     }\n+    else {\n+        log(debug, \"status != 0 error in get_addr_cb\");\n+        (*handle_data).output_ch.send(\n+            result::err(get_addr_unknown_error));\n+    }\n+    if res != (ptr::null::<addrinfo>()) {\n+        uv_freeaddrinfo(res);\n+    }\n+    log(debug, \"leaving get_addr_cb\");\n }\n \n #[cfg(test)]\n mod test {\n     #[test]\n-    fn test_format_ip() {\n-        assert (format_addr(ipv4(127u8, 0u8, 0u8, 1u8))\n-                == \"127.0.0.1\")\n+    fn test_ip_ipv4_parse_and_format_ip() {\n+        let localhost_str = \"127.0.0.1\";\n+        assert (format_addr(v4::parse_addr(localhost_str))\n+                == localhost_str)\n+    }\n+    #[test]\n+    fn test_ip_ipv6_parse_and_format_ip() {\n+        let localhost_str = \"::1\";\n+        let format_result = format_addr(v6::parse_addr(localhost_str));\n+        log(debug, #fmt(\"results: expected: '%s' actual: '%s'\",\n+            localhost_str, format_result));\n+        assert format_result == localhost_str;\n+    }\n+    #[test]\n+    fn test_ip_ipv4_bad_parse() {\n+        alt v4::try_parse_addr(\"b4df00d\") {\n+          result::err(err_info) {\n+            log(debug, #fmt(\"got error as expected %?\", err_info));\n+            assert true;\n+          }\n+          result::ok(addr) {\n+            fail #fmt(\"Expected failure, but got addr %?\", addr);\n+          }\n+        }\n+    }\n+    #[test]\n+    #[ignore(target_os=\"win32\")]\n+    fn test_ip_ipv6_bad_parse() {\n+        alt v6::try_parse_addr(\"::,~2234k;\") {\n+          result::err(err_info) {\n+            log(debug, #fmt(\"got error as expected %?\", err_info));\n+            assert true;\n+          }\n+          result::ok(addr) {\n+            fail #fmt(\"Expected failure, but got addr %?\", addr);\n+          }\n+        }\n+    }\n+    #[test]\n+    #[ignore(reason = \"valgrind says it's leaky\")]\n+    fn test_ip_get_addr() {\n+        let localhost_name = \"localhost\";\n+        let iotask = uv::global_loop::get();\n+        let ga_result = get_addr(localhost_name, iotask);\n+        if result::is_err(ga_result) {\n+            fail \"got err result from net::ip::get_addr();\"\n+        }\n+        // note really sure how to realiably test/assert\n+        // this.. mostly just wanting to see it work, atm.\n+        let results = result::unwrap(ga_result);\n+        log(debug, #fmt(\"test_get_addr: Number of results for %s: %?\",\n+                        localhost_name, vec::len(results)));\n+        for vec::each(results) |r| {\n+            let ipv_prefix = alt r {\n+              ipv4(_) {\n+                \"IPv4\"\n+              }\n+              ipv6(_) {\n+                \"IPv6\"\n+              }\n+            };\n+            log(debug, #fmt(\"test_get_addr: result %s: '%s'\",\n+                            ipv_prefix, format_addr(r)));\n+        }\n+        // at least one result.. this is going to vary from system\n+        // to system, based on stuff like the contents of /etc/hosts\n+        assert vec::len(results) > 0;\n     }\n-\n     #[test]\n-    fn test_parse_ip() {\n-        assert (v4::parse_addr(\"127.0.0.1\") ==\n-                ipv4(127u8, 0u8, 0u8, 1u8));\n+    #[ignore(reason = \"valgrind says it's leaky\")]\n+    fn test_ip_get_addr_bad_input() {\n+        let localhost_name = \"sjkl234m,./sdf\";\n+        let iotask = uv::global_loop::get();\n+        let ga_result = get_addr(localhost_name, iotask);\n+        assert result::is_err(ga_result);\n     }\n }\n\\ No newline at end of file"}, {"sha": "6fb9024e72958dceb09c52ddacce2b16da15f0a5", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 606, "deletions": 534, "changes": 1140, "blob_url": "https://github.com/rust-lang/rust/blob/2ea8922b8ab8ce7f820869778950346a749ed757/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea8922b8ab8ce7f820869778950346a749ed757/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=2ea8922b8ab8ce7f820869778950346a749ed757", "patch": "@@ -6,21 +6,26 @@ import ip = net_ip;\n import uv::iotask;\n import uv::iotask::iotask;\n import comm::methods;\n-import future_spawn = future::spawn;\n import future::future;\n-import result::{result,err,ok,extensions};\n-\n-// data\n-export tcp_socket, tcp_conn_port, tcp_err_data;\n+import future_spawn = future::spawn;\n+// FIXME #1935\n+// should be able to, but can't atm, replace w/ result::{result, extensions};\n+import result::*;\n+import libc::size_t;\n+import str::extensions;\n+\n+// tcp interfaces\n+export tcp_socket;\n+// buffered socket\n+export tcp_socket_buf, socket_buf;\n+// errors\n+export tcp_err_data, tcp_connect_err_data;\n // operations on a tcp_socket\n export write, write_future, read_start, read_stop;\n // tcp server stuff\n-export listen_for_conn, accept;\n-export new_listener, conn_recv, conn_recv_spawn, conn_peek;\n+export listen, accept;\n // tcp client stuff\n export connect;\n-// helper methods\n-export conn_port_methods, sock_methods;\n \n #[nolink]\n native mod rustrt {\n@@ -41,44 +46,20 @@ class tcp_socket {\n   new(socket_data: @tcp_socket_data) { self.socket_data = socket_data; }\n   drop {\n     unsafe {\n-       let closed_po = comm::port::<()>();\n-       let closed_ch = comm::chan(closed_po);\n-       let close_data = {\n-             closed_ch: closed_ch\n-       };\n-       let close_data_ptr = ptr::addr_of(close_data);\n-       let stream_handle_ptr = (*(self.socket_data)).stream_handle_ptr;\n-        do iotask::interact((*(self.socket_data)).iotask) |loop_ptr| {\n-          log(debug, #fmt(\"interact dtor for tcp_socket stream %? loop %?\",\n-            stream_handle_ptr, loop_ptr));\n-           uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n-                                       close_data_ptr);\n-           uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n-       };\n-       comm::recv(closed_po);\n-       log(debug, #fmt(\"about to free socket_data at %?\", self.socket_data));\n-       rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n-                                           as *libc::c_void);\n-       log(debug, \"exiting dtor for tcp_socket\");\n+        tear_down_socket_data(self.socket_data)\n     }\n   }\n }\n \n-class tcp_conn_port {\n-  let conn_data: @tcp_conn_port_data;\n-  new(conn_data: @tcp_conn_port_data) { self.conn_data = conn_data; }\n-  drop unsafe {\n-    let conn_data_ptr = ptr::addr_of(*(self.conn_data));\n-    let server_stream_ptr = ptr::addr_of((*conn_data_ptr).server_stream);\n-    let stream_closed_po = (*(self.conn_data)).stream_closed_po;\n-    let iotask = (*conn_data_ptr).iotask;\n-      do iotask::interact(iotask) |loop_ptr| {\n-        log(debug, #fmt(\"dtor for tcp_conn_port loop: %?\",\n-                       loop_ptr));\n-        uv::ll::close(server_stream_ptr, tcp_nl_close_cb);\n-    }\n-    comm::recv(stream_closed_po);\n-  }\n+#[doc=\"\n+A buffered wrapper for `net::tcp::tcp_socket`\n+\n+It is created with a call to `net::tcp::socket_buf()` and has impls that\n+satisfy both the `io::reader` and `io::writer` ifaces.\n+\"]\n+class tcp_socket_buf {\n+  let data: @tcp_buffered_socket_data;\n+  new(data: @tcp_buffered_socket_data) { self.data = data; }\n }\n \n #[doc=\"\n@@ -88,25 +69,69 @@ type tcp_err_data = {\n     err_name: str,\n     err_msg: str\n };\n+#[doc=\"\n+Details returned as part of a `result::err` result from `tcp::listen`\n+\"]\n+enum tcp_listen_err_data {\n+    #[doc=\"\n+    Some unplanned-for error. The first and second fields correspond\n+    to libuv's `err_name` and `err_msg` fields, respectively.\n+    \"]\n+    generic_listen_err(str, str),\n+    #[doc=\"\n+    Failed to bind to the requested IP/Port, because it is already in use.\n+\n+    # Possible Causes\n+\n+    * Attempting to bind to a port already bound to another listener\n+    \"]\n+    address_in_use,\n+    #[doc=\"\n+    Request to bind to an IP/Port was denied by the system.\n+\n+    # Possible Causes\n+\n+    * Attemping to binding to an IP/Port as a non-Administrator\n+      on Windows Vista+\n+    * Attempting to bind, as a non-priv'd\n+      user, to 'privileged' ports (< 1024) on *nix\n+    \"]\n+    access_denied\n+}\n+#[doc=\"\n+Details returned as part of a `result::err` result from `tcp::connect`\n+\"]\n+enum tcp_connect_err_data {\n+    #[doc=\"\n+    Some unplanned-for error. The first and second fields correspond\n+    to libuv's `err_name` and `err_msg` fields, respectively.\n+    \"]\n+    generic_connect_err(str, str),\n+    #[doc=\"\n+    Invalid IP or invalid port\n+    \"]\n+    connection_refused\n+}\n \n #[doc=\"\n Initiate a client connection over TCP/IP\n \n # Arguments\n \n-* `ip` - The IP address (versions 4 or 6) of the remote host\n+* `input_ip` - The IP address (versions 4 or 6) of the remote host\n * `port` - the unsigned integer of the desired remote host port\n * `iotask` - a `uv::iotask` that the tcp request will run on\n \n # Returns\n \n-A `result` that, if the operation succeeds, contains a `tcp_socket` that\n-can be used to send and receive data to/from the remote host. In the event\n-of failure, a `tcp_err_data` will be returned\n+A `result` that, if the operation succeeds, contains a `net::net::tcp_socket`\n+that can be used to send and receive data to/from the remote host. In the\n+event of failure, a `net::tcp::tcp_connect_err_data` instance will be\n+returned\n \"]\n-fn connect(input_ip: ip::ip_addr, port: uint,\n+fn connect(-input_ip: ip::ip_addr, port: uint,\n            iotask: iotask)\n-    -> result::result<tcp_socket, tcp_err_data> unsafe {\n+    -> result::result<tcp_socket, tcp_connect_err_data> unsafe {\n     let result_po = comm::port::<conn_attempt>();\n     let closed_signal_po = comm::port::<()>();\n     let conn_data = {\n@@ -141,16 +166,35 @@ fn connect(input_ip: ip::ip_addr, port: uint,\n             alt input_ip {\n               ipv4 {\n                 log(debug, \"dealing w/ ipv4 connection..\");\n-                let tcp_addr = ipv4_ip_addr_to_sockaddr_in(input_ip,\n-                                                           port);\n-                let tcp_addr_ptr = ptr::addr_of(tcp_addr);\n                 let connect_req_ptr =\n                     ptr::addr_of((*socket_data_ptr).connect_req);\n-                alt uv::ll::tcp_connect(\n-                    connect_req_ptr,\n-                    stream_handle_ptr,\n-                    tcp_addr_ptr,\n-                    tcp_connect_on_connect_cb) {\n+                let addr_str = ip::format_addr(input_ip);\n+                let connect_result = alt input_ip {\n+                  ip::ipv4(addr) {\n+                    // have to \"recreate\" the sockaddr_in/6\n+                    // since the ip_addr discards the port\n+                    // info.. should probably add an additional\n+                    // rust type that actually is closer to\n+                    // what the libuv API expects (ip str + port num)\n+                    log(debug, #fmt(\"addr: %?\", addr));\n+                    let in_addr = uv::ll::ip4_addr(addr_str, port as int);\n+                    uv::ll::tcp_connect(\n+                        connect_req_ptr,\n+                        stream_handle_ptr,\n+                        ptr::addr_of(in_addr),\n+                        tcp_connect_on_connect_cb)\n+                  }\n+                  ip::ipv6(addr) {\n+                    log(debug, #fmt(\"addr: %?\", addr));\n+                    let in_addr = uv::ll::ip6_addr(addr_str, port as int);\n+                    uv::ll::tcp_connect6(\n+                        connect_req_ptr,\n+                        stream_handle_ptr,\n+                        ptr::addr_of(in_addr),\n+                        tcp_connect_on_connect_cb)\n+                  }\n+                };\n+                alt connect_result {\n                   0i32 {\n                     log(debug, \"tcp_connect successful\");\n                     // reusable data that we'll have for the\n@@ -196,7 +240,14 @@ fn connect(input_ip: ip::ip_addr, port: uint,\n       conn_failure(err_data) {\n         comm::recv(closed_signal_po);\n         log(debug, \"tcp::connect - received failure on result_po\");\n-        result::err(err_data.to_tcp_err())\n+        // still have to free the malloc'd stream handle..\n+        rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n+                                           as *libc::c_void);\n+        let tcp_conn_err = alt err_data.err_name {\n+          \"ECONNREFUSED\" { connection_refused }\n+          _ { generic_connect_err(err_data.err_name, err_data.err_msg) }\n+        };\n+        result::err(tcp_conn_err)\n       }\n     }\n }\n@@ -226,9 +277,12 @@ Write binary data to tcp stream; Returns a `future::future` value immediately\n \n # Safety\n \n-This function can produce unsafe results if the call to `write_future` is\n-made, the `future::future` value returned is never resolved via\n-`future::get`, and then the `tcp_socket` passed in to `write_future` leaves\n+This function can produce unsafe results if:\n+\n+1. the call to `write_future` is made\n+2. the `future::future` value returned is never resolved via\n+`future::get`\n+3. and then the `tcp_socket` passed in to `write_future` leaves\n scope and is destructed before the task that runs the libuv write\n operation completes.\n \n@@ -252,7 +306,8 @@ fn write_future(sock: tcp_socket, raw_write_data: ~[u8])\n     -> future<result::result<(), tcp_err_data>> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n     do future_spawn || {\n-        write_common_impl(socket_data_ptr, raw_write_data)\n+        let data_copy = copy(raw_write_data);\n+        write_common_impl(socket_data_ptr, data_copy)\n     }\n }\n \n@@ -283,9 +338,11 @@ Stop reading from an open TCP connection; used with `read_start`\n \n * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n \"]\n-fn read_stop(sock: tcp_socket) ->\n+fn read_stop(sock: tcp_socket,\n+             -read_port: comm::port<result::result<[u8]/~, tcp_err_data>>) ->\n     result::result<(), tcp_err_data> unsafe {\n-    let socket_data = ptr::addr_of(*(sock.socket_data));\n+    log(debug, #fmt(\"taking the read_port out of commission %?\", read_port));\n+    let socket_data = ptr::addr_of(*sock.socket_data);\n     read_stop_common_impl(socket_data)\n }\n \n@@ -345,182 +402,6 @@ fn read_future(sock: tcp_socket, timeout_msecs: uint)\n     }\n }\n \n-#[doc=\"\n-Bind to a given IP/port and listen for new connections\n-\n-# Arguments\n-\n-* `host_ip` - a `net::ip::ip_addr` representing a unique IP\n-(versions 4 or 6)\n-* `port` - a uint representing the port to listen on\n-* `backlog` - a uint representing the number of incoming connections\n-to cache in memory\n-* `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n-\n-# Returns\n-\n-A `result` instance containing either a `tcp_conn_port` which can used\n-to listen for, and accept, new connections, or a `tcp_err_data` if\n-failure to create the tcp listener occurs\n-\"]\n-fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint,\n-                iotask: iotask)\n-    -> result::result<tcp_conn_port, tcp_err_data> unsafe {\n-    let stream_closed_po = comm::port::<()>();\n-    let stream_closed_ch = comm::chan(stream_closed_po);\n-    let new_conn_po = comm::port::<result::result<*uv::ll::uv_tcp_t,\n-                                                  tcp_err_data>>();\n-    let new_conn_ch = comm::chan(new_conn_po);\n-    // FIXME (#2656): This shared box should not be captured in the i/o\n-    // task Make it a unique pointer.\n-    let server_data: @tcp_conn_port_data = @{\n-        server_stream: uv::ll::tcp_t(),\n-        stream_closed_po: stream_closed_po,\n-        stream_closed_ch: stream_closed_ch,\n-        iotask: iotask,\n-        new_conn_po: new_conn_po,\n-        new_conn_ch: new_conn_ch\n-    };\n-    let server_data_ptr = ptr::addr_of(*server_data);\n-    let server_stream_ptr = ptr::addr_of((*server_data_ptr)\n-                                         .server_stream);\n-\n-    let setup_po = comm::port::<option<tcp_err_data>>();\n-    let setup_ch = comm::chan(setup_po);\n-    do iotask::interact(iotask) |loop_ptr| {\n-        let tcp_addr = ipv4_ip_addr_to_sockaddr_in(host_ip,\n-                                                   port);\n-        alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n-          0i32 {\n-            alt uv::ll::tcp_bind(server_stream_ptr,\n-                                 ptr::addr_of(tcp_addr)) {\n-              0i32 {\n-                alt uv::ll::listen(server_stream_ptr,\n-                                   backlog as libc::c_int,\n-                                   tcp_nl_on_connection_cb) {\n-                  0i32 {\n-                    uv::ll::set_data_for_uv_handle(\n-                        server_stream_ptr,\n-                        server_data_ptr);\n-                    comm::send(setup_ch, none);\n-                  }\n-                  _ {\n-                    log(debug, \"failure to uv_listen()\");\n-                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    comm::send(setup_ch, some(err_data));\n-                  }\n-                }\n-              }\n-              _ {\n-                log(debug, \"failure to uv_tcp_bind\");\n-                let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                comm::send(setup_ch, some(err_data));\n-              }\n-            }\n-          }\n-          _ {\n-            log(debug, \"failure to uv_tcp_init\");\n-            let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            comm::send(setup_ch, some(err_data));\n-          }\n-        }\n-    };\n-    alt comm::recv(setup_po) {\n-      some(err_data) {\n-        // we failed to bind/list w/ libuv\n-        result::err(err_data.to_tcp_err())\n-      }\n-      none {\n-        result::ok(tcp_conn_port(server_data))\n-      }\n-    }\n-}\n-\n-#[doc=\"\n-Block on a `net::tcp::tcp_conn_port` until a new connection arrives\n-\n-This function behaves similarly to `comm::recv()`\n-\n-# Arguments\n-\n-* server_port -- a `net::tcp::tcp_conn_port` that you wish to listen\n-on for an incoming connection\n-\n-# Returns\n-\n-A `result` object containing a `net::tcp::tcp_socket`, ready for immediate\n-use, as the `ok` varient, or a `net::tcp::tcp_err_data` for the `err`\n-variant\n-\"]\n-fn conn_recv(server_port: tcp_conn_port)\n-    -> result::result<tcp_socket, tcp_err_data> {\n-    let new_conn_po = (*(server_port.conn_data)).new_conn_po;\n-    let iotask = (*(server_port.conn_data)).iotask;\n-    let new_conn_result = comm::recv(new_conn_po);\n-    alt new_conn_result {\n-      ok(client_stream_ptr) {\n-        conn_port_new_tcp_socket(client_stream_ptr, iotask)\n-      }\n-      err(err_data) {\n-        result::err(err_data)\n-      }\n-    }\n-}\n-\n-#[doc=\"\n-Identical to `net::tcp::conn_recv`, but ran on a new task\n-\n-The recv'd tcp_socket is created with a new task on the current scheduler,\n-and given as a parameter to the provided callback\n-\n-# Arguments\n-\n-* `server_port` -- a `net::tcp::tcp_conn_port` that you wish to listen\n-on for an incoming connection\n-* `cb` -- a callback that will be ran, in a new task on the current scheduler,\n-once a new connection is recv'd. Its parameter:\n-  * A `result` object containing a `net::tcp::tcp_socket`, ready for immediate\n-    use, as the `ok` varient, or a `net::tcp::tcp_err_data` for the `err`\n-    variant\n-\"]\n-fn conn_recv_spawn(server_port: tcp_conn_port,\n-                   +cb: fn~(result::result<tcp_socket, tcp_err_data>)) {\n-    let new_conn_po = (*(server_port.conn_data)).new_conn_po;\n-    let iotask = (*(server_port.conn_data)).iotask;\n-    let new_conn_result = comm::recv(new_conn_po);\n-    do task::spawn || {\n-        let sock_create_result = alt new_conn_result {\n-          ok(client_stream_ptr) {\n-            conn_port_new_tcp_socket(client_stream_ptr, iotask)\n-          }\n-          err(err_data) {\n-            result::err(err_data)\n-          }\n-        };\n-        cb(sock_create_result);\n-    };\n-}\n-\n-#[doc=\"\n-Check if a `net::tcp::tcp_conn_port` has one-or-more pending, new connections\n-\n-This function behaves similarly to `comm::peek()`\n-\n-# Arguments\n-\n-* `server_port` -- a `net::tcp::tcp_conn_port` representing a server\n-connection\n-\n-# Returns\n-\n-`true` if there are one-or-more pending connections, `false` if there are\n-none.\n-\"]\n-fn conn_peek(server_port: tcp_conn_port) -> bool {\n-    let new_conn_po = (*(server_port.conn_data)).new_conn_po;\n-    comm::peek(new_conn_po)\n-}\n-\n #[doc=\"\n Bind an incoming client connection to a `net::tcp::tcp_socket`\n \n@@ -546,12 +427,20 @@ Here, the `new_conn` is used in conjunction with `accept` from within\n a task spawned by the `new_connect_cb` passed into `listen`\n \n ~~~~~~~~~~~\n-net::tcp::listen(remote_ip, remote_port, backlog) {|new_conn, kill_ch|\n+net::tcp::listen(remote_ip, remote_port, backlog)\n+    // this callback is ran once after the connection is successfully\n+    // set up\n+    {|kill_ch|\n+      // pass the kill_ch to your main loop or wherever you want\n+      // to be able to externally kill the server from\n+    }\n+    // this callback is ran when a new connection arrives\n+    {|new_conn, kill_ch|\n     let cont_po = comm::port::<option<tcp_err_data>>();\n     let cont_ch = comm::chan(cont_po);\n     task::spawn {||\n         let accept_result = net::tcp::accept(new_conn);\n-        if accept_result.is_failure() {\n+        if accept_result.is_err() {\n             comm::send(cont_ch, result::get_err(accept_result));\n             // fail?\n         }\n@@ -576,13 +465,11 @@ net::tcp::listen(remote_ip, remote_port, backlog) {|new_conn, kill_ch|\n \n # Returns\n \n-* Success\n-  * On success, this function will return a `net::tcp::tcp_socket` as the\n-  `ok` variant of a `result`. The `net::tcp::tcp_socket` is anchored within\n-  the task that `accept` was called within for its lifetime.\n-* Failure\n-  * On failure, this function will return a `net::tcp::tcp_err_data` record\n-  as the `err` variant of a `result`.\n+On success, this function will return a `net::tcp::tcp_socket` as the\n+`ok` variant of a `result`. The `net::tcp::tcp_socket` is anchored within\n+the task that `accept` was called within for its lifetime. On failure,\n+this function will return a `net::tcp::tcp_err_data` record\n+as the `err` variant of a `result`.\n \"]\n fn accept(new_conn: tcp_new_connection)\n     -> result::result<tcp_socket, tcp_err_data> unsafe {\n@@ -683,15 +570,31 @@ callback's arguments are:\n # returns\n \n a `result` instance containing empty data of type `()` on a\n-successful/normal shutdown, and a `tcp_err_data` record in the event\n+successful/normal shutdown, and a `tcp_listen_err_data` enum in the event\n of listen exiting because of an error\n \"]\n-fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n+fn listen(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n           iotask: iotask,\n           on_establish_cb: fn~(comm::chan<option<tcp_err_data>>),\n           +new_connect_cb: fn~(tcp_new_connection,\n                                comm::chan<option<tcp_err_data>>))\n-    -> result::result<(), tcp_err_data> unsafe {\n+    -> result::result<(), tcp_listen_err_data> unsafe {\n+    do listen_common(host_ip, port, backlog, iotask, on_establish_cb)\n+        // on_connect_cb\n+        |handle| {\n+            let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n+                as *tcp_listen_fc_data;\n+            let new_conn = new_tcp_conn(handle);\n+            let kill_ch = (*server_data_ptr).kill_ch;\n+            new_connect_cb(new_conn, kill_ch);\n+    }\n+}\n+\n+fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n+          iotask: iotask,\n+          on_establish_cb: fn~(comm::chan<option<tcp_err_data>>),\n+          -on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n+    -> result::result<(), tcp_listen_err_data> unsafe {\n     let stream_closed_po = comm::port::<()>();\n     let kill_po = comm::port::<option<tcp_err_data>>();\n     let kill_ch = comm::chan(kill_po);\n@@ -701,56 +604,97 @@ fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n         server_stream_ptr: server_stream_ptr,\n         stream_closed_ch: comm::chan(stream_closed_po),\n         kill_ch: kill_ch,\n-        new_connect_cb: new_connect_cb,\n+        on_connect_cb: on_connect_cb,\n         iotask: iotask,\n         mut active: true\n     };\n     let server_data_ptr = ptr::addr_of(server_data);\n \n-    let setup_po = comm::port::<option<tcp_err_data>>();\n-    let setup_ch = comm::chan(setup_po);\n-    do iotask::interact(iotask) |loop_ptr| {\n-        let tcp_addr = ipv4_ip_addr_to_sockaddr_in(host_ip,\n-                                                   port);\n-        alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n-          0i32 {\n-            alt uv::ll::tcp_bind(server_stream_ptr,\n-                                 ptr::addr_of(tcp_addr)) {\n+    let setup_result = do comm::listen |setup_ch| {\n+        // this is to address a compiler warning about\n+        // an implicit copy.. it seems that double nested\n+        // will defeat a move sigil, as is done to the host_ip\n+        // arg above.. this same pattern works w/o complaint in\n+        // tcp::connect (because the iotask::interact cb isn't\n+        // nested within a comm::listen block)\n+        let loc_ip = copy(host_ip);\n+        do iotask::interact(iotask) |loop_ptr| {\n+            alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n               0i32 {\n-                alt uv::ll::listen(server_stream_ptr,\n-                                   backlog as libc::c_int,\n-                                   tcp_lfc_on_connection_cb) {\n+                uv::ll::set_data_for_uv_handle(\n+                    server_stream_ptr,\n+                    server_data_ptr);\n+                let addr_str = ip::format_addr(loc_ip);\n+                let bind_result = alt loc_ip {\n+                  ip::ipv4(addr) {\n+                    log(debug, #fmt(\"addr: %?\", addr));\n+                    let in_addr = uv::ll::ip4_addr(addr_str, port as int);\n+                    uv::ll::tcp_bind(server_stream_ptr,\n+                                     ptr::addr_of(in_addr))\n+                  }\n+                  ip::ipv6(addr) {\n+                    log(debug, #fmt(\"addr: %?\", addr));\n+                    let in_addr = uv::ll::ip6_addr(addr_str, port as int);\n+                    uv::ll::tcp_bind6(server_stream_ptr,\n+                                     ptr::addr_of(in_addr))\n+                  }\n+                };\n+                alt bind_result {\n                   0i32 {\n-                    uv::ll::set_data_for_uv_handle(\n-                        server_stream_ptr,\n-                        server_data_ptr);\n-                    comm::send(setup_ch, none);\n+                    alt uv::ll::listen(server_stream_ptr,\n+                                       backlog as libc::c_int,\n+                                       tcp_lfc_on_connection_cb) {\n+                      0i32 {\n+                        comm::send(setup_ch, none);\n+                      }\n+                      _ {\n+                        log(debug, \"failure to uv_listen()\");\n+                        let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                        comm::send(setup_ch, some(err_data));\n+                      }\n+                    }\n                   }\n                   _ {\n-                    log(debug, \"failure to uv_listen()\");\n+                    log(debug, \"failure to uv_tcp_bind\");\n                     let err_data = uv::ll::get_last_err_data(loop_ptr);\n                     comm::send(setup_ch, some(err_data));\n                   }\n                 }\n               }\n               _ {\n-                log(debug, \"failure to uv_tcp_bind\");\n+                log(debug, \"failure to uv_tcp_init\");\n                 let err_data = uv::ll::get_last_err_data(loop_ptr);\n                 comm::send(setup_ch, some(err_data));\n               }\n             }\n+        };\n+        setup_ch.recv()\n+    };\n+    alt setup_result {\n+      some(err_data) {\n+        do iotask::interact(iotask) |loop_ptr| {\n+            log(debug, #fmt(\"tcp::listen post-kill recv hl interact %?\",\n+                            loop_ptr));\n+            (*server_data_ptr).active = false;\n+            uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n+        };\n+        stream_closed_po.recv();\n+        alt err_data.err_name {\n+          \"EACCES\" {\n+            log(debug, \"Got EACCES error\");\n+            result::err(access_denied)\n+          }\n+          \"EADDRINUSE\" {\n+            log(debug, \"Got EADDRINUSE error\");\n+            result::err(address_in_use)\n           }\n           _ {\n-            log(debug, \"failure to uv_tcp_init\");\n-            let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            comm::send(setup_ch, some(err_data));\n+            log(debug, #fmt(\"Got '%s' '%s' libuv error\",\n+                            err_data.err_name, err_data.err_msg));\n+            result::err(\n+                generic_listen_err(err_data.err_name, err_data.err_msg))\n           }\n         }\n-    };\n-    alt comm::recv(setup_po) {\n-      some(err_data) {\n-        // we failed to bind/list w/ libuv\n-        result::err(err_data.to_tcp_err())\n       }\n       none {\n         on_establish_cb(kill_ch);\n@@ -761,11 +705,12 @@ fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n             (*server_data_ptr).active = false;\n             uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n         };\n-        comm::recv(stream_closed_po);\n+        stream_closed_po.recv();\n         alt kill_result {\n           // some failure post bind/listen\n           some(err_data) {\n-            result::err(err_data)\n+            result::err(generic_listen_err(err_data.err_name,\n+                                            err_data.err_msg))\n           }\n           // clean exit\n           none {\n@@ -777,46 +722,154 @@ fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n }\n \n #[doc=\"\n-Convenience methods extending `net::tcp::tcp_conn_port`\n+Convert a `net::tcp::tcp_socket` to a `net::tcp::tcp_socket_buf`.\n+\n+This function takes ownership of a `net::tcp::tcp_socket`, returning it\n+stored within a buffered wrapper, which can be converted to a `io::reader`\n+or `io::writer`\n+\n+# Arguments\n+\n+* `sock` -- a `net::tcp::tcp_socket` that you want to buffer\n+\n+# Returns\n+\n+A buffered wrapper that you can cast as an `io::reader` or `io::writer`\n \"]\n-impl conn_port_methods for tcp_conn_port {\n-    fn recv() -> result::result<tcp_socket, tcp_err_data> { conn_recv(self) }\n-    fn recv_spawn(+cb: fn~(result::result<tcp_socket,tcp_err_data>))\n-                  { conn_recv_spawn(self, cb); }\n-    fn peek() -> bool { conn_peek(self) }\n+fn socket_buf(-sock: tcp_socket) -> tcp_socket_buf {\n+    tcp_socket_buf(@{ sock: sock, mut buf: []/~ })\n }\n \n #[doc=\"\n Convenience methods extending `net::tcp::tcp_socket`\n \"]\n-impl sock_methods for tcp_socket {\n+impl tcp_socket for tcp_socket {\n     fn read_start() -> result::result<comm::port<\n         result::result<~[u8], tcp_err_data>>, tcp_err_data> {\n         read_start(self)\n     }\n-    fn read_stop() ->\n+    fn read_stop(-read_port:\n+                 comm::port<result::result<[u8]/~, tcp_err_data>>) ->\n         result::result<(), tcp_err_data> {\n-        read_stop(self)\n+        read_stop(self, read_port)\n     }\n     fn read(timeout_msecs: uint) ->\n         result::result<~[u8], tcp_err_data> {\n         read(self, timeout_msecs)\n     }\n     fn read_future(timeout_msecs: uint) ->\n-        future<result::result<~[u8], tcp_err_data>> {\n+        future::future<result::result<~[u8], tcp_err_data>> {\n         read_future(self, timeout_msecs)\n     }\n     fn write(raw_write_data: ~[u8])\n         -> result::result<(), tcp_err_data> {\n         write(self, raw_write_data)\n     }\n     fn write_future(raw_write_data: ~[u8])\n-        -> future<result::result<(), tcp_err_data>> {\n+        -> future::future<result::result<(), tcp_err_data>> {\n         write_future(self, raw_write_data)\n     }\n }\n+\n+#[doc=\"\n+Implementation of `io::reader` iface for a buffered `net::tcp::tcp_socket`\n+\"]\n+impl tcp_socket_buf of io::reader for @tcp_socket_buf {\n+    fn read_bytes(amt: uint) -> [u8]/~ {\n+        let has_amt_available =\n+            vec::len((*(self.data)).buf) >= amt;\n+        if has_amt_available {\n+            // no arbitrary-length shift in vec::?\n+            let mut ret_buf = []/~;\n+            while vec::len(ret_buf) < amt {\n+                ret_buf += [vec::shift((*(self.data)).buf)]/~;\n+            }\n+            ret_buf\n+        }\n+        else {\n+            let read_result = read((*(self.data)).sock, 0u);\n+            if read_result.is_err() {\n+                let err_data = read_result.get_err();\n+                log(debug, #fmt(\"ERROR sock_buf as io::reader.read err %? %?\",\n+                                 err_data.err_name, err_data.err_msg));\n+                []/~\n+            }\n+            else {\n+                let new_chunk = result::unwrap(read_result);\n+                (*(self.data)).buf += new_chunk;\n+                self.read_bytes(amt)\n+            }\n+        }\n+    }\n+    fn read_byte() -> int {\n+        self.read_bytes(1u)[0] as int\n+    }\n+    fn unread_byte(amt: int) {\n+        vec::unshift((*(self.data)).buf, amt as u8);\n+    }\n+    fn eof() -> bool {\n+        false // noop\n+    }\n+    fn seek(dist: int, seek: io::seek_style) {\n+        log(debug, #fmt(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n+        // noop\n+    }\n+    fn tell() -> uint {\n+        0u // noop\n+    }\n+}\n+\n+#[doc=\"\n+Implementation of `io::reader` iface for a buffered `net::tcp::tcp_socket`\n+\"]\n+impl tcp_socket_buf of io::writer for @tcp_socket_buf {\n+    fn write(data: [const u8]/&) unsafe {\n+        let socket_data_ptr =\n+            ptr::addr_of(*((*(self.data)).sock).socket_data);\n+        let w_result = write_common_impl(socket_data_ptr,\n+                                        vec::slice(data, 0, vec::len(data)));\n+        if w_result.is_err() {\n+            let err_data = w_result.get_err();\n+            log(debug, #fmt(\"ERROR sock_buf as io::writer.writer err: %? %?\",\n+                             err_data.err_name, err_data.err_msg));\n+        }\n+    }\n+    fn seek(dist: int, seek: io::seek_style) {\n+      log(debug, #fmt(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n+        // noop\n+    }\n+    fn tell() -> uint {\n+        0u\n+    }\n+    fn flush() -> int {\n+        0\n+    }\n+}\n+\n // INTERNAL API\n \n+fn tear_down_socket_data(socket_data: @tcp_socket_data) unsafe {\n+    let closed_po = comm::port::<()>();\n+    let closed_ch = comm::chan(closed_po);\n+    let close_data = {\n+        closed_ch: closed_ch\n+    };\n+    let close_data_ptr = ptr::addr_of(close_data);\n+    let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n+    do iotask::interact((*socket_data).iotask) |loop_ptr| {\n+        log(debug, #fmt(\"interact dtor for tcp_socket stream %? loop %?\",\n+            stream_handle_ptr, loop_ptr));\n+        uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n+                                       close_data_ptr);\n+        uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n+    };\n+    comm::recv(closed_po);\n+    log(debug, #fmt(\"about to free socket_data at %?\", socket_data));\n+    rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n+                                       as *libc::c_void);\n+    log(debug, \"exiting dtor for tcp_socket\");\n+}\n+\n // shared implementation for tcp::read\n fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n     -> result::result<~[u8],tcp_err_data> unsafe {\n@@ -919,6 +972,8 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n     }\n }\n \n+// helper to convert a \"class\" vector of [u8] to a *[uv::ll::uv_buf_t]\n+\n // shared implementation used by write and write_future\n fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n                      raw_write_data: ~[u8])\n@@ -963,56 +1018,15 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n     }\n }\n \n-// various recv_* can use a tcp_conn_port can re-use this..\n-fn conn_port_new_tcp_socket(\n-    stream_handle_ptr: *uv::ll::uv_tcp_t,\n-    iotask: iotask)\n-    -> result::result<tcp_socket,tcp_err_data> unsafe {\n-    // tcp_nl_on_connection_cb\n-    let reader_po = comm::port::<result::result<~[u8], tcp_err_data>>();\n-    let client_socket_data = @{\n-        reader_po : reader_po,\n-        reader_ch : comm::chan(reader_po),\n-        stream_handle_ptr : stream_handle_ptr,\n-        connect_req : uv::ll::connect_t(),\n-        write_req : uv::ll::write_t(),\n-        iotask : iotask\n-    };\n-    let client_socket_data_ptr = ptr::addr_of(*client_socket_data);\n-    do comm::listen |cont_ch| {\n-        do iotask::interact(iotask) |loop_ptr| {\n-            log(debug, #fmt(\"in interact cb 4 conn_port_new_tcp.. loop %?\",\n-                loop_ptr));\n-            uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n-                                           client_socket_data_ptr);\n-            cont_ch.send(());\n-        };\n-        cont_ch.recv()\n-    };\n-    result::ok(tcp_socket(client_socket_data))\n-}\n-\n enum tcp_new_connection {\n     new_tcp_conn(*uv::ll::uv_tcp_t)\n }\n \n-type tcp_conn_port_data = {\n-    server_stream: uv::ll::uv_tcp_t,\n-    stream_closed_po: comm::port<()>,\n-    stream_closed_ch: comm::chan<()>,\n-    iotask: iotask,\n-    new_conn_po: comm::port<result::result<*uv::ll::uv_tcp_t,\n-                                            tcp_err_data>>,\n-    new_conn_ch: comm::chan<result::result<*uv::ll::uv_tcp_t,\n-                                           tcp_err_data>>\n-};\n-\n type tcp_listen_fc_data = {\n     server_stream_ptr: *uv::ll::uv_tcp_t,\n     stream_closed_ch: comm::chan<()>,\n     kill_ch: comm::chan<option<tcp_err_data>>,\n-    new_connect_cb: fn~(tcp_new_connection,\n-                        comm::chan<option<tcp_err_data>>),\n+    on_connect_cb: fn~(*uv::ll::uv_tcp_t),\n     iotask: iotask,\n     mut active: bool\n };\n@@ -1031,8 +1045,7 @@ crust fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n     if (*server_data_ptr).active {\n         alt status {\n           0i32 {\n-            let new_conn = new_tcp_conn(handle);\n-            (*server_data_ptr).new_connect_cb(new_conn, kill_ch);\n+            (*server_data_ptr).on_connect_cb(handle);\n           }\n           _ {\n             let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n@@ -1045,66 +1058,11 @@ crust fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n     }\n }\n \n-crust fn tcp_nl_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n-    let conn_data_ptr = uv::ll::get_data_for_uv_handle(\n-        handle) as *tcp_conn_port_data;\n-    comm::send((*conn_data_ptr).stream_closed_ch, ());\n-}\n-\n fn malloc_uv_tcp_t() -> *uv::ll::uv_tcp_t unsafe {\n     rustrt::rust_uv_current_kernel_malloc(\n         rustrt::rust_uv_helper_uv_tcp_t_size()) as *uv::ll::uv_tcp_t\n }\n \n-crust fn tcp_nl_on_connection_cb(server_handle_ptr: *uv::ll::uv_tcp_t,\n-                                     status: libc::c_int) unsafe {\n-    let server_data_ptr = uv::ll::get_data_for_uv_handle(server_handle_ptr)\n-        as *tcp_conn_port_data;\n-    let new_conn_ch = (*server_data_ptr).new_conn_ch;\n-    let loop_ptr = uv::ll::get_loop_for_uv_handle(server_handle_ptr);\n-    alt status {\n-      0i32 {\n-        let client_stream_handle_ptr = malloc_uv_tcp_t();\n-        *(client_stream_handle_ptr as *mut uv::ll::uv_tcp_t) =\n-            uv::ll::tcp_t();\n-        alt uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n-          0i32 {\n-            log(debug, \"uv_tcp_init successful for client stream\");\n-            alt uv::ll::accept(\n-                server_handle_ptr as *libc::c_void,\n-                client_stream_handle_ptr as *libc::c_void) {\n-              0i32 {\n-                log(debug, \"successfully accepted client connection\");\n-                comm::send(new_conn_ch,\n-                           result::ok(client_stream_handle_ptr));\n-              }\n-              _ {\n-                log(debug, \"failed to accept client conn\");\n-                comm::send(\n-                    new_conn_ch,\n-                    result::err(uv::ll::get_last_err_data(loop_ptr)\n-                        .to_tcp_err()));\n-              }\n-            }\n-          }\n-          _ {\n-            log(debug, \"failed to init client stream\");\n-            comm::send(\n-                new_conn_ch,\n-                result::err(uv::ll::get_last_err_data(loop_ptr)\n-                    .to_tcp_err()));\n-          }\n-        }\n-      }\n-      _ {\n-        comm::send(\n-            new_conn_ch,\n-            result::err(uv::ll::get_last_err_data(loop_ptr)\n-                .to_tcp_err()));\n-      }\n-    }\n-}\n-\n enum tcp_connect_result {\n     tcp_connected(tcp_socket),\n     tcp_connect_error(tcp_err_data)\n@@ -1171,7 +1129,7 @@ crust fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n }\n \n crust fn on_alloc_cb(handle: *libc::c_void,\n-                     ++suggested_size: libc::size_t)\n+                     ++suggested_size: size_t)\n     -> uv::ll::uv_buf_t unsafe {\n     log(debug, \"tcp read on_alloc_cb!\");\n     let char_ptr = uv::ll::malloc_buf_base_of(suggested_size);\n@@ -1273,21 +1231,12 @@ type tcp_socket_data = {\n     iotask: iotask\n };\n \n-// convert rust ip_addr to libuv's native representation\n-fn ipv4_ip_addr_to_sockaddr_in(input_ip: ip::ip_addr,\n-                               port: uint) -> uv::ll::sockaddr_in unsafe {\n-    // FIXME (#2656): ipv6\n-    alt input_ip {\n-      ip::ipv4(_,_,_,_) {\n-        uv::ll::ip4_addr(ip::format_addr(input_ip), port as int)\n-      }\n-      ip::ipv6(_,_,_,_,_,_,_,_) {\n-        fail \"FIXME (#2656) ipv6 not yet supported\";\n-      }\n-    }\n-}\n+type tcp_buffered_socket_data = {\n+    sock: tcp_socket,\n+    mut buf: [u8]/~\n+};\n \n-#[cfg(test)]\n+//#[cfg(test)]\n mod test {\n     // FIXME don't run on fbsd or linux 32 bit (#2064)\n     #[cfg(target_os=\"win32\")]\n@@ -1301,9 +1250,22 @@ mod test {\n                 impl_gl_tcp_ipv4_server_and_client();\n             }\n             #[test]\n-            fn test_gl_tcp_server_listener_and_client_ipv4() unsafe {\n-                impl_gl_tcp_ipv4_server_listener_and_client();\n+            fn test_gl_tcp_ipv4_client_error_connection_refused() unsafe {\n+                impl_gl_tcp_ipv4_client_error_connection_refused();\n+            }\n+            #[test]\n+            fn test_gl_tcp_server_address_in_use() unsafe {\n+                impl_gl_tcp_ipv4_server_address_in_use();\n+            }\n+            #[test]\n+            fn test_gl_tcp_server_access_denied() unsafe {\n+                impl_gl_tcp_ipv4_server_access_denied();\n             }\n+            #[test]\n+            fn test_gl_tcp_ipv4_server_client_reader_writer() {\n+                impl_gl_tcp_ipv4_server_client_reader_writer();\n+            }\n+\n         }\n         #[cfg(target_arch=\"x86\")]\n         mod impl32 {\n@@ -1314,8 +1276,24 @@ mod test {\n             }\n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]\n-            fn test_gl_tcp_server_listener_and_client_ipv4() unsafe {\n-                impl_gl_tcp_ipv4_server_listener_and_client();\n+            fn test_gl_tcp_ipv4_client_error_connection_refused() unsafe {\n+                impl_gl_tcp_ipv4_client_error_connection_refused();\n+            }\n+            #[test]\n+            #[ignore(cfg(target_os = \"linux\"))]\n+            fn test_gl_tcp_server_address_in_use() unsafe {\n+                impl_gl_tcp_ipv4_server_address_in_use();\n+            }\n+            #[test]\n+            #[ignore(cfg(target_os = \"linux\"))]\n+            #[ignore(cfg(windows), reason = \"deadlocking bots\")]\n+            fn test_gl_tcp_server_access_denied() unsafe {\n+                impl_gl_tcp_ipv4_server_access_denied();\n+            }\n+            #[test]\n+            #[ignore(cfg(target_os = \"linux\"))]\n+            fn test_gl_tcp_ipv4_server_client_reader_writer() {\n+                impl_gl_tcp_ipv4_server_client_reader_writer();\n             }\n         }\n     }\n@@ -1347,14 +1325,16 @@ mod test {\n         comm::recv(cont_po);\n         // client\n         log(debug, \"server started, firing up client..\");\n-        let actual_resp = do comm::listen |client_ch| {\n+        let actual_resp_result = do comm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n                 expected_req,\n                 client_ch,\n                 hl_loop)\n         };\n+        assert actual_resp_result.is_ok();\n+        let actual_resp = actual_resp_result.get();\n         let actual_req = comm::recv(server_result_po);\n         log(debug, #fmt(\"REQ: expected: '%s' actual: '%s'\",\n                        expected_req, actual_req));\n@@ -1363,11 +1343,34 @@ mod test {\n         assert str::contains(actual_req, expected_req);\n         assert str::contains(actual_resp, expected_resp);\n     }\n-    fn impl_gl_tcp_ipv4_server_listener_and_client() {\n+    fn impl_gl_tcp_ipv4_client_error_connection_refused() {\n         let hl_loop = uv::global_loop::get();\n         let server_ip = \"127.0.0.1\";\n         let server_port = 8889u;\n         let expected_req = \"ping\";\n+        // client\n+        log(debug, \"firing up client..\");\n+        let actual_resp_result = do comm::listen |client_ch| {\n+            run_tcp_test_client(\n+                server_ip,\n+                server_port,\n+                expected_req,\n+                client_ch,\n+                hl_loop)\n+        };\n+        alt actual_resp_result.get_err() {\n+          connection_refused {\n+          }\n+          _ {\n+            fail \"unknown error.. expected connection_refused\"\n+          }\n+        }\n+    }\n+    fn impl_gl_tcp_ipv4_server_address_in_use() {\n+        let hl_loop = uv::global_loop::get();\n+        let server_ip = \"127.0.0.1\";\n+        let server_port = 8890u;\n+        let expected_req = \"ping\";\n         let expected_resp = \"pong\";\n \n         let server_result_po = comm::port::<str>();\n@@ -1378,7 +1381,7 @@ mod test {\n         // server\n         do task::spawn_sched(task::manual_threads(1u)) || {\n             let actual_req = do comm::listen |server_ch| {\n-                run_tcp_test_server_listener(\n+                run_tcp_test_server(\n                     server_ip,\n                     server_port,\n                     expected_resp,\n@@ -1389,16 +1392,91 @@ mod test {\n             server_result_ch.send(actual_req);\n         };\n         comm::recv(cont_po);\n-        // client\n+        // this one should fail..\n+        let listen_err = run_tcp_test_server_fail(\n+                            server_ip,\n+                            server_port,\n+                            hl_loop);\n+        // client.. just doing this so that the first server tears down\n         log(debug, \"server started, firing up client..\");\n-        let actual_resp = do comm::listen |client_ch| {\n+        do comm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n                 expected_req,\n                 client_ch,\n                 hl_loop)\n         };\n+        alt listen_err {\n+          address_in_use {\n+            assert true;\n+          }\n+          _ {\n+            fail \"expected address_in_use listen error,\"+\n+                      \"but got a different error varient. check logs.\";\n+          }\n+        }\n+    }\n+    fn impl_gl_tcp_ipv4_server_access_denied() {\n+        let hl_loop = uv::global_loop::get();\n+        let server_ip = \"127.0.0.1\";\n+        let server_port = 80u;\n+        // this one should fail..\n+        let listen_err = run_tcp_test_server_fail(\n+                            server_ip,\n+                            server_port,\n+                            hl_loop);\n+        alt listen_err {\n+          access_denied {\n+            assert true;\n+          }\n+          _ {\n+            fail \"expected address_in_use listen error,\"+\n+                      \"but got a different error varient. check logs.\";\n+          }\n+        }\n+    }\n+    fn impl_gl_tcp_ipv4_server_client_reader_writer() {\n+        let iotask = uv::global_loop::get();\n+        let server_ip = \"127.0.0.1\";\n+        let server_port = 8891u;\n+        let expected_req = \"ping\";\n+        let expected_resp = \"pong\";\n+\n+        let server_result_po = comm::port::<str>();\n+        let server_result_ch = comm::chan(server_result_po);\n+\n+        let cont_po = comm::port::<()>();\n+        let cont_ch = comm::chan(cont_po);\n+        // server\n+        do task::spawn_sched(task::manual_threads(1u)) || {\n+            let actual_req = do comm::listen |server_ch| {\n+                run_tcp_test_server(\n+                    server_ip,\n+                    server_port,\n+                    expected_resp,\n+                    server_ch,\n+                    cont_ch,\n+                    iotask)\n+            };\n+            server_result_ch.send(actual_req);\n+        };\n+        comm::recv(cont_po);\n+        // client\n+        let server_addr = ip::v4::parse_addr(server_ip);\n+        let conn_result = connect(server_addr, server_port, iotask);\n+        if result::is_err(conn_result) {\n+            assert false;\n+        }\n+        let sock_buf = @socket_buf(result::unwrap(conn_result));\n+        buf_write(sock_buf as io::writer, expected_req);\n+\n+        // so contrived!\n+        let actual_resp = do str::as_bytes(expected_resp) |resp_buf| {\n+            buf_read(sock_buf as io::reader,\n+                     vec::len(resp_buf))\n+        };\n+\n         let actual_req = comm::recv(server_result_po);\n         log(debug, #fmt(\"REQ: expected: '%s' actual: '%s'\",\n                        expected_req, actual_req));\n@@ -1408,147 +1486,141 @@ mod test {\n         assert str::contains(actual_resp, expected_resp);\n     }\n \n+    fn buf_write(+w: io::writer, val: str) {\n+        log(debug, #fmt(\"BUF_WRITE: val len %?\", str::len(val)));\n+        do str::byte_slice(val) |b_slice| {\n+            log(debug, #fmt(\"BUF_WRITE: b_slice len %?\",\n+                            vec::len(b_slice)));\n+            w.write(b_slice)\n+        }\n+    }\n+\n+    fn buf_read(+r: io::reader, len: uint) -> str {\n+        let new_bytes = r.read_bytes(len);\n+        log(debug, #fmt(\"in buf_read.. new_bytes len: %?\",\n+                        vec::len(new_bytes)));\n+        str::from_bytes(new_bytes)\n+    }\n+\n     fn run_tcp_test_server(server_ip: str, server_port: uint, resp: str,\n                           server_ch: comm::chan<str>,\n                           cont_ch: comm::chan<()>,\n                           iotask: iotask) -> str {\n-\n-        do task::spawn_sched(task::manual_threads(1u)) || {\n-            let server_ip_addr = ip::v4::parse_addr(server_ip);\n-            let listen_result =\n-                listen_for_conn(server_ip_addr, server_port, 128u,\n-                iotask, |kill_ch| {\n-                    // on_establish_cb -- called when listener is set up\n-                    log(debug, #fmt(\"establish_cb %?\",\n-                        kill_ch));\n-                    comm::send(cont_ch, ());\n-                }, |new_conn, kill_ch| {\n-                // risky to run this on the loop, but some users\n-                // will want the POWER\n-                log(debug, \"SERVER: new connection!\");\n-                    do comm::listen |cont_ch| {\n-                        do task::spawn_sched(task::manual_threads(1u)) || {\n-                        log(debug, \"SERVER: starting worker for new req\");\n-\n-                        let accept_result = accept(new_conn);\n-                        log(debug, \"SERVER: after accept()\");\n-                        if result::is_err(accept_result) {\n-                            log(debug, \"SERVER: error accept connection\");\n-                            let err_data = result::get_err(accept_result);\n+        let server_ip_addr = ip::v4::parse_addr(server_ip);\n+        let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n+            // on_establish_cb -- called when listener is set up\n+            |kill_ch| {\n+                log(debug, #fmt(\"establish_cb %?\",\n+                    kill_ch));\n+                comm::send(cont_ch, ());\n+            },\n+            // risky to run this on the loop, but some users\n+            // will want the POWER\n+            |new_conn, kill_ch| {\n+            log(debug, \"SERVER: new connection!\");\n+            do comm::listen |cont_ch| {\n+                do task::spawn_sched(task::manual_threads(1u)) || {\n+                    log(debug, \"SERVER: starting worker for new req\");\n+\n+                    let accept_result = accept(new_conn);\n+                    log(debug, \"SERVER: after accept()\");\n+                    if result::is_err(accept_result) {\n+                        log(debug, \"SERVER: error accept connection\");\n+                        let err_data = result::get_err(accept_result);\n+                        comm::send(kill_ch, some(err_data));\n+                        log(debug,\n+                            \"SERVER/WORKER: send on err cont ch\");\n+                        cont_ch.send(());\n+                    }\n+                    else {\n+                        log(debug,\n+                            \"SERVER/WORKER: send on cont ch\");\n+                        cont_ch.send(());\n+                        let sock = result::unwrap(accept_result);\n+                        log(debug, \"SERVER: successfully accepted\"+\n+                            \"connection!\");\n+                        let received_req_bytes = read(sock, 0u);\n+                        alt received_req_bytes {\n+                          result::ok(data) {\n+                            log(debug, \"SERVER: got REQ str::from_bytes..\");\n+                            log(debug, #fmt(\"SERVER: REQ data len: %?\",\n+                                            vec::len(data)));\n+                            server_ch.send(\n+                                str::from_bytes(data));\n+                            log(debug, \"SERVER: before write\");\n+                            tcp_write_single(sock, str::bytes(resp));\n+                            log(debug, \"SERVER: after write.. die\");\n+                            comm::send(kill_ch, none);\n+                          }\n+                          result::err(err_data) {\n+                            log(debug, #fmt(\"SERVER: error recvd: %s %s\",\n+                                err_data.err_name, err_data.err_msg));\n                             comm::send(kill_ch, some(err_data));\n-                            log(debug,\n-                                \"SERVER/WORKER: send on err cont ch\");\n-                            cont_ch.send(());\n-                        }\n-                        else {\n-                            log(debug,\n-                                \"SERVER/WORKER: send on cont ch\");\n-                            cont_ch.send(());\n-                            let sock = result::unwrap(accept_result);\n-                            log(debug, \"SERVER: successfully accepted\"+\n-                                \"connection!\");\n-                            let received_req_bytes = sock.read(0u);\n-                            alt received_req_bytes {\n-                              result::ok(data) {\n-                                server_ch.send(\n-                                    str::from_bytes(data));\n-                                log(debug, \"SERVER: before write\");\n-                                tcp_write_single(sock, str::bytes(resp));\n-                                log(debug, \"SERVER: after write.. die\");\n-                                comm::send(kill_ch, none);\n-                              }\n-                              result::err(err_data) {\n-                                log(debug, #fmt(\"SERVER: error recvd: %s %s\",\n-                                    err_data.err_name, err_data.err_msg));\n-                                comm::send(kill_ch, some(err_data));\n-                                server_ch.send(\"\");\n-                              }\n-                            }\n-                            log(debug, \"SERVER: worker spinning down\");\n+                            server_ch.send(\"\");\n+                          }\n                         }\n+                        log(debug, \"SERVER: worker spinning down\");\n                     }\n-                    log(debug, \"SERVER: waiting to recv on cont_ch\");\n-                    cont_ch.recv()\n-                };\n-                log(debug, \"SERVER: recv'd on cont_ch..leaving listen cb\");\n-            });\n-            // err check on listen_result\n-            if result::is_err(listen_result) {\n-                let err_data = result::get_err(listen_result);\n-                log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n-                                err_data.err_name, err_data.err_msg));\n-            }\n-        };\n-        let ret_val = server_ch.recv();\n-        log(debug, #fmt(\"SERVER: exited and got ret val: '%s'\", ret_val));\n-        ret_val\n-    }\n-\n-    fn run_tcp_test_server_listener(server_ip: str,\n-                                    server_port: uint, resp: str,\n-                                    server_ch: comm::chan<str>,\n-                                    cont_ch: comm::chan<()>,\n-                                    iotask: iotask) -> str {\n-\n-        do task::spawn_sched(task::manual_threads(1u)) || {\n-            let server_ip_addr = ip::v4::parse_addr(server_ip);\n-            let new_listener_result =\n-                new_listener(server_ip_addr, server_port, 128u, iotask);\n-            if result::is_err(new_listener_result) {\n-                let err_data = result::get_err(new_listener_result);\n-                log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n-                                err_data.err_name, err_data.err_msg));\n-                fail \"couldn't set up new listener\";\n-            }\n-            let server_port = result::unwrap(new_listener_result);\n-            cont_ch.send(());\n-            // receive a single new connection.. normally this'd be\n-            // in a loop {}, but we're just going to take a single\n-            // client.. get their req, write a resp and then exit\n-            let new_conn_result = server_port.recv();\n-            if result::is_err(new_conn_result) {\n-                let err_data = result::get_err(new_conn_result);\n-                log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n-                                err_data.err_name, err_data.err_msg));\n-                fail \"couldn't recv new conn\";\n-            }\n-            let sock = result::unwrap(new_conn_result);\n-            log(debug, \"SERVER: successfully accepted\"+\n-                \"connection!\");\n-            let received_req_bytes =\n-                sock.read(0u);\n-            alt received_req_bytes {\n-              result::ok(data) {\n-                server_ch.send(\n-                    str::from_bytes(data));\n-                log(debug, \"SERVER: before write\");\n-                tcp_write_single(sock, str::bytes(resp));\n-                log(debug, \"SERVER: after write.. die\");\n+                }\n+                log(debug, \"SERVER: waiting to recv on cont_ch\");\n+                cont_ch.recv()\n+            };\n+            log(debug, \"SERVER: recv'd on cont_ch..leaving listen cb\");\n+        });\n+        // err check on listen_result\n+        if result::is_err(listen_result) {\n+            alt result::get_err(listen_result) {\n+              generic_listen_err(name, msg) {\n+                fail #fmt(\"SERVER: exited abnormally name %s msg %s\",\n+                                name, msg);\n               }\n-              result::err(err_data) {\n-                server_ch.send(\"\");\n+              access_denied {\n+                fail \"SERVER: exited abnormally, got access denied..\";\n+              }\n+              address_in_use {\n+                fail \"SERVER: exited abnormally, got address in use...\";\n               }\n             }\n-        };\n+        }\n         let ret_val = server_ch.recv();\n         log(debug, #fmt(\"SERVER: exited and got ret val: '%s'\", ret_val));\n         ret_val\n     }\n \n+    fn run_tcp_test_server_fail(server_ip: str, server_port: uint,\n+                          iotask: iotask) -> tcp_listen_err_data {\n+        let server_ip_addr = ip::v4::parse_addr(server_ip);\n+        let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n+            // on_establish_cb -- called when listener is set up\n+            |kill_ch| {\n+                log(debug, #fmt(\"establish_cb %?\",\n+                    kill_ch));\n+            },\n+            |new_conn, kill_ch| {\n+                fail #fmt(\"SERVER: shouldn't be called.. %? %?\",\n+                           new_conn, kill_ch);\n+        });\n+        // err check on listen_result\n+        if result::is_err(listen_result) {\n+            result::get_err(listen_result)\n+        }\n+        else {\n+            fail \"SERVER: did not fail as expected\"\n+        }\n+    }\n+\n     fn run_tcp_test_client(server_ip: str, server_port: uint, resp: str,\n                           client_ch: comm::chan<str>,\n-                          iotask: iotask) -> str {\n-\n+                          iotask: iotask) -> result::result<str,\n+                                                    tcp_connect_err_data> {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n \n         log(debug, \"CLIENT: starting..\");\n         let connect_result = connect(server_ip_addr, server_port, iotask);\n         if result::is_err(connect_result) {\n             log(debug, \"CLIENT: failed to connect\");\n             let err_data = result::get_err(connect_result);\n-            log(debug, #fmt(\"CLIENT: connect err name: %s msg: %s\",\n-                            err_data.err_name, err_data.err_msg));\n-            \"\"\n+            err(err_data)\n         }\n         else {\n             let sock = result::unwrap(connect_result);\n@@ -1557,14 +1629,14 @@ mod test {\n             let read_result = sock.read(0u);\n             if read_result.is_err() {\n                 log(debug, \"CLIENT: failure to read\");\n-                \"\"\n+                ok(\"\")\n             }\n             else {\n                 client_ch.send(str::from_bytes(read_result.get()));\n                 let ret_val = client_ch.recv();\n                 log(debug, #fmt(\"CLIENT: after client_ch recv ret: '%s'\",\n                    ret_val));\n-                ret_val\n+                ok(ret_val)\n             }\n         }\n     }"}, {"sha": "3470727121755be63d29cd5ee4dfe9747ca382d4", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea8922b8ab8ce7f820869778950346a749ed757/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2ea8922b8ab8ce7f820869778950346a749ed757/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=2ea8922b8ab8ce7f820869778950346a749ed757", "patch": "@@ -15,7 +15,7 @@\n use core(vers = \"0.2\");\n import core::*;\n \n-export net, net_tcp;\n+export net, net_tcp, net_ip;\n export uv, uv_ll, uv_iotask, uv_global_loop;\n export c_vec, util, timer;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap;"}, {"sha": "ff3ed3b9a6bdabc53ac0612259633d7392e779a1", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 274, "deletions": 10, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/2ea8922b8ab8ce7f820869778950346a749ed757/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea8922b8ab8ce7f820869778950346a749ed757/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=2ea8922b8ab8ce7f820869778950346a749ed757", "patch": "@@ -223,10 +223,82 @@ type sockaddr_in = {\n     mut sin_zero: (u8, u8, u8, u8, u8, u8, u8, u8)\n };\n \n-// unix size: 28 .. make due w/ 32\n+// unix size: 28 .. FIXME #1645\n+// stuck with 32 becuse of rust padding structs?\n+#[cfg(target_arch=\"x86_64\")]\n+type sockaddr_in6 = {\n+    a0: *u8, a1: *u8,\n+    a2: *u8, a3: *u8\n+};\n+#[cfg(target_arch=\"x86\")]\n type sockaddr_in6 = {\n     a0: *u8, a1: *u8,\n-    a2: *u8, a3: (u8, u8, u8, u8)\n+    a2: *u8, a3: *u8,\n+    a4: *u8, a5: *u8,\n+    a6: *u8, a7: *u8\n+};\n+\n+// unix size: 28 .. FIXME #1645\n+// stuck with 32 becuse of rust padding structs?\n+type addr_in = addr_in_impl::addr_in;\n+#[cfg(unix)]\n+mod addr_in_impl {\n+    #[cfg(target_arch=\"x86_64\")]\n+    type addr_in = {\n+        a0: *u8, a1: *u8,\n+        a2: *u8, a3: *u8\n+    };\n+    #[cfg(target_arch=\"x86\")]\n+    type addr_in = {\n+        a0: *u8, a1: *u8,\n+        a2: *u8, a3: *u8,\n+        a4: *u8, a5: *u8,\n+        a6: *u8, a7: *u8,\n+    };\n+}\n+#[cfg(windows)]\n+mod addr_in_impl {\n+    type addr_in = {\n+        a0: *u8, a1: *u8,\n+        a2: *u8, a3: *u8\n+    };\n+}\n+\n+// unix size: 48, 32bit: 32\n+type addrinfo = addrinfo_impl::addrinfo;\n+#[cfg(target_os=\"linux\")]\n+mod addrinfo_impl {\n+    #[cfg(target_arch=\"x86_64\")]\n+    type addrinfo = {\n+        a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+        a04: *u8, a05: *u8\n+    };\n+    #[cfg(target_arch=\"x86\")]\n+    type addrinfo = {\n+        a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+        a04: *u8, a05: *u8, a06: *u8, a07: *u8\n+    };\n+}\n+#[cfg(target_os=\"macos\")]\n+#[cfg(target_os=\"freebsd\")]\n+mod addrinfo_impl {\n+    type addrinfo = {\n+        a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+        a04: *u8, a05: *u8\n+    };\n+}\n+#[cfg(windows)]\n+mod addrinfo_impl {\n+    type addrinfo = {\n+        a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+        a04: *u8, a05: *u8\n+    };\n+}\n+\n+// unix size: 72\n+type uv_getaddrinfo_t = {\n+    a00: *u8, a01: *u8, a02: *u8, a03: *u8, a04: *u8, a05: *u8,\n+    a06: *u8, a07: *u8, a08: *u8\n };\n \n mod uv_ll_struct_stubgen {\n@@ -474,10 +546,18 @@ mod uv_ll_struct_stubgen {\n             a12: 0 as *u8\n         };\n     }\n+    fn gen_stub_uv_getaddrinfo_t() -> uv_getaddrinfo_t {\n+        {\n+            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n+            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n+            a08: 0 as *u8\n+        }\n+    }\n }\n \n #[nolink]\n native mod rustrt {\n+    // libuv public API\n     fn rust_uv_loop_new() -> *libc::c_void;\n     fn rust_uv_loop_delete(lp: *libc::c_void);\n     fn rust_uv_loop_refcount(loop_ptr: *libc::c_void) -> libc::c_int;\n@@ -500,6 +580,12 @@ native mod rustrt {\n     fn rust_uv_err_name(err: *uv_err_t) -> *libc::c_char;\n     fn rust_uv_ip4_addr(ip: *u8, port: libc::c_int)\n         -> sockaddr_in;\n+    fn rust_uv_ip6_addr(ip: *u8, port: libc::c_int)\n+        -> sockaddr_in6;\n+    fn rust_uv_ip4_name(src: *sockaddr_in, dst: *u8, size: libc::size_t)\n+        -> libc::c_int;\n+    fn rust_uv_ip6_name(src: *sockaddr_in6, dst: *u8, size: libc::size_t)\n+        -> libc::c_int;\n     // FIXME ref #2064\n     fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n                            tcp_handle_ptr: *uv_tcp_t,\n@@ -508,6 +594,14 @@ native mod rustrt {\n     // FIXME ref #2064\n     fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t,\n                         ++addr: *sockaddr_in) -> libc::c_int;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t,\n+                           tcp_handle_ptr: *uv_tcp_t,\n+                           ++after_cb: *u8,\n+                           ++addr: *sockaddr_in6) -> libc::c_int;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t,\n+                        ++addr: *sockaddr_in6) -> libc::c_int;\n     fn rust_uv_listen(stream: *libc::c_void, backlog: libc::c_int,\n                       cb: *u8) -> libc::c_int;\n     fn rust_uv_accept(server: *libc::c_void, client: *libc::c_void)\n@@ -527,7 +621,22 @@ native mod rustrt {\n         repeat: libc::c_uint) -> libc::c_int;\n     fn rust_uv_timer_stop(handle: *uv_timer_t) -> libc::c_int;\n \n+    fn rust_uv_getaddrinfo(loop_ptr: *libc::c_void,\n+                           handle: *uv_getaddrinfo_t,\n+                           cb: *u8,\n+                           node_name_ptr: *u8,\n+                           service_name_ptr: *u8,\n+                           // should probably only pass ptr::null()\n+                           hints: *addrinfo) -> libc::c_int;\n+    fn rust_uv_freeaddrinfo(res: *addrinfo);\n+\n     // data accessors/helpers for rust-mapped uv structs\n+    fn rust_uv_helper_get_INADDR_NONE() -> u32;\n+    fn rust_uv_is_ipv4_addrinfo(input: *addrinfo) -> bool;\n+    fn rust_uv_is_ipv6_addrinfo(input: *addrinfo) -> bool;\n+    fn rust_uv_get_next_addrinfo(input: *addrinfo) -> *addrinfo;\n+    fn rust_uv_addrinfo_as_sockaddr_in(input: *addrinfo) -> *sockaddr_in;\n+    fn rust_uv_addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6;\n     fn rust_uv_malloc_buf_base_of(sug_size: libc::size_t) -> *u8;\n     fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n     fn rust_uv_get_stream_handle_from_connect_req(\n@@ -558,8 +667,12 @@ native mod rustrt {\n     fn rust_uv_helper_uv_write_t_size() -> libc::c_uint;\n     fn rust_uv_helper_uv_err_t_size() -> libc::c_uint;\n     fn rust_uv_helper_sockaddr_in_size() -> libc::c_uint;\n+    fn rust_uv_helper_sockaddr_in6_size() -> libc::c_uint;\n     fn rust_uv_helper_uv_async_t_size() -> libc::c_uint;\n     fn rust_uv_helper_uv_timer_t_size() -> libc::c_uint;\n+    fn rust_uv_helper_uv_getaddrinfo_t_size() -> libc::c_uint;\n+    fn rust_uv_helper_addrinfo_size() -> libc::c_uint;\n+    fn rust_uv_helper_addr_in_size() -> libc::c_uint;\n }\n \n unsafe fn loop_new() -> *libc::c_void {\n@@ -598,11 +711,26 @@ unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n                                     after_connect_cb, addr_ptr);\n }\n // FIXME ref #2064\n+unsafe fn tcp_connect6(connect_ptr: *uv_connect_t,\n+                      tcp_handle_ptr: *uv_tcp_t,\n+                      addr_ptr: *sockaddr_in6,\n+                      ++after_connect_cb: *u8)\n+-> libc::c_int {\n+    ret rustrt::rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr,\n+                                    after_connect_cb, addr_ptr);\n+}\n+// FIXME ref #2064\n unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t,\n                    addr_ptr: *sockaddr_in) -> libc::c_int {\n     ret rustrt::rust_uv_tcp_bind(tcp_server_ptr,\n                                  addr_ptr);\n }\n+// FIXME ref #2064\n+unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t,\n+                   addr_ptr: *sockaddr_in6) -> libc::c_int {\n+    ret rustrt::rust_uv_tcp_bind6(tcp_server_ptr,\n+                                 addr_ptr);\n+}\n \n unsafe fn listen<T>(stream: *T, backlog: libc::c_int,\n                  cb: *u8) -> libc::c_int {\n@@ -677,14 +805,59 @@ unsafe fn buf_init(++input: *u8, len: uint) -> uv_buf_t {\n }\n unsafe fn ip4_addr(ip: str, port: int)\n -> sockaddr_in {\n-    let mut addr_vec = str::bytes(ip);\n-    vec::push(addr_vec, 0u8); // add null terminator\n-    let addr_vec_ptr = vec::unsafe::to_ptr(addr_vec);\n-    let ip_back = str::from_bytes(addr_vec);\n-    log(debug, #fmt(\"vec val: '%s' length: %u\",\n-                     ip_back, vec::len(addr_vec)));\n-    ret rustrt::rust_uv_ip4_addr(addr_vec_ptr,\n-                                 port as libc::c_int);\n+    do str::as_c_str(ip) |ip_buf| {\n+        rustrt::rust_uv_ip4_addr(ip_buf as *u8,\n+                                 port as libc::c_int)\n+    }\n+}\n+unsafe fn ip6_addr(ip: str, port: int)\n+-> sockaddr_in6 {\n+    do str::as_c_str(ip) |ip_buf| {\n+        rustrt::rust_uv_ip6_addr(ip_buf as *u8,\n+                                 port as libc::c_int)\n+    }\n+}\n+unsafe fn ip4_name(src: &sockaddr_in) -> str {\n+    // ipv4 addr max size: 15 + 1 trailing null byte\n+    let dst: [u8]/~ = [0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n+                     0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8]/~;\n+    let size = 16 as libc::size_t;\n+    do vec::as_buf(dst) |dst_buf| {\n+        rustrt::rust_uv_ip4_name(src as *sockaddr_in,\n+                                              dst_buf, size);\n+        // seems that checking the result of uv_ip4_name\n+        // doesn't work too well..\n+        // you're stuck looking at the value of dst_buf\n+        // to see if it is the string representation of\n+        // INADDR_NONE (0xffffffff or 255.255.255.255 on\n+        // many platforms)\n+        str::unsafe::from_buf(dst_buf)\n+    }\n+}\n+unsafe fn ip6_name(src: &sockaddr_in6) -> str {\n+    // ipv6 addr max size: 45 + 1 trailing null byte\n+    let dst: [u8]/~ = [0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n+                       0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n+                       0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n+                       0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n+                       0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n+                       0u8,0u8,0u8,0u8,0u8,0u8]/~;\n+    let size = 46 as libc::size_t;\n+    do vec::as_buf(dst) |dst_buf| {\n+        let src_unsafe_ptr = src as *sockaddr_in6;\n+        log(debug, #fmt(\"val of src *sockaddr_in6: %? sockaddr_in6: %?\",\n+                        src_unsafe_ptr, src));\n+        let result = rustrt::rust_uv_ip6_name(src_unsafe_ptr,\n+                                              dst_buf, size);\n+        alt result {\n+          0i32 {\n+            str::unsafe::from_buf(dst_buf)\n+          }\n+          _ {\n+            \"\"\n+          }\n+        }\n+    }\n }\n \n unsafe fn timer_init(loop_ptr: *libc::c_void,\n@@ -699,6 +872,22 @@ unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: uint,\n unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> libc::c_int {\n     ret rustrt::rust_uv_timer_stop(timer_ptr);\n }\n+unsafe fn getaddrinfo(loop_ptr: *libc::c_void,\n+                           handle: *uv_getaddrinfo_t,\n+                           cb: *u8,\n+                           node_name_ptr: *u8,\n+                           service_name_ptr: *u8,\n+                           hints: *addrinfo) -> libc::c_int {\n+    rustrt::rust_uv_getaddrinfo(loop_ptr,\n+                           handle,\n+                           cb,\n+                           node_name_ptr,\n+                           service_name_ptr,\n+                           hints)\n+}\n+unsafe fn freeaddrinfo(res: *addrinfo) {\n+    rustrt::rust_uv_freeaddrinfo(res);\n+}\n \n // libuv struct initializers\n unsafe fn tcp_t() -> uv_tcp_t {\n@@ -716,6 +905,9 @@ unsafe fn async_t() -> uv_async_t {\n unsafe fn timer_t() -> uv_timer_t {\n     ret uv_ll_struct_stubgen::gen_stub_uv_timer_t();\n }\n+unsafe fn getaddrinfo_t() -> uv_getaddrinfo_t {\n+    ret uv_ll_struct_stubgen::gen_stub_uv_getaddrinfo_t();\n+}\n \n // data access helpers\n unsafe fn get_loop_for_uv_handle<T>(handle: *T)\n@@ -791,6 +983,25 @@ type uv_err_data = {\n     err_msg: str\n };\n \n+unsafe fn is_ipv4_addrinfo(input: *addrinfo) -> bool {\n+    rustrt::rust_uv_is_ipv4_addrinfo(input)\n+}\n+unsafe fn is_ipv6_addrinfo(input: *addrinfo) -> bool {\n+    rustrt::rust_uv_is_ipv6_addrinfo(input)\n+}\n+unsafe fn get_INADDR_NONE() -> u32 {\n+    rustrt::rust_uv_helper_get_INADDR_NONE()\n+}\n+unsafe fn get_next_addrinfo(input: *addrinfo) -> *addrinfo {\n+    rustrt::rust_uv_get_next_addrinfo(input)\n+}\n+unsafe fn addrinfo_as_sockaddr_in(input: *addrinfo) -> *sockaddr_in {\n+    rustrt::rust_uv_addrinfo_as_sockaddr_in(input)\n+}\n+unsafe fn addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6 {\n+    rustrt::rust_uv_addrinfo_as_sockaddr_in6(input)\n+}\n+\n #[cfg(test)]\n mod test {\n     enum tcp_read_data {\n@@ -1366,6 +1577,33 @@ mod test {\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_ll_struct_size_sockaddr_in6() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_sockaddr_in6_size();\n+        let rust_handle_size = sys::size_of::<sockaddr_in6>();\n+        let output = #fmt(\"sockaddr_in6 -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        // FIXME #1645 .. rust appears to pad structs to the nearest byte..?\n+        // .. can't get the uv::ll::sockaddr_in6 to == 28 :/\n+        // .. so the type always appears to be 32 in size.. which is\n+        // good, i guess.. better too big than too little\n+        assert (4u+native_handle_size as uint) == rust_handle_size;\n+    }\n+    #[test]\n+    #[ignore(reason = \"questionable size calculations\")]\n+    fn test_uv_ll_struct_size_addr_in() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_addr_in_size();\n+        let rust_handle_size = sys::size_of::<addr_in>();\n+        let output = #fmt(\"addr_in -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        // FIXME #1645 .. see note above about struct padding\n+        assert (4u+native_handle_size as uint) == rust_handle_size;\n+    }\n \n     #[test]\n     #[ignore(cfg(target_os = \"freebsd\"))]\n@@ -1390,4 +1628,30 @@ mod test {\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n+\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn test_uv_ll_struct_size_uv_getaddrinfo_t() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_uv_getaddrinfo_t_size();\n+        let rust_handle_size = sys::size_of::<uv_getaddrinfo_t>();\n+        let output = #fmt(\"uv_getaddrinfo_t -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    #[ignore(cfg(target_os = \"macos\"))]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn test_uv_ll_struct_size_addrinfo() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_addrinfo_size();\n+        let rust_handle_size = sys::size_of::<addrinfo>();\n+        let output = #fmt(\"addrinfo -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n }"}, {"sha": "706e8ff43807fca67d77e1c79bbbac6116d33711", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 87, "deletions": 16, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/2ea8922b8ab8ce7f820869778950346a749ed757/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2ea8922b8ab8ce7f820869778950346a749ed757/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=2ea8922b8ab8ce7f820869778950346a749ed757", "patch": "@@ -238,32 +238,36 @@ rust_uv_tcp_connect(uv_connect_t* connect_ptr,\n         uv_tcp_t* tcp_ptr,\n         uv_connect_cb cb,\n         sockaddr_in* addr_ptr) {\n-    rust_task* task = rust_get_current_task();\n-    LOG(task, stdlib, \"inside rust_uv_tcp_connect\");\n     // FIXME ref #2064\n     sockaddr_in addr = *addr_ptr;\n-    LOG(task, stdlib, \"before tcp_connect .. port: %d\",\n-        addr.sin_port);\n-    LOG(task, stdlib, \"before tcp_connect.. tcp stream:\" \\\n-        \"%lu cb ptr: %lu\",\n-        (unsigned long int)tcp_ptr, (unsigned long int)cb);\n     int result = uv_tcp_connect(connect_ptr, tcp_ptr, addr, cb);\n-    LOG(task, stdlib, \"leaving rust_uv_tcp_connect..\" \\\n-        \"and result: %d\",\n-            result);\n     return result;\n }\n \n extern \"C\" int\n rust_uv_tcp_bind(uv_tcp_t* tcp_server, sockaddr_in* addr_ptr) {\n     // FIXME ref #2064\n-    rust_task* task = rust_get_current_task();\n     sockaddr_in addr = *addr_ptr;\n-    LOG(task, stdlib, \"before uv_tcp_bind .. tcp_server:\" \\\n-        \"%lu port: %d\",\n-            (unsigned long int)tcp_server, addr.sin_port);\n     return uv_tcp_bind(tcp_server, addr);\n }\n+extern \"C\" int\n+rust_uv_tcp_connect6(uv_connect_t* connect_ptr,\n+        uv_tcp_t* tcp_ptr,\n+        uv_connect_cb cb,\n+        sockaddr_in6* addr_ptr) {\n+    // FIXME ref #2064\n+    sockaddr_in6 addr = *addr_ptr;\n+    int result = uv_tcp_connect6(connect_ptr, tcp_ptr, addr, cb);\n+    return result;\n+}\n+\n+extern \"C\" int\n+rust_uv_tcp_bind6\n+(uv_tcp_t* tcp_server, sockaddr_in6* addr_ptr) {\n+    // FIXME ref #2064\n+    sockaddr_in6 addr = *addr_ptr;\n+    return uv_tcp_bind6(tcp_server, addr);\n+}\n \n extern \"C\" int\n rust_uv_listen(uv_stream_t* stream, int backlog,\n@@ -301,14 +305,33 @@ rust_uv_helper_sockaddr_in_size() {\n     return sizeof(sockaddr_in);\n }\n extern \"C\" size_t\n+rust_uv_helper_sockaddr_in6_size() {\n+    return sizeof(sockaddr_in6);\n+}\n+extern \"C\" size_t\n rust_uv_helper_uv_async_t_size() {\n     return sizeof(uv_async_t);\n }\n extern \"C\" size_t\n rust_uv_helper_uv_timer_t_size() {\n     return sizeof(uv_timer_t);\n }\n-\n+extern \"C\" size_t\n+rust_uv_helper_addr_in_size() {\n+    return sizeof(sockaddr_in6);\n+}\n+extern \"C\" size_t\n+rust_uv_helper_uv_getaddrinfo_t_size() {\n+    return sizeof(uv_getaddrinfo_t);\n+}\n+extern \"C\" size_t\n+rust_uv_helper_addrinfo_size() {\n+    return sizeof(addrinfo);\n+}\n+extern \"C\" unsigned int\n+rust_uv_helper_get_INADDR_NONE() {\n+    return INADDR_NONE;\n+}\n extern \"C\" uv_stream_t*\n rust_uv_get_stream_handle_from_connect_req(uv_connect_t* connect) {\n     return connect->handle;\n@@ -436,11 +459,27 @@ extern \"C\" struct sockaddr_in\n rust_uv_ip4_addr(const char* ip, int port) {\n     rust_task* task = rust_get_current_task();\n     LOG(task, stdlib, \"before creating addr_ptr.. ip %s\" \\\n-        \"port %d\", ip, port);\n+        \" port %d\\n\", ip, port);\n     struct sockaddr_in addr = uv_ip4_addr(ip, port);\n     LOG(task, stdlib, \"after creating .. port: %d\", addr.sin_port);\n     return addr;\n }\n+extern \"C\" struct sockaddr_in6\n+rust_uv_ip6_addr(const char* ip, int port) {\n+    rust_task* task = rust_get_current_task();\n+    LOG(task, stdlib, \"before creating addr_ptr.. ip %s\" \\\n+        \" port %d\\n\", ip, port);\n+    return uv_ip6_addr(ip, port);\n+}\n+extern \"C\" int\n+rust_uv_ip4_name(struct sockaddr_in* src, char* dst, size_t size) {\n+    return uv_ip4_name(src, dst, size);\n+}\n+extern \"C\" int\n+rust_uv_ip6_name(struct sockaddr_in6* src, char* dst, size_t size) {\n+    int result = uv_ip6_name(src, dst, size);\n+    return result;\n+}\n \n extern \"C\" uintptr_t*\n rust_uv_get_kernel_global_chan_ptr() {\n@@ -460,3 +499,35 @@ extern \"C\" void\n rust_uv_current_kernel_free(void* mem) {\n     current_kernel_free(mem);\n }\n+\n+extern  \"C\" int\n+rust_uv_getaddrinfo(uv_loop_t* loop, uv_getaddrinfo_t* handle,\n+                    uv_getaddrinfo_cb cb,\n+                    char* node, char* service,\n+                    addrinfo* hints) {\n+    return uv_getaddrinfo(loop, handle, cb, node, service, hints);\n+}\n+extern \"C\" void\n+rust_uv_freeaddrinfo(addrinfo* res) {\n+    uv_freeaddrinfo(res);\n+}\n+extern \"C\" bool\n+rust_uv_is_ipv4_addrinfo(addrinfo* input) {\n+    return input->ai_family == AF_INET;\n+}\n+extern \"C\" bool\n+rust_uv_is_ipv6_addrinfo(addrinfo* input) {\n+    return input->ai_family == AF_INET6;\n+}\n+extern \"C\" addrinfo*\n+rust_uv_get_next_addrinfo(addrinfo* input) {\n+    return input->ai_next;\n+}\n+extern \"C\" sockaddr_in*\n+rust_uv_addrinfo_as_sockaddr_in(addrinfo* input) {\n+    return (sockaddr_in*)input->ai_addr;\n+}\n+extern \"C\" sockaddr_in6*\n+rust_uv_addrinfo_as_sockaddr_in6(addrinfo* input) {\n+    return (sockaddr_in6*)input->ai_addr;\n+}"}, {"sha": "a218782dcbe63c096e47b06ddbb28322c0260bb2", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2ea8922b8ab8ce7f820869778950346a749ed757/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/2ea8922b8ab8ce7f820869778950346a749ed757/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=2ea8922b8ab8ce7f820869778950346a749ed757", "patch": "@@ -111,21 +111,36 @@ rust_uv_last_error\n rust_uv_strerror\n rust_uv_err_name\n rust_uv_ip4_addr\n+rust_uv_ip4_name\n+rust_uv_ip6_addr\n+rust_uv_ip6_name\n rust_uv_tcp_connect\n rust_uv_tcp_bind\n+rust_uv_tcp_connect6\n+rust_uv_tcp_bind6\n rust_uv_listen\n rust_uv_accept\n rust_uv_write\n rust_uv_read_start\n rust_uv_read_stop\n rust_uv_malloc_buf_base_of\n rust_uv_free_base_of_buf\n+rust_uv_is_ipv4_addrinfo\n+rust_uv_is_ipv6_addrinfo\n+rust_uv_get_next_addrinfo\n+rust_uv_addrinfo_as_sockaddr_in\n+rust_uv_addrinfo_as_sockaddr_in6\n rust_uv_helper_uv_tcp_t_size\n rust_uv_helper_uv_connect_t_size\n rust_uv_helper_uv_buf_t_size\n rust_uv_helper_uv_write_t_size\n rust_uv_helper_uv_err_t_size\n rust_uv_helper_sockaddr_in_size\n+rust_uv_helper_sockaddr_in6_size\n+rust_uv_helper_addr_in_size\n+rust_uv_helper_addrinfo_size\n+rust_uv_helper_uv_getaddrinfo_t_size\n+rust_uv_helper_get_INADDR_NONE\n rust_uv_helper_uv_async_t_size\n rust_uv_helper_uv_timer_t_size\n rust_uv_get_stream_handle_from_connect_req\n@@ -142,6 +157,8 @@ rust_uv_get_len_from_buf\n rust_uv_get_kernel_global_chan_ptr\n rust_uv_current_kernel_malloc\n rust_uv_current_kernel_free\n+rust_uv_getaddrinfo\n+rust_uv_freeaddrinfo\n rust_dbg_lock_create\n rust_dbg_lock_destroy\n rust_dbg_lock_lock"}]}