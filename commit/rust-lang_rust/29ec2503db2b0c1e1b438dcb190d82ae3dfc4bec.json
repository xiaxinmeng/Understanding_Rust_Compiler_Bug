{"sha": "29ec2503db2b0c1e1b438dcb190d82ae3dfc4bec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ZWMyNTAzZGIyYjBjMWUxYjQzOGRjYjE5MGQ4MmFlM2RmYzRiZWM=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-03T22:39:43Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-04T02:49:29Z"}, "message": "Put comments on trans contexts back where they belong.  :(", "tree": {"sha": "80e524f31937e37ea298bd6b0f93316bd2a4e78f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80e524f31937e37ea298bd6b0f93316bd2a4e78f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29ec2503db2b0c1e1b438dcb190d82ae3dfc4bec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29ec2503db2b0c1e1b438dcb190d82ae3dfc4bec", "html_url": "https://github.com/rust-lang/rust/commit/29ec2503db2b0c1e1b438dcb190d82ae3dfc4bec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29ec2503db2b0c1e1b438dcb190d82ae3dfc4bec/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "316bf01e26d3fbe46dfabcd346d388ec45926a01", "url": "https://api.github.com/repos/rust-lang/rust/commits/316bf01e26d3fbe46dfabcd346d388ec45926a01", "html_url": "https://github.com/rust-lang/rust/commit/316bf01e26d3fbe46dfabcd346d388ec45926a01"}], "stats": {"total": 222, "additions": 114, "deletions": 108}, "files": [{"sha": "097be3357fcbe3dedd2eb142c6710ba536a12450", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 114, "deletions": 108, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/29ec2503db2b0c1e1b438dcb190d82ae3dfc4bec/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ec2503db2b0c1e1b438dcb190d82ae3dfc4bec/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=29ec2503db2b0c1e1b438dcb190d82ae3dfc4bec", "patch": "@@ -103,44 +103,44 @@ type stats =\n      fn_times: @mutable {ident: str, time: int}[]};\n \n // Crate context.  Every crate we compile has one of these.\n-type crate_ctxt =\n+type crate_ctxt = {\n+    sess: session::session,\n+    llmod: ModuleRef,\n+    td: target_data,\n+    tn: type_names,\n+    externs: hashmap[str, ValueRef],\n+    intrinsics: hashmap[str, ValueRef],\n \n     // A mapping from the def_id of each item in this crate to the address\n     // of the first instruction of the item's definition in the executable\n     // we're generating.\n-\n+    item_ids: hashmap[ast::node_id, ValueRef],\n+    ast_map: ast_map::map,\n+    item_symbols: hashmap[ast::node_id, str],\n+    mutable main_fn: option::t[ValueRef],\n+    link_meta: link::link_meta,\n     // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n-    {sess: session::session,\n-     llmod: ModuleRef,\n-     td: target_data,\n-     tn: type_names,\n-     externs: hashmap[str, ValueRef],\n-     intrinsics: hashmap[str, ValueRef],\n-     item_ids: hashmap[ast::node_id, ValueRef],\n-     ast_map: ast_map::map,\n-     item_symbols: hashmap[ast::node_id, str],\n-     mutable main_fn: option::t[ValueRef],\n-     link_meta: link::link_meta,\n-     tag_sizes: hashmap[ty::t, uint],\n-     discrims: hashmap[ast::node_id, ValueRef],\n-     discrim_symbols: hashmap[ast::node_id, str],\n-     fn_pairs: hashmap[ast::node_id, ValueRef],\n-     consts: hashmap[ast::node_id, ValueRef],\n-     obj_methods: hashmap[ast::node_id, ()],\n-     tydescs: hashmap[ty::t, @tydesc_info],\n-     module_data: hashmap[str, ValueRef],\n-     lltypes: hashmap[ty::t, TypeRef],\n-     glues: @glue_fns,\n-     names: namegen,\n-     sha: std::sha1::sha1,\n-     type_sha1s: hashmap[ty::t, str],\n-     type_short_names: hashmap[ty::t, str],\n-     tcx: ty::ctxt,\n-     stats: stats,\n-     upcalls: @upcall::upcalls,\n-     rust_object_type: TypeRef,\n-     tydesc_type: TypeRef,\n-     task_type: TypeRef};\n+    tag_sizes: hashmap[ty::t, uint],\n+    discrims: hashmap[ast::node_id, ValueRef],\n+    discrim_symbols: hashmap[ast::node_id, str],\n+    fn_pairs: hashmap[ast::node_id, ValueRef],\n+    consts: hashmap[ast::node_id, ValueRef],\n+    obj_methods: hashmap[ast::node_id, ()],\n+    tydescs: hashmap[ty::t, @tydesc_info],\n+    module_data: hashmap[str, ValueRef],\n+    lltypes: hashmap[ty::t, TypeRef],\n+    glues: @glue_fns,\n+    names: namegen,\n+    sha: std::sha1::sha1,\n+    type_sha1s: hashmap[ty::t, str],\n+    type_short_names: hashmap[ty::t, str],\n+    tcx: ty::ctxt,\n+    stats: stats,\n+    upcalls: @upcall::upcalls,\n+    rust_object_type: TypeRef,\n+    tydesc_type: TypeRef,\n+    task_type: TypeRef\n+};\n \n type local_ctxt =\n     {path: str[],\n@@ -152,123 +152,127 @@ type local_ctxt =\n // Types used for llself.\n type val_self_pair = {v: ValueRef, t: ty::t};\n \n-// Function context.  Every LLVM function we create will have one of these.\n-type fn_ctxt =\n+// Function context.  Every LLVM function we create will have one of\n+// these.\n+type fn_ctxt = {\n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n-    // address of the first instruction in the sequence of instructions\n-    // for this function that will go in the .text section of the\n-    // executable we're generating.\n+    // address of the first instruction in the sequence of\n+    // instructions for this function that will go in the .text\n+    // section of the executable we're generating.\n+    llfn: ValueRef,\n \n     // The three implicit arguments that arrive in the function we're\n-    // creating.  For instance, foo(int, int) is really foo(ret*, task*,\n-    // env*, int, int).  These are also available via\n-    // llvm::LLVMGetParam(llfn, uint) where uint = 1, 2, 0 respectively,\n-    // but we unpack them into these fields for convenience.\n+    // creating.  For instance, foo(int, int) is really foo(ret*,\n+    // task*, env*, int, int).  These are also available via\n+    // llvm::LLVMGetParam(llfn, uint) where uint = 1, 2, 0\n+    // respectively, but we unpack them into these fields for\n+    // convenience.\n \n     // Points to the current task.\n+    lltaskptr: ValueRef,\n \n     // Points to the current environment (bindings of variables to\n     // values), if this is a regular function; points to the current\n     // object, if this is a method.\n+    llenv: ValueRef,\n \n-    // Points to where the return value of this function should end up.\n+    // Points to where the return value of this function should end\n+    // up.\n+    llretptr: ValueRef,\n \n     // The next three elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in\n     // the function, due to LLVM's quirks.\n \n-    // A block for all the function's static allocas, so that LLVM will\n-    // coalesce them into a single alloca call.\n+    // A block for all the function's static allocas, so that LLVM\n+    // will coalesce them into a single alloca call.\n+    mutable llstaticallocas: BasicBlockRef,\n \n     // A block containing code that copies incoming arguments to space\n-    // already allocated by code in one of the llallocas blocks.  (LLVM\n-    // requires that arguments be copied to local allocas before allowing\n-    // most any operation to be performed on them.)\n+    // already allocated by code in one of the llallocas blocks.\n+    // (LLVM requires that arguments be copied to local allocas before\n+    // allowing most any operation to be performed on them.)\n+    mutable llcopyargs: BasicBlockRef,\n \n     // The first block containing derived tydescs received from the\n     // runtime.  See description of derived_tydescs, below.\n+    mutable llderivedtydescs_first: BasicBlockRef,\n \n     // The last block of the llderivedtydescs group.\n+    mutable llderivedtydescs: BasicBlockRef,\n \n     // A block for all of the dynamically sized allocas.  This must be\n     // after llderivedtydescs, because these sometimes depend on\n     // information computed from derived tydescs.\n \n-    // FIXME: Is llcopyargs actually the block containing the allocas for\n-    // incoming function arguments?  Or is it merely the block containing\n-    // code that copies incoming args to space already alloca'd by code in\n-    // llallocas?\n+    // FIXME: Is llcopyargs actually the block containing the allocas\n+    // for incoming function arguments?  Or is it merely the block\n+    // containing code that copies incoming args to space already\n+    // alloca'd by code in llallocas?\n+    mutable lldynamicallocas: BasicBlockRef,\n \n-    // The 'self' object currently in use in this function, if there is\n-    // one.\n+    // The 'self' object currently in use in this function, if there\n+    // is one.\n+    mutable llself: option::t[val_self_pair],\n \n-    // If this function is actually a iter, a block containing the code\n-    // called whenever the iter calls 'put'.\n+    // If this function is actually a iter, a block containing the\n+    // code called whenever the iter calls 'put'.\n+    mutable lliterbody: option::t[ValueRef],\n \n     // If this function is actually a iter, the type of the function\n     // that that we call when we call 'put'. Having to track this is\n     // pretty irritating. We have to do it because we need the type if\n     // we are going to put the iterbody into a closure (if it appears\n     // in a for-each inside of an iter).\n+    mutable iterbodyty: option::t[ty::t],\n \n     // The next four items: hash tables mapping from AST def_ids to\n     // LLVM-stuff-in-the-frame.\n \n     // Maps arguments to allocas created for them in llallocas.\n+    llargs: hashmap[ast::node_id, ValueRef],\n \n-    // Maps fields in objects to pointers into the interior of llself's\n-    // body.\n+    // Maps fields in objects to pointers into the interior of\n+    // llself's body.\n+    llobjfields: hashmap[ast::node_id, ValueRef],\n \n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n+    lllocals: hashmap[ast::node_id, ValueRef],\n \n-    // The same as above, but for variables accessed via the frame pointer\n-    // we pass into an iter, for access to the static environment of the\n-    // iter-calling frame.\n+    // The same as above, but for variables accessed via the frame\n+    // pointer we pass into an iter, for access to the static\n+    // environment of the iter-calling frame.\n+    llupvars: hashmap[ast::node_id, ValueRef],\n \n-    // For convenience, a vector of the incoming tydescs for each of this\n-    // functions type parameters, fetched via llvm::LLVMGetParam.  For\n-    // example, for a function foo[A, B, C](), lltydescs contains the\n-    // ValueRefs for the tydescs for A, B, and C.\n+    // For convenience, a vector of the incoming tydescs for each of\n+    // this functions type parameters, fetched via llvm::LLVMGetParam.\n+    // For example, for a function foo[A, B, C](), lltydescs contains\n+    // the ValueRefs for the tydescs for A, B, and C.\n+    mutable lltydescs: ValueRef[],\n \n     // Derived tydescs are tydescs created at runtime, for types that\n     // involve type parameters inside type constructors.  For example,\n     // suppose a function parameterized by T creates a vector of type\n-    // [T].  The function doesn't know what T is until runtime, and the\n-    // function's caller knows T but doesn't know that a vector is\n+    // [T].  The function doesn't know what T is until runtime, and\n+    // the function's caller knows T but doesn't know that a vector is\n     // involved.  So a tydesc for [T] can't be created until runtime,\n-    // when information about both \"[T]\" and \"T\" are available.  When such\n-    // a tydesc is created, we cache it in the derived_tydescs table for\n-    // the next time that such a tydesc is needed.\n+    // when information about both \"[T]\" and \"T\" are available.  When\n+    // such a tydesc is created, we cache it in the derived_tydescs\n+    // table for the next time that such a tydesc is needed.\n+    derived_tydescs: hashmap[ty::t, derived_tydesc_info],\n \n-    // The node_id of the function, or -1 if it doesn't correspond to a\n-    // user defined function.\n+    // The node_id of the function, or -1 if it doesn't correspond to\n+    // a user-defined function.\n+    id: ast::node_id,\n \n     // The source span where this function comes from, for error\n     // reporting.\n+    sp: span,\n \n     // This function's enclosing local context.\n-    {llfn: ValueRef,\n-     lltaskptr: ValueRef,\n-     llenv: ValueRef,\n-     llretptr: ValueRef,\n-     mutable llstaticallocas: BasicBlockRef,\n-     mutable llcopyargs: BasicBlockRef,\n-     mutable llderivedtydescs_first: BasicBlockRef,\n-     mutable llderivedtydescs: BasicBlockRef,\n-     mutable lldynamicallocas: BasicBlockRef,\n-     mutable llself: option::t[val_self_pair],\n-     mutable lliterbody: option::t[ValueRef],\n-     mutable iterbodyty: option::t[ty::t],\n-     llargs: hashmap[ast::node_id, ValueRef],\n-     llobjfields: hashmap[ast::node_id, ValueRef],\n-     lllocals: hashmap[ast::node_id, ValueRef],\n-     llupvars: hashmap[ast::node_id, ValueRef],\n-     mutable lltydescs: ValueRef[],\n-     derived_tydescs: hashmap[ty::t, derived_tydesc_info],\n-     id: ast::node_id,\n-     sp: span,\n-     lcx: @local_ctxt};\n+    lcx: @local_ctxt\n+};\n \n tag cleanup {\n     clean(fn(&@block_ctxt) -> result );\n@@ -340,34 +344,36 @@ tag block_kind {\n // code.  Each basic block we generate is attached to a function, typically\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n-type block_ctxt =\n+type block_ctxt = {\n     // The BasicBlockRef returned from a call to\n-    // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic block to\n-    // the function pointed to by llfn.  We insert instructions into that\n-    // block by way of this block context.\n+    // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n+    // block to the function pointed to by llfn.  We insert\n+    // instructions into that block by way of this block context.\n+    llbb: BasicBlockRef,\n \n     // The llvm::builder object serving as an interface to LLVM's\n     // LLVMBuild* functions.\n+    build: builder,\n \n     // The block pointing to this one in the function's digraph.\n+    parent: block_parent,\n \n     // The 'kind' of basic block this is.\n+    kind: block_kind,\n \n-    // A list of functions that run at the end of translating this block,\n-    // cleaning up any variables that were introduced in the block and\n-    // need to go out of scope at the end of it.\n+    // A list of functions that run at the end of translating this\n+    // block, cleaning up any variables that were introduced in the\n+    // block and need to go out of scope at the end of it.\n+    mutable cleanups: cleanup[],\n \n-    // The source span where this block comes from, for error reporting.\n+    // The source span where this block comes from, for error\n+    // reporting.\n+    sp: span,\n \n     // The function context for the function to which this block is\n     // attached.\n-    {llbb: BasicBlockRef,\n-     build: builder,\n-     parent: block_parent,\n-     kind: block_kind,\n-     mutable cleanups: cleanup[],\n-     sp: span,\n-     fcx: @fn_ctxt};\n+    fcx: @fn_ctxt\n+};\n \n // FIXME: we should be able to use option::t[@block_parent] here but\n // the infinite-tag check in rustboot gets upset."}]}