{"sha": "82765a0b48aa79ecd9a3fe20bf693c6e68464ef5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNzY1YTBiNDhhYTc5ZWNkOWEzZmUyMGJmNjkzYzZlNjg0NjRlZjU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-04-17T22:47:24Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-04-17T22:58:11Z"}, "message": "rustpkg: Implement clean; replace boolean result flags with fail!()\n\n1. Implemented the `clean` command\n\n2. The methods implementing rustpkg commands all returned `bool`.\nSince most of not all of the error situations seem unrecoverable,\nI changed the methods to return unit (and also stubbed out several\nmore methods that were assuming a package script existed, to be\nre-implemented in the future)", "tree": {"sha": "22450ebbe9acb809763ed6153c45951b8a67bb2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22450ebbe9acb809763ed6153c45951b8a67bb2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82765a0b48aa79ecd9a3fe20bf693c6e68464ef5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82765a0b48aa79ecd9a3fe20bf693c6e68464ef5", "html_url": "https://github.com/rust-lang/rust/commit/82765a0b48aa79ecd9a3fe20bf693c6e68464ef5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82765a0b48aa79ecd9a3fe20bf693c6e68464ef5/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6c3c371a554de6079c1c0b27885b8792431e516", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6c3c371a554de6079c1c0b27885b8792431e516", "html_url": "https://github.com/rust-lang/rust/commit/e6c3c371a554de6079c1c0b27885b8792431e516"}], "stats": {"total": 226, "additions": 67, "deletions": 159}, "files": [{"sha": "b3b47e7aeda19eb7d103f4172ed74759d420269e", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 61, "deletions": 156, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/82765a0b48aa79ecd9a3fe20bf693c6e68464ef5/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/82765a0b48aa79ecd9a3fe20bf693c6e68464ef5/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=82765a0b48aa79ecd9a3fe20bf693c6e68464ef5", "patch": "@@ -33,7 +33,6 @@ use core::hashmap::HashMap;\n use core::io::WriterUtil;\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n-use std::net::url;\n use std::{getopts};\n use syntax::{ast, diagnostic};\n use util::*;\n@@ -244,16 +243,21 @@ impl Ctx {\n                 src.build(&dst_dir, cfgs);\n             }\n             ~\"clean\" => {\n-                self.clean();\n+                if args.len() < 1 {\n+                    return usage::build();\n+                }\n+                // The package id is presumed to be the first command-line\n+                // argument\n+                let pkgid = PkgId::new(args[0]);\n+\n+                self.clean(pkgid);\n             }\n             ~\"do\" => {\n                 if args.len() < 2 {\n                     return usage::do_cmd();\n                 }\n \n-                if !self.do_cmd(args[0], args[1]) {\n-                    fail!(~\"a command failed!\");\n-                }\n+                self.do_cmd(args[0], args[1]);\n             }\n             ~\"info\" => {\n                 self.info();\n@@ -298,12 +302,11 @@ impl Ctx {\n         }\n     }\n \n-    fn do_cmd(&self, cmd: ~str, pkgname: ~str) -> bool {\n+    fn do_cmd(&self, cmd: ~str, pkgname: ~str)  {\n         match cmd {\n             ~\"build\" | ~\"test\" => {\n                 util::error(~\"that command cannot be manually called\");\n-\n-                return false;\n+                fail!(~\"do_cmd\");\n             }\n             _ => {}\n         }\n@@ -319,16 +322,15 @@ impl Ctx {\n             Some(script_path) => {\n                 let script = PkgScript::parse(script_path, pkgid);\n                 let (_, status) = script.run_custom(cmd); // Ignore cfgs?\n-                if status == 42 { // ???\n+                if status == 42 {\n                     util::error(~\"no fns are listening for that cmd\");\n-                    return false;\n+                    fail!(~\"do_cmd\");\n                 }\n-                status == 0\n             }\n             None => {\n                 util::error(fmt!(\"invoked `do`, but there is no package script in %s\",\n                                  cwd.to_str()));\n-                false\n+                fail!(~\"do_cmd\");\n             }\n         }\n     }\n@@ -341,128 +343,44 @@ impl Ctx {\n     }\n \n     fn compile(&self, _crate: &Path, _dir: &Path, _flags: ~[~str],\n-               _cfgs: ~[~str], _opt: bool, _test: bool) -> bool {\n+               _cfgs: ~[~str], _opt: bool, _test: bool)  {\n         // What's the difference between build and compile?\n         fail!(~\"compile not yet implemented\");\n     }\n \n-    fn clean(&self) -> bool {\n-        // stub\n-        fail!();\n+    fn clean(&self, id: PkgId)  {\n+        // Could also support a custom build hook in the pkg\n+        // script for cleaning files rustpkg doesn't know about.\n+        // Do something reasonable for now\n+\n+        let dir = dest_dir(id);\n+        util::note(fmt!(\"Cleaning package %s (removing directory %s)\",\n+                        id.to_str(), dir.to_str()));\n+        if os::path_exists(&dir) {\n+            util::remove_dir_r(&dir);\n+            util::note(fmt!(\"Removed directory %s\", dir.to_str()));\n+        }\n+\n+        util::note(fmt!(\"Cleaned package %s\", id.to_str()));\n     }\n \n     fn info(&self) {\n         // stub\n-        fail!();\n+        fail!(~\"info not yet implemented\");\n     }\n \n-    fn install(&self, url: Option<~str>,\n-               target: Option<~str>, cache: bool) -> bool {\n-       let dir = match url {\n-            None => {\n-                util::note(~\"installing from the cwd\");\n-                os::getcwd()\n-            }\n-            Some(url) => {\n-                let hash = util::hash(if !target.is_none() {\n-                    url + target.get()\n-                }\n-                else { url });\n-\n-                if self.dep_cache.contains_key(&hash) {\n-                    util::warn(~\"already installed dep this run\");\n-                    return true;\n-                }\n-\n-                self.dep_cache.insert(hash, true);\n-\n-                let dir = util::root().push(~\"tmp\").push(hash);\n-\n-                if cache && os::path_exists(&dir) {\n-                    return true;\n-                }\n-\n-                if !self.fetch(&dir, url, target) {\n-                    return false;\n-                }\n-                dir\n-            }\n-        };\n-\n-        let script = match self.build(&dir, false, true, false) {\n-            Some(script) => script,\n-            None => {\n-                return false;\n-            }\n-        };\n-        let work_dir = script.build_dir;\n-        let from_bin_dir = work_dir.push(~\"bin\");\n-        let from_lib_dir = work_dir.push(~\"lib\");\n-        let to_bin_dir = util::root().push(~\"bin\");\n-        let to_lib_dir = util::root().push(~\"lib\");\n-        let mut bins = ~[];\n-        let mut libs = ~[];\n-\n-        for os::walk_dir(&from_bin_dir) |bin| {\n-            let to = to_bin_dir.push_rel(&bin.file_path());\n-\n-            os::copy_file(bin, &to);\n-            bins.push(to.to_str());\n-        }\n-\n-        for os::walk_dir(&from_lib_dir) |lib| {\n-            let to = to_lib_dir.push_rel(&lib.file_path());\n-\n-            os::copy_file(lib, &to);\n-            libs.push(to.to_str());\n-        }\n-\n-        let package = Pkg {\n-            id: script.id,\n-            bins: bins,\n-            libs: libs\n-        };\n-\n-        util::note(fmt!(\"installed %s\", script.id.to_str()));\n-        util::add_pkg(&package);\n-\n-        true\n+    fn install(&self, _url: Option<~str>,\n+               _target: Option<~str>, _cache: bool)  {\n+        // stub\n+        fail!(~\"install not yet implemented\");\n     }\n \n-    fn fetch(&self, dir: &Path, url: ~str, target: Option<~str>) -> bool {\n-        let url = if str::find_str(url, \"://\").is_none() {\n-            ~\"http://\" + url }\n-        else { url };\n-        let url = match url::from_str(url) {\n-            result::Ok(url) => url,\n-            result::Err(err) => {\n-                util::error(fmt!(\"failed parsing %s\", err.to_lower()));\n-\n-                return false;\n-            }\n-        };\n-        let str = url.to_str();\n-\n-        match Path(url.path).filetype() {\n-            Some(ext) => {\n-                if ext == ~\".git\" {\n-                    return self.fetch_git(dir, str, target);\n-                }\n-            }\n-            None => {}\n-        }\n-\n-        match url.scheme {\n-            ~\"git\" => self.fetch_git(dir, str, target),\n-            ~\"http\" | ~\"ftp\" | ~\"file\" => self.fetch_curl(dir, str),\n-            _ => {\n-                util::warn(~\"unknown url scheme to fetch, using curl\");\n-                self.fetch_curl(dir, str)\n-            }\n-        }\n+    fn fetch(&self, _dir: &Path, _url: ~str, _target: Option<~str>)  {\n+        // stub\n+        fail!(~\"fetch not yet implemented\");\n     }\n \n-    fn fetch_curl(&self, dir: &Path, url: ~str) -> bool {\n+    fn fetch_curl(&self, dir: &Path, url: ~str)  {\n         util::note(fmt!(\"fetching from %s using curl\", url));\n \n         let tar = dir.dir_path().push(&dir.file_path().to_str() + ~\".tar\");\n@@ -472,7 +390,7 @@ impl Ctx {\n                                           url]).status != 0 {\n             util::error(~\"fetching failed: downloading using curl failed\");\n \n-            return false;\n+            fail!();\n         }\n \n         if run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n@@ -481,13 +399,11 @@ impl Ctx {\n             util::error(~\"fetching failed: extracting using tar failed\" +\n                         ~\"(is it a valid tar archive?)\");\n \n-            return false;\n+           fail!();\n         }\n-\n-        true\n     }\n \n-    fn fetch_git(&self, dir: &Path, url: ~str, target: Option<~str>) -> bool {\n+    fn fetch_git(&self, dir: &Path, url: ~str, target: Option<~str>)  {\n         util::note(fmt!(\"fetching from %s using git\", url));\n \n         // Git can't clone into a non-empty directory\n@@ -496,8 +412,7 @@ impl Ctx {\n         if run::program_output(~\"git\", ~[~\"clone\", url,\n                                          dir.to_str()]).status != 0 {\n             util::error(~\"fetching failed: can't clone repository\");\n-\n-            return false;\n+            fail!();\n         }\n \n         if !target.is_none() {\n@@ -511,21 +426,17 @@ impl Ctx {\n \n             if !success {\n                 util::error(~\"fetching failed: can't checkout target\");\n-\n-                return false;\n+                fail!();\n             }\n         }\n-\n-        true\n     }\n \n-    fn prefer(&self, id: ~str, vers: Option<~str>) -> bool {\n+    fn prefer(&self, id: ~str, vers: Option<~str>)  {\n         let package = match util::get_pkg(id, vers) {\n             result::Ok(package) => package,\n             result::Err(err) => {\n                 util::error(err);\n-\n-                return false;\n+                fail!(); // Condition?\n             }\n         };\n         let name = package.id.path.to_str(); // ???\n@@ -548,29 +459,18 @@ impl Ctx {\n         }\n \n         util::note(fmt!(\"preferred %s v%s\", name, package.id.version.to_str()));\n-\n-        true\n     }\n \n-    fn test(&self) -> bool {\n-        let script = match self.build(&os::getcwd(), false, false, true) {\n-            Some(script) => script,\n-            None => {\n-                return false;\n-            }\n-        };\n-\n-        // To do\n-        util::note(fmt!(\"Would test %s, but this is a dry run\",\n-                        script.id.to_str()));\n-        false\n+    fn test(&self)  {\n+        // stub\n+        fail!(~\"test not yet implemented\");\n     }\n \n-    fn uninstall(&self, _id: ~str, _vers: Option<~str>) -> bool {\n+    fn uninstall(&self, _id: ~str, _vers: Option<~str>)  {\n         fail!(~\"uninstall not yet implemented\");\n     }\n \n-    fn unprefer(&self, _id: ~str, _vers: Option<~str>) -> bool {\n+    fn unprefer(&self, _id: ~str, _vers: Option<~str>)  {\n         fail!(~\"unprefer not yet implemented\");\n     }\n }\n@@ -839,14 +739,19 @@ impl PkgSrc {\n                                                prefix, pth),\n                 Some(~\"bench.rs\") => push_crate(&mut self.benchs,\n                                                 prefix, pth),\n-                _ => {\n-                    util::note(~\"Couldn't infer any crates to build.\\n\\\n-                                Try naming a crate `main.rs`, `lib.rs`, \\\n-                                `test.rs`, or `bench.rs`.\");\n-                    fail!(~\"Failed to infer crates to build\");\n-                }\n+                _ => ()\n             }\n         }\n+\n+        if self.libs.is_empty() && self.mains.is_empty()\n+            && self.tests.is_empty() && self.benchs.is_empty() {\n+\n+            util::note(~\"Couldn't infer any crates to build.\\n\\\n+                         Try naming a crate `main.rs`, `lib.rs`, \\\n+                         `test.rs`, or `bench.rs`.\");\n+            fail!(~\"Failed to infer crates to build\");\n+        }\n+        \n         debug!(\"found %u libs, %u mains, %u tests, %u benchs\",\n                self.libs.len(),\n                self.mains.len(),"}, {"sha": "2ef387d962000c1f044061bb646ae299fa97b045", "filename": "src/librustpkg/testsuite/pass/hello-world/main.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/82765a0b48aa79ecd9a3fe20bf693c6e68464ef5/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fhello-world%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82765a0b48aa79ecd9a3fe20bf693c6e68464ef5/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fhello-world%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fhello-world%2Fmain.rs?ref=82765a0b48aa79ecd9a3fe20bf693c6e68464ef5", "patch": "@@ -10,9 +10,12 @@\n \n /*\n The test runner should check that, after `rustpkg build hello-world`:\n-  * testsuite/hello-world/build/ exists\n-  * testsuite/hello-world/build/ contains an executable named hello-world\n-  * testsuite/hello-world/build/ does not contain a library\n+  * testsuite/pass/hello-world/build/ exists\n+  * testsuite/pass/hello-world/build/ contains an executable named hello-world\n+  * testsuite/pass/hello-world/build/ does not contain a library\n+\n+ It should also check that after `rustpkg clean hello-world`:\n+  * testsuite/pass/hello-world/build is empty\n */\n \n use core::io;"}]}