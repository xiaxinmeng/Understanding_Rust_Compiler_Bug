{"sha": "1553874149c3c37b94d75e9122092b131ba74c77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NTM4NzQxNDljM2MzN2I5NGQ3NWU5MTIyMDkyYjEzMWJhNzRjNzc=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T07:42:24Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T13:02:55Z"}, "message": "std: convert str::reserve* to methods, and methodise str::push_*.", "tree": {"sha": "ea25b52a29e038180659148f319410843b13fa02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea25b52a29e038180659148f319410843b13fa02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1553874149c3c37b94d75e9122092b131ba74c77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1553874149c3c37b94d75e9122092b131ba74c77", "html_url": "https://github.com/rust-lang/rust/commit/1553874149c3c37b94d75e9122092b131ba74c77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1553874149c3c37b94d75e9122092b131ba74c77/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a64e886e3c1dd38473fd7711933557f1b97a9036", "url": "https://api.github.com/repos/rust-lang/rust/commits/a64e886e3c1dd38473fd7711933557f1b97a9036", "html_url": "https://github.com/rust-lang/rust/commit/a64e886e3c1dd38473fd7711933557f1b97a9036"}], "stats": {"total": 496, "additions": 248, "deletions": 248}, "files": [{"sha": "62d4a32b8e239b3de576d2653b3f6b272147a2f6", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -49,7 +49,7 @@ impl<'self> ToBase64 for &'self [u8] {\n     fn to_base64(&self) -> ~str {\n         let mut s = ~\"\";\n         let len = self.len();\n-        str::reserve(&mut s, ((len + 3u) / 4u) * 3u);\n+        s.reserve(((len + 3u) / 4u) * 3u);\n \n         let mut i = 0u;\n \n@@ -59,10 +59,10 @@ impl<'self> ToBase64 for &'self [u8] {\n                     (self[i + 2u] as uint);\n \n             // This 24-bit number gets separated into four 6-bit numbers.\n-            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n-            str::push_char(&mut s, CHARS[n & 63u]);\n+            s.push_char(CHARS[(n >> 18u) & 63u]);\n+            s.push_char(CHARS[(n >> 12u) & 63u]);\n+            s.push_char(CHARS[(n >> 6u) & 63u]);\n+            s.push_char(CHARS[n & 63u]);\n \n             i += 3u;\n         }\n@@ -73,18 +73,18 @@ impl<'self> ToBase64 for &'self [u8] {\n           0 => (),\n           1 => {\n             let n = (self[i] as uint) << 16u;\n-            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-            str::push_char(&mut s, '=');\n-            str::push_char(&mut s, '=');\n+            s.push_char(CHARS[(n >> 18u) & 63u]);\n+            s.push_char(CHARS[(n >> 12u) & 63u]);\n+            s.push_char('=');\n+            s.push_char('=');\n           }\n           2 => {\n             let n = (self[i] as uint) << 16u |\n                 (self[i + 1u] as uint) << 8u;\n-            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n-            str::push_char(&mut s, '=');\n+            s.push_char(CHARS[(n >> 18u) & 63u]);\n+            s.push_char(CHARS[(n >> 12u) & 63u]);\n+            s.push_char(CHARS[(n >> 6u) & 63u]);\n+            s.push_char('=');\n           }\n           _ => fail!(\"Algebra is broken, please alert the math police\")\n         }"}, {"sha": "1e9ec48aff32d5f61686b328c90465fb3de5a1f0", "filename": "src/libextra/json.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -79,7 +79,7 @@ fn escape_str(s: &str) -> ~str {\n \n fn spaces(n: uint) -> ~str {\n     let mut ss = ~\"\";\n-    for n.times { str::push_str(&mut ss, \" \"); }\n+    for n.times { ss.push_str(\" \"); }\n     return ss;\n }\n \n@@ -712,14 +712,14 @@ impl Parser {\n \n             if (escape) {\n                 match self.ch {\n-                  '\"' => str::push_char(&mut res, '\"'),\n-                  '\\\\' => str::push_char(&mut res, '\\\\'),\n-                  '/' => str::push_char(&mut res, '/'),\n-                  'b' => str::push_char(&mut res, '\\x08'),\n-                  'f' => str::push_char(&mut res, '\\x0c'),\n-                  'n' => str::push_char(&mut res, '\\n'),\n-                  'r' => str::push_char(&mut res, '\\r'),\n-                  't' => str::push_char(&mut res, '\\t'),\n+                  '\"' => res.push_char('\"'),\n+                  '\\\\' => res.push_char('\\\\'),\n+                  '/' => res.push_char('/'),\n+                  'b' => res.push_char('\\x08'),\n+                  'f' => res.push_char('\\x0c'),\n+                  'n' => res.push_char('\\n'),\n+                  'r' => res.push_char('\\r'),\n+                  't' => res.push_char('\\t'),\n                   'u' => {\n                       // Parse \\u1234.\n                       let mut i = 0u;\n@@ -748,7 +748,7 @@ impl Parser {\n                             ~\"invalid \\\\u escape (not four digits)\");\n                       }\n \n-                      str::push_char(&mut res, n as char);\n+                      res.push_char(n as char);\n                   }\n                   _ => return self.error(~\"invalid escape\")\n                 }\n@@ -760,7 +760,7 @@ impl Parser {\n                     self.bump();\n                     return Ok(res);\n                 }\n-                str::push_char(&mut res, self.ch);\n+                res.push_char(self.ch);\n             }\n         }\n "}, {"sha": "30d55721efb76dec9dd7446ae803c3a04c7e1649", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -81,7 +81,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n               'a' .. 'z' |\n               '0' .. '9' |\n               '-' | '.' | '_' | '~' => {\n-                str::push_char(&mut out, ch);\n+                out.push_char(ch);\n               }\n               _ => {\n                   if full_url {\n@@ -92,7 +92,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n                       // sub-delims:\n                       '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n                       '+' | ',' | ';' | '=' => {\n-                        str::push_char(&mut out, ch);\n+                        out.push_char(ch);\n                       }\n \n                       _ => out += fmt!(\"%%%X\", ch as uint)\n@@ -148,18 +148,18 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n                       // sub-delims:\n                       '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n                       '+' | ',' | ';' | '=' => {\n-                        str::push_char(&mut out, '%');\n-                        str::push_char(&mut out, bytes[0u] as char);\n-                        str::push_char(&mut out, bytes[1u] as char);\n+                        out.push_char('%');\n+                        out.push_char(bytes[0u] as char);\n+                        out.push_char(bytes[1u] as char);\n                       }\n \n-                      ch => str::push_char(&mut out, ch)\n+                      ch => out.push_char(ch)\n                     }\n                 } else {\n-                      str::push_char(&mut out, ch);\n+                      out.push_char(ch);\n                 }\n               }\n-              ch => str::push_char(&mut out, ch)\n+              ch => out.push_char(ch)\n             }\n         }\n \n@@ -191,9 +191,9 @@ fn encode_plus(s: &str) -> ~str {\n             let ch = rdr.read_byte() as char;\n             match ch {\n               'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '.' | '-' => {\n-                str::push_char(&mut out, ch);\n+                out.push_char(ch);\n               }\n-              ' ' => str::push_char(&mut out, '+'),\n+              ' ' => out.push_char('+'),\n               _ => out += fmt!(\"%%%X\", ch as uint)\n             }\n         }\n@@ -216,7 +216,7 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n             if first {\n                 first = false;\n             } else {\n-                str::push_char(&mut out, '&');\n+                out.push_char('&');\n                 first = false;\n             }\n \n@@ -267,9 +267,9 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n                     };\n \n                     if parsing_key {\n-                        str::push_char(&mut key, ch)\n+                        key.push_char(ch)\n                     } else {\n-                        str::push_char(&mut value, ch)\n+                        value.push_char(ch)\n                     }\n                 }\n             }"}, {"sha": "de78e0a6eebda847ac402db5e6a373425c8dabfc", "filename": "src/libextra/rope.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibextra%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibextra%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frope.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -1289,9 +1289,7 @@ mod tests {\n             fn aux(str: &mut ~str, node: @node::Node) {\n                 match (*node) {\n                     node::Leaf(x) => {\n-                        str::push_str(\n-                            str,\n-                            x.content.slice(x.byte_offset, x.byte_offset + x.byte_len));\n+                        str.push_str(x.content.slice(x.byte_offset, x.byte_offset + x.byte_len));\n                     }\n                     node::Concat(ref x) => {\n                         aux(str, x.left);"}, {"sha": "dad080752388e74a57dcd5a1b82c3bab006b7983", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -149,7 +149,7 @@ fn take_nonempty_prefix(rdr: @io::Reader,\n     let mut buf = ~\"\";\n     let mut ch = ch;\n     while pred(ch) {\n-        str::push_char(&mut buf, ch);\n+        buf.push_char(ch);\n         ch = rdr.read_char();\n     }\n     if buf.is_empty() {"}, {"sha": "fea5cb560acafedd0ee7151240232357ff9f476c", "filename": "src/libextra/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -851,7 +851,7 @@ priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n         while !rdr.eof() {\n             match rdr.read_char() {\n                 '%' => buf += parse_type(rdr.read_char(), tm),\n-                ch => str::push_char(&mut buf, ch)\n+                ch => buf.push_char(ch)\n             }\n         }\n     }"}, {"sha": "18946ee2d790e0e3b622a1261c9140d6078521d1", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -980,7 +980,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         fn type_string(doc: ebml::Doc) -> ~str {\n             let mut str = ~\"\";\n             for uint::range(doc.start, doc.end) |i| {\n-                str::push_char(&mut str, doc.data[i] as char);\n+                str.push_char(doc.data[i] as char);\n             }\n             str\n         }"}, {"sha": "b0b9c9f7efb62e0a1f997f3b084ffe7e90c5923b", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -694,9 +694,9 @@ impl BorrowckCtxt {\n                                                  out: &mut ~str) {\n         match *loan_path {\n             LpExtend(_, _, LpDeref) => {\n-                str::push_char(out, '(');\n+                out.push_char('(');\n                 self.append_loan_path_to_str(loan_path, out);\n-                str::push_char(out, ')');\n+                out.push_char(')');\n             }\n             LpExtend(_, _, LpInterior(_)) |\n             LpVar(_) => {\n@@ -712,7 +712,7 @@ impl BorrowckCtxt {\n             LpVar(id) => {\n                 match self.tcx.items.find(&id) {\n                     Some(&ast_map::node_local(ref ident)) => {\n-                        str::push_str(out, *token::ident_to_str(ident));\n+                        out.push_str(*token::ident_to_str(ident));\n                     }\n                     r => {\n                         self.tcx.sess.bug(\n@@ -726,23 +726,23 @@ impl BorrowckCtxt {\n                 self.append_loan_path_to_str_from_interior(lp_base, out);\n                 match fname {\n                     mc::NamedField(ref fname) => {\n-                        str::push_char(out, '.');\n-                        str::push_str(out, *token::ident_to_str(fname));\n+                        out.push_char('.');\n+                        out.push_str(*token::ident_to_str(fname));\n                     }\n                     mc::PositionalField(idx) => {\n-                        str::push_char(out, '#'); // invent a notation here\n-                        str::push_str(out, idx.to_str());\n+                        out.push_char('#'); // invent a notation here\n+                        out.push_str(idx.to_str());\n                     }\n                 }\n             }\n \n             LpExtend(lp_base, _, LpInterior(mc::InteriorElement(_))) => {\n                 self.append_loan_path_to_str_from_interior(lp_base, out);\n-                str::push_str(out, \"[]\");\n+                out.push_str(\"[]\");\n             }\n \n             LpExtend(lp_base, _, LpDeref) => {\n-                str::push_char(out, '*');\n+                out.push_char('*');\n                 self.append_loan_path_to_str(lp_base, out);\n             }\n         }"}, {"sha": "e2d88e3c76812ce978c3a2327cca402e4a22f0a5", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -947,13 +947,13 @@ fn bits_to_str(words: &[uint]) -> ~str {\n     for words.each |&word| {\n         let mut v = word;\n         for uint::range(0, uint::bytes) |_| {\n-            str::push_char(&mut result, sep);\n-            str::push_str(&mut result, fmt!(\"%02x\", v & 0xFF));\n+            result.push_char(sep);\n+            result.push_str(fmt!(\"%02x\", v & 0xFF));\n             v >>= 8;\n             sep = '-';\n         }\n     }\n-    str::push_char(&mut result, ']');\n+    result.push_char(']');\n     return result;\n }\n "}, {"sha": "5455edc25863ca1a42ea4740f2829bc80c66e746", "filename": "src/libstd/str.rs", "status": "modified", "additions": 167, "deletions": 165, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -139,121 +139,35 @@ pub fn from_byte(b: u8) -> ~str {\n     unsafe { ::cast::transmute(~[b, 0u8]) }\n }\n \n-/// Appends a character at the end of a string\n-pub fn push_char(s: &mut ~str, ch: char) {\n-    unsafe {\n-        let code = ch as uint;\n-        let nb = if code < max_one_b { 1u }\n-        else if code < max_two_b { 2u }\n-        else if code < max_three_b { 3u }\n-        else if code < max_four_b { 4u }\n-        else if code < max_five_b { 5u }\n-        else { 6u };\n-        let len = s.len();\n-        let new_len = len + nb;\n-        reserve_at_least(&mut *s, new_len);\n-        let off = len;\n-        do as_buf(*s) |buf, _len| {\n-            let buf: *mut u8 = ::cast::transmute(buf);\n-            match nb {\n-                1u => {\n-                    *ptr::mut_offset(buf, off) = code as u8;\n-                }\n-                2u => {\n-                    *ptr::mut_offset(buf, off) = (code >> 6u & 31u | tag_two_b) as u8;\n-                    *ptr::mut_offset(buf, off + 1u) = (code & 63u | tag_cont) as u8;\n-                }\n-                3u => {\n-                    *ptr::mut_offset(buf, off) = (code >> 12u & 15u | tag_three_b) as u8;\n-                    *ptr::mut_offset(buf, off + 1u) = (code >> 6u & 63u | tag_cont) as u8;\n-                    *ptr::mut_offset(buf, off + 2u) = (code & 63u | tag_cont) as u8;\n-                }\n-                4u => {\n-                    *ptr::mut_offset(buf, off) = (code >> 18u & 7u | tag_four_b) as u8;\n-                    *ptr::mut_offset(buf, off + 1u) = (code >> 12u & 63u | tag_cont) as u8;\n-                    *ptr::mut_offset(buf, off + 2u) = (code >> 6u & 63u | tag_cont) as u8;\n-                    *ptr::mut_offset(buf, off + 3u) = (code & 63u | tag_cont) as u8;\n-                }\n-                5u => {\n-                    *ptr::mut_offset(buf, off) = (code >> 24u & 3u | tag_five_b) as u8;\n-                    *ptr::mut_offset(buf, off + 1u) = (code >> 18u & 63u | tag_cont) as u8;\n-                    *ptr::mut_offset(buf, off + 2u) = (code >> 12u & 63u | tag_cont) as u8;\n-                    *ptr::mut_offset(buf, off + 3u) = (code >> 6u & 63u | tag_cont) as u8;\n-                    *ptr::mut_offset(buf, off + 4u) = (code & 63u | tag_cont) as u8;\n-                }\n-                6u => {\n-                    *ptr::mut_offset(buf, off) = (code >> 30u & 1u | tag_six_b) as u8;\n-                    *ptr::mut_offset(buf, off + 1u) = (code >> 24u & 63u | tag_cont) as u8;\n-                    *ptr::mut_offset(buf, off + 2u) = (code >> 18u & 63u | tag_cont) as u8;\n-                    *ptr::mut_offset(buf, off + 3u) = (code >> 12u & 63u | tag_cont) as u8;\n-                    *ptr::mut_offset(buf, off + 4u) = (code >> 6u & 63u | tag_cont) as u8;\n-                    *ptr::mut_offset(buf, off + 5u) = (code & 63u | tag_cont) as u8;\n-                }\n-                _ => {}\n-            }\n-        }\n-        raw::set_len(s, new_len);\n-    }\n-}\n-\n /// Convert a char to a string\n pub fn from_char(ch: char) -> ~str {\n     let mut buf = ~\"\";\n-    push_char(&mut buf, ch);\n+    buf.push_char(ch);\n     buf\n }\n \n /// Convert a vector of chars to a string\n pub fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n-    reserve(&mut buf, chs.len());\n+    buf.reserve(chs.len());\n     for chs.each |ch| {\n-        push_char(&mut buf, *ch);\n+        buf.push_char(*ch)\n     }\n     buf\n }\n \n-/// Appends a string slice to the back of a string, without overallocating\n-#[inline(always)]\n-pub fn push_str_no_overallocate(lhs: &mut ~str, rhs: &str) {\n-    unsafe {\n-        let llen = lhs.len();\n-        let rlen = rhs.len();\n-        reserve(&mut *lhs, llen + rlen);\n-        do as_buf(*lhs) |lbuf, _llen| {\n-            do as_buf(rhs) |rbuf, _rlen| {\n-                let dst = ptr::offset(lbuf, llen);\n-                let dst = ::cast::transmute_mut_unsafe(dst);\n-                ptr::copy_memory(dst, rbuf, rlen);\n-            }\n-        }\n-        raw::set_len(lhs, llen + rlen);\n-    }\n-}\n-\n-/// Appends a string slice to the back of a string\n-#[inline(always)]\n+/// A function version of the `.push_str`, required for `fmt!` during\n+/// the bootstrap. Use `lhs.push_str(rhs)` instead of this.\n+#[doc=\"hidden\"]\n pub fn push_str(lhs: &mut ~str, rhs: &str) {\n-    unsafe {\n-        let llen = lhs.len();\n-        let rlen = rhs.len();\n-        reserve_at_least(&mut *lhs, llen + rlen);\n-        do as_buf(*lhs) |lbuf, _llen| {\n-            do as_buf(rhs) |rbuf, _rlen| {\n-                let dst = ptr::offset(lbuf, llen);\n-                let dst = ::cast::transmute_mut_unsafe(dst);\n-                ptr::copy_memory(dst, rbuf, rlen);\n-            }\n-        }\n-        raw::set_len(lhs, llen + rlen);\n-    }\n+    lhs.push_str(rhs)\n }\n \n /// Concatenate two strings together\n #[inline(always)]\n pub fn append(lhs: ~str, rhs: &str) -> ~str {\n     let mut v = lhs;\n-    push_str_no_overallocate(&mut v, rhs);\n+    v.push_str_no_overallocate(rhs);\n     v\n }\n \n@@ -286,7 +200,7 @@ impl<'self> StrVector for &'self [~str] {\n         }\n         let mut s = ~\"\";\n \n-        reserve(&mut s, len);\n+        s.reserve(len);\n \n         unsafe {\n             do as_buf(s) |buf, _| {\n@@ -319,7 +233,7 @@ impl<'self> StrVector for &'self [~str] {\n         let mut s = ~\"\";\n         let mut first = true;\n \n-        reserve(&mut s, len);\n+        s.reserve(len);\n \n         unsafe {\n             do as_buf(s) |buf, _| {\n@@ -358,7 +272,7 @@ impl<'self> StrVector for &'self [&'self str] {\n         }\n         let mut s = ~\"\";\n \n-        reserve(&mut s, len);\n+        s.reserve(len);\n \n         unsafe {\n             do as_buf(s) |buf, _| {\n@@ -391,7 +305,7 @@ impl<'self> StrVector for &'self [&'self str] {\n         let mut s = ~\"\";\n         let mut first = true;\n \n-        reserve(&mut s, len);\n+        s.reserve(len);\n \n         unsafe {\n             do as_buf(s) |buf, _| {\n@@ -425,7 +339,7 @@ pub fn repeat(ss: &str, nn: uint) -> ~str {\n         let mut ret = ~\"\";\n         // ignore the NULL terminator\n         let len = len - 1;\n-        reserve(&mut ret, nn * len);\n+        ret.reserve(nn * len);\n \n         unsafe {\n             do as_buf(ret) |rbuf, _len| {\n@@ -1148,9 +1062,9 @@ Section: Iterating through strings\n /// Apply a function to each character\n pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n-    reserve(&mut result, ss.len());\n+    result.reserve(ss.len());\n     for ss.iter().advance |cc| {\n-        str::push_char(&mut result, ff(cc));\n+        result.push_char(ff(cc));\n     }\n     result\n }\n@@ -1325,8 +1239,8 @@ pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n  */\n pub fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n-    reserve(&mut buf, v.len());\n-    utf16_chars(v, |ch| push_char(&mut buf, ch));\n+    buf.reserve(v.len());\n+    utf16_chars(v, |ch| buf.push_char(ch));\n     buf\n }\n \n@@ -1336,7 +1250,7 @@ pub fn from_utf16(v: &[u16]) -> ~str {\n  */\n pub fn with_capacity(capacity: uint) -> ~str {\n     let mut buf = ~\"\";\n-    reserve(&mut buf, capacity);\n+    buf.reserve(capacity);\n     buf\n }\n \n@@ -1660,54 +1574,6 @@ pub fn subslice_offset(outer: &str, inner: &str) -> uint {\n     }\n }\n \n-/**\n- * Reserves capacity for exactly `n` bytes in the given string, not including\n- * the null terminator.\n- *\n- * Assuming single-byte characters, the resulting string will be large\n- * enough to hold a string of length `n`. To account for the null terminator,\n- * the underlying buffer will have the size `n` + 1.\n- *\n- * If the capacity for `s` is already equal to or greater than the requested\n- * capacity, then no action is taken.\n- *\n- * # Arguments\n- *\n- * * s - A string\n- * * n - The number of bytes to reserve space for\n- */\n-#[inline(always)]\n-pub fn reserve(s: &mut ~str, n: uint) {\n-    unsafe {\n-        let v: *mut ~[u8] = cast::transmute(s);\n-        vec::reserve(&mut *v, n + 1);\n-    }\n-}\n-\n-/**\n- * Reserves capacity for at least `n` bytes in the given string, not including\n- * the null terminator.\n- *\n- * Assuming single-byte characters, the resulting string will be large\n- * enough to hold a string of length `n`. To account for the null terminator,\n- * the underlying buffer will have the size `n` + 1.\n- *\n- * This function will over-allocate in order to amortize the allocation costs\n- * in scenarios where the caller may need to repeatedly reserve additional\n- * space.\n- *\n- * If the capacity for `s` is already equal to or greater than the requested\n- * capacity, then no action is taken.\n- *\n- * # Arguments\n- *\n- * * s - A string\n- * * n - The number of bytes to reserve space for\n- */\n-#[inline(always)]\n-pub fn reserve_at_least(s: &mut ~str, n: uint) {\n-    reserve(s, uint::next_power_of_two(n + 1u) - 1u)\n-}\n \n /**\n  * Returns the number of single-byte characters the string can hold without\n@@ -1724,19 +1590,19 @@ pub fn capacity(s: &const ~str) -> uint {\n /// Escape each char in `s` with char::escape_default.\n pub fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n-    reserve_at_least(&mut out, s.len());\n+    out.reserve_at_least(s.len());\n     for s.iter().advance |c| {\n-        push_str(&mut out, char::escape_default(c));\n+        out.push_str(char::escape_default(c));\n     }\n     out\n }\n \n /// Escape each char in `s` with char::escape_unicode.\n pub fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n-    reserve_at_least(&mut out, s.len());\n+    out.reserve_at_least(s.len());\n     for s.iter().advance |c| {\n-        push_str(&mut out, char::escape_unicode(c));\n+        out.push_str(char::escape_unicode(c));\n     }\n     out\n }\n@@ -1747,7 +1613,7 @@ pub mod raw {\n     use libc;\n     use ptr;\n     use str::raw;\n-    use str::{as_buf, is_utf8, reserve_at_least};\n+    use str::{as_buf, is_utf8};\n     use vec;\n \n     /// Create a Rust string from a null-terminated *u8 buffer\n@@ -1859,7 +1725,7 @@ pub mod raw {\n     /// Appends a byte to a string. (Not UTF-8 safe).\n     pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n         let new_len = s.len() + 1;\n-        reserve_at_least(&mut *s, new_len);\n+        s.reserve_at_least(new_len);\n         do as_buf(*s) |buf, len| {\n             let buf: *mut u8 = ::cast::transmute(buf);\n             *ptr::mut_offset(buf, len) = b;\n@@ -1870,7 +1736,7 @@ pub mod raw {\n     /// Appends a vector of bytes to a string. (Not UTF-8 safe).\n     unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) {\n         let new_len = s.len() + bytes.len();\n-        reserve_at_least(&mut *s, new_len);\n+        s.reserve_at_least(new_len);\n         for bytes.each |byte| { push_byte(&mut *s, *byte); }\n     }\n \n@@ -2274,18 +2140,154 @@ impl<'self> StrSlice<'self> for &'self str {\n \n #[allow(missing_doc)]\n pub trait OwnedStr {\n-    fn push_str(&mut self, v: &str);\n+    fn push_str_no_overallocate(&mut self, rhs: &str);\n+    fn push_str(&mut self, rhs: &str);\n     fn push_char(&mut self, c: char);\n+    fn reserve(&mut self, n: uint);\n+    fn reserve_at_least(&mut self, n: uint);\n }\n \n impl OwnedStr for ~str {\n+    /// Appends a string slice to the back of a string, without overallocating\n+    #[inline(always)]\n+    fn push_str_no_overallocate(&mut self, rhs: &str) {\n+        unsafe {\n+            let llen = self.len();\n+            let rlen = rhs.len();\n+            self.reserve(llen + rlen);\n+            do as_buf(*self) |lbuf, _llen| {\n+                do as_buf(rhs) |rbuf, _rlen| {\n+                    let dst = ptr::offset(lbuf, llen);\n+                    let dst = ::cast::transmute_mut_unsafe(dst);\n+                    ptr::copy_memory(dst, rbuf, rlen);\n+                }\n+            }\n+            raw::set_len(self, llen + rlen);\n+        }\n+    }\n+\n+    /// Appends a string slice to the back of a string\n     #[inline]\n-    fn push_str(&mut self, v: &str) {\n-        push_str(self, v);\n+    fn push_str(&mut self, rhs: &str) {\n+        unsafe {\n+            let llen = self.len();\n+            let rlen = rhs.len();\n+            self.reserve_at_least(llen + rlen);\n+            do as_buf(*self) |lbuf, _llen| {\n+                do as_buf(rhs) |rbuf, _rlen| {\n+                    let dst = ptr::offset(lbuf, llen);\n+                    let dst = ::cast::transmute_mut_unsafe(dst);\n+                    ptr::copy_memory(dst, rbuf, rlen);\n+                }\n+            }\n+            raw::set_len(self, llen + rlen);\n+        }\n     }\n+    /// Appends a character to the back of a string\n     #[inline]\n     fn push_char(&mut self, c: char) {\n-        push_char(self, c);\n+        unsafe {\n+            let code = c as uint;\n+            let nb = if code < max_one_b { 1u }\n+            else if code < max_two_b { 2u }\n+            else if code < max_three_b { 3u }\n+            else if code < max_four_b { 4u }\n+            else if code < max_five_b { 5u }\n+            else { 6u };\n+            let len = self.len();\n+            let new_len = len + nb;\n+            self.reserve_at_least(new_len);\n+            let off = len;\n+            do as_buf(*self) |buf, _len| {\n+                let buf: *mut u8 = ::cast::transmute(buf);\n+                match nb {\n+                    1u => {\n+                        *ptr::mut_offset(buf, off) = code as u8;\n+                    }\n+                    2u => {\n+                        *ptr::mut_offset(buf, off) = (code >> 6u & 31u | tag_two_b) as u8;\n+                        *ptr::mut_offset(buf, off + 1u) = (code & 63u | tag_cont) as u8;\n+                    }\n+                    3u => {\n+                        *ptr::mut_offset(buf, off) = (code >> 12u & 15u | tag_three_b) as u8;\n+                        *ptr::mut_offset(buf, off + 1u) = (code >> 6u & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off + 2u) = (code & 63u | tag_cont) as u8;\n+                    }\n+                    4u => {\n+                        *ptr::mut_offset(buf, off) = (code >> 18u & 7u | tag_four_b) as u8;\n+                        *ptr::mut_offset(buf, off + 1u) = (code >> 12u & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off + 2u) = (code >> 6u & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off + 3u) = (code & 63u | tag_cont) as u8;\n+                    }\n+                    5u => {\n+                        *ptr::mut_offset(buf, off) = (code >> 24u & 3u | tag_five_b) as u8;\n+                        *ptr::mut_offset(buf, off + 1u) = (code >> 18u & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off + 2u) = (code >> 12u & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off + 3u) = (code >> 6u & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off + 4u) = (code & 63u | tag_cont) as u8;\n+                    }\n+                    6u => {\n+                        *ptr::mut_offset(buf, off) = (code >> 30u & 1u | tag_six_b) as u8;\n+                        *ptr::mut_offset(buf, off + 1u) = (code >> 24u & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off + 2u) = (code >> 18u & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off + 3u) = (code >> 12u & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off + 4u) = (code >> 6u & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off + 5u) = (code & 63u | tag_cont) as u8;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            raw::set_len(self, new_len);\n+        }\n+    }\n+\n+    /**\n+     * Reserves capacity for exactly `n` bytes in the given string, not including\n+     * the null terminator.\n+     *\n+     * Assuming single-byte characters, the resulting string will be large\n+     * enough to hold a string of length `n`. To account for the null terminator,\n+     * the underlying buffer will have the size `n` + 1.\n+     *\n+     * If the capacity for `s` is already equal to or greater than the requested\n+     * capacity, then no action is taken.\n+     *\n+     * # Arguments\n+     *\n+     * * s - A string\n+     * * n - The number of bytes to reserve space for\n+     */\n+    #[inline(always)]\n+    pub fn reserve(&mut self, n: uint) {\n+        unsafe {\n+            let v: *mut ~[u8] = cast::transmute(self);\n+            vec::reserve(&mut *v, n + 1);\n+        }\n+    }\n+\n+    /**\n+     * Reserves capacity for at least `n` bytes in the given string, not including\n+     * the null terminator.\n+     *\n+     * Assuming single-byte characters, the resulting string will be large\n+     * enough to hold a string of length `n`. To account for the null terminator,\n+     * the underlying buffer will have the size `n` + 1.\n+     *\n+     * This function will over-allocate in order to amortize the allocation costs\n+     * in scenarios where the caller may need to repeatedly reserve additional\n+     * space.\n+     *\n+     * If the capacity for `s` is already equal to or greater than the requested\n+     * capacity, then no action is taken.\n+     *\n+     * # Arguments\n+     *\n+     * * s - A string\n+     * * n - The number of bytes to reserve space for\n+     */\n+    #[inline(always)]\n+    fn reserve_at_least(&mut self, n: uint) {\n+        self.reserve(uint::next_power_of_two(n + 1u) - 1u)\n     }\n }\n \n@@ -2582,13 +2584,13 @@ mod tests {\n         fn a_million_letter_a() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n-            while i < 100000 { push_str(&mut rs, \"aaaaaaaaaa\"); i += 1; }\n+            while i < 100000 { rs.push_str(\"aaaaaaaaaa\"); i += 1; }\n             rs\n         }\n         fn half_a_million_letter_a() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n-            while i < 100000 { push_str(&mut rs, \"aaaaa\"); i += 1; }\n+            while i < 100000 { rs.push_str(\"aaaaa\"); i += 1; }\n             rs\n         }\n         let letters = a_million_letter_a();"}, {"sha": "e75cf2c01c6755bc8658975b21939ed6503d7dd7", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -136,10 +136,10 @@ unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n             let mut sep = \" at \";\n             for borrow_list.rev_iter().advance |entry| {\n                 if entry.box == box {\n-                    str::push_str(&mut msg, sep);\n+                    msg.push_str(sep);\n                     let filename = str::raw::from_c_str(entry.file);\n-                    str::push_str(&mut msg, filename);\n-                    str::push_str(&mut msg, fmt!(\":%u\", entry.line as uint));\n+                    msg.push_str(filename);\n+                    msg.push_str(fmt!(\":%u\", entry.line as uint));\n                     sep = \" and at \";\n                 }\n             }"}, {"sha": "b2ec3684b70e0c64c05b72570ed49f58bad08fc0", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -276,6 +276,9 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                     stms.push(cx.stmt_let(fmt_sp, npieces > 1,\n                                           ident, cx.expr_str_uniq(fmt_sp, s)));\n                 } else {\n+                    // we call the push_str function because the\n+                    // bootstrap doesnt't seem to work if we call the\n+                    // method.\n                     let args = ~[cx.expr_mut_addr_of(fmt_sp, buf()), cx.expr_str(fmt_sp, s)];\n                     let call = cx.expr_call_global(fmt_sp,\n                                                    ~[core_ident,"}, {"sha": "89fd5c3762a3b86861ebc8f59755725797ef178d", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -125,7 +125,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n fn read_to_eol(rdr: @mut StringReader) -> ~str {\n     let mut val = ~\"\";\n     while rdr.curr != '\\n' && !is_eof(rdr) {\n-        str::push_char(&mut val, rdr.curr);\n+        val.push_char(rdr.curr);\n         bump(rdr);\n     }\n     if rdr.curr == '\\n' { bump(rdr); }\n@@ -237,7 +237,7 @@ fn read_block_comment(rdr: @mut StringReader,\n     // doc-comments are not really comments, they are attributes\n     if rdr.curr == '*' || rdr.curr == '!' {\n         while !(rdr.curr == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n-            str::push_char(&mut curr_line, rdr.curr);\n+            curr_line.push_char(rdr.curr);\n             bump(rdr);\n         }\n         if !is_eof(rdr) {\n@@ -261,7 +261,7 @@ fn read_block_comment(rdr: @mut StringReader,\n                 curr_line = ~\"\";\n                 bump(rdr);\n             } else {\n-                str::push_char(&mut curr_line, rdr.curr);\n+                curr_line.push_char(rdr.curr);\n                 if rdr.curr == '/' && nextch(rdr) == '*' {\n                     bump(rdr);\n                     bump(rdr);"}, {"sha": "809a222352fb8063373b6a297621e6474e89bd9b", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -358,11 +358,11 @@ fn scan_exponent(rdr: @mut StringReader) -> Option<~str> {\n     let mut c = rdr.curr;\n     let mut rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n-        str::push_char(&mut rslt, c);\n+        rslt.push_char(c);\n         bump(rdr);\n         c = rdr.curr;\n         if c == '-' || c == '+' {\n-            str::push_char(&mut rslt, c);\n+            rslt.push_char(c);\n             bump(rdr);\n         }\n         let exponent = scan_digits(rdr, 10u);\n@@ -379,7 +379,7 @@ fn scan_digits(rdr: @mut StringReader, radix: uint) -> ~str {\n         if c == '_' { bump(rdr); loop; }\n         match char::to_digit(c, radix) {\n           Some(_) => {\n-            str::push_char(&mut rslt, c);\n+            rslt.push_char(c);\n             bump(rdr);\n           }\n           _ => return rslt\n@@ -721,31 +721,28 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                 let escaped = rdr.curr;\n                 bump(rdr);\n                 match escaped {\n-                  'n' => str::push_char(&mut accum_str, '\\n'),\n-                  'r' => str::push_char(&mut accum_str, '\\r'),\n-                  't' => str::push_char(&mut accum_str, '\\t'),\n-                  '\\\\' => str::push_char(&mut accum_str, '\\\\'),\n-                  '\\'' => str::push_char(&mut accum_str, '\\''),\n-                  '\"' => str::push_char(&mut accum_str, '\"'),\n+                  'n' => accum_str.push_char('\\n'),\n+                  'r' => accum_str.push_char('\\r'),\n+                  't' => accum_str.push_char('\\t'),\n+                  '\\\\' => accum_str.push_char('\\\\'),\n+                  '\\'' => accum_str.push_char('\\''),\n+                  '\"' => accum_str.push_char('\"'),\n                   '\\n' => consume_whitespace(rdr),\n                   'x' => {\n-                    str::push_char(&mut accum_str,\n-                                   scan_numeric_escape(rdr, 2u));\n+                    accum_str.push_char(scan_numeric_escape(rdr, 2u));\n                   }\n                   'u' => {\n-                    str::push_char(&mut accum_str,\n-                                   scan_numeric_escape(rdr, 4u));\n+                    accum_str.push_char(scan_numeric_escape(rdr, 4u));\n                   }\n                   'U' => {\n-                    str::push_char(&mut accum_str,\n-                                   scan_numeric_escape(rdr, 8u));\n+                    accum_str.push_char(scan_numeric_escape(rdr, 8u));\n                   }\n                   c2 => {\n                     rdr.fatal(fmt!(\"unknown string escape: %d\", c2 as int));\n                   }\n                 }\n               }\n-              _ => str::push_char(&mut accum_str, ch)\n+              _ => accum_str.push_char(ch)\n             }\n         }\n         bump(rdr);"}, {"sha": "5c77e698bec8b3866007c8e6c4658c83403e3f3a", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -79,7 +79,7 @@ fn make_random_fasta(wr: @io::Writer,\n     };\n     let mut op: ~str = ~\"\";\n     for uint::range(0u, n as uint) |_i| {\n-        str::push_char(&mut op, select_random(myrandom_next(rng, 100u32),\n+        op.push_char(select_random(myrandom_next(rng, 100u32),\n                                               copy genelist));\n         if op.len() >= LINE_LENGTH() {\n             wr.write_line(op);"}, {"sha": "972b9c7a525336bc12785160f6426c27b57f5e00", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -95,10 +95,10 @@ priv fn parse_response(io: @io::Reader) -> Result {\n \n priv fn cmd_to_str(cmd: ~[~str]) -> ~str {\n   let mut res = ~\"*\";\n-  str::push_str(&mut res, cmd.len().to_str());\n-  str::push_str(&mut res, \"\\r\\n\");\n+  res.push_str(cmd.len().to_str());\n+  res.push_str(\"\\r\\n\");\n     for cmd.each |s| {\n-    str::push_str(&mut res, str::concat(~[~\"$\", s.len().to_str(), ~\"\\r\\n\",\n+    res.push_str(str::concat(~[~\"$\", s.len().to_str(), ~\"\\r\\n\",\n                                           copy *s, ~\"\\r\\n\"]));\n     }\n   res"}, {"sha": "a3c2872803adce3cdb62aa6881d2f3b5c4954db7", "filename": "src/test/run-pass/move-out-of-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -6,7 +6,7 @@ struct StringBuffer {\n \n impl StringBuffer {\n     pub fn append(&mut self, v: &str) {\n-        str::push_str(&mut self.s, v);\n+        self.s.push_str(v);\n     }\n }\n "}, {"sha": "94990d649d82fd13f54f4bae7db4781b73ad7bab", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1553874149c3c37b94d75e9122092b131ba74c77/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1553874149c3c37b94d75e9122092b131ba74c77/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=1553874149c3c37b94d75e9122092b131ba74c77", "patch": "@@ -33,7 +33,7 @@ pub fn main() {\n     let mut stack = ~\"a\u00d7c\u20ac\";\n     assert_eq!(str::pop_char(&mut stack), '\u20ac');\n     assert_eq!(str::pop_char(&mut stack), 'c');\n-    str::push_char(&mut stack, 'u');\n+    stack.push_char('u');\n     assert!(stack == ~\"a\u00d7u\");\n     assert_eq!(str::shift_char(&mut stack), 'a');\n     assert_eq!(str::shift_char(&mut stack), '\u00d7');"}]}