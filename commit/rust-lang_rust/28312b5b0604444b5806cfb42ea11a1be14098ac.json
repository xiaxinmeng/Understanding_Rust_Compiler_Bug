{"sha": "28312b5b0604444b5806cfb42ea11a1be14098ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MzEyYjViMDYwNDQ0NGI1ODA2Y2ZiNDJlYTExYTFiZTE0MDk4YWM=", "commit": {"author": {"name": "Albin Stjerna", "email": "albin.stjerna@gmail.com", "date": "2019-08-19T13:56:16Z"}, "committer": {"name": "Albin Stjerna", "email": "albin.stjerna@gmail.com", "date": "2019-09-04T08:52:03Z"}, "message": "Rustfmt the files I touched", "tree": {"sha": "0a0f3ee3422e6bd6962eaec13c5ae06d1a0e57ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a0f3ee3422e6bd6962eaec13c5ae06d1a0e57ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28312b5b0604444b5806cfb42ea11a1be14098ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28312b5b0604444b5806cfb42ea11a1be14098ac", "html_url": "https://github.com/rust-lang/rust/commit/28312b5b0604444b5806cfb42ea11a1be14098ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28312b5b0604444b5806cfb42ea11a1be14098ac/comments", "author": null, "committer": null, "parents": [{"sha": "560ef6d7103f18581b1dcc57de480247ba638677", "url": "https://api.github.com/repos/rust-lang/rust/commits/560ef6d7103f18581b1dcc57de480247ba638677", "html_url": "https://github.com/rust-lang/rust/commit/560ef6d7103f18581b1dcc57de480247ba638677"}], "stats": {"total": 355, "additions": 187, "deletions": 168}, "files": [{"sha": "1ff3228afa376fc198b77732948152ac56b65b2c", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/28312b5b0604444b5806cfb42ea11a1be14098ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28312b5b0604444b5806cfb42ea11a1be14098ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=28312b5b0604444b5806cfb42ea11a1be14098ac", "patch": "@@ -11,7 +11,8 @@ use crate::transform::MirSource;\n use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n-use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Local, Location, Body, LocalKind, BasicBlock, Promoted};\n+use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements,\n+                 Local, Location, Body, LocalKind, BasicBlock, Promoted};\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::Diagnostic;\n@@ -72,11 +73,27 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n \n // This function populates an AllFacts instance with base facts related to\n // MovePaths and needed for the move analysis.\n-fn populate_polonius_move_facts(all_facts: &mut AllFacts, move_data: &MoveData<'_>, location_table: &LocationTable, body: &Body<'_>) {\n-    all_facts.path_belongs_to_var.extend(move_data.rev_lookup.iter_locals_enumerated().map(|(v, &m)| (m, v)));\n+fn populate_polonius_move_facts(\n+    all_facts: &mut AllFacts,\n+    move_data: &MoveData<'_>,\n+    location_table: &LocationTable,\n+    body: &Body<'_>) {\n+    all_facts\n+        .path_belongs_to_var\n+        .extend(\n+            move_data\n+                .rev_lookup\n+                .iter_locals_enumerated()\n+                .map(|(v, &m)| (m, v)));\n \n     for (child, move_path) in move_data.move_paths.iter_enumerated() {\n-        all_facts.child.extend(move_path.parents(&move_data.move_paths).iter().map(|&parent| (child, parent)));\n+        all_facts\n+            .child\n+            .extend(\n+                move_path\n+                    .parents(&move_data.move_paths)\n+                    .iter()\n+                    .map(|&parent| (child, parent)));\n     }\n \n     // initialized_at\n@@ -99,7 +116,9 @@ fn populate_polonius_move_facts(all_facts: &mut AllFacts, move_data: &MoveData<'\n                         // The initialization happened in (or rather, when arriving at)\n                         // the successors, but not in the unwind block.\n                         let first_statement = Location { block: successor, statement_index: 0};\n-                        all_facts.initialized_at.push((init.path, location_table.start_index(first_statement)));\n+                        all_facts\n+                            .initialized_at\n+                            .push((init.path, location_table.start_index(first_statement)));\n                     }\n \n                 } else {\n@@ -121,7 +140,13 @@ fn populate_polonius_move_facts(all_facts: &mut AllFacts, move_data: &MoveData<'\n \n     // moved_out_at\n     // deinitialisation is assumed to always happen!\n-    all_facts.moved_out_at.extend(move_data.moves.iter().map(|mo| (mo.path, location_table.mid_index(mo.source))));\n+    all_facts\n+        .moved_out_at\n+        .extend(\n+            move_data\n+                .moves\n+                .iter()\n+                .map(|mo| (mo.path, location_table.mid_index(mo.source))));\n }\n \n /// Computes the (non-lexical) regions from the input MIR."}, {"sha": "049d83bb22f1bc9cf48a56606bca4fdfb93adc02", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/28312b5b0604444b5806cfb42ea11a1be14098ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28312b5b0604444b5806cfb42ea11a1be14098ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=28312b5b0604444b5806cfb42ea11a1be14098ac", "patch": "@@ -1,7 +1,7 @@\n use crate::borrow_check::nll::region_infer::values::{PointIndex, RegionValueElements};\n use crate::util::liveness::{categorize, DefUse};\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{Local, Location, Body};\n+use rustc::mir::{Body, Local, Location};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::vec_linked_list as vll;\n \n@@ -72,16 +72,10 @@ impl LocalUseMap {\n \n         let mut locals_with_use_data: IndexVec<Local, bool> =\n             IndexVec::from_elem_n(false, body.local_decls.len());\n-        live_locals\n-            .iter()\n-            .for_each(|&local| locals_with_use_data[local] = true);\n-\n-        LocalUseMapBuild {\n-            local_use_map: &mut local_use_map,\n-            elements,\n-            locals_with_use_data,\n-        }\n-        .visit_body(body);\n+        live_locals.iter().for_each(|&local| locals_with_use_data[local] = true);\n+\n+        LocalUseMapBuild { local_use_map: &mut local_use_map, elements, locals_with_use_data }\n+            .visit_body(body);\n \n         local_use_map\n     }\n@@ -151,10 +145,8 @@ impl LocalUseMapBuild<'_> {\n         location: Location,\n     ) {\n         let point_index = elements.point_from_location(location);\n-        let appearance_index = appearances.push(Appearance {\n-            point_index,\n-            next: *first_appearance,\n-        });\n+        let appearance_index =\n+            appearances.push(Appearance { point_index, next: *first_appearance });\n         *first_appearance = Some(appearance_index);\n     }\n }"}, {"sha": "9b55881cb1b10162a4e24b3d7657748b043e90b5", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/28312b5b0604444b5806cfb42ea11a1be14098ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28312b5b0604444b5806cfb42ea11a1be14098ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=28312b5b0604444b5806cfb42ea11a1be14098ac", "patch": "@@ -394,12 +394,7 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n     ) {\n         debug!(\"add_use_live_facts_for(value={:?})\", value);\n \n-        Self::make_all_regions_live(\n-            self.elements,\n-            &mut self.typeck,\n-            value,\n-            live_at,\n-        )\n+        Self::make_all_regions_live(self.elements, &mut self.typeck, value, live_at)\n     }\n \n     /// Some variable with type `live_ty` is \"drop live\" at `location`\n@@ -450,12 +445,7 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n         // All things in the `outlives` array may be touched by\n         // the destructor and must be live at this point.\n         for &kind in &drop_data.dropck_result.kinds {\n-            Self::make_all_regions_live(\n-                self.elements,\n-                &mut self.typeck,\n-                kind,\n-                live_at,\n-            );\n+            Self::make_all_regions_live(self.elements, &mut self.typeck, kind, live_at);\n \n             polonius::add_var_drops_regions(&mut self.typeck, dropped_local, &kind);\n         }"}, {"sha": "d97f3b7417286806ca73f824fdacffb39988b660", "filename": "src/librustc_mir/dataflow/move_paths/abs_domain.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/28312b5b0604444b5806cfb42ea11a1be14098ac/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28312b5b0604444b5806cfb42ea11a1be14098ac/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs?ref=28312b5b0604444b5806cfb42ea11a1be14098ac", "patch": "@@ -11,7 +11,7 @@\n //! `a[x]` would still overlap them both. But that is not this\n //! representation does today.)\n \n-use rustc::mir::{Local, PlaceElem, Operand, ProjectionElem};\n+use rustc::mir::{Local, Operand, PlaceElem, ProjectionElem};\n use rustc::ty::Ty;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -26,36 +26,36 @@ pub trait Lift {\n }\n impl<'tcx> Lift for Operand<'tcx> {\n     type Abstract = AbstractOperand;\n-    fn lift(&self) -> Self::Abstract { AbstractOperand }\n+    fn lift(&self) -> Self::Abstract {\n+        AbstractOperand\n+    }\n }\n impl Lift for Local {\n     type Abstract = AbstractOperand;\n-    fn lift(&self) -> Self::Abstract { AbstractOperand }\n+    fn lift(&self) -> Self::Abstract {\n+        AbstractOperand\n+    }\n }\n impl<'tcx> Lift for Ty<'tcx> {\n     type Abstract = AbstractType;\n-    fn lift(&self) -> Self::Abstract { AbstractType }\n+    fn lift(&self) -> Self::Abstract {\n+        AbstractType\n+    }\n }\n impl<'tcx> Lift for PlaceElem<'tcx> {\n     type Abstract = AbstractElem;\n     fn lift(&self) -> Self::Abstract {\n         match *self {\n-            ProjectionElem::Deref =>\n-                ProjectionElem::Deref,\n-            ProjectionElem::Field(ref f, ty) =>\n-                ProjectionElem::Field(f.clone(), ty.lift()),\n-            ProjectionElem::Index(ref i) =>\n-                ProjectionElem::Index(i.lift()),\n-            ProjectionElem::Subslice {from, to} =>\n-                ProjectionElem::Subslice { from: from, to: to },\n-            ProjectionElem::ConstantIndex {offset,min_length,from_end} =>\n-                ProjectionElem::ConstantIndex {\n-                    offset,\n-                    min_length,\n-                    from_end,\n-                },\n-            ProjectionElem::Downcast(a, u) =>\n-                ProjectionElem::Downcast(a, u.clone()),\n+            ProjectionElem::Deref => ProjectionElem::Deref,\n+            ProjectionElem::Field(ref f, ty) => ProjectionElem::Field(f.clone(), ty.lift()),\n+            ProjectionElem::Index(ref i) => ProjectionElem::Index(i.lift()),\n+            ProjectionElem::Subslice { from, to } => {\n+                ProjectionElem::Subslice { from: from, to: to }\n+            }\n+            ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n+                ProjectionElem::ConstantIndex { offset, min_length, from_end }\n+            }\n+            ProjectionElem::Downcast(a, u) => ProjectionElem::Downcast(a, u.clone()),\n         }\n     }\n }"}, {"sha": "81451c2500c471bd1f9ca7bb7c9993a8f2fa420c", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 102, "deletions": 98, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/28312b5b0604444b5806cfb42ea11a1be14098ac/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28312b5b0604444b5806cfb42ea11a1be14098ac/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=28312b5b0604444b5806cfb42ea11a1be14098ac", "patch": "@@ -1,16 +1,18 @@\n-use rustc::ty::{self, TyCtxt};\n-use rustc::mir::*;\n use rustc::mir::tcx::RvalueInitializationState;\n-use rustc_data_structures::indexed_vec::{IndexVec};\n-use smallvec::{SmallVec, smallvec};\n+use rustc::mir::*;\n+use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use smallvec::{smallvec, SmallVec};\n \n use std::collections::hash_map::Entry;\n use std::mem;\n \n use super::abs_domain::Lift;\n-use super::{LocationMap, MoveData, MovePath, MovePathLookup, MovePathIndex, MoveOut, MoveOutIndex};\n-use super::{MoveError, InitIndex, Init, InitLocation, LookupResult, InitKind};\n use super::IllegalMoveOriginKind::*;\n+use super::{Init, InitIndex, InitKind, InitLocation, LookupResult, MoveError};\n+use super::{\n+    LocationMap, MoveData, MoveOut, MoveOutIndex, MovePath, MovePathIndex, MovePathLookup,\n+};\n \n struct MoveDataBuilder<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n@@ -33,43 +35,42 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                 moves: IndexVec::new(),\n                 loc_map: LocationMap::new(body),\n                 rev_lookup: MovePathLookup {\n-                    locals: body.local_decls.indices().map(|i| {\n-                        Self::new_move_path(\n-                            &mut move_paths,\n-                            &mut path_map,\n-                            &mut init_path_map,\n-                            None,\n-                            Place::from(i),\n-                        )\n-                    }).collect(),\n+                    locals: body\n+                        .local_decls\n+                        .indices()\n+                        .map(|i| {\n+                            Self::new_move_path(\n+                                &mut move_paths,\n+                                &mut path_map,\n+                                &mut init_path_map,\n+                                None,\n+                                Place::from(i),\n+                            )\n+                        })\n+                        .collect(),\n                     projections: Default::default(),\n                 },\n                 move_paths,\n                 path_map,\n                 inits: IndexVec::new(),\n                 init_loc_map: LocationMap::new(body),\n                 init_path_map,\n-            }\n+            },\n         }\n     }\n \n-    fn new_move_path(move_paths: &mut IndexVec<MovePathIndex, MovePath<'tcx>>,\n-                     path_map: &mut IndexVec<MovePathIndex, SmallVec<[MoveOutIndex; 4]>>,\n-                     init_path_map: &mut IndexVec<MovePathIndex, SmallVec<[InitIndex; 4]>>,\n-                     parent: Option<MovePathIndex>,\n-                     place: Place<'tcx>)\n-                     -> MovePathIndex\n-    {\n-        let move_path = move_paths.push(MovePath {\n-            next_sibling: None,\n-            first_child: None,\n-            parent,\n-            place,\n-        });\n+    fn new_move_path(\n+        move_paths: &mut IndexVec<MovePathIndex, MovePath<'tcx>>,\n+        path_map: &mut IndexVec<MovePathIndex, SmallVec<[MoveOutIndex; 4]>>,\n+        init_path_map: &mut IndexVec<MovePathIndex, SmallVec<[InitIndex; 4]>>,\n+        parent: Option<MovePathIndex>,\n+        place: Place<'tcx>,\n+    ) -> MovePathIndex {\n+        let move_path =\n+            move_paths.push(MovePath { next_sibling: None, first_child: None, parent, place });\n \n         if let Some(parent) = parent {\n-            let next_sibling =\n-                mem::replace(&mut move_paths[parent].first_child, Some(move_path));\n+            let next_sibling = mem::replace(&mut move_paths[parent].first_child, Some(move_path));\n             move_paths[move_path].next_sibling = next_sibling;\n         }\n \n@@ -91,9 +92,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     /// problematic for borrowck.\n     ///\n     /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n-    fn move_path_for(&mut self, place: &Place<'tcx>)\n-                     -> Result<MovePathIndex, MoveError<'tcx>>\n-    {\n+    fn move_path_for(&mut self, place: &Place<'tcx>) -> Result<MovePathIndex, MoveError<'tcx>> {\n         debug!(\"lookup({:?})\", place);\n         place.iterate(|place_base, place_projection| {\n             let mut base = match place_base {\n@@ -108,39 +107,46 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 let tcx = self.builder.tcx;\n                 let place_ty = Place::ty_from(place_base, &proj.base, body, tcx).ty;\n                 match place_ty.sty {\n-                    ty::Ref(..) | ty::RawPtr(..) =>\n+                    ty::Ref(..) | ty::RawPtr(..) => {\n                         return Err(MoveError::cannot_move_out_of(\n                             self.loc,\n                             BorrowedContent {\n                                 target_place: Place {\n                                     base: place_base.clone(),\n                                     projection: Some(Box::new(proj.clone())),\n-                                }\n-                            })),\n-                    ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n-                        return Err(MoveError::cannot_move_out_of(self.loc,\n-                                                                 InteriorOfTypeWithDestructor {\n-                            container_ty: place_ty\n-                        })),\n+                                },\n+                            },\n+                        ));\n+                    }\n+                    ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() => {\n+                        return Err(MoveError::cannot_move_out_of(\n+                            self.loc,\n+                            InteriorOfTypeWithDestructor { container_ty: place_ty },\n+                        ));\n+                    }\n                     // move out of union - always move the entire union\n-                    ty::Adt(adt, _) if adt.is_union() =>\n-                        return Err(MoveError::UnionMove { path: base }),\n-                    ty::Slice(_) =>\n+                    ty::Adt(adt, _) if adt.is_union() => {\n+                        return Err(MoveError::UnionMove { path: base });\n+                    }\n+                    ty::Slice(_) => {\n                         return Err(MoveError::cannot_move_out_of(\n                             self.loc,\n                             InteriorOfSliceOrArray {\n-                                ty: place_ty, is_index: match proj.elem {\n+                                ty: place_ty,\n+                                is_index: match proj.elem {\n                                     ProjectionElem::Index(..) => true,\n-                                    _ => false\n+                                    _ => false,\n                                 },\n-                            })),\n+                            },\n+                        ));\n+                    }\n                     ty::Array(..) => match proj.elem {\n-                        ProjectionElem::Index(..) =>\n+                        ProjectionElem::Index(..) => {\n                             return Err(MoveError::cannot_move_out_of(\n                                 self.loc,\n-                                InteriorOfSliceOrArray {\n-                                    ty: place_ty, is_index: true\n-                                })),\n+                                InteriorOfSliceOrArray { ty: place_ty, is_index: true },\n+                            ));\n+                        }\n                         _ => {\n                             // FIXME: still badly broken\n                         }\n@@ -186,7 +192,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n \n impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     fn finalize(\n-        self\n+        self,\n     ) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n         debug!(\"{}\", {\n             debug!(\"moves for {:?}:\", self.body.span);\n@@ -200,11 +206,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             \"done dumping moves\"\n         });\n \n-        if !self.errors.is_empty() {\n-            Err((self.data, self.errors))\n-        } else {\n-            Ok(self.data)\n-        }\n+        if !self.errors.is_empty() { Err((self.data, self.errors)) } else { Ok(self.data) }\n     }\n }\n \n@@ -222,10 +224,7 @@ pub(super) fn gather_moves<'tcx>(\n             builder.gather_statement(source, stmt);\n         }\n \n-        let terminator_loc = Location {\n-            block: bb,\n-            statement_index: block.statements.len()\n-        };\n+        let terminator_loc = Location { block: bb, statement_index: block.statements.len() };\n         builder.gather_terminator(terminator_loc, block.terminator());\n     }\n \n@@ -238,11 +237,12 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             let path = self.data.rev_lookup.locals[arg];\n \n             let init = self.data.inits.push(Init {\n-                path, kind: InitKind::Deep, location: InitLocation::Argument(arg),\n+                path,\n+                kind: InitKind::Deep,\n+                location: InitLocation::Argument(arg),\n             });\n \n-            debug!(\"gather_args: adding init {:?} of {:?} for argument {:?}\",\n-                init, path, arg);\n+            debug!(\"gather_args: adding init {:?} of {:?} for argument {:?}\", init, path, arg);\n \n             self.data.init_path_map[path].push(init);\n         }\n@@ -297,26 +297,26 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             StatementKind::StorageDead(local) => {\n                 self.gather_move(&Place::from(local));\n             }\n-            StatementKind::SetDiscriminant{ .. } => {\n-                span_bug!(stmt.source_info.span,\n-                          \"SetDiscriminant should not exist during borrowck\");\n+            StatementKind::SetDiscriminant { .. } => {\n+                span_bug!(\n+                    stmt.source_info.span,\n+                    \"SetDiscriminant should not exist during borrowck\"\n+                );\n             }\n-            StatementKind::Retag { .. } |\n-            StatementKind::AscribeUserType(..) |\n-            StatementKind::Nop => {}\n+            StatementKind::Retag { .. }\n+            | StatementKind::AscribeUserType(..)\n+            | StatementKind::Nop => {}\n         }\n     }\n \n     fn gather_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n         match *rvalue {\n-            Rvalue::Use(ref operand) |\n-            Rvalue::Repeat(ref operand, _) |\n-            Rvalue::Cast(_, ref operand, _) |\n-            Rvalue::UnaryOp(_, ref operand) => {\n-                self.gather_operand(operand)\n-            }\n-            Rvalue::BinaryOp(ref _binop, ref lhs, ref rhs) |\n-            Rvalue::CheckedBinaryOp(ref _binop, ref lhs, ref rhs) => {\n+            Rvalue::Use(ref operand)\n+            | Rvalue::Repeat(ref operand, _)\n+            | Rvalue::Cast(_, ref operand, _)\n+            | Rvalue::UnaryOp(_, ref operand) => self.gather_operand(operand),\n+            Rvalue::BinaryOp(ref _binop, ref lhs, ref rhs)\n+            | Rvalue::CheckedBinaryOp(ref _binop, ref lhs, ref rhs) => {\n                 self.gather_operand(lhs);\n                 self.gather_operand(rhs);\n             }\n@@ -325,11 +325,11 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                     self.gather_operand(operand);\n                 }\n             }\n-            Rvalue::Ref(..) |\n-            Rvalue::Discriminant(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::NullaryOp(NullOp::SizeOf, _) |\n-            Rvalue::NullaryOp(NullOp::Box, _) => {\n+            Rvalue::Ref(..)\n+            | Rvalue::Discriminant(..)\n+            | Rvalue::Len(..)\n+            | Rvalue::NullaryOp(NullOp::SizeOf, _)\n+            | Rvalue::NullaryOp(NullOp::Box, _) => {\n                 // This returns an rvalue with uninitialized contents. We can't\n                 // move out of it here because it is an rvalue - assignments always\n                 // completely initialize their place.\n@@ -346,13 +346,13 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n \n     fn gather_terminator(&mut self, term: &Terminator<'tcx>) {\n         match term.kind {\n-            TerminatorKind::Goto { target: _ } |\n-            TerminatorKind::Resume |\n-            TerminatorKind::Abort |\n-            TerminatorKind::GeneratorDrop |\n-            TerminatorKind::FalseEdges { .. } |\n-            TerminatorKind::FalseUnwind { .. } |\n-            TerminatorKind::Unreachable => { }\n+            TerminatorKind::Goto { target: _ }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::FalseEdges { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::Unreachable => {}\n \n             TerminatorKind::Return => {\n                 self.gather_move(&Place::RETURN_PLACE);\n@@ -399,9 +399,9 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n \n     fn gather_operand(&mut self, operand: &Operand<'tcx>) {\n         match *operand {\n-            Operand::Constant(..) |\n-            Operand::Copy(..) => {} // not-a-move\n-            Operand::Move(ref place) => { // a move\n+            Operand::Constant(..) | Operand::Copy(..) => {} // not-a-move\n+            Operand::Move(ref place) => {\n+                // a move\n                 self.gather_move(place);\n             }\n         }\n@@ -419,8 +419,10 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n         };\n         let move_out = self.builder.data.moves.push(MoveOut { path: path, source: self.loc });\n \n-        debug!(\"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n-               self.loc, place, move_out, path);\n+        debug!(\n+            \"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n+            self.loc, place, move_out, path\n+        );\n \n         self.builder.data.path_map[path].push(move_out);\n         self.builder.data.loc_map[self.loc].push(move_out);\n@@ -452,8 +454,10 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 kind,\n             });\n \n-            debug!(\"gather_init({:?}, {:?}): adding init {:?} of {:?}\",\n-               self.loc, place, init, path);\n+            debug!(\n+                \"gather_init({:?}, {:?}): adding init {:?} of {:?}\",\n+                self.loc, place, init, path\n+            );\n \n             self.builder.data.init_path_map[path].push(init);\n             self.builder.data.init_loc_map[self.loc].push(init);"}, {"sha": "5028e9650918c5d55a3e01ca0fc2ea53f07dbe47", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/28312b5b0604444b5806cfb42ea11a1be14098ac/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28312b5b0604444b5806cfb42ea11a1be14098ac/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=28312b5b0604444b5806cfb42ea11a1be14098ac", "patch": "@@ -1,10 +1,10 @@\n-use rustc::ty::{Ty, TyCtxt};\n+use core::slice::Iter;\n use rustc::mir::*;\n+use rustc::ty::{Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec, Enumerated};\n+use rustc_data_structures::indexed_vec::{Enumerated, Idx, IndexVec};\n use smallvec::SmallVec;\n-use syntax_pos::{Span};\n-use core::slice::Iter;\n+use syntax_pos::Span;\n \n use std::fmt;\n use std::ops::{Index, IndexMut};\n@@ -138,12 +138,17 @@ impl<T> IndexMut<Location> for LocationMap<T> {\n     }\n }\n \n-impl<T> LocationMap<T> where T: Default + Clone {\n+impl<T> LocationMap<T>\n+where\n+    T: Default + Clone,\n+{\n     fn new(body: &Body<'_>) -> Self {\n         LocationMap {\n-            map: body.basic_blocks().iter().map(|block| {\n-                vec![T::default(); block.statements.len()+1]\n-            }).collect()\n+            map: body\n+                .basic_blocks()\n+                .iter()\n+                .map(|block| vec![T::default(); block.statements.len() + 1])\n+                .collect(),\n         }\n     }\n }\n@@ -179,7 +184,6 @@ pub struct Init {\n     pub kind: InitKind,\n }\n \n-\n /// Initializations can be from an argument or from a statement. Arguments\n /// do not have locations, in those cases the `Local` is kept..\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -225,15 +229,15 @@ pub struct MovePathLookup {\n     /// subsequent search so that it is solely relative to that\n     /// base-place). For the remaining lookup, we map the projection\n     /// elem to the associated MovePathIndex.\n-    projections: FxHashMap<(MovePathIndex, AbstractElem), MovePathIndex>\n+    projections: FxHashMap<(MovePathIndex, AbstractElem), MovePathIndex>,\n }\n \n mod builder;\n \n #[derive(Copy, Clone, Debug)]\n pub enum LookupResult {\n     Exact(MovePathIndex),\n-    Parent(Option<MovePathIndex>)\n+    Parent(Option<MovePathIndex>),\n }\n \n impl MovePathLookup {\n@@ -296,7 +300,7 @@ pub(crate) enum IllegalMoveOriginKind<'tcx> {\n     InteriorOfTypeWithDestructor { container_ty: Ty<'tcx> },\n \n     /// Illegal move due to attempt to move out of a slice or array.\n-    InteriorOfSliceOrArray { ty: Ty<'tcx>, is_index: bool, },\n+    InteriorOfSliceOrArray { ty: Ty<'tcx>, is_index: bool },\n }\n \n #[derive(Debug)]\n@@ -325,11 +329,15 @@ impl<'tcx> MoveData<'tcx> {\n     pub fn base_local(&self, mut mpi: MovePathIndex) -> Option<Local> {\n         loop {\n             let path = &self.move_paths[mpi];\n-            if let Place {\n-                base: PlaceBase::Local(l),\n-                projection: None,\n-            } = path.place { return Some(l); }\n-            if let Some(parent) = path.parent { mpi = parent; continue } else { return None }\n+            if let Place { base: PlaceBase::Local(l), projection: None } = path.place {\n+                return Some(l);\n+            }\n+            if let Some(parent) = path.parent {\n+                mpi = parent;\n+                continue;\n+            } else {\n+                return None;\n+            }\n         }\n     }\n }"}]}