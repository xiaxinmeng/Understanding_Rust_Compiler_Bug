{"sha": "dfd3525cff90fe2363494559499276ca07d2aef7", "node_id": "C_kwDOAAsO6NoAKGRmZDM1MjVjZmY5MGZlMjM2MzQ5NDU1OTQ5OTI3NmNhMDdkMmFlZjc", "commit": {"author": {"name": "Samuel Moelius", "email": "sam@moeli.us", "date": "2022-10-01T01:10:10Z"}, "committer": {"name": "Samuel Moelius", "email": "sam@moeli.us", "date": "2022-10-15T11:01:44Z"}, "message": "Separate internal lints by pass", "tree": {"sha": "c3d786a1df72cf1b39b424beb72c917b7a09f32f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3d786a1df72cf1b39b424beb72c917b7a09f32f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfd3525cff90fe2363494559499276ca07d2aef7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfd3525cff90fe2363494559499276ca07d2aef7", "html_url": "https://github.com/rust-lang/rust/commit/dfd3525cff90fe2363494559499276ca07d2aef7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfd3525cff90fe2363494559499276ca07d2aef7/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50f192f86a12d4b39d8f7f061fbd8e0ba8007932", "url": "https://api.github.com/repos/rust-lang/rust/commits/50f192f86a12d4b39d8f7f061fbd8e0ba8007932", "html_url": "https://github.com/rust-lang/rust/commit/50f192f86a12d4b39d8f7f061fbd8e0ba8007932"}], "stats": {"total": 3306, "additions": 1702, "deletions": 1604}, "files": [{"sha": "40c94c6e8d33dc8101986d7ba7251433288adaa5", "filename": "clippy_lints/src/lib.register_internal.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Flib.register_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Flib.register_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_internal.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -3,20 +3,20 @@\n // Manual edits will be overwritten.\n \n store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n-    LintId::of(utils::internal_lints::CLIPPY_LINTS_INTERNAL),\n-    LintId::of(utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS),\n-    LintId::of(utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n-    LintId::of(utils::internal_lints::DEFAULT_DEPRECATION_REASON),\n-    LintId::of(utils::internal_lints::DEFAULT_LINT),\n-    LintId::of(utils::internal_lints::IF_CHAIN_STYLE),\n-    LintId::of(utils::internal_lints::INTERNING_DEFINED_SYMBOL),\n-    LintId::of(utils::internal_lints::INVALID_CLIPPY_VERSION_ATTRIBUTE),\n-    LintId::of(utils::internal_lints::INVALID_PATHS),\n-    LintId::of(utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n-    LintId::of(utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE),\n-    LintId::of(utils::internal_lints::MISSING_MSRV_ATTR_IMPL),\n-    LintId::of(utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n-    LintId::of(utils::internal_lints::PRODUCE_ICE),\n-    LintId::of(utils::internal_lints::UNNECESSARY_DEF_PATH),\n-    LintId::of(utils::internal_lints::UNNECESSARY_SYMBOL_STR),\n+    LintId::of(utils::internal_lints::clippy_lints_internal::CLIPPY_LINTS_INTERNAL),\n+    LintId::of(utils::internal_lints::collapsible_calls::COLLAPSIBLE_SPAN_LINT_CALLS),\n+    LintId::of(utils::internal_lints::compiler_lint_functions::COMPILER_LINT_FUNCTIONS),\n+    LintId::of(utils::internal_lints::if_chain_style::IF_CHAIN_STYLE),\n+    LintId::of(utils::internal_lints::interning_defined_symbol::INTERNING_DEFINED_SYMBOL),\n+    LintId::of(utils::internal_lints::interning_defined_symbol::UNNECESSARY_SYMBOL_STR),\n+    LintId::of(utils::internal_lints::invalid_paths::INVALID_PATHS),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::DEFAULT_DEPRECATION_REASON),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::DEFAULT_LINT),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::INVALID_CLIPPY_VERSION_ATTRIBUTE),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::LINT_WITHOUT_LINT_PASS),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::MISSING_CLIPPY_VERSION_ATTRIBUTE),\n+    LintId::of(utils::internal_lints::msrv_attr_impl::MISSING_MSRV_ATTR_IMPL),\n+    LintId::of(utils::internal_lints::outer_expn_data_pass::OUTER_EXPN_EXPN_DATA),\n+    LintId::of(utils::internal_lints::produce_ice::PRODUCE_ICE),\n+    LintId::of(utils::internal_lints::unnecessary_def_path::UNNECESSARY_DEF_PATH),\n ])"}, {"sha": "5609a4dc9ea074857530c7f923cee627f3ccbbe6", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -4,37 +4,37 @@\n \n store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::CLIPPY_LINTS_INTERNAL,\n+    utils::internal_lints::clippy_lints_internal::CLIPPY_LINTS_INTERNAL,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS,\n+    utils::internal_lints::collapsible_calls::COLLAPSIBLE_SPAN_LINT_CALLS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n+    utils::internal_lints::compiler_lint_functions::COMPILER_LINT_FUNCTIONS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::DEFAULT_DEPRECATION_REASON,\n+    utils::internal_lints::if_chain_style::IF_CHAIN_STYLE,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::DEFAULT_LINT,\n+    utils::internal_lints::interning_defined_symbol::INTERNING_DEFINED_SYMBOL,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::IF_CHAIN_STYLE,\n+    utils::internal_lints::interning_defined_symbol::UNNECESSARY_SYMBOL_STR,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::INTERNING_DEFINED_SYMBOL,\n+    utils::internal_lints::invalid_paths::INVALID_PATHS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::INVALID_CLIPPY_VERSION_ATTRIBUTE,\n+    utils::internal_lints::lint_without_lint_pass::DEFAULT_DEPRECATION_REASON,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::INVALID_PATHS,\n+    utils::internal_lints::lint_without_lint_pass::DEFAULT_LINT,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n+    utils::internal_lints::lint_without_lint_pass::INVALID_CLIPPY_VERSION_ATTRIBUTE,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n+    utils::internal_lints::lint_without_lint_pass::LINT_WITHOUT_LINT_PASS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::MISSING_MSRV_ATTR_IMPL,\n+    utils::internal_lints::lint_without_lint_pass::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n+    utils::internal_lints::msrv_attr_impl::MISSING_MSRV_ATTR_IMPL,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::PRODUCE_ICE,\n+    utils::internal_lints::outer_expn_data_pass::OUTER_EXPN_EXPN_DATA,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::UNNECESSARY_DEF_PATH,\n+    utils::internal_lints::produce_ice::PRODUCE_ICE,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n+    utils::internal_lints::unnecessary_def_path::UNNECESSARY_DEF_PATH,\n     almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE,\n     approx_const::APPROX_CONSTANT,\n     as_conversions::AS_CONVERSIONS,"}, {"sha": "b2ee58ec7ff7c5afce357de3fd59efe8ece2ce4a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -528,17 +528,23 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     // all the internal lints\n     #[cfg(feature = \"internal\")]\n     {\n-        store.register_early_pass(|| Box::new(utils::internal_lints::ClippyLintsInternal));\n-        store.register_early_pass(|| Box::new(utils::internal_lints::ProduceIce));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::CollapsibleCalls));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::CompilerLintFunctions::new()));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::IfChainStyle));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::InvalidPaths));\n-        store.register_late_pass(|_| Box::<utils::internal_lints::InterningDefinedSymbol>::default());\n-        store.register_late_pass(|_| Box::<utils::internal_lints::LintWithoutLintPass>::default());\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::UnnecessaryDefPath));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::OuterExpnDataPass));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::MsrvAttrImpl));\n+        store.register_early_pass(|| Box::new(utils::internal_lints::clippy_lints_internal::ClippyLintsInternal));\n+        store.register_early_pass(|| Box::new(utils::internal_lints::produce_ice::ProduceIce));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::collapsible_calls::CollapsibleCalls));\n+        store.register_late_pass(|_| {\n+            Box::new(utils::internal_lints::compiler_lint_functions::CompilerLintFunctions::new())\n+        });\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::if_chain_style::IfChainStyle));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::invalid_paths::InvalidPaths));\n+        store.register_late_pass(|_| {\n+            Box::<utils::internal_lints::interning_defined_symbol::InterningDefinedSymbol>::default()\n+        });\n+        store.register_late_pass(|_| {\n+            Box::<utils::internal_lints::lint_without_lint_pass::LintWithoutLintPass>::default()\n+        });\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::unnecessary_def_path::UnnecessaryDefPath));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::outer_expn_data_pass::OuterExpnDataPass));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::msrv_attr_impl::MsrvAttrImpl));\n     }\n \n     let arithmetic_side_effects_allowed = conf.arithmetic_side_effects_allowed.clone();"}, {"sha": "71f6c9909ddda5881d6d9e5f181e20154516e879", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 11, "deletions": 1559, "changes": 1570, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -1,1560 +1,12 @@\n-use crate::utils::internal_lints::metadata_collector::is_deprecated_lint;\n-use clippy_utils::consts::{constant_simple, Constant};\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::macros::root_macro_call_first_node;\n-use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::ty::match_type;\n-use clippy_utils::{\n-    def_path_res, higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_any_def_paths,\n-    match_def_path, method_calls, paths, peel_blocks_with_stmt, peel_hir_expr_refs, SpanlessEq,\n-};\n-use if_chain::if_chain;\n-use rustc_ast as ast;\n-use rustc_ast::ast::{Crate, ItemKind, LitKind, ModKind, NodeId};\n-use rustc_ast::visit::FnKind;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Namespace, Res};\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::hir_id::CRATE_HIR_ID;\n-use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{\n-    BinOpKind, Block, Closure, Expr, ExprKind, HirId, Item, Local, MutTy, Mutability, Node, Path, Stmt, StmtKind,\n-    TyKind, UnOp,\n-};\n-use rustc_hir_analysis::hir_ty_to_ty;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::nested_filter;\n-use rustc_middle::mir::interpret::{Allocation, ConstValue, GlobalAlloc};\n-use rustc_middle::ty::{\n-    self, fast_reject::SimplifiedTypeGen, subst::GenericArgKind, AssocKind, DefIdTree, FloatTy, Ty,\n-};\n-use rustc_semver::RustcVersion;\n-use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{Ident, Symbol};\n-use rustc_span::{sym, BytePos, Span};\n-\n-use std::borrow::{Borrow, Cow};\n-use std::str;\n-\n-#[cfg(feature = \"internal\")]\n+pub mod clippy_lints_internal;\n+pub mod collapsible_calls;\n+pub mod compiler_lint_functions;\n+pub mod if_chain_style;\n+pub mod interning_defined_symbol;\n+pub mod invalid_paths;\n+pub mod lint_without_lint_pass;\n pub mod metadata_collector;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for various things we like to keep tidy in clippy.\n-    ///\n-    /// ### Why is this bad?\n-    /// We like to pretend we're an example of tidy code.\n-    ///\n-    /// ### Example\n-    /// Wrong ordering of the util::paths constants.\n-    pub CLIPPY_LINTS_INTERNAL,\n-    internal,\n-    \"various things that will negatively affect your clippy experience\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Ensures every lint is associated to a `LintPass`.\n-    ///\n-    /// ### Why is this bad?\n-    /// The compiler only knows lints via a `LintPass`. Without\n-    /// putting a lint to a `LintPass::get_lints()`'s return, the compiler will not\n-    /// know the name of the lint.\n-    ///\n-    /// ### Known problems\n-    /// Only checks for lints associated using the\n-    /// `declare_lint_pass!`, `impl_lint_pass!`, and `lint_array!` macros.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// declare_lint! { pub LINT_1, ... }\n-    /// declare_lint! { pub LINT_2, ... }\n-    /// declare_lint! { pub FORGOTTEN_LINT, ... }\n-    /// // ...\n-    /// declare_lint_pass!(Pass => [LINT_1, LINT_2]);\n-    /// // missing FORGOTTEN_LINT\n-    /// ```\n-    pub LINT_WITHOUT_LINT_PASS,\n-    internal,\n-    \"declaring a lint without associating it in a LintPass\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for calls to `cx.span_lint*` and suggests to use the `utils::*`\n-    /// variant of the function.\n-    ///\n-    /// ### Why is this bad?\n-    /// The `utils::*` variants also add a link to the Clippy documentation to the\n-    /// warning/error messages.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// cx.span_lint(LINT_NAME, \"message\");\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// utils::span_lint(cx, LINT_NAME, \"message\");\n-    /// ```\n-    pub COMPILER_LINT_FUNCTIONS,\n-    internal,\n-    \"usage of the lint functions of the compiler instead of the utils::* variant\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for calls to `cx.outer().expn_data()` and suggests to use\n-    /// the `cx.outer_expn_data()`\n-    ///\n-    /// ### Why is this bad?\n-    /// `cx.outer_expn_data()` is faster and more concise.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// expr.span.ctxt().outer().expn_data()\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// expr.span.ctxt().outer_expn_data()\n-    /// ```\n-    pub OUTER_EXPN_EXPN_DATA,\n-    internal,\n-    \"using `cx.outer_expn().expn_data()` instead of `cx.outer_expn_data()`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Not an actual lint. This lint is only meant for testing our customized internal compiler\n-    /// error message by calling `panic`.\n-    ///\n-    /// ### Why is this bad?\n-    /// ICE in large quantities can damage your teeth\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// \ud83c\udf66\ud83c\udf66\ud83c\udf66\ud83c\udf66\ud83c\udf66\n-    /// ```\n-    pub PRODUCE_ICE,\n-    internal,\n-    \"this message should not appear anywhere as we ICE before and don't emit the lint\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for cases of an auto-generated lint without an updated description,\n-    /// i.e. `default lint description`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Indicates that the lint is not finished.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// declare_lint! { pub COOL_LINT, nursery, \"default lint description\" }\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// declare_lint! { pub COOL_LINT, nursery, \"a great new lint\" }\n-    /// ```\n-    pub DEFAULT_LINT,\n-    internal,\n-    \"found 'default lint description' in a lint declaration\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Lints `span_lint_and_then` function calls, where the\n-    /// closure argument has only one statement and that statement is a method\n-    /// call to `span_suggestion`, `span_help`, `span_note` (using the same\n-    /// span), `help` or `note`.\n-    ///\n-    /// These usages of `span_lint_and_then` should be replaced with one of the\n-    /// wrapper functions `span_lint_and_sugg`, span_lint_and_help`, or\n-    /// `span_lint_and_note`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Using the wrapper `span_lint_and_*` functions, is more\n-    /// convenient, readable and less error prone.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.span_suggestion(\n-    ///         expr.span,\n-    ///         help_msg,\n-    ///         sugg.to_string(),\n-    ///         Applicability::MachineApplicable,\n-    ///     );\n-    /// });\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.span_help(expr.span, help_msg);\n-    /// });\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.help(help_msg);\n-    /// });\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.span_note(expr.span, note_msg);\n-    /// });\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.note(note_msg);\n-    /// });\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// span_lint_and_sugg(\n-    ///     cx,\n-    ///     TEST_LINT,\n-    ///     expr.span,\n-    ///     lint_msg,\n-    ///     help_msg,\n-    ///     sugg.to_string(),\n-    ///     Applicability::MachineApplicable,\n-    /// );\n-    /// span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), help_msg);\n-    /// span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, None, help_msg);\n-    /// span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), note_msg);\n-    /// span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, None, note_msg);\n-    /// ```\n-    pub COLLAPSIBLE_SPAN_LINT_CALLS,\n-    internal,\n-    \"found collapsible `span_lint_and_then` calls\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for usages of def paths when a diagnostic item or a `LangItem` could be used.\n-    ///\n-    /// ### Why is this bad?\n-    /// The path for an item is subject to change and is less efficient to look up than a\n-    /// diagnostic item or a `LangItem`.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// utils::match_type(cx, ty, &paths::VEC)\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// utils::is_type_diagnostic_item(cx, ty, sym::Vec)\n-    /// ```\n-    pub UNNECESSARY_DEF_PATH,\n-    internal,\n-    \"using a def path when a diagnostic item or a `LangItem` is available\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks the paths module for invalid paths.\n-    ///\n-    /// ### Why is this bad?\n-    /// It indicates a bug in the code.\n-    ///\n-    /// ### Example\n-    /// None.\n-    pub INVALID_PATHS,\n-    internal,\n-    \"invalid path\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for interning symbols that have already been pre-interned and defined as constants.\n-    ///\n-    /// ### Why is this bad?\n-    /// It's faster and easier to use the symbol constant.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// let _ = sym!(f32);\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// let _ = sym::f32;\n-    /// ```\n-    pub INTERNING_DEFINED_SYMBOL,\n-    internal,\n-    \"interning a symbol that is pre-interned and defined as a constant\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for unnecessary conversion from Symbol to a string.\n-    ///\n-    /// ### Why is this bad?\n-    /// It's faster use symbols directly instead of strings.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// symbol.as_str() == \"clippy\";\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// symbol == sym::clippy;\n-    /// ```\n-    pub UNNECESSARY_SYMBOL_STR,\n-    internal,\n-    \"unnecessary conversion between Symbol and string\"\n-}\n-\n-declare_clippy_lint! {\n-    /// Finds unidiomatic usage of `if_chain!`\n-    pub IF_CHAIN_STYLE,\n-    internal,\n-    \"non-idiomatic `if_chain!` usage\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for invalid `clippy::version` attributes.\n-    ///\n-    /// Valid values are:\n-    /// * \"pre 1.29.0\"\n-    /// * any valid semantic version\n-    pub INVALID_CLIPPY_VERSION_ATTRIBUTE,\n-    internal,\n-    \"found an invalid `clippy::version` attribute\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for declared clippy lints without the `clippy::version` attribute.\n-    ///\n-    pub MISSING_CLIPPY_VERSION_ATTRIBUTE,\n-    internal,\n-    \"found clippy lint without `clippy::version` attribute\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Check that the `extract_msrv_attr!` macro is used, when a lint has a MSRV.\n-    ///\n-    pub MISSING_MSRV_ATTR_IMPL,\n-    internal,\n-    \"checking if all necessary steps were taken when adding a MSRV to a lint\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for cases of an auto-generated deprecated lint without an updated reason,\n-    /// i.e. `\"default deprecation note\"`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Indicates that the documentation is incomplete.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// declare_deprecated_lint! {\n-    ///     /// ### What it does\n-    ///     /// Nothing. This lint has been deprecated.\n-    ///     ///\n-    ///     /// ### Deprecation reason\n-    ///     /// TODO\n-    ///     #[clippy::version = \"1.63.0\"]\n-    ///     pub COOL_LINT,\n-    ///     \"default deprecation note\"\n-    /// }\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// declare_deprecated_lint! {\n-    ///     /// ### What it does\n-    ///     /// Nothing. This lint has been deprecated.\n-    ///     ///\n-    ///     /// ### Deprecation reason\n-    ///     /// This lint has been replaced by `cooler_lint`\n-    ///     #[clippy::version = \"1.63.0\"]\n-    ///     pub COOL_LINT,\n-    ///     \"this lint has been replaced by `cooler_lint`\"\n-    /// }\n-    /// ```\n-    pub DEFAULT_DEPRECATION_REASON,\n-    internal,\n-    \"found 'default deprecation note' in a deprecated lint declaration\"\n-}\n-\n-declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n-\n-impl EarlyLintPass for ClippyLintsInternal {\n-    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &Crate) {\n-        if let Some(utils) = krate.items.iter().find(|item| item.ident.name.as_str() == \"utils\") {\n-            if let ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) = utils.kind {\n-                if let Some(paths) = items.iter().find(|item| item.ident.name.as_str() == \"paths\") {\n-                    if let ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) = paths.kind {\n-                        let mut last_name: Option<&str> = None;\n-                        for item in items {\n-                            let name = item.ident.as_str();\n-                            if let Some(last_name) = last_name {\n-                                if *last_name > *name {\n-                                    span_lint(\n-                                        cx,\n-                                        CLIPPY_LINTS_INTERNAL,\n-                                        item.span,\n-                                        \"this constant should be before the previous constant due to lexical \\\n-                                         ordering\",\n-                                    );\n-                                }\n-                            }\n-                            last_name = Some(name);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, Default)]\n-pub struct LintWithoutLintPass {\n-    declared_lints: FxHashMap<Symbol, Span>,\n-    registered_lints: FxHashSet<Symbol>,\n-}\n-\n-impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS, INVALID_CLIPPY_VERSION_ATTRIBUTE, MISSING_CLIPPY_VERSION_ATTRIBUTE, DEFAULT_DEPRECATION_REASON]);\n-\n-impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if is_lint_allowed(cx, DEFAULT_LINT, item.hir_id())\n-            || is_lint_allowed(cx, DEFAULT_DEPRECATION_REASON, item.hir_id())\n-        {\n-            return;\n-        }\n-\n-        if let hir::ItemKind::Static(ty, Mutability::Not, body_id) = item.kind {\n-            let is_lint_ref_ty = is_lint_ref_type(cx, ty);\n-            if is_deprecated_lint(cx, ty) || is_lint_ref_ty {\n-                check_invalid_clippy_version_attribute(cx, item);\n-\n-                let expr = &cx.tcx.hir().body(body_id).value;\n-                let fields;\n-                if is_lint_ref_ty {\n-                    if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind\n-                        && let ExprKind::Struct(_, struct_fields, _) = inner_exp.kind {\n-                            fields = struct_fields;\n-                    } else {\n-                        return;\n-                    }\n-                } else if let ExprKind::Struct(_, struct_fields, _) = expr.kind {\n-                    fields = struct_fields;\n-                } else {\n-                    return;\n-                }\n-\n-                let field = fields\n-                    .iter()\n-                    .find(|f| f.ident.as_str() == \"desc\")\n-                    .expect(\"lints must have a description field\");\n-\n-                if let ExprKind::Lit(Spanned {\n-                    node: LitKind::Str(ref sym, _),\n-                    ..\n-                }) = field.expr.kind\n-                {\n-                    let sym_str = sym.as_str();\n-                    if is_lint_ref_ty {\n-                        if sym_str == \"default lint description\" {\n-                            span_lint(\n-                                cx,\n-                                DEFAULT_LINT,\n-                                item.span,\n-                                &format!(\"the lint `{}` has the default lint description\", item.ident.name),\n-                            );\n-                        }\n-\n-                        self.declared_lints.insert(item.ident.name, item.span);\n-                    } else if sym_str == \"default deprecation note\" {\n-                        span_lint(\n-                            cx,\n-                            DEFAULT_DEPRECATION_REASON,\n-                            item.span,\n-                            &format!(\"the lint `{}` has the default deprecation reason\", item.ident.name),\n-                        );\n-                    }\n-                }\n-            }\n-        } else if let Some(macro_call) = root_macro_call_first_node(cx, item) {\n-            if !matches!(\n-                cx.tcx.item_name(macro_call.def_id).as_str(),\n-                \"impl_lint_pass\" | \"declare_lint_pass\"\n-            ) {\n-                return;\n-            }\n-            if let hir::ItemKind::Impl(hir::Impl {\n-                of_trait: None,\n-                items: impl_item_refs,\n-                ..\n-            }) = item.kind\n-            {\n-                let mut collector = LintCollector {\n-                    output: &mut self.registered_lints,\n-                    cx,\n-                };\n-                let body_id = cx.tcx.hir().body_owned_by(\n-                    cx.tcx.hir().local_def_id(\n-                        impl_item_refs\n-                            .iter()\n-                            .find(|iiref| iiref.ident.as_str() == \"get_lints\")\n-                            .expect(\"LintPass needs to implement get_lints\")\n-                            .id\n-                            .hir_id(),\n-                    ),\n-                );\n-                collector.visit_expr(cx.tcx.hir().body(body_id).value);\n-            }\n-        }\n-    }\n-\n-    fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n-        if is_lint_allowed(cx, LINT_WITHOUT_LINT_PASS, CRATE_HIR_ID) {\n-            return;\n-        }\n-\n-        for (lint_name, &lint_span) in &self.declared_lints {\n-            // When using the `declare_tool_lint!` macro, the original `lint_span`'s\n-            // file points to \"<rustc macros>\".\n-            // `compiletest-rs` thinks that's an error in a different file and\n-            // just ignores it. This causes the test in compile-fail/lint_pass\n-            // not able to capture the error.\n-            // Therefore, we need to climb the macro expansion tree and find the\n-            // actual span that invoked `declare_tool_lint!`:\n-            let lint_span = lint_span.ctxt().outer_expn_data().call_site;\n-\n-            if !self.registered_lints.contains(lint_name) {\n-                span_lint(\n-                    cx,\n-                    LINT_WITHOUT_LINT_PASS,\n-                    lint_span,\n-                    &format!(\"the lint `{lint_name}` is not added to any `LintPass`\"),\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &hir::Ty<'_>) -> bool {\n-    if let TyKind::Rptr(\n-        _,\n-        MutTy {\n-            ty: inner,\n-            mutbl: Mutability::Not,\n-        },\n-    ) = ty.kind\n-    {\n-        if let TyKind::Path(ref path) = inner.kind {\n-            if let Res::Def(DefKind::Struct, def_id) = cx.qpath_res(path, inner.hir_id) {\n-                return match_def_path(cx, def_id, &paths::LINT);\n-            }\n-        }\n-    }\n-\n-    false\n-}\n-\n-fn check_invalid_clippy_version_attribute(cx: &LateContext<'_>, item: &'_ Item<'_>) {\n-    if let Some(value) = extract_clippy_version_value(cx, item) {\n-        // The `sym!` macro doesn't work as it only expects a single token.\n-        // It's better to keep it this way and have a direct `Symbol::intern` call here.\n-        if value == Symbol::intern(\"pre 1.29.0\") {\n-            return;\n-        }\n-\n-        if RustcVersion::parse(value.as_str()).is_err() {\n-            span_lint_and_help(\n-                cx,\n-                INVALID_CLIPPY_VERSION_ATTRIBUTE,\n-                item.span,\n-                \"this item has an invalid `clippy::version` attribute\",\n-                None,\n-                \"please use a valid semantic version, see `doc/adding_lints.md`\",\n-            );\n-        }\n-    } else {\n-        span_lint_and_help(\n-            cx,\n-            MISSING_CLIPPY_VERSION_ATTRIBUTE,\n-            item.span,\n-            \"this lint is missing the `clippy::version` attribute or version value\",\n-            None,\n-            \"please use a `clippy::version` attribute, see `doc/adding_lints.md`\",\n-        );\n-    }\n-}\n-\n-/// This function extracts the version value of a `clippy::version` attribute if the given value has\n-/// one\n-fn extract_clippy_version_value(cx: &LateContext<'_>, item: &'_ Item<'_>) -> Option<Symbol> {\n-    let attrs = cx.tcx.hir().attrs(item.hir_id());\n-    attrs.iter().find_map(|attr| {\n-        if_chain! {\n-            // Identify attribute\n-            if let ast::AttrKind::Normal(ref attr_kind) = &attr.kind;\n-            if let [tool_name, attr_name] = &attr_kind.item.path.segments[..];\n-            if tool_name.ident.name == sym::clippy;\n-            if attr_name.ident.name == sym::version;\n-            if let Some(version) = attr.value_str();\n-            then {\n-                Some(version)\n-            } else {\n-                None\n-            }\n-        }\n-    })\n-}\n-\n-struct LintCollector<'a, 'tcx> {\n-    output: &'a mut FxHashSet<Symbol>,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for LintCollector<'a, 'tcx> {\n-    type NestedFilter = nested_filter::All;\n-\n-    fn visit_path(&mut self, path: &'tcx Path<'_>, _: HirId) {\n-        if path.segments.len() == 1 {\n-            self.output.insert(path.segments[0].ident.name);\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.cx.tcx.hir()\n-    }\n-}\n-\n-#[derive(Clone, Default)]\n-pub struct CompilerLintFunctions {\n-    map: FxHashMap<&'static str, &'static str>,\n-}\n-\n-impl CompilerLintFunctions {\n-    #[must_use]\n-    pub fn new() -> Self {\n-        let mut map = FxHashMap::default();\n-        map.insert(\"span_lint\", \"utils::span_lint\");\n-        map.insert(\"struct_span_lint\", \"utils::span_lint\");\n-        map.insert(\"lint\", \"utils::span_lint\");\n-        map.insert(\"span_lint_note\", \"utils::span_lint_and_note\");\n-        map.insert(\"span_lint_help\", \"utils::span_lint_and_help\");\n-        Self { map }\n-    }\n-}\n-\n-impl_lint_pass!(CompilerLintFunctions => [COMPILER_LINT_FUNCTIONS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if is_lint_allowed(cx, COMPILER_LINT_FUNCTIONS, expr.hir_id) {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::MethodCall(path, self_arg, _, _) = &expr.kind;\n-            let fn_name = path.ident;\n-            if let Some(sugg) = self.map.get(fn_name.as_str());\n-            let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n-            if match_type(cx, ty, &paths::EARLY_CONTEXT)\n-                || match_type(cx, ty, &paths::LATE_CONTEXT);\n-            then {\n-                span_lint_and_help(\n-                    cx,\n-                    COMPILER_LINT_FUNCTIONS,\n-                    path.ident.span,\n-                    \"usage of a compiler lint function\",\n-                    None,\n-                    &format!(\"please use the Clippy variant of this function: `{sugg}`\"),\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint_pass!(OuterExpnDataPass => [OUTER_EXPN_EXPN_DATA]);\n-\n-impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if is_lint_allowed(cx, OUTER_EXPN_EXPN_DATA, expr.hir_id) {\n-            return;\n-        }\n-\n-        let (method_names, arg_lists, spans) = method_calls(expr, 2);\n-        let method_names: Vec<&str> = method_names.iter().map(Symbol::as_str).collect();\n-        if_chain! {\n-            if let [\"expn_data\", \"outer_expn\"] = method_names.as_slice();\n-            let (self_arg, args)= arg_lists[1];\n-            if args.is_empty();\n-            let self_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n-            if match_type(cx, self_ty, &paths::SYNTAX_CONTEXT);\n-            then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    OUTER_EXPN_EXPN_DATA,\n-                    spans[1].with_hi(expr.span.hi()),\n-                    \"usage of `outer_expn().expn_data()`\",\n-                    \"try\",\n-                    \"outer_expn_data()\".to_string(),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint_pass!(ProduceIce => [PRODUCE_ICE]);\n-\n-impl EarlyLintPass for ProduceIce {\n-    fn check_fn(&mut self, _: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: Span, _: NodeId) {\n-        assert!(!is_trigger_fn(fn_kind), \"Would you like some help with that?\");\n-    }\n-}\n-\n-fn is_trigger_fn(fn_kind: FnKind<'_>) -> bool {\n-    match fn_kind {\n-        FnKind::Fn(_, ident, ..) => ident.name.as_str() == \"it_looks_like_you_are_trying_to_kill_clippy\",\n-        FnKind::Closure(..) => false,\n-    }\n-}\n-\n-declare_lint_pass!(CollapsibleCalls => [COLLAPSIBLE_SPAN_LINT_CALLS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if is_lint_allowed(cx, COLLAPSIBLE_SPAN_LINT_CALLS, expr.hir_id) {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::Call(func, and_then_args) = expr.kind;\n-            if is_expr_path_def_path(cx, func, &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_then\"]);\n-            if and_then_args.len() == 5;\n-            if let ExprKind::Closure(&Closure { body, .. }) = &and_then_args[4].kind;\n-            let body = cx.tcx.hir().body(body);\n-            let only_expr = peel_blocks_with_stmt(body.value);\n-            if let ExprKind::MethodCall(ps, recv, span_call_args, _) = &only_expr.kind;\n-            if let ExprKind::Path(..) = recv.kind;\n-            then {\n-                let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n-                let mut sle = SpanlessEq::new(cx).deny_side_effects();\n-                match ps.ident.as_str() {\n-                    \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n-                        suggest_suggestion(cx, expr, &and_then_snippets, &span_suggestion_snippets(cx, span_call_args));\n-                    },\n-                    \"span_help\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n-                        let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n-                        suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), true);\n-                    },\n-                    \"span_note\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n-                        let note_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n-                        suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), true);\n-                    },\n-                    \"help\" => {\n-                        let help_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n-                        suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), false);\n-                    }\n-                    \"note\" => {\n-                        let note_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n-                        suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), false);\n-                    }\n-                    _  => (),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-struct AndThenSnippets<'a> {\n-    cx: Cow<'a, str>,\n-    lint: Cow<'a, str>,\n-    span: Cow<'a, str>,\n-    msg: Cow<'a, str>,\n-}\n-\n-fn get_and_then_snippets<'a, 'hir>(cx: &LateContext<'_>, and_then_snippets: &'hir [Expr<'hir>]) -> AndThenSnippets<'a> {\n-    let cx_snippet = snippet(cx, and_then_snippets[0].span, \"cx\");\n-    let lint_snippet = snippet(cx, and_then_snippets[1].span, \"..\");\n-    let span_snippet = snippet(cx, and_then_snippets[2].span, \"span\");\n-    let msg_snippet = snippet(cx, and_then_snippets[3].span, r#\"\"...\"\"#);\n-\n-    AndThenSnippets {\n-        cx: cx_snippet,\n-        lint: lint_snippet,\n-        span: span_snippet,\n-        msg: msg_snippet,\n-    }\n-}\n-\n-struct SpanSuggestionSnippets<'a> {\n-    help: Cow<'a, str>,\n-    sugg: Cow<'a, str>,\n-    applicability: Cow<'a, str>,\n-}\n-\n-fn span_suggestion_snippets<'a, 'hir>(\n-    cx: &LateContext<'_>,\n-    span_call_args: &'hir [Expr<'hir>],\n-) -> SpanSuggestionSnippets<'a> {\n-    let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n-    let sugg_snippet = snippet(cx, span_call_args[2].span, \"..\");\n-    let applicability_snippet = snippet(cx, span_call_args[3].span, \"Applicability::MachineApplicable\");\n-\n-    SpanSuggestionSnippets {\n-        help: help_snippet,\n-        sugg: sugg_snippet,\n-        applicability: applicability_snippet,\n-    }\n-}\n-\n-fn suggest_suggestion(\n-    cx: &LateContext<'_>,\n-    expr: &Expr<'_>,\n-    and_then_snippets: &AndThenSnippets<'_>,\n-    span_suggestion_snippets: &SpanSuggestionSnippets<'_>,\n-) {\n-    span_lint_and_sugg(\n-        cx,\n-        COLLAPSIBLE_SPAN_LINT_CALLS,\n-        expr.span,\n-        \"this call is collapsible\",\n-        \"collapse into\",\n-        format!(\n-            \"span_lint_and_sugg({}, {}, {}, {}, {}, {}, {})\",\n-            and_then_snippets.cx,\n-            and_then_snippets.lint,\n-            and_then_snippets.span,\n-            and_then_snippets.msg,\n-            span_suggestion_snippets.help,\n-            span_suggestion_snippets.sugg,\n-            span_suggestion_snippets.applicability\n-        ),\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n-fn suggest_help(\n-    cx: &LateContext<'_>,\n-    expr: &Expr<'_>,\n-    and_then_snippets: &AndThenSnippets<'_>,\n-    help: &str,\n-    with_span: bool,\n-) {\n-    let option_span = if with_span {\n-        format!(\"Some({})\", and_then_snippets.span)\n-    } else {\n-        \"None\".to_string()\n-    };\n-\n-    span_lint_and_sugg(\n-        cx,\n-        COLLAPSIBLE_SPAN_LINT_CALLS,\n-        expr.span,\n-        \"this call is collapsible\",\n-        \"collapse into\",\n-        format!(\n-            \"span_lint_and_help({}, {}, {}, {}, {}, {help})\",\n-            and_then_snippets.cx, and_then_snippets.lint, and_then_snippets.span, and_then_snippets.msg, &option_span,\n-        ),\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n-fn suggest_note(\n-    cx: &LateContext<'_>,\n-    expr: &Expr<'_>,\n-    and_then_snippets: &AndThenSnippets<'_>,\n-    note: &str,\n-    with_span: bool,\n-) {\n-    let note_span = if with_span {\n-        format!(\"Some({})\", and_then_snippets.span)\n-    } else {\n-        \"None\".to_string()\n-    };\n-\n-    span_lint_and_sugg(\n-        cx,\n-        COLLAPSIBLE_SPAN_LINT_CALLS,\n-        expr.span,\n-        \"this call is collapsible\",\n-        \"collapse into\",\n-        format!(\n-            \"span_lint_and_note({}, {}, {}, {}, {note_span}, {note})\",\n-            and_then_snippets.cx, and_then_snippets.lint, and_then_snippets.span, and_then_snippets.msg,\n-        ),\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n-declare_lint_pass!(UnnecessaryDefPath => [UNNECESSARY_DEF_PATH]);\n-\n-#[allow(clippy::too_many_lines)]\n-impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        enum Item {\n-            LangItem(Symbol),\n-            DiagnosticItem(Symbol),\n-        }\n-        static PATHS: &[&[&str]] = &[\n-            &[\"clippy_utils\", \"match_def_path\"],\n-            &[\"clippy_utils\", \"match_trait_method\"],\n-            &[\"clippy_utils\", \"ty\", \"match_type\"],\n-            &[\"clippy_utils\", \"is_expr_path_def_path\"],\n-        ];\n-\n-        if is_lint_allowed(cx, UNNECESSARY_DEF_PATH, expr.hir_id) {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::Call(func, [cx_arg, def_arg, args@..]) = expr.kind;\n-            if let ExprKind::Path(path) = &func.kind;\n-            if let Some(id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n-            if let Some(which_path) = match_any_def_paths(cx, id, PATHS);\n-            let item_arg = if which_path == 4 { &args[1] } else { &args[0] };\n-            // Extract the path to the matched type\n-            if let Some(segments) = path_to_matched_type(cx, item_arg);\n-            let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n-            if let Some(def_id) = def_path_res(cx, &segments[..], None).opt_def_id();\n-            then {\n-                // def_path_res will match field names before anything else, but for this we want to match\n-                // inherent functions first.\n-                let def_id = if cx.tcx.def_kind(def_id) == DefKind::Field {\n-                    let method_name = *segments.last().unwrap();\n-                    cx.tcx.def_key(def_id).parent\n-                        .and_then(|parent_idx|\n-                            cx.tcx.inherent_impls(DefId { index: parent_idx, krate: def_id.krate }).iter()\n-                                .find_map(|impl_id| cx.tcx.associated_items(*impl_id)\n-                                    .find_by_name_and_kind(\n-                                        cx.tcx,\n-                                        Ident::from_str(method_name),\n-                                        AssocKind::Fn,\n-                                        *impl_id,\n-                                    )\n-                                )\n-                        )\n-                        .map_or(def_id, |item| item.def_id)\n-                } else {\n-                    def_id\n-                };\n-\n-                // Check if the target item is a diagnostic item or LangItem.\n-                let (msg, item) = if let Some(item_name)\n-                    = cx.tcx.diagnostic_items(def_id.krate).id_to_name.get(&def_id)\n-                {\n-                    (\n-                        \"use of a def path to a diagnostic item\",\n-                        Item::DiagnosticItem(*item_name),\n-                    )\n-                } else if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n-                    let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"], Some(Namespace::TypeNS)).def_id();\n-                    let item_name = cx.tcx.adt_def(lang_items).variants().iter().nth(lang_item).unwrap().name;\n-                    (\n-                        \"use of a def path to a `LangItem`\",\n-                        Item::LangItem(item_name),\n-                    )\n-                } else {\n-                    return;\n-                };\n-\n-                let has_ctor = match cx.tcx.def_kind(def_id) {\n-                    DefKind::Struct => {\n-                        let variant = cx.tcx.adt_def(def_id).non_enum_variant();\n-                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n-                    }\n-                    DefKind::Variant => {\n-                        let variant = cx.tcx.adt_def(cx.tcx.parent(def_id)).variant_with_id(def_id);\n-                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n-                    }\n-                    _ => false,\n-                };\n-\n-                let mut app = Applicability::MachineApplicable;\n-                let cx_snip = snippet_with_applicability(cx, cx_arg.span, \"..\", &mut app);\n-                let def_snip = snippet_with_applicability(cx, def_arg.span, \"..\", &mut app);\n-                let (sugg, with_note) = match (which_path, item) {\n-                    // match_def_path\n-                    (0, Item::DiagnosticItem(item)) =>\n-                        (format!(\"{cx_snip}.tcx.is_diagnostic_item(sym::{item}, {def_snip})\"), has_ctor),\n-                    (0, Item::LangItem(item)) => (\n-                        format!(\"{cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some({def_snip})\"),\n-                        has_ctor\n-                    ),\n-                    // match_trait_method\n-                    (1, Item::DiagnosticItem(item)) =>\n-                        (format!(\"is_trait_method({cx_snip}, {def_snip}, sym::{item})\"), false),\n-                    // match_type\n-                    (2, Item::DiagnosticItem(item)) =>\n-                        (format!(\"is_type_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n-                    (2, Item::LangItem(item)) =>\n-                        (format!(\"is_type_lang_item({cx_snip}, {def_snip}, LangItem::{item})\"), false),\n-                    // is_expr_path_def_path\n-                    (3, Item::DiagnosticItem(item)) if has_ctor => (\n-                        format!(\n-                            \"is_res_diag_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), sym::{item})\",\n-                        ),\n-                        false,\n-                    ),\n-                    (3, Item::LangItem(item)) if has_ctor => (\n-                        format!(\n-                            \"is_res_lang_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), LangItem::{item})\",\n-                        ),\n-                        false,\n-                    ),\n-                    (3, Item::DiagnosticItem(item)) =>\n-                        (format!(\"is_path_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n-                    (3, Item::LangItem(item)) => (\n-                        format!(\n-                            \"path_res({cx_snip}, {def_snip}).opt_def_id()\\\n-                                .map_or(false, |id| {cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some(id))\",\n-                        ),\n-                        false,\n-                    ),\n-                    _ => return,\n-                };\n-\n-                span_lint_and_then(\n-                    cx,\n-                    UNNECESSARY_DEF_PATH,\n-                    expr.span,\n-                    msg,\n-                    |diag| {\n-                        diag.span_suggestion(expr.span, \"try\", sugg, app);\n-                        if with_note {\n-                            diag.help(\n-                                \"if this `DefId` came from a constructor expression or pattern then the \\\n-                                    parent `DefId` should be used instead\"\n-                            );\n-                        }\n-                    },\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<String>> {\n-    match peel_hir_expr_refs(expr).0.kind {\n-        ExprKind::Path(ref qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n-            Res::Local(hir_id) => {\n-                let parent_id = cx.tcx.hir().get_parent_node(hir_id);\n-                if let Some(Node::Local(Local { init: Some(init), .. })) = cx.tcx.hir().find(parent_id) {\n-                    path_to_matched_type(cx, init)\n-                } else {\n-                    None\n-                }\n-            },\n-            Res::Def(DefKind::Static(_), def_id) => read_mir_alloc_def_path(\n-                cx,\n-                cx.tcx.eval_static_initializer(def_id).ok()?.inner(),\n-                cx.tcx.type_of(def_id),\n-            ),\n-            Res::Def(DefKind::Const, def_id) => match cx.tcx.const_eval_poly(def_id).ok()? {\n-                ConstValue::ByRef { alloc, offset } if offset.bytes() == 0 => {\n-                    read_mir_alloc_def_path(cx, alloc.inner(), cx.tcx.type_of(def_id))\n-                },\n-                _ => None,\n-            },\n-            _ => None,\n-        },\n-        ExprKind::Array(exprs) => exprs\n-            .iter()\n-            .map(|expr| {\n-                if let ExprKind::Lit(lit) = &expr.kind {\n-                    if let LitKind::Str(sym, _) = lit.node {\n-                        return Some((*sym.as_str()).to_owned());\n-                    }\n-                }\n-\n-                None\n-            })\n-            .collect(),\n-        _ => None,\n-    }\n-}\n-\n-fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation, ty: Ty<'_>) -> Option<Vec<String>> {\n-    let (alloc, ty) = if let ty::Ref(_, ty, Mutability::Not) = *ty.kind() {\n-        let &alloc = alloc.provenance().values().next()?;\n-        if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n-            (alloc.inner(), ty)\n-        } else {\n-            return None;\n-        }\n-    } else {\n-        (alloc, ty)\n-    };\n-\n-    if let ty::Array(ty, _) | ty::Slice(ty) = *ty.kind()\n-        && let ty::Ref(_, ty, Mutability::Not) = *ty.kind()\n-        && ty.is_str()\n-    {\n-        alloc\n-            .provenance()\n-            .values()\n-            .map(|&alloc| {\n-                if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n-                    let alloc = alloc.inner();\n-                    str::from_utf8(alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()))\n-                        .ok().map(ToOwned::to_owned)\n-                } else {\n-                    None\n-                }\n-            })\n-            .collect()\n-    } else {\n-        None\n-    }\n-}\n-\n-// This is not a complete resolver for paths. It works on all the paths currently used in the paths\n-// module.  That's all it does and all it needs to do.\n-pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n-    if def_path_res(cx, path, None) != Res::Err {\n-        return true;\n-    }\n-\n-    // Some implementations can't be found by `path_to_res`, particularly inherent\n-    // implementations of native types. Check lang items.\n-    let path_syms: Vec<_> = path.iter().map(|p| Symbol::intern(p)).collect();\n-    let lang_items = cx.tcx.lang_items();\n-    // This list isn't complete, but good enough for our current list of paths.\n-    let incoherent_impls = [\n-        SimplifiedTypeGen::FloatSimplifiedType(FloatTy::F32),\n-        SimplifiedTypeGen::FloatSimplifiedType(FloatTy::F64),\n-        SimplifiedTypeGen::SliceSimplifiedType,\n-        SimplifiedTypeGen::StrSimplifiedType,\n-    ]\n-    .iter()\n-    .flat_map(|&ty| cx.tcx.incoherent_impls(ty));\n-    for item_def_id in lang_items.items().iter().flatten().chain(incoherent_impls) {\n-        let lang_item_path = cx.get_def_path(*item_def_id);\n-        if path_syms.starts_with(&lang_item_path) {\n-            if let [item] = &path_syms[lang_item_path.len()..] {\n-                if matches!(\n-                    cx.tcx.def_kind(*item_def_id),\n-                    DefKind::Mod | DefKind::Enum | DefKind::Trait\n-                ) {\n-                    for child in cx.tcx.module_children(*item_def_id) {\n-                        if child.ident.name == *item {\n-                            return true;\n-                        }\n-                    }\n-                } else {\n-                    for child in cx.tcx.associated_item_def_ids(*item_def_id) {\n-                        if cx.tcx.item_name(*child) == *item {\n-                            return true;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    false\n-}\n-\n-declare_lint_pass!(InvalidPaths => [INVALID_PATHS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        let local_def_id = &cx.tcx.parent_module(item.hir_id());\n-        let mod_name = &cx.tcx.item_name(local_def_id.to_def_id());\n-        if_chain! {\n-            if mod_name.as_str() == \"paths\";\n-            if let hir::ItemKind::Const(ty, body_id) = item.kind;\n-            let ty = hir_ty_to_ty(cx.tcx, ty);\n-            if let ty::Array(el_ty, _) = &ty.kind();\n-            if let ty::Ref(_, el_ty, _) = &el_ty.kind();\n-            if el_ty.is_str();\n-            let body = cx.tcx.hir().body(body_id);\n-            let typeck_results = cx.tcx.typeck_body(body_id);\n-            if let Some(Constant::Vec(path)) = constant_simple(cx, typeck_results, body.value);\n-            let path: Vec<&str> = path.iter().map(|x| {\n-                    if let Constant::Str(s) = x {\n-                        s.as_str()\n-                    } else {\n-                        // We checked the type of the constant above\n-                        unreachable!()\n-                    }\n-                }).collect();\n-            if !check_path(cx, &path[..]);\n-            then {\n-                span_lint(cx, INVALID_PATHS, item.span, \"invalid path\");\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Default)]\n-pub struct InterningDefinedSymbol {\n-    // Maps the symbol value to the constant DefId.\n-    symbol_map: FxHashMap<u32, DefId>,\n-}\n-\n-impl_lint_pass!(InterningDefinedSymbol => [INTERNING_DEFINED_SYMBOL, UNNECESSARY_SYMBOL_STR]);\n-\n-impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n-    fn check_crate(&mut self, cx: &LateContext<'_>) {\n-        if !self.symbol_map.is_empty() {\n-            return;\n-        }\n-\n-        for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n-            if let Some(def_id) = def_path_res(cx, module, None).opt_def_id() {\n-                for item in cx.tcx.module_children(def_id).iter() {\n-                    if_chain! {\n-                        if let Res::Def(DefKind::Const, item_def_id) = item.res;\n-                        let ty = cx.tcx.type_of(item_def_id);\n-                        if match_type(cx, ty, &paths::SYMBOL);\n-                        if let Ok(ConstValue::Scalar(value)) = cx.tcx.const_eval_poly(item_def_id);\n-                        if let Ok(value) = value.to_u32();\n-                        then {\n-                            self.symbol_map.insert(value, item_def_id);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Call(func, [arg]) = &expr.kind;\n-            if let ty::FnDef(def_id, _) = cx.typeck_results().expr_ty(func).kind();\n-            if match_def_path(cx, *def_id, &paths::SYMBOL_INTERN);\n-            if let Some(Constant::Str(arg)) = constant_simple(cx, cx.typeck_results(), arg);\n-            let value = Symbol::intern(&arg).as_u32();\n-            if let Some(&def_id) = self.symbol_map.get(&value);\n-            then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    INTERNING_DEFINED_SYMBOL,\n-                    is_expn_of(expr.span, \"sym\").unwrap_or(expr.span),\n-                    \"interning a defined symbol\",\n-                    \"try\",\n-                    cx.tcx.def_path_str(def_id),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-        if let ExprKind::Binary(op, left, right) = expr.kind {\n-            if matches!(op.node, BinOpKind::Eq | BinOpKind::Ne) {\n-                let data = [\n-                    (left, self.symbol_str_expr(left, cx)),\n-                    (right, self.symbol_str_expr(right, cx)),\n-                ];\n-                match data {\n-                    // both operands are a symbol string\n-                    [(_, Some(left)), (_, Some(right))] => {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            UNNECESSARY_SYMBOL_STR,\n-                            expr.span,\n-                            \"unnecessary `Symbol` to string conversion\",\n-                            \"try\",\n-                            format!(\n-                                \"{} {} {}\",\n-                                left.as_symbol_snippet(cx),\n-                                op.node.as_str(),\n-                                right.as_symbol_snippet(cx),\n-                            ),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    },\n-                    // one of the operands is a symbol string\n-                    [(expr, Some(symbol)), _] | [_, (expr, Some(symbol))] => {\n-                        // creating an owned string for comparison\n-                        if matches!(symbol, SymbolStrExpr::Expr { is_to_owned: true, .. }) {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                UNNECESSARY_SYMBOL_STR,\n-                                expr.span,\n-                                \"unnecessary string allocation\",\n-                                \"try\",\n-                                format!(\"{}.as_str()\", symbol.as_symbol_snippet(cx)),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    },\n-                    // nothing found\n-                    [(_, None), (_, None)] => {},\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl InterningDefinedSymbol {\n-    fn symbol_str_expr<'tcx>(&self, expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> Option<SymbolStrExpr<'tcx>> {\n-        static IDENT_STR_PATHS: &[&[&str]] = &[&paths::IDENT_AS_STR, &paths::TO_STRING_METHOD];\n-        static SYMBOL_STR_PATHS: &[&[&str]] = &[\n-            &paths::SYMBOL_AS_STR,\n-            &paths::SYMBOL_TO_IDENT_STRING,\n-            &paths::TO_STRING_METHOD,\n-        ];\n-        let call = if_chain! {\n-            if let ExprKind::AddrOf(_, _, e) = expr.kind;\n-            if let ExprKind::Unary(UnOp::Deref, e) = e.kind;\n-            then { e } else { expr }\n-        };\n-        if_chain! {\n-            // is a method call\n-            if let ExprKind::MethodCall(_, item, [], _) = call.kind;\n-            if let Some(did) = cx.typeck_results().type_dependent_def_id(call.hir_id);\n-            let ty = cx.typeck_results().expr_ty(item);\n-            // ...on either an Ident or a Symbol\n-            if let Some(is_ident) = if match_type(cx, ty, &paths::SYMBOL) {\n-                Some(false)\n-            } else if match_type(cx, ty, &paths::IDENT) {\n-                Some(true)\n-            } else {\n-                None\n-            };\n-            // ...which converts it to a string\n-            let paths = if is_ident { IDENT_STR_PATHS } else { SYMBOL_STR_PATHS };\n-            if let Some(path) = paths.iter().find(|path| match_def_path(cx, did, path));\n-            then {\n-                let is_to_owned = path.last().unwrap().ends_with(\"string\");\n-                return Some(SymbolStrExpr::Expr {\n-                    item,\n-                    is_ident,\n-                    is_to_owned,\n-                });\n-            }\n-        }\n-        // is a string constant\n-        if let Some(Constant::Str(s)) = constant_simple(cx, cx.typeck_results(), expr) {\n-            let value = Symbol::intern(&s).as_u32();\n-            // ...which matches a symbol constant\n-            if let Some(&def_id) = self.symbol_map.get(&value) {\n-                return Some(SymbolStrExpr::Const(def_id));\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-enum SymbolStrExpr<'tcx> {\n-    /// a string constant with a corresponding symbol constant\n-    Const(DefId),\n-    /// a \"symbol to string\" expression like `symbol.as_str()`\n-    Expr {\n-        /// part that evaluates to `Symbol` or `Ident`\n-        item: &'tcx Expr<'tcx>,\n-        is_ident: bool,\n-        /// whether an owned `String` is created like `to_ident_string()`\n-        is_to_owned: bool,\n-    },\n-}\n-\n-impl<'tcx> SymbolStrExpr<'tcx> {\n-    /// Returns a snippet that evaluates to a `Symbol` and is const if possible\n-    fn as_symbol_snippet(&self, cx: &LateContext<'_>) -> Cow<'tcx, str> {\n-        match *self {\n-            Self::Const(def_id) => cx.tcx.def_path_str(def_id).into(),\n-            Self::Expr { item, is_ident, .. } => {\n-                let mut snip = snippet(cx, item.span.source_callsite(), \"..\");\n-                if is_ident {\n-                    // get `Ident.name`\n-                    snip.to_mut().push_str(\".name\");\n-                }\n-                snip\n-            },\n-        }\n-    }\n-}\n-\n-declare_lint_pass!(IfChainStyle => [IF_CHAIN_STYLE]);\n-\n-impl<'tcx> LateLintPass<'tcx> for IfChainStyle {\n-    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n-        let (local, after, if_chain_span) = if_chain! {\n-            if let [Stmt { kind: StmtKind::Local(local), .. }, after @ ..] = block.stmts;\n-            if let Some(if_chain_span) = is_expn_of(block.span, \"if_chain\");\n-            then { (local, after, if_chain_span) } else { return }\n-        };\n-        if is_first_if_chain_expr(cx, block.hir_id, if_chain_span) {\n-            span_lint(\n-                cx,\n-                IF_CHAIN_STYLE,\n-                if_chain_local_span(cx, local, if_chain_span),\n-                \"`let` expression should be above the `if_chain!`\",\n-            );\n-        } else if local.span.ctxt() == block.span.ctxt() && is_if_chain_then(after, block.expr, if_chain_span) {\n-            span_lint(\n-                cx,\n-                IF_CHAIN_STYLE,\n-                if_chain_local_span(cx, local, if_chain_span),\n-                \"`let` expression should be inside `then { .. }`\",\n-            );\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        let (cond, then, els) = if let Some(higher::IfOrIfLet { cond, r#else, then }) = higher::IfOrIfLet::hir(expr) {\n-            (cond, then, r#else.is_some())\n-        } else {\n-            return;\n-        };\n-        let ExprKind::Block(then_block, _) = then.kind else { return };\n-        let if_chain_span = is_expn_of(expr.span, \"if_chain\");\n-        if !els {\n-            check_nested_if_chains(cx, expr, then_block, if_chain_span);\n-        }\n-        let Some(if_chain_span) = if_chain_span else { return };\n-        // check for `if a && b;`\n-        if_chain! {\n-            if let ExprKind::Binary(op, _, _) = cond.kind;\n-            if op.node == BinOpKind::And;\n-            if cx.sess().source_map().is_multiline(cond.span);\n-            then {\n-                span_lint(cx, IF_CHAIN_STYLE, cond.span, \"`if a && b;` should be `if a; if b;`\");\n-            }\n-        }\n-        if is_first_if_chain_expr(cx, expr.hir_id, if_chain_span)\n-            && is_if_chain_then(then_block.stmts, then_block.expr, if_chain_span)\n-        {\n-            span_lint(cx, IF_CHAIN_STYLE, expr.span, \"`if_chain!` only has one `if`\");\n-        }\n-    }\n-}\n-\n-fn check_nested_if_chains(\n-    cx: &LateContext<'_>,\n-    if_expr: &Expr<'_>,\n-    then_block: &Block<'_>,\n-    if_chain_span: Option<Span>,\n-) {\n-    #[rustfmt::skip]\n-    let (head, tail) = match *then_block {\n-        Block { stmts, expr: Some(tail), .. } => (stmts, tail),\n-        Block {\n-            stmts: &[\n-                ref head @ ..,\n-                Stmt { kind: StmtKind::Expr(tail) | StmtKind::Semi(tail), .. }\n-            ],\n-            ..\n-        } => (head, tail),\n-        _ => return,\n-    };\n-    if_chain! {\n-        if let Some(higher::IfOrIfLet { r#else: None, .. }) = higher::IfOrIfLet::hir(tail);\n-        let sm = cx.sess().source_map();\n-        if head\n-            .iter()\n-            .all(|stmt| matches!(stmt.kind, StmtKind::Local(..)) && !sm.is_multiline(stmt.span));\n-        if if_chain_span.is_some() || !is_else_clause(cx.tcx, if_expr);\n-        then {} else { return }\n-    }\n-    let (span, msg) = match (if_chain_span, is_expn_of(tail.span, \"if_chain\")) {\n-        (None, Some(_)) => (if_expr.span, \"this `if` can be part of the inner `if_chain!`\"),\n-        (Some(_), None) => (tail.span, \"this `if` can be part of the outer `if_chain!`\"),\n-        (Some(a), Some(b)) if a != b => (b, \"this `if_chain!` can be merged with the outer `if_chain!`\"),\n-        _ => return,\n-    };\n-    span_lint_and_then(cx, IF_CHAIN_STYLE, span, msg, |diag| {\n-        let (span, msg) = match head {\n-            [] => return,\n-            [stmt] => (stmt.span, \"this `let` statement can also be in the `if_chain!`\"),\n-            [a, .., b] => (\n-                a.span.to(b.span),\n-                \"these `let` statements can also be in the `if_chain!`\",\n-            ),\n-        };\n-        diag.span_help(span, msg);\n-    });\n-}\n-\n-fn is_first_if_chain_expr(cx: &LateContext<'_>, hir_id: HirId, if_chain_span: Span) -> bool {\n-    cx.tcx\n-        .hir()\n-        .parent_iter(hir_id)\n-        .find(|(_, node)| {\n-            #[rustfmt::skip]\n-            !matches!(node, Node::Expr(Expr { kind: ExprKind::Block(..), .. }) | Node::Stmt(_))\n-        })\n-        .map_or(false, |(id, _)| {\n-            is_expn_of(cx.tcx.hir().span(id), \"if_chain\") != Some(if_chain_span)\n-        })\n-}\n-\n-/// Checks a trailing slice of statements and expression of a `Block` to see if they are part\n-/// of the `then {..}` portion of an `if_chain!`\n-fn is_if_chain_then(stmts: &[Stmt<'_>], expr: Option<&Expr<'_>>, if_chain_span: Span) -> bool {\n-    let span = if let [stmt, ..] = stmts {\n-        stmt.span\n-    } else if let Some(expr) = expr {\n-        expr.span\n-    } else {\n-        // empty `then {}`\n-        return true;\n-    };\n-    is_expn_of(span, \"if_chain\").map_or(true, |span| span != if_chain_span)\n-}\n-\n-/// Creates a `Span` for `let x = ..;` in an `if_chain!` call.\n-fn if_chain_local_span(cx: &LateContext<'_>, local: &Local<'_>, if_chain_span: Span) -> Span {\n-    let mut span = local.pat.span;\n-    if let Some(init) = local.init {\n-        span = span.to(init.span);\n-    }\n-    span.adjust(if_chain_span.ctxt().outer_expn());\n-    let sm = cx.sess().source_map();\n-    let span = sm.span_extend_to_prev_str(span, \"let\", false, true).unwrap_or(span);\n-    let span = sm.span_extend_to_next_char(span, ';', false);\n-    Span::new(\n-        span.lo() - BytePos(3),\n-        span.hi() + BytePos(1),\n-        span.ctxt(),\n-        span.parent(),\n-    )\n-}\n-\n-declare_lint_pass!(MsrvAttrImpl => [MISSING_MSRV_ATTR_IMPL]);\n-\n-impl LateLintPass<'_> for MsrvAttrImpl {\n-    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if_chain! {\n-            if let hir::ItemKind::Impl(hir::Impl {\n-                of_trait: Some(lint_pass_trait_ref),\n-                self_ty,\n-                items,\n-                ..\n-            }) = &item.kind;\n-            if let Some(lint_pass_trait_def_id) = lint_pass_trait_ref.trait_def_id();\n-            let is_late_pass = match_def_path(cx, lint_pass_trait_def_id, &paths::LATE_LINT_PASS);\n-            if is_late_pass || match_def_path(cx, lint_pass_trait_def_id, &paths::EARLY_LINT_PASS);\n-            let self_ty = hir_ty_to_ty(cx.tcx, self_ty);\n-            if let ty::Adt(self_ty_def, _) = self_ty.kind();\n-            if self_ty_def.is_struct();\n-            if self_ty_def.all_fields().any(|f| {\n-                cx.tcx\n-                    .type_of(f.did)\n-                    .walk()\n-                    .filter(|t| matches!(t.unpack(), GenericArgKind::Type(_)))\n-                    .any(|t| match_type(cx, t.expect_ty(), &paths::RUSTC_VERSION))\n-            });\n-            if !items.iter().any(|item| item.ident.name == sym!(enter_lint_attrs));\n-            then {\n-                let context = if is_late_pass { \"LateContext\" } else { \"EarlyContext\" };\n-                let lint_pass = if is_late_pass { \"LateLintPass\" } else { \"EarlyLintPass\" };\n-                let span = cx.sess().source_map().span_through_char(item.span, '{');\n-                span_lint_and_sugg(\n-                    cx,\n-                    MISSING_MSRV_ATTR_IMPL,\n-                    span,\n-                    &format!(\"`extract_msrv_attr!` macro missing from `{lint_pass}` implementation\"),\n-                    &format!(\"add `extract_msrv_attr!({context})` to the `{lint_pass}` implementation\"),\n-                    format!(\"{}\\n    extract_msrv_attr!({context});\", snippet(cx, span, \"..\")),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-}\n+pub mod msrv_attr_impl;\n+pub mod outer_expn_data_pass;\n+pub mod produce_ice;\n+pub mod unnecessary_def_path;"}, {"sha": "da9514dd15eee4c85293c8ea8e0c546c99f5cb0e", "filename": "clippy_lints/src/utils/internal_lints/clippy_lints_internal.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fclippy_lints_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fclippy_lints_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fclippy_lints_internal.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -0,0 +1,49 @@\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_ast::ast::{Crate, ItemKind, ModKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for various things we like to keep tidy in clippy.\n+    ///\n+    /// ### Why is this bad?\n+    /// We like to pretend we're an example of tidy code.\n+    ///\n+    /// ### Example\n+    /// Wrong ordering of the util::paths constants.\n+    pub CLIPPY_LINTS_INTERNAL,\n+    internal,\n+    \"various things that will negatively affect your clippy experience\"\n+}\n+\n+declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n+\n+impl EarlyLintPass for ClippyLintsInternal {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &Crate) {\n+        if let Some(utils) = krate.items.iter().find(|item| item.ident.name.as_str() == \"utils\") {\n+            if let ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) = utils.kind {\n+                if let Some(paths) = items.iter().find(|item| item.ident.name.as_str() == \"paths\") {\n+                    if let ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) = paths.kind {\n+                        let mut last_name: Option<&str> = None;\n+                        for item in items {\n+                            let name = item.ident.as_str();\n+                            if let Some(last_name) = last_name {\n+                                if *last_name > *name {\n+                                    span_lint(\n+                                        cx,\n+                                        CLIPPY_LINTS_INTERNAL,\n+                                        item.span,\n+                                        \"this constant should be before the previous constant due to lexical \\\n+                                         ordering\",\n+                                    );\n+                                }\n+                            }\n+                            last_name = Some(name);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "c9089aecfa59526429667139972f7b273442bce8", "filename": "clippy_lints/src/utils/internal_lints/collapsible_calls.rs", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcollapsible_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcollapsible_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcollapsible_calls.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -0,0 +1,240 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{is_expr_path_def_path, is_lint_allowed, peel_blocks_with_stmt, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::{Closure, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use std::borrow::{Borrow, Cow};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Lints `span_lint_and_then` function calls, where the\n+    /// closure argument has only one statement and that statement is a method\n+    /// call to `span_suggestion`, `span_help`, `span_note` (using the same\n+    /// span), `help` or `note`.\n+    ///\n+    /// These usages of `span_lint_and_then` should be replaced with one of the\n+    /// wrapper functions `span_lint_and_sugg`, span_lint_and_help`, or\n+    /// `span_lint_and_note`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Using the wrapper `span_lint_and_*` functions, is more\n+    /// convenient, readable and less error prone.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.span_suggestion(\n+    ///         expr.span,\n+    ///         help_msg,\n+    ///         sugg.to_string(),\n+    ///         Applicability::MachineApplicable,\n+    ///     );\n+    /// });\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.span_help(expr.span, help_msg);\n+    /// });\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.help(help_msg);\n+    /// });\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.span_note(expr.span, note_msg);\n+    /// });\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.note(note_msg);\n+    /// });\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// span_lint_and_sugg(\n+    ///     cx,\n+    ///     TEST_LINT,\n+    ///     expr.span,\n+    ///     lint_msg,\n+    ///     help_msg,\n+    ///     sugg.to_string(),\n+    ///     Applicability::MachineApplicable,\n+    /// );\n+    /// span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), help_msg);\n+    /// span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, None, help_msg);\n+    /// span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), note_msg);\n+    /// span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, None, note_msg);\n+    /// ```\n+    pub COLLAPSIBLE_SPAN_LINT_CALLS,\n+    internal,\n+    \"found collapsible `span_lint_and_then` calls\"\n+}\n+\n+declare_lint_pass!(CollapsibleCalls => [COLLAPSIBLE_SPAN_LINT_CALLS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if is_lint_allowed(cx, COLLAPSIBLE_SPAN_LINT_CALLS, expr.hir_id) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let ExprKind::Call(func, and_then_args) = expr.kind;\n+            if is_expr_path_def_path(cx, func, &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_then\"]);\n+            if and_then_args.len() == 5;\n+            if let ExprKind::Closure(&Closure { body, .. }) = &and_then_args[4].kind;\n+            let body = cx.tcx.hir().body(body);\n+            let only_expr = peel_blocks_with_stmt(body.value);\n+            if let ExprKind::MethodCall(ps, recv, span_call_args, _) = &only_expr.kind;\n+            if let ExprKind::Path(..) = recv.kind;\n+            then {\n+                let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n+                let mut sle = SpanlessEq::new(cx).deny_side_effects();\n+                match ps.ident.as_str() {\n+                    \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n+                        suggest_suggestion(cx, expr, &and_then_snippets, &span_suggestion_snippets(cx, span_call_args));\n+                    },\n+                    \"span_help\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n+                        let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+                        suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), true);\n+                    },\n+                    \"span_note\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n+                        let note_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+                        suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), true);\n+                    },\n+                    \"help\" => {\n+                        let help_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n+                        suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), false);\n+                    }\n+                    \"note\" => {\n+                        let note_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n+                        suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), false);\n+                    }\n+                    _  => (),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct AndThenSnippets<'a> {\n+    cx: Cow<'a, str>,\n+    lint: Cow<'a, str>,\n+    span: Cow<'a, str>,\n+    msg: Cow<'a, str>,\n+}\n+\n+fn get_and_then_snippets<'a, 'hir>(cx: &LateContext<'_>, and_then_snippets: &'hir [Expr<'hir>]) -> AndThenSnippets<'a> {\n+    let cx_snippet = snippet(cx, and_then_snippets[0].span, \"cx\");\n+    let lint_snippet = snippet(cx, and_then_snippets[1].span, \"..\");\n+    let span_snippet = snippet(cx, and_then_snippets[2].span, \"span\");\n+    let msg_snippet = snippet(cx, and_then_snippets[3].span, r#\"\"...\"\"#);\n+\n+    AndThenSnippets {\n+        cx: cx_snippet,\n+        lint: lint_snippet,\n+        span: span_snippet,\n+        msg: msg_snippet,\n+    }\n+}\n+\n+struct SpanSuggestionSnippets<'a> {\n+    help: Cow<'a, str>,\n+    sugg: Cow<'a, str>,\n+    applicability: Cow<'a, str>,\n+}\n+\n+fn span_suggestion_snippets<'a, 'hir>(\n+    cx: &LateContext<'_>,\n+    span_call_args: &'hir [Expr<'hir>],\n+) -> SpanSuggestionSnippets<'a> {\n+    let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+    let sugg_snippet = snippet(cx, span_call_args[2].span, \"..\");\n+    let applicability_snippet = snippet(cx, span_call_args[3].span, \"Applicability::MachineApplicable\");\n+\n+    SpanSuggestionSnippets {\n+        help: help_snippet,\n+        sugg: sugg_snippet,\n+        applicability: applicability_snippet,\n+    }\n+}\n+\n+fn suggest_suggestion(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    and_then_snippets: &AndThenSnippets<'_>,\n+    span_suggestion_snippets: &SpanSuggestionSnippets<'_>,\n+) {\n+    span_lint_and_sugg(\n+        cx,\n+        COLLAPSIBLE_SPAN_LINT_CALLS,\n+        expr.span,\n+        \"this call is collapsible\",\n+        \"collapse into\",\n+        format!(\n+            \"span_lint_and_sugg({}, {}, {}, {}, {}, {}, {})\",\n+            and_then_snippets.cx,\n+            and_then_snippets.lint,\n+            and_then_snippets.span,\n+            and_then_snippets.msg,\n+            span_suggestion_snippets.help,\n+            span_suggestion_snippets.sugg,\n+            span_suggestion_snippets.applicability\n+        ),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn suggest_help(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    and_then_snippets: &AndThenSnippets<'_>,\n+    help: &str,\n+    with_span: bool,\n+) {\n+    let option_span = if with_span {\n+        format!(\"Some({})\", and_then_snippets.span)\n+    } else {\n+        \"None\".to_string()\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        COLLAPSIBLE_SPAN_LINT_CALLS,\n+        expr.span,\n+        \"this call is collapsible\",\n+        \"collapse into\",\n+        format!(\n+            \"span_lint_and_help({}, {}, {}, {}, {}, {help})\",\n+            and_then_snippets.cx, and_then_snippets.lint, and_then_snippets.span, and_then_snippets.msg, &option_span,\n+        ),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn suggest_note(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    and_then_snippets: &AndThenSnippets<'_>,\n+    note: &str,\n+    with_span: bool,\n+) {\n+    let note_span = if with_span {\n+        format!(\"Some({})\", and_then_snippets.span)\n+    } else {\n+        \"None\".to_string()\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        COLLAPSIBLE_SPAN_LINT_CALLS,\n+        expr.span,\n+        \"this call is collapsible\",\n+        \"collapse into\",\n+        format!(\n+            \"span_lint_and_note({}, {}, {}, {}, {note_span}, {note})\",\n+            and_then_snippets.cx, and_then_snippets.lint, and_then_snippets.span, and_then_snippets.msg,\n+        ),\n+        Applicability::MachineApplicable,\n+    );\n+}"}, {"sha": "67357a5cb6b0a47c2b54510a6d7b38bc8f941664", "filename": "clippy_lints/src/utils/internal_lints/compiler_lint_functions.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcompiler_lint_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcompiler_lint_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcompiler_lint_functions.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -0,0 +1,78 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::{is_lint_allowed, paths};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for calls to `cx.span_lint*` and suggests to use the `utils::*`\n+    /// variant of the function.\n+    ///\n+    /// ### Why is this bad?\n+    /// The `utils::*` variants also add a link to the Clippy documentation to the\n+    /// warning/error messages.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// cx.span_lint(LINT_NAME, \"message\");\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// utils::span_lint(cx, LINT_NAME, \"message\");\n+    /// ```\n+    pub COMPILER_LINT_FUNCTIONS,\n+    internal,\n+    \"usage of the lint functions of the compiler instead of the utils::* variant\"\n+}\n+\n+#[derive(Clone, Default)]\n+pub struct CompilerLintFunctions {\n+    map: FxHashMap<&'static str, &'static str>,\n+}\n+\n+impl CompilerLintFunctions {\n+    #[must_use]\n+    pub fn new() -> Self {\n+        let mut map = FxHashMap::default();\n+        map.insert(\"span_lint\", \"utils::span_lint\");\n+        map.insert(\"struct_span_lint\", \"utils::span_lint\");\n+        map.insert(\"lint\", \"utils::span_lint\");\n+        map.insert(\"span_lint_note\", \"utils::span_lint_and_note\");\n+        map.insert(\"span_lint_help\", \"utils::span_lint_and_help\");\n+        Self { map }\n+    }\n+}\n+\n+impl_lint_pass!(CompilerLintFunctions => [COMPILER_LINT_FUNCTIONS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if is_lint_allowed(cx, COMPILER_LINT_FUNCTIONS, expr.hir_id) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let ExprKind::MethodCall(path, self_arg, _, _) = &expr.kind;\n+            let fn_name = path.ident;\n+            if let Some(sugg) = self.map.get(fn_name.as_str());\n+            let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n+            if match_type(cx, ty, &paths::EARLY_CONTEXT)\n+                || match_type(cx, ty, &paths::LATE_CONTEXT);\n+            then {\n+                span_lint_and_help(\n+                    cx,\n+                    COMPILER_LINT_FUNCTIONS,\n+                    path.ident.span,\n+                    \"usage of a compiler lint function\",\n+                    None,\n+                    &format!(\"please use the Clippy variant of this function: `{sugg}`\"),\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "a863fdc9d50cf870585c280c3226b41ff7ece8e6", "filename": "clippy_lints/src/utils/internal_lints/if_chain_style.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fif_chain_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fif_chain_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fif_chain_style.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -0,0 +1,161 @@\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n+use clippy_utils::{higher, is_else_clause, is_expn_of};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Local, Node, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{BytePos, Span};\n+\n+declare_clippy_lint! {\n+    /// Finds unidiomatic usage of `if_chain!`\n+    pub IF_CHAIN_STYLE,\n+    internal,\n+    \"non-idiomatic `if_chain!` usage\"\n+}\n+\n+declare_lint_pass!(IfChainStyle => [IF_CHAIN_STYLE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for IfChainStyle {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n+        let (local, after, if_chain_span) = if_chain! {\n+            if let [Stmt { kind: StmtKind::Local(local), .. }, after @ ..] = block.stmts;\n+            if let Some(if_chain_span) = is_expn_of(block.span, \"if_chain\");\n+            then { (local, after, if_chain_span) } else { return }\n+        };\n+        if is_first_if_chain_expr(cx, block.hir_id, if_chain_span) {\n+            span_lint(\n+                cx,\n+                IF_CHAIN_STYLE,\n+                if_chain_local_span(cx, local, if_chain_span),\n+                \"`let` expression should be above the `if_chain!`\",\n+            );\n+        } else if local.span.ctxt() == block.span.ctxt() && is_if_chain_then(after, block.expr, if_chain_span) {\n+            span_lint(\n+                cx,\n+                IF_CHAIN_STYLE,\n+                if_chain_local_span(cx, local, if_chain_span),\n+                \"`let` expression should be inside `then { .. }`\",\n+            );\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        let (cond, then, els) = if let Some(higher::IfOrIfLet { cond, r#else, then }) = higher::IfOrIfLet::hir(expr) {\n+            (cond, then, r#else.is_some())\n+        } else {\n+            return;\n+        };\n+        let ExprKind::Block(then_block, _) = then.kind else { return };\n+        let if_chain_span = is_expn_of(expr.span, \"if_chain\");\n+        if !els {\n+            check_nested_if_chains(cx, expr, then_block, if_chain_span);\n+        }\n+        let Some(if_chain_span) = if_chain_span else { return };\n+        // check for `if a && b;`\n+        if_chain! {\n+            if let ExprKind::Binary(op, _, _) = cond.kind;\n+            if op.node == BinOpKind::And;\n+            if cx.sess().source_map().is_multiline(cond.span);\n+            then {\n+                span_lint(cx, IF_CHAIN_STYLE, cond.span, \"`if a && b;` should be `if a; if b;`\");\n+            }\n+        }\n+        if is_first_if_chain_expr(cx, expr.hir_id, if_chain_span)\n+            && is_if_chain_then(then_block.stmts, then_block.expr, if_chain_span)\n+        {\n+            span_lint(cx, IF_CHAIN_STYLE, expr.span, \"`if_chain!` only has one `if`\");\n+        }\n+    }\n+}\n+\n+fn check_nested_if_chains(\n+    cx: &LateContext<'_>,\n+    if_expr: &Expr<'_>,\n+    then_block: &Block<'_>,\n+    if_chain_span: Option<Span>,\n+) {\n+    #[rustfmt::skip]\n+    let (head, tail) = match *then_block {\n+        Block { stmts, expr: Some(tail), .. } => (stmts, tail),\n+        Block {\n+            stmts: &[\n+                ref head @ ..,\n+                Stmt { kind: StmtKind::Expr(tail) | StmtKind::Semi(tail), .. }\n+            ],\n+            ..\n+        } => (head, tail),\n+        _ => return,\n+    };\n+    if_chain! {\n+        if let Some(higher::IfOrIfLet { r#else: None, .. }) = higher::IfOrIfLet::hir(tail);\n+        let sm = cx.sess().source_map();\n+        if head\n+            .iter()\n+            .all(|stmt| matches!(stmt.kind, StmtKind::Local(..)) && !sm.is_multiline(stmt.span));\n+        if if_chain_span.is_some() || !is_else_clause(cx.tcx, if_expr);\n+        then {} else { return }\n+    }\n+    let (span, msg) = match (if_chain_span, is_expn_of(tail.span, \"if_chain\")) {\n+        (None, Some(_)) => (if_expr.span, \"this `if` can be part of the inner `if_chain!`\"),\n+        (Some(_), None) => (tail.span, \"this `if` can be part of the outer `if_chain!`\"),\n+        (Some(a), Some(b)) if a != b => (b, \"this `if_chain!` can be merged with the outer `if_chain!`\"),\n+        _ => return,\n+    };\n+    span_lint_and_then(cx, IF_CHAIN_STYLE, span, msg, |diag| {\n+        let (span, msg) = match head {\n+            [] => return,\n+            [stmt] => (stmt.span, \"this `let` statement can also be in the `if_chain!`\"),\n+            [a, .., b] => (\n+                a.span.to(b.span),\n+                \"these `let` statements can also be in the `if_chain!`\",\n+            ),\n+        };\n+        diag.span_help(span, msg);\n+    });\n+}\n+\n+fn is_first_if_chain_expr(cx: &LateContext<'_>, hir_id: HirId, if_chain_span: Span) -> bool {\n+    cx.tcx\n+        .hir()\n+        .parent_iter(hir_id)\n+        .find(|(_, node)| {\n+            #[rustfmt::skip]\n+            !matches!(node, Node::Expr(Expr { kind: ExprKind::Block(..), .. }) | Node::Stmt(_))\n+        })\n+        .map_or(false, |(id, _)| {\n+            is_expn_of(cx.tcx.hir().span(id), \"if_chain\") != Some(if_chain_span)\n+        })\n+}\n+\n+/// Checks a trailing slice of statements and expression of a `Block` to see if they are part\n+/// of the `then {..}` portion of an `if_chain!`\n+fn is_if_chain_then(stmts: &[Stmt<'_>], expr: Option<&Expr<'_>>, if_chain_span: Span) -> bool {\n+    let span = if let [stmt, ..] = stmts {\n+        stmt.span\n+    } else if let Some(expr) = expr {\n+        expr.span\n+    } else {\n+        // empty `then {}`\n+        return true;\n+    };\n+    is_expn_of(span, \"if_chain\").map_or(true, |span| span != if_chain_span)\n+}\n+\n+/// Creates a `Span` for `let x = ..;` in an `if_chain!` call.\n+fn if_chain_local_span(cx: &LateContext<'_>, local: &Local<'_>, if_chain_span: Span) -> Span {\n+    let mut span = local.pat.span;\n+    if let Some(init) = local.init {\n+        span = span.to(init.span);\n+    }\n+    span.adjust(if_chain_span.ctxt().outer_expn());\n+    let sm = cx.sess().source_map();\n+    let span = sm.span_extend_to_prev_str(span, \"let\", false, true).unwrap_or(span);\n+    let span = sm.span_extend_to_next_char(span, ';', false);\n+    Span::new(\n+        span.lo() - BytePos(3),\n+        span.hi() + BytePos(1),\n+        span.ctxt(),\n+        span.parent(),\n+    )\n+}"}, {"sha": "096b601572b4db5dcce28ff090f39b8e1d4eadf6", "filename": "clippy_lints/src/utils/internal_lints/interning_defined_symbol.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -0,0 +1,239 @@\n+use clippy_utils::consts::{constant_simple, Constant};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::{def_path_res, is_expn_of, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::Applicability;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::mir::interpret::ConstValue;\n+use rustc_middle::ty::{self};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::Symbol;\n+\n+use std::borrow::Cow;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for interning symbols that have already been pre-interned and defined as constants.\n+    ///\n+    /// ### Why is this bad?\n+    /// It's faster and easier to use the symbol constant.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// let _ = sym!(f32);\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// let _ = sym::f32;\n+    /// ```\n+    pub INTERNING_DEFINED_SYMBOL,\n+    internal,\n+    \"interning a symbol that is pre-interned and defined as a constant\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for unnecessary conversion from Symbol to a string.\n+    ///\n+    /// ### Why is this bad?\n+    /// It's faster use symbols directly instead of strings.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// symbol.as_str() == \"clippy\";\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// symbol == sym::clippy;\n+    /// ```\n+    pub UNNECESSARY_SYMBOL_STR,\n+    internal,\n+    \"unnecessary conversion between Symbol and string\"\n+}\n+\n+#[derive(Default)]\n+pub struct InterningDefinedSymbol {\n+    // Maps the symbol value to the constant DefId.\n+    symbol_map: FxHashMap<u32, DefId>,\n+}\n+\n+impl_lint_pass!(InterningDefinedSymbol => [INTERNING_DEFINED_SYMBOL, UNNECESSARY_SYMBOL_STR]);\n+\n+impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n+    fn check_crate(&mut self, cx: &LateContext<'_>) {\n+        if !self.symbol_map.is_empty() {\n+            return;\n+        }\n+\n+        for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n+            if let Some(def_id) = def_path_res(cx, module, None).opt_def_id() {\n+                for item in cx.tcx.module_children(def_id).iter() {\n+                    if_chain! {\n+                        if let Res::Def(DefKind::Const, item_def_id) = item.res;\n+                        let ty = cx.tcx.type_of(item_def_id);\n+                        if match_type(cx, ty, &paths::SYMBOL);\n+                        if let Ok(ConstValue::Scalar(value)) = cx.tcx.const_eval_poly(item_def_id);\n+                        if let Ok(value) = value.to_u32();\n+                        then {\n+                            self.symbol_map.insert(value, item_def_id);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Call(func, [arg]) = &expr.kind;\n+            if let ty::FnDef(def_id, _) = cx.typeck_results().expr_ty(func).kind();\n+            if match_def_path(cx, *def_id, &paths::SYMBOL_INTERN);\n+            if let Some(Constant::Str(arg)) = constant_simple(cx, cx.typeck_results(), arg);\n+            let value = Symbol::intern(&arg).as_u32();\n+            if let Some(&def_id) = self.symbol_map.get(&value);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    INTERNING_DEFINED_SYMBOL,\n+                    is_expn_of(expr.span, \"sym\").unwrap_or(expr.span),\n+                    \"interning a defined symbol\",\n+                    \"try\",\n+                    cx.tcx.def_path_str(def_id),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        if let ExprKind::Binary(op, left, right) = expr.kind {\n+            if matches!(op.node, BinOpKind::Eq | BinOpKind::Ne) {\n+                let data = [\n+                    (left, self.symbol_str_expr(left, cx)),\n+                    (right, self.symbol_str_expr(right, cx)),\n+                ];\n+                match data {\n+                    // both operands are a symbol string\n+                    [(_, Some(left)), (_, Some(right))] => {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            UNNECESSARY_SYMBOL_STR,\n+                            expr.span,\n+                            \"unnecessary `Symbol` to string conversion\",\n+                            \"try\",\n+                            format!(\n+                                \"{} {} {}\",\n+                                left.as_symbol_snippet(cx),\n+                                op.node.as_str(),\n+                                right.as_symbol_snippet(cx),\n+                            ),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n+                    // one of the operands is a symbol string\n+                    [(expr, Some(symbol)), _] | [_, (expr, Some(symbol))] => {\n+                        // creating an owned string for comparison\n+                        if matches!(symbol, SymbolStrExpr::Expr { is_to_owned: true, .. }) {\n+                            span_lint_and_sugg(\n+                                cx,\n+                                UNNECESSARY_SYMBOL_STR,\n+                                expr.span,\n+                                \"unnecessary string allocation\",\n+                                \"try\",\n+                                format!(\"{}.as_str()\", symbol.as_symbol_snippet(cx)),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    },\n+                    // nothing found\n+                    [(_, None), (_, None)] => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl InterningDefinedSymbol {\n+    fn symbol_str_expr<'tcx>(&self, expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> Option<SymbolStrExpr<'tcx>> {\n+        static IDENT_STR_PATHS: &[&[&str]] = &[&paths::IDENT_AS_STR, &paths::TO_STRING_METHOD];\n+        static SYMBOL_STR_PATHS: &[&[&str]] = &[\n+            &paths::SYMBOL_AS_STR,\n+            &paths::SYMBOL_TO_IDENT_STRING,\n+            &paths::TO_STRING_METHOD,\n+        ];\n+        let call = if_chain! {\n+            if let ExprKind::AddrOf(_, _, e) = expr.kind;\n+            if let ExprKind::Unary(UnOp::Deref, e) = e.kind;\n+            then { e } else { expr }\n+        };\n+        if_chain! {\n+            // is a method call\n+            if let ExprKind::MethodCall(_, item, [], _) = call.kind;\n+            if let Some(did) = cx.typeck_results().type_dependent_def_id(call.hir_id);\n+            let ty = cx.typeck_results().expr_ty(item);\n+            // ...on either an Ident or a Symbol\n+            if let Some(is_ident) = if match_type(cx, ty, &paths::SYMBOL) {\n+                Some(false)\n+            } else if match_type(cx, ty, &paths::IDENT) {\n+                Some(true)\n+            } else {\n+                None\n+            };\n+            // ...which converts it to a string\n+            let paths = if is_ident { IDENT_STR_PATHS } else { SYMBOL_STR_PATHS };\n+            if let Some(path) = paths.iter().find(|path| match_def_path(cx, did, path));\n+            then {\n+                let is_to_owned = path.last().unwrap().ends_with(\"string\");\n+                return Some(SymbolStrExpr::Expr {\n+                    item,\n+                    is_ident,\n+                    is_to_owned,\n+                });\n+            }\n+        }\n+        // is a string constant\n+        if let Some(Constant::Str(s)) = constant_simple(cx, cx.typeck_results(), expr) {\n+            let value = Symbol::intern(&s).as_u32();\n+            // ...which matches a symbol constant\n+            if let Some(&def_id) = self.symbol_map.get(&value) {\n+                return Some(SymbolStrExpr::Const(def_id));\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+enum SymbolStrExpr<'tcx> {\n+    /// a string constant with a corresponding symbol constant\n+    Const(DefId),\n+    /// a \"symbol to string\" expression like `symbol.as_str()`\n+    Expr {\n+        /// part that evaluates to `Symbol` or `Ident`\n+        item: &'tcx Expr<'tcx>,\n+        is_ident: bool,\n+        /// whether an owned `String` is created like `to_ident_string()`\n+        is_to_owned: bool,\n+    },\n+}\n+\n+impl<'tcx> SymbolStrExpr<'tcx> {\n+    /// Returns a snippet that evaluates to a `Symbol` and is const if possible\n+    fn as_symbol_snippet(&self, cx: &LateContext<'_>) -> Cow<'tcx, str> {\n+        match *self {\n+            Self::Const(def_id) => cx.tcx.def_path_str(def_id).into(),\n+            Self::Expr { item, is_ident, .. } => {\n+                let mut snip = snippet(cx, item.span.source_callsite(), \"..\");\n+                if is_ident {\n+                    // get `Ident.name`\n+                    snip.to_mut().push_str(\".name\");\n+                }\n+                snip\n+            },\n+        }\n+    }\n+}"}, {"sha": "57eb3f49d062f4aced0645a72e6fe6da750f3eda", "filename": "clippy_lints/src/utils/internal_lints/invalid_paths.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -0,0 +1,105 @@\n+use clippy_utils::consts::{constant_simple, Constant};\n+use clippy_utils::def_path_res;\n+use clippy_utils::diagnostics::span_lint;\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::Item;\n+use rustc_hir_analysis::hir_ty_to_ty;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, fast_reject::SimplifiedTypeGen, FloatTy};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Symbol;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks the paths module for invalid paths.\n+    ///\n+    /// ### Why is this bad?\n+    /// It indicates a bug in the code.\n+    ///\n+    /// ### Example\n+    /// None.\n+    pub INVALID_PATHS,\n+    internal,\n+    \"invalid path\"\n+}\n+\n+// This is not a complete resolver for paths. It works on all the paths currently used in the paths\n+// module.  That's all it does and all it needs to do.\n+pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n+    if def_path_res(cx, path, None) != Res::Err {\n+        return true;\n+    }\n+\n+    // Some implementations can't be found by `path_to_res`, particularly inherent\n+    // implementations of native types. Check lang items.\n+    let path_syms: Vec<_> = path.iter().map(|p| Symbol::intern(p)).collect();\n+    let lang_items = cx.tcx.lang_items();\n+    // This list isn't complete, but good enough for our current list of paths.\n+    let incoherent_impls = [\n+        SimplifiedTypeGen::FloatSimplifiedType(FloatTy::F32),\n+        SimplifiedTypeGen::FloatSimplifiedType(FloatTy::F64),\n+        SimplifiedTypeGen::SliceSimplifiedType,\n+        SimplifiedTypeGen::StrSimplifiedType,\n+    ]\n+    .iter()\n+    .flat_map(|&ty| cx.tcx.incoherent_impls(ty));\n+    for item_def_id in lang_items.items().iter().flatten().chain(incoherent_impls) {\n+        let lang_item_path = cx.get_def_path(*item_def_id);\n+        if path_syms.starts_with(&lang_item_path) {\n+            if let [item] = &path_syms[lang_item_path.len()..] {\n+                if matches!(\n+                    cx.tcx.def_kind(*item_def_id),\n+                    DefKind::Mod | DefKind::Enum | DefKind::Trait\n+                ) {\n+                    for child in cx.tcx.module_children(*item_def_id) {\n+                        if child.ident.name == *item {\n+                            return true;\n+                        }\n+                    }\n+                } else {\n+                    for child in cx.tcx.associated_item_def_ids(*item_def_id) {\n+                        if cx.tcx.item_name(*child) == *item {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n+declare_lint_pass!(InvalidPaths => [INVALID_PATHS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        let local_def_id = &cx.tcx.parent_module(item.hir_id());\n+        let mod_name = &cx.tcx.item_name(local_def_id.to_def_id());\n+        if_chain! {\n+            if mod_name.as_str() == \"paths\";\n+            if let hir::ItemKind::Const(ty, body_id) = item.kind;\n+            let ty = hir_ty_to_ty(cx.tcx, ty);\n+            if let ty::Array(el_ty, _) = &ty.kind();\n+            if let ty::Ref(_, el_ty, _) = &el_ty.kind();\n+            if el_ty.is_str();\n+            let body = cx.tcx.hir().body(body_id);\n+            let typeck_results = cx.tcx.typeck_body(body_id);\n+            if let Some(Constant::Vec(path)) = constant_simple(cx, typeck_results, body.value);\n+            let path: Vec<&str> = path.iter().map(|x| {\n+                    if let Constant::Str(s) = x {\n+                        s.as_str()\n+                    } else {\n+                        // We checked the type of the constant above\n+                        unreachable!()\n+                    }\n+                }).collect();\n+            if !check_path(cx, &path[..]);\n+            then {\n+                span_lint(cx, INVALID_PATHS, item.span, \"invalid path\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "06dfc6e43607128c568e3843fbfb7a3a4d0cbbd4", "filename": "clippy_lints/src/utils/internal_lints/lint_without_lint_pass.rs", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -0,0 +1,346 @@\n+use crate::utils::internal_lints::metadata_collector::is_deprecated_lint;\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n+use clippy_utils::macros::root_macro_call_first_node;\n+use clippy_utils::{is_lint_allowed, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_ast as ast;\n+use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::hir_id::CRATE_HIR_ID;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{ExprKind, HirId, Item, MutTy, Mutability, Path, TyKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::nested_filter;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::source_map::Spanned;\n+use rustc_span::symbol::Symbol;\n+use rustc_span::{sym, Span};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Ensures every lint is associated to a `LintPass`.\n+    ///\n+    /// ### Why is this bad?\n+    /// The compiler only knows lints via a `LintPass`. Without\n+    /// putting a lint to a `LintPass::get_lints()`'s return, the compiler will not\n+    /// know the name of the lint.\n+    ///\n+    /// ### Known problems\n+    /// Only checks for lints associated using the\n+    /// `declare_lint_pass!`, `impl_lint_pass!`, and `lint_array!` macros.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// declare_lint! { pub LINT_1, ... }\n+    /// declare_lint! { pub LINT_2, ... }\n+    /// declare_lint! { pub FORGOTTEN_LINT, ... }\n+    /// // ...\n+    /// declare_lint_pass!(Pass => [LINT_1, LINT_2]);\n+    /// // missing FORGOTTEN_LINT\n+    /// ```\n+    pub LINT_WITHOUT_LINT_PASS,\n+    internal,\n+    \"declaring a lint without associating it in a LintPass\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for cases of an auto-generated lint without an updated description,\n+    /// i.e. `default lint description`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Indicates that the lint is not finished.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// declare_lint! { pub COOL_LINT, nursery, \"default lint description\" }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// declare_lint! { pub COOL_LINT, nursery, \"a great new lint\" }\n+    /// ```\n+    pub DEFAULT_LINT,\n+    internal,\n+    \"found 'default lint description' in a lint declaration\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for invalid `clippy::version` attributes.\n+    ///\n+    /// Valid values are:\n+    /// * \"pre 1.29.0\"\n+    /// * any valid semantic version\n+    pub INVALID_CLIPPY_VERSION_ATTRIBUTE,\n+    internal,\n+    \"found an invalid `clippy::version` attribute\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for declared clippy lints without the `clippy::version` attribute.\n+    ///\n+    pub MISSING_CLIPPY_VERSION_ATTRIBUTE,\n+    internal,\n+    \"found clippy lint without `clippy::version` attribute\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for cases of an auto-generated deprecated lint without an updated reason,\n+    /// i.e. `\"default deprecation note\"`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Indicates that the documentation is incomplete.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// declare_deprecated_lint! {\n+    ///     /// ### What it does\n+    ///     /// Nothing. This lint has been deprecated.\n+    ///     ///\n+    ///     /// ### Deprecation reason\n+    ///     /// TODO\n+    ///     #[clippy::version = \"1.63.0\"]\n+    ///     pub COOL_LINT,\n+    ///     \"default deprecation note\"\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// declare_deprecated_lint! {\n+    ///     /// ### What it does\n+    ///     /// Nothing. This lint has been deprecated.\n+    ///     ///\n+    ///     /// ### Deprecation reason\n+    ///     /// This lint has been replaced by `cooler_lint`\n+    ///     #[clippy::version = \"1.63.0\"]\n+    ///     pub COOL_LINT,\n+    ///     \"this lint has been replaced by `cooler_lint`\"\n+    /// }\n+    /// ```\n+    pub DEFAULT_DEPRECATION_REASON,\n+    internal,\n+    \"found 'default deprecation note' in a deprecated lint declaration\"\n+}\n+\n+#[derive(Clone, Debug, Default)]\n+pub struct LintWithoutLintPass {\n+    declared_lints: FxHashMap<Symbol, Span>,\n+    registered_lints: FxHashSet<Symbol>,\n+}\n+\n+impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS, INVALID_CLIPPY_VERSION_ATTRIBUTE, MISSING_CLIPPY_VERSION_ATTRIBUTE, DEFAULT_DEPRECATION_REASON]);\n+\n+impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        if is_lint_allowed(cx, DEFAULT_LINT, item.hir_id())\n+            || is_lint_allowed(cx, DEFAULT_DEPRECATION_REASON, item.hir_id())\n+        {\n+            return;\n+        }\n+\n+        if let hir::ItemKind::Static(ty, Mutability::Not, body_id) = item.kind {\n+            let is_lint_ref_ty = is_lint_ref_type(cx, ty);\n+            if is_deprecated_lint(cx, ty) || is_lint_ref_ty {\n+                check_invalid_clippy_version_attribute(cx, item);\n+\n+                let expr = &cx.tcx.hir().body(body_id).value;\n+                let fields;\n+                if is_lint_ref_ty {\n+                    if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind\n+                        && let ExprKind::Struct(_, struct_fields, _) = inner_exp.kind {\n+                            fields = struct_fields;\n+                    } else {\n+                        return;\n+                    }\n+                } else if let ExprKind::Struct(_, struct_fields, _) = expr.kind {\n+                    fields = struct_fields;\n+                } else {\n+                    return;\n+                }\n+\n+                let field = fields\n+                    .iter()\n+                    .find(|f| f.ident.as_str() == \"desc\")\n+                    .expect(\"lints must have a description field\");\n+\n+                if let ExprKind::Lit(Spanned {\n+                    node: LitKind::Str(ref sym, _),\n+                    ..\n+                }) = field.expr.kind\n+                {\n+                    let sym_str = sym.as_str();\n+                    if is_lint_ref_ty {\n+                        if sym_str == \"default lint description\" {\n+                            span_lint(\n+                                cx,\n+                                DEFAULT_LINT,\n+                                item.span,\n+                                &format!(\"the lint `{}` has the default lint description\", item.ident.name),\n+                            );\n+                        }\n+\n+                        self.declared_lints.insert(item.ident.name, item.span);\n+                    } else if sym_str == \"default deprecation note\" {\n+                        span_lint(\n+                            cx,\n+                            DEFAULT_DEPRECATION_REASON,\n+                            item.span,\n+                            &format!(\"the lint `{}` has the default deprecation reason\", item.ident.name),\n+                        );\n+                    }\n+                }\n+            }\n+        } else if let Some(macro_call) = root_macro_call_first_node(cx, item) {\n+            if !matches!(\n+                cx.tcx.item_name(macro_call.def_id).as_str(),\n+                \"impl_lint_pass\" | \"declare_lint_pass\"\n+            ) {\n+                return;\n+            }\n+            if let hir::ItemKind::Impl(hir::Impl {\n+                of_trait: None,\n+                items: impl_item_refs,\n+                ..\n+            }) = item.kind\n+            {\n+                let mut collector = LintCollector {\n+                    output: &mut self.registered_lints,\n+                    cx,\n+                };\n+                let body_id = cx.tcx.hir().body_owned_by(\n+                    cx.tcx.hir().local_def_id(\n+                        impl_item_refs\n+                            .iter()\n+                            .find(|iiref| iiref.ident.as_str() == \"get_lints\")\n+                            .expect(\"LintPass needs to implement get_lints\")\n+                            .id\n+                            .hir_id(),\n+                    ),\n+                );\n+                collector.visit_expr(cx.tcx.hir().body(body_id).value);\n+            }\n+        }\n+    }\n+\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n+        if is_lint_allowed(cx, LINT_WITHOUT_LINT_PASS, CRATE_HIR_ID) {\n+            return;\n+        }\n+\n+        for (lint_name, &lint_span) in &self.declared_lints {\n+            // When using the `declare_tool_lint!` macro, the original `lint_span`'s\n+            // file points to \"<rustc macros>\".\n+            // `compiletest-rs` thinks that's an error in a different file and\n+            // just ignores it. This causes the test in compile-fail/lint_pass\n+            // not able to capture the error.\n+            // Therefore, we need to climb the macro expansion tree and find the\n+            // actual span that invoked `declare_tool_lint!`:\n+            let lint_span = lint_span.ctxt().outer_expn_data().call_site;\n+\n+            if !self.registered_lints.contains(lint_name) {\n+                span_lint(\n+                    cx,\n+                    LINT_WITHOUT_LINT_PASS,\n+                    lint_span,\n+                    &format!(\"the lint `{lint_name}` is not added to any `LintPass`\"),\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+pub(super) fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &hir::Ty<'_>) -> bool {\n+    if let TyKind::Rptr(\n+        _,\n+        MutTy {\n+            ty: inner,\n+            mutbl: Mutability::Not,\n+        },\n+    ) = ty.kind\n+    {\n+        if let TyKind::Path(ref path) = inner.kind {\n+            if let Res::Def(DefKind::Struct, def_id) = cx.qpath_res(path, inner.hir_id) {\n+                return match_def_path(cx, def_id, &paths::LINT);\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn check_invalid_clippy_version_attribute(cx: &LateContext<'_>, item: &'_ Item<'_>) {\n+    if let Some(value) = extract_clippy_version_value(cx, item) {\n+        // The `sym!` macro doesn't work as it only expects a single token.\n+        // It's better to keep it this way and have a direct `Symbol::intern` call here.\n+        if value == Symbol::intern(\"pre 1.29.0\") {\n+            return;\n+        }\n+\n+        if RustcVersion::parse(value.as_str()).is_err() {\n+            span_lint_and_help(\n+                cx,\n+                INVALID_CLIPPY_VERSION_ATTRIBUTE,\n+                item.span,\n+                \"this item has an invalid `clippy::version` attribute\",\n+                None,\n+                \"please use a valid semantic version, see `doc/adding_lints.md`\",\n+            );\n+        }\n+    } else {\n+        span_lint_and_help(\n+            cx,\n+            MISSING_CLIPPY_VERSION_ATTRIBUTE,\n+            item.span,\n+            \"this lint is missing the `clippy::version` attribute or version value\",\n+            None,\n+            \"please use a `clippy::version` attribute, see `doc/adding_lints.md`\",\n+        );\n+    }\n+}\n+\n+/// This function extracts the version value of a `clippy::version` attribute if the given value has\n+/// one\n+pub(super) fn extract_clippy_version_value(cx: &LateContext<'_>, item: &'_ Item<'_>) -> Option<Symbol> {\n+    let attrs = cx.tcx.hir().attrs(item.hir_id());\n+    attrs.iter().find_map(|attr| {\n+        if_chain! {\n+            // Identify attribute\n+            if let ast::AttrKind::Normal(ref attr_kind) = &attr.kind;\n+            if let [tool_name, attr_name] = &attr_kind.item.path.segments[..];\n+            if tool_name.ident.name == sym::clippy;\n+            if attr_name.ident.name == sym::version;\n+            if let Some(version) = attr.value_str();\n+            then {\n+                Some(version)\n+            } else {\n+                None\n+            }\n+        }\n+    })\n+}\n+\n+struct LintCollector<'a, 'tcx> {\n+    output: &'a mut FxHashSet<Symbol>,\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for LintCollector<'a, 'tcx> {\n+    type NestedFilter = nested_filter::All;\n+\n+    fn visit_path(&mut self, path: &'tcx Path<'_>, _: HirId) {\n+        if path.segments.len() == 1 {\n+            self.output.insert(path.segments[0].ident.name);\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.cx.tcx.hir()\n+    }\n+}"}, {"sha": "8efe170a1e5d00cbe11aad54c2ef280c518c803a", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -8,7 +8,7 @@\n //! a simple mistake)\n \n use crate::renamed_lints::RENAMED_LINTS;\n-use crate::utils::internal_lints::{extract_clippy_version_value, is_lint_ref_type};\n+use crate::utils::internal_lints::lint_without_lint_pass::{extract_clippy_version_value, is_lint_ref_type};\n \n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::{match_type, walk_ptrs_ty_depth};"}, {"sha": "1e994e3f2b1713b1c2cef1502479177d8f7566e0", "filename": "clippy_lints/src/utils/internal_lints/msrv_attr_impl.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmsrv_attr_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmsrv_attr_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmsrv_attr_impl.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -0,0 +1,63 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::{match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir_analysis::hir_ty_to_ty;\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::ty::{self, subst::GenericArgKind};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Check that the `extract_msrv_attr!` macro is used, when a lint has a MSRV.\n+    ///\n+    pub MISSING_MSRV_ATTR_IMPL,\n+    internal,\n+    \"checking if all necessary steps were taken when adding a MSRV to a lint\"\n+}\n+\n+declare_lint_pass!(MsrvAttrImpl => [MISSING_MSRV_ATTR_IMPL]);\n+\n+impl LateLintPass<'_> for MsrvAttrImpl {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n+        if_chain! {\n+            if let hir::ItemKind::Impl(hir::Impl {\n+                of_trait: Some(lint_pass_trait_ref),\n+                self_ty,\n+                items,\n+                ..\n+            }) = &item.kind;\n+            if let Some(lint_pass_trait_def_id) = lint_pass_trait_ref.trait_def_id();\n+            let is_late_pass = match_def_path(cx, lint_pass_trait_def_id, &paths::LATE_LINT_PASS);\n+            if is_late_pass || match_def_path(cx, lint_pass_trait_def_id, &paths::EARLY_LINT_PASS);\n+            let self_ty = hir_ty_to_ty(cx.tcx, self_ty);\n+            if let ty::Adt(self_ty_def, _) = self_ty.kind();\n+            if self_ty_def.is_struct();\n+            if self_ty_def.all_fields().any(|f| {\n+                cx.tcx\n+                    .type_of(f.did)\n+                    .walk()\n+                    .filter(|t| matches!(t.unpack(), GenericArgKind::Type(_)))\n+                    .any(|t| match_type(cx, t.expect_ty(), &paths::RUSTC_VERSION))\n+            });\n+            if !items.iter().any(|item| item.ident.name == sym!(enter_lint_attrs));\n+            then {\n+                let context = if is_late_pass { \"LateContext\" } else { \"EarlyContext\" };\n+                let lint_pass = if is_late_pass { \"LateLintPass\" } else { \"EarlyLintPass\" };\n+                let span = cx.sess().source_map().span_through_char(item.span, '{');\n+                span_lint_and_sugg(\n+                    cx,\n+                    MISSING_MSRV_ATTR_IMPL,\n+                    span,\n+                    &format!(\"`extract_msrv_attr!` macro missing from `{lint_pass}` implementation\"),\n+                    &format!(\"add `extract_msrv_attr!({context})` to the `{lint_pass}` implementation\"),\n+                    format!(\"{}\\n    extract_msrv_attr!({context});\", snippet(cx, span, \"..\")),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "3bc05d69579a5e0c71f5183a232e7965f0a2f9af", "filename": "clippy_lints/src/utils/internal_lints/outer_expn_data_pass.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fouter_expn_data_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fouter_expn_data_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fouter_expn_data_pass.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -0,0 +1,62 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::{is_lint_allowed, method_calls, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Symbol;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for calls to `cx.outer().expn_data()` and suggests to use\n+    /// the `cx.outer_expn_data()`\n+    ///\n+    /// ### Why is this bad?\n+    /// `cx.outer_expn_data()` is faster and more concise.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// expr.span.ctxt().outer().expn_data()\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// expr.span.ctxt().outer_expn_data()\n+    /// ```\n+    pub OUTER_EXPN_EXPN_DATA,\n+    internal,\n+    \"using `cx.outer_expn().expn_data()` instead of `cx.outer_expn_data()`\"\n+}\n+\n+declare_lint_pass!(OuterExpnDataPass => [OUTER_EXPN_EXPN_DATA]);\n+\n+impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if is_lint_allowed(cx, OUTER_EXPN_EXPN_DATA, expr.hir_id) {\n+            return;\n+        }\n+\n+        let (method_names, arg_lists, spans) = method_calls(expr, 2);\n+        let method_names: Vec<&str> = method_names.iter().map(Symbol::as_str).collect();\n+        if_chain! {\n+            if let [\"expn_data\", \"outer_expn\"] = method_names.as_slice();\n+            let (self_arg, args)= arg_lists[1];\n+            if args.is_empty();\n+            let self_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n+            if match_type(cx, self_ty, &paths::SYNTAX_CONTEXT);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    OUTER_EXPN_EXPN_DATA,\n+                    spans[1].with_hi(expr.span.hi()),\n+                    \"usage of `outer_expn().expn_data()`\",\n+                    \"try\",\n+                    \"outer_expn_data()\".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "5899b94e16ba241e078300d5760ca6537a525ec3", "filename": "clippy_lints/src/utils/internal_lints/produce_ice.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fproduce_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fproduce_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fproduce_ice.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -0,0 +1,37 @@\n+use rustc_ast::ast::NodeId;\n+use rustc_ast::visit::FnKind;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Not an actual lint. This lint is only meant for testing our customized internal compiler\n+    /// error message by calling `panic`.\n+    ///\n+    /// ### Why is this bad?\n+    /// ICE in large quantities can damage your teeth\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// \ud83c\udf66\ud83c\udf66\ud83c\udf66\ud83c\udf66\ud83c\udf66\n+    /// ```\n+    pub PRODUCE_ICE,\n+    internal,\n+    \"this message should not appear anywhere as we ICE before and don't emit the lint\"\n+}\n+\n+declare_lint_pass!(ProduceIce => [PRODUCE_ICE]);\n+\n+impl EarlyLintPass for ProduceIce {\n+    fn check_fn(&mut self, _: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: Span, _: NodeId) {\n+        assert!(!is_trigger_fn(fn_kind), \"Would you like some help with that?\");\n+    }\n+}\n+\n+fn is_trigger_fn(fn_kind: FnKind<'_>) -> bool {\n+    match fn_kind {\n+        FnKind::Fn(_, ident, ..) => ident.name.as_str() == \"it_looks_like_you_are_trying_to_kill_clippy\",\n+        FnKind::Closure(..) => false,\n+    }\n+}"}, {"sha": "9b524d5b07af63e5be50cd583be7847c880636c5", "filename": "clippy_lints/src/utils/internal_lints/unnecessary_def_path.rs", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -0,0 +1,260 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{def_path_res, is_lint_allowed, match_any_def_paths, peel_hir_expr_refs};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Namespace, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{ExprKind, Local, Mutability, Node};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::mir::interpret::{Allocation, ConstValue, GlobalAlloc};\n+use rustc_middle::ty::{self, AssocKind, DefIdTree, Ty};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::{Ident, Symbol};\n+\n+use std::str;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usages of def paths when a diagnostic item or a `LangItem` could be used.\n+    ///\n+    /// ### Why is this bad?\n+    /// The path for an item is subject to change and is less efficient to look up than a\n+    /// diagnostic item or a `LangItem`.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// utils::match_type(cx, ty, &paths::VEC)\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// utils::is_type_diagnostic_item(cx, ty, sym::Vec)\n+    /// ```\n+    pub UNNECESSARY_DEF_PATH,\n+    internal,\n+    \"using a def path when a diagnostic item or a `LangItem` is available\"\n+}\n+\n+declare_lint_pass!(UnnecessaryDefPath => [UNNECESSARY_DEF_PATH]);\n+\n+#[allow(clippy::too_many_lines)]\n+impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        enum Item {\n+            LangItem(Symbol),\n+            DiagnosticItem(Symbol),\n+        }\n+        static PATHS: &[&[&str]] = &[\n+            &[\"clippy_utils\", \"match_def_path\"],\n+            &[\"clippy_utils\", \"match_trait_method\"],\n+            &[\"clippy_utils\", \"ty\", \"match_type\"],\n+            &[\"clippy_utils\", \"is_expr_path_def_path\"],\n+        ];\n+\n+        if is_lint_allowed(cx, UNNECESSARY_DEF_PATH, expr.hir_id) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let ExprKind::Call(func, [cx_arg, def_arg, args@..]) = expr.kind;\n+            if let ExprKind::Path(path) = &func.kind;\n+            if let Some(id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n+            if let Some(which_path) = match_any_def_paths(cx, id, PATHS);\n+            let item_arg = if which_path == 4 { &args[1] } else { &args[0] };\n+            // Extract the path to the matched type\n+            if let Some(segments) = path_to_matched_type(cx, item_arg);\n+            let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n+            if let Some(def_id) = def_path_res(cx, &segments[..], None).opt_def_id();\n+            then {\n+                // def_path_res will match field names before anything else, but for this we want to match\n+                // inherent functions first.\n+                let def_id = if cx.tcx.def_kind(def_id) == DefKind::Field {\n+                    let method_name = *segments.last().unwrap();\n+                    cx.tcx.def_key(def_id).parent\n+                        .and_then(|parent_idx|\n+                            cx.tcx.inherent_impls(DefId { index: parent_idx, krate: def_id.krate }).iter()\n+                                .find_map(|impl_id| cx.tcx.associated_items(*impl_id)\n+                                    .find_by_name_and_kind(\n+                                        cx.tcx,\n+                                        Ident::from_str(method_name),\n+                                        AssocKind::Fn,\n+                                        *impl_id,\n+                                    )\n+                                )\n+                        )\n+                        .map_or(def_id, |item| item.def_id)\n+                } else {\n+                    def_id\n+                };\n+\n+                // Check if the target item is a diagnostic item or LangItem.\n+                let (msg, item) = if let Some(item_name)\n+                    = cx.tcx.diagnostic_items(def_id.krate).id_to_name.get(&def_id)\n+                {\n+                    (\n+                        \"use of a def path to a diagnostic item\",\n+                        Item::DiagnosticItem(*item_name),\n+                    )\n+                } else if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n+                    let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"], Some(Namespace::TypeNS)).def_id();\n+                    let item_name = cx.tcx.adt_def(lang_items).variants().iter().nth(lang_item).unwrap().name;\n+                    (\n+                        \"use of a def path to a `LangItem`\",\n+                        Item::LangItem(item_name),\n+                    )\n+                } else {\n+                    return;\n+                };\n+\n+                let has_ctor = match cx.tcx.def_kind(def_id) {\n+                    DefKind::Struct => {\n+                        let variant = cx.tcx.adt_def(def_id).non_enum_variant();\n+                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                    }\n+                    DefKind::Variant => {\n+                        let variant = cx.tcx.adt_def(cx.tcx.parent(def_id)).variant_with_id(def_id);\n+                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                    }\n+                    _ => false,\n+                };\n+\n+                let mut app = Applicability::MachineApplicable;\n+                let cx_snip = snippet_with_applicability(cx, cx_arg.span, \"..\", &mut app);\n+                let def_snip = snippet_with_applicability(cx, def_arg.span, \"..\", &mut app);\n+                let (sugg, with_note) = match (which_path, item) {\n+                    // match_def_path\n+                    (0, Item::DiagnosticItem(item)) =>\n+                        (format!(\"{cx_snip}.tcx.is_diagnostic_item(sym::{item}, {def_snip})\"), has_ctor),\n+                    (0, Item::LangItem(item)) => (\n+                        format!(\"{cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some({def_snip})\"),\n+                        has_ctor\n+                    ),\n+                    // match_trait_method\n+                    (1, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_trait_method({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    // match_type\n+                    (2, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_type_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    (2, Item::LangItem(item)) =>\n+                        (format!(\"is_type_lang_item({cx_snip}, {def_snip}, LangItem::{item})\"), false),\n+                    // is_expr_path_def_path\n+                    (3, Item::DiagnosticItem(item)) if has_ctor => (\n+                        format!(\n+                            \"is_res_diag_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), sym::{item})\",\n+                        ),\n+                        false,\n+                    ),\n+                    (3, Item::LangItem(item)) if has_ctor => (\n+                        format!(\n+                            \"is_res_lang_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), LangItem::{item})\",\n+                        ),\n+                        false,\n+                    ),\n+                    (3, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_path_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    (3, Item::LangItem(item)) => (\n+                        format!(\n+                            \"path_res({cx_snip}, {def_snip}).opt_def_id()\\\n+                                .map_or(false, |id| {cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some(id))\",\n+                        ),\n+                        false,\n+                    ),\n+                    _ => return,\n+                };\n+\n+                span_lint_and_then(\n+                    cx,\n+                    UNNECESSARY_DEF_PATH,\n+                    expr.span,\n+                    msg,\n+                    |diag| {\n+                        diag.span_suggestion(expr.span, \"try\", sugg, app);\n+                        if with_note {\n+                            diag.help(\n+                                \"if this `DefId` came from a constructor expression or pattern then the \\\n+                                    parent `DefId` should be used instead\"\n+                            );\n+                        }\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<String>> {\n+    match peel_hir_expr_refs(expr).0.kind {\n+        ExprKind::Path(ref qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n+            Res::Local(hir_id) => {\n+                let parent_id = cx.tcx.hir().get_parent_node(hir_id);\n+                if let Some(Node::Local(Local { init: Some(init), .. })) = cx.tcx.hir().find(parent_id) {\n+                    path_to_matched_type(cx, init)\n+                } else {\n+                    None\n+                }\n+            },\n+            Res::Def(DefKind::Static(_), def_id) => read_mir_alloc_def_path(\n+                cx,\n+                cx.tcx.eval_static_initializer(def_id).ok()?.inner(),\n+                cx.tcx.type_of(def_id),\n+            ),\n+            Res::Def(DefKind::Const, def_id) => match cx.tcx.const_eval_poly(def_id).ok()? {\n+                ConstValue::ByRef { alloc, offset } if offset.bytes() == 0 => {\n+                    read_mir_alloc_def_path(cx, alloc.inner(), cx.tcx.type_of(def_id))\n+                },\n+                _ => None,\n+            },\n+            _ => None,\n+        },\n+        ExprKind::Array(exprs) => exprs\n+            .iter()\n+            .map(|expr| {\n+                if let ExprKind::Lit(lit) = &expr.kind {\n+                    if let LitKind::Str(sym, _) = lit.node {\n+                        return Some((*sym.as_str()).to_owned());\n+                    }\n+                }\n+\n+                None\n+            })\n+            .collect(),\n+        _ => None,\n+    }\n+}\n+\n+fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation, ty: Ty<'_>) -> Option<Vec<String>> {\n+    let (alloc, ty) = if let ty::Ref(_, ty, Mutability::Not) = *ty.kind() {\n+        let &alloc = alloc.provenance().values().next()?;\n+        if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n+            (alloc.inner(), ty)\n+        } else {\n+            return None;\n+        }\n+    } else {\n+        (alloc, ty)\n+    };\n+\n+    if let ty::Array(ty, _) | ty::Slice(ty) = *ty.kind()\n+        && let ty::Ref(_, ty, Mutability::Not) = *ty.kind()\n+        && ty.is_str()\n+    {\n+        alloc\n+            .provenance()\n+            .values()\n+            .map(|&alloc| {\n+                if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n+                    let alloc = alloc.inner();\n+                    str::from_utf8(alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()))\n+                        .ok().map(ToOwned::to_owned)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect()\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "07c5941013c1af5d6b89a661100c9b2a42e01801", "filename": "tests/ui-internal/custom_ice_message.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfd3525cff90fe2363494559499276ca07d2aef7/tests%2Fui-internal%2Fcustom_ice_message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dfd3525cff90fe2363494559499276ca07d2aef7/tests%2Fui-internal%2Fcustom_ice_message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcustom_ice_message.stderr?ref=dfd3525cff90fe2363494559499276ca07d2aef7", "patch": "@@ -1,4 +1,4 @@\n-thread 'rustc' panicked at 'Would you like some help with that?', clippy_lints/src/utils/internal_lints.rs\n+thread 'rustc' panicked at 'Would you like some help with that?', clippy_lints/src/utils/internal_lints/produce_ice.rs:28:9\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n \n error: internal compiler error: unexpected panic"}]}