{"sha": "5ad1083e5bb6dfea0f4368031466b4f366dabf79", "node_id": "C_kwDOAAsO6NoAKDVhZDEwODNlNWJiNmRmZWEwZjQzNjgwMzE0NjZiNGYzNjZkYWJmNzk", "commit": {"author": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2023-03-15T15:09:29Z"}, "committer": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2023-03-15T15:09:29Z"}, "message": "Revert \"Auto merge of #107376 - aliemjay:remove-givens, r=lcnr\"\n\nThis reverts commit e84e5ff04a647ce28540300244a26ba120642eea, reversing\nchanges made to 1716932743a7b3705cbf0c34db0c4e070ed1930d.", "tree": {"sha": "172e89da4969ef214c237e0309f6aa494b249c20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/172e89da4969ef214c237e0309f6aa494b249c20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ad1083e5bb6dfea0f4368031466b4f366dabf79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ad1083e5bb6dfea0f4368031466b4f366dabf79", "html_url": "https://github.com/rust-lang/rust/commit/5ad1083e5bb6dfea0f4368031466b4f366dabf79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ad1083e5bb6dfea0f4368031466b4f366dabf79/comments", "author": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "992d154f3a84cc8abcefcf6e6cf3698e4821b506", "url": "https://api.github.com/repos/rust-lang/rust/commits/992d154f3a84cc8abcefcf6e6cf3698e4821b506", "html_url": "https://github.com/rust-lang/rust/commit/992d154f3a84cc8abcefcf6e6cf3698e4821b506"}], "stats": {"total": 239, "additions": 152, "deletions": 87}, "files": [{"sha": "6e6f8c1533bfea5a90fa848042d0e344b9353e8f", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=5ad1083e5bb6dfea0f4368031466b4f366dabf79", "patch": "@@ -330,6 +330,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     // lifetime parameters.\n     let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n+        Some(infcx),\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys.clone()),\n     );\n     infcx.process_registered_region_obligations(\n@@ -727,6 +728,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     // lifetime parameters.\n     let outlives_environment = OutlivesEnvironment::with_bounds(\n         param_env,\n+        Some(infcx),\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys),\n     );\n     infcx\n@@ -2056,7 +2058,8 @@ pub(super) fn check_type_bounds<'tcx>(\n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_def_id, assumed_wf_types);\n-    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n+    let outlives_environment =\n+        OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n \n     infcx.err_ctxt().check_region_obligations_and_report_errors(\n         impl_ty.def_id.expect_local(),"}, {"sha": "71050864ce0c514a2f914eb6a38cae8e4b521c0f", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=5ad1083e5bb6dfea0f4368031466b4f366dabf79", "patch": "@@ -115,7 +115,8 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n         return;\n     }\n \n-    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n+    let outlives_environment =\n+        OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n \n     let _ = infcx\n         .err_ctxt()\n@@ -675,6 +676,7 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     let infcx = tcx.infer_ctxt().build();\n     let outlives_environment = OutlivesEnvironment::with_bounds(\n         param_env,\n+        Some(&infcx),\n         infcx.implied_bounds_tys(param_env, id, wf_tys.clone()),\n     );\n     let region_bound_pairs = outlives_environment.region_bound_pairs();"}, {"sha": "58dd03811f78cf04ed5245ea8ec1114105860452", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=5ad1083e5bb6dfea0f4368031466b4f366dabf79", "patch": "@@ -179,7 +179,7 @@ fn get_impl_substs(\n     }\n \n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_def_id, assumed_wf_types);\n-    let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n+    let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n     let _ =\n         infcx.err_ctxt().check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {"}, {"sha": "c36c75e444368fb3c0bee4863145746bbadd5f1d", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=5ad1083e5bb6dfea0f4368031466b4f366dabf79", "patch": "@@ -238,8 +238,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Note that there are two tests to check that this remains true\n         // (`regions-reassign-{match,let}-bound-pointer.rs`).\n         //\n-        // 2. An outdated issue related to the old HIR borrowck. See the test\n+        // 2. Things go horribly wrong if we use subtype. The reason for\n+        // THIS is a fairly subtle case involving bound regions. See the\n+        // `givens` field in `region_constraints`, as well as the test\n         // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n+        // for details. Short version is that we must sometimes detect\n+        // relationships between specific region variables and regions\n+        // bound in a closure signature, and that detection gets thrown\n+        // off when we substitute fresh region variables here to enable\n+        // subtyping.\n     }\n \n     /// Compute the new expected type and default binding mode from the old ones"}, {"sha": "436d29c2449e4f925b2d748a2ec0d4ea3fca2e2f", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=5ad1083e5bb6dfea0f4368031466b4f366dabf79", "patch": "@@ -636,9 +636,11 @@ pub fn make_query_region_constraints<'tcx>(\n     outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>, ConstraintCategory<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> QueryRegionConstraints<'tcx> {\n-    let RegionConstraintData { constraints, verifys, member_constraints } = region_constraints;\n+    let RegionConstraintData { constraints, verifys, givens, member_constraints } =\n+        region_constraints;\n \n     assert!(verifys.is_empty());\n+    assert!(givens.is_empty());\n \n     debug!(?constraints);\n "}, {"sha": "2c480355085efc5fcb9ef24a049010e825cb12d3", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=5ad1083e5bb6dfea0f4368031466b4f366dabf79", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n use rustc_data_structures::intern::Interned;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::PlaceholderRegion;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -132,6 +132,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n \n         let graph = self.construct_graph();\n+        self.expand_givens(&graph);\n         self.expansion(&mut var_data);\n         self.collect_errors(&mut var_data, errors);\n         self.collect_var_errors(&var_data, &graph, errors);\n@@ -163,6 +164,38 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    fn expand_givens(&mut self, graph: &RegionGraph<'_>) {\n+        // Givens are a kind of horrible hack to account for\n+        // constraints like 'c <= '0 that are known to hold due to\n+        // closure signatures (see the comment above on the `givens`\n+        // field). They should go away. But until they do, the role\n+        // of this fn is to account for the transitive nature:\n+        //\n+        //     Given 'c <= '0\n+        //     and   '0 <= '1\n+        //     then  'c <= '1\n+\n+        let seeds: Vec<_> = self.data.givens.iter().cloned().collect();\n+        for (r, vid) in seeds {\n+            // While all things transitively reachable in the graph\n+            // from the variable (`'0` in the example above).\n+            let seed_index = NodeIndex(vid.index() as usize);\n+            for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n+                let succ_index = succ_index.0;\n+\n+                // The first N nodes correspond to the region\n+                // variables. Other nodes correspond to constant\n+                // regions.\n+                if succ_index < self.num_vars() {\n+                    let succ_vid = RegionVid::new(succ_index);\n+\n+                    // Add `'c <= '1`.\n+                    self.data.givens.insert((r, succ_vid));\n+                }\n+            }\n+        }\n+    }\n+\n     /// Gets the LUb of a given region and the empty region\n     fn lub_empty(&self, a_region: Region<'tcx>) -> Result<Region<'tcx>, PlaceholderRegion> {\n         match *a_region {\n@@ -329,6 +362,18 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     ) -> bool {\n         debug!(\"expand_node({:?}, {:?} == {:?})\", a_region, b_vid, b_data);\n \n+        match *a_region {\n+            // Check if this relationship is implied by a given.\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n+                if self.data.givens.contains(&(a_region, b_vid)) {\n+                    debug!(\"given\");\n+                    return false;\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+\n         match *b_data {\n             VarValue::Empty(empty_ui) => {\n                 let lub = match self.lub_empty(a_region) {"}, {"sha": "4a834957959dbef27b8df1247ed235c198fd1d9f", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=5ad1083e5bb6dfea0f4368031466b4f366dabf79", "patch": "@@ -855,6 +855,10 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.inner.borrow().undo_log.opaque_types_in_snapshot(&snapshot.undo_snapshot)\n     }\n \n+    pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n+        self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);\n+    }\n+\n     pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,"}, {"sha": "24e3c34dd94fc40d28b22d2ea7675f62b7618144", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=5ad1083e5bb6dfea0f4368031466b4f366dabf79", "patch": "@@ -1,9 +1,9 @@\n use crate::infer::free_regions::FreeRegionMap;\n-use crate::infer::GenericKind;\n+use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::OutlivesBound;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_data_structures::transitive_relation::TransitiveRelationBuilder;\n-use rustc_middle::ty::{self, Region};\n+use rustc_middle::ty::{self, ReEarlyBound, ReFree, ReVar, Region};\n \n use super::explicit_outlives_bounds;\n \n@@ -75,7 +75,7 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n             region_bound_pairs: Default::default(),\n         };\n \n-        builder.add_outlives_bounds(explicit_outlives_bounds(param_env));\n+        builder.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n \n         builder\n     }\n@@ -89,10 +89,11 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n     /// Create a new `OutlivesEnvironment` with extra outlives bounds.\n     pub fn with_bounds(\n         param_env: ty::ParamEnv<'tcx>,\n+        infcx: Option<&InferCtxt<'tcx>>,\n         extra_bounds: impl IntoIterator<Item = OutlivesBound<'tcx>>,\n     ) -> Self {\n         let mut builder = Self::builder(param_env);\n-        builder.add_outlives_bounds(extra_bounds);\n+        builder.add_outlives_bounds(infcx, extra_bounds);\n         builder.build()\n     }\n \n@@ -119,7 +120,12 @@ impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n     }\n \n     /// Processes outlives bounds that are known to hold, whether from implied or other sources.\n-    fn add_outlives_bounds<I>(&mut self, outlives_bounds: I)\n+    ///\n+    /// The `infcx` parameter is optional; if the implied bounds may\n+    /// contain inference variables, it must be supplied, in which\n+    /// case we will register \"givens\" on the inference context. (See\n+    /// `RegionConstraintData`.)\n+    fn add_outlives_bounds<I>(&mut self, infcx: Option<&InferCtxt<'tcx>>, outlives_bounds: I)\n     where\n         I: IntoIterator<Item = OutlivesBound<'tcx>>,\n     {\n@@ -136,14 +142,27 @@ impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n                     self.region_bound_pairs\n                         .insert(ty::OutlivesPredicate(GenericKind::Alias(alias_b), r_a));\n                 }\n-                OutlivesBound::RegionSubRegion(r_a, r_b) => match (*r_a, *r_b) {\n-                    (\n-                        ty::ReStatic | ty::ReEarlyBound(_) | ty::ReFree(_),\n-                        ty::ReStatic | ty::ReEarlyBound(_) | ty::ReFree(_),\n-                    ) => self.region_relation.add(r_a, r_b),\n-                    (ty::ReError(_), _) | (_, ty::ReError(_)) => {}\n-                    _ => bug!(\"add_outlives_bounds: unexpected regions\"),\n-                },\n+                OutlivesBound::RegionSubRegion(r_a, r_b) => {\n+                    if let (ReEarlyBound(_) | ReFree(_), ReVar(vid_b)) = (r_a.kind(), r_b.kind()) {\n+                        infcx\n+                            .expect(\"no infcx provided but region vars found\")\n+                            .add_given(r_a, vid_b);\n+                    } else {\n+                        // In principle, we could record (and take\n+                        // advantage of) every relationship here, but\n+                        // we are also free not to -- it simply means\n+                        // strictly less that we can successfully type\n+                        // check. Right now we only look for things\n+                        // relationships between free regions. (It may\n+                        // also be that we should revise our inference\n+                        // system to be more general and to make use\n+                        // of *every* relationship that arises here,\n+                        // but presently we do not.)\n+                        if r_a.is_free_or_static() && r_b.is_free() {\n+                            self.region_relation.add(r_a, r_b)\n+                        }\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "e413b2bb570d6b23d79a23c00bc121182c5d8b31", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=5ad1083e5bb6dfea0f4368031466b4f366dabf79", "patch": "@@ -424,6 +424,9 @@ impl<'tcx> MiniGraph<'tcx> {\n                 &AddConstraint(Constraint::RegSubReg(a, b)) => {\n                     each_edge(a, b);\n                 }\n+                &AddGiven(a, b) => {\n+                    each_edge(a, tcx.mk_re_var(b));\n+                }\n                 &AddVerify(i) => span_bug!(\n                     verifys[i].origin.span(),\n                     \"we never add verifications while doing higher-ranked things\","}, {"sha": "0b86d9c1fb82729a9d8ba444e0b9dcf8841a7b40", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=5ad1083e5bb6dfea0f4368031466b4f366dabf79", "patch": "@@ -7,7 +7,7 @@ use super::{\n     InferCtxtUndoLogs, MiscVariable, RegionVariableOrigin, Rollback, Snapshot, SubregionOrigin,\n };\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::UndoLogs;\n@@ -104,6 +104,26 @@ pub struct RegionConstraintData<'tcx> {\n     /// An example is a `A <= B` where neither `A` nor `B` are\n     /// inference variables.\n     pub verifys: Vec<Verify<'tcx>>,\n+\n+    /// A \"given\" is a relationship that is known to hold. In\n+    /// particular, we often know from closure fn signatures that a\n+    /// particular free region must be a subregion of a region\n+    /// variable:\n+    ///\n+    ///    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n+    ///\n+    /// In situations like this, `'b` is in fact a region variable\n+    /// introduced by the call to `iter()`, and `'a` is a bound region\n+    /// on the closure (as indicated by the `<'a>` prefix). If we are\n+    /// naive, we wind up inferring that `'b` must be `'static`,\n+    /// because we require that it be greater than `'a` and we do not\n+    /// know what `'a` is precisely.\n+    ///\n+    /// This hashmap is used to avoid that naive scenario. Basically\n+    /// we record the fact that `'a <= 'b` is implied by the fn\n+    /// signature, and then ignore the constraint when solving\n+    /// equations. This is a bit of a hack but seems to work.\n+    pub givens: FxIndexSet<(Region<'tcx>, ty::RegionVid)>,\n }\n \n /// Represents a constraint that influences the inference process.\n@@ -277,6 +297,9 @@ pub(crate) enum UndoLog<'tcx> {\n     /// We added the given `verify`.\n     AddVerify(usize),\n \n+    /// We added the given `given`.\n+    AddGiven(Region<'tcx>, ty::RegionVid),\n+\n     /// We added a GLB/LUB \"combination variable\".\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n }\n@@ -325,6 +348,9 @@ impl<'tcx> RegionConstraintStorage<'tcx> {\n                 self.data.verifys.pop();\n                 assert_eq!(self.data.verifys.len(), index);\n             }\n+            AddGiven(sub, sup) => {\n+                self.data.givens.remove(&(sub, sup));\n+            }\n             AddCombination(Glb, ref regions) => {\n                 self.glbs.remove(regions);\n             }\n@@ -466,6 +492,15 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         self.undo_log.push(AddVerify(index));\n     }\n \n+    pub(super) fn add_given(&mut self, sub: Region<'tcx>, sup: ty::RegionVid) {\n+        // cannot add givens once regions are resolved\n+        if self.data.givens.insert((sub, sup)) {\n+            debug!(\"add_given({:?} <= {:?})\", sub, sup);\n+\n+            self.undo_log.push(AddGiven(sub, sup));\n+        }\n+    }\n+\n     pub(super) fn make_eqregion(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n@@ -769,8 +804,11 @@ impl<'tcx> RegionConstraintData<'tcx> {\n     /// Returns `true` if this region constraint data contains no constraints, and `false`\n     /// otherwise.\n     pub fn is_empty(&self) -> bool {\n-        let RegionConstraintData { constraints, member_constraints, verifys } = self;\n-        constraints.is_empty() && member_constraints.is_empty() && verifys.is_empty()\n+        let RegionConstraintData { constraints, member_constraints, verifys, givens } = self;\n+        constraints.is_empty()\n+            && member_constraints.is_empty()\n+            && verifys.is_empty()\n+            && givens.is_empty()\n     }\n }\n "}, {"sha": "96a4b76af550fd5c9eb26d0782114f4514dee93c", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=5ad1083e5bb6dfea0f4368031466b4f366dabf79", "patch": "@@ -388,6 +388,7 @@ fn resolve_negative_obligation<'tcx>(\n     let wf_tys = ocx.assumed_wf_types(param_env, DUMMY_SP, body_def_id);\n     let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n+        Some(&infcx),\n         infcx.implied_bounds_tys(param_env, body_def_id, wf_tys),\n     );\n "}, {"sha": "336db4fee6ced7e4981a31b6eb5b6e1dc43cb039", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=5ad1083e5bb6dfea0f4368031466b4f366dabf79", "patch": "@@ -111,6 +111,7 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n             // Check regions assuming the self type of the impl is WF\n             let outlives_env = OutlivesEnvironment::with_bounds(\n                 param_env,\n+                Some(&infcx),\n                 infcx.implied_bounds_tys(\n                     param_env,\n                     parent_cause.body_id,"}, {"sha": "6cb64ad574f5be191db9341065d1245b3b306c16", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad1083e5bb6dfea0f4368031466b4f366dabf79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=5ad1083e5bb6dfea0f4368031466b4f366dabf79", "patch": "@@ -3,8 +3,7 @@ use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use crate::traits::query::NoSolution;\n use crate::traits::ObligationCause;\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n-use rustc_middle::ty::{self, ParamEnv, Ty, TypeFolder, TypeVisitableExt};\n+use rustc_middle::ty::{self, ParamEnv, Ty};\n use rustc_span::def_id::LocalDefId;\n \n pub use rustc_middle::traits::query::OutlivesBound;\n@@ -53,10 +52,6 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n         body_id: LocalDefId,\n         ty: Ty<'tcx>,\n     ) -> Vec<OutlivesBound<'tcx>> {\n-        let ty = self.resolve_vars_if_possible(ty);\n-        let ty = OpportunisticRegionResolver::new(self).fold_ty(ty);\n-        assert!(!ty.needs_infer());\n-\n         let span = self.tcx.def_span(body_id);\n         let result = param_env\n             .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty })\n@@ -110,7 +105,10 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n         tys: FxIndexSet<Ty<'tcx>>,\n     ) -> Bounds<'a, 'tcx> {\n         tys.into_iter()\n-            .map(move |ty| self.implied_outlives_bounds(param_env, body_id, ty))\n+            .map(move |ty| {\n+                let ty = self.resolve_vars_if_possible(ty);\n+                self.implied_outlives_bounds(param_env, body_id, ty)\n+            })\n             .flatten()\n     }\n }"}, {"sha": "f776fc98a9edeb24b3ba13298659d652e38884c2", "filename": "tests/ui/implied-bounds/normalization.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/992d154f3a84cc8abcefcf6e6cf3698e4821b506/tests%2Fui%2Fimplied-bounds%2Fnormalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/992d154f3a84cc8abcefcf6e6cf3698e4821b506/tests%2Fui%2Fimplied-bounds%2Fnormalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fnormalization.rs?ref=992d154f3a84cc8abcefcf6e6cf3698e4821b506", "patch": "@@ -1,58 +0,0 @@\n-// Test that we get implied bounds from complex projections after normalization.\n-\n-// check-pass\n-\n-// implementations wil ensure that\n-// WF(<T as Combine<'a>>::Ty) implies T: 'a\n-trait Combine<'a> {\n-    type Ty;\n-}\n-\n-impl<'a, T: 'a> Combine<'a> for Box<T> {\n-    type Ty = &'a T;\n-}\n-\n-// ======= Wrappers ======\n-\n-// normalizes to a projection\n-struct WrapA<T>(T);\n-impl<'a, T> Combine<'a> for WrapA<T>\n-where\n-    T: Combine<'a>,\n-{\n-    type Ty = T::Ty;\n-}\n-\n-// <WrapB<T> as Combine<'a>>::Ty normalizes to a type variable ?X\n-// with constraint `<T as Combine<'a>>::Ty == ?X`\n-struct WrapB<T>(T);\n-impl<'a, X, T> Combine<'a> for WrapB<T>\n-where\n-    T: Combine<'a, Ty = X>,\n-{\n-    type Ty = X;\n-}\n-\n-// <WrapC<T> as Combine<'a>>::Ty normalizes to `&'a &'?x ()`\n-// with constraint `<T as Combine<'a>>::Ty == &'a &'?x ()`\n-struct WrapC<T>(T);\n-impl<'a, 'x: 'a, T> Combine<'a> for WrapC<T>\n-where\n-    T: Combine<'a, Ty = &'a &'x ()>,\n-{\n-    type Ty = &'a &'x ();\n-}\n-\n-//==== Test implied bounds ======\n-\n-fn test_wrap<'a, 'b, 'c1, 'c2, A, B>(\n-    _: <WrapA<Box<A>> as Combine<'a>>::Ty,        // normalized: &'a A\n-    _: <WrapB<Box<B>> as Combine<'b>>::Ty,        // normalized: &'b B\n-    _: <WrapC<Box<&'c1 ()>> as Combine<'c2>>::Ty, // normalized: &'c2 &'c1 ()\n-) {\n-    None::<&'a A>;\n-    None::<&'b B>;\n-    None::<&'c2 &'c1 ()>;\n-}\n-\n-fn main() {}"}]}