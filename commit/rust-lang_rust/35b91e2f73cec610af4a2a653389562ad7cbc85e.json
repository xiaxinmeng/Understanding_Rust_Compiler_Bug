{"sha": "35b91e2f73cec610af4a2a653389562ad7cbc85e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1YjkxZTJmNzNjZWM2MTBhZjRhMmE2NTMzODk1NjJhZDdjYmM4NWU=", "commit": {"author": {"name": "Jeong YunWon", "email": "jeong@youknowone.org", "date": "2013-05-02T16:28:53Z"}, "committer": {"name": "Jeong YunWon", "email": "jeong@youknowone.org", "date": "2013-05-02T16:41:09Z"}, "message": "Use static strings", "tree": {"sha": "77a53cb72be2d852b2f1eda9863b513ce7607be4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77a53cb72be2d852b2f1eda9863b513ce7607be4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35b91e2f73cec610af4a2a653389562ad7cbc85e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35b91e2f73cec610af4a2a653389562ad7cbc85e", "html_url": "https://github.com/rust-lang/rust/commit/35b91e2f73cec610af4a2a653389562ad7cbc85e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35b91e2f73cec610af4a2a653389562ad7cbc85e/comments", "author": {"login": "youknowone", "id": 69878, "node_id": "MDQ6VXNlcjY5ODc4", "avatar_url": "https://avatars.githubusercontent.com/u/69878?v=4", "gravatar_id": "", "url": "https://api.github.com/users/youknowone", "html_url": "https://github.com/youknowone", "followers_url": "https://api.github.com/users/youknowone/followers", "following_url": "https://api.github.com/users/youknowone/following{/other_user}", "gists_url": "https://api.github.com/users/youknowone/gists{/gist_id}", "starred_url": "https://api.github.com/users/youknowone/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/youknowone/subscriptions", "organizations_url": "https://api.github.com/users/youknowone/orgs", "repos_url": "https://api.github.com/users/youknowone/repos", "events_url": "https://api.github.com/users/youknowone/events{/privacy}", "received_events_url": "https://api.github.com/users/youknowone/received_events", "type": "User", "site_admin": false}, "committer": {"login": "youknowone", "id": 69878, "node_id": "MDQ6VXNlcjY5ODc4", "avatar_url": "https://avatars.githubusercontent.com/u/69878?v=4", "gravatar_id": "", "url": "https://api.github.com/users/youknowone", "html_url": "https://github.com/youknowone", "followers_url": "https://api.github.com/users/youknowone/followers", "following_url": "https://api.github.com/users/youknowone/following{/other_user}", "gists_url": "https://api.github.com/users/youknowone/gists{/gist_id}", "starred_url": "https://api.github.com/users/youknowone/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/youknowone/subscriptions", "organizations_url": "https://api.github.com/users/youknowone/orgs", "repos_url": "https://api.github.com/users/youknowone/repos", "events_url": "https://api.github.com/users/youknowone/events{/privacy}", "received_events_url": "https://api.github.com/users/youknowone/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1f7220219c722665e15b88aeecfc78601fa4f22", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1f7220219c722665e15b88aeecfc78601fa4f22", "html_url": "https://github.com/rust-lang/rust/commit/d1f7220219c722665e15b88aeecfc78601fa4f22"}], "stats": {"total": 457, "additions": 201, "deletions": 256}, "files": [{"sha": "4dd727390aadc782f5447051e95d3e2b13db066d", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -115,15 +115,15 @@ pub impl LoanContext {\n         if cmt.lp.is_none() {\n             self.bccx.tcx.sess.span_bug(\n                 cmt.span,\n-                ~\"loan() called with non-lendable value\");\n+                \"loan() called with non-lendable value\");\n         }\n \n         match cmt.cat {\n           cat_binding(_) | cat_rvalue | cat_special(_) => {\n             // should never be loanable\n             self.bccx.tcx.sess.span_bug(\n                 cmt.span,\n-                ~\"rvalue with a non-none lp\");\n+                \"rvalue with a non-none lp\");\n           }\n           cat_local(local_id) | cat_arg(local_id) | cat_self(local_id) => {\n               // FIXME(#4903)\n@@ -188,7 +188,7 @@ pub impl LoanContext {\n             // Aliased data is simply not lendable.\n             self.bccx.tcx.sess.span_bug(\n                 cmt.span,\n-                ~\"aliased ptr with a non-none lp\");\n+                \"aliased ptr with a non-none lp\");\n           }\n         }\n     }"}, {"sha": "f1d45e6e9aaa72fd355c8d53345b8fdfc698ab3e", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -525,11 +525,11 @@ pub impl BorrowckCtxt {\n         self.note_and_explain_bckerr(err);\n     }\n \n-    fn span_err(&self, s: span, m: ~str) {\n+    fn span_err(&self, s: span, m: &str) {\n         self.tcx.sess.span_err(s, m);\n     }\n \n-    fn span_note(&self, s: span, m: ~str) {\n+    fn span_note(&self, s: span, m: &str) {\n         self.tcx.sess.span_note(s, m);\n     }\n "}, {"sha": "62358823f23221a5cc869162be4694b3f8453a2a", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -124,7 +124,7 @@ pub impl<'self> PreserveCtxt<'self> {\n             if self.root_managed_data {\n                 self.tcx().sess.span_bug(\n                     cmt.span,\n-                    ~\"preserve() called with local and !root_managed_data\");\n+                    \"preserve() called with local and !root_managed_data\");\n             }\n             let local_region = self.tcx().region_maps.encl_region(local_id);\n             self.compare_scope(cmt, local_region)"}, {"sha": "3bd2a8269b7633bb84eb1add5a25ccaeb0e1850d", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -557,8 +557,7 @@ pub fn enter_opt<'r>(bcx: block,\n                             struct_id = found_struct_id;\n                         }\n                         _ => {\n-                            tcx.sess.span_bug(p.span, ~\"expected enum \\\n-                                                        variant def\");\n+                            tcx.sess.span_bug(p.span, \"expected enum variant def\");\n                         }\n                     }\n "}, {"sha": "87e347d2004085779131a6d020bf04f4884020f7", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -1125,10 +1125,11 @@ pub fn init_local(bcx: block, local: @ast::local) -> block {\n     }\n \n     let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n-      Some(&local_mem(v)) => v,\n-      _ => { bcx.tcx().sess.span_bug(local.span,\n-                        ~\"init_local: Someone forgot to document why it's\\\n-                         safe to assume local.node.init must be local_mem!\");\n+        Some(&local_mem(v)) => v,\n+        _ => {\n+            bcx.tcx().sess.span_bug(local.span,\n+                                    \"init_local: Someone forgot to document why it's\\\n+                                     safe to assume local.node.init must be local_mem!\");\n         }\n     };\n "}, {"sha": "ed7f91bf04a6b49280f144d0771881f920129450", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -356,9 +356,7 @@ pub fn trans_method_call(in_cx: block,\n                                               origin)\n                 }\n                 None => {\n-                    cx.tcx().sess.span_bug(call_ex.span,\n-                                           ~\"method call expr wasn't in \\\n-                                             method map\")\n+                    cx.tcx().sess.span_bug(call_ex.span, \"method call expr wasn't in method map\")\n                 }\n             }\n         },"}, {"sha": "9d04905bcc978f551baeb4e1927e0506aa3f226f", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -58,8 +58,7 @@ pub fn const_lit(cx: @CrateContext, e: @ast::expr, lit: ast::lit)\n           }\n           _ => {\n             cx.sess.span_bug(lit.span,\n-                             ~\"floating point literal doesn't have the right \\\n-                               type\");\n+                             \"floating point literal doesn't have the right type\");\n           }\n         }\n       }\n@@ -281,7 +280,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                 else           { llvm::LLVMConstURem(te1, te2) }\n               }\n               ast::and    |\n-              ast::or     => cx.sess.span_unimpl(e.span, ~\"binop logic\"),\n+              ast::or     => cx.sess.span_unimpl(e.span, \"binop logic\"),\n               ast::bitxor => llvm::LLVMConstXor(te1, te2),\n               ast::bitand => llvm::LLVMConstAnd(te1, te2),\n               ast::bitor  => llvm::LLVMConstOr(te1, te2),\n@@ -295,7 +294,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n               ast::le     |\n               ast::ne     |\n               ast::ge     |\n-              ast::gt     => cx.sess.span_unimpl(e.span, ~\"binop comparator\")\n+              ast::gt     => cx.sess.span_unimpl(e.span, \"binop comparator\")\n             }\n           }\n           ast::expr_unary(u, e) => {\n@@ -344,8 +343,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n                   _ => cx.sess.span_bug(index.span,\n-                                        ~\"index is not an integer-constant \\\n-                                          expression\")\n+                                        \"index is not an integer-constant expression\")\n               };\n               let (arr, len) = match ty::get(bt).sty {\n                   ty::ty_evec(_, vstore) | ty::ty_estr(vstore) =>\n@@ -363,12 +361,10 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                                                unit_sz))\n                       },\n                       _ => cx.sess.span_bug(base.span,\n-                                            ~\"index-expr base must be \\\n-                                              fixed-size or slice\")\n+                                            \"index-expr base must be fixed-size or slice\")\n                   },\n                   _ =>  cx.sess.span_bug(base.span,\n-                                         ~\"index-expr base must be \\\n-                                           a vector or string type\")\n+                                         \"index-expr base must be a vector or string type\")\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n@@ -380,7 +376,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                   // FIXME #3170: report this earlier on in the const-eval\n                   // pass. Reporting here is a bit late.\n                   cx.sess.span_err(e.span,\n-                                   ~\"const index-expr is out of bounds\");\n+                                   \"const index-expr is out of bounds\");\n               }\n               const_get_elt(cx, arr, [iv as c_uint])\n           }\n@@ -454,8 +450,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                       match fs.find(|f| field_ty.ident == f.node.ident) {\n                           Some(ref f) => const_expr(cx, (*f).node.expr),\n                           None => {\n-                              cx.tcx.sess.span_bug(\n-                                  e.span, ~\"missing struct field\");\n+                              cx.tcx.sess.span_bug(e.span, \"missing struct field\");\n                           }\n                       }\n                   });\n@@ -471,8 +466,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n               ast::expr_lit(ref lit) => {\n                 match lit.node {\n                   ast::lit_str(*) => { const_expr(cx, sub) }\n-                  _ => { cx.sess.span_bug(e.span,\n-                                          ~\"bad const-slice lit\") }\n+                  _ => { cx.sess.span_bug(e.span, \"bad const-slice lit\") }\n                 }\n               }\n               ast::expr_vec(ref es, ast::m_imm) => {\n@@ -487,8 +481,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                 let p = const_ptrcast(cx, gv, llunitty);\n                 C_struct(~[p, sz])\n               }\n-              _ => cx.sess.span_bug(e.span,\n-                                    ~\"bad const-slice expr\")\n+              _ => cx.sess.span_bug(e.span, \"bad const-slice expr\")\n             }\n           }\n           ast::expr_path(pth) => {\n@@ -520,8 +513,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                     C_null(llty)\n                 }\n                 _ => {\n-                    cx.sess.span_bug(e.span, ~\"expected a const, fn, \\\n-                                               struct, or variant def\")\n+                    cx.sess.span_bug(e.span, \"expected a const, fn, struct, or variant def\")\n                 }\n             }\n           }\n@@ -542,13 +534,12 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                       adt::trans_const(cx, repr, vinfo.disr_val,\n                                        args.map(|a| const_expr(cx, *a)))\n                   }\n-                  _ => cx.sess.span_bug(e.span, ~\"expected a struct or \\\n-                                                  variant def\")\n+                  _ => cx.sess.span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n           ast::expr_paren(e) => { return const_expr(cx, e); }\n           _ => cx.sess.span_bug(e.span,\n-                ~\"bad constant expression type in consts::const_expr\")\n+                  \"bad constant expression type in consts::const_expr\")\n         };\n     }\n }"}, {"sha": "cf5fbb6e216ecb69014861966be8454e15a26607", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -761,8 +761,8 @@ pub impl Datum {\n         match self.try_deref(bcx, expr.id, derefs, false) {\n             (Some(lvres), bcx) => DatumBlock { bcx: bcx, datum: lvres },\n             (None, _) => {\n-                bcx.ccx().sess.span_bug(\n-                    expr.span, ~\"Cannot deref this expression\");\n+                bcx.ccx().sess.span_bug(expr.span,\n+                                        \"Cannot deref this expression\");\n             }\n         }\n     }"}, {"sha": "b7a1a90741c431a4414e429e1c127a9e4f38a1fe", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -756,7 +756,7 @@ fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n             }\n         },\n         ty::ty_enum(_did, ref _substs) => {\n-            cx.sess.span_bug(span, ~\"debuginfo for enum NYI\")\n+            cx.sess.span_bug(span, \"debuginfo for enum NYI\")\n         }\n         ty::ty_box(ref mt) | ty::ty_uniq(ref mt) => {\n             let boxed = create_ty(cx, mt.ty, span);\n@@ -782,18 +782,18 @@ fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n             create_pointer_type(cx, t, span, pointee)\n         },\n         ty::ty_rptr(ref _region, ref _mt) => {\n-            cx.sess.span_bug(span, ~\"debuginfo for rptr NYI\")\n+            cx.sess.span_bug(span, \"debuginfo for rptr NYI\")\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n             let inputs = do barefnty.sig.inputs.map |a| { a.ty };\n             let output = barefnty.sig.output;\n             create_fn_ty(cx, t, inputs, output, span)\n         },\n         ty::ty_closure(ref _closurety) => {\n-            cx.sess.span_bug(span, ~\"debuginfo for closure NYI\")\n+            cx.sess.span_bug(span, \"debuginfo for closure NYI\")\n         },\n         ty::ty_trait(_did, ref _substs, ref _vstore, _) => {\n-            cx.sess.span_bug(span, ~\"debuginfo for trait NYI\")\n+            cx.sess.span_bug(span, \"debuginfo for trait NYI\")\n         },\n         ty::ty_struct(did, ref substs) => {\n             let fields = ty::struct_fields(cx.tcx, did, substs);\n@@ -860,14 +860,12 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n     let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n       option::Some(&local_mem(v)) => v,\n       option::Some(_) => {\n-        bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n-                something weird\");\n+        bcx.tcx().sess.span_bug(local.span, \"local is bound to something weird\");\n       }\n       option::None => {\n         match *bcx.fcx.lllocals.get(&local.node.pat.id) {\n           local_imm(v) => v,\n-          _ => bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n-                                                     something weird\")\n+          _ => bcx.tcx().sess.span_bug(local.span, \"local is bound to something weird\")\n         }\n       }\n     };\n@@ -966,8 +964,7 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n           ast::item_fn(ref decl, _, _, _, _) => {\n             (item.ident, decl.output, item.id)\n           }\n-          _ => fcx.ccx.sess.span_bug(item.span, ~\"create_function: item \\\n-                                                  bound to non-function\")\n+          _ => fcx.ccx.sess.span_bug(item.span, \"create_function: item bound to non-function\")\n         }\n       }\n       ast_map::node_method(method, _, _) => {\n@@ -979,12 +976,10 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n             ((dbg_cx.names)(~\"fn\"), decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,\n-                                     ~\"create_function: \\\n-                                       expected an expr_fn_block here\")\n+                  \"create_function: expected an expr_fn_block here\")\n         }\n       }\n-      _ => fcx.ccx.sess.bug(~\"create_function: unexpected \\\n-                              sort of node\")\n+      _ => fcx.ccx.sess.bug(\"create_function: unexpected sort of node\")\n     };\n \n     debug!(\"%?\", ident);"}, {"sha": "7cdd7c3799ec4e0173b0abd5e2aa57e9e977aabc", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -690,7 +690,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n                 }\n                 _ => {\n                     bcx.tcx().sess.span_bug(expr.span,\n-                                            ~\"expr_cast of non-trait\");\n+                                            \"expr_cast of non-trait\");\n                 }\n             }\n         }\n@@ -700,8 +700,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                fmt!(\"trans_rvalue_dps_unadjusted reached \\\n-                      fall-through case: %?\",\n+                fmt!(\"trans_rvalue_dps_unadjusted reached fall-through case: %?\",\n                      expr.node));\n         }\n     }\n@@ -1202,7 +1201,7 @@ fn trans_rec_or_struct(bcx: block,\n                 }\n                 None => {\n                     tcx.sess.span_bug(field.span,\n-                                      ~\"Couldn't find field in struct type\")\n+                                      \"Couldn't find field in struct type\")\n                 }\n             }\n         };\n@@ -1478,15 +1477,15 @@ fn trans_eager_binop(bcx: block,\n         } else {\n             if !ty::type_is_scalar(rhs_t) {\n                 bcx.tcx().sess.span_bug(binop_expr.span,\n-                                        ~\"non-scalar comparison\");\n+                                        \"non-scalar comparison\");\n             }\n             let cmpr = base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op);\n             bcx = cmpr.bcx;\n             ZExt(bcx, cmpr.val, T_i8())\n         }\n       }\n       _ => {\n-        bcx.tcx().sess.span_bug(binop_expr.span, ~\"unexpected binop\");\n+        bcx.tcx().sess.span_bug(binop_expr.span, \"unexpected binop\");\n       }\n     };\n "}, {"sha": "0e2bf80cc5e846e2e5275afffe5bd57da7bf42bc", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -1080,7 +1080,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         _ => {\n             // Could we make this an enum rather than a string? does it get\n             // checked earlier?\n-            ccx.sess.span_bug(item.span, ~\"unknown intrinsic\");\n+            ccx.sess.span_bug(item.span, \"unknown intrinsic\");\n         }\n     }\n     build_return(bcx);"}, {"sha": "2640dab1c04fb109d6de494da3b5bd518f0978ca", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -160,7 +160,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     // causing an infinite expansion.\n     if depth > 30 {\n         ccx.sess.span_fatal(\n-            span, ~\"overly deep expansion of inlined function\");\n+            span, \"overly deep expansion of inlined function\");\n     }\n     ccx.monomorphizing.insert(fn_id, depth + 1);\n "}, {"sha": "f301a7d297342e4610c98b9e7a5517f1b0c9f4eb", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -170,11 +170,13 @@ fn traverse_inline_body(cx: &ctx, body: &blk) {\n           expr_path(_) => {\n             match cx.tcx.def_map.find(&e.id) {\n                 Some(&d) => {\n-                  traverse_def_id(cx, def_id_of_def(d));\n+                    traverse_def_id(cx, def_id_of_def(d));\n                 }\n-                None      => cx.tcx.sess.span_bug(e.span, fmt!(\"Unbound node \\\n-                  id %? while traversing %s\", e.id,\n-                  expr_to_str(e, cx.tcx.sess.intr())))\n+                None => cx.tcx.sess.span_bug(\n+                    e.span,\n+                    fmt!(\"Unbound node id %? while traversing %s\",\n+                         e.id,\n+                         expr_to_str(e, cx.tcx.sess.intr())))\n             }\n           }\n           expr_field(_, _, _) => {"}, {"sha": "e8075c1f2ad1dbc380782c095f90b36c25e7ee2d", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -469,7 +469,7 @@ pub fn write_content(bcx: block,\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(content_expr.span,\n-                                    ~\"Unexpected evec content\");\n+                                    \"Unexpected evec content\");\n         }\n     }\n }\n@@ -503,7 +503,7 @@ pub fn elements_required(bcx: block, content_expr: @ast::expr) -> uint {\n             ty::eval_repeat_count(bcx.tcx(), count_expr)\n         }\n         _ => bcx.tcx().sess.span_bug(content_expr.span,\n-                                     ~\"Unexpected evec content\")\n+                                     \"Unexpected evec content\")\n     }\n }\n "}, {"sha": "7ef77646f5203a95d1267e469bd3dbde9e9a4dce", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -291,10 +291,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n                             ty::vstore_fixed(*) => {\n                                 tcx.sess.span_err(\n                                     path.span,\n-                                    ~\"@trait, ~trait or &trait \\\n-                                      are the only supported \\\n-                                      forms of casting-to-\\\n-                                      trait\");\n+                                    \"@trait, ~trait or &trait are the only supported \\\n+                                     forms of casting-to-trait\");\n                                 ty::BoxTraitStore\n                             }\n                         };\n@@ -321,15 +319,15 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n             if path.types.len() > 0u {\n                 tcx.sess.span_err(\n                     path.span,\n-                    ~\"type parameters are not allowed on this type\");\n+                    \"type parameters are not allowed on this type\");\n             }\n         }\n \n         if (flags & NO_REGIONS) != 0u {\n             if path.rp.is_some() {\n                 tcx.sess.span_err(\n                     path.span,\n-                    ~\"region parameters are not allowed on this type\");\n+                    \"region parameters are not allowed on this type\");\n             }\n         }\n     }\n@@ -339,9 +337,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n     match tcx.ast_ty_to_ty_cache.find(&ast_ty.id) {\n       Some(&ty::atttce_resolved(ty)) => return ty,\n       Some(&ty::atttce_unresolved) => {\n-        tcx.sess.span_fatal(ast_ty.span, ~\"illegal recursive type; \\\n-                                          insert an enum in the cycle, \\\n-                                          if this is desired\");\n+        tcx.sess.span_fatal(ast_ty.span, \"illegal recursive type; \\\n+                                          insert an enum in the cycle, if this is desired\");\n       }\n       None => { /* go on */ }\n     }\n@@ -359,11 +356,9 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n                    |tmt| ty::mk_uniq(tcx, tmt))\n       }\n       ast::ty_vec(ref mt) => {\n-        tcx.sess.span_err(ast_ty.span,\n-                          ~\"bare `[]` is not a type\");\n+        tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n         // return /something/ so they can at least get more errors\n-        ty::mk_evec(tcx, ast_mt_to_mt(self, rscope, mt),\n-                    ty::vstore_uniq)\n+        ty::mk_evec(tcx, ast_mt_to_mt(self, rscope, mt), ty::vstore_uniq)\n       }\n       ast::ty_ptr(ref mt) => {\n         ty::mk_ptr(tcx, ast_mt_to_mt(self, rscope, mt))\n@@ -434,7 +429,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n               }\n               ast::ty_str => {\n                 tcx.sess.span_err(ast_ty.span,\n-                                  ~\"bare `str` is not a type\");\n+                                  \"bare `str` is not a type\");\n                 // return /something/ so they can at least get more errors\n                 ty::mk_estr(tcx, ty::vstore_uniq)\n               }\n@@ -454,7 +449,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n           }\n           _ => {\n             tcx.sess.span_fatal(ast_ty.span,\n-                                ~\"found type name used as a variable\");\n+                                \"found type name used as a variable\");\n           }\n         }\n       }\n@@ -470,7 +465,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n                             ty::vstore_fixed(i as uint)),\n               _ => {\n                 tcx.sess.span_fatal(\n-                    ast_ty.span, ~\"expected constant expr for vector length\");\n+                    ast_ty.span, \"expected constant expr for vector length\");\n               }\n             }\n           }\n@@ -489,11 +484,11 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n         // routine.\n         self.tcx().sess.span_bug(\n             ast_ty.span,\n-            ~\"found `ty_infer` in unexpected place\");\n+            \"found `ty_infer` in unexpected place\");\n       }\n       ast::ty_mac(_) => {\n         tcx.sess.span_bug(ast_ty.span,\n-                          ~\"found `ty_mac` in unexpected place\");\n+                          \"found `ty_mac` in unexpected place\");\n       }\n     };\n "}, {"sha": "de384d02dc3bc17fa98dc26bd93c0c17ca984552", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -204,8 +204,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n     if arg_len > 0 {\n         // N-ary variant.\n         if arg_len != subpats_len {\n-            let s = fmt!(\"this pattern has %u field%s, but the corresponding \\\n-                          %s has %u field%s\",\n+            let s = fmt!(\"this pattern has %u field%s, but the corresponding %s has %u field%s\",\n                          subpats_len,\n                          if subpats_len == 1u { ~\"\" } else { ~\"s\" },\n                          kind_name,\n@@ -223,13 +222,12 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n             }\n         }\n     } else if subpats_len > 0 {\n-        tcx.sess.span_err\n-            (pat.span, fmt!(\"this pattern has %u field%s, but the \\\n-                             corresponding %s has no fields\",\n-                            subpats_len,\n-                            if subpats_len == 1u { ~\"\" }\n-                            else { ~\"s\" },\n-                            kind_name));\n+        tcx.sess.span_err(pat.span,\n+                          fmt!(\"this pattern has %u field%s, but the corresponding %s has no \\\n+                                fields\",\n+                               subpats_len,\n+                               if subpats_len == 1u { \"\" } else { \"s\" },\n+                               kind_name));\n         error_happened = true;\n     }\n \n@@ -319,20 +317,19 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::node_id, span: span,\n         Some(&ast::def_struct(*)) | Some(&ast::def_variant(*)) => {\n             let name = pprust::path_to_str(path, tcx.sess.intr());\n             tcx.sess.span_err(span,\n-                              fmt!(\"mismatched types: expected `%s` but \\\n-                                    found `%s`\",\n+                              fmt!(\"mismatched types: expected `%s` but found `%s`\",\n                                    fcx.infcx().ty_to_str(expected),\n                                    name));\n         }\n         _ => {\n-            tcx.sess.span_bug(span, ~\"resolve didn't write in class\");\n+            tcx.sess.span_bug(span, \"resolve didn't write in class\");\n         }\n     }\n \n     // Forbid pattern-matching structs with destructors.\n     if ty::has_dtor(tcx, class_id) {\n-        tcx.sess.span_err(span, ~\"deconstructing struct not allowed in \\\n-                                  pattern (it has a destructor)\");\n+        tcx.sess.span_err(span, \"deconstructing struct not allowed in pattern \\\n+                                 (it has a destructor)\");\n     }\n \n     check_struct_pat_fields(pcx, span, path, fields, class_fields, class_id,\n@@ -370,7 +367,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n                                    name));\n         }\n         _ => {\n-            tcx.sess.span_bug(span, ~\"resolve didn't write in variant\");\n+            tcx.sess.span_bug(span, \"resolve didn't write in variant\");\n         }\n     }\n }\n@@ -404,10 +401,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         {\n             // no-op\n         } else if !ty::type_is_numeric(b_ty) {\n-            tcx.sess.span_err(pat.span, ~\"non-numeric type used in range\");\n+            tcx.sess.span_err(pat.span, \"non-numeric type used in range\");\n         } else if !valid_range_bounds(fcx.ccx, begin, end) {\n-            tcx.sess.span_err(begin.span, ~\"lower range bound must be less \\\n-                                           than upper\");\n+            tcx.sess.span_err(begin.span, \"lower range bound must be less than upper\");\n         }\n         fcx.write_ty(pat.id, b_ty);\n       }\n@@ -476,9 +472,8 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             }\n             _ => {\n                 tcx.sess.span_err(pat.span,\n-                                    fmt!(\"mismatched types: expected `%s` \\\n-                                          but found struct\",\n-                                         fcx.infcx().ty_to_str(expected)));\n+                                  fmt!(\"mismatched types: expected `%s` but found struct\",\n+                                       fcx.infcx().ty_to_str(expected)));\n                 error_happened = true;\n             }\n         }"}, {"sha": "abaadceb053fc06c26be9ad1290bfc98e904c64e", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -872,7 +872,7 @@ pub impl<'self> LookupContext<'self> {\n         if relevant_candidates.len() > 1 {\n             self.tcx().sess.span_err(\n                 self.expr.span,\n-                ~\"multiple applicable methods in scope\");\n+                \"multiple applicable methods in scope\");\n             for uint::range(0, relevant_candidates.len()) |idx| {\n                 self.report_candidate(idx, &relevant_candidates[idx].origin);\n             }\n@@ -983,12 +983,12 @@ pub impl<'self> LookupContext<'self> {\n             } else if num_method_tps == 0u {\n                 tcx.sess.span_err(\n                     self.expr.span,\n-                    ~\"this method does not take type parameters\");\n+                    \"this method does not take type parameters\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else if num_supplied_tps != num_method_tps {\n                 tcx.sess.span_err(\n                     self.expr.span,\n-                    ~\"incorrect number of type \\\n+                    \"incorrect number of type \\\n                      parameters given for this method\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else {\n@@ -1082,14 +1082,14 @@ pub impl<'self> LookupContext<'self> {\n         if ty::type_has_self(method_fty) {\n             self.tcx().sess.span_err(\n                 self.expr.span,\n-                ~\"cannot call a method whose type contains a \\\n-                  self-type through a boxed trait\");\n+                \"cannot call a method whose type contains a \\\n+                 self-type through a boxed trait\");\n         }\n \n         if candidate.method_ty.generics.has_type_params() {\n             self.tcx().sess.span_err(\n                 self.expr.span,\n-                ~\"cannot call a generic method through a boxed trait\");\n+                \"cannot call a generic method through a boxed trait\");\n         }\n     }\n \n@@ -1109,7 +1109,7 @@ pub impl<'self> LookupContext<'self> {\n \n         if bad {\n             self.tcx().sess.span_err(self.expr.span,\n-                                     ~\"explicit call to destructor\");\n+                                     \"explicit call to destructor\");\n         }\n     }\n "}, {"sha": "69775771d96971bf19dc599d2c9791b89140b326", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 50, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -542,17 +542,15 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n         let (id, sp) = *p;\n         let orig_sp = field_names.find(&id).map_consume(|x| *x);\n         match orig_sp {\n-          Some(orig_sp) => {\n-            tcx.sess.span_err(sp, fmt!(\"Duplicate field \\\n-                                   name %s in record type declaration\",\n-                                        *tcx.sess.str_of(id)));\n-            tcx.sess.span_note(orig_sp, ~\"First declaration of \\\n-                                          this field occurred here\");\n-            break;\n-          }\n-          None => {\n-            field_names.insert(id, sp);\n-          }\n+            Some(orig_sp) => {\n+                tcx.sess.span_err(sp, fmt!(\"Duplicate field name %s in record type declaration\",\n+                                           *tcx.sess.str_of(id)));\n+                tcx.sess.span_note(orig_sp, \"First declaration of this field occurred here\");\n+                break;\n+            }\n+            None => {\n+                field_names.insert(id, sp);\n+            }\n         }\n     }\n }\n@@ -1252,8 +1250,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                 ty::ty_rptr(_, mt) => formal_ty = mt.ty,\n                                 ty::ty_err => (),\n                                 _ => {\n-                                    fcx.ccx.tcx.sess.span_bug(arg.span,\n-                                                              ~\"no ref\");\n+                                    fcx.ccx.tcx.sess.span_bug(arg.span, \"no ref\");\n                                 }\n                             }\n                         }\n@@ -1559,8 +1556,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             match ty::get(lhs_resolved_t).sty {\n                 ty::ty_bare_fn(_) | ty::ty_closure(_) => {\n                     tcx.sess.span_note(\n-                        ex.span, ~\"did you forget the `do` keyword \\\n-                                   for the call?\");\n+                        ex.span, \"did you forget the `do` keyword for the call?\");\n                 }\n                 _ => ()\n             }\n@@ -1851,9 +1847,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 tcx.sess.span_err(span,\n                                   fmt!(\"missing field%s: %s\",\n                                        if missing_fields.len() == 1 {\n-                                           ~\"\"\n+                                           \"\"\n                                        } else {\n-                                           ~\"s\"\n+                                           \"s\"\n                                        },\n                                        str::connect(missing_fields, ~\", \")));\n              }\n@@ -1901,7 +1897,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 }\n                 _ => {\n                     tcx.sess.span_bug(span,\n-                                      ~\"resolve didn't map this to a class\");\n+                                      \"resolve didn't map this to a class\");\n                 }\n             }\n         } else {\n@@ -1989,7 +1985,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 }\n                 _ => {\n                     tcx.sess.span_bug(span,\n-                                      ~\"resolve didn't map this to an enum\");\n+                                      \"resolve didn't map this to an enum\");\n                 }\n             }\n         } else {\n@@ -2201,7 +2197,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n           }\n           _ =>\n-            tcx.sess.span_bug(expr.span, ~\"vstore modifier on non-sequence\")\n+            tcx.sess.span_bug(expr.span, \"vstore modifier on non-sequence\")\n         };\n         fcx.write_ty(ev.id, typ);\n         fcx.write_ty(id, typ);\n@@ -2284,21 +2280,18 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                 ty::ty_enum(*) => {\n                                     tcx.sess.span_err(\n                                         expr.span,\n-                                        ~\"can only dereference enums \\\n-                                          with a single variant which has a \\\n-                                          single argument\");\n+                                        \"can only dereference enums with a single variant which \\\n+                                         has a single argument\");\n                                 }\n                                 ty::ty_struct(*) => {\n                                     tcx.sess.span_err(\n                                         expr.span,\n-                                        ~\"can only dereference structs with \\\n-                                          one anonymous field\");\n+                                        \"can only dereference structs with one anonymous field\");\n                                 }\n                                 _ => {\n                                     fcx.type_error_message(expr.span,\n                                         |actual| {\n-                                            fmt!(\"type %s cannot be \\\n-                                                  dereferenced\", actual)\n+                                            fmt!(\"type %s cannot be dereferenced\", actual)\n                                     }, oprnd_t, None);\n                                 }\n                             }\n@@ -2394,7 +2387,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             result::Err(_) => {\n                 tcx.sess.span_err(\n                     expr.span,\n-                    ~\"`return;` in function returning non-nil\");\n+                    \"`return;` in function returning non-nil\");\n             }\n           },\n           Some(e) => {\n@@ -2758,8 +2751,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                           variant_id, *fields);\n             }\n             _ => {\n-                tcx.sess.span_bug(path.span, ~\"structure constructor does \\\n-                                               not name a structure type\");\n+                tcx.sess.span_bug(path.span,\n+                                  \"structure constructor does not name a structure type\");\n             }\n         }\n       }\n@@ -2961,7 +2954,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n                   }\n                   _ => false\n                 } {\n-                fcx.ccx.tcx.sess.span_warn(s.span, ~\"unreachable statement\");\n+                fcx.ccx.tcx.sess.span_warn(s.span, \"unreachable statement\");\n                 warned = true;\n             }\n             if ty::type_is_bot(s_ty) {\n@@ -2982,7 +2975,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n             },\n           Some(e) => {\n             if any_bot && !warned {\n-                fcx.ccx.tcx.sess.span_warn(e.span, ~\"unreachable expression\");\n+                fcx.ccx.tcx.sess.span_warn(e.span, \"unreachable expression\");\n             }\n             check_expr_with_opt_hint(fcx, e, expected);\n               let ety = fcx.expr_ty(e);\n@@ -3073,8 +3066,8 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                     *disr_val = val as int;\n                   }\n                   Ok(_) => {\n-                    ccx.tcx.sess.span_err(e.span, ~\"expected signed integer \\\n-                                                    constant\");\n+                    ccx.tcx.sess.span_err(e.span, \"expected signed integer \\\n+                                                   constant\");\n                   }\n                   Err(ref err) => {\n                     ccx.tcx.sess.span_err(e.span,\n@@ -3085,7 +3078,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n             }\n             if vec::contains(*disr_vals, &*disr_val) {\n                 ccx.tcx.sess.span_err(v.span,\n-                                      ~\"discriminator value already exists\");\n+                                      \"discriminator value already exists\");\n             }\n             disr_vals.push(*disr_val);\n             let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n@@ -3142,9 +3135,9 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n           _ => false\n         }\n     }) {\n-        ccx.tcx.sess.span_err(sp, ~\"illegal recursive enum type; \\\n-                                 wrap the inner value in a box to \\\n-                                 make it representable\");\n+        ccx.tcx.sess.span_err(sp,\n+                              \"illegal recursive enum type; \\\n+                               wrap the inner value in a box to make it representable\");\n     }\n \n     // Check that it is possible to instantiate this enum:\n@@ -3205,26 +3198,25 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n       ast::def_ty(_) |\n       ast::def_prim_ty(_) |\n       ast::def_ty_param(*)=> {\n-        fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found type\");\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found type\");\n       }\n       ast::def_mod(*) | ast::def_foreign_mod(*) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found module\");\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found module\");\n       }\n       ast::def_use(*) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found use\");\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found use\");\n       }\n       ast::def_region(*) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found region\");\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found region\");\n       }\n       ast::def_typaram_binder(*) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found type \\\n-                                          parameter\");\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found type parameter\");\n       }\n       ast::def_label(*) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found label\");\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found label\");\n       }\n       ast::def_self_ty(*) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found self ty\");\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found self ty\");\n       }\n     }\n }\n@@ -3253,7 +3245,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n         match tpt.generics.region_param {\n           None => { // ...but the type is not lifetime parameterized!\n             fcx.ccx.tcx.sess.span_err\n-                (span, ~\"this item is not region-parameterized\");\n+                (span, \"this item is not region-parameterized\");\n             None\n           }\n           Some(_) => { // ...and the type is lifetime parameterized, ok.\n@@ -3273,15 +3265,15 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else if ty_param_count == 0 {\n         fcx.ccx.tcx.sess.span_err\n-            (span, ~\"this item does not take type parameters\");\n+            (span, \"this item does not take type parameters\");\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else if ty_substs_len > ty_param_count {\n         fcx.ccx.tcx.sess.span_err\n-            (span, ~\"too many type parameters provided for this item\");\n+            (span, \"too many type parameters provided for this item\");\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else if ty_substs_len < ty_param_count {\n         fcx.ccx.tcx.sess.span_err\n-            (span, ~\"not enough type parameters provided for this item\");\n+            (span, \"not enough type parameters provided for this item\");\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else {\n         pth.types.map(|aty| fcx.to_ty(*aty))"}, {"sha": "3a38d0b1d7ba379e2539ecb4ba176e20d43aed48", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -490,13 +490,13 @@ fn constrain_auto_ref(rcx: @mut Rcx, expr: @ast::expr) {\n             // reporting an error would be the correct path.\n             tcx.sess.span_err(\n                 expr.span,\n-                ~\"lifetime of borrowed pointer does not include \\\n-                  the expression being borrowed\");\n+                \"lifetime of borrowed pointer does not include \\\n+                 the expression being borrowed\");\n             note_and_explain_region(\n                 tcx,\n-                ~\"lifetime of the borrowed pointer is\",\n+                \"lifetime of the borrowed pointer is\",\n                 region,\n-                ~\"\");\n+                \"\");\n             rcx.errors_reported += 1;\n         }\n     }\n@@ -522,17 +522,17 @@ fn constrain_free_variables(\n           result::Err(_) => {\n             tcx.sess.span_err(\n                 freevar.span,\n-                ~\"captured variable does not outlive the enclosing closure\");\n+                \"captured variable does not outlive the enclosing closure\");\n             note_and_explain_region(\n                 tcx,\n-                ~\"captured variable is valid for \",\n+                \"captured variable is valid for \",\n                 en_region,\n-                ~\"\");\n+                \"\");\n             note_and_explain_region(\n                 tcx,\n-                ~\"closure is valid for \",\n+                \"closure is valid for \",\n                 region,\n-                ~\"\");\n+                \"\");\n           }\n         }\n     }"}, {"sha": "532638faa68c7d9339951237b313a2dd6e800451", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -414,7 +414,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                     if !is_early {\n                         vcx.tcx().sess.span_err(\n                             location_info.span,\n-                            ~\"multiple applicable methods in scope\");\n+                            \"multiple applicable methods in scope\");\n                     }\n                     return Some(/*bad*/copy found[0]);\n                 }"}, {"sha": "7fff756b01da50a785fbb9b9e7df22efd8b03f15", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -76,10 +76,8 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n         }\n         _ => {\n             inference_context.tcx.sess.span_fatal(span,\n-                                                  ~\"the type of this value \\\n-                                                    must be known in order \\\n-                                                    to determine the base \\\n-                                                    type\");\n+                                                  \"the type of this value must be known in order \\\n+                                                   to determine the base type\");\n         }\n     }\n \n@@ -257,9 +255,8 @@ pub impl CoherenceChecker {\n                 None => {\n                     let session = self.crate_context.tcx.sess;\n                     session.span_err(item.span,\n-                                     ~\"no base type found for inherent \\\n-                                       implementation; implement a \\\n-                                       trait or new type instead\");\n+                                     \"no base type found for inherent implementation; \\\n+                                      implement a trait or new type instead\");\n                 }\n                 Some(_) => {\n                     // Nothing to do.\n@@ -483,11 +480,9 @@ pub impl CoherenceChecker {\n                     if self.polytypes_unify(polytype_a, polytype_b) {\n                         let session = self.crate_context.tcx.sess;\n                         session.span_err(self.span_of_impl(implementation_b),\n-                                         ~\"conflicting implementations for a \\\n-                                           trait\");\n+                                         \"conflicting implementations for a trait\");\n                         session.span_note(self.span_of_impl(implementation_a),\n-                                          ~\"note conflicting implementation \\\n-                                            here\");\n+                                          \"note conflicting implementation here\");\n                     }\n                 }\n             }\n@@ -667,11 +662,9 @@ pub impl CoherenceChecker {\n                             // This is an error.\n                             let session = self.crate_context.tcx.sess;\n                             session.span_err(item.span,\n-                                             ~\"cannot associate methods with \\\n-                                               a type outside the crate the \\\n-                                               type is defined in; define \\\n-                                               and implement a trait or new \\\n-                                               type instead\");\n+                                             \"cannot associate methods with a type outside the \\\n+                                              crate the type is defined in; define and implement \\\n+                                              a trait or new type instead\");\n                         }\n                     }\n                     item_impl(_, Some(trait_ref), _, _) => {\n@@ -690,10 +683,8 @@ pub impl CoherenceChecker {\n                             if trait_def_id.crate != local_crate {\n                                 let session = self.crate_context.tcx.sess;\n                                 session.span_err(item.span,\n-                                                 ~\"cannot provide an \\\n-                                                   extension implementation \\\n-                                                   for a trait not defined \\\n-                                                   in this crate\");\n+                                                 \"cannot provide an extension implementation \\\n+                                                  for a trait not defined in this crate\");\n                             }\n                         }\n \n@@ -765,7 +756,7 @@ pub impl CoherenceChecker {\n                             None => {\n                                 self.crate_context.tcx.sess.span_bug(\n                                     original_type.span,\n-                                    ~\"resolve didn't resolve this type?!\");\n+                                    \"resolve didn't resolve this type?!\");\n                             }\n                             Some(&node_item(item, _)) => {\n                                 match item.node {\n@@ -849,8 +840,7 @@ pub impl CoherenceChecker {\n             }\n             _ => {\n                 self.crate_context.tcx.sess.span_bug(item.span,\n-                                                     ~\"can't convert a \\\n-                                                       non-impl to an impl\");\n+                                                     \"can't convert a non-impl to an impl\");\n             }\n         }\n     }\n@@ -862,9 +852,8 @@ pub impl CoherenceChecker {\n                 return item.span;\n             }\n             _ => {\n-                self.crate_context.tcx.sess.bug(~\"span_of_impl() called on \\\n-                                                  something that wasn't an \\\n-                                                  impl!\");\n+                self.crate_context.tcx.sess.bug(\"span_of_impl() called on something that \\\n+                                                 wasn't an impl!\");\n             }\n         }\n     }\n@@ -1045,17 +1034,16 @@ pub impl CoherenceChecker {\n                         match tcx.items.find(&impl_info.did.node) {\n                             Some(&ast_map::node_item(@ref item, _)) => {\n                                 tcx.sess.span_err((*item).span,\n-                                                  ~\"the Drop trait may only \\\n-                                                    be implemented on \\\n-                                                    structures\");\n+                                                  \"the Drop trait may only be implemented on \\\n+                                                   structures\");\n                             }\n                             _ => {\n-                                tcx.sess.bug(~\"didn't find impl in ast map\");\n+                                tcx.sess.bug(\"didn't find impl in ast map\");\n                             }\n                         }\n                     } else {\n-                        tcx.sess.bug(~\"found external impl of Drop trait on \\\n-                                       something other than a struct\");\n+                        tcx.sess.bug(\"found external impl of Drop trait on \\\n+                                      something other than a struct\");\n                     }\n                 }\n             }"}, {"sha": "45d61bb735728c6e3bc1a3ed406fdec23415949c", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -151,7 +151,7 @@ impl AstConv for CrateCtxt {\n \n     fn ty_infer(&self, span: span) -> ty::t {\n         self.tcx.sess.span_bug(span,\n-                               ~\"found `ty_infer` in unexpected place\");\n+                               \"found `ty_infer` in unexpected place\");\n     }\n }\n \n@@ -416,8 +416,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n         if ty_trait_refs.any(|other_trait| other_trait.def_id == trait_ref.def_id) {\n             // This means a trait inherited from the same supertrait more\n             // than once.\n-            tcx.sess.span_err(sp, ~\"Duplicate supertrait in trait \\\n-                                     declaration\");\n+            tcx.sess.span_err(sp, \"Duplicate supertrait in trait declaration\");\n             break;\n         } else {\n             ty_trait_refs.push(trait_ref);"}, {"sha": "25e65d7a18bca6ba4d5b4a3ce732c868744a192d", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -1587,19 +1587,19 @@ pub impl RegionVarBindings {\n \n                     note_and_explain_region(\n                         self.tcx,\n-                        ~\"first, the lifetime cannot outlive \",\n+                        \"first, the lifetime cannot outlive \",\n                         upper_bound.region,\n-                        ~\"...\");\n+                        \"...\");\n \n                     self.tcx.sess.span_note(\n                         upper_bound.span,\n                         fmt!(\"...due to the following expression\"));\n \n                     note_and_explain_region(\n                         self.tcx,\n-                        ~\"but, the lifetime must be valid for \",\n+                        \"but, the lifetime must be valid for \",\n                         lower_bound.region,\n-                        ~\"...\");\n+                        \"...\");\n \n                     self.tcx.sess.span_note(\n                         lower_bound.span,"}, {"sha": "0012eb700302a3af49683b6765d92bcae6fb3bbc", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -214,7 +214,7 @@ pub fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n     match tcx.def_map.find(&id) {\n       Some(&x) => x,\n       _ => {\n-        tcx.sess.span_fatal(sp, ~\"internal error looking up a definition\")\n+        tcx.sess.span_fatal(sp, \"internal error looking up a definition\")\n       }\n     }\n }\n@@ -301,8 +301,7 @@ fn check_main_fn_ty(ccx: @mut CrateCtxt,\n                         if ps.is_parameterized() => {\n                             tcx.sess.span_err(\n                                 main_span,\n-                                ~\"main function is not allowed \\\n-                                  to have type parameters\");\n+                                \"main function is not allowed to have type parameters\");\n                             return;\n                         }\n                         _ => ()\n@@ -343,8 +342,7 @@ fn check_start_fn_ty(ccx: @mut CrateCtxt,\n                         if ps.is_parameterized() => {\n                             tcx.sess.span_err(\n                                 start_span,\n-                                ~\"start function is not allowed to have type \\\n-                                parameters\");\n+                                \"start function is not allowed to have type parameters\");\n                             return;\n                         }\n                         _ => ()"}, {"sha": "db4912d2131080ef6f81a1209d866a41213bb534", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -342,7 +342,7 @@ pub fn expr_to_str(cx: @ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n \n pub fn expr_to_ident(cx: @ext_ctxt,\n                      expr: @ast::expr,\n-                     err_msg: ~str) -> ast::ident {\n+                     err_msg: &str) -> ast::ident {\n     match expr.node {\n       ast::expr_path(p) => {\n         if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {"}, {"sha": "5ae101a567cc2203053994227c0e27bcf1e076a2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b91e2f73cec610af4a2a653389562ad7cbc85e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=35b91e2f73cec610af4a2a653389562ad7cbc85e", "patch": "@@ -308,22 +308,22 @@ pub impl Parser {\n         }\n         return copy self.buffer[(*self.buffer_start + dist - 1) & 3].tok;\n     }\n-    fn fatal(&self, m: ~str) -> ! {\n+    fn fatal(&self, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(*copy self.span, m)\n     }\n-    fn span_fatal(&self, sp: span, m: ~str) -> ! {\n+    fn span_fatal(&self, sp: span, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n     }\n-    fn span_note(&self, sp: span, m: ~str) {\n+    fn span_note(&self, sp: span, m: &str) {\n         self.sess.span_diagnostic.span_note(sp, m)\n     }\n-    fn bug(&self, m: ~str) -> ! {\n+    fn bug(&self, m: &str) -> ! {\n         self.sess.span_diagnostic.span_bug(*copy self.span, m)\n     }\n-    fn warn(&self, m: ~str) {\n+    fn warn(&self, m: &str) {\n         self.sess.span_diagnostic.span_warn(*copy self.span, m)\n     }\n-    fn span_err(&self, sp: span, m: ~str) {\n+    fn span_err(&self, sp: span, m: &str) {\n         self.sess.span_diagnostic.span_err(sp, m)\n     }\n     fn abort_if_errors(&self) {\n@@ -2029,8 +2029,7 @@ pub impl Parser {\n             // This is a 'continue' expression\n             if opt_ident.is_some() {\n                 self.span_err(*self.last_span,\n-                              ~\"a label may not be used with a `loop` \\\n-                                expression\");\n+                              \"a label may not be used with a `loop` expression\");\n             }\n \n             let lo = self.span.lo;\n@@ -2167,7 +2166,7 @@ pub impl Parser {\n                     @ast::pat { node: pat_wild, _ } => (),\n                     @ast::pat { node: pat_ident(_, _, _), _ } => (),\n                     @ast::pat { span, _ } => self.span_fatal(\n-                        span, ~\"expected an identifier or `_`\"\n+                        span, \"expected an identifier or `_`\"\n                     )\n                 }\n                 slice = Some(subpat);\n@@ -2459,7 +2458,7 @@ pub impl Parser {\n                        -> ast::pat_ {\n         if !is_plain_ident(&*self.token) {\n             self.span_fatal(*self.last_span,\n-                            ~\"expected identifier, found path\");\n+                            \"expected identifier, found path\");\n         }\n         // why a path here, and not just an identifier?\n         let name = self.parse_path_without_tps();\n@@ -2478,7 +2477,7 @@ pub impl Parser {\n         if *self.token == token::LPAREN {\n             self.span_fatal(\n                 *self.last_span,\n-                ~\"expected identifier, found enum pattern\");\n+                \"expected identifier, found enum pattern\");\n         }\n \n         pat_ident(binding_mode, name, sub)\n@@ -2609,19 +2608,19 @@ pub impl Parser {\n \n             match self.parse_item_or_view_item(/*bad*/ copy item_attrs,\n                                                            false) {\n-              iovi_item(i) => {\n-                let hi = i.span.hi;\n-                let decl = @spanned(lo, hi, decl_item(i));\n-                return @spanned(lo, hi, stmt_decl(decl, self.get_id()));\n-              }\n-              iovi_view_item(vi) => {\n-                self.span_fatal(vi.span, ~\"view items must be declared at \\\n-                                           the top of the block\");\n-              }\n-              iovi_foreign_item(_) => {\n-                  self.fatal(~\"foreign items are not allowed here\");\n-              }\n-              iovi_none() => { /* fallthrough */ }\n+                iovi_item(i) => {\n+                    let hi = i.span.hi;\n+                    let decl = @spanned(lo, hi, decl_item(i));\n+                    return @spanned(lo, hi, stmt_decl(decl, self.get_id()));\n+                }\n+                iovi_view_item(vi) => {\n+                    self.span_fatal(vi.span,\n+                                    \"view items must be declared at the top of the block\");\n+                }\n+                iovi_foreign_item(_) => {\n+                    self.fatal(~\"foreign items are not allowed here\");\n+                }\n+                iovi_none() => { /* fallthrough */ }\n             }\n \n             check_expected_item(self, item_attrs);\n@@ -2822,8 +2821,7 @@ pub impl Parser {\n                         result.push(RegionTyParamBound);\n                     } else {\n                         self.span_err(*self.span,\n-                                      ~\"`'static` is the only permissible \\\n-                                        region bound here\");\n+                                      \"`'static` is the only permissible region bound here\");\n                     }\n                     self.bump();\n                 }\n@@ -3238,7 +3236,7 @@ pub impl Parser {\n                     })\n                 }\n                 _ => {\n-                    self.span_err(*self.span, ~\"not a trait\");\n+                    self.span_err(*self.span, \"not a trait\");\n                     None\n                 }\n             };\n@@ -3467,9 +3465,8 @@ pub impl Parser {\n             ) {\n               iovi_item(item) => items.push(item),\n               iovi_view_item(view_item) => {\n-                self.span_fatal(view_item.span, ~\"view items must be \\\n-                                                  declared at the top of the \\\n-                                                  module\");\n+                self.span_fatal(view_item.span, \"view items must be  declared at the top of the \\\n+                                                 module\");\n               }\n               _ => {\n                 self.fatal(\n@@ -3762,7 +3759,7 @@ pub impl Parser {\n         }\n \n         if opt_abis.is_some() {\n-            self.span_err(*self.span, ~\"an ABI may not be specified here\");\n+            self.span_err(*self.span, \"an ABI may not be specified here\");\n         }\n \n         // extern mod foo;\n@@ -4397,9 +4394,7 @@ pub impl Parser {\n                         view_item_extern_mod(*)\n                         if !extern_mod_allowed => {\n                             self.span_err(view_item.span,\n-                                          ~\"\\\"extern mod\\\" \\\n-                                            declarations are not \\\n-                                            allowed here\");\n+                                          \"\\\"extern mod\\\" declarations are not allowed here\");\n                         }\n                         view_item_extern_mod(*) => {}\n                     }\n@@ -4425,8 +4420,7 @@ pub impl Parser {\n                     iovi_none => break,\n                     iovi_view_item(view_item) => {\n                         self.span_err(view_item.span,\n-                                      ~\"`use` and `extern mod` declarations \\\n-                                        must precede items\");\n+                                      \"`use` and `extern mod` declarations must precede items\");\n                     }\n                     iovi_item(item) => {\n                         items.push(item)\n@@ -4461,8 +4455,7 @@ pub impl Parser {\n                 iovi_view_item(view_item) => {\n                     // I think this can't occur:\n                     self.span_err(view_item.span,\n-                                  ~\"`use` and `extern mod` declarations \\\n-                                    must precede items\");\n+                                  \"`use` and `extern mod` declarations must precede items\");\n                 }\n                 iovi_item(_) => {\n                     // FIXME #5668: this will occur for a macro invocation:"}]}